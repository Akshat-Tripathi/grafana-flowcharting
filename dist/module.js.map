{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./globals_class.ts","webpack:///../node_modules/tslib/tslib.es6.js","webpack:///external \"lodash\"","webpack:///../node_modules/pako/lib/utils/common.js","webpack:///../node_modules/chroma-js/chroma.js","webpack:///external \"app/plugins/sdk\"","webpack:///../node_modules/chartist/dist/chartist.js","webpack:///../node_modules/pako/lib/zlib/messages.js","webpack:///external \"app/core/utils/kbn\"","webpack:///external \"@grafana/data\"","webpack:///./drawio_custom.js","webpack:///../node_modules/pako/lib/zlib/adler32.js","webpack:///../node_modules/pako/lib/zlib/crc32.js","webpack:///../node_modules/pako/lib/utils/strings.js","webpack:///../node_modules/pako/lib/zlib/zstream.js","webpack:///../node_modules/pako/lib/zlib/constants.js","webpack:///external \"app/core/time_series2\"","webpack:///external \"app/core/app_events\"","webpack:///./utils_raw.js","webpack:///../node_modules/pako/index.js","webpack:///../node_modules/pako/lib/deflate.js","webpack:///../node_modules/pako/lib/zlib/deflate.js","webpack:///../node_modules/pako/lib/zlib/trees.js","webpack:///../node_modules/pako/lib/inflate.js","webpack:///../node_modules/pako/lib/zlib/inflate.js","webpack:///../node_modules/pako/lib/zlib/inffast.js","webpack:///../node_modules/pako/lib/zlib/inftrees.js","webpack:///../node_modules/pako/lib/zlib/gzheader.js","webpack:///../node_modules/vkbeautify/index.js","webpack:///../node_modules/safe-eval/index.js","webpack:///../node_modules/vm-browserify/index.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./grafana_func.ts","webpack:///./rule_class.ts","webpack:///./mapping_options.ts","webpack:///./graph_class.ts","webpack:///./mxgraph_custom.js","webpack:///./flowchart_options.ts","webpack:///./inspect_options.ts","webpack:///./rulesHandler.ts","webpack:///./tooltipHandler.ts","webpack:///./state_class.ts","webpack:///./statesHandler.ts","webpack:///./flowchart_class.ts","webpack:///./flowchartHandler.ts","webpack:///./metric_class.ts","webpack:///./metricHandler.ts","webpack:///./flowchart_ctrl.ts","webpack:///./module.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","GFVariables","this","_variables","Map","set","Array","from","keys","$GF","getGrafanaVars","concat","getVarsNames","map","x","clear","text","templateSrv","getVar","CONSTANTS","VAR_OBJ_TEMPLATESRV","undefined","replaceWithText","replace","error","replaceText","utils","evalIt","LOCALVARIABLENAMES","GFLog","args","toDisplay","DEBUG","title","shift","console","debug","WARN","warn","INFO","info","ERROR","level","logDisplay","logLevel","GFPlugin","url","data","links","forEach","link","version","VAR_STG_CTXROOT","getLibsPath","getRootPath","getDrawioPath","getMxBasePath","$scope","dashboard","plug","contextRoot","defaultContextRoot","__dirname","length","setVar","$root","appSubUrl","VAR_OBJ_DASHBOARD","GFMessage","parent","container","querySelector","span","message","document","createElement","appendChild","type","INFO_MESSAGE","innerHTML","ERROR_MESSAGE","WARNING_MESSAGE","style","color","INFO_COLOR","ERROR_COLOR","WARNING_COLOR","display","setUniqTimeOut","clearMessage","CONF_GFMESSAGE_MS","clearUniqTimeOut","parentDiv","GFTrace","fn","enable","trace","Name","Id","uniqueID","Args","Return","Before","Date","now","End","ExecTime","Indent","indent","trc","_inc","after","tb","TotalTimes","push","table","f","Calls","Function","plugin","init","log","html","_globalvars","variables","variable","getGlobalVars","unset","getAvailableLocalVarNames","begin","end","count","result","distance","step","Math","round","current","index","fc","timer","id","timeout","VAR_MAP_TIMEOUT","thread","window","setTimeout","toString","tm","clearTimeout","interval","VAR_MAP_INTERVAL","clearUniqInterval","setInterval","clearInterval","varName","fileName","contextroot","filePath","fetch","then","response","ok","txt","loadFile","timestamp","isGraphHoverEnabled","graphHover","GHTimeStamp","sharedTooltipModeEnabled","hasGraphHover","tagBook","tagImage","getRepo","images","textEncoded","String","desc","book","image","CONF_PATH_LIBS","CONF_PATH_DRAWIO","CONF_PATH_STATIC","CONF_PATH_PARTIALS","CONF_PATH_STYLES","CONF_FILE_PLUGINJSON","CONF_FILE_DEFAULTDIO","CONF_FILE_DEFAULTCSV","CONF_FILE_SHAPESTXT","CONF_FILE_APPJS","CONF_FILE_SHAPESJS","CONF_FILE_VIEWERJS","CONF_FILE_PRECONFIGJS","CONF_FILE_POSTCONFIGJS","CONF_TOOLTIPS_DELAY","CONF_GRAPHHOVER_DELAY","CONF_COLORS_STEPS","CONF_COLORS_MS","CONF_ANIMS_STEP","CONF_ANIMS_MS","CONF_BLINK_COLOR","VAR_STG_SHAPES","VAR_TBL_SHAPES","VAR_STR_VIEWERJS","VAR_STR_SHAPESJS","VAR_NUM_GHTIMESTAMP","VAR_OBJ_CTRL","VAR_STR_RULENAME","VAR_NUM_LEVEL","VAR_NUM_VALUE","VAR_STR_FORMATED","VAR_STR_COLOR","FLOWCHART_CHG_SOURCES","FLOWCHART_CHG_OPTIONS","FLOWCHART_APL_OPTIONS","FLOWCHART_CHG_DATAS","FLOWCHART_CHG_RULES","FLOWCHART_CHG_GRAPHHOVER","FLOWCHART_CHG_HIDDENCHANGE","TOOLTIP_APPLYON","COLOR_APPLYON","TEXT_APPLYON","LINK_APPLYON","VALUE_TYPES","METRIC_TYPES","SOURCE_TYPES","DIOTHEME_TYPES","IDENT_TYPES","AGGREGATION_TYPES","TOOLTIP_GRAPH_TYPES","TOOLTIP_GRAPH_SCALE_TYPES","TOOLTIP_GRAPH_SIZE_TYPES","TOOLTIP_DIRECTION_TYPES","VALUE_DATEFORMAT_TYPES","VALUEMAPPINGTYPES","TEXTMETHODS","placeholder","COLORMETHODS","EVENTMETHODS","default","typeahead","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","next","e","rejected","done","apply","__WEBPACK_EXTERNAL_MODULE__2__","TYPED_OK","Uint8Array","Uint16Array","Int32Array","_has","obj","assign","sources","slice","arguments","source","TypeError","shrinkBuf","buf","size","subarray","fnTyped","arraySet","dest","src","src_offs","len","dest_offs","flattenChunks","chunks","pos","chunk","fnUntyped","setTyped","on","Buf8","Buf16","Buf32","limit","min","max","classToType","list","toLowerCase","PI","clip_rgb","rgb","_clipped","_unclipped","unpack","keyOrder","split","filter","k","last","TWOPI","PITHIRD","DEG2RAD","RAD2DEG","input","format","autodetect","last$1","clip_rgb$1","type$1","Color","me","constructor","sorted","sort","a","b","chk","test","Error","_rgb","hex","join","Color_1","chroma","chroma_1","unpack$1","rgb2cmyk_1","ref","g","y","unpack$2","cmyk2rgb_1","alpha","unpack$3","type$2","cmyk","unpack$4","last$2","rnd","hsl2css_1","hsla","unpack$5","rgb2hsl_1","h","Number","NaN","unpack$6","last$3","rgb2css_1","rgba","substr","unpack$7","round$1","hsl2rgb_1","t3","t2","t1","h_","RE_RGB","RE_RGBA","RE_RGB_PCT","RE_RGBA_PCT","RE_HSL","RE_HSLA","round$2","css2rgb","css","trim","named","match","rgb$1","i$1","rgb$2","i$2","rgb$3","i$3","hsl","rgb$4","hsl$1","rgb$5","css2rgb_1","type$3","rest","unpack$8","gl","unpack$9","rgb2hcg_1","delta","_g","unpack$a","floor","hcg2rgb_1","assign$1","assign$2","assign$3","assign$4","assign$5","_c","q","v","unpack$b","type$4","hcg","unpack$c","last$4","round$3","rgb2hex_1","u","str","hxa","RE_HEX","RE_HEXA","hex2rgb_1","parseInt","u$1","type$5","indexOf","unpack$d","sqrt","acos","rgb2hsi_1","min_","unpack$e","limit$1","TWOPI$1","cos","hsi2rgb_1","isNaN","unpack$f","type$6","hsi","unpack$g","type$7","unpack$h","min$1","max$1","rgb2hsv","max_","unpack$i","floor$1","hsv2rgb_1","unpack$j","type$8","hsv","labConstants","unpack$k","pow","rgb_xyz","xyz_lab","rgb2xyz","rgb2lab_1","ref$1","z","unpack$l","pow$1","xyz_rgb","lab_xyz","lab2rgb_1","unpack$m","type$9","lab","unpack$n","sqrt$1","atan2","round$4","lab2lch_1","unpack$o","rgb2lch_1","b_","unpack$p","sin","cos$1","lch2lab_1","unpack$q","lch2rgb_1","L","unpack$r","hcl2rgb_1","hcl","reverse","unpack$s","type$a","lch","w3cx11_1","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflower","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","laserlemon","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrod","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","maroon2","maroon3","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","purple2","purple3","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","type$b","unpack$t","rgb2num_1","type$c","num2rgb_1","num","type$d","unpack$u","type$e","round$5","temperature2rgb_1","kelvin","temp","unpack$v","round$6","rgb2temperature_1","minTemp","maxTemp","eps","temperature","type$f","mutate","clipped","darken","amount","brighten","darker","brighter","mc","channel","type$g","pow$2","luminance","lum","cur_lum","max_iter","low","high","mid","interpolate","lm","abs","rgb2luminance","luminance_x","interpolator","type$h","mix","col1","col2","premultiply","saturate","desaturate","type$i","charAt","out","xyz0","xyz1","sqrt$2","pow$3","lrgb","x1","y1","z1","x2","y2","z2","_hsx","hue0","hue1","sat0","sat1","lbv0","lbv1","sat","hue","lch$1","c1","c2","clip_rgb$2","pow$4","sqrt$3","PI$1","cos$2","sin$1","atan2$1","_average_lrgb","colors","weights","xyz","col","type$j","pow$5","scale","_mode","_nacol","_spread","_domain","_pos","_padding","_classes","_colors","_out","_min","_max","_correctLightness","_colorCache","_useCache","_gamma","setColors","brewer","c$1","resetCache","tMapLightness","tMapDomain","getColor","val","bypassMap","getClass","classes","analyze","limits","domain","tOut","tBreaks","every","_m","range","_o","spread","correctLightness","L0","L1","pol","L_actual","L_ideal","L_diff","t0","padding","numColors","dm","dd","__range__","samples","asc","cache","gamma","nodata","left","right","inclusive","ascending","bezier","I","lab0","lab1","lab2","lab3","I0","I1","blend","bottom","top","blend_f","c0","each","normal","multiply","screen","overlay","lighten","dodge","burn","blend_1","type$k","clip_rgb$3","TWOPI$2","pow$6","sin$2","cos$3","floor$2","random","log$1","pow$7","floor$3","MAX_VALUE","sum","values","min_log","LOG10E","max_log","pb","pr","cluster","assignments","clusterSizes","repeat","nb_iters","centroids","j","i$4","mindist","best","j$1","dist","newCentroids","j$2","i$5","j$3","j$4","kClusters","j$5","i$6","tmpKMeansBreaks","j$6","i$7","analyze_1","sqrt$4","atan2$2","abs$1","cos$4","PI$2","scales","cool","hot","colorbrewer","OrRd","PuBu","BuPu","Oranges","BuGn","YlOrBr","YlGn","Reds","RdPu","Greens","YlGnBu","Purples","GnBu","Greys","YlOrRd","PuRd","Blues","PuBuGn","Viridis","Spectral","RdYlGn","RdBu","PiYG","PRGn","RdYlBu","BrBG","RdGy","PuOr","Set2","Accent","Set1","Set3","Dark2","Paired","Pastel2","Pastel1","list$1","colorbrewer_1","average","reduce","w","first","cnt","dx","dy","A","ci","xyz2","A$1","cubehelix","start","rotations","lightness","dl","dh","fract","amp","cos_a","sin_a","code","contrast","l1","l2","deltaE","C","a1","b1","L2","a2","b2","sl","sc","h1","c4","sh","delC","delA","delB","v1","v2","sum_sq","valid","factory","__WEBPACK_EXTERNAL_MODULE__5__","root","Chartist","globalRoot","namespaces","svg","xmlns","xhtml","xlink","ct","noop","alphaNumerate","fromCharCode","extend","target","sourceProp","prop","replaceAll","subStr","newSubStr","RegExp","ensureUnit","unit","quantity","exec","query","Node","times","previous","mapMultiply","factor","mapAdd","addend","serialMap","arr","cb","roundWithPrecision","digits","precision","escapingMap","'","serialize","JSON","stringify","deserialize","parse","createSvg","width","height","className","querySelectorAll","getAttributeNS","removeChild","Svg","attr","addClass","_node","normalizeData","multi","labelCount","output","raw","normalized","series","getDataArray","labels","reverseData","safeHasProperty","isDataHoleValue","recursiveConvert","multiValue","getNumberOrUndefined","normalizePadding","fallback","getMetaData","meta","orderOfMagnitude","LN10","projectLength","axisLength","bounds","getAvailableHeight","options","chartPadding","axisX","offset","getHighLow","dimension","highLow","toUpperCase","findHigh","findLow","recursiveHighLow","referenceValue","isNumeric","isFinite","isFalseyButZero","isMultiValue","getMultiValue","rho","gcd","divisor","getBounds","scaleMinSpace","onlyInteger","newMin","newMax","optimizationCounter","valueRange","oom","ceil","numberOfSteps","scaleUp","smallestFactor","safeIncrement","increment","polarToCartesian","centerX","centerY","radius","angleInDegrees","angleInRadians","createChartRect","fallbackPadding","hasAxis","axisY","yAxisOffset","xAxisOffset","normalizedPadding","chartRect","position","createGrid","axis","group","eventEmitter","positionalData","units","counterUnits","gridElement","elem","emit","element","createGridBackground","gridGroup","gridBackground","createLabel","axisOffset","labelOffset","useForeignObject","labelElement","content","setAttribute","innerText","foreignObject","getSeriesOption","seriesOptions","optionsProvider","responsiveOptions","currentOptions","baseOptions","mediaQueryListeners","updateCurrentOptions","mediaEvent","previousOptions","matchMedia","matches","mql","addListener","removeMediaQueryListeners","removeListener","getCurrentOptions","splitIntoSegments","pathCoordinates","valueData","increasingX","fillHoles","segments","hole","global","Interpolation","none","path","Path","currX","currY","currData","move","line","simple","prevX","prevY","prevData","curve","cardinal","tension","paths","segment","iLen","monotoneCubic","xs","ys","ms","ds","dys","dxs","postpone","EventEmitter","handlers","addEventHandler","event","handler","removeEventHandler","splice","starHandler","listToArray","Class","properties","superProtoOverride","superProto","proto","cloneDefinitions","constr","instance","super","getOwnPropertyNames","propName","getOwnPropertyDescriptor","initialize","addEventListener","resizeListener","update","plugins","createChart","initializeTimeoutId","Base","defaultOptions","supportsForeignObject","isSupported","supportsAnimations","__chartist__","detach","override","removeEventListener","off","attributes","insertFirst","Element","createElementNS","firstChild","insertBefore","getAttribute","namespacedAttribute","setAttributeNS","parentNode","SVGElement","node","nodeName","selector","foundNode","foundNodes","List","getNode","fnObj","createTextNode","empty","remove","newElement","replaceChild","append","names","self","removeClass","removedClasses","removeAllClasses","getBoundingClientRect","animate","animations","guided","attribute","createAnimate","animationDefinition","easing","attributeProperties","Easing","dur","calcMode","keySplines","keyTimes","fill","attributeName","beginElement","err","to","params","feature","implementation","hasFeature","easeInSine","easeOutSine","easeInOutSine","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInBack","easeOutBack","easeInOutBack","nodeList","svgElements","prototypeProperty","elementDescriptions","accuracy","command","pathElements","relative","pathElement","forEachParam","pathElementIndex","paramName","paramIndex","close","arc","rx","ry","xAr","lAf","sf","translate","transform","transformFnc","transformed","pop","elements","description","spliceArgs","accuracyMultiplier","clone","splitByCommand","joinedPath","axisUnits","dir","rectStart","rectEnd","rectOffset","Axis","ticks","gridOffset","createGridAndLabels","labelGroup","chartOptions","axisOptions","projectedValues","projectValue","labelValues","labelInterpolationFnc","projectedValue","labelLength","showGrid","classNames","grid","showLabel","label","AutoScaleAxis","axisUnit","FixedScaleAxis","stepLength","StepAxis","calc","stretch","showLine","showPoint","showArea","areaBase","lineSmooth","showGridBackground","fullWidth","chart","point","area","vertical","horizontal","Line","seriesGroup","seriesIndex","seriesElement","pathData","valueIndex","seriesMeta","areaBaseProjected","pathSegment","solidPathSegments","firstElement","lastElement","areaPath","seriesBarDistance","stackBars","stackMode","horizontalBars","distributeSeries","bar","Bar","serialSums","prev","curr","valueAxis","labelAxisTicks","labelAxis","zeroPoint","stackedBarValues","periodHalfLength","biPol","projected","previousStack","labelAxisValueIndex","positions","metaData","chartPie","chartDonut","slicePie","sliceDonut","sliceDonutSolid","startAngle","total","donut","donutSolid","donutWidth","labelPosition","labelDirection","ignoreEmptyValues","determineAnchorPosition","center","direction","toTheRight","Pie","labelsGroup","labelRadius","totalDataSum","seriesGroups","previousValue","currentValue","hasSingleValInSeries","endAngle","overlappigStartAngle","innerStart","innerEnd","donutSolidRadius","pathClassName","strokeWidth","rawValue","interpolatedValue","2","1","0","__WEBPACK_EXTERNAL_MODULE__8__","__WEBPACK_EXTERNAL_MODULE__9__","executeLayout","graph","post","isEnabled","getModel","beginUpdate","endUpdate","executeLayoutList","layoutList","cells","getSelectionCells","layout","config","execute","getDefaultParent","csvToArray","m0","m1","m2","m3","importCsv","lines","allCells","dups","lookups","styles","stylename","labelname","parentstyle","identity","namespace","edgespacing","nodespacing","levelspacing","afterInsert","view","getGraphBounds","pt","getFreeInsertPoint","x0","y0","edges","ignore","substring","mxUtils","idx","sanitizeHtml","parseFloat","mxResources","identityIndex","parentIndex","attribs","arrays","short","model","cell","getCell","exists","newCell","mxCell","mxGeometry","vertex","setAttributeForCell","tempLabel","labelChanged","tempStyle","replacePlaceholders","setGeometry","geometry","setStyle","setLinkForCell","fireEvent","mxEventObject","getPreferredSizeForCell","addCell","roots","select","edge","insertEdge","realCell","dataCell","tmp","refs","fromlabel","tolabel","placeholders","invert","createCurrentEdgeStyle","edgeLayout","mxParallelEdgeLayout","spacing","postProcess","geo","getCellGeometry","snap","validate","circleLayout","mxCircleLayout","resetEdges","circleLayoutIsVertexIgnored","isVertexIgnored","treeLayout","mxCompactTreeLayout","levelDistance","edgeRouting","flowLayout","mxHierarchicalLayout","mxConstants","DIRECTION_WEST","DIRECTION_NORTH","intraCellSpacing","parallelEdgeSpacing","interRankCellSpacing","disableEdgeStyle","moveCells","organicLayout","mxFastOrganicLayout","forceConstant","organicLayoutIsVertexIgnored","anonymize","div","anonymizeString","zeros","anonymizeHtml","replaceTextContent","elt","nodeValue","nodeType","NODETYPE_ELEMENT","nextSibling","queue","getLabel","isHtmlLabel","setValue","addExtFont","fontName","fontUrl","dontRemember","fontId","getElementById","Editor","GOOGLE_FONTS","mxClient","getElementsByTagName","extFonts","notFound","adler","s1","s2","crcTable","makeTable","crc","STR_APPLY_OK","STR_APPLY_UIA_OK","__","_utf8len","buf2binstring","string2buf","m_pos","str_len","buf_len","charCodeAt","binstring2buf","buf2string","c_len","utf16buf","utf8border","next_in","avail_in","total_in","next_out","avail_out","total_out","msg","state","data_type","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_BINARY","Z_TEXT","Z_UNKNOWN","Z_DEFLATED","__WEBPACK_EXTERNAL_MODULE__16__","__WEBPACK_EXTERNAL_MODULE__17__","pako","require","vkbeautify","safeEval","stringToBytes","bytesToString","encode","deflate","base64","encodeURIComponent","deflateRaw","btoa","removeLinebreaks","isencoded","parseXml","documentElement","decode","diagrams","getTextContent","atob","inflateRaw","decodeURIComponent","xml","DOMParser","parseFromString","createXmlDocument","async","loadXML","doc","createDocument","ActiveXObject","decodeFromUri","textContent","normalizeXml","sleep","mess","delay","chr4","stringToJsRegex","matchString","pattern","regex","minify","xmlmin","prettify","prettifyJSON","json","addScript","loadJS","fname","evalRaw","req","load","getStatus","getText","$loadFile","$","ajax","success","$evalFile","eval","getfileContent","request","zlib_deflate","strings","ZStream","Deflate","method","chunkSize","windowBits","memLevel","strategy","opt","gzip","ended","strm","status","deflateInit2","header","deflateSetHeader","dictionary","dict","deflateSetDictionary","_dict_set","deflator","onEnd","onData","deflateEnd","configuration_table","trees","adler32","crc32","errorCode","rank","zero","flush_pending","pending","pending_buf","pending_out","flush_block_only","_tr_flush_block","block_start","strstart","put_byte","putShortMSB","longest_match","cur_match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","more","_w_size","window_size","hash_size","head","wrap","insert","ins_h","hash_shift","hash_mask","deflate_fast","flush","hash_head","bflush","match_length","_tr_tally","max_lazy_match","MIN_MATCH","last_lit","deflate_slow","max_insert","prev_match","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","DeflateState","pending_buf_size","gzhead","gzindex","last_flush","w_bits","hash_bits","dyn_ltree","HEAP_SIZE","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","MAX_BITS","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","bi_buf","bi_valid","deflateResetKeep","_tr_init","deflateReset","ret","max_block_size","max_start","deflateInit","old_flush","beg","hcrc","extra","comment","time","os","bstate","deflate_huff","deflate_rle","_tr_align","_tr_stored_block","avail","tmpDict","dictLength","deflateInfo","extra_lbits","extra_dbits","extra_blbits","bl_order","static_ltree","static_dtree","D_CODES","_dist_code","_length_code","MAX_MATCH","base_length","static_l_desc","static_d_desc","static_bl_desc","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","put_short","send_bits","send_code","tree","bi_reverse","res","gen_codes","bits","next_code","init_block","LITERALS","END_BLOCK","bi_windup","smaller","_n2","_m2","pqdownheap","compress_block","ltree","dtree","lc","lx","build_tree","stree","xbits","base","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","stored_len","copy_block","LENGTH_CODES","L_CODES","tr_static_init","opt_lenb","static_lenb","max_blindex","black_mask","detect_data_type","BL_CODES","build_bl_tree","lcodes","dcodes","blcodes","send_all_trees","STATIC_TREES","bi_flush","zlib_inflate","GZheader","Inflate","inflateInit2","inflateGetHeader","inflateSetDictionary","inflate","inflator","next_out_utf8","tail","utf8str","allowBufError","inflateEnd","ungzip","inflate_fast","inflate_table","zswap32","InflateState","havedict","flags","dmax","check","wbits","wsize","whave","wnext","hold","lencode","distcode","lenbits","distbits","ncode","nlen","ndist","have","lens","work","lendyn","distdyn","sane","back","was","inflateResetKeep","inflateReset","inflateReset2","lenfix","distfix","virgin","fixedtables","sym","updatewindow","copy","inflateInit","put","_in","from_source","here_bits","here_op","here_val","last_bits","last_op","last_val","opts","here","hbuf","order","inf_leave","xflags","extra_len","inflateInfo","s_window","lcode","dcode","lmask","dmask","op","dolen","dodist","lbase","lext","dbase","dext","lens_index","codes","table_index","incr","mask","drop","used","huff","base_index","MAXBITS","offs","extra_index","createShiftArr","space","ix","isSubquery","parenthesisLevel","split_sql","tab","ar","inComment","deep","search","sql","ar_by_quote","preserveComments","jsonmin","cssmin","sqlmin","vm","context","sandbox","resultKey","runInNewContext","item","Object_keys","defineProp","writable","configurable","globals","Context","Script","runInContext","iframe","body","win","contentWindow","wEval","wExecScript","execScript","winKeys","runInThisContext","ctx","createContext","isContext","createScript","formatValue","decimals","valueFormats","getUnitFormats","loadCss","dark","light","getTimeSeries","seriesData","datapoints","alias","getFormatedDate","appEvents","MetricsPanelCtrl","PanelEvents","shapeMaps","textMaps","linkMaps","eventMaps","valueMaps","rangeMaps","removeClick","highestLevel","highestColor","highestFormattedValue","highestValue","execTimes","states","before","metricType","refId","column","aggregation","colorOn","linkUrl","linkParams","linkOn","textOn","textReplace","textPattern","dateFormat","thresholds","stringThresholds","stringWarning","stringCritical","gradient","overlayIcon","tooltip","tooltipLabel","tooltipColors","tooltipOn","tpDirection","tpGraph","tpGraphSize","tpGraphType","tpGraphLow","tpGraphHigh","tpGraphScale","maps","shapeProp","shapeRegEx","shapeData","addShapeMap","textProp","textRegEx","textData","addTextMap","linkProp","linkRegEx","linkData","addLinkMap","eventProp","eventRegEx","eventData","addEventMap","mappingType","addValueMap","rangeData","addRangeMap","sanitize","highlightCell","unhighlightCell","hidden","invertColorOrder","colorStart","colorEnd","metric","getName","ShapeMap","getDefaultData","found","LinkMap","getDefaultdata","RangeMap","hide","show","toFixed","getThresholdLevel","getColorForLevel","cursor","absoluteDistance","ratio","thresholdLevel","formatedValue","getFormattedValue","matchMetric","getValue","formattedValue","getValueForMetric","decimalPlaces","isArray","getFormattedText","$sanitize","escape","methods","find","FormattedValue","regexVal","location","ph","EventMap","getDefaultPlaceHolder","getFullAvailableVarNames","shapes","getFormNames","vbd","getDefaultValue","eventOn","shapesText","isString","EventType","getDefaultMethods","propTypes","metricTypes","dateFormats","aggregationTypes","mappingTypes","editor","ctrl","panel","rulesHandler","flowchartHandler","metricHandler","unitFormats","getMetricNames","getNames","getCellNames","flowchart","getFlowchart","getNamesByProp","uniq","Set","getCellNamesById","getCellNamesByValue","getVariables","getEventValues","isTypeOf","rule","isOnlyTables","isOnlySeries","tableName","getColumnsName","countRules","render","subItem","onRulesChange","lvl","shape","getShapeMap","unselectCell","removeShapeMap","getTextMap","removeTextMap","lnk","getLinkMap","removeLinkMap","evt","getEventMap","removeEventMap","ruleIndex","colorIndex","newColor","getRule","xgraph","getXGraph","selectMxCells","unselectMxCells","bool","highlightCells","unhighlightCells","force","removeRule","cloneRule","up","moveRuleToUp","moveRuleToDown","getTypeahead","mappingOptionsTab","$q","uiSegmentSrv","restrict","scope","templateUrl","getPartialPath","controller","definition","xmlGraph","csvGraph","lock","animation","zoom","zoomFactor","cumulativeZoomFactor","bgColor","zoomPercent","onMapping","active","XGraph","initMxGraph","initGraph","mxEvent","CLICK","_sender","_evt","eventDebug","getState","Graph","xmlDoc","codec","mxCodec","destroy","myWindow","initialized","mxGraph","preInitGlobalVars","mxTooltipHandler","tip","destroyed","isNode","$div","place_tt","visibility","fit","addGestureListeners","hideTooltip","getTooltipForCell","hasTips","isReplacePlaceholders","ttDiv","ignored","builtInProperties","attrs","attrDiv","attrString","isCustomLink","htmlEntities","GF_tooltipHandler","getDiv","addMouseWheelListener","IS_FF","detail","wheelDelta","IS_NS","documentMode","IS_GC","IS_SF","postInitGlobalVars","BASE_PATH","RESOURCES_PATH","getMxResourcePath","RESOURCE_BASE","STENCIL_PATH","getStencilsPath","SHAPES_PATH","getShapesPath","IMAGE_PATH","getMxImagePath","STYLE_PATH","getMxStylePath","CSS_PATH","getMxCssPath","mxLanguages","DRAWIO_BASE_URL","DRAW_MATH_URL","DRAWIO_VIEWER_URL","DRAWIO_CONFIG","urlParams","mxImageBasePath","mxBasePath","mxLoadStylesheets","mxLanguage","mxLoadResources","VSD_CONVERT_URL","EMF_CONVERT_URL","ICONSEARCH_PATH","compress","decompress","setPanning","clickBackup","click","dbclickBackup","dblClick","eventMouseWheel","IS_IE","IS_EDGE","eventKey","preventDefault","eventDbClick","loadExtFont","updateCssTransform","selectUnlockedLayer","refresh","setMessage","getCurrentCells","ef","parts","unzoomGraph","zoomGraph","tooltipGraph","lockGraph","fitGraph","scaleGraph","centerGraph","gridGraph","bgGraph","foldingEnabled","cellRenderer","forceControlClickHandler","setEnabled","setTooltips","mxUrlConverter","baseUrl","baseDomain","centerZoom","rendering","cw","clientWidth","ch","clientHeight","scaleAndTranslate","backgroundImage","percent","zoomTo","zoomActual","drawGraph","cellIds","mxcell","getId","getLabelCell","mxcells","getMxCells","findMxCells","mxCellOverlay","alert","addCellOverlay","createOverlay","warningImage","removeCellOverlays","getLinkForCell","oldId","newId","getXml","isAnimated","startColor","getStyleCell","endColor","steps","lg","graduate","setStyleCell","setCellStyles","endValue","beginValue","getIntervalCounter","currentClass","includes","STYLE_DASHED","removeAttribute","cellLabelChanged","onMappingObj","eventClick","$applyAsync","getValuePropOfMxCell","focus","unsetMap","lazyZoomCell","isZoomWheelEvent","deltaY","rect","clientX","clientY","lazyZoomPointer","consume","isConsumed","keyCode","applyGraph","offsetX","offsetY","highlight","sw","STYLE_STROKEWIDTH","hl","mxCellHighlight","opacity","setPrefixedStyle","blink","bl_on","blink_on","blink_ms","bl_off","isCellCollapsed","isCollapsedCell","foldCells","collapse","isVisibleCell","setVisible","isVisible","origine","getGeometry","_x","_ow","_y","_oh","_w","_h","_rec","mxRectangle","steps_x","steps_y","steps_w","steps_h","resizeCell","mxgeo","rec","isVertex","boundingBox","zoomToRect","sourceTypes","themes","errorSourceFlag","errorSourceMsg","errorDownloadFlag","errorDownloadMsg","editMode","newName","currentFlowchartName","currentFlowchart","getCurrentFlowchartName","onSourceChange","onOptionsChange","isValidXml","addFlowchart","getFlowchartTmpName","setCurrentFlowchart","getCurrentFlowchart","removeFlowchart","canceled","fcs","getFlowchartNames","setName","statusText","openDrawEditor","getFlowcharts","flowcharts","flowchartOptionsTab","$sce","traceEnable","getStates","columns","stateHandler","getStateHandler","newcellId","cellId","edited","previousId","edit","draw","renameId","applyModel","getStatesForInspect","orderBy","getTextLevel","getCellProp","disable","xg","inspectOptionsTab","activeRuleIndex","rules","rulesData","tmpRules","sortBy","ruleData","addRule","setOrder","newRule","getOrder","getData","newData","getRules","TooltipHandler","timeFormat","checked","metrics","add","currentDateTime","lastChange","getFullYear","getMonth","toLocaleString","minimumIntegerDigits","useGrouping","getDate","getHours","getMinutes","getSeconds","getDateDiv","mxObjectId","graphs","getTextDiv","getGraphsDiv","GraphTooltip","scaleType","chartistOptions","seq","delays","durations","changed","matched","globalLevel","tooltipHandler","shapeState","tooltipState","iconState","IconState","eventState","textState","linkState","createLocalVars","originalText","applyState","isHidden","beginPerf","getShapeMaps","getTextMaps","getLinkMaps","getEventMaps","getColorForValue","cellProp","toColorize","toTooltipize","setTooltip","toIconize","toLabelize","textScoped","getReplaceText","getMatchValue","toEventable","toLinkable","getLink","endPerf","has","isEdge","reset","prepare","matchedKey","changedKey","originalValue","matchValue","matchLevel","init_core","hasKey","GFState","DEFAULTLEVEL","default_core","getOriginalValue","defaultValue","addValue","isMatched","apply_core","isChanged","getLevel","reset_core","getSizeCell","_get","_set","toUnset","newkey","startsWith","unsetClassCell","setClassCell","setLabelCell","hideCell","showCell","collapseCell","expandCell","changeSizeCell","resetSizeCell","setStyleAnimCell","blinkCell","unblinkCell","geBlinkMxCell","addLink","removeLink","setColorAnimCell","tpColor","metricToolip","addMetric","setLabel","setColor","setDirection","addGraph","setColumn","setMetric","setSize","setScaling","setScale","updateDate","isChecked","addOverlay","removeOverlay","initStates","addState","matchShape","matchText","matchLink","matchEvent","getStatesForRule","setState","async_applyState","applyStates","visible","getDefaultDioGraph","csv","getDefaultCsvGraph","download","allowDrawio","enableAnim","editorUrl","editorTheme","unsetState","getContent","setOptions","setStates","setCenter","setGrid","setLock","setZoom","setBgColor","setContent","destroyGraph","toBack","getOrignalCells","replaceVarBool","getCsv","loadContent","getSource","getXmlModel","redraw","getContainer","setMap","scrollIntoView","forceRefresh","applyOptions","firstLoad","datas","hiddenChange","newMode","sequenceNumber","mousedownTimeout","mousedown","onEdit","postedId","editorWindow","FlowchartHandler","$elem","main","events","onmousedown","onmouseup","defaultXml","defaultCsv","tmpFc","fcData","countFlowcharts","toFront","cf","margin","touchAction","border","createContainer","flagChange","isFlagedChange","getFlagNames","getMetrics","async_refreshStates","aknowledgeFlagChange","renderingCompleted","refreshStates","updateStates","reload","objToMap","getFlowchartById","postMessage","origin","$apply","listenMessage","urlEditor","getUrlEditor","theme","getThemeEditor","open","dataList","nullPointMode","aggregator","seriesHandler","addCustomStats","flotpairs","getFlotPairs","stats","getGraphHover","findValue","middle","log10","tableColumnOptions","tableColumn","allIsNull","allIsZero","tableHandler","tableData","columnNames","columnIndex","timeIndex","timeColumn","setTableColumnToSensibleDefault","rows","row","datapoint","fillStyle","ignoreNulls","nullAsZero","currName","logmin","avg","current_notnull","first_notnull","diff","timeStep","currentTime","nonNulls","previousTime","previousDeltaUp","isNumber","last_time","tables","addTable","addSerie","serie","metricName","findMetrics","$injector","$rootScope","GHApplied","getVersion","changedSource","changedData","changedOptions","panelDefaults","newFlag","valueName","flowchartsData","defaults","graphId","containerDivId","onRender","onRefresh","dataReceived","onDataReceived","dataError","onDataError","dataSnapshotLoad","editModeInitialized","onInitEditMode","onGraphHover","clearCrosshair","onVarChanged","addEditorTab","setGraphHover","onGraphHoverChange","unsetGraphHover","initData","onDatasChange","resume","setMessageDiv","newRulesData","newFlowchartsData"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 33);\n","import _ from 'lodash';\nclass GFCONSTANT {\n  // CONFIG\n  CONF_PATH_LIBS = 'libs/';\n  CONF_PATH_DRAWIO = 'libs/drawio/';\n  CONF_PATH_STATIC = 'static/';\n  CONF_PATH_PARTIALS = 'partials/';\n  CONF_PATH_STYLES = 'styles/';\n  CONF_FILE_PLUGINJSON = './plugin.json';\n  CONF_FILE_DEFAULTDIO = 'static/defaultGraph.drawio';\n  CONF_FILE_DEFAULTCSV = 'static/defaultGraph.csv';\n  CONF_FILE_SHAPESTXT = 'static/shapes.txt';\n  CONF_FILE_APPJS = 'libs/drawio/js/app.min.js';\n  CONF_FILE_SHAPESJS = 'libs/drawio/js/shapes.min.js';\n  CONF_FILE_VIEWERJS = 'libs/drawio/js/viewer.min.js';\n  CONF_FILE_PRECONFIGJS = 'libs/drawio/js/PreConfig.js';\n  CONF_FILE_POSTCONFIGJS = 'libs/drawio/js/PostConfig.js';\n  CONF_TOOLTIPS_DELAY = 200;\n  CONF_GRAPHHOVER_DELAY = 50;\n  CONF_COLORS_STEPS = 5;\n  CONF_COLORS_MS = 50;\n  CONF_ANIMS_STEP = 5;\n  CONF_ANIMS_MS = 50;\n  CONF_GFMESSAGE_MS = 5000;\n  CONF_BLINK_COLOR = '#f5f242';\n\n  // GLOBAL VARIABLE\n  VAR_STG_SHAPES = 'shapestext';\n  VAR_TBL_SHAPES = 'shapesarray';\n  VAR_STR_VIEWERJS = 'viewer.min.js';\n  VAR_STR_SHAPESJS = 'shapes.min.js';\n  VAR_STG_CTXROOT = 'contextroot';\n  VAR_NUM_GHTIMESTAMP = 'graph-hover-timestamp';\n  VAR_OBJ_TEMPLATESRV = 'templatesrv';\n  VAR_OBJ_CTRL = 'ctrl';\n  VAR_OBJ_DASHBOARD = 'dashboard';\n  VAR_MAP_INTERVAL = 'interval';\n  VAR_MAP_TIMEOUT = 'timeout';\n  VAR_STR_RULENAME: gf.TVariableKeys = '_rule';\n  VAR_NUM_LEVEL: gf.TVariableKeys = '_level';\n  VAR_NUM_VALUE: gf.TVariableKeys = '_value';\n  VAR_STR_FORMATED: gf.TVariableKeys = '_formated';\n  VAR_STR_COLOR: gf.TVariableKeys = '_color';\n\n  // FLOWCHART CHANGE KEY FLAG\n  FLOWCHART_CHG_SOURCES: gf.TFlowchartFlagKeys = 'sources';\n  FLOWCHART_CHG_OPTIONS: gf.TFlowchartFlagKeys = 'options';\n  FLOWCHART_APL_OPTIONS: gf.TFlowchartFlagKeys = 'applyOptions';\n  FLOWCHART_CHG_DATAS: gf.TFlowchartFlagKeys = 'datas';\n  FLOWCHART_CHG_RULES: gf.TFlowchartFlagKeys = 'rules';\n  FLOWCHART_CHG_GRAPHHOVER: gf.TFlowchartFlagKeys = 'graphHover';\n  FLOWCHART_CHG_HIDDENCHANGE: gf.TFlowchartFlagKeys = 'hiddenChange';\n\n  // CONDITIONS\n  TOOLTIP_APPLYON: gf.TTooltipOnList = [\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Always', value: 'a' },\n  ];\n  COLOR_APPLYON: gf.TColorOnList = [\n    { text: 'Never', value: 'n' },\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Always', value: 'a' },\n  ];\n  TEXT_APPLYON: gf.TTextOnList = [\n    { text: 'Never', value: 'n' },\n    { text: 'When Metric Displayed', value: 'wmd' },\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Critical Only', value: 'co' },\n  ];\n  LINK_APPLYON: gf.TLinkOnList = [\n    { text: 'Warning / Critical', value: 'wc' },\n    { text: 'Always', value: 'a' },\n  ];\n\n  // TYPES\n  VALUE_TYPES: gf.TValueTypeList = [\n    { text: 'Number', value: 'number' },\n    { text: 'String', value: 'string' },\n    { text: 'Date', value: 'date' },\n  ];\n  METRIC_TYPES: gf.TMetricTypeList = [\n    { text: 'Series', value: 'serie' },\n    { text: 'Table', value: 'table' },\n  ];\n  SOURCE_TYPES: gf.TSourceTypeList = [\n    { text: 'XML', value: 'xml' },\n    { text: 'CSV', value: 'csv' },\n  ];\n  DIOTHEME_TYPES: gf.TDioThemeList = [\n    { text: 'Dark', value: 'dark' },\n    { text: 'Light', value: 'kennedy' },\n    { text: 'Mobile', value: 'minimal' },\n    { text: 'atlas', value: 'atlas' },\n  ];\n  IDENT_TYPES: { text: string; value: gf.TPropertieKey }[] = [\n    { text: 'Id', value: 'id' },\n    { text: 'Label', value: 'value' },\n  ];\n  AGGREGATION_TYPES: gf.TAggregationList = [\n    { text: 'First', value: 'first' },\n    { text: 'First (not null)', value: 'first_notnull' },\n    { text: 'Last', value: 'current' },\n    { text: 'Last (not null)', value: 'current_notnull' },\n    { text: 'Min', value: 'min' },\n    { text: 'Max', value: 'max' },\n    { text: 'Sum', value: 'total' },\n    { text: 'Avg', value: 'avg' },\n    { text: 'Count', value: 'count' },\n    { text: 'Delta', value: 'delta' },\n    { text: 'Range', value: 'range' },\n    { text: 'Diff', value: 'diff' },\n    { text: 'Time of last point', value: 'last_time' },\n  ];\n  TOOLTIP_GRAPH_TYPES: gf.TGraphTypeList = [\n    { text: 'Line', value: 'line' },\n    { text: 'Histogram', value: 'bar' },\n  ];\n  TOOLTIP_GRAPH_SCALE_TYPES: gf.TGraphScaleList = [\n    { text: 'Linear', value: 'linear' },\n    { text: 'Logarithmic', value: 'log' },\n  ];\n  TOOLTIP_GRAPH_SIZE_TYPES: gf.TGraphSizeList = [\n    { text: 'Adjustable', value: '100%' },\n    { text: 'Small', value: '100px' },\n    { text: 'Medium', value: '200px' },\n    { text: 'Large', value: '400px' },\n  ];\n  TOOLTIP_DIRECTION_TYPES: gf.TDirectionList = [\n    { text: 'Vertical', value: 'v' },\n    { text: 'Horizontal ', value: 'h' },\n  ];\n  VALUE_DATEFORMAT_TYPES: gf.TDateFormatList = [\n    { text: 'YYYY-MM-DD HH:mm:ss', value: 'YYYY-MM-DD HH:mm:ss' },\n    { text: 'YYYY-MM-DD HH:mm:ss.SSS', value: 'YYYY-MM-DD HH:mm:ss.SSS' },\n    { text: 'MM/DD/YY h:mm:ss a', value: 'MM/DD/YY h:mm:ss a' },\n    { text: 'MMMM D, YYYY LT', value: 'MMMM D, YYYY LT' },\n    { text: 'YYYY-MM-DD', value: 'YYYY-MM-DD' },\n  ];\n\n  VALUEMAPPINGTYPES: gf.TValueMappingList = [\n    { text: 'Value to text', value: 1 },\n    { text: 'Range to text', value: 2 },\n  ];\n\n  // METHODS\n  TEXTMETHODS: gf.TTextMethodList = [\n    { text: 'All content', value: 'content' },\n    { text: 'Substring', value: 'pattern', placeholder: '/RegEx/' },\n    { text: 'Append (Space) ', value: 'as' },\n    { text: 'Append (New line) ', value: 'anl' },\n  ];\n  COLORMETHODS: gf.TStyleColorList = [\n    { text: 'Shape Stroke/Border', value: 'strokeColor' },\n    { text: 'Shape Fill', value: 'fillColor' },\n    { text: 'Shape Gradient', value: 'gradientColor' },\n    { text: 'Label font color', value: 'fontColor' },\n    { text: 'Label background color', value: 'labelBackgroundColor' },\n    { text: 'Label border color', value: 'labelBorderColor' },\n    { text: 'Image background', value: 'imageBackground' },\n    { text: 'Image border', value: 'imageBorder' },\n  ];\n  EVENTMETHODS: gf.TStyleEventList = [\n    { text: 'Shape : Change form (text)', value: 'shape', type: 'text', placeholder: 'Shape name' },\n    { text: 'Shape : Rotate Shape (0-360)', value: 'rotation', type: 'number', placeholder: '0-360', default: 0 },\n    { text: 'Shape : Blink (frequence ms)', value: 'blink', type: 'number', placeholder: 'Number in ms', default: 500 },\n    { text: 'Shape : Hide/Show (0|1)', value: 'visibility', type: 'number', placeholder: '0 or 1', typeahead: '0|1' },\n    { text: 'Shape : Height (number)', value: 'height', type: 'number', placeholder: 'Number of px' },\n    { text: 'Shape : Width (number)', value: 'width', type: 'number', placeholder: 'Number of px' },\n    { text: 'Shape : Resize (percent)', value: 'size', type: 'number', placeholder: 'percent' },\n    { text: 'Shape : Opacity (0-100)', value: 'opacity', type: 'number', placeholder: '0-100', default: 100 },\n    {\n      text: 'Shape : Gradient direction',\n      value: 'gradientDirection',\n      type: 'text',\n      placeholder: 'Direction name',\n      default: 'south',\n      typeahead: 'south|east|north|west',\n    },\n    {\n      text: 'Shape : Collapse/Expande (0|1)',\n      value: 'fold',\n      type: 'number',\n      placeholder: '0 or 1',\n      typeahead: '0|1',\n      default: '1',\n    },\n    { text: 'Shape : Change position in Bar (0-100)', value: 'barPos', type: 'number', placeholder: '0-100' },\n    {\n      text: 'Shape : Flip horizontally (0|1)',\n      value: 'flipH',\n      type: 'number',\n      placeholder: '0 or 1',\n      typeahead: '0|1',\n    },\n    { text: 'Shape : Flip vertically (0|1)', value: 'flipV', type: 'number', placeholder: '0 or 1', typeahead: '0|1' },\n    {\n      text: 'Arrow : change start marker (text)',\n      value: 'startArrow',\n      type: 'text',\n      placeholder: 'Marker',\n      typeahead:\n        'none|classic|classicThin|block|blockThin|open|openThin|oval|diamond|diamondThin|openAsync|async|box|halfCircle|dash|cross|circlePlus|circle|ERone|ERmandOne|ERoneToMany|ERzeroToOne',\n    },\n    {\n      text: 'Arrow : change end marker (text)',\n      value: 'endArrow',\n      type: 'text',\n      placeholder: 'Marker',\n      typeahead:\n        'none|classic|classicThin|block|blockThin|open|openThin|oval|diamond|diamondThin|openAsync|async|box|halfCircle|dash|cross|circlePlus|circle|ERone|ERmandOne|ERoneToMany|ERzeroToOne',\n    },\n    {\n      text: 'Arrow : Anime flow (frequence ms)',\n      value: 'class_mxEdgeFlow',\n      type: 'number',\n      placeholder: 'Number in ms',\n    },\n    { text: 'Label : Replace text (text)', value: 'text', type: 'text', placeholder: 'Text' },\n    { text: 'Label : Font Size (numeric)', value: 'fontSize', type: 'number', placeholder: 'Number' },\n    { text: 'Label : Opacity (numeric)', value: 'textOpacity', type: 'number', placeholder: '0-100', default: 100 },\n    { text: 'Image : Change URL (text)', value: 'image', type: 'text', placeholder: 'Url' },\n  ];\n\n  LOCALVARIABLENAMES: gf.TVariableList = [\n    { text: 'Name of the rule', value: this.VAR_STR_RULENAME },\n    { text: 'Current color according to the thresholds', value: this.VAR_STR_COLOR },\n    { text: 'Current raw value according to the aggregation', value: this.VAR_NUM_VALUE },\n    { text: 'Current level according to the thresholds', value: this.VAR_NUM_LEVEL },\n    { text: 'Current formated value accordingto the type', value: this.VAR_STR_FORMATED },\n  ];\n}\n\nexport class GFVariables {\n  _variables: Map<string, any>;\n  constructor() {\n    this._variables = new Map();\n  }\n\n  /**\n   * Get the full available vars names\n   *\n   * @static\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  static getAvailableLocalVarNames(): string[] {\n    return $GF.CONSTANTS.LOCALVARIABLENAMES.map(x => '${' + x.value + '}');\n  }\n\n  /**\n   * set or redefine varaible\n   *\n   * @param {string} key\n   * @param {*} value\n   * @returns {this}\n   * @memberof GFVariables\n   */\n  set(key: gf.TVariableKeys, value: any): this {\n    this._variables.set(key, value);\n    return this;\n  }\n\n  unset(key: gf.TVariableKeys): this {\n    this._variables.delete(key);\n    return this;\n  }\n\n  /**\n   * Get variable value\n   *\n   * @param {string} key\n   * @returns {*}\n   * @memberof GFVariables\n   */\n  get(key: gf.TVariableKeys): any {\n    return this._variables.get(key);\n  }\n\n  /**\n   * Return the name of variables without ${}\n   *\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  keys(): string[] {\n    return Array.from(this._variables.keys());\n  }\n\n  /**\n   * Return all local declared variables and grafana variables\n   *\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  getFullVarsNames(): string[] {\n    return $GF.getGrafanaVars().concat(this.getVarsNames());\n  }\n\n  /**\n   * Get the full names of declared local vars\n   *\n   * @returns {string[]}\n   * @memberof GFVariables\n   */\n  getVarsNames(): string[] {\n    return this.keys().map(x => '${' + x + '}');\n  }\n\n  /**\n   * Clear all variables\n   *\n   * @returns {this}\n   * @memberof GFVariables\n   */\n  clear(): this {\n    this._variables.clear();\n    return this;\n  }\n\n  /**\n   * Replace text with variables\n   *\n   * @param {string} text\n   * @returns {string}\n   * @memberof GFVariables\n   */\n  replaceText(text: string): string {\n    try {\n      let templateSrv = $GF.getVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV);\n      text = templateSrv !== undefined ? templateSrv.replaceWithText(text) : text;\n      for (let [key, value] of this._variables) {\n        text = text.replace('${' + key + '}', value);\n      }\n    } catch (error) {\n      return text;\n    }\n    return text;\n  }\n\n  /**\n   * Replace and eval text with variables\n   *\n   * @param {string} text\n   * @returns {string}\n   * @memberof GFVariables\n   */\n  eval(text: string): string {\n    let t = this.replaceText(text);\n    return $GF.utils.evalIt(t);\n  }\n}\n\nclass GFLog {\n  static DEBUG = 0;\n  static INFO = 1;\n  static WARN = 2;\n  static ERROR = 3;\n  static logLevel = GFLog.WARN;\n  static logDisplay = true;\n  constructor() {}\n\n  static init(): GFLog {\n    return new GFLog();\n  }\n\n  /**\n   * If message must be displayed\n   *\n   * @param {number} level (DEBUG : 0, INFO : 1, WARN:2, ERROR:3)\n   * @returns {boolean}\n   * @memberof Log\n   */\n  static toDisplay(level: number): boolean {\n    if (GFLog.logDisplay !== undefined && GFLog.logDisplay === true) {\n      if (GFLog.logLevel !== undefined && level >= GFLog.logLevel) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Display debug message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async debug(...args) {\n    if (GFLog.toDisplay(GFLog.DEBUG)) {\n      const title = args.shift();\n      console.debug(`GF DEBUG : ${title}`, ...args);\n    }\n  }\n\n  /**\n   * Display warn message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async warn(...args) {\n    if (GFLog.toDisplay(GFLog.WARN)) {\n      const title = args.shift();\n      console.warn(`GF WARN : ${title}`, ...args);\n    }\n  }\n\n  /**\n   * Display info message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async info(...args) {\n    if (GFLog.toDisplay(GFLog.INFO)) {\n      const title = args.shift();\n      console.info(`GF INFO : ${title}`, ...args);\n    }\n  }\n\n  /**\n   * Display error message in console\n   *\n   * @param {string} title\n   * @param {((any | undefined))} obj\n   * @memberof Log\n   */\n  async error(...args) {\n    if (GFLog.toDisplay(GFLog.ERROR)) {\n      const title = args.shift();\n      console.error(`GF ERROR : ${title}`, ...args);\n    }\n  }\n}\n\nclass GFPlugin {\n  static data: any = require('./plugin.json');\n  static defaultContextRoot = '/public/plugins/agenty-flowcharting-panel/';\n  static contextRoot: string;\n  constructor() {}\n\n  /**\n   * init GFPlugin\n   *\n   * @static\n   * @param {*} $scope\n   * @param {*} templateSrv\n   * @returns {GFPlugin}\n   * @memberof GFPlugin\n   */\n  static init($scope: any, templateSrv: any, dashboard: any): GFPlugin {\n    let plug = new GFPlugin();\n    this.contextRoot = GFPlugin.defaultContextRoot;\n    if ($scope === undefined) {\n      this.contextRoot = __dirname;\n      if (this.contextRoot.length > 0) {\n        $GF.setVar($GF.CONSTANTS.VAR_STG_CTXROOT, this.contextRoot);\n      }\n    } else {\n      this.contextRoot = $scope.$root.appSubUrl + this.defaultContextRoot;\n    }\n    $GF.setVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV, templateSrv);\n    $GF.setVar($GF.CONSTANTS.VAR_STG_CTXROOT, this.contextRoot);\n    $GF.setVar($GF.CONSTANTS.VAR_OBJ_DASHBOARD, dashboard);\n    return plug;\n  }\n\n  getRepo(): string {\n    let url = '';\n    GFPlugin.data.info.links.forEach((link: { name: string; url: string }) => {\n      if (link.name === 'Documentation') {\n        url = link.url;\n      }\n    });\n    return url;\n  }\n\n  /**\n   * Get version of plugin\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getVersion(): string {\n    return GFPlugin.data.info.version;\n  }\n\n  /**\n   * Get root path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getRootPath(): string {\n    return $GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT);\n  }\n\n  /**\n   * Get libs path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getLibsPath(): string {\n    return `${$GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT)}libs/`;\n  }\n\n  /**\n   * Get Draw.io libs path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getDrawioPath(): string {\n    return `${this.getLibsPath()}drawio/`;\n  }\n\n  /**\n   * Get statics path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getStaticPath(): string {\n    return `${this.getRootPath()}static/`;\n  }\n\n  /**\n   * Get mxBasePath\n   * mxBasePath: Specifies the path in mxClient.basePath.\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getMxBasePath(): string {\n    return `${this.getDrawioPath()}mxgraph/`;\n  }\n\n  /**\n   * Return Style path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getMxStylePath(): string {\n    return `${this.getDrawioPath()}styles/`;\n  }\n\n  /**\n   * Return shapes xml path for draw.io\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getShapesPath(): string {\n    return `${this.getDrawioPath()}/shapes/`;\n  }\n\n  /**\n   * Return partial path\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getPartialPath(): string {\n    return `${this.getRootPath()}partials/`;\n  }\n\n  /**\n   * Return stencils js path for draw.io\n   *\n   * @returns {string}\n   * @memberof GFPlugin\n   */\n  getStencilsPath(): string {\n    return `${this.getDrawioPath()}/stencils/`;\n  }\n\n  getMxCssPath(): string {\n    return `${this.getDrawioPath()}styles/`;\n  }\n\n  getMxResourcePath(): string {\n    return `${this.getMxBasePath()}css/`;\n  }\n\n  getMxImagePath(): string {\n    return `${this.getMxBasePath()}images/`;\n  }\n}\n\nclass GFMessage {\n  static container: HTMLDivElement;\n  static message: HTMLSpanElement;\n  static ERROR_MESSAGE = 'error';\n  static ERROR_COLOR = 'red';\n  static INFO_MESSAGE = 'info';\n  static INFO_COLOR = 'white';\n  static WARNING_MESSAGE = 'warning';\n  static WARNING_COLOR = 'yellow';\n\n  constructor(parent: HTMLElement) {\n    const container = parent.querySelector<HTMLDivElement>('div#flowcharting-message');\n    if (container !== null) {\n      GFMessage.container = container;\n      const span = container.querySelector<HTMLSpanElement>('#message-text');\n      if (span === null) {\n        GFMessage.message = document.createElement('span');\n        GFMessage.container.appendChild(GFMessage.message);\n      } else {\n        GFMessage.message = span;\n      }\n    }\n  }\n\n  static init(parentDiv: HTMLElement): GFMessage {\n    return new GFMessage(parentDiv);\n  }\n\n  async setMessage(message: string, type: string = GFMessage.INFO_MESSAGE) {\n    if (GFMessage.container && GFMessage.message) {\n      GFMessage.message.innerHTML = message;\n      switch (type) {\n        case GFMessage.INFO_MESSAGE:\n          GFMessage.message.style.color = GFMessage.INFO_COLOR;\n          break;\n        case GFMessage.ERROR_MESSAGE:\n          GFMessage.message.style.color = GFMessage.ERROR_COLOR;\n          break;\n        case GFMessage.WARNING_MESSAGE:\n          GFMessage.message.style.color = GFMessage.WARNING_COLOR;\n          break;\n\n        default:\n          GFMessage.message.style.color = GFMessage.INFO_COLOR;\n          break;\n      }\n      GFMessage.container.style.display = '';\n      $GF.setUniqTimeOut(this.clearMessage, $GF.CONSTANTS.CONF_GFMESSAGE_MS, 'flowcharting-message');\n    }\n  }\n\n  clearMessage() {\n    if (GFMessage.container && GFMessage.message) {\n      GFMessage.container.style.display = 'none';\n      GFMessage.message.innerHTML = '';\n    }\n    $GF.clearUniqTimeOut('flowcharting-message');\n  }\n}\n\n/**\n * Trace Perf class\n *\n * @class GFTrace\n */\nclass GFTrace {\n  static enable = false;\n  static trc = new Map();\n  static fn = new Map();\n  static indent = 0;\n  trace:\n    | {\n        Name: string;\n        Id: string;\n        Args: any;\n        Return: any;\n        Before: number;\n        End: number | undefined;\n        ExecTime: number | undefined;\n        Indent: number;\n      }\n    | undefined;\n\n  constructor(fn?: string) {\n    if (GFTrace.enable && fn !== undefined) {\n      this.trace = {\n        Name: fn,\n        Id: $GF.utils.uniqueID(),\n        Args: undefined,\n        Return: undefined,\n        Before: Date.now(),\n        End: undefined,\n        ExecTime: undefined,\n        Indent: GFTrace.indent,\n      };\n      GFTrace.trc.set(this.trace.Id, this.trace);\n    }\n  }\n\n  static init(): GFTrace {\n    return new GFTrace();\n  }\n\n  before(\n    fn: string | undefined\n  ):\n    | GFTrace\n    | {\n        after: () => void;\n      } {\n    if (GFTrace.enable && fn !== undefined) {\n      const t = new GFTrace(fn);\n      GFTrace.indent++;\n      GFTrace._inc(fn);\n      return t;\n    }\n    return { after: () => {} };\n  }\n\n  static _inc(fn) {\n    let f = GFTrace.fn.get(fn);\n    if (f === undefined) {\n      f = {\n        Calls: 0,\n        Function: fn,\n        TotalTimes: 0,\n      };\n    }\n    f.Calls++;\n    GFTrace.fn.set(fn, f);\n  }\n\n  async after() {\n    if (GFTrace.enable && this.trace !== undefined) {\n      if (this.trace) {\n        this.trace.End = Date.now();\n        GFTrace.indent--;\n      }\n    }\n  }\n\n  async clear() {\n    if (GFTrace.enable) {\n      GFTrace.trc.clear();\n      GFTrace.fn.clear();\n    }\n  }\n\n  enable() {\n    GFTrace.enable = true;\n  }\n\n  disable() {\n    GFTrace.enable = false;\n  }\n\n  isEnabled() {\n    return GFTrace.enable;\n  }\n\n  async resume() {\n    if (GFTrace.enable) {\n      let tb: any[] = [];\n      let fn: any[] = [];\n      GFTrace.trc.forEach(trace => {\n        trace.ExecTime = trace.End - trace.Before;\n        const f = GFTrace.fn.get(trace.Name);\n        f.TotalTimes += trace.ExecTime;\n        tb.push(trace);\n      });\n      console.table(tb, ['Indent', 'Name', 'ExecTime']);\n      GFTrace.fn.forEach(f => {\n        fn.push(f);\n      });\n      console.table(fn, ['Function', 'Calls', 'TotalTimes']);\n      this.clear();\n    }\n  }\n}\n\nexport class $GF {\n  static _globalvars: GFVariables = new GFVariables();\n  static CONSTANTS: GFCONSTANT = new GFCONSTANT();\n  static log: GFLog = GFLog.init();\n  static trace: GFTrace = GFTrace.init();\n  static message: GFMessage;\n  static plugin: GFPlugin;\n  static graphHover = false;\n  static GHTimeStamp = 0;\n  static DEBUG = false;\n  static utils: {\n    decode: (data: string, encode: boolean, deflate: boolean, base64: boolean) => string;\n    encode: (data: string, encode: boolean, deflate: boolean, base64: boolean) => string;\n    loadJS: (fname: string) => void;\n    sleep: (ms: number, mess?: string) => void;\n    uniqueID: () => string;\n    // getRatioColor: (ratio: number, colorStart: string, colorEnd: string) => string;\n    matchString: (str: string, pattern: string | undefined, regex?: boolean) => boolean;\n    stringToJsRegex: (str: string) => RegExp;\n    isencoded: (data: string) => boolean;\n    minify: (text: string) => string;\n    prettify: (text: string) => string;\n    getMarky: () => any;\n    // getStepColors: (colorStart: string, colorEnd: string, colorCount: number) => string[];\n    evalIt: (code: string) => string;\n    loadFile: (fname: string) => string;\n    $loadFile: (fname: string) => string;\n    $evalFile: (fname: string) => void;\n    evalRaw: (code: string) => void;\n    addScript: (src: string) => void;\n  } = require('./utils_raw');\n\n  static init($scope: any, templateSrv: any, dashboard: any): $GF {\n    this.plugin = GFPlugin.init($scope, templateSrv, dashboard);\n    if (this.DEBUG) {\n      console.log('DEBUG Scope', $scope);\n      console.log('DEBUG TemplateSrv', templateSrv);\n      console.log('DEBUG Theme', dashboard.style);\n      console.log('DEBUG dashboard', dashboard);\n    }\n    return this;\n  }\n\n  static me(): $GF {\n    return this;\n  }\n\n  /**\n   * Recover Meassage div in module.html\n   *\n   * @static\n   * @param {HTMLElement} html\n   * @memberof $GF\n   */\n  static setMessageDiv(html: HTMLElement) {\n    this.message = GFMessage.init(html);\n  }\n\n  /**\n   * Return the theme\n   *\n   * @static\n   * @returns {string}\n   * @memberof $GF\n   */\n  static getTheme(): string {\n    let templateSrv = $GF.getVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV);\n    let theme = templateSrv !== undefined ? templateSrv.style : 'dark';\n    return theme;\n  }\n\n  /**\n   * Create and get local variables container\n   *\n   * @static\n   * @returns {GFVariables}\n   * @memberof GFGlobal\n   */\n  static createLocalVars(): GFVariables {\n    let _v = new GFVariables();\n    return _v;\n  }\n\n  /**\n   * Get global variables container\n   *\n   * @static\n   * @returns {GFVariables}\n   * @memberof GFGlobal\n   */\n  static getGlobalVars(): GFVariables {\n    if ($GF._globalvars === undefined) {\n      $GF._globalvars = new GFVariables();\n    }\n    return $GF._globalvars;\n  }\n\n  static getGrafanaVars(): string[] {\n    const templateSrv = $GF.getVar($GF.CONSTANTS.VAR_OBJ_TEMPLATESRV);\n    if (templateSrv !== undefined && templateSrv !== null) {\n      return _.map(templateSrv.variables, variable => `\\${${variable.name}}`);\n    }\n    return [];\n  }\n\n  /**\n   * Get global variable value\n   *\n   * @static\n   * @param {*} key\n   * @returns {*}\n   * @memberof GFGlobal\n   */\n  static getVar(key: any): any {\n    return $GF.getGlobalVars().get(key);\n  }\n\n  /**\n   * set global variable with value\n   *\n   * @static\n   * @param {*} key\n   * @param {*} value\n   * @memberof GFGlobal\n   */\n  static setVar(key: any, value: any) {\n    $GF.getGlobalVars().set(key, value);\n  }\n\n  static unsetVar(key: any) {\n    $GF.getGlobalVars().unset(key);\n  }\n\n  /**\n   * Get all available variables name\n   *\n   * @static\n   * @returns {string[]}\n   * @memberof GFGlobal\n   */\n  static getFullAvailableVarNames(): string[] {\n    return GFVariables.getAvailableLocalVarNames().concat($GF.getGrafanaVars());\n  }\n\n  static getIntervalCounter(begin: number, end: number, count: number, method: gf.TCounterKeys = 'linear'): number[] {\n    let result: number[] = [];\n    const distance = end - begin;\n    const step = Math.round(distance / count);\n    let current = begin;\n    let index = 0;\n    for (index = 0; index < count; index++) {\n      current += step;\n      result.push(current);\n    }\n    result[index] = end;\n    return result;\n  }\n\n  static setUniqTimeOut(fc: CallableFunction, timer: number, id?: string): string {\n    let timeout: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_TIMEOUT);\n    if (timeout === undefined) {\n      timeout = new Map();\n      $GF.setVar($GF.CONSTANTS.VAR_MAP_TIMEOUT, timeout);\n    }\n    if (id !== undefined) {\n      this.clearUniqTimeOut(id);\n    }\n    const thread = window.setTimeout(fc, timer);\n    id = id === undefined ? thread.toString() : id;\n    timeout.set(id, thread);\n    return id;\n  }\n\n  static clearUniqTimeOut(id: string) {\n    const timeout: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_TIMEOUT);\n    if (timeout !== undefined) {\n      try {\n        const tm = timeout.get(id);\n        if (tm !== undefined) {\n          timeout.delete(id);\n          window.clearTimeout(tm);\n        }\n      } catch (error) {\n        $GF.log.warn('Failed to clear timeout thread', id, error);\n      }\n    }\n  }\n\n  /**\n   * Add a new Intervall (window.setInterval)\n   *\n   * @static\n   * @param {CallableFunction} fc\n   * @param {number} timer\n   * @returns {number}\n   * @memberof GFGlobal\n   */\n  static setUniqInterval(fc: CallableFunction, timer: number, id?: string): string {\n    let interval: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_INTERVAL);\n    if (interval === undefined) {\n      interval = new Map();\n      $GF.setVar($GF.CONSTANTS.VAR_MAP_INTERVAL, interval);\n    }\n    if (id !== undefined) {\n      this.clearUniqInterval(id);\n    }\n    const thread = window.setInterval(fc, timer);\n    id = id === undefined ? thread.toString() : id;\n    interval.set(id, thread);\n    return id;\n  }\n\n  /**\n   * Add/clear a  Intervall (window.clearInterval)\n   *\n   * @static\n   * @param {string} id\n   * @memberof GFGlobal\n   */\n  static clearUniqInterval(id: string) {\n    let interval: Map<string, number> = $GF.getVar($GF.CONSTANTS.VAR_MAP_INTERVAL);\n    if (interval !== undefined) {\n      try {\n        const int = interval.get(id);\n        interval.delete(id);\n        window.clearInterval(int);\n      } catch (error) {\n        $GF.log.warn('Failed to clear interval thread', id, error);\n      }\n    }\n  }\n\n  /**\n   * Load a file into variables\n   *\n   * @static\n   * @param {string} varName\n   * @param {string} fileName\n   * @memberof GFGlobal\n   */\n  static async loadLocalFile(varName: string, fileName: string) {\n    let v = $GF.getVar(varName);\n    if (v === undefined) {\n      const contextroot = $GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT);\n      if (contextroot !== undefined) {\n        const filePath = `${contextroot}/${fileName}`;\n        if (!!window.fetch) {\n          // exécuter ma requête fetch ici\n          fetch(filePath)\n            .then(response => {\n              if (response.ok) {\n                response\n                  .text()\n                  .then(text => {\n                    $GF.log.info('loadLocalFile called succesfully', filePath);\n                    $GF.setVar(varName, text);\n                    return text;\n                  })\n                  .catch(error => $GF.log.error('Error when download text file', filePath, error));\n              }\n            })\n            .catch(error => $GF.log.error('Error when download file', filePath, error));\n        } else {\n          // Faire quelque chose avec XMLHttpRequest?\n          const txt = $GF.utils.loadFile(fileName);\n          if (txt) {\n            $GF.setVar(varName, $GF.utils.loadFile(fileName));\n            return txt;\n          }\n        }\n      } else {\n        $GF.log.warn('loadLocalFile Contexroot : ', contextroot);\n      }\n    }\n    return false;\n  }\n\n  static setGraphHover(timestamp: number) {\n    if (this.isGraphHoverEnabled()) {\n      this.graphHover = true;\n      this.GHTimeStamp = timestamp;\n    }\n  }\n\n  static unsetGraphHover() {\n    this.graphHover = false;\n    this.GHTimeStamp = 0;\n  }\n\n  static hasGraphHover(): boolean {\n    return this.graphHover && this.isGraphHoverEnabled();\n  }\n\n  static isGraphHoverEnabled(): boolean {\n    const dashboard = this.getVar($GF.CONSTANTS.VAR_OBJ_DASHBOARD);\n    return dashboard !== undefined && dashboard.sharedTooltipModeEnabled();\n  }\n\n  static getGraphHover(): number | undefined {\n    if (this.hasGraphHover()) {\n      // return this.getVar($GF.CONSTANTS.VAR_NUM_GHTIMESTAMP);\n      return this.GHTimeStamp;\n    }\n    return undefined;\n  }\n\n  /**\n   * Return Html for popup with links to documentation\n   *\n   * @param {string} text\n   * @param {string} tagBook\n   * @param {string} [tagImage]\n   * @returns {string}\n   * @memberof $GF\n   */\n  static popover(text: string, tagBook: string, tagImage?: string): string {\n    const url = $GF.plugin.getRepo();\n    const images = `${this.plugin.getRepo()}images/`;\n    const textEncoded = String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;');\n    const desc = `${textEncoded}`;\n    let book = '';\n    let image = '';\n    if (tagBook) {\n      book = `<a href=\"${url}${tagBook}\" target=\"_blank\"><i class=\"fa fa-book fa-fw\"></i>Help</a>`;\n    }\n    if (tagImage) {\n      image = `<a href=\"${images}${tagImage}.png\" target=\"_blank\"><i class=\"fa fa-image fa-fw\"></i>Example</a>`;\n    }\n    return `\n    <div id=\"popover\" style=\"display:flex;flex-wrap:wrap;width: 100%;\">\n      <div style=\"flex:1;height:100px;margin-bottom: 20px;\">${desc}</div>\n      <div style=\"flex:1;height:100px;margin-bottom: 20px;\">${book}</div>\n      <div style=\"flex-basis: 100%;height:100px;margin-bottom:20px;\">${image}</div>\n    </div>`;\n  }\n\n  static destroy() {\n    let interval: Set<any> = $GF.getVar($GF.CONSTANTS.VAR_MAP_INTERVAL);\n    if (interval !== undefined) {\n      interval.forEach(x => $GF.clearUniqInterval(x));\n      interval.clear();\n    }\n    let timeout: Set<any> = $GF.getVar($GF.CONSTANTS.VAR_MAP_TIMEOUT);\n    if (timeout !== undefined) {\n      timeout.forEach(x => $GF.clearUniqTimeOut(x));\n      timeout.clear();\n    }\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2019, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.chroma = factory());\n}(this, (function () { 'use strict';\n\n    var limit = function (x, min, max) {\n        if ( min === void 0 ) min=0;\n        if ( max === void 0 ) max=1;\n\n        return x < min ? min : x > max ? max : x;\n    };\n\n    var clip_rgb = function (rgb) {\n        rgb._clipped = false;\n        rgb._unclipped = rgb.slice(0);\n        for (var i=0; i<=3; i++) {\n            if (i < 3) {\n                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }\n                rgb[i] = limit(rgb[i], 0, 255);\n            } else if (i === 3) {\n                rgb[i] = limit(rgb[i], 0, 1);\n            }\n        }\n        return rgb;\n    };\n\n    // ported from jQuery's $.type\n    var classToType = {};\n    for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\n        var name = list[i];\n\n        classToType[(\"[object \" + name + \"]\")] = name.toLowerCase();\n    }\n    var type = function(obj) {\n        return classToType[Object.prototype.toString.call(obj)] || \"object\";\n    };\n\n    var unpack = function (args, keyOrder) {\n        if ( keyOrder === void 0 ) keyOrder=null;\n\n    \t// if called with more than 3 arguments, we return the arguments\n        if (args.length >= 3) { return Array.prototype.slice.call(args); }\n        // with less than 3 args we check if first arg is object\n        // and use the keyOrder string to extract and sort properties\n    \tif (type(args[0]) == 'object' && keyOrder) {\n    \t\treturn keyOrder.split('')\n    \t\t\t.filter(function (k) { return args[0][k] !== undefined; })\n    \t\t\t.map(function (k) { return args[0][k]; });\n    \t}\n    \t// otherwise we just return the first argument\n    \t// (which we suppose is an array of args)\n        return args[0];\n    };\n\n    var last = function (args) {\n        if (args.length < 2) { return null; }\n        var l = args.length-1;\n        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }\n        return null;\n    };\n\n    var PI = Math.PI;\n\n    var utils = {\n    \tclip_rgb: clip_rgb,\n    \tlimit: limit,\n    \ttype: type,\n    \tunpack: unpack,\n    \tlast: last,\n    \tPI: PI,\n    \tTWOPI: PI*2,\n    \tPITHIRD: PI/3,\n    \tDEG2RAD: PI / 180,\n    \tRAD2DEG: 180 / PI\n    };\n\n    var input = {\n    \tformat: {},\n    \tautodetect: []\n    };\n\n    var last$1 = utils.last;\n    var clip_rgb$1 = utils.clip_rgb;\n    var type$1 = utils.type;\n\n\n    var Color = function Color() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var me = this;\n        if (type$1(args[0]) === 'object' &&\n            args[0].constructor &&\n            args[0].constructor === this.constructor) {\n            // the argument is already a Color instance\n            return args[0];\n        }\n\n        // last argument could be the mode\n        var mode = last$1(args);\n        var autodetect = false;\n\n        if (!mode) {\n            autodetect = true;\n            if (!input.sorted) {\n                input.autodetect = input.autodetect.sort(function (a,b) { return b.p - a.p; });\n                input.sorted = true;\n            }\n            // auto-detect format\n            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n                var chk = list[i];\n\n                mode = chk.test.apply(chk, args);\n                if (mode) { break; }\n            }\n        }\n\n        if (input.format[mode]) {\n            var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));\n            me._rgb = clip_rgb$1(rgb);\n        } else {\n            throw new Error('unknown format: '+args);\n        }\n\n        // add alpha channel\n        if (me._rgb.length === 3) { me._rgb.push(1); }\n    };\n\n    Color.prototype.toString = function toString () {\n        if (type$1(this.hex) == 'function') { return this.hex(); }\n        return (\"[\" + (this._rgb.join(',')) + \"]\");\n    };\n\n    var Color_1 = Color;\n\n    var chroma = function () {\n    \tvar args = [], len = arguments.length;\n    \twhile ( len-- ) args[ len ] = arguments[ len ];\n\n    \treturn new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));\n    };\n\n    chroma.Color = Color_1;\n    chroma.version = '2.1.0';\n\n    var chroma_1 = chroma;\n\n    var unpack$1 = utils.unpack;\n    var max = Math.max;\n\n    var rgb2cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$1(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var k = 1 - max(r,max(g,b));\n        var f = k < 1 ? 1 / (1-k) : 0;\n        var c = (1-r-k) * f;\n        var m = (1-g-k) * f;\n        var y = (1-b-k) * f;\n        return [c,m,y,k];\n    };\n\n    var rgb2cmyk_1 = rgb2cmyk;\n\n    var unpack$2 = utils.unpack;\n\n    var cmyk2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$2(args, 'cmyk');\n        var c = args[0];\n        var m = args[1];\n        var y = args[2];\n        var k = args[3];\n        var alpha = args.length > 4 ? args[4] : 1;\n        if (k === 1) { return [0,0,0,alpha]; }\n        return [\n            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r\n            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g\n            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b\n            alpha\n        ];\n    };\n\n    var cmyk2rgb_1 = cmyk2rgb;\n\n    var unpack$3 = utils.unpack;\n    var type$2 = utils.type;\n\n\n\n    Color_1.prototype.cmyk = function() {\n        return rgb2cmyk_1(this._rgb);\n    };\n\n    chroma_1.cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['cmyk']) ));\n    };\n\n    input.format.cmyk = cmyk2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$3(args, 'cmyk');\n            if (type$2(args) === 'array' && args.length === 4) {\n                return 'cmyk';\n            }\n        }\n    });\n\n    var unpack$4 = utils.unpack;\n    var last$2 = utils.last;\n    var rnd = function (a) { return Math.round(a*100)/100; };\n\n    /*\n     * supported arguments:\n     * - hsl2css(h,s,l)\n     * - hsl2css(h,s,l,a)\n     * - hsl2css([h,s,l], mode)\n     * - hsl2css([h,s,l,a], mode)\n     * - hsl2css({h,s,l,a}, mode)\n     */\n    var hsl2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hsla = unpack$4(args, 'hsla');\n        var mode = last$2(args) || 'lsa';\n        hsla[0] = rnd(hsla[0] || 0);\n        hsla[1] = rnd(hsla[1]*100) + '%';\n        hsla[2] = rnd(hsla[2]*100) + '%';\n        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {\n            hsla[3] = hsla.length > 3 ? hsla[3] : 1;\n            mode = 'hsla';\n        } else {\n            hsla.length = 3;\n        }\n        return (mode + \"(\" + (hsla.join(',')) + \")\");\n    };\n\n    var hsl2css_1 = hsl2css;\n\n    var unpack$5 = utils.unpack;\n\n    /*\n     * supported arguments:\n     * - rgb2hsl(r,g,b)\n     * - rgb2hsl(r,g,b,a)\n     * - rgb2hsl([r,g,b])\n     * - rgb2hsl([r,g,b,a])\n     * - rgb2hsl({r,g,b,a})\n     */\n    var rgb2hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$5(args, 'rgba');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n\n        var l = (max + min) / 2;\n        var s, h;\n\n        if (max === min){\n            s = 0;\n            h = Number.NaN;\n        } else {\n            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n        }\n\n        if (r == max) { h = (g - b) / (max - min); }\n        else if (g == max) { h = 2 + (b - r) / (max - min); }\n        else if (b == max) { h = 4 + (r - g) / (max - min); }\n\n        h *= 60;\n        if (h < 0) { h += 360; }\n        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }\n        return [h,s,l];\n    };\n\n    var rgb2hsl_1 = rgb2hsl;\n\n    var unpack$6 = utils.unpack;\n    var last$3 = utils.last;\n\n\n    var round = Math.round;\n\n    /*\n     * supported arguments:\n     * - rgb2css(r,g,b)\n     * - rgb2css(r,g,b,a)\n     * - rgb2css([r,g,b], mode)\n     * - rgb2css([r,g,b,a], mode)\n     * - rgb2css({r,g,b,a}, mode)\n     */\n    var rgb2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack$6(args, 'rgba');\n        var mode = last$3(args) || 'rgb';\n        if (mode.substr(0,3) == 'hsl') {\n            return hsl2css_1(rgb2hsl_1(rgba), mode);\n        }\n        rgba[0] = round(rgba[0]);\n        rgba[1] = round(rgba[1]);\n        rgba[2] = round(rgba[2]);\n        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {\n            rgba[3] = rgba.length > 3 ? rgba[3] : 1;\n            mode = 'rgba';\n        }\n        return (mode + \"(\" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + \")\");\n    };\n\n    var rgb2css_1 = rgb2css;\n\n    var unpack$7 = utils.unpack;\n    var round$1 = Math.round;\n\n    var hsl2rgb = function () {\n        var assign;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$7(args, 'hsl');\n        var h = args[0];\n        var s = args[1];\n        var l = args[2];\n        var r,g,b;\n        if (s === 0) {\n            r = g = b = l*255;\n        } else {\n            var t3 = [0,0,0];\n            var c = [0,0,0];\n            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;\n            var t1 = 2 * l - t2;\n            var h_ = h / 360;\n            t3[0] = h_ + 1/3;\n            t3[1] = h_;\n            t3[2] = h_ - 1/3;\n            for (var i=0; i<3; i++) {\n                if (t3[i] < 0) { t3[i] += 1; }\n                if (t3[i] > 1) { t3[i] -= 1; }\n                if (6 * t3[i] < 1)\n                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }\n                else if (2 * t3[i] < 1)\n                    { c[i] = t2; }\n                else if (3 * t3[i] < 2)\n                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }\n                else\n                    { c[i] = t1; }\n            }\n            (assign = [round$1(c[0]*255),round$1(c[1]*255),round$1(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);\n        }\n        if (args.length > 3) {\n            // keep alpha channel\n            return [r,g,b,args[3]];\n        }\n        return [r,g,b,1];\n    };\n\n    var hsl2rgb_1 = hsl2rgb;\n\n    var RE_RGB = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n    var RE_RGBA = /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n    var RE_RGB_PCT = /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n    var RE_RGBA_PCT = /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n    var RE_HSL = /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n    var RE_HSLA = /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\n    var round$2 = Math.round;\n\n    var css2rgb = function (css) {\n        css = css.toLowerCase().trim();\n        var m;\n\n        if (input.format.named) {\n            try {\n                return input.format.named(css);\n            } catch (e) {\n                // eslint-disable-next-line\n            }\n        }\n\n        // rgb(250,20,0)\n        if ((m = css.match(RE_RGB))) {\n            var rgb = m.slice(1,4);\n            for (var i=0; i<3; i++) {\n                rgb[i] = +rgb[i];\n            }\n            rgb[3] = 1;  // default alpha\n            return rgb;\n        }\n\n        // rgba(250,20,0,0.4)\n        if ((m = css.match(RE_RGBA))) {\n            var rgb$1 = m.slice(1,5);\n            for (var i$1=0; i$1<4; i$1++) {\n                rgb$1[i$1] = +rgb$1[i$1];\n            }\n            return rgb$1;\n        }\n\n        // rgb(100%,0%,0%)\n        if ((m = css.match(RE_RGB_PCT))) {\n            var rgb$2 = m.slice(1,4);\n            for (var i$2=0; i$2<3; i$2++) {\n                rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\n            }\n            rgb$2[3] = 1;  // default alpha\n            return rgb$2;\n        }\n\n        // rgba(100%,0%,0%,0.4)\n        if ((m = css.match(RE_RGBA_PCT))) {\n            var rgb$3 = m.slice(1,5);\n            for (var i$3=0; i$3<3; i$3++) {\n                rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\n            }\n            rgb$3[3] = +rgb$3[3];\n            return rgb$3;\n        }\n\n        // hsl(0,100%,50%)\n        if ((m = css.match(RE_HSL))) {\n            var hsl = m.slice(1,4);\n            hsl[1] *= 0.01;\n            hsl[2] *= 0.01;\n            var rgb$4 = hsl2rgb_1(hsl);\n            rgb$4[3] = 1;\n            return rgb$4;\n        }\n\n        // hsla(0,100%,50%,0.5)\n        if ((m = css.match(RE_HSLA))) {\n            var hsl$1 = m.slice(1,4);\n            hsl$1[1] *= 0.01;\n            hsl$1[2] *= 0.01;\n            var rgb$5 = hsl2rgb_1(hsl$1);\n            rgb$5[3] = +m[4];  // default alpha = 1\n            return rgb$5;\n        }\n    };\n\n    css2rgb.test = function (s) {\n        return RE_RGB.test(s) ||\n            RE_RGBA.test(s) ||\n            RE_RGB_PCT.test(s) ||\n            RE_RGBA_PCT.test(s) ||\n            RE_HSL.test(s) ||\n            RE_HSLA.test(s);\n    };\n\n    var css2rgb_1 = css2rgb;\n\n    var type$3 = utils.type;\n\n\n\n\n    Color_1.prototype.css = function(mode) {\n        return rgb2css_1(this._rgb, mode);\n    };\n\n    chroma_1.css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['css']) ));\n    };\n\n    input.format.css = css2rgb_1;\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\n                return 'css';\n            }\n        }\n    });\n\n    var unpack$8 = utils.unpack;\n\n    input.format.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack$8(args, 'rgba');\n        rgb[0] *= 255;\n        rgb[1] *= 255;\n        rgb[2] *= 255;\n        return rgb;\n    };\n\n    chroma_1.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['gl']) ));\n    };\n\n    Color_1.prototype.gl = function() {\n        var rgb = this._rgb;\n        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];\n    };\n\n    var unpack$9 = utils.unpack;\n\n    var rgb2hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$9(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n        var delta = max - min;\n        var c = delta * 100 / 255;\n        var _g = min / (255 - delta) * 100;\n        var h;\n        if (delta === 0) {\n            h = Number.NaN;\n        } else {\n            if (r === max) { h = (g - b) / delta; }\n            if (g === max) { h = 2+(b - r) / delta; }\n            if (b === max) { h = 4+(r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, c, _g];\n    };\n\n    var rgb2hcg_1 = rgb2hcg;\n\n    var unpack$a = utils.unpack;\n    var floor = Math.floor;\n\n    /*\n     * this is basically just HSV with some minor tweaks\n     *\n     * hue.. [0..360]\n     * chroma .. [0..1]\n     * grayness .. [0..1]\n     */\n\n    var hcg2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$a(args, 'hcg');\n        var h = args[0];\n        var c = args[1];\n        var _g = args[2];\n        var r,g,b;\n        _g = _g * 255;\n        var _c = c * 255;\n        if (c === 0) {\n            r = g = b = _g;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n            var i = floor(h);\n            var f = h - i;\n            var p = _g * (1 - c);\n            var q = p + _c * (1 - f);\n            var t = p + _c * f;\n            var v = p + _c;\n            switch (i) {\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\n            }\n        }\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var hcg2rgb_1 = hcg2rgb;\n\n    var unpack$b = utils.unpack;\n    var type$4 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hcg = function() {\n        return rgb2hcg_1(this._rgb);\n    };\n\n    chroma_1.hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcg']) ));\n    };\n\n    input.format.hcg = hcg2rgb_1;\n\n    input.autodetect.push({\n        p: 1,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$b(args, 'hcg');\n            if (type$4(args) === 'array' && args.length === 3) {\n                return 'hcg';\n            }\n        }\n    });\n\n    var unpack$c = utils.unpack;\n    var last$4 = utils.last;\n    var round$3 = Math.round;\n\n    var rgb2hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$c(args, 'rgba');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var a = ref[3];\n        var mode = last$4(args) || 'auto';\n        if (a === undefined) { a = 1; }\n        if (mode === 'auto') {\n            mode = a < 1 ? 'rgba' : 'rgb';\n        }\n        r = round$3(r);\n        g = round$3(g);\n        b = round$3(b);\n        var u = r << 16 | g << 8 | b;\n        var str = \"000000\" + u.toString(16); //#.toUpperCase();\n        str = str.substr(str.length - 6);\n        var hxa = '0' + round$3(a * 255).toString(16);\n        hxa = hxa.substr(hxa.length - 2);\n        switch (mode.toLowerCase()) {\n            case 'rgba': return (\"#\" + str + hxa);\n            case 'argb': return (\"#\" + hxa + str);\n            default: return (\"#\" + str);\n        }\n    };\n\n    var rgb2hex_1 = rgb2hex;\n\n    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n    var hex2rgb = function (hex) {\n        if (hex.match(RE_HEX)) {\n            // remove optional leading #\n            if (hex.length === 4 || hex.length === 7) {\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full six-digit\n            if (hex.length === 3) {\n                hex = hex.split('');\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];\n            }\n            var u = parseInt(hex, 16);\n            var r = u >> 16;\n            var g = u >> 8 & 0xFF;\n            var b = u & 0xFF;\n            return [r,g,b,1];\n        }\n\n        // match rgba hex format, eg #FF000077\n        if (hex.match(RE_HEXA)) {\n            if (hex.length === 5 || hex.length === 9) {\n                // remove optional leading #\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full eight-digit\n            if (hex.length === 4) {\n                hex = hex.split('');\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];\n            }\n            var u$1 = parseInt(hex, 16);\n            var r$1 = u$1 >> 24 & 0xFF;\n            var g$1 = u$1 >> 16 & 0xFF;\n            var b$1 = u$1 >> 8 & 0xFF;\n            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\n            return [r$1,g$1,b$1,a];\n        }\n\n        // we used to check for css colors here\n        // if _input.css? and rgb = _input.css hex\n        //     return rgb\n\n        throw new Error((\"unknown hex color: \" + hex));\n    };\n\n    var hex2rgb_1 = hex2rgb;\n\n    var type$5 = utils.type;\n\n\n\n\n    Color_1.prototype.hex = function(mode) {\n        return rgb2hex_1(this._rgb, mode);\n    };\n\n    chroma_1.hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hex']) ));\n    };\n\n    input.format.hex = hex2rgb_1;\n    input.autodetect.push({\n        p: 4,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$5(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {\n                return 'hex';\n            }\n        }\n    });\n\n    var unpack$d = utils.unpack;\n    var TWOPI = utils.TWOPI;\n    var min = Math.min;\n    var sqrt = Math.sqrt;\n    var acos = Math.acos;\n\n    var rgb2hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n        */\n        var ref = unpack$d(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var h;\n        var min_ = min(r,g,b);\n        var i = (r+g+b) / 3;\n        var s = i > 0 ? 1 - min_/i : 0;\n        if (s === 0) {\n            h = NaN;\n        } else {\n            h = ((r-g)+(r-b)) / 2;\n            h /= sqrt((r-g)*(r-g) + (r-b)*(g-b));\n            h = acos(h);\n            if (b > g) {\n                h = TWOPI - h;\n            }\n            h /= TWOPI;\n        }\n        return [h*360,s,i];\n    };\n\n    var rgb2hsi_1 = rgb2hsi;\n\n    var unpack$e = utils.unpack;\n    var limit$1 = utils.limit;\n    var TWOPI$1 = utils.TWOPI;\n    var PITHIRD = utils.PITHIRD;\n    var cos = Math.cos;\n\n    /*\n     * hue [0..360]\n     * saturation [0..1]\n     * intensity [0..1]\n     */\n    var hsi2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n        */\n        args = unpack$e(args, 'hsi');\n        var h = args[0];\n        var s = args[1];\n        var i = args[2];\n        var r,g,b;\n\n        if (isNaN(h)) { h = 0; }\n        if (isNaN(s)) { s = 0; }\n        // normalize hue\n        if (h > 360) { h -= 360; }\n        if (h < 0) { h += 360; }\n        h /= 360;\n        if (h < 1/3) {\n            b = (1-s)/3;\n            r = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            g = 1 - (b+r);\n        } else if (h < 2/3) {\n            h -= 1/3;\n            r = (1-s)/3;\n            g = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            b = 1 - (r+g);\n        } else {\n            h -= 2/3;\n            g = (1-s)/3;\n            b = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\n            r = 1 - (g+b);\n        }\n        r = limit$1(i*r*3);\n        g = limit$1(i*g*3);\n        b = limit$1(i*b*3);\n        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];\n    };\n\n    var hsi2rgb_1 = hsi2rgb;\n\n    var unpack$f = utils.unpack;\n    var type$6 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsi = function() {\n        return rgb2hsi_1(this._rgb);\n    };\n\n    chroma_1.hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsi']) ));\n    };\n\n    input.format.hsi = hsi2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$f(args, 'hsi');\n            if (type$6(args) === 'array' && args.length === 3) {\n                return 'hsi';\n            }\n        }\n    });\n\n    var unpack$g = utils.unpack;\n    var type$7 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsl = function() {\n        return rgb2hsl_1(this._rgb);\n    };\n\n    chroma_1.hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsl']) ));\n    };\n\n    input.format.hsl = hsl2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$g(args, 'hsl');\n            if (type$7(args) === 'array' && args.length === 3) {\n                return 'hsl';\n            }\n        }\n    });\n\n    var unpack$h = utils.unpack;\n    var min$1 = Math.min;\n    var max$1 = Math.max;\n\n    /*\n     * supported arguments:\n     * - rgb2hsv(r,g,b)\n     * - rgb2hsv([r,g,b])\n     * - rgb2hsv({r,g,b})\n     */\n    var rgb2hsl$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$h(args, 'rgb');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n        var min_ = min$1(r, g, b);\n        var max_ = max$1(r, g, b);\n        var delta = max_ - min_;\n        var h,s,v;\n        v = max_ / 255.0;\n        if (max_ === 0) {\n            h = Number.NaN;\n            s = 0;\n        } else {\n            s = delta / max_;\n            if (r === max_) { h = (g - b) / delta; }\n            if (g === max_) { h = 2+(b - r) / delta; }\n            if (b === max_) { h = 4+(r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, s, v]\n    };\n\n    var rgb2hsv = rgb2hsl$1;\n\n    var unpack$i = utils.unpack;\n    var floor$1 = Math.floor;\n\n    var hsv2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack$i(args, 'hsv');\n        var h = args[0];\n        var s = args[1];\n        var v = args[2];\n        var r,g,b;\n        v *= 255;\n        if (s === 0) {\n            r = g = b = v;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n\n            var i = floor$1(h);\n            var f = h - i;\n            var p = v * (1 - s);\n            var q = v * (1 - s * f);\n            var t = v * (1 - s * (1 - f));\n\n            switch (i) {\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\n            }\n        }\n        return [r,g,b,args.length > 3?args[3]:1];\n    };\n\n    var hsv2rgb_1 = hsv2rgb;\n\n    var unpack$j = utils.unpack;\n    var type$8 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.hsv = function() {\n        return rgb2hsv(this._rgb);\n    };\n\n    chroma_1.hsv = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsv']) ));\n    };\n\n    input.format.hsv = hsv2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$j(args, 'hsv');\n            if (type$8(args) === 'array' && args.length === 3) {\n                return 'hsv';\n            }\n        }\n    });\n\n    var labConstants = {\n        // Corresponds roughly to RGB brighter/darker\n        Kn: 18,\n\n        // D65 standard referent\n        Xn: 0.950470,\n        Yn: 1,\n        Zn: 1.088830,\n\n        t0: 0.137931034,  // 4 / 29\n        t1: 0.206896552,  // 6 / 29\n        t2: 0.12841855,   // 3 * t1 * t1\n        t3: 0.008856452,  // t1 * t1 * t1\n    };\n\n    var unpack$k = utils.unpack;\n    var pow = Math.pow;\n\n    var rgb2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$k(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var ref$1 = rgb2xyz(r,g,b);\n        var x = ref$1[0];\n        var y = ref$1[1];\n        var z = ref$1[2];\n        var l = 116 * y - 16;\n        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\n    };\n\n    var rgb_xyz = function (r) {\n        if ((r /= 255) <= 0.04045) { return r / 12.92; }\n        return pow((r + 0.055) / 1.055, 2.4);\n    };\n\n    var xyz_lab = function (t) {\n        if (t > labConstants.t3) { return pow(t, 1 / 3); }\n        return t / labConstants.t2 + labConstants.t0;\n    };\n\n    var rgb2xyz = function (r,g,b) {\n        r = rgb_xyz(r);\n        g = rgb_xyz(g);\n        b = rgb_xyz(b);\n        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\n        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\n        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\n        return [x,y,z];\n    };\n\n    var rgb2lab_1 = rgb2lab;\n\n    var unpack$l = utils.unpack;\n    var pow$1 = Math.pow;\n\n    /*\n     * L* [0..100]\n     * a [-100..100]\n     * b [-100..100]\n     */\n    var lab2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$l(args, 'lab');\n        var l = args[0];\n        var a = args[1];\n        var b = args[2];\n        var x,y,z, r,g,b_;\n\n        y = (l + 16) / 116;\n        x = isNaN(a) ? y : y + a / 500;\n        z = isNaN(b) ? y : y - b / 200;\n\n        y = labConstants.Yn * lab_xyz(y);\n        x = labConstants.Xn * lab_xyz(x);\n        z = labConstants.Zn * lab_xyz(z);\n\n        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB\n        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n\n        return [r,g,b_,args.length > 3 ? args[3] : 1];\n    };\n\n    var xyz_rgb = function (r) {\n        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055)\n    };\n\n    var lab_xyz = function (t) {\n        return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0)\n    };\n\n    var lab2rgb_1 = lab2rgb;\n\n    var unpack$m = utils.unpack;\n    var type$9 = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.lab = function() {\n        return rgb2lab_1(this._rgb);\n    };\n\n    chroma_1.lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lab']) ));\n    };\n\n    input.format.lab = lab2rgb_1;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$m(args, 'lab');\n            if (type$9(args) === 'array' && args.length === 3) {\n                return 'lab';\n            }\n        }\n    });\n\n    var unpack$n = utils.unpack;\n    var RAD2DEG = utils.RAD2DEG;\n    var sqrt$1 = Math.sqrt;\n    var atan2 = Math.atan2;\n    var round$4 = Math.round;\n\n    var lab2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$n(args, 'lab');\n        var l = ref[0];\n        var a = ref[1];\n        var b = ref[2];\n        var c = sqrt$1(a * a + b * b);\n        var h = (atan2(b, a) * RAD2DEG + 360) % 360;\n        if (round$4(c*10000) === 0) { h = Number.NaN; }\n        return [l, c, h];\n    };\n\n    var lab2lch_1 = lab2lch;\n\n    var unpack$o = utils.unpack;\n\n\n\n    var rgb2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$o(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var ref$1 = rgb2lab_1(r,g,b);\n        var l = ref$1[0];\n        var a = ref$1[1];\n        var b_ = ref$1[2];\n        return lab2lch_1(l,a,b_);\n    };\n\n    var rgb2lch_1 = rgb2lch;\n\n    var unpack$p = utils.unpack;\n    var DEG2RAD = utils.DEG2RAD;\n    var sin = Math.sin;\n    var cos$1 = Math.cos;\n\n    var lch2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n        These formulas were invented by David Dalrymple to obtain maximum contrast without going\n        out of gamut if the parameters are in the range 0-1.\n\n        A saturation multiplier was added by Gregor Aisch\n        */\n        var ref = unpack$p(args, 'lch');\n        var l = ref[0];\n        var c = ref[1];\n        var h = ref[2];\n        if (isNaN(h)) { h = 0; }\n        h = h * DEG2RAD;\n        return [l, cos$1(h) * c, sin(h) * c]\n    };\n\n    var lch2lab_1 = lch2lab;\n\n    var unpack$q = utils.unpack;\n\n\n\n    var lch2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack$q(args, 'lch');\n        var l = args[0];\n        var c = args[1];\n        var h = args[2];\n        var ref = lch2lab_1 (l,c,h);\n        var L = ref[0];\n        var a = ref[1];\n        var b_ = ref[2];\n        var ref$1 = lab2rgb_1 (L,a,b_);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b = ref$1[2];\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var lch2rgb_1 = lch2rgb;\n\n    var unpack$r = utils.unpack;\n\n\n    var hcl2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hcl = unpack$r(args, 'hcl').reverse();\n        return lch2rgb_1.apply(void 0, hcl);\n    };\n\n    var hcl2rgb_1 = hcl2rgb;\n\n    var unpack$s = utils.unpack;\n    var type$a = utils.type;\n\n\n\n\n\n\n    Color_1.prototype.lch = function() { return rgb2lch_1(this._rgb); };\n    Color_1.prototype.hcl = function() { return rgb2lch_1(this._rgb).reverse(); };\n\n    chroma_1.lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lch']) ));\n    };\n    chroma_1.hcl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcl']) ));\n    };\n\n    input.format.lch = lch2rgb_1;\n    input.format.hcl = hcl2rgb_1;\n\n    ['lch','hcl'].forEach(function (m) { return input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$s(args, m);\n            if (type$a(args) === 'array' && args.length === 3) {\n                return m;\n            }\n        }\n    }); });\n\n    /**\n    \tX11 color names\n\n    \thttp://www.w3.org/TR/css3-color/#svg-color\n    */\n\n    var w3cx11 = {\n        aliceblue: '#f0f8ff',\n        antiquewhite: '#faebd7',\n        aqua: '#00ffff',\n        aquamarine: '#7fffd4',\n        azure: '#f0ffff',\n        beige: '#f5f5dc',\n        bisque: '#ffe4c4',\n        black: '#000000',\n        blanchedalmond: '#ffebcd',\n        blue: '#0000ff',\n        blueviolet: '#8a2be2',\n        brown: '#a52a2a',\n        burlywood: '#deb887',\n        cadetblue: '#5f9ea0',\n        chartreuse: '#7fff00',\n        chocolate: '#d2691e',\n        coral: '#ff7f50',\n        cornflower: '#6495ed',\n        cornflowerblue: '#6495ed',\n        cornsilk: '#fff8dc',\n        crimson: '#dc143c',\n        cyan: '#00ffff',\n        darkblue: '#00008b',\n        darkcyan: '#008b8b',\n        darkgoldenrod: '#b8860b',\n        darkgray: '#a9a9a9',\n        darkgreen: '#006400',\n        darkgrey: '#a9a9a9',\n        darkkhaki: '#bdb76b',\n        darkmagenta: '#8b008b',\n        darkolivegreen: '#556b2f',\n        darkorange: '#ff8c00',\n        darkorchid: '#9932cc',\n        darkred: '#8b0000',\n        darksalmon: '#e9967a',\n        darkseagreen: '#8fbc8f',\n        darkslateblue: '#483d8b',\n        darkslategray: '#2f4f4f',\n        darkslategrey: '#2f4f4f',\n        darkturquoise: '#00ced1',\n        darkviolet: '#9400d3',\n        deeppink: '#ff1493',\n        deepskyblue: '#00bfff',\n        dimgray: '#696969',\n        dimgrey: '#696969',\n        dodgerblue: '#1e90ff',\n        firebrick: '#b22222',\n        floralwhite: '#fffaf0',\n        forestgreen: '#228b22',\n        fuchsia: '#ff00ff',\n        gainsboro: '#dcdcdc',\n        ghostwhite: '#f8f8ff',\n        gold: '#ffd700',\n        goldenrod: '#daa520',\n        gray: '#808080',\n        green: '#008000',\n        greenyellow: '#adff2f',\n        grey: '#808080',\n        honeydew: '#f0fff0',\n        hotpink: '#ff69b4',\n        indianred: '#cd5c5c',\n        indigo: '#4b0082',\n        ivory: '#fffff0',\n        khaki: '#f0e68c',\n        laserlemon: '#ffff54',\n        lavender: '#e6e6fa',\n        lavenderblush: '#fff0f5',\n        lawngreen: '#7cfc00',\n        lemonchiffon: '#fffacd',\n        lightblue: '#add8e6',\n        lightcoral: '#f08080',\n        lightcyan: '#e0ffff',\n        lightgoldenrod: '#fafad2',\n        lightgoldenrodyellow: '#fafad2',\n        lightgray: '#d3d3d3',\n        lightgreen: '#90ee90',\n        lightgrey: '#d3d3d3',\n        lightpink: '#ffb6c1',\n        lightsalmon: '#ffa07a',\n        lightseagreen: '#20b2aa',\n        lightskyblue: '#87cefa',\n        lightslategray: '#778899',\n        lightslategrey: '#778899',\n        lightsteelblue: '#b0c4de',\n        lightyellow: '#ffffe0',\n        lime: '#00ff00',\n        limegreen: '#32cd32',\n        linen: '#faf0e6',\n        magenta: '#ff00ff',\n        maroon: '#800000',\n        maroon2: '#7f0000',\n        maroon3: '#b03060',\n        mediumaquamarine: '#66cdaa',\n        mediumblue: '#0000cd',\n        mediumorchid: '#ba55d3',\n        mediumpurple: '#9370db',\n        mediumseagreen: '#3cb371',\n        mediumslateblue: '#7b68ee',\n        mediumspringgreen: '#00fa9a',\n        mediumturquoise: '#48d1cc',\n        mediumvioletred: '#c71585',\n        midnightblue: '#191970',\n        mintcream: '#f5fffa',\n        mistyrose: '#ffe4e1',\n        moccasin: '#ffe4b5',\n        navajowhite: '#ffdead',\n        navy: '#000080',\n        oldlace: '#fdf5e6',\n        olive: '#808000',\n        olivedrab: '#6b8e23',\n        orange: '#ffa500',\n        orangered: '#ff4500',\n        orchid: '#da70d6',\n        palegoldenrod: '#eee8aa',\n        palegreen: '#98fb98',\n        paleturquoise: '#afeeee',\n        palevioletred: '#db7093',\n        papayawhip: '#ffefd5',\n        peachpuff: '#ffdab9',\n        peru: '#cd853f',\n        pink: '#ffc0cb',\n        plum: '#dda0dd',\n        powderblue: '#b0e0e6',\n        purple: '#800080',\n        purple2: '#7f007f',\n        purple3: '#a020f0',\n        rebeccapurple: '#663399',\n        red: '#ff0000',\n        rosybrown: '#bc8f8f',\n        royalblue: '#4169e1',\n        saddlebrown: '#8b4513',\n        salmon: '#fa8072',\n        sandybrown: '#f4a460',\n        seagreen: '#2e8b57',\n        seashell: '#fff5ee',\n        sienna: '#a0522d',\n        silver: '#c0c0c0',\n        skyblue: '#87ceeb',\n        slateblue: '#6a5acd',\n        slategray: '#708090',\n        slategrey: '#708090',\n        snow: '#fffafa',\n        springgreen: '#00ff7f',\n        steelblue: '#4682b4',\n        tan: '#d2b48c',\n        teal: '#008080',\n        thistle: '#d8bfd8',\n        tomato: '#ff6347',\n        turquoise: '#40e0d0',\n        violet: '#ee82ee',\n        wheat: '#f5deb3',\n        white: '#ffffff',\n        whitesmoke: '#f5f5f5',\n        yellow: '#ffff00',\n        yellowgreen: '#9acd32'\n    };\n\n    var w3cx11_1 = w3cx11;\n\n    var type$b = utils.type;\n\n\n\n\n\n    Color_1.prototype.name = function() {\n        var hex = rgb2hex_1(this._rgb, 'rgb');\n        for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\n            var n = list[i];\n\n            if (w3cx11_1[n] === hex) { return n.toLowerCase(); }\n        }\n        return hex;\n    };\n\n    input.format.named = function (name) {\n        name = name.toLowerCase();\n        if (w3cx11_1[name]) { return hex2rgb_1(w3cx11_1[name]); }\n        throw new Error('unknown color name: '+name);\n    };\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\n                return 'named';\n            }\n        }\n    });\n\n    var unpack$t = utils.unpack;\n\n    var rgb2num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack$t(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        return (r << 16) + (g << 8) + b;\n    };\n\n    var rgb2num_1 = rgb2num;\n\n    var type$c = utils.type;\n\n    var num2rgb = function (num) {\n        if (type$c(num) == \"number\" && num >= 0 && num <= 0xFFFFFF) {\n            var r = num >> 16;\n            var g = (num >> 8) & 0xFF;\n            var b = num & 0xFF;\n            return [r,g,b,1];\n        }\n        throw new Error(\"unknown num color: \"+num);\n    };\n\n    var num2rgb_1 = num2rgb;\n\n    var type$d = utils.type;\n\n\n\n    Color_1.prototype.num = function() {\n        return rgb2num_1(this._rgb);\n    };\n\n    chroma_1.num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['num']) ));\n    };\n\n    input.format.num = num2rgb_1;\n\n    input.autodetect.push({\n        p: 5,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\n                return 'num';\n            }\n        }\n    });\n\n    var unpack$u = utils.unpack;\n    var type$e = utils.type;\n    var round$5 = Math.round;\n\n    Color_1.prototype.rgb = function(rnd) {\n        if ( rnd === void 0 ) rnd=true;\n\n        if (rnd === false) { return this._rgb.slice(0,3); }\n        return this._rgb.slice(0,3).map(round$5);\n    };\n\n    Color_1.prototype.rgba = function(rnd) {\n        if ( rnd === void 0 ) rnd=true;\n\n        return this._rgb.slice(0,4).map(function (v,i) {\n            return i<3 ? (rnd === false ? v : round$5(v)) : v;\n        });\n    };\n\n    chroma_1.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['rgb']) ));\n    };\n\n    input.format.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack$u(args, 'rgba');\n        if (rgba[3] === undefined) { rgba[3] = 1; }\n        return rgba;\n    };\n\n    input.autodetect.push({\n        p: 3,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack$u(args, 'rgba');\n            if (type$e(args) === 'array' && (args.length === 3 ||\n                args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\n                return 'rgb';\n            }\n        }\n    });\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     */\n\n    var log = Math.log;\n\n    var temperature2rgb = function (kelvin) {\n        var temp = kelvin / 100;\n        var r,g,b;\n        if (temp < 66) {\n            r = 255;\n            g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g);\n            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b);\n        } else {\n            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r);\n            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g);\n            b = 255;\n        }\n        return [r,g,b,1];\n    };\n\n    var temperature2rgb_1 = temperature2rgb;\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     **/\n\n\n    var unpack$v = utils.unpack;\n    var round$6 = Math.round;\n\n    var rgb2temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack$v(args, 'rgb');\n        var r = rgb[0], b = rgb[2];\n        var minTemp = 1000;\n        var maxTemp = 40000;\n        var eps = 0.4;\n        var temp;\n        while (maxTemp - minTemp > eps) {\n            temp = (maxTemp + minTemp) * 0.5;\n            var rgb$1 = temperature2rgb_1(temp);\n            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {\n                maxTemp = temp;\n            } else {\n                minTemp = temp;\n            }\n        }\n        return round$6(temp);\n    };\n\n    var rgb2temperature_1 = rgb2temperature;\n\n    Color_1.prototype.temp =\n    Color_1.prototype.kelvin =\n    Color_1.prototype.temperature = function() {\n        return rgb2temperature_1(this._rgb);\n    };\n\n    chroma_1.temp =\n    chroma_1.kelvin =\n    chroma_1.temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['temp']) ));\n    };\n\n    input.format.temp =\n    input.format.kelvin =\n    input.format.temperature = temperature2rgb_1;\n\n    var type$f = utils.type;\n\n    Color_1.prototype.alpha = function(a, mutate) {\n        if ( mutate === void 0 ) mutate=false;\n\n        if (a !== undefined && type$f(a) === 'number') {\n            if (mutate) {\n                this._rgb[3] = a;\n                return this;\n            }\n            return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n        }\n        return this._rgb[3];\n    };\n\n    Color_1.prototype.clipped = function() {\n        return this._rgb._clipped || false;\n    };\n\n    Color_1.prototype.darken = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \tvar me = this;\n    \tvar lab = me.lab();\n    \tlab[0] -= labConstants.Kn * amount;\n    \treturn new Color_1(lab, 'lab').alpha(me.alpha(), true);\n    };\n\n    Color_1.prototype.brighten = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \treturn this.darken(-amount);\n    };\n\n    Color_1.prototype.darker = Color_1.prototype.darken;\n    Color_1.prototype.brighter = Color_1.prototype.brighten;\n\n    Color_1.prototype.get = function(mc) {\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel);\n            if (i > -1) { return src[i]; }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var type$g = utils.type;\n    var pow$2 = Math.pow;\n\n    var EPS = 1e-7;\n    var MAX_ITER = 20;\n\n    Color_1.prototype.luminance = function(lum) {\n        if (lum !== undefined && type$g(lum) === 'number') {\n            if (lum === 0) {\n                // return pure black\n                return new Color_1([0,0,0,this._rgb[3]], 'rgb');\n            }\n            if (lum === 1) {\n                // return pure white\n                return new Color_1([255,255,255,this._rgb[3]], 'rgb');\n            }\n            // compute new color using...\n            var cur_lum = this.luminance();\n            var mode = 'rgb';\n            var max_iter = MAX_ITER;\n\n            var test = function (low, high) {\n                var mid = low.interpolate(high, 0.5, mode);\n                var lm = mid.luminance();\n                if (Math.abs(lum - lm) < EPS || !max_iter--) {\n                    // close enough\n                    return mid;\n                }\n                return lm > lum ? test(low, mid) : test(mid, high);\n            };\n\n            var rgb = (cur_lum > lum ? test(new Color_1([0,0,0]), this) : test(this, new Color_1([255,255,255]))).rgb();\n            return new Color_1(rgb.concat( [this._rgb[3]]));\n        }\n        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));\n    };\n\n\n    var rgb2luminance = function (r,g,b) {\n        // relative luminance\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        r = luminance_x(r);\n        g = luminance_x(g);\n        b = luminance_x(b);\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    };\n\n    var luminance_x = function (x) {\n        x /= 255;\n        return x <= 0.03928 ? x/12.92 : pow$2((x+0.055)/1.055, 2.4);\n    };\n\n    var interpolator = {};\n\n    var type$h = utils.type;\n\n\n    var mix = function (col1, col2, f) {\n        if ( f === void 0 ) f=0.5;\n        var rest = [], len = arguments.length - 3;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];\n\n        var mode = rest[0] || 'lrgb';\n        if (!interpolator[mode] && !rest.length) {\n            // fall back to the first supported mode\n            mode = Object.keys(interpolator)[0];\n        }\n        if (!interpolator[mode]) {\n            throw new Error((\"interpolation mode \" + mode + \" is not defined\"));\n        }\n        if (type$h(col1) !== 'object') { col1 = new Color_1(col1); }\n        if (type$h(col2) !== 'object') { col2 = new Color_1(col2); }\n        return interpolator[mode](col1, col2, f)\n            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\n    };\n\n    Color_1.prototype.mix =\n    Color_1.prototype.interpolate = function(col2, f) {\n    \tif ( f === void 0 ) f=0.5;\n    \tvar rest = [], len = arguments.length - 2;\n    \twhile ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\n\n    \treturn mix.apply(void 0, [ this, col2, f ].concat( rest ));\n    };\n\n    Color_1.prototype.premultiply = function(mutate) {\n    \tif ( mutate === void 0 ) mutate=false;\n\n    \tvar rgb = this._rgb;\n    \tvar a = rgb[3];\n    \tif (mutate) {\n    \t\tthis._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];\n    \t\treturn this;\n    \t} else {\n    \t\treturn new Color_1([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');\n    \t}\n    };\n\n    Color_1.prototype.saturate = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \tvar me = this;\n    \tvar lch = me.lch();\n    \tlch[1] += labConstants.Kn * amount;\n    \tif (lch[1] < 0) { lch[1] = 0; }\n    \treturn new Color_1(lch, 'lch').alpha(me.alpha(), true);\n    };\n\n    Color_1.prototype.desaturate = function(amount) {\n    \tif ( amount === void 0 ) amount=1;\n\n    \treturn this.saturate(-amount);\n    };\n\n    var type$i = utils.type;\n\n    Color_1.prototype.set = function(mc, value, mutate) {\n        if ( mutate === void 0 ) mutate=false;\n\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel);\n            if (i > -1) {\n                if (type$i(value) == 'string') {\n                    switch(value.charAt(0)) {\n                        case '+': src[i] += +value; break;\n                        case '-': src[i] += +value; break;\n                        case '*': src[i] *= +(value.substr(1)); break;\n                        case '/': src[i] /= +(value.substr(1)); break;\n                        default: src[i] = +value;\n                    }\n                } else if (type$i(value) === 'number') {\n                    src[i] = value;\n                } else {\n                    throw new Error(\"unsupported value for Color.set\");\n                }\n                var out = new Color_1(src, mode);\n                if (mutate) {\n                    this._rgb = out._rgb;\n                    return this;\n                }\n                return out;\n            }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var rgb$1 = function (col1, col2, f) {\n        var xyz0 = col1._rgb;\n        var xyz1 = col2._rgb;\n        return new Color_1(\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\n            'rgb'\n        )\n    };\n\n    // register interpolator\n    interpolator.rgb = rgb$1;\n\n    var sqrt$2 = Math.sqrt;\n    var pow$3 = Math.pow;\n\n    var lrgb = function (col1, col2, f) {\n        var ref = col1._rgb;\n        var x1 = ref[0];\n        var y1 = ref[1];\n        var z1 = ref[2];\n        var ref$1 = col2._rgb;\n        var x2 = ref$1[0];\n        var y2 = ref$1[1];\n        var z2 = ref$1[2];\n        return new Color_1(\n            sqrt$2(pow$3(x1,2) * (1-f) + pow$3(x2,2) * f),\n            sqrt$2(pow$3(y1,2) * (1-f) + pow$3(y2,2) * f),\n            sqrt$2(pow$3(z1,2) * (1-f) + pow$3(z2,2) * f),\n            'rgb'\n        )\n    };\n\n    // register interpolator\n    interpolator.lrgb = lrgb;\n\n    var lab$1 = function (col1, col2, f) {\n        var xyz0 = col1.lab();\n        var xyz1 = col2.lab();\n        return new Color_1(\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\n            'lab'\n        )\n    };\n\n    // register interpolator\n    interpolator.lab = lab$1;\n\n    var _hsx = function (col1, col2, f, m) {\n        var assign, assign$1;\n\n        var xyz0, xyz1;\n        if (m === 'hsl') {\n            xyz0 = col1.hsl();\n            xyz1 = col2.hsl();\n        } else if (m === 'hsv') {\n            xyz0 = col1.hsv();\n            xyz1 = col2.hsv();\n        } else if (m === 'hcg') {\n            xyz0 = col1.hcg();\n            xyz1 = col2.hcg();\n        } else if (m === 'hsi') {\n            xyz0 = col1.hsi();\n            xyz1 = col2.hsi();\n        } else if (m === 'lch' || m === 'hcl') {\n            m = 'hcl';\n            xyz0 = col1.hcl();\n            xyz1 = col2.hcl();\n        }\n\n        var hue0, hue1, sat0, sat1, lbv0, lbv1;\n        if (m.substr(0, 1) === 'h') {\n            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);\n            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);\n        }\n\n        var sat, hue, lbv, dh;\n\n        if (!isNaN(hue0) && !isNaN(hue1)) {\n            // both colors have hue\n            if (hue1 > hue0 && hue1 - hue0 > 180) {\n                dh = hue1-(hue0+360);\n            } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n                dh = hue1+360-hue0;\n            } else{\n                dh = hue1 - hue0;\n            }\n            hue = hue0 + f * dh;\n        } else if (!isNaN(hue0)) {\n            hue = hue0;\n            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }\n        } else if (!isNaN(hue1)) {\n            hue = hue1;\n            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }\n        } else {\n            hue = Number.NaN;\n        }\n\n        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }\n        lbv = lbv0 + f * (lbv1-lbv0);\n        return new Color_1([hue, sat, lbv], m);\n    };\n\n    var lch$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'lch');\n    };\n\n    // register interpolator\n    interpolator.lch = lch$1;\n    interpolator.hcl = lch$1;\n\n    var num$1 = function (col1, col2, f) {\n        var c1 = col1.num();\n        var c2 = col2.num();\n        return new Color_1(c1 + f * (c2-c1), 'num')\n    };\n\n    // register interpolator\n    interpolator.num = num$1;\n\n    var hcg$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hcg');\n    };\n\n    // register interpolator\n    interpolator.hcg = hcg$1;\n\n    var hsi$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsi');\n    };\n\n    // register interpolator\n    interpolator.hsi = hsi$1;\n\n    var hsl$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsl');\n    };\n\n    // register interpolator\n    interpolator.hsl = hsl$1;\n\n    var hsv$1 = function (col1, col2, f) {\n    \treturn _hsx(col1, col2, f, 'hsv');\n    };\n\n    // register interpolator\n    interpolator.hsv = hsv$1;\n\n    var clip_rgb$2 = utils.clip_rgb;\n    var pow$4 = Math.pow;\n    var sqrt$3 = Math.sqrt;\n    var PI$1 = Math.PI;\n    var cos$2 = Math.cos;\n    var sin$1 = Math.sin;\n    var atan2$1 = Math.atan2;\n\n    var average = function (colors, mode, weights) {\n        if ( mode === void 0 ) mode='lrgb';\n        if ( weights === void 0 ) weights=null;\n\n        var l = colors.length;\n        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }\n        // normalize weights\n        var k = l / weights.reduce(function(a, b) { return a + b; });\n        weights.forEach(function (w,i) { weights[i] *= k; });\n        // convert colors to Color objects\n        colors = colors.map(function (c) { return new Color_1(c); });\n        if (mode === 'lrgb') {\n            return _average_lrgb(colors, weights)\n        }\n        var first = colors.shift();\n        var xyz = first.get(mode);\n        var cnt = [];\n        var dx = 0;\n        var dy = 0;\n        // initial color\n        for (var i=0; i<xyz.length; i++) {\n            xyz[i] = (xyz[i] || 0) * weights[0];\n            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n                var A = xyz[i] / 180 * PI$1;\n                dx += cos$2(A) * weights[0];\n                dy += sin$1(A) * weights[0];\n            }\n        }\n\n        var alpha = first.alpha() * weights[0];\n        colors.forEach(function (c,ci) {\n            var xyz2 = c.get(mode);\n            alpha += c.alpha() * weights[ci+1];\n            for (var i=0; i<xyz.length; i++) {\n                if (!isNaN(xyz2[i])) {\n                    cnt[i] += weights[ci+1];\n                    if (mode.charAt(i) === 'h') {\n                        var A = xyz2[i] / 180 * PI$1;\n                        dx += cos$2(A) * weights[ci+1];\n                        dy += sin$1(A) * weights[ci+1];\n                    } else {\n                        xyz[i] += xyz2[i] * weights[ci+1];\n                    }\n                }\n            }\n        });\n\n        for (var i$1=0; i$1<xyz.length; i$1++) {\n            if (mode.charAt(i$1) === 'h') {\n                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\n                while (A$1 < 0) { A$1 += 360; }\n                while (A$1 >= 360) { A$1 -= 360; }\n                xyz[i$1] = A$1;\n            } else {\n                xyz[i$1] = xyz[i$1]/cnt[i$1];\n            }\n        }\n        alpha /= l;\n        return (new Color_1(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);\n    };\n\n\n    var _average_lrgb = function (colors, weights) {\n        var l = colors.length;\n        var xyz = [0,0,0,0];\n        for (var i=0; i < colors.length; i++) {\n            var col = colors[i];\n            var f = weights[i] / l;\n            var rgb = col._rgb;\n            xyz[0] += pow$4(rgb[0],2) * f;\n            xyz[1] += pow$4(rgb[1],2) * f;\n            xyz[2] += pow$4(rgb[2],2) * f;\n            xyz[3] += rgb[3] * f;\n        }\n        xyz[0] = sqrt$3(xyz[0]);\n        xyz[1] = sqrt$3(xyz[1]);\n        xyz[2] = sqrt$3(xyz[2]);\n        if (xyz[3] > 0.9999999) { xyz[3] = 1; }\n        return new Color_1(clip_rgb$2(xyz));\n    };\n\n    // minimal multi-purpose interface\n\n    // @requires utils color analyze\n\n\n    var type$j = utils.type;\n\n    var pow$5 = Math.pow;\n\n    var scale = function(colors) {\n\n        // constructor\n        var _mode = 'rgb';\n        var _nacol = chroma_1('#ccc');\n        var _spread = 0;\n        // const _fixed = false;\n        var _domain = [0, 1];\n        var _pos = [];\n        var _padding = [0,0];\n        var _classes = false;\n        var _colors = [];\n        var _out = false;\n        var _min = 0;\n        var _max = 1;\n        var _correctLightness = false;\n        var _colorCache = {};\n        var _useCache = true;\n        var _gamma = 1;\n\n        // private methods\n\n        var setColors = function(colors) {\n            colors = colors || ['#fff', '#000'];\n            if (colors && type$j(colors) === 'string' && chroma_1.brewer &&\n                chroma_1.brewer[colors.toLowerCase()]) {\n                colors = chroma_1.brewer[colors.toLowerCase()];\n            }\n            if (type$j(colors) === 'array') {\n                // handle single color\n                if (colors.length === 1) {\n                    colors = [colors[0], colors[0]];\n                }\n                // make a copy of the colors\n                colors = colors.slice(0);\n                // convert to chroma classes\n                for (var c=0; c<colors.length; c++) {\n                    colors[c] = chroma_1(colors[c]);\n                }\n                // auto-fill color position\n                _pos.length = 0;\n                for (var c$1=0; c$1<colors.length; c$1++) {\n                    _pos.push(c$1/(colors.length-1));\n                }\n            }\n            resetCache();\n            return _colors = colors;\n        };\n\n        var getClass = function(value) {\n            if (_classes != null) {\n                var n = _classes.length-1;\n                var i = 0;\n                while (i < n && value >= _classes[i]) {\n                    i++;\n                }\n                return i-1;\n            }\n            return 0;\n        };\n\n        var tMapLightness = function (t) { return t; };\n        var tMapDomain = function (t) { return t; };\n\n        // const classifyValue = function(value) {\n        //     let val = value;\n        //     if (_classes.length > 2) {\n        //         const n = _classes.length-1;\n        //         const i = getClass(value);\n        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n        //     }\n        //     return val;\n        // };\n\n        var getColor = function(val, bypassMap) {\n            var col, t;\n            if (bypassMap == null) { bypassMap = false; }\n            if (isNaN(val) || (val === null)) { return _nacol; }\n            if (!bypassMap) {\n                if (_classes && (_classes.length > 2)) {\n                    // find the class\n                    var c = getClass(val);\n                    t = c / (_classes.length-2);\n                } else if (_max !== _min) {\n                    // just interpolate between min/max\n                    t = (val - _min) / (_max - _min);\n                } else {\n                    t = 1;\n                }\n            } else {\n                t = val;\n            }\n\n            // domain map\n            t = tMapDomain(t);\n\n            if (!bypassMap) {\n                t = tMapLightness(t);  // lightness correction\n            }\n\n            if (_gamma !== 1) { t = pow$5(t, _gamma); }\n\n            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));\n\n            t = Math.min(1, Math.max(0, t));\n\n            var k = Math.floor(t * 10000);\n\n            if (_useCache && _colorCache[k]) {\n                col = _colorCache[k];\n            } else {\n                if (type$j(_colors) === 'array') {\n                    //for i in [0.._pos.length-1]\n                    for (var i=0; i<_pos.length; i++) {\n                        var p = _pos[i];\n                        if (t <= p) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if ((t >= p) && (i === (_pos.length-1))) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if (t > p && t < _pos[i+1]) {\n                            t = (t-p)/(_pos[i+1]-p);\n                            col = chroma_1.interpolate(_colors[i], _colors[i+1], t, _mode);\n                            break;\n                        }\n                    }\n                } else if (type$j(_colors) === 'function') {\n                    col = _colors(t);\n                }\n                if (_useCache) { _colorCache[k] = col; }\n            }\n            return col;\n        };\n\n        var resetCache = function () { return _colorCache = {}; };\n\n        setColors(colors);\n\n        // public interface\n\n        var f = function(v) {\n            var c = chroma_1(getColor(v));\n            if (_out && c[_out]) { return c[_out](); } else { return c; }\n        };\n\n        f.classes = function(classes) {\n            if (classes != null) {\n                if (type$j(classes) === 'array') {\n                    _classes = classes;\n                    _domain = [classes[0], classes[classes.length-1]];\n                } else {\n                    var d = chroma_1.analyze(_domain);\n                    if (classes === 0) {\n                        _classes = [d.min, d.max];\n                    } else {\n                        _classes = chroma_1.limits(d, 'e', classes);\n                    }\n                }\n                return f;\n            }\n            return _classes;\n        };\n\n\n        f.domain = function(domain) {\n            if (!arguments.length) {\n                return _domain;\n            }\n            _min = domain[0];\n            _max = domain[domain.length-1];\n            _pos = [];\n            var k = _colors.length;\n            if ((domain.length === k) && (_min !== _max)) {\n                // update positions\n                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n                    var d = list[i];\n\n                  _pos.push((d-_min) / (_max-_min));\n                }\n            } else {\n                for (var c=0; c<k; c++) {\n                    _pos.push(c/(k-1));\n                }\n                if (domain.length > 2) {\n                    // set domain map\n                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });\n                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });\n                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {\n                        tMapDomain = function (t) {\n                            if (t <= 0 || t >= 1) { return t; }\n                            var i = 0;\n                            while (t >= tBreaks[i+1]) { i++; }\n                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);\n                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);\n                            return out;\n                        };\n                    }\n\n                }\n            }\n            _domain = [_min, _max];\n            return f;\n        };\n\n        f.mode = function(_m) {\n            if (!arguments.length) {\n                return _mode;\n            }\n            _mode = _m;\n            resetCache();\n            return f;\n        };\n\n        f.range = function(colors, _pos) {\n            setColors(colors, _pos);\n            return f;\n        };\n\n        f.out = function(_o) {\n            _out = _o;\n            return f;\n        };\n\n        f.spread = function(val) {\n            if (!arguments.length) {\n                return _spread;\n            }\n            _spread = val;\n            return f;\n        };\n\n        f.correctLightness = function(v) {\n            if (v == null) { v = true; }\n            _correctLightness = v;\n            resetCache();\n            if (_correctLightness) {\n                tMapLightness = function(t) {\n                    var L0 = getColor(0, true).lab()[0];\n                    var L1 = getColor(1, true).lab()[0];\n                    var pol = L0 > L1;\n                    var L_actual = getColor(t, true).lab()[0];\n                    var L_ideal = L0 + ((L1 - L0) * t);\n                    var L_diff = L_actual - L_ideal;\n                    var t0 = 0;\n                    var t1 = 1;\n                    var max_iter = 20;\n                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {\n                        (function() {\n                            if (pol) { L_diff *= -1; }\n                            if (L_diff < 0) {\n                                t0 = t;\n                                t += (t1 - t) * 0.5;\n                            } else {\n                                t1 = t;\n                                t += (t0 - t) * 0.5;\n                            }\n                            L_actual = getColor(t, true).lab()[0];\n                            return L_diff = L_actual - L_ideal;\n                        })();\n                    }\n                    return t;\n                };\n            } else {\n                tMapLightness = function (t) { return t; };\n            }\n            return f;\n        };\n\n        f.padding = function(p) {\n            if (p != null) {\n                if (type$j(p) === 'number') {\n                    p = [p,p];\n                }\n                _padding = p;\n                return f;\n            } else {\n                return _padding;\n            }\n        };\n\n        f.colors = function(numColors, out) {\n            // If no arguments are given, return the original colors that were provided\n            if (arguments.length < 2) { out = 'hex'; }\n            var result = [];\n\n            if (arguments.length === 0) {\n                result = _colors.slice(0);\n\n            } else if (numColors === 1) {\n                result = [f(0.5)];\n\n            } else if (numColors > 1) {\n                var dm = _domain[0];\n                var dd = _domain[1] - dm;\n                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });\n\n            } else { // returns all colors based on the defined classes\n                colors = [];\n                var samples = [];\n                if (_classes && (_classes.length > 2)) {\n                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n                        samples.push((_classes[i-1]+_classes[i])*0.5);\n                    }\n                } else {\n                    samples = _domain;\n                }\n                result = samples.map(function (v) { return f(v); });\n            }\n\n            if (chroma_1[out]) {\n                result = result.map(function (c) { return c[out](); });\n            }\n            return result;\n        };\n\n        f.cache = function(c) {\n            if (c != null) {\n                _useCache = c;\n                return f;\n            } else {\n                return _useCache;\n            }\n        };\n\n        f.gamma = function(g) {\n            if (g != null) {\n                _gamma = g;\n                return f;\n            } else {\n                return _gamma;\n            }\n        };\n\n        f.nodata = function(d) {\n            if (d != null) {\n                _nacol = chroma_1(d);\n                return f;\n            } else {\n                return _nacol;\n            }\n        };\n\n        return f;\n    };\n\n    function __range__(left, right, inclusive) {\n      var range = [];\n      var ascending = left < right;\n      var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n      }\n      return range;\n    }\n\n    //\n    // interpolates between a set of colors uzing a bezier spline\n    //\n\n    // @requires utils lab\n\n\n\n\n    var bezier = function(colors) {\n        var assign, assign$1, assign$2;\n\n        var I, lab0, lab1, lab2;\n        colors = colors.map(function (c) { return new Color_1(c); });\n        if (colors.length === 2) {\n            // linear interpolation\n            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 3) {\n            // quadratic bezier interpolation\n            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 4) {\n            // cubic bezier interpolation\n            var lab3;\n            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);\n            I = function(t) {\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));\n                return new Color_1(lab, 'lab');\n            };\n        } else if (colors.length === 5) {\n            var I0 = bezier(colors.slice(0, 3));\n            var I1 = bezier(colors.slice(2, 5));\n            I = function(t) {\n                if (t < 0.5) {\n                    return I0(t*2);\n                } else {\n                    return I1((t-0.5)*2);\n                }\n            };\n        }\n        return I;\n    };\n\n    var bezier_1 = function (colors) {\n        var f = bezier(colors);\n        f.scale = function () { return scale(f); };\n        return f;\n    };\n\n    /*\n     * interpolates between a set of colors uzing a bezier spline\n     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n     */\n\n\n\n\n    var blend = function (bottom, top, mode) {\n        if (!blend[mode]) {\n            throw new Error('unknown blend mode ' + mode);\n        }\n        return blend[mode](bottom, top);\n    };\n\n    var blend_f = function (f) { return function (bottom,top) {\n            var c0 = chroma_1(top).rgb();\n            var c1 = chroma_1(bottom).rgb();\n            return chroma_1.rgb(f(c0, c1));\n        }; };\n\n    var each = function (f) { return function (c0, c1) {\n            var out = [];\n            out[0] = f(c0[0], c1[0]);\n            out[1] = f(c0[1], c1[1]);\n            out[2] = f(c0[2], c1[2]);\n            return out;\n        }; };\n\n    var normal = function (a) { return a; };\n    var multiply = function (a,b) { return a * b / 255; };\n    var darken$1 = function (a,b) { return a > b ? b : a; };\n    var lighten = function (a,b) { return a > b ? a : b; };\n    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };\n    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };\n    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };\n    var dodge = function (a,b) {\n        if (a === 255) { return 255; }\n        a = 255 * (b / 255) / (1 - a / 255);\n        return a > 255 ? 255 : a\n    };\n\n    // # add = (a,b) ->\n    // #     if (a + b > 255) then 255 else a + b\n\n    blend.normal = blend_f(each(normal));\n    blend.multiply = blend_f(each(multiply));\n    blend.screen = blend_f(each(screen));\n    blend.overlay = blend_f(each(overlay));\n    blend.darken = blend_f(each(darken$1));\n    blend.lighten = blend_f(each(lighten));\n    blend.dodge = blend_f(each(dodge));\n    blend.burn = blend_f(each(burn));\n    // blend.add = blend_f(each(add));\n\n    var blend_1 = blend;\n\n    // cubehelix interpolation\n    // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n    // http://astron-soc.in/bulletin/11June/289392011.pdf\n\n    var type$k = utils.type;\n    var clip_rgb$3 = utils.clip_rgb;\n    var TWOPI$2 = utils.TWOPI;\n    var pow$6 = Math.pow;\n    var sin$2 = Math.sin;\n    var cos$3 = Math.cos;\n\n\n    var cubehelix = function(start, rotations, hue, gamma, lightness) {\n        if ( start === void 0 ) start=300;\n        if ( rotations === void 0 ) rotations=-1.5;\n        if ( hue === void 0 ) hue=1;\n        if ( gamma === void 0 ) gamma=1;\n        if ( lightness === void 0 ) lightness=[0,1];\n\n        var dh = 0, dl;\n        if (type$k(lightness) === 'array') {\n            dl = lightness[1] - lightness[0];\n        } else {\n            dl = 0;\n            lightness = [lightness, lightness];\n        }\n\n        var f = function(fract) {\n            var a = TWOPI$2 * (((start+120)/360) + (rotations * fract));\n            var l = pow$6(lightness[0] + (dl * fract), gamma);\n            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;\n            var amp = (h * l * (1-l)) / 2;\n            var cos_a = cos$3(a);\n            var sin_a = sin$2(a);\n            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));\n            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));\n            var b = l + (amp * (+1.97294 * cos_a));\n            return chroma_1(clip_rgb$3([r*255,g*255,b*255,1]));\n        };\n\n        f.start = function(s) {\n            if ((s == null)) { return start; }\n            start = s;\n            return f;\n        };\n\n        f.rotations = function(r) {\n            if ((r == null)) { return rotations; }\n            rotations = r;\n            return f;\n        };\n\n        f.gamma = function(g) {\n            if ((g == null)) { return gamma; }\n            gamma = g;\n            return f;\n        };\n\n        f.hue = function(h) {\n            if ((h == null)) { return hue; }\n            hue = h;\n            if (type$k(hue) === 'array') {\n                dh = hue[1] - hue[0];\n                if (dh === 0) { hue = hue[1]; }\n            } else {\n                dh = 0;\n            }\n            return f;\n        };\n\n        f.lightness = function(h) {\n            if ((h == null)) { return lightness; }\n            if (type$k(h) === 'array') {\n                lightness = h;\n                dl = h[1] - h[0];\n            } else {\n                lightness = [h,h];\n                dl = 0;\n            }\n            return f;\n        };\n\n        f.scale = function () { return chroma_1.scale(f); };\n\n        f.hue(hue);\n\n        return f;\n    };\n\n    var digits = '0123456789abcdef';\n\n    var floor$2 = Math.floor;\n    var random = Math.random;\n\n    var random_1 = function () {\n        var code = '#';\n        for (var i=0; i<6; i++) {\n            code += digits.charAt(floor$2(random() * 16));\n        }\n        return new Color_1(code, 'hex');\n    };\n\n    var log$1 = Math.log;\n    var pow$7 = Math.pow;\n    var floor$3 = Math.floor;\n    var abs = Math.abs;\n\n\n    var analyze = function (data, key) {\n        if ( key === void 0 ) key=null;\n\n        var r = {\n            min: Number.MAX_VALUE,\n            max: Number.MAX_VALUE*-1,\n            sum: 0,\n            values: [],\n            count: 0\n        };\n        if (type(data) === 'object') {\n            data = Object.values(data);\n        }\n        data.forEach(function (val) {\n            if (key && type(val) === 'object') { val = val[key]; }\n            if (val !== undefined && val !== null && !isNaN(val)) {\n                r.values.push(val);\n                r.sum += val;\n                if (val < r.min) { r.min = val; }\n                if (val > r.max) { r.max = val; }\n                r.count += 1;\n            }\n        });\n\n        r.domain = [r.min, r.max];\n\n        r.limits = function (mode, num) { return limits(r, mode, num); };\n\n        return r;\n    };\n\n\n    var limits = function (data, mode, num) {\n        if ( mode === void 0 ) mode='equal';\n        if ( num === void 0 ) num=7;\n\n        if (type(data) == 'array') {\n            data = analyze(data);\n        }\n        var min = data.min;\n        var max = data.max;\n        var values = data.values.sort(function (a,b) { return a-b; });\n\n        if (num === 1) { return [min,max]; }\n\n        var limits = [];\n\n        if (mode.substr(0,1) === 'c') { // continuous\n            limits.push(min);\n            limits.push(max);\n        }\n\n        if (mode.substr(0,1) === 'e') { // equal interval\n            limits.push(min);\n            for (var i=1; i<num; i++) {\n                limits.push(min+((i/num)*(max-min)));\n            }\n            limits.push(max);\n        }\n\n        else if (mode.substr(0,1) === 'l') { // log scale\n            if (min <= 0) {\n                throw new Error('Logarithmic scales are only possible for values > 0');\n            }\n            var min_log = Math.LOG10E * log$1(min);\n            var max_log = Math.LOG10E * log$1(max);\n            limits.push(min);\n            for (var i$1=1; i$1<num; i$1++) {\n                limits.push(pow$7(10, min_log + ((i$1/num) * (max_log - min_log))));\n            }\n            limits.push(max);\n        }\n\n        else if (mode.substr(0,1) === 'q') { // quantile scale\n            limits.push(min);\n            for (var i$2=1; i$2<num; i$2++) {\n                var p = ((values.length-1) * i$2)/num;\n                var pb = floor$3(p);\n                if (pb === p) {\n                    limits.push(values[pb]);\n                } else { // p > pb\n                    var pr = p - pb;\n                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));\n                }\n            }\n            limits.push(max);\n\n        }\n\n        else if (mode.substr(0,1) === 'k') { // k-means clustering\n            /*\n            implementation based on\n            http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n            simplified for 1-d input values\n            */\n            var cluster;\n            var n = values.length;\n            var assignments = new Array(n);\n            var clusterSizes = new Array(num);\n            var repeat = true;\n            var nb_iters = 0;\n            var centroids = null;\n\n            // get seed values\n            centroids = [];\n            centroids.push(min);\n            for (var i$3=1; i$3<num; i$3++) {\n                centroids.push(min + ((i$3/num) * (max-min)));\n            }\n            centroids.push(max);\n\n            while (repeat) {\n                // assignment step\n                for (var j=0; j<num; j++) {\n                    clusterSizes[j] = 0;\n                }\n                for (var i$4=0; i$4<n; i$4++) {\n                    var value = values[i$4];\n                    var mindist = Number.MAX_VALUE;\n                    var best = (void 0);\n                    for (var j$1=0; j$1<num; j$1++) {\n                        var dist = abs(centroids[j$1]-value);\n                        if (dist < mindist) {\n                            mindist = dist;\n                            best = j$1;\n                        }\n                        clusterSizes[best]++;\n                        assignments[i$4] = best;\n                    }\n                }\n\n                // update centroids step\n                var newCentroids = new Array(num);\n                for (var j$2=0; j$2<num; j$2++) {\n                    newCentroids[j$2] = null;\n                }\n                for (var i$5=0; i$5<n; i$5++) {\n                    cluster = assignments[i$5];\n                    if (newCentroids[cluster] === null) {\n                        newCentroids[cluster] = values[i$5];\n                    } else {\n                        newCentroids[cluster] += values[i$5];\n                    }\n                }\n                for (var j$3=0; j$3<num; j$3++) {\n                    newCentroids[j$3] *= 1/clusterSizes[j$3];\n                }\n\n                // check convergence\n                repeat = false;\n                for (var j$4=0; j$4<num; j$4++) {\n                    if (newCentroids[j$4] !== centroids[j$4]) {\n                        repeat = true;\n                        break;\n                    }\n                }\n\n                centroids = newCentroids;\n                nb_iters++;\n\n                if (nb_iters > 200) {\n                    repeat = false;\n                }\n            }\n\n            // finished k-means clustering\n            // the next part is borrowed from gabrielflor.it\n            var kClusters = {};\n            for (var j$5=0; j$5<num; j$5++) {\n                kClusters[j$5] = [];\n            }\n            for (var i$6=0; i$6<n; i$6++) {\n                cluster = assignments[i$6];\n                kClusters[cluster].push(values[i$6]);\n            }\n            var tmpKMeansBreaks = [];\n            for (var j$6=0; j$6<num; j$6++) {\n                tmpKMeansBreaks.push(kClusters[j$6][0]);\n                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);\n            }\n            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });\n            limits.push(tmpKMeansBreaks[0]);\n            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {\n                var v = tmpKMeansBreaks[i$7];\n                if (!isNaN(v) && (limits.indexOf(v) === -1)) {\n                    limits.push(v);\n                }\n            }\n        }\n        return limits;\n    };\n\n    var analyze_1 = {analyze: analyze, limits: limits};\n\n    var contrast = function (a, b) {\n        // WCAG contrast ratio\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var l1 = a.luminance();\n        var l2 = b.luminance();\n        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n    };\n\n    var sqrt$4 = Math.sqrt;\n    var atan2$2 = Math.atan2;\n    var abs$1 = Math.abs;\n    var cos$4 = Math.cos;\n    var PI$2 = Math.PI;\n\n    var deltaE = function(a, b, L, C) {\n        if ( L === void 0 ) L=1;\n        if ( C === void 0 ) C=1;\n\n        // Delta E (CMC)\n        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var ref = Array.from(a.lab());\n        var L1 = ref[0];\n        var a1 = ref[1];\n        var b1 = ref[2];\n        var ref$1 = Array.from(b.lab());\n        var L2 = ref$1[0];\n        var a2 = ref$1[1];\n        var b2 = ref$1[2];\n        var c1 = sqrt$4((a1 * a1) + (b1 * b1));\n        var c2 = sqrt$4((a2 * a2) + (b2 * b2));\n        var sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + (0.01765 * L1));\n        var sc = ((0.0638 * c1) / (1.0 + (0.0131 * c1))) + 0.638;\n        var h1 = c1 < 0.000001 ? 0.0 : (atan2$2(b1, a1) * 180.0) / PI$2;\n        while (h1 < 0) { h1 += 360; }\n        while (h1 >= 360) { h1 -= 360; }\n        var t = (h1 >= 164.0) && (h1 <= 345.0) ? (0.56 + abs$1(0.2 * cos$4((PI$2 * (h1 + 168.0)) / 180.0))) : (0.36 + abs$1(0.4 * cos$4((PI$2 * (h1 + 35.0)) / 180.0)));\n        var c4 = c1 * c1 * c1 * c1;\n        var f = sqrt$4(c4 / (c4 + 1900.0));\n        var sh = sc * (((f * t) + 1.0) - f);\n        var delL = L1 - L2;\n        var delC = c1 - c2;\n        var delA = a1 - a2;\n        var delB = b1 - b2;\n        var dH2 = ((delA * delA) + (delB * delB)) - (delC * delC);\n        var v1 = delL / (L * sl);\n        var v2 = delC / (C * sc);\n        var v3 = sh;\n        return sqrt$4((v1 * v1) + (v2 * v2) + (dH2 / (v3 * v3)));\n    };\n\n    // simple Euclidean distance\n    var distance = function(a, b, mode) {\n        if ( mode === void 0 ) mode='lab';\n\n        // Delta E (CIE 1976)\n        // see http://www.brucelindbloom.com/index.html?Equations.html\n        a = new Color_1(a);\n        b = new Color_1(b);\n        var l1 = a.get(mode);\n        var l2 = b.get(mode);\n        var sum_sq = 0;\n        for (var i in l1) {\n            var d = (l1[i] || 0) - (l2[i] || 0);\n            sum_sq += d*d;\n        }\n        return Math.sqrt(sum_sq);\n    };\n\n    var valid = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        try {\n            new (Function.prototype.bind.apply( Color_1, [ null ].concat( args) ));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // some pre-defined color scales:\n\n\n\n\n    var scales = {\n    \tcool: function cool() { return scale([chroma_1.hsl(180,1,.9), chroma_1.hsl(250,.7,.4)]) },\n    \thot: function hot() { return scale(['#000','#f00','#ff0','#fff'], [0,.25,.75,1]).mode('rgb') }\n    };\n\n    /**\n        ColorBrewer colors for chroma.js\n\n        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n        Pennsylvania State University.\n\n        Licensed under the Apache License, Version 2.0 (the \"License\");\n        you may not use this file except in compliance with the License.\n        You may obtain a copy of the License at\n        http://www.apache.org/licenses/LICENSE-2.0\n\n        Unless required by applicable law or agreed to in writing, software distributed\n        under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n        CONDITIONS OF ANY KIND, either express or implied. See the License for the\n        specific language governing permissions and limitations under the License.\n    */\n\n    var colorbrewer = {\n        // sequential\n        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n\n        // diverging\n\n        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n\n        // qualitative\n\n        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],\n    };\n\n    // add lowercase aliases for case-insensitive matches\n    for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\n        var key = list$1[i$1];\n\n        colorbrewer[key.toLowerCase()] = colorbrewer[key];\n    }\n\n    var colorbrewer_1 = colorbrewer;\n\n    // feel free to comment out anything to rollup\n    // a smaller chroma.js built\n\n    // io --> convert colors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // operators --> modify existing Colors\n\n\n\n\n\n\n\n\n\n\n    // interpolators\n\n\n\n\n\n\n\n\n\n\n    // generators -- > create new colors\n    chroma_1.average = average;\n    chroma_1.bezier = bezier_1;\n    chroma_1.blend = blend_1;\n    chroma_1.cubehelix = cubehelix;\n    chroma_1.mix = chroma_1.interpolate = mix;\n    chroma_1.random = random_1;\n    chroma_1.scale = scale;\n\n    // other utility methods\n    chroma_1.analyze = analyze_1.analyze;\n    chroma_1.contrast = contrast;\n    chroma_1.deltaE = deltaE;\n    chroma_1.distance = distance;\n    chroma_1.limits = analyze_1.limits;\n    chroma_1.valid = valid;\n\n    // scale\n    chroma_1.scales = scales;\n\n    // colors\n    chroma_1.colors = w3cx11_1;\n    chroma_1.brewer = colorbrewer_1;\n\n    var chroma_js = chroma_1;\n\n    return chroma_js;\n\n})));\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define('Chartist', [], function () {\n      return (root['Chartist'] = factory());\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Chartist'] = factory();\n  }\n}(this, function () {\n\n/* Chartist.js 0.11.4\n * Copyright © 2019 Gion Kunz\n * Free to use under either the WTFPL license or the MIT license.\n * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-WTFPL\n * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-MIT\n */\n/**\n * The core module of Chartist that is mainly providing static functions and higher level functions for chart modules.\n *\n * @module Chartist.Core\n */\nvar Chartist = {\n  version: '0.11.4'\n};\n\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * This object contains all namespaces used within Chartist.\n   *\n   * @memberof Chartist.Core\n   * @type {{svg: string, xmlns: string, xhtml: string, xlink: string, ct: string}}\n   */\n  Chartist.namespaces = {\n    svg: 'http://www.w3.org/2000/svg',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xhtml: 'http://www.w3.org/1999/xhtml',\n    xlink: 'http://www.w3.org/1999/xlink',\n    ct: 'http://gionkunz.github.com/chartist-js/ct'\n  };\n\n  /**\n   * Helps to simplify functional style code\n   *\n   * @memberof Chartist.Core\n   * @param {*} n This exact value will be returned by the noop function\n   * @return {*} The same value that was provided to the n parameter\n   */\n  Chartist.noop = function (n) {\n    return n;\n  };\n\n  /**\n   * Generates a-z from a number 0 to 26\n   *\n   * @memberof Chartist.Core\n   * @param {Number} n A number from 0 to 26 that will result in a letter a-z\n   * @return {String} A character from a-z based on the input number n\n   */\n  Chartist.alphaNumerate = function (n) {\n    // Limit to a-z\n    return String.fromCharCode(97 + n % 26);\n  };\n\n  /**\n   * Simple recursive object extend\n   *\n   * @memberof Chartist.Core\n   * @param {Object} target Target object where the source will be merged into\n   * @param {Object...} sources This object (objects) will be merged into target and then target is returned\n   * @return {Object} An object that has the same reference as target but is extended and merged with the properties of source\n   */\n  Chartist.extend = function (target) {\n    var i, source, sourceProp;\n    target = target || {};\n\n    for (i = 1; i < arguments.length; i++) {\n      source = arguments[i];\n      for (var prop in source) {\n        sourceProp = source[prop];\n        if (typeof sourceProp === 'object' && sourceProp !== null && !(sourceProp instanceof Array)) {\n          target[prop] = Chartist.extend(target[prop], sourceProp);\n        } else {\n          target[prop] = sourceProp;\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Replaces all occurrences of subStr in str with newSubStr and returns a new string.\n   *\n   * @memberof Chartist.Core\n   * @param {String} str\n   * @param {String} subStr\n   * @param {String} newSubStr\n   * @return {String}\n   */\n  Chartist.replaceAll = function(str, subStr, newSubStr) {\n    return str.replace(new RegExp(subStr, 'g'), newSubStr);\n  };\n\n  /**\n   * Converts a number to a string with a unit. If a string is passed then this will be returned unmodified.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} value\n   * @param {String} unit\n   * @return {String} Returns the passed number value with unit.\n   */\n  Chartist.ensureUnit = function(value, unit) {\n    if(typeof value === 'number') {\n      value = value + unit;\n    }\n\n    return value;\n  };\n\n  /**\n   * Converts a number or string to a quantity object.\n   *\n   * @memberof Chartist.Core\n   * @param {String|Number} input\n   * @return {Object} Returns an object containing the value as number and the unit as string.\n   */\n  Chartist.quantity = function(input) {\n    if (typeof input === 'string') {\n      var match = (/^(\\d+)\\s*(.*)$/g).exec(input);\n      return {\n        value : +match[1],\n        unit: match[2] || undefined\n      };\n    }\n    return { value: input };\n  };\n\n  /**\n   * This is a wrapper around document.querySelector that will return the query if it's already of type Node\n   *\n   * @memberof Chartist.Core\n   * @param {String|Node} query The query to use for selecting a Node or a DOM node that will be returned directly\n   * @return {Node}\n   */\n  Chartist.querySelector = function(query) {\n    return query instanceof Node ? query : document.querySelector(query);\n  };\n\n  /**\n   * Functional style helper to produce array with given length initialized with undefined values\n   *\n   * @memberof Chartist.Core\n   * @param length\n   * @return {Array}\n   */\n  Chartist.times = function(length) {\n    return Array.apply(null, new Array(length));\n  };\n\n  /**\n   * Sum helper to be used in reduce functions\n   *\n   * @memberof Chartist.Core\n   * @param previous\n   * @param current\n   * @return {*}\n   */\n  Chartist.sum = function(previous, current) {\n    return previous + (current ? current : 0);\n  };\n\n  /**\n   * Multiply helper to be used in `Array.map` for multiplying each value of an array with a factor.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} factor\n   * @returns {Function} Function that can be used in `Array.map` to multiply each value in an array\n   */\n  Chartist.mapMultiply = function(factor) {\n    return function(num) {\n      return num * factor;\n    };\n  };\n\n  /**\n   * Add helper to be used in `Array.map` for adding a addend to each value of an array.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} addend\n   * @returns {Function} Function that can be used in `Array.map` to add a addend to each value in an array\n   */\n  Chartist.mapAdd = function(addend) {\n    return function(num) {\n      return num + addend;\n    };\n  };\n\n  /**\n   * Map for multi dimensional arrays where their nested arrays will be mapped in serial. The output array will have the length of the largest nested array. The callback function is called with variable arguments where each argument is the nested array value (or undefined if there are no more values).\n   *\n   * @memberof Chartist.Core\n   * @param arr\n   * @param cb\n   * @return {Array}\n   */\n  Chartist.serialMap = function(arr, cb) {\n    var result = [],\n        length = Math.max.apply(null, arr.map(function(e) {\n          return e.length;\n        }));\n\n    Chartist.times(length).forEach(function(e, index) {\n      var args = arr.map(function(e) {\n        return e[index];\n      });\n\n      result[index] = cb.apply(null, args);\n    });\n\n    return result;\n  };\n\n  /**\n   * This helper function can be used to round values with certain precision level after decimal. This is used to prevent rounding errors near float point precision limit.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} value The value that should be rounded with precision\n   * @param {Number} [digits] The number of digits after decimal used to do the rounding\n   * @returns {number} Rounded value\n   */\n  Chartist.roundWithPrecision = function(value, digits) {\n    var precision = Math.pow(10, digits || Chartist.precision);\n    return Math.round(value * precision) / precision;\n  };\n\n  /**\n   * Precision level used internally in Chartist for rounding. If you require more decimal places you can increase this number.\n   *\n   * @memberof Chartist.Core\n   * @type {number}\n   */\n  Chartist.precision = 8;\n\n  /**\n   * A map with characters to escape for strings to be safely used as attribute values.\n   *\n   * @memberof Chartist.Core\n   * @type {Object}\n   */\n  Chartist.escapingMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#039;'\n  };\n\n  /**\n   * This function serializes arbitrary data to a string. In case of data that can't be easily converted to a string, this function will create a wrapper object and serialize the data using JSON.stringify. The outcoming string will always be escaped using Chartist.escapingMap.\n   * If called with null or undefined the function will return immediately with null or undefined.\n   *\n   * @memberof Chartist.Core\n   * @param {Number|String|Object} data\n   * @return {String}\n   */\n  Chartist.serialize = function(data) {\n    if(data === null || data === undefined) {\n      return data;\n    } else if(typeof data === 'number') {\n      data = ''+data;\n    } else if(typeof data === 'object') {\n      data = JSON.stringify({data: data});\n    }\n\n    return Object.keys(Chartist.escapingMap).reduce(function(result, key) {\n      return Chartist.replaceAll(result, key, Chartist.escapingMap[key]);\n    }, data);\n  };\n\n  /**\n   * This function de-serializes a string previously serialized with Chartist.serialize. The string will always be unescaped using Chartist.escapingMap before it's returned. Based on the input value the return type can be Number, String or Object. JSON.parse is used with try / catch to see if the unescaped string can be parsed into an Object and this Object will be returned on success.\n   *\n   * @memberof Chartist.Core\n   * @param {String} data\n   * @return {String|Number|Object}\n   */\n  Chartist.deserialize = function(data) {\n    if(typeof data !== 'string') {\n      return data;\n    }\n\n    data = Object.keys(Chartist.escapingMap).reduce(function(result, key) {\n      return Chartist.replaceAll(result, Chartist.escapingMap[key], key);\n    }, data);\n\n    try {\n      data = JSON.parse(data);\n      data = data.data !== undefined ? data.data : data;\n    } catch(e) {}\n\n    return data;\n  };\n\n  /**\n   * Create or reinitialize the SVG element for the chart\n   *\n   * @memberof Chartist.Core\n   * @param {Node} container The containing DOM Node object that will be used to plant the SVG element\n   * @param {String} width Set the width of the SVG element. Default is 100%\n   * @param {String} height Set the height of the SVG element. Default is 100%\n   * @param {String} className Specify a class to be added to the SVG element\n   * @return {Object} The created/reinitialized SVG element\n   */\n  Chartist.createSvg = function (container, width, height, className) {\n    var svg;\n\n    width = width || '100%';\n    height = height || '100%';\n\n    // Check if there is a previous SVG element in the container that contains the Chartist XML namespace and remove it\n    // Since the DOM API does not support namespaces we need to manually search the returned list http://www.w3.org/TR/selectors-api/\n    Array.prototype.slice.call(container.querySelectorAll('svg')).filter(function filterChartistSvgObjects(svg) {\n      return svg.getAttributeNS(Chartist.namespaces.xmlns, 'ct');\n    }).forEach(function removePreviousElement(svg) {\n      container.removeChild(svg);\n    });\n\n    // Create svg object with width and height or use 100% as default\n    svg = new Chartist.Svg('svg').attr({\n      width: width,\n      height: height\n    }).addClass(className);\n\n    svg._node.style.width = width;\n    svg._node.style.height = height;\n\n    // Add the DOM node to our container\n    container.appendChild(svg._node);\n\n    return svg;\n  };\n\n  /**\n   * Ensures that the data object passed as second argument to the charts is present and correctly initialized.\n   *\n   * @param  {Object} data The data object that is passed as second argument to the charts\n   * @return {Object} The normalized data object\n   */\n  Chartist.normalizeData = function(data, reverse, multi) {\n    var labelCount;\n    var output = {\n      raw: data,\n      normalized: {}\n    };\n\n    // Check if we should generate some labels based on existing series data\n    output.normalized.series = Chartist.getDataArray({\n      series: data.series || []\n    }, reverse, multi);\n\n    // If all elements of the normalized data array are arrays we're dealing with\n    // multi series data and we need to find the largest series if they are un-even\n    if (output.normalized.series.every(function(value) {\n        return value instanceof Array;\n      })) {\n      // Getting the series with the the most elements\n      labelCount = Math.max.apply(null, output.normalized.series.map(function(series) {\n        return series.length;\n      }));\n    } else {\n      // We're dealing with Pie data so we just take the normalized array length\n      labelCount = output.normalized.series.length;\n    }\n\n    output.normalized.labels = (data.labels || []).slice();\n    // Padding the labels to labelCount with empty strings\n    Array.prototype.push.apply(\n      output.normalized.labels,\n      Chartist.times(Math.max(0, labelCount - output.normalized.labels.length)).map(function() {\n        return '';\n      })\n    );\n\n    if(reverse) {\n      Chartist.reverseData(output.normalized);\n    }\n\n    return output;\n  };\n\n  /**\n   * This function safely checks if an objects has an owned property.\n   *\n   * @param {Object} object The object where to check for a property\n   * @param {string} property The property name\n   * @returns {boolean} Returns true if the object owns the specified property\n   */\n  Chartist.safeHasProperty = function(object, property) {\n    return object !== null &&\n      typeof object === 'object' &&\n      object.hasOwnProperty(property);\n  };\n\n  /**\n   * Checks if a value is considered a hole in the data series.\n   *\n   * @param {*} value\n   * @returns {boolean} True if the value is considered a data hole\n   */\n  Chartist.isDataHoleValue = function(value) {\n    return value === null ||\n      value === undefined ||\n      (typeof value === 'number' && isNaN(value));\n  };\n\n  /**\n   * Reverses the series, labels and series data arrays.\n   *\n   * @memberof Chartist.Core\n   * @param data\n   */\n  Chartist.reverseData = function(data) {\n    data.labels.reverse();\n    data.series.reverse();\n    for (var i = 0; i < data.series.length; i++) {\n      if(typeof(data.series[i]) === 'object' && data.series[i].data !== undefined) {\n        data.series[i].data.reverse();\n      } else if(data.series[i] instanceof Array) {\n        data.series[i].reverse();\n      }\n    }\n  };\n\n  /**\n   * Convert data series into plain array\n   *\n   * @memberof Chartist.Core\n   * @param {Object} data The series object that contains the data to be visualized in the chart\n   * @param {Boolean} [reverse] If true the whole data is reversed by the getDataArray call. This will modify the data object passed as first parameter. The labels as well as the series order is reversed. The whole series data arrays are reversed too.\n   * @param {Boolean} [multi] Create a multi dimensional array from a series data array where a value object with `x` and `y` values will be created.\n   * @return {Array} A plain array that contains the data to be visualized in the chart\n   */\n  Chartist.getDataArray = function(data, reverse, multi) {\n    // Recursively walks through nested arrays and convert string values to numbers and objects with value properties\n    // to values. Check the tests in data core -> data normalization for a detailed specification of expected values\n    function recursiveConvert(value) {\n      if(Chartist.safeHasProperty(value, 'value')) {\n        // We are dealing with value object notation so we need to recurse on value property\n        return recursiveConvert(value.value);\n      } else if(Chartist.safeHasProperty(value, 'data')) {\n        // We are dealing with series object notation so we need to recurse on data property\n        return recursiveConvert(value.data);\n      } else if(value instanceof Array) {\n        // Data is of type array so we need to recurse on the series\n        return value.map(recursiveConvert);\n      } else if(Chartist.isDataHoleValue(value)) {\n        // We're dealing with a hole in the data and therefore need to return undefined\n        // We're also returning undefined for multi value output\n        return undefined;\n      } else {\n        // We need to prepare multi value output (x and y data)\n        if(multi) {\n          var multiValue = {};\n\n          // Single series value arrays are assumed to specify the Y-Axis value\n          // For example: [1, 2] => [{x: undefined, y: 1}, {x: undefined, y: 2}]\n          // If multi is a string then it's assumed that it specified which dimension should be filled as default\n          if(typeof multi === 'string') {\n            multiValue[multi] = Chartist.getNumberOrUndefined(value);\n          } else {\n            multiValue.y = Chartist.getNumberOrUndefined(value);\n          }\n\n          multiValue.x = value.hasOwnProperty('x') ? Chartist.getNumberOrUndefined(value.x) : multiValue.x;\n          multiValue.y = value.hasOwnProperty('y') ? Chartist.getNumberOrUndefined(value.y) : multiValue.y;\n\n          return multiValue;\n\n        } else {\n          // We can return simple data\n          return Chartist.getNumberOrUndefined(value);\n        }\n      }\n    }\n\n    return data.series.map(recursiveConvert);\n  };\n\n  /**\n   * Converts a number into a padding object.\n   *\n   * @memberof Chartist.Core\n   * @param {Object|Number} padding\n   * @param {Number} [fallback] This value is used to fill missing values if a incomplete padding object was passed\n   * @returns {Object} Returns a padding object containing top, right, bottom, left properties filled with the padding number passed in as argument. If the argument is something else than a number (presumably already a correct padding object) then this argument is directly returned.\n   */\n  Chartist.normalizePadding = function(padding, fallback) {\n    fallback = fallback || 0;\n\n    return typeof padding === 'number' ? {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    } : {\n      top: typeof padding.top === 'number' ? padding.top : fallback,\n      right: typeof padding.right === 'number' ? padding.right : fallback,\n      bottom: typeof padding.bottom === 'number' ? padding.bottom : fallback,\n      left: typeof padding.left === 'number' ? padding.left : fallback\n    };\n  };\n\n  Chartist.getMetaData = function(series, index) {\n    var value = series.data ? series.data[index] : series[index];\n    return value ? value.meta : undefined;\n  };\n\n  /**\n   * Calculate the order of magnitude for the chart scale\n   *\n   * @memberof Chartist.Core\n   * @param {Number} value The value Range of the chart\n   * @return {Number} The order of magnitude\n   */\n  Chartist.orderOfMagnitude = function (value) {\n    return Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  };\n\n  /**\n   * Project a data length into screen coordinates (pixels)\n   *\n   * @memberof Chartist.Core\n   * @param {Object} axisLength The svg element for the chart\n   * @param {Number} length Single data value from a series array\n   * @param {Object} bounds All the values to set the bounds of the chart\n   * @return {Number} The projected data length in pixels\n   */\n  Chartist.projectLength = function (axisLength, length, bounds) {\n    return length / bounds.range * axisLength;\n  };\n\n  /**\n   * Get the height of the area in the chart for the data series\n   *\n   * @memberof Chartist.Core\n   * @param {Object} svg The svg element for the chart\n   * @param {Object} options The Object that contains all the optional values for the chart\n   * @return {Number} The height of the area in the chart for the data series\n   */\n  Chartist.getAvailableHeight = function (svg, options) {\n    return Math.max((Chartist.quantity(options.height).value || svg.height()) - (options.chartPadding.top +  options.chartPadding.bottom) - options.axisX.offset, 0);\n  };\n\n  /**\n   * Get highest and lowest value of data array. This Array contains the data that will be visualized in the chart.\n   *\n   * @memberof Chartist.Core\n   * @param {Array} data The array that contains the data to be visualized in the chart\n   * @param {Object} options The Object that contains the chart options\n   * @param {String} dimension Axis dimension 'x' or 'y' used to access the correct value and high / low configuration\n   * @return {Object} An object that contains the highest and lowest value that will be visualized on the chart.\n   */\n  Chartist.getHighLow = function (data, options, dimension) {\n    // TODO: Remove workaround for deprecated global high / low config. Axis high / low configuration is preferred\n    options = Chartist.extend({}, options, dimension ? options['axis' + dimension.toUpperCase()] : {});\n\n    var highLow = {\n        high: options.high === undefined ? -Number.MAX_VALUE : +options.high,\n        low: options.low === undefined ? Number.MAX_VALUE : +options.low\n      };\n    var findHigh = options.high === undefined;\n    var findLow = options.low === undefined;\n\n    // Function to recursively walk through arrays and find highest and lowest number\n    function recursiveHighLow(data) {\n      if(data === undefined) {\n        return undefined;\n      } else if(data instanceof Array) {\n        for (var i = 0; i < data.length; i++) {\n          recursiveHighLow(data[i]);\n        }\n      } else {\n        var value = dimension ? +data[dimension] : +data;\n\n        if (findHigh && value > highLow.high) {\n          highLow.high = value;\n        }\n\n        if (findLow && value < highLow.low) {\n          highLow.low = value;\n        }\n      }\n    }\n\n    // Start to find highest and lowest number recursively\n    if(findHigh || findLow) {\n      recursiveHighLow(data);\n    }\n\n    // Overrides of high / low based on reference value, it will make sure that the invisible reference value is\n    // used to generate the chart. This is useful when the chart always needs to contain the position of the\n    // invisible reference value in the view i.e. for bipolar scales.\n    if (options.referenceValue || options.referenceValue === 0) {\n      highLow.high = Math.max(options.referenceValue, highLow.high);\n      highLow.low = Math.min(options.referenceValue, highLow.low);\n    }\n\n    // If high and low are the same because of misconfiguration or flat data (only the same value) we need\n    // to set the high or low to 0 depending on the polarity\n    if (highLow.high <= highLow.low) {\n      // If both values are 0 we set high to 1\n      if (highLow.low === 0) {\n        highLow.high = 1;\n      } else if (highLow.low < 0) {\n        // If we have the same negative value for the bounds we set bounds.high to 0\n        highLow.high = 0;\n      } else if (highLow.high > 0) {\n        // If we have the same positive value for the bounds we set bounds.low to 0\n        highLow.low = 0;\n      } else {\n        // If data array was empty, values are Number.MAX_VALUE and -Number.MAX_VALUE. Set bounds to prevent errors\n        highLow.high = 1;\n        highLow.low = 0;\n      }\n    }\n\n    return highLow;\n  };\n\n  /**\n   * Checks if a value can be safely coerced to a number. This includes all values except null which result in finite numbers when coerced. This excludes NaN, since it's not finite.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @returns {Boolean}\n   */\n  Chartist.isNumeric = function(value) {\n    return value === null ? false : isFinite(value);\n  };\n\n  /**\n   * Returns true on all falsey values except the numeric value 0.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @returns {boolean}\n   */\n  Chartist.isFalseyButZero = function(value) {\n    return !value && value !== 0;\n  };\n\n  /**\n   * Returns a number if the passed parameter is a valid number or the function will return undefined. On all other values than a valid number, this function will return undefined.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @returns {*}\n   */\n  Chartist.getNumberOrUndefined = function(value) {\n    return Chartist.isNumeric(value) ? +value : undefined;\n  };\n\n  /**\n   * Checks if provided value object is multi value (contains x or y properties)\n   *\n   * @memberof Chartist.Core\n   * @param value\n   */\n  Chartist.isMultiValue = function(value) {\n    return typeof value === 'object' && ('x' in value || 'y' in value);\n  };\n\n  /**\n   * Gets a value from a dimension `value.x` or `value.y` while returning value directly if it's a valid numeric value. If the value is not numeric and it's falsey this function will return `defaultValue`.\n   *\n   * @memberof Chartist.Core\n   * @param value\n   * @param dimension\n   * @param defaultValue\n   * @returns {*}\n   */\n  Chartist.getMultiValue = function(value, dimension) {\n    if(Chartist.isMultiValue(value)) {\n      return Chartist.getNumberOrUndefined(value[dimension || 'y']);\n    } else {\n      return Chartist.getNumberOrUndefined(value);\n    }\n  };\n\n  /**\n   * Pollard Rho Algorithm to find smallest factor of an integer value. There are more efficient algorithms for factorization, but this one is quite efficient and not so complex.\n   *\n   * @memberof Chartist.Core\n   * @param {Number} num An integer number where the smallest factor should be searched for\n   * @returns {Number} The smallest integer factor of the parameter num.\n   */\n  Chartist.rho = function(num) {\n    if(num === 1) {\n      return num;\n    }\n\n    function gcd(p, q) {\n      if (p % q === 0) {\n        return q;\n      } else {\n        return gcd(q, p % q);\n      }\n    }\n\n    function f(x) {\n      return x * x + 1;\n    }\n\n    var x1 = 2, x2 = 2, divisor;\n    if (num % 2 === 0) {\n      return 2;\n    }\n\n    do {\n      x1 = f(x1) % num;\n      x2 = f(f(x2)) % num;\n      divisor = gcd(Math.abs(x1 - x2), num);\n    } while (divisor === 1);\n\n    return divisor;\n  };\n\n  /**\n   * Calculate and retrieve all the bounds for the chart and return them in one array\n   *\n   * @memberof Chartist.Core\n   * @param {Number} axisLength The length of the Axis used for\n   * @param {Object} highLow An object containing a high and low property indicating the value range of the chart.\n   * @param {Number} scaleMinSpace The minimum projected length a step should result in\n   * @param {Boolean} onlyInteger\n   * @return {Object} All the values to set the bounds of the chart\n   */\n  Chartist.getBounds = function (axisLength, highLow, scaleMinSpace, onlyInteger) {\n    var i,\n      optimizationCounter = 0,\n      newMin,\n      newMax,\n      bounds = {\n        high: highLow.high,\n        low: highLow.low\n      };\n\n    bounds.valueRange = bounds.high - bounds.low;\n    bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);\n    bounds.step = Math.pow(10, bounds.oom);\n    bounds.min = Math.floor(bounds.low / bounds.step) * bounds.step;\n    bounds.max = Math.ceil(bounds.high / bounds.step) * bounds.step;\n    bounds.range = bounds.max - bounds.min;\n    bounds.numberOfSteps = Math.round(bounds.range / bounds.step);\n\n    // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace\n    // If we are already below the scaleMinSpace value we will scale up\n    var length = Chartist.projectLength(axisLength, bounds.step, bounds);\n    var scaleUp = length < scaleMinSpace;\n    var smallestFactor = onlyInteger ? Chartist.rho(bounds.range) : 0;\n\n    // First check if we should only use integer steps and if step 1 is still larger than scaleMinSpace so we can use 1\n    if(onlyInteger && Chartist.projectLength(axisLength, 1, bounds) >= scaleMinSpace) {\n      bounds.step = 1;\n    } else if(onlyInteger && smallestFactor < bounds.step && Chartist.projectLength(axisLength, smallestFactor, bounds) >= scaleMinSpace) {\n      // If step 1 was too small, we can try the smallest factor of range\n      // If the smallest factor is smaller than the current bounds.step and the projected length of smallest factor\n      // is larger than the scaleMinSpace we should go for it.\n      bounds.step = smallestFactor;\n    } else {\n      // Trying to divide or multiply by 2 and find the best step value\n      while (true) {\n        if (scaleUp && Chartist.projectLength(axisLength, bounds.step, bounds) <= scaleMinSpace) {\n          bounds.step *= 2;\n        } else if (!scaleUp && Chartist.projectLength(axisLength, bounds.step / 2, bounds) >= scaleMinSpace) {\n          bounds.step /= 2;\n          if(onlyInteger && bounds.step % 1 !== 0) {\n            bounds.step *= 2;\n            break;\n          }\n        } else {\n          break;\n        }\n\n        if(optimizationCounter++ > 1000) {\n          throw new Error('Exceeded maximum number of iterations while optimizing scale step!');\n        }\n      }\n    }\n\n    var EPSILON = 2.221E-16;\n    bounds.step = Math.max(bounds.step, EPSILON);\n    function safeIncrement(value, increment) {\n      // If increment is too small use *= (1+EPSILON) as a simple nextafter\n      if (value === (value += increment)) {\n      \tvalue *= (1 + (increment > 0 ? EPSILON : -EPSILON));\n      }\n      return value;\n    }\n\n    // Narrow min and max based on new step\n    newMin = bounds.min;\n    newMax = bounds.max;\n    while (newMin + bounds.step <= bounds.low) {\n    \tnewMin = safeIncrement(newMin, bounds.step);\n    }\n    while (newMax - bounds.step >= bounds.high) {\n    \tnewMax = safeIncrement(newMax, -bounds.step);\n    }\n    bounds.min = newMin;\n    bounds.max = newMax;\n    bounds.range = bounds.max - bounds.min;\n\n    var values = [];\n    for (i = bounds.min; i <= bounds.max; i = safeIncrement(i, bounds.step)) {\n      var value = Chartist.roundWithPrecision(i);\n      if (value !== values[values.length - 1]) {\n        values.push(value);\n      }\n    }\n    bounds.values = values;\n    return bounds;\n  };\n\n  /**\n   * Calculate cartesian coordinates of polar coordinates\n   *\n   * @memberof Chartist.Core\n   * @param {Number} centerX X-axis coordinates of center point of circle segment\n   * @param {Number} centerY X-axis coordinates of center point of circle segment\n   * @param {Number} radius Radius of circle segment\n   * @param {Number} angleInDegrees Angle of circle segment in degrees\n   * @return {{x:Number, y:Number}} Coordinates of point on circumference\n   */\n  Chartist.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {\n    var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n\n    return {\n      x: centerX + (radius * Math.cos(angleInRadians)),\n      y: centerY + (radius * Math.sin(angleInRadians))\n    };\n  };\n\n  /**\n   * Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right\n   *\n   * @memberof Chartist.Core\n   * @param {Object} svg The svg element for the chart\n   * @param {Object} options The Object that contains all the optional values for the chart\n   * @param {Number} [fallbackPadding] The fallback padding if partial padding objects are used\n   * @return {Object} The chart rectangles coordinates inside the svg element plus the rectangles measurements\n   */\n  Chartist.createChartRect = function (svg, options, fallbackPadding) {\n    var hasAxis = !!(options.axisX || options.axisY);\n    var yAxisOffset = hasAxis ? options.axisY.offset : 0;\n    var xAxisOffset = hasAxis ? options.axisX.offset : 0;\n    // If width or height results in invalid value (including 0) we fallback to the unitless settings or even 0\n    var width = svg.width() || Chartist.quantity(options.width).value || 0;\n    var height = svg.height() || Chartist.quantity(options.height).value || 0;\n    var normalizedPadding = Chartist.normalizePadding(options.chartPadding, fallbackPadding);\n\n    // If settings were to small to cope with offset (legacy) and padding, we'll adjust\n    width = Math.max(width, yAxisOffset + normalizedPadding.left + normalizedPadding.right);\n    height = Math.max(height, xAxisOffset + normalizedPadding.top + normalizedPadding.bottom);\n\n    var chartRect = {\n      padding: normalizedPadding,\n      width: function () {\n        return this.x2 - this.x1;\n      },\n      height: function () {\n        return this.y1 - this.y2;\n      }\n    };\n\n    if(hasAxis) {\n      if (options.axisX.position === 'start') {\n        chartRect.y2 = normalizedPadding.top + xAxisOffset;\n        chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);\n      } else {\n        chartRect.y2 = normalizedPadding.top;\n        chartRect.y1 = Math.max(height - normalizedPadding.bottom - xAxisOffset, chartRect.y2 + 1);\n      }\n\n      if (options.axisY.position === 'start') {\n        chartRect.x1 = normalizedPadding.left + yAxisOffset;\n        chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);\n      } else {\n        chartRect.x1 = normalizedPadding.left;\n        chartRect.x2 = Math.max(width - normalizedPadding.right - yAxisOffset, chartRect.x1 + 1);\n      }\n    } else {\n      chartRect.x1 = normalizedPadding.left;\n      chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);\n      chartRect.y2 = normalizedPadding.top;\n      chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);\n    }\n\n    return chartRect;\n  };\n\n  /**\n   * Creates a grid line based on a projected value.\n   *\n   * @memberof Chartist.Core\n   * @param position\n   * @param index\n   * @param axis\n   * @param offset\n   * @param length\n   * @param group\n   * @param classes\n   * @param eventEmitter\n   */\n  Chartist.createGrid = function(position, index, axis, offset, length, group, classes, eventEmitter) {\n    var positionalData = {};\n    positionalData[axis.units.pos + '1'] = position;\n    positionalData[axis.units.pos + '2'] = position;\n    positionalData[axis.counterUnits.pos + '1'] = offset;\n    positionalData[axis.counterUnits.pos + '2'] = offset + length;\n\n    var gridElement = group.elem('line', positionalData, classes.join(' '));\n\n    // Event for grid draw\n    eventEmitter.emit('draw',\n      Chartist.extend({\n        type: 'grid',\n        axis: axis,\n        index: index,\n        group: group,\n        element: gridElement\n      }, positionalData)\n    );\n  };\n\n  /**\n   * Creates a grid background rect and emits the draw event.\n   *\n   * @memberof Chartist.Core\n   * @param gridGroup\n   * @param chartRect\n   * @param className\n   * @param eventEmitter\n   */\n  Chartist.createGridBackground = function (gridGroup, chartRect, className, eventEmitter) {\n    var gridBackground = gridGroup.elem('rect', {\n        x: chartRect.x1,\n        y: chartRect.y2,\n        width: chartRect.width(),\n        height: chartRect.height(),\n      }, className, true);\n\n      // Event for grid background draw\n      eventEmitter.emit('draw', {\n        type: 'gridBackground',\n        group: gridGroup,\n        element: gridBackground\n      });\n  };\n\n  /**\n   * Creates a label based on a projected value and an axis.\n   *\n   * @memberof Chartist.Core\n   * @param position\n   * @param length\n   * @param index\n   * @param labels\n   * @param axis\n   * @param axisOffset\n   * @param labelOffset\n   * @param group\n   * @param classes\n   * @param useForeignObject\n   * @param eventEmitter\n   */\n  Chartist.createLabel = function(position, length, index, labels, axis, axisOffset, labelOffset, group, classes, useForeignObject, eventEmitter) {\n    var labelElement;\n    var positionalData = {};\n\n    positionalData[axis.units.pos] = position + labelOffset[axis.units.pos];\n    positionalData[axis.counterUnits.pos] = labelOffset[axis.counterUnits.pos];\n    positionalData[axis.units.len] = length;\n    positionalData[axis.counterUnits.len] = Math.max(0, axisOffset - 10);\n\n    if(useForeignObject) {\n      // We need to set width and height explicitly to px as span will not expand with width and height being\n      // 100% in all browsers\n      var content = document.createElement('span');\n      content.className = classes.join(' ');\n      content.setAttribute('xmlns', Chartist.namespaces.xhtml);\n      content.innerText = labels[index];\n      content.style[axis.units.len] = Math.round(positionalData[axis.units.len]) + 'px';\n      content.style[axis.counterUnits.len] = Math.round(positionalData[axis.counterUnits.len]) + 'px';\n\n      labelElement = group.foreignObject(content, Chartist.extend({\n        style: 'overflow: visible;'\n      }, positionalData));\n    } else {\n      labelElement = group.elem('text', positionalData, classes.join(' ')).text(labels[index]);\n    }\n\n    eventEmitter.emit('draw', Chartist.extend({\n      type: 'label',\n      axis: axis,\n      index: index,\n      group: group,\n      element: labelElement,\n      text: labels[index]\n    }, positionalData));\n  };\n\n  /**\n   * Helper to read series specific options from options object. It automatically falls back to the global option if\n   * there is no option in the series options.\n   *\n   * @param {Object} series Series object\n   * @param {Object} options Chartist options object\n   * @param {string} key The options key that should be used to obtain the options\n   * @returns {*}\n   */\n  Chartist.getSeriesOption = function(series, options, key) {\n    if(series.name && options.series && options.series[series.name]) {\n      var seriesOptions = options.series[series.name];\n      return seriesOptions.hasOwnProperty(key) ? seriesOptions[key] : options[key];\n    } else {\n      return options[key];\n    }\n  };\n\n  /**\n   * Provides options handling functionality with callback for options changes triggered by responsive options and media query matches\n   *\n   * @memberof Chartist.Core\n   * @param {Object} options Options set by user\n   * @param {Array} responsiveOptions Optional functions to add responsive behavior to chart\n   * @param {Object} eventEmitter The event emitter that will be used to emit the options changed events\n   * @return {Object} The consolidated options object from the defaults, base and matching responsive options\n   */\n  Chartist.optionsProvider = function (options, responsiveOptions, eventEmitter) {\n    var baseOptions = Chartist.extend({}, options),\n      currentOptions,\n      mediaQueryListeners = [],\n      i;\n\n    function updateCurrentOptions(mediaEvent) {\n      var previousOptions = currentOptions;\n      currentOptions = Chartist.extend({}, baseOptions);\n\n      if (responsiveOptions) {\n        for (i = 0; i < responsiveOptions.length; i++) {\n          var mql = window.matchMedia(responsiveOptions[i][0]);\n          if (mql.matches) {\n            currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);\n          }\n        }\n      }\n\n      if(eventEmitter && mediaEvent) {\n        eventEmitter.emit('optionsChanged', {\n          previousOptions: previousOptions,\n          currentOptions: currentOptions\n        });\n      }\n    }\n\n    function removeMediaQueryListeners() {\n      mediaQueryListeners.forEach(function(mql) {\n        mql.removeListener(updateCurrentOptions);\n      });\n    }\n\n    if (!window.matchMedia) {\n      throw 'window.matchMedia not found! Make sure you\\'re using a polyfill.';\n    } else if (responsiveOptions) {\n\n      for (i = 0; i < responsiveOptions.length; i++) {\n        var mql = window.matchMedia(responsiveOptions[i][0]);\n        mql.addListener(updateCurrentOptions);\n        mediaQueryListeners.push(mql);\n      }\n    }\n    // Execute initially without an event argument so we get the correct options\n    updateCurrentOptions();\n\n    return {\n      removeMediaQueryListeners: removeMediaQueryListeners,\n      getCurrentOptions: function getCurrentOptions() {\n        return Chartist.extend({}, currentOptions);\n      }\n    };\n  };\n\n\n  /**\n   * Splits a list of coordinates and associated values into segments. Each returned segment contains a pathCoordinates\n   * valueData property describing the segment.\n   *\n   * With the default options, segments consist of contiguous sets of points that do not have an undefined value. Any\n   * points with undefined values are discarded.\n   *\n   * **Options**\n   * The following options are used to determine how segments are formed\n   * ```javascript\n   * var options = {\n   *   // If fillHoles is true, undefined values are simply discarded without creating a new segment. Assuming other options are default, this returns single segment.\n   *   fillHoles: false,\n   *   // If increasingX is true, the coordinates in all segments have strictly increasing x-values.\n   *   increasingX: false\n   * };\n   * ```\n   *\n   * @memberof Chartist.Core\n   * @param {Array} pathCoordinates List of point coordinates to be split in the form [x1, y1, x2, y2 ... xn, yn]\n   * @param {Array} values List of associated point values in the form [v1, v2 .. vn]\n   * @param {Object} options Options set by user\n   * @return {Array} List of segments, each containing a pathCoordinates and valueData property.\n   */\n  Chartist.splitIntoSegments = function(pathCoordinates, valueData, options) {\n    var defaultOptions = {\n      increasingX: false,\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    var segments = [];\n    var hole = true;\n\n    for(var i = 0; i < pathCoordinates.length; i += 2) {\n      // If this value is a \"hole\" we set the hole flag\n      if(Chartist.getMultiValue(valueData[i / 2].value) === undefined) {\n      // if(valueData[i / 2].value === undefined) {\n        if(!options.fillHoles) {\n          hole = true;\n        }\n      } else {\n        if(options.increasingX && i >= 2 && pathCoordinates[i] <= pathCoordinates[i-2]) {\n          // X is not increasing, so we need to make sure we start a new segment\n          hole = true;\n        }\n\n\n        // If it's a valid value we need to check if we're coming out of a hole and create a new empty segment\n        if(hole) {\n          segments.push({\n            pathCoordinates: [],\n            valueData: []\n          });\n          // As we have a valid value now, we are not in a \"hole\" anymore\n          hole = false;\n        }\n\n        // Add to the segment pathCoordinates and valueData\n        segments[segments.length - 1].pathCoordinates.push(pathCoordinates[i], pathCoordinates[i + 1]);\n        segments[segments.length - 1].valueData.push(valueData[i / 2]);\n      }\n    }\n\n    return segments;\n  };\n}(this || global, Chartist));\n;/**\n * Chartist path interpolation functions.\n *\n * @module Chartist.Interpolation\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  Chartist.Interpolation = {};\n\n  /**\n   * This interpolation function does not smooth the path and the result is only containing lines and no curves.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.none({\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   *\n   * @memberof Chartist.Interpolation\n   * @return {Function}\n   */\n  Chartist.Interpolation.none = function(options) {\n    var defaultOptions = {\n      fillHoles: false\n    };\n    options = Chartist.extend({}, defaultOptions, options);\n    return function none(pathCoordinates, valueData) {\n      var path = new Chartist.Svg.Path();\n      var hole = true;\n\n      for(var i = 0; i < pathCoordinates.length; i += 2) {\n        var currX = pathCoordinates[i];\n        var currY = pathCoordinates[i + 1];\n        var currData = valueData[i / 2];\n\n        if(Chartist.getMultiValue(currData.value) !== undefined) {\n\n          if(hole) {\n            path.move(currX, currY, false, currData);\n          } else {\n            path.line(currX, currY, false, currData);\n          }\n\n          hole = false;\n        } else if(!options.fillHoles) {\n          hole = true;\n        }\n      }\n\n      return path;\n    };\n  };\n\n  /**\n   * Simple smoothing creates horizontal handles that are positioned with a fraction of the length between two data points. You can use the divisor option to specify the amount of smoothing.\n   *\n   * Simple smoothing can be used instead of `Chartist.Smoothing.cardinal` if you'd like to get rid of the artifacts it produces sometimes. Simple smoothing produces less flowing lines but is accurate by hitting the points and it also doesn't swing below or above the given data point.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter. The simple interpolation function accepts one configuration parameter `divisor`, between 1 and ∞, which controls the smoothing characteristics.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.simple({\n   *     divisor: 2,\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   *\n   * @memberof Chartist.Interpolation\n   * @param {Object} options The options of the simple interpolation factory function.\n   * @return {Function}\n   */\n  Chartist.Interpolation.simple = function(options) {\n    var defaultOptions = {\n      divisor: 2,\n      fillHoles: false\n    };\n    options = Chartist.extend({}, defaultOptions, options);\n\n    var d = 1 / Math.max(1, options.divisor);\n\n    return function simple(pathCoordinates, valueData) {\n      var path = new Chartist.Svg.Path();\n      var prevX, prevY, prevData;\n\n      for(var i = 0; i < pathCoordinates.length; i += 2) {\n        var currX = pathCoordinates[i];\n        var currY = pathCoordinates[i + 1];\n        var length = (currX - prevX) * d;\n        var currData = valueData[i / 2];\n\n        if(currData.value !== undefined) {\n\n          if(prevData === undefined) {\n            path.move(currX, currY, false, currData);\n          } else {\n            path.curve(\n              prevX + length,\n              prevY,\n              currX - length,\n              currY,\n              currX,\n              currY,\n              false,\n              currData\n            );\n          }\n\n          prevX = currX;\n          prevY = currY;\n          prevData = currData;\n        } else if(!options.fillHoles) {\n          prevX = currX = prevData = undefined;\n        }\n      }\n\n      return path;\n    };\n  };\n\n  /**\n   * Cardinal / Catmull-Rome spline interpolation is the default smoothing function in Chartist. It produces nice results where the splines will always meet the points. It produces some artifacts though when data values are increased or decreased rapidly. The line may not follow a very accurate path and if the line should be accurate this smoothing function does not produce the best results.\n   *\n   * Cardinal splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter. The cardinal interpolation function accepts one configuration parameter `tension`, between 0 and 1, which controls the smoothing intensity.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.cardinal({\n   *     tension: 1,\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   * @memberof Chartist.Interpolation\n   * @param {Object} options The options of the cardinal factory function.\n   * @return {Function}\n   */\n  Chartist.Interpolation.cardinal = function(options) {\n    var defaultOptions = {\n      tension: 1,\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    var t = Math.min(1, Math.max(0, options.tension)),\n      c = 1 - t;\n\n    return function cardinal(pathCoordinates, valueData) {\n      // First we try to split the coordinates into segments\n      // This is necessary to treat \"holes\" in line charts\n      var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {\n        fillHoles: options.fillHoles\n      });\n\n      if(!segments.length) {\n        // If there were no segments return 'Chartist.Interpolation.none'\n        return Chartist.Interpolation.none()([]);\n      } else if(segments.length > 1) {\n        // If the split resulted in more that one segment we need to interpolate each segment individually and join them\n        // afterwards together into a single path.\n          var paths = [];\n        // For each segment we will recurse the cardinal function\n        segments.forEach(function(segment) {\n          paths.push(cardinal(segment.pathCoordinates, segment.valueData));\n        });\n        // Join the segment path data into a single path and return\n        return Chartist.Svg.Path.join(paths);\n      } else {\n        // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first\n        // segment\n        pathCoordinates = segments[0].pathCoordinates;\n        valueData = segments[0].valueData;\n\n        // If less than two points we need to fallback to no smoothing\n        if(pathCoordinates.length <= 4) {\n          return Chartist.Interpolation.none()(pathCoordinates, valueData);\n        }\n\n        var path = new Chartist.Svg.Path().move(pathCoordinates[0], pathCoordinates[1], false, valueData[0]),\n          z;\n\n        for (var i = 0, iLen = pathCoordinates.length; iLen - 2 * !z > i; i += 2) {\n          var p = [\n            {x: +pathCoordinates[i - 2], y: +pathCoordinates[i - 1]},\n            {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]},\n            {x: +pathCoordinates[i + 2], y: +pathCoordinates[i + 3]},\n            {x: +pathCoordinates[i + 4], y: +pathCoordinates[i + 5]}\n          ];\n          if (z) {\n            if (!i) {\n              p[0] = {x: +pathCoordinates[iLen - 2], y: +pathCoordinates[iLen - 1]};\n            } else if (iLen - 4 === i) {\n              p[3] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};\n            } else if (iLen - 2 === i) {\n              p[2] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};\n              p[3] = {x: +pathCoordinates[2], y: +pathCoordinates[3]};\n            }\n          } else {\n            if (iLen - 4 === i) {\n              p[3] = p[2];\n            } else if (!i) {\n              p[0] = {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]};\n            }\n          }\n\n          path.curve(\n            (t * (-p[0].x + 6 * p[1].x + p[2].x) / 6) + (c * p[2].x),\n            (t * (-p[0].y + 6 * p[1].y + p[2].y) / 6) + (c * p[2].y),\n            (t * (p[1].x + 6 * p[2].x - p[3].x) / 6) + (c * p[2].x),\n            (t * (p[1].y + 6 * p[2].y - p[3].y) / 6) + (c * p[2].y),\n            p[2].x,\n            p[2].y,\n            false,\n            valueData[(i + 2) / 2]\n          );\n        }\n\n        return path;\n      }\n    };\n  };\n\n  /**\n   * Monotone Cubic spline interpolation produces a smooth curve which preserves monotonicity. Unlike cardinal splines, the curve will not extend beyond the range of y-values of the original data points.\n   *\n   * Monotone Cubic splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.\n   *\n   * The x-values of subsequent points must be increasing to fit a Monotone Cubic spline. If this condition is not met for a pair of adjacent points, then there will be a break in the curve between those data points.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.monotoneCubic({\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   * @memberof Chartist.Interpolation\n   * @param {Object} options The options of the monotoneCubic factory function.\n   * @return {Function}\n   */\n  Chartist.Interpolation.monotoneCubic = function(options) {\n    var defaultOptions = {\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    return function monotoneCubic(pathCoordinates, valueData) {\n      // First we try to split the coordinates into segments\n      // This is necessary to treat \"holes\" in line charts\n      var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {\n        fillHoles: options.fillHoles,\n        increasingX: true\n      });\n\n      if(!segments.length) {\n        // If there were no segments return 'Chartist.Interpolation.none'\n        return Chartist.Interpolation.none()([]);\n      } else if(segments.length > 1) {\n        // If the split resulted in more that one segment we need to interpolate each segment individually and join them\n        // afterwards together into a single path.\n          var paths = [];\n        // For each segment we will recurse the monotoneCubic fn function\n        segments.forEach(function(segment) {\n          paths.push(monotoneCubic(segment.pathCoordinates, segment.valueData));\n        });\n        // Join the segment path data into a single path and return\n        return Chartist.Svg.Path.join(paths);\n      } else {\n        // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first\n        // segment\n        pathCoordinates = segments[0].pathCoordinates;\n        valueData = segments[0].valueData;\n\n        // If less than three points we need to fallback to no smoothing\n        if(pathCoordinates.length <= 4) {\n          return Chartist.Interpolation.none()(pathCoordinates, valueData);\n        }\n\n        var xs = [],\n          ys = [],\n          i,\n          n = pathCoordinates.length / 2,\n          ms = [],\n          ds = [], dys = [], dxs = [],\n          path;\n\n        // Populate x and y coordinates into separate arrays, for readability\n\n        for(i = 0; i < n; i++) {\n          xs[i] = pathCoordinates[i * 2];\n          ys[i] = pathCoordinates[i * 2 + 1];\n        }\n\n        // Calculate deltas and derivative\n\n        for(i = 0; i < n - 1; i++) {\n          dys[i] = ys[i + 1] - ys[i];\n          dxs[i] = xs[i + 1] - xs[i];\n          ds[i] = dys[i] / dxs[i];\n        }\n\n        // Determine desired slope (m) at each point using Fritsch-Carlson method\n        // See: http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\n\n        ms[0] = ds[0];\n        ms[n - 1] = ds[n - 2];\n\n        for(i = 1; i < n - 1; i++) {\n          if(ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0)) {\n            ms[i] = 0;\n          } else {\n            ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\n              (2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\n              (dxs[i] + 2 * dxs[i - 1]) / ds[i]);\n\n            if(!isFinite(ms[i])) {\n              ms[i] = 0;\n            }\n          }\n        }\n\n        // Now build a path from the slopes\n\n        path = new Chartist.Svg.Path().move(xs[0], ys[0], false, valueData[0]);\n\n        for(i = 0; i < n - 1; i++) {\n          path.curve(\n            // First control point\n            xs[i] + dxs[i] / 3,\n            ys[i] + ms[i] * dxs[i] / 3,\n            // Second control point\n            xs[i + 1] - dxs[i] / 3,\n            ys[i + 1] - ms[i + 1] * dxs[i] / 3,\n            // End point\n            xs[i + 1],\n            ys[i + 1],\n\n            false,\n            valueData[i + 1]\n          );\n        }\n\n        return path;\n      }\n    };\n  };\n\n  /**\n   * Step interpolation will cause the line chart to move in steps rather than diagonal or smoothed lines. This interpolation will create additional points that will also be drawn when the `showPoint` option is enabled.\n   *\n   * All smoothing functions within Chartist are factory functions that accept an options parameter. The step interpolation function accepts one configuration parameter `postpone`, that can be `true` or `false`. The default value is `true` and will cause the step to occur where the value actually changes. If a different behaviour is needed where the step is shifted to the left and happens before the actual value, this option can be set to `false`.\n   *\n   * @example\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [[1, 2, 8, 1, 7]]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.step({\n   *     postpone: true,\n   *     fillHoles: false\n   *   })\n   * });\n   *\n   * @memberof Chartist.Interpolation\n   * @param options\n   * @returns {Function}\n   */\n  Chartist.Interpolation.step = function(options) {\n    var defaultOptions = {\n      postpone: true,\n      fillHoles: false\n    };\n\n    options = Chartist.extend({}, defaultOptions, options);\n\n    return function step(pathCoordinates, valueData) {\n      var path = new Chartist.Svg.Path();\n\n      var prevX, prevY, prevData;\n\n      for (var i = 0; i < pathCoordinates.length; i += 2) {\n        var currX = pathCoordinates[i];\n        var currY = pathCoordinates[i + 1];\n        var currData = valueData[i / 2];\n\n        // If the current point is also not a hole we can draw the step lines\n        if(currData.value !== undefined) {\n          if(prevData === undefined) {\n            path.move(currX, currY, false, currData);\n          } else {\n            if(options.postpone) {\n              // If postponed we should draw the step line with the value of the previous value\n              path.line(currX, prevY, false, prevData);\n            } else {\n              // If not postponed we should draw the step line with the value of the current value\n              path.line(prevX, currY, false, currData);\n            }\n            // Line to the actual point (this should only be a Y-Axis movement\n            path.line(currX, currY, false, currData);\n          }\n\n          prevX = currX;\n          prevY = currY;\n          prevData = currData;\n        } else if(!options.fillHoles) {\n          prevX = prevY = prevData = undefined;\n        }\n      }\n\n      return path;\n    };\n  };\n\n}(this || global, Chartist));\n;/**\n * A very basic event module that helps to generate and catch events.\n *\n * @module Chartist.Event\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  Chartist.EventEmitter = function () {\n    var handlers = [];\n\n    /**\n     * Add an event handler for a specific event\n     *\n     * @memberof Chartist.Event\n     * @param {String} event The event name\n     * @param {Function} handler A event handler function\n     */\n    function addEventHandler(event, handler) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n\n    /**\n     * Remove an event handler of a specific event name or remove all event handlers for a specific event.\n     *\n     * @memberof Chartist.Event\n     * @param {String} event The event name where a specific or all handlers should be removed\n     * @param {Function} [handler] An optional event handler function. If specified only this specific handler will be removed and otherwise all handlers are removed.\n     */\n    function removeEventHandler(event, handler) {\n      // Only do something if there are event handlers with this name existing\n      if(handlers[event]) {\n        // If handler is set we will look for a specific handler and only remove this\n        if(handler) {\n          handlers[event].splice(handlers[event].indexOf(handler), 1);\n          if(handlers[event].length === 0) {\n            delete handlers[event];\n          }\n        } else {\n          // If no handler is specified we remove all handlers for this event\n          delete handlers[event];\n        }\n      }\n    }\n\n    /**\n     * Use this function to emit an event. All handlers that are listening for this event will be triggered with the data parameter.\n     *\n     * @memberof Chartist.Event\n     * @param {String} event The event name that should be triggered\n     * @param {*} data Arbitrary data that will be passed to the event handler callback functions\n     */\n    function emit(event, data) {\n      // Only do something if there are event handlers with this name existing\n      if(handlers[event]) {\n        handlers[event].forEach(function(handler) {\n          handler(data);\n        });\n      }\n\n      // Emit event to star event handlers\n      if(handlers['*']) {\n        handlers['*'].forEach(function(starHandler) {\n          starHandler(event, data);\n        });\n      }\n    }\n\n    return {\n      addEventHandler: addEventHandler,\n      removeEventHandler: removeEventHandler,\n      emit: emit\n    };\n  };\n\n}(this || global, Chartist));\n;/**\n * This module provides some basic prototype inheritance utilities.\n *\n * @module Chartist.Class\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  function listToArray(list) {\n    var arr = [];\n    if (list.length) {\n      for (var i = 0; i < list.length; i++) {\n        arr.push(list[i]);\n      }\n    }\n    return arr;\n  }\n\n  /**\n   * Method to extend from current prototype.\n   *\n   * @memberof Chartist.Class\n   * @param {Object} properties The object that serves as definition for the prototype that gets created for the new class. This object should always contain a constructor property that is the desired constructor for the newly created class.\n   * @param {Object} [superProtoOverride] By default extens will use the current class prototype or Chartist.class. With this parameter you can specify any super prototype that will be used.\n   * @return {Function} Constructor function of the new class\n   *\n   * @example\n   * var Fruit = Class.extend({\n     * color: undefined,\n     *   sugar: undefined,\n     *\n     *   constructor: function(color, sugar) {\n     *     this.color = color;\n     *     this.sugar = sugar;\n     *   },\n     *\n     *   eat: function() {\n     *     this.sugar = 0;\n     *     return this;\n     *   }\n     * });\n   *\n   * var Banana = Fruit.extend({\n     *   length: undefined,\n     *\n     *   constructor: function(length, sugar) {\n     *     Banana.super.constructor.call(this, 'Yellow', sugar);\n     *     this.length = length;\n     *   }\n     * });\n   *\n   * var banana = new Banana(20, 40);\n   * console.log('banana instanceof Fruit', banana instanceof Fruit);\n   * console.log('Fruit is prototype of banana', Fruit.prototype.isPrototypeOf(banana));\n   * console.log('bananas prototype is Fruit', Object.getPrototypeOf(banana) === Fruit.prototype);\n   * console.log(banana.sugar);\n   * console.log(banana.eat().sugar);\n   * console.log(banana.color);\n   */\n  function extend(properties, superProtoOverride) {\n    var superProto = superProtoOverride || this.prototype || Chartist.Class;\n    var proto = Object.create(superProto);\n\n    Chartist.Class.cloneDefinitions(proto, properties);\n\n    var constr = function() {\n      var fn = proto.constructor || function () {},\n        instance;\n\n      // If this is linked to the Chartist namespace the constructor was not called with new\n      // To provide a fallback we will instantiate here and return the instance\n      instance = this === Chartist ? Object.create(proto) : this;\n      fn.apply(instance, Array.prototype.slice.call(arguments, 0));\n\n      // If this constructor was not called with new we need to return the instance\n      // This will not harm when the constructor has been called with new as the returned value is ignored\n      return instance;\n    };\n\n    constr.prototype = proto;\n    constr.super = superProto;\n    constr.extend = this.extend;\n\n    return constr;\n  }\n\n  // Variable argument list clones args > 0 into args[0] and retruns modified args[0]\n  function cloneDefinitions() {\n    var args = listToArray(arguments);\n    var target = args[0];\n\n    args.splice(1, args.length - 1).forEach(function (source) {\n      Object.getOwnPropertyNames(source).forEach(function (propName) {\n        // If this property already exist in target we delete it first\n        delete target[propName];\n        // Define the property with the descriptor from source\n        Object.defineProperty(target, propName,\n          Object.getOwnPropertyDescriptor(source, propName));\n      });\n    });\n\n    return target;\n  }\n\n  Chartist.Class = {\n    extend: extend,\n    cloneDefinitions: cloneDefinitions\n  };\n\n}(this || global, Chartist));\n;/**\n * Base for all chart types. The methods in Chartist.Base are inherited to all chart types.\n *\n * @module Chartist.Base\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n\n  // TODO: Currently we need to re-draw the chart on window resize. This is usually very bad and will affect performance.\n  // This is done because we can't work with relative coordinates when drawing the chart because SVG Path does not\n  // work with relative positions yet. We need to check if we can do a viewBox hack to switch to percentage.\n  // See http://mozilla.6506.n7.nabble.com/Specyfing-paths-with-percentages-unit-td247474.html\n  // Update: can be done using the above method tested here: http://codepen.io/gionkunz/pen/KDvLj\n  // The problem is with the label offsets that can't be converted into percentage and affecting the chart container\n  /**\n   * Updates the chart which currently does a full reconstruction of the SVG DOM\n   *\n   * @param {Object} [data] Optional data you'd like to set for the chart before it will update. If not specified the update method will use the data that is already configured with the chart.\n   * @param {Object} [options] Optional options you'd like to add to the previous options for the chart before it will update. If not specified the update method will use the options that have been already configured with the chart.\n   * @param {Boolean} [override] If set to true, the passed options will be used to extend the options that have been configured already. Otherwise the chart default options will be used as the base\n   * @memberof Chartist.Base\n   */\n  function update(data, options, override) {\n    if(data) {\n      this.data = data || {};\n      this.data.labels = this.data.labels || [];\n      this.data.series = this.data.series || [];\n      // Event for data transformation that allows to manipulate the data before it gets rendered in the charts\n      this.eventEmitter.emit('data', {\n        type: 'update',\n        data: this.data\n      });\n    }\n\n    if(options) {\n      this.options = Chartist.extend({}, override ? this.options : this.defaultOptions, options);\n\n      // If chartist was not initialized yet, we just set the options and leave the rest to the initialization\n      // Otherwise we re-create the optionsProvider at this point\n      if(!this.initializeTimeoutId) {\n        this.optionsProvider.removeMediaQueryListeners();\n        this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);\n      }\n    }\n\n    // Only re-created the chart if it has been initialized yet\n    if(!this.initializeTimeoutId) {\n      this.createChart(this.optionsProvider.getCurrentOptions());\n    }\n\n    // Return a reference to the chart object to chain up calls\n    return this;\n  }\n\n  /**\n   * This method can be called on the API object of each chart and will un-register all event listeners that were added to other components. This currently includes a window.resize listener as well as media query listeners if any responsive options have been provided. Use this function if you need to destroy and recreate Chartist charts dynamically.\n   *\n   * @memberof Chartist.Base\n   */\n  function detach() {\n    // Only detach if initialization already occurred on this chart. If this chart still hasn't initialized (therefore\n    // the initializationTimeoutId is still a valid timeout reference, we will clear the timeout\n    if(!this.initializeTimeoutId) {\n      window.removeEventListener('resize', this.resizeListener);\n      this.optionsProvider.removeMediaQueryListeners();\n    } else {\n      window.clearTimeout(this.initializeTimeoutId);\n    }\n\n    return this;\n  }\n\n  /**\n   * Use this function to register event handlers. The handler callbacks are synchronous and will run in the main thread rather than the event loop.\n   *\n   * @memberof Chartist.Base\n   * @param {String} event Name of the event. Check the examples for supported events.\n   * @param {Function} handler The handler function that will be called when an event with the given name was emitted. This function will receive a data argument which contains event data. See the example for more details.\n   */\n  function on(event, handler) {\n    this.eventEmitter.addEventHandler(event, handler);\n    return this;\n  }\n\n  /**\n   * Use this function to un-register event handlers. If the handler function parameter is omitted all handlers for the given event will be un-registered.\n   *\n   * @memberof Chartist.Base\n   * @param {String} event Name of the event for which a handler should be removed\n   * @param {Function} [handler] The handler function that that was previously used to register a new event handler. This handler will be removed from the event handler list. If this parameter is omitted then all event handlers for the given event are removed from the list.\n   */\n  function off(event, handler) {\n    this.eventEmitter.removeEventHandler(event, handler);\n    return this;\n  }\n\n  function initialize() {\n    // Add window resize listener that re-creates the chart\n    window.addEventListener('resize', this.resizeListener);\n\n    // Obtain current options based on matching media queries (if responsive options are given)\n    // This will also register a listener that is re-creating the chart based on media changes\n    this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);\n    // Register options change listener that will trigger a chart update\n    this.eventEmitter.addEventHandler('optionsChanged', function() {\n      this.update();\n    }.bind(this));\n\n    // Before the first chart creation we need to register us with all plugins that are configured\n    // Initialize all relevant plugins with our chart object and the plugin options specified in the config\n    if(this.options.plugins) {\n      this.options.plugins.forEach(function(plugin) {\n        if(plugin instanceof Array) {\n          plugin[0](this, plugin[1]);\n        } else {\n          plugin(this);\n        }\n      }.bind(this));\n    }\n\n    // Event for data transformation that allows to manipulate the data before it gets rendered in the charts\n    this.eventEmitter.emit('data', {\n      type: 'initial',\n      data: this.data\n    });\n\n    // Create the first chart\n    this.createChart(this.optionsProvider.getCurrentOptions());\n\n    // As chart is initialized from the event loop now we can reset our timeout reference\n    // This is important if the chart gets initialized on the same element twice\n    this.initializeTimeoutId = undefined;\n  }\n\n  /**\n   * Constructor of chart base class.\n   *\n   * @param query\n   * @param data\n   * @param defaultOptions\n   * @param options\n   * @param responsiveOptions\n   * @constructor\n   */\n  function Base(query, data, defaultOptions, options, responsiveOptions) {\n    this.container = Chartist.querySelector(query);\n    this.data = data || {};\n    this.data.labels = this.data.labels || [];\n    this.data.series = this.data.series || [];\n    this.defaultOptions = defaultOptions;\n    this.options = options;\n    this.responsiveOptions = responsiveOptions;\n    this.eventEmitter = Chartist.EventEmitter();\n    this.supportsForeignObject = Chartist.Svg.isSupported('Extensibility');\n    this.supportsAnimations = Chartist.Svg.isSupported('AnimationEventsAttribute');\n    this.resizeListener = function resizeListener(){\n      this.update();\n    }.bind(this);\n\n    if(this.container) {\n      // If chartist was already initialized in this container we are detaching all event listeners first\n      if(this.container.__chartist__) {\n        this.container.__chartist__.detach();\n      }\n\n      this.container.__chartist__ = this;\n    }\n\n    // Using event loop for first draw to make it possible to register event listeners in the same call stack where\n    // the chart was created.\n    this.initializeTimeoutId = setTimeout(initialize.bind(this), 0);\n  }\n\n  // Creating the chart base class\n  Chartist.Base = Chartist.Class.extend({\n    constructor: Base,\n    optionsProvider: undefined,\n    container: undefined,\n    svg: undefined,\n    eventEmitter: undefined,\n    createChart: function() {\n      throw new Error('Base chart type can\\'t be instantiated!');\n    },\n    update: update,\n    detach: detach,\n    on: on,\n    off: off,\n    version: Chartist.version,\n    supportsForeignObject: false\n  });\n\n}(this || global, Chartist));\n;/**\n * Chartist SVG module for simple SVG DOM abstraction\n *\n * @module Chartist.Svg\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  var document = globalRoot.document;\n\n  /**\n   * Chartist.Svg creates a new SVG object wrapper with a starting element. You can use the wrapper to fluently create sub-elements and modify them.\n   *\n   * @memberof Chartist.Svg\n   * @constructor\n   * @param {String|Element} name The name of the SVG element to create or an SVG dom element which should be wrapped into Chartist.Svg\n   * @param {Object} attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.\n   * @param {String} className This class or class list will be added to the SVG element\n   * @param {Object} parent The parent SVG wrapper object where this newly created wrapper and it's element will be attached to as child\n   * @param {Boolean} insertFirst If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element\n   */\n  function Svg(name, attributes, className, parent, insertFirst) {\n    // If Svg is getting called with an SVG element we just return the wrapper\n    if(name instanceof Element) {\n      this._node = name;\n    } else {\n      this._node = document.createElementNS(Chartist.namespaces.svg, name);\n\n      // If this is an SVG element created then custom namespace\n      if(name === 'svg') {\n        this.attr({\n          'xmlns:ct': Chartist.namespaces.ct\n        });\n      }\n    }\n\n    if(attributes) {\n      this.attr(attributes);\n    }\n\n    if(className) {\n      this.addClass(className);\n    }\n\n    if(parent) {\n      if (insertFirst && parent._node.firstChild) {\n        parent._node.insertBefore(this._node, parent._node.firstChild);\n      } else {\n        parent._node.appendChild(this._node);\n      }\n    }\n  }\n\n  /**\n   * Set attributes on the current SVG element of the wrapper you're currently working on.\n   *\n   * @memberof Chartist.Svg\n   * @param {Object|String} attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added. If this parameter is a String then the function is used as a getter and will return the attribute value.\n   * @param {String} [ns] If specified, the attribute will be obtained using getAttributeNs. In order to write namepsaced attributes you can use the namespace:attribute notation within the attributes object.\n   * @return {Object|String} The current wrapper object will be returned so it can be used for chaining or the attribute value if used as getter function.\n   */\n  function attr(attributes, ns) {\n    if(typeof attributes === 'string') {\n      if(ns) {\n        return this._node.getAttributeNS(ns, attributes);\n      } else {\n        return this._node.getAttribute(attributes);\n      }\n    }\n\n    Object.keys(attributes).forEach(function(key) {\n      // If the attribute value is undefined we can skip this one\n      if(attributes[key] === undefined) {\n        return;\n      }\n\n      if (key.indexOf(':') !== -1) {\n        var namespacedAttribute = key.split(':');\n        this._node.setAttributeNS(Chartist.namespaces[namespacedAttribute[0]], key, attributes[key]);\n      } else {\n        this._node.setAttribute(key, attributes[key]);\n      }\n    }.bind(this));\n\n    return this;\n  }\n\n  /**\n   * Create a new SVG element whose wrapper object will be selected for further operations. This way you can also create nested groups easily.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} name The name of the SVG element that should be created as child element of the currently selected element wrapper\n   * @param {Object} [attributes] An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.\n   * @param {String} [className] This class or class list will be added to the SVG element\n   * @param {Boolean} [insertFirst] If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element\n   * @return {Chartist.Svg} Returns a Chartist.Svg wrapper object that can be used to modify the containing SVG data\n   */\n  function elem(name, attributes, className, insertFirst) {\n    return new Chartist.Svg(name, attributes, className, this, insertFirst);\n  }\n\n  /**\n   * Returns the parent Chartist.SVG wrapper object\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} Returns a Chartist.Svg wrapper around the parent node of the current node. If the parent node is not existing or it's not an SVG node then this function will return null.\n   */\n  function parent() {\n    return this._node.parentNode instanceof SVGElement ? new Chartist.Svg(this._node.parentNode) : null;\n  }\n\n  /**\n   * This method returns a Chartist.Svg wrapper around the root SVG element of the current tree.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The root SVG element wrapped in a Chartist.Svg element\n   */\n  function root() {\n    var node = this._node;\n    while(node.nodeName !== 'svg') {\n      node = node.parentNode;\n    }\n    return new Chartist.Svg(node);\n  }\n\n  /**\n   * Find the first child SVG element of the current element that matches a CSS selector. The returned object is a Chartist.Svg wrapper.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} selector A CSS selector that is used to query for child SVG elements\n   * @return {Chartist.Svg} The SVG wrapper for the element found or null if no element was found\n   */\n  function querySelector(selector) {\n    var foundNode = this._node.querySelector(selector);\n    return foundNode ? new Chartist.Svg(foundNode) : null;\n  }\n\n  /**\n   * Find the all child SVG elements of the current element that match a CSS selector. The returned object is a Chartist.Svg.List wrapper.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} selector A CSS selector that is used to query for child SVG elements\n   * @return {Chartist.Svg.List} The SVG wrapper list for the element found or null if no element was found\n   */\n  function querySelectorAll(selector) {\n    var foundNodes = this._node.querySelectorAll(selector);\n    return foundNodes.length ? new Chartist.Svg.List(foundNodes) : null;\n  }\n\n  /**\n   * Returns the underlying SVG node for the current element.\n   *\n   * @memberof Chartist.Svg\n   * @returns {Node}\n   */\n  function getNode() {\n    return this._node;\n  }\n\n  /**\n   * This method creates a foreignObject (see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) that allows to embed HTML content into a SVG graphic. With the help of foreignObjects you can enable the usage of regular HTML elements inside of SVG where they are subject for SVG positioning and transformation but the Browser will use the HTML rendering capabilities for the containing DOM.\n   *\n   * @memberof Chartist.Svg\n   * @param {Node|String} content The DOM Node, or HTML string that will be converted to a DOM Node, that is then placed into and wrapped by the foreignObject\n   * @param {String} [attributes] An object with properties that will be added as attributes to the foreignObject element that is created. Attributes with undefined values will not be added.\n   * @param {String} [className] This class or class list will be added to the SVG element\n   * @param {Boolean} [insertFirst] Specifies if the foreignObject should be inserted as first child\n   * @return {Chartist.Svg} New wrapper object that wraps the foreignObject element\n   */\n  function foreignObject(content, attributes, className, insertFirst) {\n    // If content is string then we convert it to DOM\n    // TODO: Handle case where content is not a string nor a DOM Node\n    if(typeof content === 'string') {\n      var container = document.createElement('div');\n      container.innerHTML = content;\n      content = container.firstChild;\n    }\n\n    // Adding namespace to content element\n    content.setAttribute('xmlns', Chartist.namespaces.xmlns);\n\n    // Creating the foreignObject without required extension attribute (as described here\n    // http://www.w3.org/TR/SVG/extend.html#ForeignObjectElement)\n    var fnObj = this.elem('foreignObject', attributes, className, insertFirst);\n\n    // Add content to foreignObjectElement\n    fnObj._node.appendChild(content);\n\n    return fnObj;\n  }\n\n  /**\n   * This method adds a new text element to the current Chartist.Svg wrapper.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} t The text that should be added to the text element that is created\n   * @return {Chartist.Svg} The same wrapper object that was used to add the newly created element\n   */\n  function text(t) {\n    this._node.appendChild(document.createTextNode(t));\n    return this;\n  }\n\n  /**\n   * This method will clear all child nodes of the current wrapper object.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The same wrapper object that got emptied\n   */\n  function empty() {\n    while (this._node.firstChild) {\n      this._node.removeChild(this._node.firstChild);\n    }\n\n    return this;\n  }\n\n  /**\n   * This method will cause the current wrapper to remove itself from its parent wrapper. Use this method if you'd like to get rid of an element in a given DOM structure.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The parent wrapper object of the element that got removed\n   */\n  function remove() {\n    this._node.parentNode.removeChild(this._node);\n    return this.parent();\n  }\n\n  /**\n   * This method will replace the element with a new element that can be created outside of the current DOM.\n   *\n   * @memberof Chartist.Svg\n   * @param {Chartist.Svg} newElement The new Chartist.Svg object that will be used to replace the current wrapper object\n   * @return {Chartist.Svg} The wrapper of the new element\n   */\n  function replace(newElement) {\n    this._node.parentNode.replaceChild(newElement._node, this._node);\n    return newElement;\n  }\n\n  /**\n   * This method will append an element to the current element as a child.\n   *\n   * @memberof Chartist.Svg\n   * @param {Chartist.Svg} element The Chartist.Svg element that should be added as a child\n   * @param {Boolean} [insertFirst] Specifies if the element should be inserted as first child\n   * @return {Chartist.Svg} The wrapper of the appended object\n   */\n  function append(element, insertFirst) {\n    if(insertFirst && this._node.firstChild) {\n      this._node.insertBefore(element._node, this._node.firstChild);\n    } else {\n      this._node.appendChild(element._node);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns an array of class names that are attached to the current wrapper element. This method can not be chained further.\n   *\n   * @memberof Chartist.Svg\n   * @return {Array} A list of classes or an empty array if there are no classes on the current element\n   */\n  function classes() {\n    return this._node.getAttribute('class') ? this._node.getAttribute('class').trim().split(/\\s+/) : [];\n  }\n\n  /**\n   * Adds one or a space separated list of classes to the current element and ensures the classes are only existing once.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} names A white space separated list of class names\n   * @return {Chartist.Svg} The wrapper of the current element\n   */\n  function addClass(names) {\n    this._node.setAttribute('class',\n      this.classes(this._node)\n        .concat(names.trim().split(/\\s+/))\n        .filter(function(elem, pos, self) {\n          return self.indexOf(elem) === pos;\n        }).join(' ')\n    );\n\n    return this;\n  }\n\n  /**\n   * Removes one or a space separated list of classes from the current element.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} names A white space separated list of class names\n   * @return {Chartist.Svg} The wrapper of the current element\n   */\n  function removeClass(names) {\n    var removedClasses = names.trim().split(/\\s+/);\n\n    this._node.setAttribute('class', this.classes(this._node).filter(function(name) {\n      return removedClasses.indexOf(name) === -1;\n    }).join(' '));\n\n    return this;\n  }\n\n  /**\n   * Removes all classes from the current element.\n   *\n   * @memberof Chartist.Svg\n   * @return {Chartist.Svg} The wrapper of the current element\n   */\n  function removeAllClasses() {\n    this._node.setAttribute('class', '');\n\n    return this;\n  }\n\n  /**\n   * Get element height using `getBoundingClientRect`\n   *\n   * @memberof Chartist.Svg\n   * @return {Number} The elements height in pixels\n   */\n  function height() {\n    return this._node.getBoundingClientRect().height;\n  }\n\n  /**\n   * Get element width using `getBoundingClientRect`\n   *\n   * @memberof Chartist.Core\n   * @return {Number} The elements width in pixels\n   */\n  function width() {\n    return this._node.getBoundingClientRect().width;\n  }\n\n  /**\n   * The animate function lets you animate the current element with SMIL animations. You can add animations for multiple attributes at the same time by using an animation definition object. This object should contain SMIL animation attributes. Please refer to http://www.w3.org/TR/SVG/animate.html for a detailed specification about the available animation attributes. Additionally an easing property can be passed in the animation definition object. This can be a string with a name of an easing function in `Chartist.Svg.Easing` or an array with four numbers specifying a cubic Bézier curve.\n   * **An animations object could look like this:**\n   * ```javascript\n   * element.animate({\n   *   opacity: {\n   *     dur: 1000,\n   *     from: 0,\n   *     to: 1\n   *   },\n   *   x1: {\n   *     dur: '1000ms',\n   *     from: 100,\n   *     to: 200,\n   *     easing: 'easeOutQuart'\n   *   },\n   *   y1: {\n   *     dur: '2s',\n   *     from: 0,\n   *     to: 100\n   *   }\n   * });\n   * ```\n   * **Automatic unit conversion**\n   * For the `dur` and the `begin` animate attribute you can also omit a unit by passing a number. The number will automatically be converted to milli seconds.\n   * **Guided mode**\n   * The default behavior of SMIL animations with offset using the `begin` attribute is that the attribute will keep it's original value until the animation starts. Mostly this behavior is not desired as you'd like to have your element attributes already initialized with the animation `from` value even before the animation starts. Also if you don't specify `fill=\"freeze\"` on an animate element or if you delete the animation after it's done (which is done in guided mode) the attribute will switch back to the initial value. This behavior is also not desired when performing simple one-time animations. For one-time animations you'd want to trigger animations immediately instead of relative to the document begin time. That's why in guided mode Chartist.Svg will also use the `begin` property to schedule a timeout and manually start the animation after the timeout. If you're using multiple SMIL definition objects for an attribute (in an array), guided mode will be disabled for this attribute, even if you explicitly enabled it.\n   * If guided mode is enabled the following behavior is added:\n   * - Before the animation starts (even when delayed with `begin`) the animated attribute will be set already to the `from` value of the animation\n   * - `begin` is explicitly set to `indefinite` so it can be started manually without relying on document begin time (creation)\n   * - The animate element will be forced to use `fill=\"freeze\"`\n   * - The animation will be triggered with `beginElement()` in a timeout where `begin` of the definition object is interpreted in milli seconds. If no `begin` was specified the timeout is triggered immediately.\n   * - After the animation the element attribute value will be set to the `to` value of the animation\n   * - The animate element is deleted from the DOM\n   *\n   * @memberof Chartist.Svg\n   * @param {Object} animations An animations object where the property keys are the attributes you'd like to animate. The properties should be objects again that contain the SMIL animation attributes (usually begin, dur, from, and to). The property begin and dur is auto converted (see Automatic unit conversion). You can also schedule multiple animations for the same attribute by passing an Array of SMIL definition objects. Attributes that contain an array of SMIL definition objects will not be executed in guided mode.\n   * @param {Boolean} guided Specify if guided mode should be activated for this animation (see Guided mode). If not otherwise specified, guided mode will be activated.\n   * @param {Object} eventEmitter If specified, this event emitter will be notified when an animation starts or ends.\n   * @return {Chartist.Svg} The current element where the animation was added\n   */\n  function animate(animations, guided, eventEmitter) {\n    if(guided === undefined) {\n      guided = true;\n    }\n\n    Object.keys(animations).forEach(function createAnimateForAttributes(attribute) {\n\n      function createAnimate(animationDefinition, guided) {\n        var attributeProperties = {},\n          animate,\n          timeout,\n          easing;\n\n        // Check if an easing is specified in the definition object and delete it from the object as it will not\n        // be part of the animate element attributes.\n        if(animationDefinition.easing) {\n          // If already an easing Bézier curve array we take it or we lookup a easing array in the Easing object\n          easing = animationDefinition.easing instanceof Array ?\n            animationDefinition.easing :\n            Chartist.Svg.Easing[animationDefinition.easing];\n          delete animationDefinition.easing;\n        }\n\n        // If numeric dur or begin was provided we assume milli seconds\n        animationDefinition.begin = Chartist.ensureUnit(animationDefinition.begin, 'ms');\n        animationDefinition.dur = Chartist.ensureUnit(animationDefinition.dur, 'ms');\n\n        if(easing) {\n          animationDefinition.calcMode = 'spline';\n          animationDefinition.keySplines = easing.join(' ');\n          animationDefinition.keyTimes = '0;1';\n        }\n\n        // Adding \"fill: freeze\" if we are in guided mode and set initial attribute values\n        if(guided) {\n          animationDefinition.fill = 'freeze';\n          // Animated property on our element should already be set to the animation from value in guided mode\n          attributeProperties[attribute] = animationDefinition.from;\n          this.attr(attributeProperties);\n\n          // In guided mode we also set begin to indefinite so we can trigger the start manually and put the begin\n          // which needs to be in ms aside\n          timeout = Chartist.quantity(animationDefinition.begin || 0).value;\n          animationDefinition.begin = 'indefinite';\n        }\n\n        animate = this.elem('animate', Chartist.extend({\n          attributeName: attribute\n        }, animationDefinition));\n\n        if(guided) {\n          // If guided we take the value that was put aside in timeout and trigger the animation manually with a timeout\n          setTimeout(function() {\n            // If beginElement fails we set the animated attribute to the end position and remove the animate element\n            // This happens if the SMIL ElementTimeControl interface is not supported or any other problems occured in\n            // the browser. (Currently FF 34 does not support animate elements in foreignObjects)\n            try {\n              animate._node.beginElement();\n            } catch(err) {\n              // Set animated attribute to current animated value\n              attributeProperties[attribute] = animationDefinition.to;\n              this.attr(attributeProperties);\n              // Remove the animate element as it's no longer required\n              animate.remove();\n            }\n          }.bind(this), timeout);\n        }\n\n        if(eventEmitter) {\n          animate._node.addEventListener('beginEvent', function handleBeginEvent() {\n            eventEmitter.emit('animationBegin', {\n              element: this,\n              animate: animate._node,\n              params: animationDefinition\n            });\n          }.bind(this));\n        }\n\n        animate._node.addEventListener('endEvent', function handleEndEvent() {\n          if(eventEmitter) {\n            eventEmitter.emit('animationEnd', {\n              element: this,\n              animate: animate._node,\n              params: animationDefinition\n            });\n          }\n\n          if(guided) {\n            // Set animated attribute to current animated value\n            attributeProperties[attribute] = animationDefinition.to;\n            this.attr(attributeProperties);\n            // Remove the animate element as it's no longer required\n            animate.remove();\n          }\n        }.bind(this));\n      }\n\n      // If current attribute is an array of definition objects we create an animate for each and disable guided mode\n      if(animations[attribute] instanceof Array) {\n        animations[attribute].forEach(function(animationDefinition) {\n          createAnimate.bind(this)(animationDefinition, false);\n        }.bind(this));\n      } else {\n        createAnimate.bind(this)(animations[attribute], guided);\n      }\n\n    }.bind(this));\n\n    return this;\n  }\n\n  Chartist.Svg = Chartist.Class.extend({\n    constructor: Svg,\n    attr: attr,\n    elem: elem,\n    parent: parent,\n    root: root,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll,\n    getNode: getNode,\n    foreignObject: foreignObject,\n    text: text,\n    empty: empty,\n    remove: remove,\n    replace: replace,\n    append: append,\n    classes: classes,\n    addClass: addClass,\n    removeClass: removeClass,\n    removeAllClasses: removeAllClasses,\n    height: height,\n    width: width,\n    animate: animate\n  });\n\n  /**\n   * This method checks for support of a given SVG feature like Extensibility, SVG-animation or the like. Check http://www.w3.org/TR/SVG11/feature for a detailed list.\n   *\n   * @memberof Chartist.Svg\n   * @param {String} feature The SVG 1.1 feature that should be checked for support.\n   * @return {Boolean} True of false if the feature is supported or not\n   */\n  Chartist.Svg.isSupported = function(feature) {\n    return document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#' + feature, '1.1');\n  };\n\n  /**\n   * This Object contains some standard easing cubic bezier curves. Then can be used with their name in the `Chartist.Svg.animate`. You can also extend the list and use your own name in the `animate` function. Click the show code button to see the available bezier functions.\n   *\n   * @memberof Chartist.Svg\n   */\n  var easingCubicBeziers = {\n    easeInSine: [0.47, 0, 0.745, 0.715],\n    easeOutSine: [0.39, 0.575, 0.565, 1],\n    easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n    easeInQuad: [0.55, 0.085, 0.68, 0.53],\n    easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n    easeInCubic: [0.55, 0.055, 0.675, 0.19],\n    easeOutCubic: [0.215, 0.61, 0.355, 1],\n    easeInOutCubic: [0.645, 0.045, 0.355, 1],\n    easeInQuart: [0.895, 0.03, 0.685, 0.22],\n    easeOutQuart: [0.165, 0.84, 0.44, 1],\n    easeInOutQuart: [0.77, 0, 0.175, 1],\n    easeInQuint: [0.755, 0.05, 0.855, 0.06],\n    easeOutQuint: [0.23, 1, 0.32, 1],\n    easeInOutQuint: [0.86, 0, 0.07, 1],\n    easeInExpo: [0.95, 0.05, 0.795, 0.035],\n    easeOutExpo: [0.19, 1, 0.22, 1],\n    easeInOutExpo: [1, 0, 0, 1],\n    easeInCirc: [0.6, 0.04, 0.98, 0.335],\n    easeOutCirc: [0.075, 0.82, 0.165, 1],\n    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],\n    easeInBack: [0.6, -0.28, 0.735, 0.045],\n    easeOutBack: [0.175, 0.885, 0.32, 1.275],\n    easeInOutBack: [0.68, -0.55, 0.265, 1.55]\n  };\n\n  Chartist.Svg.Easing = easingCubicBeziers;\n\n  /**\n   * This helper class is to wrap multiple `Chartist.Svg` elements into a list where you can call the `Chartist.Svg` functions on all elements in the list with one call. This is helpful when you'd like to perform calls with `Chartist.Svg` on multiple elements.\n   * An instance of this class is also returned by `Chartist.Svg.querySelectorAll`.\n   *\n   * @memberof Chartist.Svg\n   * @param {Array<Node>|NodeList} nodeList An Array of SVG DOM nodes or a SVG DOM NodeList (as returned by document.querySelectorAll)\n   * @constructor\n   */\n  function SvgList(nodeList) {\n    var list = this;\n\n    this.svgElements = [];\n    for(var i = 0; i < nodeList.length; i++) {\n      this.svgElements.push(new Chartist.Svg(nodeList[i]));\n    }\n\n    // Add delegation methods for Chartist.Svg\n    Object.keys(Chartist.Svg.prototype).filter(function(prototypeProperty) {\n      return ['constructor',\n          'parent',\n          'querySelector',\n          'querySelectorAll',\n          'replace',\n          'append',\n          'classes',\n          'height',\n          'width'].indexOf(prototypeProperty) === -1;\n    }).forEach(function(prototypeProperty) {\n      list[prototypeProperty] = function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        list.svgElements.forEach(function(element) {\n          Chartist.Svg.prototype[prototypeProperty].apply(element, args);\n        });\n        return list;\n      };\n    });\n  }\n\n  Chartist.Svg.List = Chartist.Class.extend({\n    constructor: SvgList\n  });\n}(this || global, Chartist));\n;/**\n * Chartist SVG path module for SVG path description creation and modification.\n *\n * @module Chartist.Svg.Path\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  /**\n   * Contains the descriptors of supported element types in a SVG path. Currently only move, line and curve are supported.\n   *\n   * @memberof Chartist.Svg.Path\n   * @type {Object}\n   */\n  var elementDescriptions = {\n    m: ['x', 'y'],\n    l: ['x', 'y'],\n    c: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n    a: ['rx', 'ry', 'xAr', 'lAf', 'sf', 'x', 'y']\n  };\n\n  /**\n   * Default options for newly created SVG path objects.\n   *\n   * @memberof Chartist.Svg.Path\n   * @type {Object}\n   */\n  var defaultOptions = {\n    // The accuracy in digit count after the decimal point. This will be used to round numbers in the SVG path. If this option is set to false then no rounding will be performed.\n    accuracy: 3\n  };\n\n  function element(command, params, pathElements, pos, relative, data) {\n    var pathElement = Chartist.extend({\n      command: relative ? command.toLowerCase() : command.toUpperCase()\n    }, params, data ? { data: data } : {} );\n\n    pathElements.splice(pos, 0, pathElement);\n  }\n\n  function forEachParam(pathElements, cb) {\n    pathElements.forEach(function(pathElement, pathElementIndex) {\n      elementDescriptions[pathElement.command.toLowerCase()].forEach(function(paramName, paramIndex) {\n        cb(pathElement, paramName, pathElementIndex, paramIndex, pathElements);\n      });\n    });\n  }\n\n  /**\n   * Used to construct a new path object.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Boolean} close If set to true then this path will be closed when stringified (with a Z at the end)\n   * @param {Object} options Options object that overrides the default objects. See default options for more details.\n   * @constructor\n   */\n  function SvgPath(close, options) {\n    this.pathElements = [];\n    this.pos = 0;\n    this.close = close;\n    this.options = Chartist.extend({}, defaultOptions, options);\n  }\n\n  /**\n   * Gets or sets the current position (cursor) inside of the path. You can move around the cursor freely but limited to 0 or the count of existing elements. All modifications with element functions will insert new elements at the position of this cursor.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} [pos] If a number is passed then the cursor is set to this position in the path element array.\n   * @return {Chartist.Svg.Path|Number} If the position parameter was passed then the return value will be the path object for easy call chaining. If no position parameter was passed then the current position is returned.\n   */\n  function position(pos) {\n    if(pos !== undefined) {\n      this.pos = Math.max(0, Math.min(this.pathElements.length, pos));\n      return this;\n    } else {\n      return this.pos;\n    }\n  }\n\n  /**\n   * Removes elements from the path starting at the current position.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} count Number of path elements that should be removed from the current position.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function remove(count) {\n    this.pathElements.splice(this.pos, count);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new move SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The x coordinate for the move element.\n   * @param {Number} y The y coordinate for the move element.\n   * @param {Boolean} [relative] If set to true the move element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function move(x, y, relative, data) {\n    element('M', {\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new line SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The x coordinate for the line element.\n   * @param {Number} y The y coordinate for the line element.\n   * @param {Boolean} [relative] If set to true the line element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function line(x, y, relative, data) {\n    element('L', {\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new curve SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x1 The x coordinate for the first control point of the bezier curve.\n   * @param {Number} y1 The y coordinate for the first control point of the bezier curve.\n   * @param {Number} x2 The x coordinate for the second control point of the bezier curve.\n   * @param {Number} y2 The y coordinate for the second control point of the bezier curve.\n   * @param {Number} x The x coordinate for the target point of the curve element.\n   * @param {Number} y The y coordinate for the target point of the curve element.\n   * @param {Boolean} [relative] If set to true the curve element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function curve(x1, y1, x2, y2, x, y, relative, data) {\n    element('C', {\n      x1: +x1,\n      y1: +y1,\n      x2: +x2,\n      y2: +y2,\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Use this function to add a new non-bezier curve SVG path element.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} rx The radius to be used for the x-axis of the arc.\n   * @param {Number} ry The radius to be used for the y-axis of the arc.\n   * @param {Number} xAr Defines the orientation of the arc\n   * @param {Number} lAf Large arc flag\n   * @param {Number} sf Sweep flag\n   * @param {Number} x The x coordinate for the target point of the curve element.\n   * @param {Number} y The y coordinate for the target point of the curve element.\n   * @param {Boolean} [relative] If set to true the curve element will be created with relative coordinates (lowercase letter)\n   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function arc(rx, ry, xAr, lAf, sf, x, y, relative, data) {\n    element('A', {\n      rx: +rx,\n      ry: +ry,\n      xAr: +xAr,\n      lAf: +lAf,\n      sf: +sf,\n      x: +x,\n      y: +y\n    }, this.pathElements, this.pos++, relative, data);\n    return this;\n  }\n\n  /**\n   * Parses an SVG path seen in the d attribute of path elements, and inserts the parsed elements into the existing path object at the current cursor position. Any closing path indicators (Z at the end of the path) will be ignored by the parser as this is provided by the close option in the options of the path object.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {String} path Any SVG path that contains move (m), line (l) or curve (c) components.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function parse(path) {\n    // Parsing the SVG path string into an array of arrays [['M', '10', '10'], ['L', '100', '100']]\n    var chunks = path.replace(/([A-Za-z])([0-9])/g, '$1 $2')\n      .replace(/([0-9])([A-Za-z])/g, '$1 $2')\n      .split(/[\\s,]+/)\n      .reduce(function(result, element) {\n        if(element.match(/[A-Za-z]/)) {\n          result.push([]);\n        }\n\n        result[result.length - 1].push(element);\n        return result;\n      }, []);\n\n    // If this is a closed path we remove the Z at the end because this is determined by the close option\n    if(chunks[chunks.length - 1][0].toUpperCase() === 'Z') {\n      chunks.pop();\n    }\n\n    // Using svgPathElementDescriptions to map raw path arrays into objects that contain the command and the parameters\n    // For example {command: 'M', x: '10', y: '10'}\n    var elements = chunks.map(function(chunk) {\n        var command = chunk.shift(),\n          description = elementDescriptions[command.toLowerCase()];\n\n        return Chartist.extend({\n          command: command\n        }, description.reduce(function(result, paramName, index) {\n          result[paramName] = +chunk[index];\n          return result;\n        }, {}));\n      });\n\n    // Preparing a splice call with the elements array as var arg params and insert the parsed elements at the current position\n    var spliceArgs = [this.pos, 0];\n    Array.prototype.push.apply(spliceArgs, elements);\n    Array.prototype.splice.apply(this.pathElements, spliceArgs);\n    // Increase the internal position by the element count\n    this.pos += elements.length;\n\n    return this;\n  }\n\n  /**\n   * This function renders to current SVG path object into a final SVG string that can be used in the d attribute of SVG path elements. It uses the accuracy option to round big decimals. If the close parameter was set in the constructor of this path object then a path closing Z will be appended to the output string.\n   *\n   * @memberof Chartist.Svg.Path\n   * @return {String}\n   */\n  function stringify() {\n    var accuracyMultiplier = Math.pow(10, this.options.accuracy);\n\n    return this.pathElements.reduce(function(path, pathElement) {\n        var params = elementDescriptions[pathElement.command.toLowerCase()].map(function(paramName) {\n          return this.options.accuracy ?\n            (Math.round(pathElement[paramName] * accuracyMultiplier) / accuracyMultiplier) :\n            pathElement[paramName];\n        }.bind(this));\n\n        return path + pathElement.command + params.join(',');\n      }.bind(this), '') + (this.close ? 'Z' : '');\n  }\n\n  /**\n   * Scales all elements in the current SVG path object. There is an individual parameter for each coordinate. Scaling will also be done for control points of curves, affecting the given coordinate.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The number which will be used to scale the x, x1 and x2 of all path elements.\n   * @param {Number} y The number which will be used to scale the y, y1 and y2 of all path elements.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function scale(x, y) {\n    forEachParam(this.pathElements, function(pathElement, paramName) {\n      pathElement[paramName] *= paramName[0] === 'x' ? x : y;\n    });\n    return this;\n  }\n\n  /**\n   * Translates all elements in the current SVG path object. The translation is relative and there is an individual parameter for each coordinate. Translation will also be done for control points of curves, affecting the given coordinate.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Number} x The number which will be used to translate the x, x1 and x2 of all path elements.\n   * @param {Number} y The number which will be used to translate the y, y1 and y2 of all path elements.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function translate(x, y) {\n    forEachParam(this.pathElements, function(pathElement, paramName) {\n      pathElement[paramName] += paramName[0] === 'x' ? x : y;\n    });\n    return this;\n  }\n\n  /**\n   * This function will run over all existing path elements and then loop over their attributes. The callback function will be called for every path element attribute that exists in the current path.\n   * The method signature of the callback function looks like this:\n   * ```javascript\n   * function(pathElement, paramName, pathElementIndex, paramIndex, pathElements)\n   * ```\n   * If something else than undefined is returned by the callback function, this value will be used to replace the old value. This allows you to build custom transformations of path objects that can't be achieved using the basic transformation functions scale and translate.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Function} transformFnc The callback function for the transformation. Check the signature in the function description.\n   * @return {Chartist.Svg.Path} The current path object for easy call chaining.\n   */\n  function transform(transformFnc) {\n    forEachParam(this.pathElements, function(pathElement, paramName, pathElementIndex, paramIndex, pathElements) {\n      var transformed = transformFnc(pathElement, paramName, pathElementIndex, paramIndex, pathElements);\n      if(transformed || transformed === 0) {\n        pathElement[paramName] = transformed;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * This function clones a whole path object with all its properties. This is a deep clone and path element objects will also be cloned.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Boolean} [close] Optional option to set the new cloned path to closed. If not specified or false, the original path close option will be used.\n   * @return {Chartist.Svg.Path}\n   */\n  function clone(close) {\n    var c = new Chartist.Svg.Path(close || this.close);\n    c.pos = this.pos;\n    c.pathElements = this.pathElements.slice().map(function cloneElements(pathElement) {\n      return Chartist.extend({}, pathElement);\n    });\n    c.options = Chartist.extend({}, this.options);\n    return c;\n  }\n\n  /**\n   * Split a Svg.Path object by a specific command in the path chain. The path chain will be split and an array of newly created paths objects will be returned. This is useful if you'd like to split an SVG path by it's move commands, for example, in order to isolate chunks of drawings.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {String} command The command you'd like to use to split the path\n   * @return {Array<Chartist.Svg.Path>}\n   */\n  function splitByCommand(command) {\n    var split = [\n      new Chartist.Svg.Path()\n    ];\n\n    this.pathElements.forEach(function(pathElement) {\n      if(pathElement.command === command.toUpperCase() && split[split.length - 1].pathElements.length !== 0) {\n        split.push(new Chartist.Svg.Path());\n      }\n\n      split[split.length - 1].pathElements.push(pathElement);\n    });\n\n    return split;\n  }\n\n  /**\n   * This static function on `Chartist.Svg.Path` is joining multiple paths together into one paths.\n   *\n   * @memberof Chartist.Svg.Path\n   * @param {Array<Chartist.Svg.Path>} paths A list of paths to be joined together. The order is important.\n   * @param {boolean} close If the newly created path should be a closed path\n   * @param {Object} options Path options for the newly created path.\n   * @return {Chartist.Svg.Path}\n   */\n\n  function join(paths, close, options) {\n    var joinedPath = new Chartist.Svg.Path(close, options);\n    for(var i = 0; i < paths.length; i++) {\n      var path = paths[i];\n      for(var j = 0; j < path.pathElements.length; j++) {\n        joinedPath.pathElements.push(path.pathElements[j]);\n      }\n    }\n    return joinedPath;\n  }\n\n  Chartist.Svg.Path = Chartist.Class.extend({\n    constructor: SvgPath,\n    position: position,\n    remove: remove,\n    move: move,\n    line: line,\n    curve: curve,\n    arc: arc,\n    scale: scale,\n    translate: translate,\n    transform: transform,\n    parse: parse,\n    stringify: stringify,\n    clone: clone,\n    splitByCommand: splitByCommand\n  });\n\n  Chartist.Svg.Path.elementDescriptions = elementDescriptions;\n  Chartist.Svg.Path.join = join;\n}(this || global, Chartist));\n;/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  var axisUnits = {\n    x: {\n      pos: 'x',\n      len: 'width',\n      dir: 'horizontal',\n      rectStart: 'x1',\n      rectEnd: 'x2',\n      rectOffset: 'y2'\n    },\n    y: {\n      pos: 'y',\n      len: 'height',\n      dir: 'vertical',\n      rectStart: 'y2',\n      rectEnd: 'y1',\n      rectOffset: 'x1'\n    }\n  };\n\n  function Axis(units, chartRect, ticks, options) {\n    this.units = units;\n    this.counterUnits = units === axisUnits.x ? axisUnits.y : axisUnits.x;\n    this.chartRect = chartRect;\n    this.axisLength = chartRect[units.rectEnd] - chartRect[units.rectStart];\n    this.gridOffset = chartRect[units.rectOffset];\n    this.ticks = ticks;\n    this.options = options;\n  }\n\n  function createGridAndLabels(gridGroup, labelGroup, useForeignObject, chartOptions, eventEmitter) {\n    var axisOptions = chartOptions['axis' + this.units.pos.toUpperCase()];\n    var projectedValues = this.ticks.map(this.projectValue.bind(this));\n    var labelValues = this.ticks.map(axisOptions.labelInterpolationFnc);\n\n    projectedValues.forEach(function(projectedValue, index) {\n      var labelOffset = {\n        x: 0,\n        y: 0\n      };\n\n      // TODO: Find better solution for solving this problem\n      // Calculate how much space we have available for the label\n      var labelLength;\n      if(projectedValues[index + 1]) {\n        // If we still have one label ahead, we can calculate the distance to the next tick / label\n        labelLength = projectedValues[index + 1] - projectedValue;\n      } else {\n        // If we don't have a label ahead and we have only two labels in total, we just take the remaining distance to\n        // on the whole axis length. We limit that to a minimum of 30 pixel, so that labels close to the border will\n        // still be visible inside of the chart padding.\n        labelLength = Math.max(this.axisLength - projectedValue, 30);\n      }\n\n      // Skip grid lines and labels where interpolated label values are falsey (execpt for 0)\n      if(Chartist.isFalseyButZero(labelValues[index]) && labelValues[index] !== '') {\n        return;\n      }\n\n      // Transform to global coordinates using the chartRect\n      // We also need to set the label offset for the createLabel function\n      if(this.units.pos === 'x') {\n        projectedValue = this.chartRect.x1 + projectedValue;\n        labelOffset.x = chartOptions.axisX.labelOffset.x;\n\n        // If the labels should be positioned in start position (top side for vertical axis) we need to set a\n        // different offset as for positioned with end (bottom)\n        if(chartOptions.axisX.position === 'start') {\n          labelOffset.y = this.chartRect.padding.top + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);\n        } else {\n          labelOffset.y = this.chartRect.y1 + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);\n        }\n      } else {\n        projectedValue = this.chartRect.y1 - projectedValue;\n        labelOffset.y = chartOptions.axisY.labelOffset.y - (useForeignObject ? labelLength : 0);\n\n        // If the labels should be positioned in start position (left side for horizontal axis) we need to set a\n        // different offset as for positioned with end (right side)\n        if(chartOptions.axisY.position === 'start') {\n          labelOffset.x = useForeignObject ? this.chartRect.padding.left + chartOptions.axisY.labelOffset.x : this.chartRect.x1 - 10;\n        } else {\n          labelOffset.x = this.chartRect.x2 + chartOptions.axisY.labelOffset.x + 10;\n        }\n      }\n\n      if(axisOptions.showGrid) {\n        Chartist.createGrid(projectedValue, index, this, this.gridOffset, this.chartRect[this.counterUnits.len](), gridGroup, [\n          chartOptions.classNames.grid,\n          chartOptions.classNames[this.units.dir]\n        ], eventEmitter);\n      }\n\n      if(axisOptions.showLabel) {\n        Chartist.createLabel(projectedValue, labelLength, index, labelValues, this, axisOptions.offset, labelOffset, labelGroup, [\n          chartOptions.classNames.label,\n          chartOptions.classNames[this.units.dir],\n          (axisOptions.position === 'start' ? chartOptions.classNames[axisOptions.position] : chartOptions.classNames['end'])\n        ], useForeignObject, eventEmitter);\n      }\n    }.bind(this));\n  }\n\n  Chartist.Axis = Chartist.Class.extend({\n    constructor: Axis,\n    createGridAndLabels: createGridAndLabels,\n    projectValue: function(value, index, data) {\n      throw new Error('Base axis can\\'t be instantiated!');\n    }\n  });\n\n  Chartist.Axis.units = axisUnits;\n\n}(this || global, Chartist));\n;/**\n * The auto scale axis uses standard linear scale projection of values along an axis. It uses order of magnitude to find a scale automatically and evaluates the available space in order to find the perfect amount of ticks for your chart.\n * **Options**\n * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.\n * ```javascript\n * var options = {\n *   // If high is specified then the axis will display values explicitly up to this value and the computed maximum from the data is ignored\n *   high: 100,\n *   // If low is specified then the axis will display values explicitly down to this value and the computed minimum from the data is ignored\n *   low: 0,\n *   // This option will be used when finding the right scale division settings. The amount of ticks on the scale will be determined so that as many ticks as possible will be displayed, while not violating this minimum required space (in pixel).\n *   scaleMinSpace: 20,\n *   // Can be set to true or false. If set to true, the scale will be generated with whole numbers only.\n *   onlyInteger: true,\n *   // The reference value can be used to make sure that this value will always be on the chart. This is especially useful on bipolar charts where the bipolar center always needs to be part of the chart.\n *   referenceValue: 5\n * };\n * ```\n *\n * @module Chartist.AutoScaleAxis\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  function AutoScaleAxis(axisUnit, data, chartRect, options) {\n    // Usually we calculate highLow based on the data but this can be overriden by a highLow object in the options\n    var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);\n    this.bounds = Chartist.getBounds(chartRect[axisUnit.rectEnd] - chartRect[axisUnit.rectStart], highLow, options.scaleMinSpace || 20, options.onlyInteger);\n    this.range = {\n      min: this.bounds.min,\n      max: this.bounds.max\n    };\n\n    Chartist.AutoScaleAxis.super.constructor.call(this,\n      axisUnit,\n      chartRect,\n      this.bounds.values,\n      options);\n  }\n\n  function projectValue(value) {\n    return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.bounds.min) / this.bounds.range;\n  }\n\n  Chartist.AutoScaleAxis = Chartist.Axis.extend({\n    constructor: AutoScaleAxis,\n    projectValue: projectValue\n  });\n\n}(this || global, Chartist));\n;/**\n * The fixed scale axis uses standard linear projection of values along an axis. It makes use of a divisor option to divide the range provided from the minimum and maximum value or the options high and low that will override the computed minimum and maximum.\n * **Options**\n * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.\n * ```javascript\n * var options = {\n *   // If high is specified then the axis will display values explicitly up to this value and the computed maximum from the data is ignored\n *   high: 100,\n *   // If low is specified then the axis will display values explicitly down to this value and the computed minimum from the data is ignored\n *   low: 0,\n *   // If specified then the value range determined from minimum to maximum (or low and high) will be divided by this number and ticks will be generated at those division points. The default divisor is 1.\n *   divisor: 4,\n *   // If ticks is explicitly set, then the axis will not compute the ticks with the divisor, but directly use the data in ticks to determine at what points on the axis a tick need to be generated.\n *   ticks: [1, 10, 20, 30]\n * };\n * ```\n *\n * @module Chartist.FixedScaleAxis\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  function FixedScaleAxis(axisUnit, data, chartRect, options) {\n    var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);\n    this.divisor = options.divisor || 1;\n    this.ticks = options.ticks || Chartist.times(this.divisor).map(function(value, index) {\n      return highLow.low + (highLow.high - highLow.low) / this.divisor * index;\n    }.bind(this));\n    this.ticks.sort(function(a, b) {\n      return a - b;\n    });\n    this.range = {\n      min: highLow.low,\n      max: highLow.high\n    };\n\n    Chartist.FixedScaleAxis.super.constructor.call(this,\n      axisUnit,\n      chartRect,\n      this.ticks,\n      options);\n\n    this.stepLength = this.axisLength / this.divisor;\n  }\n\n  function projectValue(value) {\n    return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.range.min) / (this.range.max - this.range.min);\n  }\n\n  Chartist.FixedScaleAxis = Chartist.Axis.extend({\n    constructor: FixedScaleAxis,\n    projectValue: projectValue\n  });\n\n}(this || global, Chartist));\n;/**\n * The step axis for step based charts like bar chart or step based line charts. It uses a fixed amount of ticks that will be equally distributed across the whole axis length. The projection is done using the index of the data value rather than the value itself and therefore it's only useful for distribution purpose.\n * **Options**\n * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.\n * ```javascript\n * var options = {\n *   // Ticks to be used to distribute across the axis length. As this axis type relies on the index of the value rather than the value, arbitrary data that can be converted to a string can be used as ticks.\n *   ticks: ['One', 'Two', 'Three'],\n *   // If set to true the full width will be used to distribute the values where the last value will be at the maximum of the axis length. If false the spaces between the ticks will be evenly distributed instead.\n *   stretch: true\n * };\n * ```\n *\n * @module Chartist.StepAxis\n */\n/* global Chartist */\n(function (globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  function StepAxis(axisUnit, data, chartRect, options) {\n    Chartist.StepAxis.super.constructor.call(this,\n      axisUnit,\n      chartRect,\n      options.ticks,\n      options);\n\n    var calc = Math.max(1, options.ticks.length - (options.stretch ? 1 : 0));\n    this.stepLength = this.axisLength / calc;\n  }\n\n  function projectValue(value, index) {\n    return this.stepLength * index;\n  }\n\n  Chartist.StepAxis = Chartist.Axis.extend({\n    constructor: StepAxis,\n    projectValue: projectValue\n  });\n\n}(this || global, Chartist));\n;/**\n * The Chartist line chart can be used to draw Line or Scatter charts. If used in the browser you can access the global `Chartist` namespace where you find the `Line` function as a main entry point.\n *\n * For examples on how to use the line chart please check the examples of the `Chartist.Line` method.\n *\n * @module Chartist.Line\n */\n/* global Chartist */\n(function(globalRoot, Chartist){\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * Default options in line charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.Line\n   */\n  var defaultOptions = {\n    // Options for X-Axis\n    axisX: {\n      // The offset of the labels to the chart area\n      offset: 30,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'end',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // Set the axis type to be used to project values on this axis. If not defined, Chartist.StepAxis will be used for the X-Axis, where the ticks option will be set to the labels in the data and the stretch option will be set to the global fullWidth option. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.\n      type: undefined\n    },\n    // Options for Y-Axis\n    axisY: {\n      // The offset of the labels to the chart area\n      offset: 40,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'start',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // Set the axis type to be used to project values on this axis. If not defined, Chartist.AutoScaleAxis will be used for the Y-Axis, where the high and low options will be set to the global high and low options. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.\n      type: undefined,\n      // This value specifies the minimum height in pixel of the scale steps\n      scaleMinSpace: 20,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // If the line should be drawn or not\n    showLine: true,\n    // If dots should be drawn or not\n    showPoint: true,\n    // If the line chart should draw an area\n    showArea: false,\n    // The base for the area chart that will be used to close the area shape (is normally 0)\n    areaBase: 0,\n    // Specify if the lines should be smoothed. This value can be true or false where true will result in smoothing using the default smoothing interpolation function Chartist.Interpolation.cardinal and false results in Chartist.Interpolation.none. You can also choose other smoothing / interpolation functions available in the Chartist.Interpolation module, or write your own interpolation function. Check the examples for a brief description.\n    lineSmooth: true,\n    // If the line chart should add a background fill to the .ct-grids group.\n    showGridBackground: false,\n    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value\n    low: undefined,\n    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value\n    high: undefined,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: {\n      top: 15,\n      right: 15,\n      bottom: 5,\n      left: 10\n    },\n    // When set to true, the last grid line on the x-axis is not drawn and the chart elements will expand to the full available width of the chart. For the last label to be drawn correctly you might need to add chart padding or offset the last label with a draw event handler.\n    fullWidth: false,\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // Override the class names that get used to generate the SVG structure of the chart\n    classNames: {\n      chart: 'ct-chart-line',\n      label: 'ct-label',\n      labelGroup: 'ct-labels',\n      series: 'ct-series',\n      line: 'ct-line',\n      point: 'ct-point',\n      area: 'ct-area',\n      grid: 'ct-grid',\n      gridGroup: 'ct-grids',\n      gridBackground: 'ct-grid-background',\n      vertical: 'ct-vertical',\n      horizontal: 'ct-horizontal',\n      start: 'ct-start',\n      end: 'ct-end'\n    }\n  };\n\n  /**\n   * Creates a new chart\n   *\n   */\n  function createChart(options) {\n    var data = Chartist.normalizeData(this.data, options.reverseData, true);\n\n    // Create new svg object\n    this.svg = Chartist.createSvg(this.container, options.width, options.height, options.classNames.chart);\n    // Create groups for labels, grid and series\n    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);\n    var seriesGroup = this.svg.elem('g');\n    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);\n\n    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n    var axisX, axisY;\n\n    if(options.axisX.type === undefined) {\n      axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n        ticks: data.normalized.labels,\n        stretch: options.fullWidth\n      }));\n    } else {\n      axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);\n    }\n\n    if(options.axisY.type === undefined) {\n      axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n        high: Chartist.isNumeric(options.high) ? options.high : options.axisY.high,\n        low: Chartist.isNumeric(options.low) ? options.low : options.axisY.low\n      }));\n    } else {\n      axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);\n    }\n\n    axisX.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n    axisY.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n\n    if (options.showGridBackground) {\n      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);\n    }\n\n    // Draw the series\n    data.raw.series.forEach(function(series, seriesIndex) {\n      var seriesElement = seriesGroup.elem('g');\n\n      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written\n      seriesElement.attr({\n        'ct:series-name': series.name,\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesElement.addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))\n      ].join(' '));\n\n      var pathCoordinates = [],\n        pathData = [];\n\n      data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {\n        var p = {\n          x: chartRect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),\n          y: chartRect.y1 - axisY.projectValue(value, valueIndex, data.normalized.series[seriesIndex])\n        };\n        pathCoordinates.push(p.x, p.y);\n        pathData.push({\n          value: value,\n          valueIndex: valueIndex,\n          meta: Chartist.getMetaData(series, valueIndex)\n        });\n      }.bind(this));\n\n      var seriesOptions = {\n        lineSmooth: Chartist.getSeriesOption(series, options, 'lineSmooth'),\n        showPoint: Chartist.getSeriesOption(series, options, 'showPoint'),\n        showLine: Chartist.getSeriesOption(series, options, 'showLine'),\n        showArea: Chartist.getSeriesOption(series, options, 'showArea'),\n        areaBase: Chartist.getSeriesOption(series, options, 'areaBase')\n      };\n\n      var smoothing = typeof seriesOptions.lineSmooth === 'function' ?\n        seriesOptions.lineSmooth : (seriesOptions.lineSmooth ? Chartist.Interpolation.monotoneCubic() : Chartist.Interpolation.none());\n      // Interpolating path where pathData will be used to annotate each path element so we can trace back the original\n      // index, value and meta data\n      var path = smoothing(pathCoordinates, pathData);\n\n      // If we should show points we need to create them now to avoid secondary loop\n      // Points are drawn from the pathElements returned by the interpolation function\n      // Small offset for Firefox to render squares correctly\n      if (seriesOptions.showPoint) {\n\n        path.pathElements.forEach(function(pathElement) {\n          var point = seriesElement.elem('line', {\n            x1: pathElement.x,\n            y1: pathElement.y,\n            x2: pathElement.x + 0.01,\n            y2: pathElement.y\n          }, options.classNames.point).attr({\n            'ct:value': [pathElement.data.value.x, pathElement.data.value.y].filter(Chartist.isNumeric).join(','),\n            'ct:meta': Chartist.serialize(pathElement.data.meta)\n          });\n\n          this.eventEmitter.emit('draw', {\n            type: 'point',\n            value: pathElement.data.value,\n            index: pathElement.data.valueIndex,\n            meta: pathElement.data.meta,\n            series: series,\n            seriesIndex: seriesIndex,\n            axisX: axisX,\n            axisY: axisY,\n            group: seriesElement,\n            element: point,\n            x: pathElement.x,\n            y: pathElement.y\n          });\n        }.bind(this));\n      }\n\n      if(seriesOptions.showLine) {\n        var line = seriesElement.elem('path', {\n          d: path.stringify()\n        }, options.classNames.line, true);\n\n        this.eventEmitter.emit('draw', {\n          type: 'line',\n          values: data.normalized.series[seriesIndex],\n          path: path.clone(),\n          chartRect: chartRect,\n          index: seriesIndex,\n          series: series,\n          seriesIndex: seriesIndex,\n          seriesMeta: series.meta,\n          axisX: axisX,\n          axisY: axisY,\n          group: seriesElement,\n          element: line\n        });\n      }\n\n      // Area currently only works with axes that support a range!\n      if(seriesOptions.showArea && axisY.range) {\n        // If areaBase is outside the chart area (< min or > max) we need to set it respectively so that\n        // the area is not drawn outside the chart area.\n        var areaBase = Math.max(Math.min(seriesOptions.areaBase, axisY.range.max), axisY.range.min);\n\n        // We project the areaBase value into screen coordinates\n        var areaBaseProjected = chartRect.y1 - axisY.projectValue(areaBase);\n\n        // In order to form the area we'll first split the path by move commands so we can chunk it up into segments\n        path.splitByCommand('M').filter(function onlySolidSegments(pathSegment) {\n          // We filter only \"solid\" segments that contain more than one point. Otherwise there's no need for an area\n          return pathSegment.pathElements.length > 1;\n        }).map(function convertToArea(solidPathSegments) {\n          // Receiving the filtered solid path segments we can now convert those segments into fill areas\n          var firstElement = solidPathSegments.pathElements[0];\n          var lastElement = solidPathSegments.pathElements[solidPathSegments.pathElements.length - 1];\n\n          // Cloning the solid path segment with closing option and removing the first move command from the clone\n          // We then insert a new move that should start at the area base and draw a straight line up or down\n          // at the end of the path we add an additional straight line to the projected area base value\n          // As the closing option is set our path will be automatically closed\n          return solidPathSegments.clone(true)\n            .position(0)\n            .remove(1)\n            .move(firstElement.x, areaBaseProjected)\n            .line(firstElement.x, firstElement.y)\n            .position(solidPathSegments.pathElements.length + 1)\n            .line(lastElement.x, areaBaseProjected);\n\n        }).forEach(function createArea(areaPath) {\n          // For each of our newly created area paths, we'll now create path elements by stringifying our path objects\n          // and adding the created DOM elements to the correct series group\n          var area = seriesElement.elem('path', {\n            d: areaPath.stringify()\n          }, options.classNames.area, true);\n\n          // Emit an event for each area that was drawn\n          this.eventEmitter.emit('draw', {\n            type: 'area',\n            values: data.normalized.series[seriesIndex],\n            path: areaPath.clone(),\n            series: series,\n            seriesIndex: seriesIndex,\n            axisX: axisX,\n            axisY: axisY,\n            chartRect: chartRect,\n            index: seriesIndex,\n            group: seriesElement,\n            element: area\n          });\n        }.bind(this));\n      }\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      bounds: axisY.bounds,\n      chartRect: chartRect,\n      axisX: axisX,\n      axisY: axisY,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new line chart.\n   *\n   * @memberof Chartist.Line\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object that needs to consist of a labels and a series array\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object which exposes the API for the created chart\n   *\n   * @example\n   * // Create a simple line chart\n   * var data = {\n   *   // A labels array that can contain any sort of values\n   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n   *   // Our series array that contains series objects or in this case series data arrays\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // As options we currently only set a static size of 300x200 px\n   * var options = {\n   *   width: '300px',\n   *   height: '200px'\n   * };\n   *\n   * // In the global name space Chartist we call the Line function to initialize a line chart. As a first parameter we pass in a selector where we would like to get our chart created. Second parameter is the actual data object and as a third parameter we pass in our options\n   * new Chartist.Line('.ct-chart', data, options);\n   *\n   * @example\n   * // Use specific interpolation function with configuration from the Chartist.Interpolation module\n   *\n   * var chart = new Chartist.Line('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [\n   *     [1, 1, 8, 1, 7]\n   *   ]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.cardinal({\n   *     tension: 0.2\n   *   })\n   * });\n   *\n   * @example\n   * // Create a line chart with responsive options\n   *\n   * var data = {\n   *   // A labels array that can contain any sort of values\n   *   labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n   *   // Our series array that contains series objects or in this case series data arrays\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // In addition to the regular options we specify responsive option overrides that will override the default configutation based on the matching media queries.\n   * var responsiveOptions = [\n   *   ['screen and (min-width: 641px) and (max-width: 1024px)', {\n   *     showPoint: false,\n   *     axisX: {\n   *       labelInterpolationFnc: function(value) {\n   *         // Will return Mon, Tue, Wed etc. on medium screens\n   *         return value.slice(0, 3);\n   *       }\n   *     }\n   *   }],\n   *   ['screen and (max-width: 640px)', {\n   *     showLine: false,\n   *     axisX: {\n   *       labelInterpolationFnc: function(value) {\n   *         // Will return M, T, W etc. on small screens\n   *         return value[0];\n   *       }\n   *     }\n   *   }]\n   * ];\n   *\n   * new Chartist.Line('.ct-chart', data, null, responsiveOptions);\n   *\n   */\n  function Line(query, data, options, responsiveOptions) {\n    Chartist.Line.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating line chart type in Chartist namespace\n  Chartist.Line = Chartist.Base.extend({\n    constructor: Line,\n    createChart: createChart\n  });\n\n}(this || global, Chartist));\n;/**\n * The bar chart module of Chartist that can be used to draw unipolar or bipolar bar and grouped bar charts.\n *\n * @module Chartist.Bar\n */\n/* global Chartist */\n(function(globalRoot, Chartist){\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * Default options in bar charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.Bar\n   */\n  var defaultOptions = {\n    // Options for X-Axis\n    axisX: {\n      // The offset of the chart drawing area to the border of the container\n      offset: 30,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'end',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // This value specifies the minimum width in pixel of the scale steps\n      scaleMinSpace: 30,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Options for Y-Axis\n    axisY: {\n      // The offset of the chart drawing area to the border of the container\n      offset: 40,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'start',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // This value specifies the minimum height in pixel of the scale steps\n      scaleMinSpace: 20,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value\n    high: undefined,\n    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value\n    low: undefined,\n    // Unless low/high are explicitly set, bar chart will be centered at zero by default. Set referenceValue to null to auto scale.\n    referenceValue: 0,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: {\n      top: 15,\n      right: 15,\n      bottom: 5,\n      left: 10\n    },\n    // Specify the distance in pixel of bars in a group\n    seriesBarDistance: 15,\n    // If set to true this property will cause the series bars to be stacked. Check the `stackMode` option for further stacking options.\n    stackBars: false,\n    // If set to 'overlap' this property will force the stacked bars to draw from the zero line.\n    // If set to 'accumulate' this property will form a total for each series point. This will also influence the y-axis and the overall bounds of the chart. In stacked mode the seriesBarDistance property will have no effect.\n    stackMode: 'accumulate',\n    // Inverts the axes of the bar chart in order to draw a horizontal bar chart. Be aware that you also need to invert your axis settings as the Y Axis will now display the labels and the X Axis the values.\n    horizontalBars: false,\n    // If set to true then each bar will represent a series and the data array is expected to be a one dimensional array of data values rather than a series array of series. This is useful if the bar chart should represent a profile rather than some data over time.\n    distributeSeries: false,\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // If the bar chart should add a background fill to the .ct-grids group.\n    showGridBackground: false,\n    // Override the class names that get used to generate the SVG structure of the chart\n    classNames: {\n      chart: 'ct-chart-bar',\n      horizontalBars: 'ct-horizontal-bars',\n      label: 'ct-label',\n      labelGroup: 'ct-labels',\n      series: 'ct-series',\n      bar: 'ct-bar',\n      grid: 'ct-grid',\n      gridGroup: 'ct-grids',\n      gridBackground: 'ct-grid-background',\n      vertical: 'ct-vertical',\n      horizontal: 'ct-horizontal',\n      start: 'ct-start',\n      end: 'ct-end'\n    }\n  };\n\n  /**\n   * Creates a new chart\n   *\n   */\n  function createChart(options) {\n    var data;\n    var highLow;\n\n    if(options.distributeSeries) {\n      data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');\n      data.normalized.series = data.normalized.series.map(function(value) {\n        return [value];\n      });\n    } else {\n      data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');\n    }\n\n    // Create new svg element\n    this.svg = Chartist.createSvg(\n      this.container,\n      options.width,\n      options.height,\n      options.classNames.chart + (options.horizontalBars ? ' ' + options.classNames.horizontalBars : '')\n    );\n\n    // Drawing groups in correct order\n    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);\n    var seriesGroup = this.svg.elem('g');\n    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);\n\n    if(options.stackBars && data.normalized.series.length !== 0) {\n\n      // If stacked bars we need to calculate the high low from stacked values from each series\n      var serialSums = Chartist.serialMap(data.normalized.series, function serialSums() {\n        return Array.prototype.slice.call(arguments).map(function(value) {\n          return value;\n        }).reduce(function(prev, curr) {\n          return {\n            x: prev.x + (curr && curr.x) || 0,\n            y: prev.y + (curr && curr.y) || 0\n          };\n        }, {x: 0, y: 0});\n      });\n\n      highLow = Chartist.getHighLow([serialSums], options, options.horizontalBars ? 'x' : 'y');\n\n    } else {\n\n      highLow = Chartist.getHighLow(data.normalized.series, options, options.horizontalBars ? 'x' : 'y');\n    }\n\n    // Overrides of high / low from settings\n    highLow.high = +options.high || (options.high === 0 ? 0 : highLow.high);\n    highLow.low = +options.low || (options.low === 0 ? 0 : highLow.low);\n\n    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n\n    var valueAxis,\n      labelAxisTicks,\n      labelAxis,\n      axisX,\n      axisY;\n\n    // We need to set step count based on some options combinations\n    if(options.distributeSeries && options.stackBars) {\n      // If distributed series are enabled and bars need to be stacked, we'll only have one bar and therefore should\n      // use only the first label for the step axis\n      labelAxisTicks = data.normalized.labels.slice(0, 1);\n    } else {\n      // If distributed series are enabled but stacked bars aren't, we should use the series labels\n      // If we are drawing a regular bar chart with two dimensional series data, we just use the labels array\n      // as the bars are normalized\n      labelAxisTicks = data.normalized.labels;\n    }\n\n    // Set labelAxis and valueAxis based on the horizontalBars setting. This setting will flip the axes if necessary.\n    if(options.horizontalBars) {\n      if(options.axisX.type === undefined) {\n        valueAxis = axisX = new Chartist.AutoScaleAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      } else {\n        valueAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      }\n\n      if(options.axisY.type === undefined) {\n        labelAxis = axisY = new Chartist.StepAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, {\n          ticks: labelAxisTicks\n        });\n      } else {\n        labelAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);\n      }\n    } else {\n      if(options.axisX.type === undefined) {\n        labelAxis = axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, {\n          ticks: labelAxisTicks\n        });\n      } else {\n        labelAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);\n      }\n\n      if(options.axisY.type === undefined) {\n        valueAxis = axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      } else {\n        valueAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n          highLow: highLow,\n          referenceValue: 0\n        }));\n      }\n    }\n\n    // Projected 0 point\n    var zeroPoint = options.horizontalBars ? (chartRect.x1 + valueAxis.projectValue(0)) : (chartRect.y1 - valueAxis.projectValue(0));\n    // Used to track the screen coordinates of stacked bars\n    var stackedBarValues = [];\n\n    labelAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n    valueAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n\n    if (options.showGridBackground) {\n      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);\n    }\n\n    // Draw the series\n    data.raw.series.forEach(function(series, seriesIndex) {\n      // Calculating bi-polar value of index for seriesOffset. For i = 0..4 biPol will be -1.5, -0.5, 0.5, 1.5 etc.\n      var biPol = seriesIndex - (data.raw.series.length - 1) / 2;\n      // Half of the period width between vertical grid lines used to position bars\n      var periodHalfLength;\n      // Current series SVG element\n      var seriesElement;\n\n      // We need to set periodHalfLength based on some options combinations\n      if(options.distributeSeries && !options.stackBars) {\n        // If distributed series are enabled but stacked bars aren't, we need to use the length of the normaizedData array\n        // which is the series count and divide by 2\n        periodHalfLength = labelAxis.axisLength / data.normalized.series.length / 2;\n      } else if(options.distributeSeries && options.stackBars) {\n        // If distributed series and stacked bars are enabled we'll only get one bar so we should just divide the axis\n        // length by 2\n        periodHalfLength = labelAxis.axisLength / 2;\n      } else {\n        // On regular bar charts we should just use the series length\n        periodHalfLength = labelAxis.axisLength / data.normalized.series[seriesIndex].length / 2;\n      }\n\n      // Adding the series group to the series element\n      seriesElement = seriesGroup.elem('g');\n\n      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written\n      seriesElement.attr({\n        'ct:series-name': series.name,\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesElement.addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))\n      ].join(' '));\n\n      data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {\n        var projected,\n          bar,\n          previousStack,\n          labelAxisValueIndex;\n\n        // We need to set labelAxisValueIndex based on some options combinations\n        if(options.distributeSeries && !options.stackBars) {\n          // If distributed series are enabled but stacked bars aren't, we can use the seriesIndex for later projection\n          // on the step axis for label positioning\n          labelAxisValueIndex = seriesIndex;\n        } else if(options.distributeSeries && options.stackBars) {\n          // If distributed series and stacked bars are enabled, we will only get one bar and therefore always use\n          // 0 for projection on the label step axis\n          labelAxisValueIndex = 0;\n        } else {\n          // On regular bar charts we just use the value index to project on the label step axis\n          labelAxisValueIndex = valueIndex;\n        }\n\n        // We need to transform coordinates differently based on the chart layout\n        if(options.horizontalBars) {\n          projected = {\n            x: chartRect.x1 + valueAxis.projectValue(value && value.x ? value.x : 0, valueIndex, data.normalized.series[seriesIndex]),\n            y: chartRect.y1 - labelAxis.projectValue(value && value.y ? value.y : 0, labelAxisValueIndex, data.normalized.series[seriesIndex])\n          };\n        } else {\n          projected = {\n            x: chartRect.x1 + labelAxis.projectValue(value && value.x ? value.x : 0, labelAxisValueIndex, data.normalized.series[seriesIndex]),\n            y: chartRect.y1 - valueAxis.projectValue(value && value.y ? value.y : 0, valueIndex, data.normalized.series[seriesIndex])\n          }\n        }\n\n        // If the label axis is a step based axis we will offset the bar into the middle of between two steps using\n        // the periodHalfLength value. Also we do arrange the different series so that they align up to each other using\n        // the seriesBarDistance. If we don't have a step axis, the bar positions can be chosen freely so we should not\n        // add any automated positioning.\n        if(labelAxis instanceof Chartist.StepAxis) {\n          // Offset to center bar between grid lines, but only if the step axis is not stretched\n          if(!labelAxis.options.stretch) {\n            projected[labelAxis.units.pos] += periodHalfLength * (options.horizontalBars ? -1 : 1);\n          }\n          // Using bi-polar offset for multiple series if no stacked bars or series distribution is used\n          projected[labelAxis.units.pos] += (options.stackBars || options.distributeSeries) ? 0 : biPol * options.seriesBarDistance * (options.horizontalBars ? -1 : 1);\n        }\n\n        // Enter value in stacked bar values used to remember previous screen value for stacking up bars\n        previousStack = stackedBarValues[valueIndex] || zeroPoint;\n        stackedBarValues[valueIndex] = previousStack - (zeroPoint - projected[labelAxis.counterUnits.pos]);\n\n        // Skip if value is undefined\n        if(value === undefined) {\n          return;\n        }\n\n        var positions = {};\n        positions[labelAxis.units.pos + '1'] = projected[labelAxis.units.pos];\n        positions[labelAxis.units.pos + '2'] = projected[labelAxis.units.pos];\n\n        if(options.stackBars && (options.stackMode === 'accumulate' || !options.stackMode)) {\n          // Stack mode: accumulate (default)\n          // If bars are stacked we use the stackedBarValues reference and otherwise base all bars off the zero line\n          // We want backwards compatibility, so the expected fallback without the 'stackMode' option\n          // to be the original behaviour (accumulate)\n          positions[labelAxis.counterUnits.pos + '1'] = previousStack;\n          positions[labelAxis.counterUnits.pos + '2'] = stackedBarValues[valueIndex];\n        } else {\n          // Draw from the zero line normally\n          // This is also the same code for Stack mode: overlap\n          positions[labelAxis.counterUnits.pos + '1'] = zeroPoint;\n          positions[labelAxis.counterUnits.pos + '2'] = projected[labelAxis.counterUnits.pos];\n        }\n\n        // Limit x and y so that they are within the chart rect\n        positions.x1 = Math.min(Math.max(positions.x1, chartRect.x1), chartRect.x2);\n        positions.x2 = Math.min(Math.max(positions.x2, chartRect.x1), chartRect.x2);\n        positions.y1 = Math.min(Math.max(positions.y1, chartRect.y2), chartRect.y1);\n        positions.y2 = Math.min(Math.max(positions.y2, chartRect.y2), chartRect.y1);\n\n        var metaData = Chartist.getMetaData(series, valueIndex);\n\n        // Create bar element\n        bar = seriesElement.elem('line', positions, options.classNames.bar).attr({\n          'ct:value': [value.x, value.y].filter(Chartist.isNumeric).join(','),\n          'ct:meta': Chartist.serialize(metaData)\n        });\n\n        this.eventEmitter.emit('draw', Chartist.extend({\n          type: 'bar',\n          value: value,\n          index: valueIndex,\n          meta: metaData,\n          series: series,\n          seriesIndex: seriesIndex,\n          axisX: axisX,\n          axisY: axisY,\n          chartRect: chartRect,\n          group: seriesElement,\n          element: bar\n        }, positions));\n      }.bind(this));\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      bounds: valueAxis.bounds,\n      chartRect: chartRect,\n      axisX: axisX,\n      axisY: axisY,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new bar chart and returns API object that you can use for later changes.\n   *\n   * @memberof Chartist.Bar\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object that needs to consist of a labels and a series array\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object which exposes the API for the created chart\n   *\n   * @example\n   * // Create a simple bar chart\n   * var data = {\n   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // In the global name space Chartist we call the Bar function to initialize a bar chart. As a first parameter we pass in a selector where we would like to get our chart created and as a second parameter we pass our data object.\n   * new Chartist.Bar('.ct-chart', data);\n   *\n   * @example\n   * // This example creates a bipolar grouped bar chart where the boundaries are limitted to -10 and 10\n   * new Chartist.Bar('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5, 6, 7],\n   *   series: [\n   *     [1, 3, 2, -5, -3, 1, -6],\n   *     [-5, -2, -4, -1, 2, -3, 1]\n   *   ]\n   * }, {\n   *   seriesBarDistance: 12,\n   *   low: -10,\n   *   high: 10\n   * });\n   *\n   */\n  function Bar(query, data, options, responsiveOptions) {\n    Chartist.Bar.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating bar chart type in Chartist namespace\n  Chartist.Bar = Chartist.Base.extend({\n    constructor: Bar,\n    createChart: createChart\n  });\n\n}(this || global, Chartist));\n;/**\n * The pie chart module of Chartist that can be used to draw pie, donut or gauge charts\n *\n * @module Chartist.Pie\n */\n/* global Chartist */\n(function(globalRoot, Chartist) {\n  'use strict';\n\n  var window = globalRoot.window;\n  var document = globalRoot.document;\n\n  /**\n   * Default options in line charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.Pie\n   */\n  var defaultOptions = {\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: 5,\n    // Override the class names that are used to generate the SVG structure of the chart\n    classNames: {\n      chartPie: 'ct-chart-pie',\n      chartDonut: 'ct-chart-donut',\n      series: 'ct-series',\n      slicePie: 'ct-slice-pie',\n      sliceDonut: 'ct-slice-donut',\n      sliceDonutSolid: 'ct-slice-donut-solid',\n      label: 'ct-label'\n    },\n    // The start angle of the pie chart in degrees where 0 points north. A higher value offsets the start angle clockwise.\n    startAngle: 0,\n    // An optional total you can specify. By specifying a total value, the sum of the values in the series must be this total in order to draw a full pie. You can use this parameter to draw only parts of a pie or gauge charts.\n    total: undefined,\n    // If specified the donut CSS classes will be used and strokes will be drawn instead of pie slices.\n    donut: false,\n    // If specified the donut segments will be drawn as shapes instead of strokes.\n    donutSolid: false,\n    // Specify the donut stroke width, currently done in javascript for convenience. May move to CSS styles in the future.\n    // This option can be set as number or string to specify a relative width (i.e. 100 or '30%').\n    donutWidth: 60,\n    // If a label should be shown or not\n    showLabel: true,\n    // Label position offset from the standard position which is half distance of the radius. This value can be either positive or negative. Positive values will position the label away from the center.\n    labelOffset: 0,\n    // This option can be set to 'inside', 'outside' or 'center'. Positioned with 'inside' the labels will be placed on half the distance of the radius to the border of the Pie by respecting the 'labelOffset'. The 'outside' option will place the labels at the border of the pie and 'center' will place the labels in the absolute center point of the chart. The 'center' option only makes sense in conjunction with the 'labelOffset' option.\n    labelPosition: 'inside',\n    // An interpolation function for the label value\n    labelInterpolationFnc: Chartist.noop,\n    // Label direction can be 'neutral', 'explode' or 'implode'. The labels anchor will be positioned based on those settings as well as the fact if the labels are on the right or left side of the center of the chart. Usually explode is useful when labels are positioned far away from the center.\n    labelDirection: 'neutral',\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // If true empty values will be ignored to avoid drawing unncessary slices and labels\n    ignoreEmptyValues: false\n  };\n\n  /**\n   * Determines SVG anchor position based on direction and center parameter\n   *\n   * @param center\n   * @param label\n   * @param direction\n   * @return {string}\n   */\n  function determineAnchorPosition(center, label, direction) {\n    var toTheRight = label.x > center.x;\n\n    if(toTheRight && direction === 'explode' ||\n      !toTheRight && direction === 'implode') {\n      return 'start';\n    } else if(toTheRight && direction === 'implode' ||\n      !toTheRight && direction === 'explode') {\n      return 'end';\n    } else {\n      return 'middle';\n    }\n  }\n\n  /**\n   * Creates the pie chart\n   *\n   * @param options\n   */\n  function createChart(options) {\n    var data = Chartist.normalizeData(this.data);\n    var seriesGroups = [],\n      labelsGroup,\n      chartRect,\n      radius,\n      labelRadius,\n      totalDataSum,\n      startAngle = options.startAngle;\n\n    // Create SVG.js draw\n    this.svg = Chartist.createSvg(this.container, options.width, options.height,options.donut ? options.classNames.chartDonut : options.classNames.chartPie);\n    // Calculate charting rect\n    chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n    // Get biggest circle radius possible within chartRect\n    radius = Math.min(chartRect.width() / 2, chartRect.height() / 2);\n    // Calculate total of all series to get reference value or use total reference from optional options\n    totalDataSum = options.total || data.normalized.series.reduce(function(previousValue, currentValue) {\n      return previousValue + currentValue;\n    }, 0);\n\n    var donutWidth = Chartist.quantity(options.donutWidth);\n    if (donutWidth.unit === '%') {\n      donutWidth.value *= radius / 100;\n    }\n\n    // If this is a donut chart we need to adjust our radius to enable strokes to be drawn inside\n    // Unfortunately this is not possible with the current SVG Spec\n    // See this proposal for more details: http://lists.w3.org/Archives/Public/www-svg/2003Oct/0000.html\n    radius -= options.donut && !options.donutSolid ? donutWidth.value / 2  : 0;\n\n    // If labelPosition is set to `outside` or a donut chart is drawn then the label position is at the radius,\n    // if regular pie chart it's half of the radius\n    if(options.labelPosition === 'outside' || options.donut && !options.donutSolid) {\n      labelRadius = radius;\n    } else if(options.labelPosition === 'center') {\n      // If labelPosition is center we start with 0 and will later wait for the labelOffset\n      labelRadius = 0;\n    } else if(options.donutSolid) {\n      labelRadius = radius - donutWidth.value / 2;\n    } else {\n      // Default option is 'inside' where we use half the radius so the label will be placed in the center of the pie\n      // slice\n      labelRadius = radius / 2;\n    }\n    // Add the offset to the labelRadius where a negative offset means closed to the center of the chart\n    labelRadius += options.labelOffset;\n\n    // Calculate end angle based on total sum and current data value and offset with padding\n    var center = {\n      x: chartRect.x1 + chartRect.width() / 2,\n      y: chartRect.y2 + chartRect.height() / 2\n    };\n\n    // Check if there is only one non-zero value in the series array.\n    var hasSingleValInSeries = data.raw.series.filter(function(val) {\n      return val.hasOwnProperty('value') ? val.value !== 0 : val !== 0;\n    }).length === 1;\n\n    // Creating the series groups\n    data.raw.series.forEach(function(series, index) {\n      seriesGroups[index] = this.svg.elem('g', null, null);\n    }.bind(this));\n    //if we need to show labels we create the label group now\n    if(options.showLabel) {\n      labelsGroup = this.svg.elem('g', null, null);\n    }\n\n    // Draw the series\n    // initialize series groups\n    data.raw.series.forEach(function(series, index) {\n      // If current value is zero and we are ignoring empty values then skip to next value\n      if (data.normalized.series[index] === 0 && options.ignoreEmptyValues) return;\n\n      // If the series is an object and contains a name or meta data we add a custom attribute\n      seriesGroups[index].attr({\n        'ct:series-name': series.name\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesGroups[index].addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(index))\n      ].join(' '));\n\n      // If the whole dataset is 0 endAngle should be zero. Can't divide by 0.\n      var endAngle = (totalDataSum > 0 ? startAngle + data.normalized.series[index] / totalDataSum * 360 : 0);\n\n      // Use slight offset so there are no transparent hairline issues\n      var overlappigStartAngle = Math.max(0, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));\n\n      // If we need to draw the arc for all 360 degrees we need to add a hack where we close the circle\n      // with Z and use 359.99 degrees\n      if(endAngle - overlappigStartAngle >= 359.99) {\n        endAngle = overlappigStartAngle + 359.99;\n      }\n\n      var start = Chartist.polarToCartesian(center.x, center.y, radius, overlappigStartAngle),\n        end = Chartist.polarToCartesian(center.x, center.y, radius, endAngle);\n\n      var innerStart,\n        innerEnd,\n        donutSolidRadius;\n\n      // Create a new path element for the pie chart. If this isn't a donut chart we should close the path for a correct stroke\n      var path = new Chartist.Svg.Path(!options.donut || options.donutSolid)\n        .move(end.x, end.y)\n        .arc(radius, radius, 0, endAngle - startAngle > 180, 0, start.x, start.y);\n\n      // If regular pie chart (no donut) we add a line to the center of the circle for completing the pie\n      if(!options.donut) {\n        path.line(center.x, center.y);\n      } else if (options.donutSolid) {\n        donutSolidRadius = radius - donutWidth.value;\n        innerStart = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));\n        innerEnd = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, endAngle);\n        path.line(innerStart.x, innerStart.y);\n        path.arc(donutSolidRadius, donutSolidRadius, 0, endAngle - startAngle  > 180, 1, innerEnd.x, innerEnd.y);\n      }\n\n      // Create the SVG path\n      // If this is a donut chart we add the donut class, otherwise just a regular slice\n      var pathClassName = options.classNames.slicePie;\n      if (options.donut) {\n        pathClassName = options.classNames.sliceDonut;\n        if (options.donutSolid) {\n          pathClassName = options.classNames.sliceDonutSolid;\n        }\n      }\n      var pathElement = seriesGroups[index].elem('path', {\n        d: path.stringify()\n      }, pathClassName);\n\n      // Adding the pie series value to the path\n      pathElement.attr({\n        'ct:value': data.normalized.series[index],\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // If this is a donut, we add the stroke-width as style attribute\n      if(options.donut && !options.donutSolid) {\n        pathElement._node.style.strokeWidth = donutWidth.value + 'px';\n      }\n\n      // Fire off draw event\n      this.eventEmitter.emit('draw', {\n        type: 'slice',\n        value: data.normalized.series[index],\n        totalDataSum: totalDataSum,\n        index: index,\n        meta: series.meta,\n        series: series,\n        group: seriesGroups[index],\n        element: pathElement,\n        path: path.clone(),\n        center: center,\n        radius: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n\n      // If we need to show labels we need to add the label for this slice now\n      if(options.showLabel) {\n        var labelPosition;\n        if(data.raw.series.length === 1) {\n          // If we have only 1 series, we can position the label in the center of the pie\n          labelPosition = {\n            x: center.x,\n            y: center.y\n          };\n        } else {\n          // Position at the labelRadius distance from center and between start and end angle\n          labelPosition = Chartist.polarToCartesian(\n            center.x,\n            center.y,\n            labelRadius,\n            startAngle + (endAngle - startAngle) / 2\n          );\n        }\n\n        var rawValue;\n        if(data.normalized.labels && !Chartist.isFalseyButZero(data.normalized.labels[index])) {\n          rawValue = data.normalized.labels[index];\n        } else {\n          rawValue = data.normalized.series[index];\n        }\n\n        var interpolatedValue = options.labelInterpolationFnc(rawValue, index);\n\n        if(interpolatedValue || interpolatedValue === 0) {\n          var labelElement = labelsGroup.elem('text', {\n            dx: labelPosition.x,\n            dy: labelPosition.y,\n            'text-anchor': determineAnchorPosition(center, labelPosition, options.labelDirection)\n          }, options.classNames.label).text('' + interpolatedValue);\n\n          // Fire off draw event\n          this.eventEmitter.emit('draw', {\n            type: 'label',\n            index: index,\n            group: labelsGroup,\n            element: labelElement,\n            text: '' + interpolatedValue,\n            x: labelPosition.x,\n            y: labelPosition.y\n          });\n        }\n      }\n\n      // Set next startAngle to current endAngle.\n      // (except for last slice)\n      startAngle = endAngle;\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      chartRect: chartRect,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new pie chart and returns an object that can be used to redraw the chart.\n   *\n   * @memberof Chartist.Pie\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object in the pie chart needs to have a series property with a one dimensional data array. The values will be normalized against each other and don't necessarily need to be in percentage. The series property can also be an array of value objects that contain a value property and a className property to override the CSS class name for the series group.\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object with a version and an update method to manually redraw the chart\n   *\n   * @example\n   * // Simple pie chart example with four series\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [10, 2, 4, 3]\n   * });\n   *\n   * @example\n   * // Drawing a donut chart\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [10, 2, 4, 3]\n   * }, {\n   *   donut: true\n   * });\n   *\n   * @example\n   * // Using donut, startAngle and total to draw a gauge chart\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [20, 10, 30, 40]\n   * }, {\n   *   donut: true,\n   *   donutWidth: 20,\n   *   startAngle: 270,\n   *   total: 200\n   * });\n   *\n   * @example\n   * // Drawing a pie chart with padding and labels that are outside the pie\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [20, 10, 30, 40]\n   * }, {\n   *   chartPadding: 30,\n   *   labelOffset: 50,\n   *   labelDirection: 'explode'\n   * });\n   *\n   * @example\n   * // Overriding the class names for individual series as well as a name and meta data.\n   * // The name will be written as ct:series-name attribute and the meta data will be serialized and written\n   * // to a ct:meta attribute.\n   * new Chartist.Pie('.ct-chart', {\n   *   series: [{\n   *     value: 20,\n   *     name: 'Series 1',\n   *     className: 'my-custom-class-one',\n   *     meta: 'Meta One'\n   *   }, {\n   *     value: 10,\n   *     name: 'Series 2',\n   *     className: 'my-custom-class-two',\n   *     meta: 'Meta Two'\n   *   }, {\n   *     value: 70,\n   *     name: 'Series 3',\n   *     className: 'my-custom-class-three',\n   *     meta: 'Meta Three'\n   *   }]\n   * });\n   */\n  function Pie(query, data, options, responsiveOptions) {\n    Chartist.Pie.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating pie chart type in Chartist namespace\n  Chartist.Pie = Chartist.Base.extend({\n    constructor: Pie,\n    createChart: createChart,\n    determineAnchorPosition: determineAnchorPosition\n  });\n\n}(this || global, Chartist));\n\nreturn Chartist;\n\n}));\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = {\n  executeLayout(graph, exec, animate, post) {\n    if (graph.isEnabled()) {\n      graph.getModel().beginUpdate();\n      try {\n        exec();\n      } catch (e) {\n        throw e;\n      } finally {\n        graph.getModel().endUpdate();\n        if (post != null) {\n          post();\n        }\n      }\n    }\n  },\n  executeLayoutList(graph, layoutList, done) {\n    var cells = graph.getSelectionCells();\n\n    for (var i = 0; i < layoutList.length; i++) {\n      var layout = new window[layoutList[i].layout](graph);\n\n      if (layoutList[i].config != null) {\n        for (var key in layoutList[i].config) {\n          layout[key] = layoutList[i].config[key];\n        }\n      }\n\n      this.executeLayout(\n        graph,\n        function() {\n          layout.execute(graph.getDefaultParent(), cells.length === 0 ? null : cells);\n        },\n        i === layoutList.length - 1,\n        done\n      );\n    }\n  },\n  csvToArray(text) {\n    var re_valid = /^\\s*(?:'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|[^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*)\\s*(?:,\\s*(?:'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|[^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*)\\s*)*$/;\n    var re_value = /(?!\\s*$)\\s*(?:'([^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*)'|\"([^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*)\"|([^,'\"\\s\\\\]*(?:\\s+[^,'\"\\s\\\\]+)*))\\s*(?:,|$)/g;\n    // Return NULL if input string is not well formed CSV string.\n    if (!re_valid.test(text)) {\n      return null;\n    }\n    var a = []; // Initialize array to receive values.\n    text.replace(\n      re_value, // \"Walk\" the string using replace with callback.\n      function(m0, m1, m2, m3) {\n        // Remove backslash from \\' in single quoted values.\n        if (m1 !== undefined) {\n          a.push(m1.replace(/\\\\'/g, \"'\"));\n        }\n        // Remove backslash from \\\" in double quoted values.\n        else if (m2 !== undefined) {\n          a.push(m2.replace(/\\\\\"/g, '\"'));\n        } else if (m3 !== undefined) {\n          a.push(m3);\n        }\n        return ''; // Return empty string.\n      }\n    );\n    // Handle special case of empty last value.\n    if (/,\\s*$/.test(text)) {\n      a.push('');\n    }\n    return a;\n  },\n  importCsv(graph, text) {\n    try {\n      var lines = text.split('\\n');\n      var allCells = [];\n      var cells = [];\n      var dups = {};\n\n      if (lines.length > 0) {\n        // Internal lookup table\n        var lookups = {};\n\n        // Default values\n        var style = null;\n        var styles = null;\n        var stylename = null;\n        var labelname = null;\n        var labels = null;\n        var parentstyle = null;\n        var identity = null;\n        var parent = null;\n        var namespace = '';\n        var width = 'auto';\n        var height = 'auto';\n        var left = null;\n        var top = null;\n        var edgespacing = 40;\n        var nodespacing = 40;\n        var levelspacing = 100;\n        var padding = 0;\n        var view = graph.view;\n        var bds = graph.getGraphBounds();\n\n        // Delayed after optional layout\n        var afterInsert = function() {\n          // graph.setSelectionCells(select);\n          // graph.scrollCellToVisible(graph.getSelectionCell());\n        };\n\n        // Computes unscaled, untranslated graph bounds\n        var pt = graph.getFreeInsertPoint();\n        var x0 = pt.x;\n        var y0 = pt.y;\n        var y = y0;\n\n        // Default label value depends on column names\n        var label = null;\n\n        // Default layout to run.\n        var layout = 'auto';\n\n        // Name of the attribute that contains the parent reference\n        parent = null;\n\n        // Name of the attribute that contains the references for creating edges\n        var edges = [];\n\n        // Name of the column for hyperlinks\n        var link = null;\n\n        // String array of names to remove from metadata\n        var ignore = null;\n\n        // Read processing instructions first\n        var index = 0;\n\n        while (index < lines.length && lines[index].charAt(0) === '#') {\n          text = lines[index];\n          index++;\n\n          while (index < lines.length && text.charAt(text.length - 1) === '\\\\' && lines[index].charAt(0) === '#') {\n            text = text.substring(0, text.length - 1) + mxUtils.trim(lines[index].substring(1));\n            index++;\n          }\n\n          if (text.charAt(1) !== '#') {\n            // Processing instruction\n            var idx = text.indexOf(':');\n\n            if (idx > 0) {\n              var key = mxUtils.trim(text.substring(1, idx));\n              var value = mxUtils.trim(text.substring(idx + 1));\n\n              if (key === 'label') {\n                label = graph.sanitizeHtml(value);\n              } else if (key === 'labelname' && value.length > 0 && value !== '-') {\n                labelname = value;\n              } else if (key === 'labels' && value.length > 0 && value !== '-') {\n                labels = JSON.parse(value);\n              } else if (key === 'style') {\n                style = value;\n              } else if (key === 'parentstyle') {\n                parentstyle = value;\n              } else if (key === 'stylename' && value.length > 0 && value !== '-') {\n                stylename = value;\n              } else if (key === 'styles' && value.length > 0 && value !== '-') {\n                styles = JSON.parse(value);\n              } else if (key === 'identity' && value.length > 0 && value !== '-') {\n                identity = value;\n              } else if (key === 'parent' && value.length > 0 && value !== '-') {\n                parent = value;\n              } else if (key === 'namespace' && value.length > 0 && value !== '-') {\n                namespace = value;\n              } else if (key === 'width') {\n                width = value;\n              } else if (key === 'height') {\n                height = value;\n              } else if (key === 'left' && value.length > 0) {\n                left = value;\n              } else if (key === 'top' && value.length > 0) {\n                top = value;\n              } else if (key === 'ignore') {\n                ignore = value.split(',');\n              } else if (key === 'connect') {\n                edges.push(JSON.parse(value));\n              } else if (key === 'link') {\n                link = value;\n              } else if (key === 'padding') {\n                padding = parseFloat(value);\n              } else if (key === 'edgespacing') {\n                edgespacing = parseFloat(value);\n              } else if (key === 'nodespacing') {\n                nodespacing = parseFloat(value);\n              } else if (key === 'levelspacing') {\n                levelspacing = parseFloat(value);\n              } else if (key === 'layout') {\n                layout = value;\n              }\n            }\n          }\n        }\n\n        if (lines[index] == null) {\n          throw new Error(mxResources.get('invalidOrMissingFile'));\n        }\n\n        // Converts identity and parent to index and validates XML attribute names\n        var keys = this.csvToArray(lines[index]);\n        var identityIndex = null;\n        var parentIndex = null;\n        var attribs = [];\n\n        for (var i = 0; i < keys.length; i++) {\n          if (identity === keys[i]) {\n            identityIndex = i;\n          }\n\n          if (parent === keys[i]) {\n            parentIndex = i;\n          }\n\n          attribs.push(\n            mxUtils\n              .trim(keys[i])\n              .replace(/[^a-z0-9]+/gi, '_')\n              .replace(/^\\d+/, '')\n              .replace(/_+$/, '')\n          );\n        }\n\n        if (label == null) {\n          label = '%' + attribs[0] + '%';\n        }\n\n        if (edges != null) {\n          for (var e = 0; e < edges.length; e++) {\n            if (lookups[edges[e].to] == null) {\n              lookups[edges[e].to] = {};\n            }\n          }\n        }\n\n        // Parse and validate input\n        var arrays = [];\n\n        for (let i = index + 1; i < lines.length; i++) {\n          let values = this.csvToArray(lines[i]);\n\n          if (values == null) {\n            var short = lines[i].length > 40 ? lines[i].substring(0, 40) + '...' : lines[i];\n\n            throw new Error(short + ' (' + i + '):\\n' + mxResources.get('containsValidationErrors'));\n          } else if (values.length > 0) {\n            arrays.push(values);\n          }\n        }\n\n        graph.model.beginUpdate();\n        try {\n          for (let i = 0; i < arrays.length; i++) {\n            let values = arrays[i];\n            var cell = null;\n            var id = identityIndex != null ? namespace + values[identityIndex] : null;\n\n            if (id != null) {\n              cell = graph.model.getCell(id);\n            }\n\n            var exists = cell != null;\n            var newCell = new mxCell(label, new mxGeometry(x0, y, 0, 0), style || 'whiteSpace=wrap;html=1;');\n            newCell.vertex = true;\n            newCell.id = id;\n\n            for (var j = 0; j < values.length; j++) {\n              graph.setAttributeForCell(newCell, attribs[j], values[j]);\n            }\n\n            if (labelname != null && labels != null) {\n              var tempLabel = labels[newCell.getAttribute(labelname)];\n\n              if (tempLabel != null) {\n                graph.labelChanged(newCell, tempLabel);\n              }\n            }\n\n            if (stylename != null && styles != null) {\n              var tempStyle = styles[newCell.getAttribute(stylename)];\n\n              if (tempStyle != null) {\n                newCell.style = tempStyle;\n              }\n            }\n\n            graph.setAttributeForCell(newCell, 'placeholders', '1');\n            newCell.style = graph.replacePlaceholders(newCell, newCell.style);\n\n            if (exists) {\n              graph.model.setGeometry(cell, newCell.geometry);\n              graph.model.setStyle(cell, newCell.style);\n\n              if (mxUtils.indexOf(cells, cell) < 0) {\n                cells.push(cell);\n              }\n            }\n\n            cell = newCell;\n\n            if (!exists) {\n              for (let e = 0; e < edges.length; e++) {\n                lookups[edges[e].to][cell.getAttribute(edges[e].to)] = cell;\n              }\n            }\n\n            if (link != null && link !== 'link') {\n              graph.setLinkForCell(cell, cell.getAttribute(link));\n\n              // Removes attribute\n              graph.setAttributeForCell(cell, link, null);\n            }\n\n            // Sets the size\n            graph.fireEvent(new mxEventObject('cellsInserted', 'cells', [cell]));\n            var size = graph.getPreferredSizeForCell(cell);\n\n            if (cell.vertex) {\n              if (left != null && cell.getAttribute(left) != null) {\n                cell.geometry.x = x0 + parseFloat(cell.getAttribute(left));\n              }\n\n              if (top != null && cell.getAttribute(top) != null) {\n                cell.geometry.y = y0 + parseFloat(cell.getAttribute(top));\n              }\n\n              if (width.charAt(0) === '@' && cell.getAttribute(width.substring(1)) != null) {\n                cell.geometry.width = parseFloat(cell.getAttribute(width.substring(1)));\n              } else {\n                cell.geometry.width = width === 'auto' ? size.width + padding : parseFloat(width);\n              }\n\n              if (height.charAt(0) === '@' && cell.getAttribute(height.substring(1)) != null) {\n                cell.geometry.height = parseFloat(cell.getAttribute(height.substring(1)));\n              } else {\n                cell.geometry.height = height === 'auto' ? size.height + padding : parseFloat(height);\n              }\n\n              y += cell.geometry.height + nodespacing;\n            }\n\n            if (!exists) {\n              parent = parentIndex != null ? graph.model.getCell(namespace + values[parentIndex]) : null;\n              allCells.push(cell);\n\n              if (parent != null) {\n                parent.style = graph.replacePlaceholders(parent, parentstyle);\n                graph.addCell(cell, parent);\n              } else {\n                cells.push(graph.addCell(cell));\n              }\n            } else {\n              if (dups[id] == null) {\n                dups[id] = [];\n              }\n\n              dups[id].push(cell);\n            }\n          }\n\n          var roots = cells.slice();\n          var select = cells.slice();\n\n          for (let e = 0; e < edges.length; e++) {\n            var edge = edges[e];\n\n            for (let i = 0; i < allCells.length; i++) {\n              cell = allCells[i];\n\n              var insertEdge = mxUtils.bind(this, function(realCell, dataCell, edge) {\n                var tmp = dataCell.getAttribute(edge.from);\n\n                if (tmp != null) {\n                  // Removes attribute\n                  graph.setAttributeForCell(dataCell, edge.from, null);\n\n                  if (tmp !== '') {\n                    var refs = tmp.split(',');\n\n                    for (var j = 0; j < refs.length; j++) {\n                      var ref = lookups[edge.to][refs[j]];\n\n                      if (ref != null) {\n                        var label = edge.label;\n\n                        if (edge.fromlabel != null) {\n                          label = (dataCell.getAttribute(edge.fromlabel) || '') + (label || '');\n                        }\n\n                        if (edge.tolabel != null) {\n                          label = (label || '') + (ref.getAttribute(edge.tolabel) || '');\n                        }\n\n                        var placeholders = (edge.placeholders === 'target') === !edge.invert ? ref : realCell;\n                        var style =\n                          edge.style != null\n                            ? graph.replacePlaceholders(placeholders, edge.style)\n                            : graph.createCurrentEdgeStyle();\n\n                        select.push(\n                          graph.insertEdge(\n                            null,\n                            null,\n                            label || '',\n                            edge.invert ? ref : realCell,\n                            edge.invert ? realCell : ref,\n                            style\n                          )\n                        );\n                        mxUtils.remove(edge.invert ? realCell : ref, roots);\n                      }\n                    }\n                  }\n                }\n              });\n\n              insertEdge(cell, cell, edge);\n\n              // Checks more entries\n              if (dups[cell.id] != null) {\n                for (let j = 0; j < dups[cell.id].length; j++) {\n                  insertEdge(cell, dups[cell.id][j], edge);\n                }\n              }\n            }\n          }\n          // Removes ignored attributes after processing above\n          if (ignore != null) {\n            for (let i = 0; i < allCells.length; i++) {\n              cell = allCells[i];\n\n              for (let j = 0; j < ignore.length; j++) {\n                graph.setAttributeForCell(cell, mxUtils.trim(ignore[j]), null);\n              }\n            }\n          }\n\n          if (cells.length > 0) {\n            var edgeLayout = new mxParallelEdgeLayout(graph);\n            edgeLayout.spacing = edgespacing;\n\n            var postProcess = function() {\n              if (edgeLayout.spacing > 0) {\n                edgeLayout.execute(graph.getDefaultParent());\n              }\n\n              // Aligns cells to grid and/or rounds positions\n              for (var i = 0; i < cells.length; i++) {\n                var geo = graph.getCellGeometry(cells[i]);\n                geo.x = Math.round(graph.snap(geo.x));\n                geo.y = Math.round(graph.snap(geo.y));\n\n                if (width === 'auto') {\n                  geo.width = Math.round(graph.snap(geo.width));\n                }\n\n                if (height === 'auto') {\n                  geo.height = Math.round(graph.snap(geo.height));\n                }\n              }\n            };\n            if (layout.charAt(0) === '[') {\n              // Required for layouts to work with new cells\n              var temp = afterInsert;\n              graph.view.validate();\n              this.executeLayoutList(graph, JSON.parse(layout), function() {\n                postProcess();\n                temp();\n              });\n              afterInsert = null;\n            } else if (layout === 'circle') {\n              var circleLayout = new mxCircleLayout(graph);\n              circleLayout.resetEdges = false;\n\n              var circleLayoutIsVertexIgnored = circleLayout.isVertexIgnored;\n\n              // Ignore other cells\n              circleLayout.isVertexIgnored = function(vertex) {\n                return circleLayoutIsVertexIgnored.apply(this, arguments) || mxUtils.indexOf(cells, vertex) < 0;\n              };\n\n              this.executeLayout(\n                graph,\n                function() {\n                  circleLayout.execute(graph.getDefaultParent());\n                  postProcess();\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            } else if (\n              layout === 'horizontaltree' ||\n              layout === 'verticaltree' ||\n              (layout === 'auto' && select.length === 2 * cells.length - 1 && roots.length === 1)\n            ) {\n              // Required for layouts to work with new cells\n              graph.view.validate();\n\n              var treeLayout = new mxCompactTreeLayout(graph, layout === 'horizontaltree');\n              treeLayout.levelDistance = nodespacing;\n              treeLayout.edgeRouting = false;\n              treeLayout.resetEdges = false;\n\n              this.executeLayout(\n                graph,\n                function() {\n                  treeLayout.execute(graph.getDefaultParent(), roots.length > 0 ? roots[0] : null);\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            } else if (\n              layout === 'horizontalflow' ||\n              layout === 'verticalflow' ||\n              (layout === 'auto' && roots.length === 1)\n            ) {\n              // Required for layouts to work with new cells\n              graph.view.validate();\n\n              var flowLayout = new mxHierarchicalLayout(\n                graph,\n                layout === 'horizontalflow' ? mxConstants.DIRECTION_WEST : mxConstants.DIRECTION_NORTH\n              );\n              flowLayout.intraCellSpacing = nodespacing;\n              flowLayout.parallelEdgeSpacing = edgespacing;\n              flowLayout.interRankCellSpacing = levelspacing;\n              flowLayout.disableEdgeStyle = false;\n\n              this.executeLayout(\n                graph,\n                function() {\n                  flowLayout.execute(graph.getDefaultParent(), select);\n\n                  // Workaround for flow layout moving cells to origin\n                  graph.moveCells(select, x0, y0);\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            } else if (layout === 'organic' || (layout === 'auto' && select.length > cells.length)) {\n              // Required for layouts to work with new cells\n              graph.view.validate();\n\n              var organicLayout = new mxFastOrganicLayout(graph);\n              organicLayout.forceConstant = nodespacing * 3;\n              organicLayout.resetEdges = false;\n\n              var organicLayoutIsVertexIgnored = organicLayout.isVertexIgnored;\n\n              // Ignore other cells\n              organicLayout.isVertexIgnored = function(vertex) {\n                return organicLayoutIsVertexIgnored.apply(this, arguments) || mxUtils.indexOf(cells, vertex) < 0;\n              };\n\n              edgeLayout = new mxParallelEdgeLayout(graph);\n              edgeLayout.spacing = edgespacing;\n\n              this.executeLayout(\n                graph,\n                function() {\n                  organicLayout.execute(graph.getDefaultParent());\n                  postProcess();\n                },\n                true,\n                afterInsert\n              );\n\n              afterInsert = null;\n            }\n          }\n        } finally {\n          graph.model.endUpdate();\n        }\n        if (afterInsert != null) {\n          afterInsert();\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  },\n  anonymize(graph) {\n    const div = document.createElement('div');\n    const model = graph.model;\n    const ignoredAnonymizedChars = '\\n\\t`~!@#$%^&*()_+{}|:\"<>?-=[];\\'./,\\n\\t';\n    const anonymizeString = (text, zeros) => {\n      var result = [];\n\n      for (let i = 0; i < text.length; i++) {\n        const c = text.charAt(i);\n        if (ignoredAnonymizedChars.indexOf(c) >= 0) {\n          result.push(c);\n        } else if (!isNaN(parseInt(c))) {\n          result.push(zeros ? '0' : Math.round(Math.random() * 9));\n        } else if (c.toLowerCase() !== c) {\n          result.push(String.fromCharCode(65 + Math.round(Math.random() * 25)));\n        } else if (c.toUpperCase() !== c) {\n          result.push(String.fromCharCode(97 + Math.round(Math.random() * 25)));\n        } else if (/\\s/.test(c)) {\n          result.push(' ');\n        } else {\n          result.push('?');\n        }\n      }\n      return result.join('');\n    };\n    const replaceTextContent = elt => {\n      if (elt.nodeValue != null) {\n        elt.nodeValue = anonymizeString(elt.nodeValue);\n      }\n\n      if (elt.nodeType === mxConstants.NODETYPE_ELEMENT) {\n        let tmp = elt.firstChild;\n\n        while (tmp != null) {\n          replaceTextContent(tmp);\n          tmp = tmp.nextSibling;\n        }\n      }\n    };\n    const anonymizeHtml = html => {\n      div.innerHTML = html;\n\n      replaceTextContent(div);\n\n      return div.innerHTML;\n    };\n\n    model.beginUpdate();\n    try {\n      // Queue used to fix ancestor placeholders\n      const queue = [];\n\n      for (var id in model.cells) {\n        var cell = model.cells[id];\n        var label = graph.getLabel(cell);\n\n        if (graph.isHtmlLabel(cell)) {\n          label = anonymizeHtml(label);\n        } else {\n          label = anonymizeString(label);\n        }\n\n        queue.push({ cell: cell, label: label });\n      }\n\n      for (var i = 0; i < queue.length; i++) {\n        model.setValue(queue[i].cell, queue[i].label);\n      }\n    } finally {\n      model.endUpdate();\n    }\n  },\n  addExtFont(fontName, fontUrl, dontRemember) {\n    // KNOWN: Font not added when pasting cells with custom fonts\n    if (fontName && fontUrl) {\n      var fontId = 'extFont_' + fontName;\n\n      if (document.getElementById(fontId) === null) {\n        if (fontUrl.indexOf(Editor.GOOGLE_FONTS) === 0) {\n          mxClient.link('stylesheet', fontUrl, null, fontId);\n        } else {\n          var head = document.getElementsByTagName('head')[0];\n\n          // KNOWN: Should load fonts synchronously\n          var style = document.createElement('style');\n\n          style.appendChild(\n            document.createTextNode(\n              '@font-face {\\n' + '\\tfont-family: \"' + fontName + '\";\\n' + '\\tsrc: url(\"' + fontUrl + '\");\\n' + '}'\n            )\n          );\n\n          style.setAttribute('id', fontId);\n          head = document.getElementsByTagName('head')[0];\n          head.appendChild(style);\n        }\n      }\n\n      if (!dontRemember) {\n        if (this.extFonts == null) {\n          this.extFonts = [];\n        }\n\n        var extFonts = this.extFonts,\n          notFound = true;\n\n        for (var i = 0; i < extFonts.length; i++) {\n          if (extFonts[i].name === fontName) {\n            notFound = false;\n            break;\n          }\n        }\n\n        if (notFound) {\n          this.extFonts.push({ name: fontName, url: fontUrl });\n        }\n      }\n    }\n  },\n};\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__16__;","module.exports = __WEBPACK_EXTERNAL_MODULE__17__;","const pako = require('pako');\nconst vkbeautify = require('vkbeautify');\nconst safeEval = require('safe-eval');\n\n// sources :\n// https://jgraph.github.io/drawio-tools/tools/convert.html\n\nmodule.exports = {\n  stringToBytes(str) {\n    const arr = new Array(str.length);\n\n    for (let i = 0; i < str.length; i += 1) {\n      arr[i] = str.charCodeAt(i);\n    }\n\n    return arr;\n  },\n  bytesToString(arr) {\n    let str = '';\n\n    for (let i = 0; i < arr.length; i += 1) {\n      str += String.fromCharCode(arr[i]);\n    }\n    return str;\n  },\n  encode(data, encode, deflate, base64) {\n    let result = data;\n    if (encode) {\n      try {\n        result = encodeURIComponent(result);\n      } catch (e) {\n        console.error(e);\n        return;\n      }\n    }\n\n    if (deflate && result.length > 0) {\n      try {\n        result = this.bytesToString(pako.deflateRaw(result));\n      } catch (e) {\n        console.error(e);\n        return;\n      }\n    }\n\n    if (base64) {\n      try {\n        result = btoa(result);\n      } catch (e) {\n        console.error(e);\n        return;\n      }\n    }\n    return result;\n  },\n\n  removeLinebreaks(data) {\n    return data.replace(/(\\r\\n|\\n|\\r)/gm, '');\n  },\n\n  isencoded(data) {\n    try {\n      const node = this.parseXml(data).documentElement;\n      if (node != null && node.nodeName === 'mxfile') {\n        const diagrams = node.getElementsByTagName('diagram');\n        if (diagrams.length > 0) {\n          return true;\n        }\n      } else {\n        return data.indexOf('mxGraphModel') === -1;\n      }\n    } catch (error) {\n      return true;\n    }\n    return false;\n  },\n\n  decode(data, encode, deflate, base64) {\n    try {\n      const node = this.parseXml(data).documentElement;\n\n      if (node != null && node.nodeName === 'mxfile') {\n        const diagrams = node.getElementsByTagName('diagram');\n\n        if (diagrams.length > 0) {\n          data = this.getTextContent(diagrams[0]);\n        }\n      }\n    } catch (e) {\n      // ignore\n    }\n\n    if (base64) {\n      data = atob(data);\n    }\n\n    if (deflate && data.length > 0) {\n      data = this.bytesToString(pako.inflateRaw(data));\n    }\n\n    if (encode) {\n      data = decodeURIComponent(data);\n    }\n\n    return data;\n  },\n\n  parseXml(xml) {\n    if (window.DOMParser) {\n      const parser = new DOMParser();\n\n      return parser.parseFromString(xml, 'text/xml');\n    }\n    const result = this.createXmlDocument();\n    result.async = 'false';\n    result.loadXML(xml);\n    return result;\n  },\n\n  createXmlDocument() {\n    let doc = null;\n\n    if (document.implementation && document.implementation.createDocument) {\n      doc = document.implementation.createDocument('', '', null);\n    } else if (window.ActiveXObject) {\n      doc = new ActiveXObject('Microsoft.XMLDOM');\n    }\n\n    return doc;\n  },\n\n  decodeFromUri(data) {\n    try {\n      data = decodeURIComponent(data);\n    } catch (e) {\n      console.error(e);\n      return;\n    }\n    return data;\n  },\n\n  getTextContent(node) {\n    return node != null ? node[node.textContent === undefined ? 'text' : 'textContent'] : '';\n  },\n\n  normalizeXml(data) {\n    try {\n      let str = data;\n      str = str.replace(/>\\s*/g, '>'); // Replace \"> \" with \">\"\n      str = str.replace(/\\s*</g, '<'); // Replace \"< \" with \"<\"\n      return data;\n    } catch (e) {\n      return;\n    }\n  },\n\n  async sleep(ms, mess) {\n    function delay(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    await delay(ms);\n    if (mess) {\n      console.log(mess);\n    }\n  },\n\n  uniqueID() {\n    function chr4() {\n      return Math.random()\n        .toString(16)\n        .slice(-4);\n    }\n    return `${chr4() + chr4()}-${chr4()}-${chr4()}-${chr4()}-${chr4()}${chr4()}${chr4()}`;\n  },\n\n  stringToJsRegex(str) {\n    if (str[0] !== '/') {\n      return new RegExp(`^${str}$`);\n    }\n    const match = str.match(new RegExp('^/(.*?)/(g?i?m?y?)$'));\n    return new RegExp(match[1], match[2]);\n  },\n\n  matchString(str, pattern, regex = true) {\n    if (str === null || str === undefined || pattern === null || pattern === undefined || str.length === 0 || pattern.length === 0) {\n      return false;\n    }\n    if (str === pattern) {\n      return true;\n    }\n    if (regex) {\n      const regex = this.stringToJsRegex(pattern);\n      return str.toString().match(regex);\n    }\n    return false;\n  },\n\n  minify(text) {\n    try {\n      return vkbeautify.xmlmin(text, false);\n    } catch (error) {\n      this.log(3, 'Error in minify', error);\n      return text;\n    }\n  },\n\n  prettify(text) {\n    try {\n      return vkbeautify.xml(text);\n    } catch (error) {\n      this.log(3, 'Error in prettify', error);\n      return text;\n    }\n  },\n  prettifyJSON(text) {\n    try {\n      return vkbeautify.json(text);\n    } catch (error) {\n      this.log(3, 'Error in prettify', error);\n      return text;\n    }\n  },\n\n  addScript(src) {\n    var s = document.createElement('script');\n    s.setAttribute('type', 'text/javascript');\n    s.setAttribute('src', src);\n    var r = false;\n    var t = document.getElementsByTagName('script')[0];\n\n    if (t != null) {\n      t.parentNode.insertBefore(s, t);\n    }\n  },\n\n  loadJS(fname) {\n    try {\n      var code = this.loadFile(fname)\n      if (code) {\n        this.evalRaw(code);\n        // console.info('LoadJS called succesfully', fname);\n      }\n    } catch (e) {\n      if (window.console != null) {\n        console.error('LoadJS failed:', fname, e);\n      }\n    }\n  },\n\n  loadFile(fname) {\n    try {\n      var req = mxUtils.load(fname);\n      if (req != null && req.getStatus() >= 200 && req.getStatus() <= 299) {\n        // console.info('loadFile called succesfully', fname);\n        return req.getText();\n      }\n    } catch (e) {\n      if (window.console != null) {\n        console.error('Error loadFile:', fname, e);\n      }\n    }\n  },\n\n  $loadFile(fname) {\n    let result;\n    $.ajax({\n      type: 'GET',\n      url: fname,\n      async: false,\n      success: data => {\n        result = data;\n      },\n      error: error => {\n        console.log('Error when download ' + fname), error;\n      },\n    });\n    return result;\n  },\n\n  $evalFile(fname) {\n    let result;\n    $.ajax({\n      type: 'GET',\n      url: fname,\n      async: false,\n      success: data => {\n        eval.call(window, data);\n      },\n      error: error => {\n        console.log('Error when download/eval ' + fname), error;\n      },\n    });\n  },\n\n  evalRaw(code) {\n    try {\n      eval.call(window, code);\n      // console.info('eval.call succesfully');\n    } catch (e) {\n      if (window.console != null) {\n        console.error('Error eval.call : ', e);\n      }\n    }\n  },\n\n  evalIt(code) {\n    let result = code;\n    try {\n      result = safeEval(code);\n    } catch (error) {\n      result = code;\n    }\n    return result;\n  },\n\n  getfileContent(url) {\n    let result;\n    const request = async () => {\n      const response = await fetch(url);\n      const result = await response.text();\n      console.log(getfileContent, url, result);\n    };\n    request();\n    return result;\n  },\n};\n","// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","/**\r\n* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.\r\n*\r\n* Copyright (c) 2012 Vadim Kiryukhin\r\n* vkiryukhin @ gmail.com\r\n* http://www.eslinstructor.net/vkbeautify/\r\n*\r\n* Dual licensed under the MIT and GPL licenses:\r\n*   http://www.opensource.org/licenses/mit-license.php\r\n*   http://www.gnu.org/licenses/gpl.html\r\n*\r\n*   Pretty print\r\n*\r\n*        vkbeautify.xml(text [,indent_pattern]);\r\n*        vkbeautify.json(text [,indent_pattern]);\r\n*        vkbeautify.css(text [,indent_pattern]);\r\n*        vkbeautify.sql(text [,indent_pattern]);\r\n*\r\n*        @text - String; text to beatufy;\r\n*        @indent_pattern - Integer | String;\r\n*                Integer:  number of white spaces;\r\n*                String:   character string to visualize indentation ( can also be a set of white spaces )\r\n*   Minify\r\n*\r\n*        vkbeautify.xmlmin(text [,preserve_comments]);\r\n*        vkbeautify.jsonmin(text);\r\n*        vkbeautify.cssmin(text [,preserve_comments]);\r\n*        vkbeautify.sqlmin(text);\r\n*\r\n*        @text - String; text to minify;\r\n*        @preserve_comments - Bool; [optional];\r\n*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )\r\n*\r\n*   Examples:\r\n*        vkbeautify.xml(text); // pretty print XML\r\n*        vkbeautify.json(text, 4 ); // pretty print JSON\r\n*        vkbeautify.css(text, '. . . .'); // pretty print CSS\r\n*        vkbeautify.sql(text, '----'); // pretty print SQL\r\n*\r\n*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments\r\n*        vkbeautify.jsonmin(text);// minify JSON\r\n*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )\r\n*        vkbeautify.sqlmin(text);// minify SQL\r\n*\r\n*/\r\nfunction createShiftArr(step) {\r\n\r\n\tvar space = '    ';\r\n\r\n\tif ( isNaN(parseInt(step)) ) {  // argument is string\r\n\t\tspace = step;\r\n\t} else { // argument is integer\r\n\t\tswitch(step) {\r\n\t\t\tcase 1: space = ' '; break;\r\n\t\t\tcase 2: space = '  '; break;\r\n\t\t\tcase 3: space = '   '; break;\r\n\t\t\tcase 4: space = '    '; break;\r\n\t\t\tcase 5: space = '     '; break;\r\n\t\t\tcase 6: space = '      '; break;\r\n\t\t\tcase 7: space = '       '; break;\r\n\t\t\tcase 8: space = '        '; break;\r\n\t\t\tcase 9: space = '         '; break;\r\n\t\t\tcase 10: space = '          '; break;\r\n\t\t\tcase 11: space = '           '; break;\r\n\t\t\tcase 12: space = '            '; break;\r\n\t\t}\r\n\t}\r\n\r\n\tvar shift = ['\\n']; // array of shifts\r\n\tfor(var ix=0;ix<100;ix++) {\r\n\t\tshift.push(shift[ix]+space);\r\n\t}\r\n\treturn shift;\r\n}\r\n\r\nfunction vkbeautify(){\r\n\tthis.step = '    '; // 4 spaces\r\n\tthis.shift = createShiftArr(this.step);\r\n};\r\n\r\nvkbeautify.prototype.xml = function(text,step) {\r\n\r\n\tvar ar = text.replace(/>\\s{0,}</g,\"><\")\r\n\t\t\t\t .replace(/</g,\"~::~<\")\r\n\t\t\t\t .replace(/\\s*xmlns\\:/g,\"~::~xmlns:\")\r\n\t\t\t\t .replace(/\\s*xmlns\\=/g,\"~::~xmlns=\")\r\n\t\t\t\t .split('~::~'),\r\n\t\tlen = ar.length,\r\n\t\tinComment = false,\r\n\t\tdeep = 0,\r\n\t\tstr = '',\r\n\t\tix = 0,\r\n\t\tshift = step ? createShiftArr(step) : this.shift;\r\n\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\t\t\t// start comment or <![CDATA[...]]> or <!DOCTYPE //\r\n\t\t\tif(ar[ix].search(/<!/) > -1) {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t\tinComment = true;\r\n\t\t\t\t// end comment  or <![CDATA[...]]> //\r\n\t\t\t\tif(ar[ix].search(/-->/) > -1 || ar[ix].search(/\\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {\r\n\t\t\t\t\tinComment = false;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t// end comment  or <![CDATA[...]]> //\r\n\t\t\tif(ar[ix].search(/-->/) > -1 || ar[ix].search(/\\]>/) > -1) {\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t\tinComment = false;\r\n\t\t\t} else\r\n\t\t\t// <elm></elm> //\r\n\t\t\tif( /^<\\w/.exec(ar[ix-1]) && /^<\\/\\w/.exec(ar[ix]) &&\r\n\t\t\t\t/^<[\\w:\\-\\.\\,]+/.exec(ar[ix-1]) == /^<\\/[\\w:\\-\\.\\,]+/.exec(ar[ix])[0].replace('/','')) {\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t\tif(!inComment) deep--;\r\n\t\t\t} else\r\n\t\t\t // <elm> //\r\n\t\t\tif(ar[ix].search(/<\\w/) > -1 && ar[ix].search(/<\\//) == -1 && ar[ix].search(/\\/>/) == -1 ) {\r\n\t\t\t\tstr = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t // <elm>...</elm> //\r\n\t\t\tif(ar[ix].search(/<\\w/) > -1 && ar[ix].search(/<\\//) > -1) {\r\n\t\t\t\tstr = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t// </elm> //\r\n\t\t\tif(ar[ix].search(/<\\//) > -1) {\r\n\t\t\t\tstr = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t// <elm/> //\r\n\t\t\tif(ar[ix].search(/\\/>/) > -1 ) {\r\n\t\t\t\tstr = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];\r\n\t\t\t} else\r\n\t\t\t// <? xml ... ?> //\r\n\t\t\tif(ar[ix].search(/<\\?/) > -1) {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t} else\r\n\t\t\t// xmlns //\r\n\t\t\tif( ar[ix].search(/xmlns\\:/) > -1  || ar[ix].search(/xmlns\\=/) > -1) {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\treturn  (str[0] == '\\n') ? str.slice(1) : str;\r\n}\r\n\r\nvkbeautify.prototype.json = function(text,step) {\r\n\r\n\tvar step = step ? step : this.step;\r\n\r\n\tif (typeof JSON === 'undefined' ) return text;\r\n\r\n\tif ( typeof text === \"string\" ) return JSON.stringify(JSON.parse(text), null, step);\r\n\tif ( typeof text === \"object\" ) return JSON.stringify(text, null, step);\r\n\r\n\treturn text; // text is not string nor object\r\n}\r\n\r\nvkbeautify.prototype.css = function(text, step) {\r\n\r\n\tvar ar = text.replace(/\\s{1,}/g,' ')\r\n\t\t\t\t.replace(/\\{/g,\"{~::~\")\r\n\t\t\t\t.replace(/\\}/g,\"~::~}~::~\")\r\n\t\t\t\t.replace(/\\;/g,\";~::~\")\r\n\t\t\t\t.replace(/\\/\\*/g,\"~::~/*\")\r\n\t\t\t\t.replace(/\\*\\//g,\"*/~::~\")\r\n\t\t\t\t.replace(/~::~\\s{0,}~::~/g,\"~::~\")\r\n\t\t\t\t.split('~::~'),\r\n\t\tlen = ar.length,\r\n\t\tdeep = 0,\r\n\t\tstr = '',\r\n\t\tix = 0,\r\n\t\tshift = step ? createShiftArr(step) : this.shift;\r\n\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\r\n\t\t\tif( /\\{/.exec(ar[ix]))  {\r\n\t\t\t\tstr += shift[deep++]+ar[ix];\r\n\t\t\t} else\r\n\t\t\tif( /\\}/.exec(ar[ix]))  {\r\n\t\t\t\tstr += shift[--deep]+ar[ix];\r\n\t\t\t} else\r\n\t\t\tif( /\\*\\\\/.exec(ar[ix]))  {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str.replace(/^\\n{1,}/,'');\r\n}\r\n\r\n//----------------------------------------------------------------------------\r\n\r\nfunction isSubquery(str, parenthesisLevel) {\r\n\treturn  parenthesisLevel - (str.replace(/\\(/g,'').length - str.replace(/\\)/g,'').length )\r\n}\r\n\r\nfunction split_sql(str, tab) {\r\n\r\n\treturn str.replace(/\\s{1,}/g,\" \")\r\n\r\n\t\t\t\t.replace(/ AND /ig,\"~::~\"+tab+tab+\"AND \")\r\n\t\t\t\t.replace(/ BETWEEN /ig,\"~::~\"+tab+\"BETWEEN \")\r\n\t\t\t\t.replace(/ CASE /ig,\"~::~\"+tab+\"CASE \")\r\n\t\t\t\t.replace(/ ELSE /ig,\"~::~\"+tab+\"ELSE \")\r\n\t\t\t\t.replace(/ END /ig,\"~::~\"+tab+\"END \")\r\n\t\t\t\t.replace(/ FROM /ig,\"~::~FROM \")\r\n\t\t\t\t.replace(/ GROUP\\s{1,}BY/ig,\"~::~GROUP BY \")\r\n\t\t\t\t.replace(/ HAVING /ig,\"~::~HAVING \")\r\n\t\t\t\t//.replace(/ SET /ig,\" SET~::~\")\r\n\t\t\t\t.replace(/ IN /ig,\" IN \")\r\n\r\n\t\t\t\t.replace(/ JOIN /ig,\"~::~JOIN \")\r\n\t\t\t\t.replace(/ CROSS~::~{1,}JOIN /ig,\"~::~CROSS JOIN \")\r\n\t\t\t\t.replace(/ INNER~::~{1,}JOIN /ig,\"~::~INNER JOIN \")\r\n\t\t\t\t.replace(/ LEFT~::~{1,}JOIN /ig,\"~::~LEFT JOIN \")\r\n\t\t\t\t.replace(/ RIGHT~::~{1,}JOIN /ig,\"~::~RIGHT JOIN \")\r\n\r\n\t\t\t\t.replace(/ ON /ig,\"~::~\"+tab+\"ON \")\r\n\t\t\t\t.replace(/ OR /ig,\"~::~\"+tab+tab+\"OR \")\r\n\t\t\t\t.replace(/ ORDER\\s{1,}BY/ig,\"~::~ORDER BY \")\r\n\t\t\t\t.replace(/ OVER /ig,\"~::~\"+tab+\"OVER \")\r\n\r\n\t\t\t\t.replace(/\\(\\s{0,}SELECT /ig,\"~::~(SELECT \")\r\n\t\t\t\t.replace(/\\)\\s{0,}SELECT /ig,\")~::~SELECT \")\r\n\r\n\t\t\t\t.replace(/ THEN /ig,\" THEN~::~\"+tab+\"\")\r\n\t\t\t\t.replace(/ UNION /ig,\"~::~UNION~::~\")\r\n\t\t\t\t.replace(/ USING /ig,\"~::~USING \")\r\n\t\t\t\t.replace(/ WHEN /ig,\"~::~\"+tab+\"WHEN \")\r\n\t\t\t\t.replace(/ WHERE /ig,\"~::~WHERE \")\r\n\t\t\t\t.replace(/ WITH /ig,\"~::~WITH \")\r\n\r\n\t\t\t\t//.replace(/\\,\\s{0,}\\(/ig,\",~::~( \")\r\n\t\t\t\t//.replace(/\\,/ig,\",~::~\"+tab+tab+\"\")\r\n\r\n\t\t\t\t.replace(/ ALL /ig,\" ALL \")\r\n\t\t\t\t.replace(/ AS /ig,\" AS \")\r\n\t\t\t\t.replace(/ ASC /ig,\" ASC \")\r\n\t\t\t\t.replace(/ DESC /ig,\" DESC \")\r\n\t\t\t\t.replace(/ DISTINCT /ig,\" DISTINCT \")\r\n\t\t\t\t.replace(/ EXISTS /ig,\" EXISTS \")\r\n\t\t\t\t.replace(/ NOT /ig,\" NOT \")\r\n\t\t\t\t.replace(/ NULL /ig,\" NULL \")\r\n\t\t\t\t.replace(/ LIKE /ig,\" LIKE \")\r\n\t\t\t\t.replace(/\\s{0,}SELECT /ig,\"SELECT \")\r\n\t\t\t\t.replace(/\\s{0,}UPDATE /ig,\"UPDATE \")\r\n\t\t\t\t.replace(/ SET /ig,\" SET \")\r\n\r\n\t\t\t\t.replace(/~::~{1,}/g,\"~::~\")\r\n\t\t\t\t.split('~::~');\r\n}\r\n\r\nvkbeautify.prototype.sql = function(text,step) {\r\n\r\n\tvar ar_by_quote = text.replace(/\\s{1,}/g,\" \")\r\n\t\t\t\t\t\t\t.replace(/\\'/ig,\"~::~\\'\")\r\n\t\t\t\t\t\t\t.split('~::~'),\r\n\t\tlen = ar_by_quote.length,\r\n\t\tar = [],\r\n\t\tdeep = 0,\r\n\t\ttab = this.step,//+this.step,\r\n\t\tinComment = true,\r\n\t\tinQuote = false,\r\n\t\tparenthesisLevel = 0,\r\n\t\tstr = '',\r\n\t\tix = 0,\r\n\t\tshift = step ? createShiftArr(step) : this.shift;;\r\n\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\t\t\tif(ix%2) {\r\n\t\t\t\tar = ar.concat(ar_by_quote[ix]);\r\n\t\t\t} else {\r\n\t\t\t\tar = ar.concat(split_sql(ar_by_quote[ix], tab) );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlen = ar.length;\r\n\t\tfor(ix=0;ix<len;ix++) {\r\n\r\n\t\t\tparenthesisLevel = isSubquery(ar[ix], parenthesisLevel);\r\n\r\n\t\t\tif( /\\s{0,}\\s{0,}SELECT\\s{0,}/.exec(ar[ix]))  {\r\n\t\t\t\tar[ix] = ar[ix].replace(/\\,/g,\",\\n\"+tab+tab+\"\")\r\n\t\t\t}\r\n\r\n\t\t\tif( /\\s{0,}\\s{0,}SET\\s{0,}/.exec(ar[ix]))  {\r\n\t\t\t\tar[ix] = ar[ix].replace(/\\,/g,\",\\n\"+tab+tab+\"\")\r\n\t\t\t}\r\n\r\n\t\t\tif( /\\s{0,}\\(\\s{0,}SELECT\\s{0,}/.exec(ar[ix]))  {\r\n\t\t\t\tdeep++;\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t} else\r\n\t\t\tif( /\\'/.exec(ar[ix]) )  {\r\n\t\t\t\tif(parenthesisLevel<1 && deep) {\r\n\t\t\t\t\tdeep--;\r\n\t\t\t\t}\r\n\t\t\t\tstr += ar[ix];\r\n\t\t\t}\r\n\t\t\telse  {\r\n\t\t\t\tstr += shift[deep]+ar[ix];\r\n\t\t\t\tif(parenthesisLevel<1 && deep) {\r\n\t\t\t\t\tdeep--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar junk = 0;\r\n\t\t}\r\n\r\n\t\tstr = str.replace(/^\\n{1,}/,'').replace(/\\n{1,}/g,\"\\n\");\r\n\t\treturn str;\r\n}\r\n\r\n\r\nvkbeautify.prototype.xmlmin = function(text, preserveComments) {\r\n\r\n\tvar str = preserveComments ? text\r\n\t\t\t\t\t\t\t   : text.replace(/\\<![ \\r\\n\\t]*(--([^\\-]|[\\r\\n]|-[^\\-])*--[ \\r\\n\\t]*)\\>/g,\"\")\r\n\t\t\t\t\t\t\t\t\t .replace(/[ \\r\\n\\t]{1,}xmlns/g, ' xmlns');\r\n\treturn  str.replace(/>\\s{0,}</g,\"><\");\r\n}\r\n\r\nvkbeautify.prototype.jsonmin = function(text) {\r\n\r\n\tif (typeof JSON === 'undefined' ) return text;\r\n\r\n\treturn JSON.stringify(JSON.parse(text), null, 0);\r\n\r\n}\r\n\r\nvkbeautify.prototype.cssmin = function(text, preserveComments) {\r\n\r\n\tvar str = preserveComments ? text\r\n\t\t\t\t\t\t\t   : text.replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\//g,\"\") ;\r\n\r\n\treturn str.replace(/\\s{1,}/g,' ')\r\n\t\t\t  .replace(/\\{\\s{1,}/g,\"{\")\r\n\t\t\t  .replace(/\\}\\s{1,}/g,\"}\")\r\n\t\t\t  .replace(/\\;\\s{1,}/g,\";\")\r\n\t\t\t  .replace(/\\/\\*\\s{1,}/g,\"/*\")\r\n\t\t\t  .replace(/\\*\\/\\s{1,}/g,\"*/\");\r\n}\r\n\r\nvkbeautify.prototype.sqlmin = function(text) {\r\n\treturn text.replace(/\\s{1,}/g,\" \").replace(/\\s{1,}\\(/,\"(\").replace(/\\s{1,}\\)/,\")\");\r\n}\r\n\r\nmodule.exports = new vkbeautify();\r\n","var vm = require('vm')\n\nmodule.exports = function safeEval (code, context, opts) {\n  var sandbox = {}\n  var resultKey = 'SAFE_EVAL_' + Math.floor(Math.random() * 1000000)\n  sandbox[resultKey] = {}\n  var clearContext = `\n    (function(){\n      Function = undefined;\n      const keys = Object.getOwnPropertyNames(this).concat(['constructor']);\n      keys.forEach((key) => {\n        const item = this[key];\n        if(!item || typeof item.constructor !== 'function') return;\n        this[key].constructor = undefined;\n      });\n    })();\n  `\n  code = clearContext + resultKey + '=' + code\n  if (context) {\n    Object.keys(context).forEach(function (key) {\n      sandbox[key] = context[key]\n    })\n  }\n  vm.runInNewContext(code, sandbox, opts)\n  return sandbox[resultKey]\n}\n","var indexOf = function (xs, item) {\n    if (xs.indexOf) return xs.indexOf(item);\n    else for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === item) return i;\n    }\n    return -1;\n};\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    if (context) {\n        forEach(Object_keys(ctx), function (key) {\n            context[key] = ctx[key];\n        });\n    }\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.isContext = function (context) {\n    return context instanceof Context;\n};\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// import { getValueFormat } from '@grafana/data';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport TimeSeries from 'grafana/app/core/time_series2';\nimport _ from 'lodash';\nimport { loadPluginCss, MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\nimport { dateTime, PanelEvents } from '@grafana/data';\nimport appEvents from 'grafana/app/core/app_events';\n\nvar grafana = {\n  // formatValue(value, unit, decimals) {\n  //   const fmt = getValueFormat(unit);\n  //   const result = fmt(value, decimals).toString();\n  //   return result.toString();\n  // }\n  formatValue(value, unit, decimals) {\n    return kbn.valueFormats[unit](value, decimals, null).toString();\n  },\n\n  getUnitFormats() {\n    return kbn.getUnitFormats();\n  },\n\n  loadCss() {\n    loadPluginCss({\n      dark: 'plugins/agenty-flowcharting-panel/static/css/flowchart.dark.css',\n      light: 'plugins/agenty-flowcharting-panel/static/css/flowchart.light.css',\n    });\n  },\n\n  getTimeSeries(seriesData) {\n    return new TimeSeries({\n      datapoints: seriesData.datapoints || [],\n      alias: seriesData.target,\n      unit: seriesData.unit,\n    });\n  },\n\n  getFormatedDate(value, format) {\n    return dateTime(value).format(format);\n  },\n  appEvents: appEvents,\n  MetricsPanelCtrl: MetricsPanelCtrl,\n  PanelEvents: PanelEvents,\n};\n\nexport default grafana;\n","//import moment from 'moment';\nimport grafana from 'grafana_func';\nimport { State } from './state_class';\nimport _ from 'lodash';\nimport { Metric } from 'metric_class';\nimport { $GF } from 'globals_class';\nimport chroma from 'chroma-js';\n\n/**\n * Rule definition\n *\n * @export\n * @class Rule\n */\nexport class Rule {\n  data: gf.TIRuleData;\n  shapeMaps: ShapeMap[] = [];\n  textMaps: TextMap[] = [];\n  linkMaps: LinkMap[] = [];\n  eventMaps: EventMap[] = [];\n  valueMaps: ValueMap[] = [];\n  rangeMaps: RangeMap[] = [];\n  id: string;\n  removeClick = 2;\n  states: Map<string, State>;\n  highestLevel: number = -1;\n  highestColor: string = '';\n  highestFormattedValue: string = '';\n  highestValue: any = undefined;\n  execTimes: number = 0;\n\n  /**\n   * Creates an instance of Rule.\n   * @param {string} pattern\n   * @param {TIRuleData} data\n   * @memberof Rule\n   */\n  constructor(pattern: string, data: gf.TIRuleData) {\n    this.data = data;\n    this.data.pattern = pattern;\n    this.id = $GF.utils.uniqueID();\n    this.states = new Map();\n  }\n\n  /**\n   * Get default data\n   *\n   * @static\n   * @returns {gf.TIRuleData}\n   * @memberof Rule\n   */\n  static getDefaultData(): gf.TIRuleData {\n    return {\n      order: 1,\n      pattern: '.*',\n      unit: 'short',\n      type: 'number',\n      metricType: 'serie',\n      alias: 'myRule',\n      refId: 'A',\n      column: 'Time',\n      hidden: false,\n      aggregation: 'current',\n      decimals: 2,\n      colors: ['rgba(245, 54, 54, 0.9)', 'rgba(237, 129, 40, 0.89)', 'rgba(50, 172, 45, 0.97)'],\n      reduce: true,\n      dateFormat: 'YYYY-MM-DD HH:mm:ss',\n      thresholds: [50, 80],\n      stringThresholds: ['/.*/', '/.*/'],\n      invert: false,\n      gradient: false,\n      overlayIcon: false,\n      tooltip: false,\n      tooltipLabel: '',\n      tooltipColors: false,\n      tooltipOn: 'a',\n      tpDirection: 'v',\n      tpGraph: false,\n      tpGraphSize: '100%',\n      tpGraphType: 'line',\n      tpGraphLow: null,\n      tpGraphHigh: null,\n      tpGraphScale: 'linear',\n      shapeProp: 'id',\n      shapeRegEx: true,\n      shapeData: [],\n      textProp: 'id',\n      textRegEx: true,\n      textData: [],\n      linkProp: 'id',\n      linkRegEx: true,\n      linkData: [],\n      eventProp: 'id',\n      eventRegEx: false,\n      eventData: [],\n      mappingType: 1,\n      valueData: [],\n      rangeData: [],\n      sanitize: false,\n    };\n  }\n\n  /**\n   * return data of rule\n   *\n   * @returns {data}\n   * @memberof Rule\n   */\n  getData(): gf.TIRuleData {\n    return this.data;\n  }\n\n  /**\n   * import data in rule\n   *\n   * @returns {this}\n   * @param {data} obj\n   * @memberof Rule\n   */\n  import(obj: any): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'import()');\n    if (!!obj.unit) {\n      this.data.unit = obj.unit;\n    }\n    if (!!obj.type) {\n      this.data.type = obj.type;\n    }\n    if (!!obj.metricType) {\n      this.data.metricType = obj.metricType;\n    }\n    if (!!obj.alias) {\n      this.data.alias = obj.alias;\n    }\n    if (!!obj.refId) {\n      this.data.refId = obj.refId;\n    }\n    if (!!obj.column) {\n      this.data.column = obj.column;\n    }\n    if (!!obj.aggregation) {\n      this.data.aggregation = obj.aggregation;\n    }\n    if (!!obj.decimals || obj.decimals === 0) {\n      this.data.decimals = obj.decimals;\n    }\n    if (!!obj.colors) {\n      this.data.colors = obj.colors.slice(0);\n    }\n    if (!!this.data.reduce) {\n      this.data.reduce = true;\n    }\n\n    // 0.7.0\n    let colorOn: gf.TColorOnKeys | undefined = undefined;\n    if (!!obj.colorOn) {\n      colorOn = obj.colorOn;\n    }\n\n    // 0.7.0\n    let style: gf.TStyleColorKeys | undefined = undefined;\n    if (!!obj.style) {\n      style = obj.style;\n    }\n\n    // 0.7.0\n    let link = false;\n    let linkUrl: string | undefined = undefined;\n    let linkParams: boolean | undefined = undefined;\n    if (!!obj.link) {\n      link = obj.link;\n    }\n    if (!!obj.linkUrl) {\n      linkUrl = obj.linkUrl;\n    }\n    if (!!obj.linkParams) {\n      linkParams = obj.linkParams;\n    }\n\n    // 0.7.0\n    let linkOn: gf.TLinkOnKeys | undefined = undefined;\n    if (!!obj.linkOn) {\n      linkOn = obj.linkOn;\n    }\n\n    // 0.7.0\n    let textOn: gf.TTextOnKeys | undefined = undefined;\n    if (!!obj.textOn) {\n      textOn = obj.textOn;\n    }\n\n    // 0.7.0\n    let textReplace: gf.TTextMethodKeys | undefined = undefined;\n    let textPattern: string | undefined = undefined;\n    if (!!obj.textReplace) {\n      textReplace = obj.textReplace;\n    }\n    if (!!obj.textPattern) {\n      textPattern = obj.textPattern;\n    }\n    if (!!obj.pattern) {\n      this.data.pattern = obj.pattern;\n    }\n    if (!!obj.dateFormat) {\n      this.data.dateFormat = obj.dateFormat;\n    }\n    if (!!obj.thresholds) {\n      this.data.thresholds = obj.thresholds.map((x: any) => {\n        let value = x;\n        if (typeof value === 'string') {\n          value = parseFloat(value);\n        }\n        return value;\n      });\n      // this.data.thresholds = obj.thresholds.slice(0);\n    }\n\n    if (!!obj.stringThresholds) {\n      this.data.stringThresholds = obj.stringThresholds.slice(0);\n    }\n\n    if (!!obj.stringWarning) {\n      //this.data.stringWarning = obj.stringWarning;\n      this.data.stringThresholds[1] = obj.stringWarning;\n    }\n    if (!!obj.stringCritical) {\n      //this.data.stringCritical = obj.stringCritical;\n      this.data.stringThresholds[0] = obj.stringCritical;\n    }\n\n    if (!!obj.invert || obj.invert === false) {\n      this.data.invert = obj.invert;\n    }\n\n    if (!!obj.gradient || obj.gradient === false) {\n      this.data.gradient = obj.gradient;\n    }\n\n    if (!!obj.overlayIcon || obj.overlayIcon === false) {\n      this.data.overlayIcon = obj.overlayIcon;\n    }\n    if (!!obj.tooltip || obj.tooltip === false) {\n      this.data.tooltip = obj.tooltip;\n    }\n    if (!!obj.tooltipLabel) {\n      this.data.tooltipLabel = obj.tooltipLabel;\n    }\n    if (!!obj.tooltipColors || obj.tooltipColors === false) {\n      this.data.tooltipColors = obj.tooltipColors;\n    }\n    if (!!obj.tooltipOn) {\n      this.data.tooltipOn = obj.tooltipOn;\n    }\n    if (!!obj.tpDirection) {\n      this.data.tpDirection = obj.tpDirection;\n    }\n    if (!!obj.tpGraph || this.data.tpGraph === false) {\n      this.data.tpGraph = obj.tpGraph;\n    }\n    if (!!obj.tpGraphSize) {\n      this.data.tpGraphSize = obj.tpGraphSize;\n    }\n    if (!!obj.tpGraphType) {\n      this.data.tpGraphType = obj.tpGraphType;\n    }\n    if (!!obj.tpGraphLow || obj.tpGraphLow === 0) {\n      this.data.tpGraphLow = obj.tpGraphLow;\n    }\n    if (!!obj.tpGraphHigh || obj.tpGraphHigh === 0) {\n      this.data.tpGraphHigh = obj.tpGraphHigh;\n    }\n    if (!!obj.tpGraphScale) {\n      this.data.tpGraphScale = obj.tpGraphScale;\n    }\n    let maps: any = [];\n\n    // SHAPES\n    if (!!obj.shapeProp) {\n      this.data.shapeProp = obj.shapeProp;\n    }\n    if (!!obj.shapeRegEx || obj.shapeRegEx === false) {\n      this.data.shapeRegEx = obj.shapeRegEx;\n    }\n\n    this.data.shapeData = [];\n\n    // For 0.2.0\n    maps = [];\n    if (obj.shapeMaps !== undefined && obj.shapeMaps !== null && obj.shapeMaps.length > 0) {\n      maps = obj.shapeMaps;\n    } else {\n      maps = obj.shapeData;\n    }\n\n    if (maps !== undefined && maps !== null && maps.length > 0) {\n      maps.forEach((shapeData: gf.TShapeMapData) => {\n        // 0.7.0\n        if (!!style) {\n          shapeData.style = style;\n        }\n\n        // 0.7.0\n        if (!!colorOn) {\n          shapeData.colorOn = colorOn;\n        }\n        this.addShapeMap('').import(shapeData);\n      });\n    }\n\n    // TEXT\n    this.data.textProp = obj.textProp || 'id';\n    if (!!obj.textRegEx || obj.textRegEx === false) {\n      this.data.textRegEx = obj.textRegEx;\n    }\n    this.data.textData = [];\n    // For 0.2.0\n    maps = [];\n    if (obj.shapeMaps !== undefined && obj.shapeMaps !== null && obj.shapeMaps.length > 0) {\n      maps = obj.textMaps;\n    } else {\n      maps = obj.textData;\n    }\n\n    if (maps !== undefined && maps != null && maps.length > 0) {\n      maps.forEach((textData: gf.TTextMapData) => {\n        // 0.7.0\n        if (!!textReplace) {\n          textData.textReplace = textReplace;\n        }\n        if (!!textPattern) {\n          textData.textPattern = textPattern;\n        }\n        if (!!textOn) {\n          textData.textOn = textOn;\n        }\n\n        this.addTextMap('').import(textData);\n      });\n    }\n\n    // LINK\n    this.data.linkProp = obj.linkProp || 'id';\n    if (!!obj.linkRegEx || obj.linkRegEx === false) {\n      this.data.linkRegEx = obj.linkRegEx;\n    }\n    this.data.linkData = [];\n    if (obj.linkData !== undefined && obj.linkData != null && obj.linkData.length > 0) {\n      obj.linkData.forEach((linkData: gf.TlinkMapData) => {\n        // 0.7.0\n        if (!!linkUrl && link) {\n          linkData.linkUrl = linkUrl;\n        }\n        if (!!linkParams && link) {\n          linkData.linkParams = linkParams;\n        }\n        if (!!linkOn) {\n          linkData.linkOn = linkOn;\n        }\n        this.addLinkMap('').import(linkData);\n      });\n    }\n\n    // EVENT\n    this.data.eventProp = obj.eventProp || 'id';\n    if (!!obj.eventRegEx || obj.eventRegEx === false) {\n      this.data.eventRegEx = obj.eventRegEx;\n    }\n    this.data.eventData = [];\n    if (obj.eventData !== undefined && obj.eventData != null && obj.eventData.length > 0) {\n      obj.eventData.forEach((eventData: gf.TEventMapData) => {\n        // 0.7.0\n        this.addEventMap('').import(eventData);\n      });\n    }\n\n    this.data.mappingType = obj.mappingType || 1;\n\n    // VALUES\n    this.data.valueData = [];\n    if (obj.valueData !== undefined && obj.valueData != null && obj.valueData.length > 0) {\n      obj.valueData.forEach((valueData: gf.TValueMapData) => {\n        this.addValueMap('value', 'text').import(valueData);\n      });\n    }\n\n    // RANGE\n    this.data.rangeData = [];\n    if (obj.rangeData !== undefined && obj.rangeData != null && obj.rangeData.length > 0) {\n      obj.rangeData.forEach(rangeData => {\n        this.addRangeMap('from', 'to', 'text').import(rangeData);\n      });\n    }\n    this.data.sanitize = obj.sanitize || false;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Return uniq id of rule\n   *\n   * @returns\n   * @memberof Rule\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Highlight Cells in rule (mapping color text and link)\n   *\n   * @memberof Rule\n   */\n  highlightCells() {\n    if (this.states) {\n      this.states.forEach(state => {\n        state.highlightCell();\n      });\n    }\n  }\n\n  /**\n   * Highlight Cells in rule (mapping color text and link)\n   *\n   * @memberof Rule\n   */\n  unhighlightCells() {\n    if (this.states) {\n      this.states.forEach(state => {\n        state.unhighlightCell();\n      });\n    }\n  }\n\n  /**\n   * Return the order of this rule\n   * Grafana 6+ have a bug when reload dashboad, array are not in order\n   *\n   * @param {number} order\n   * @memberof Rule\n   */\n  setOrder(order: number) {\n    this.data.order = order;\n  }\n\n  /**\n   * Return order of rule\n   *\n   * @memberof Rule\n   */\n  getOrder(): number {\n    return this.data.order;\n  }\n\n  isHidden(): boolean {\n    return this.data.hidden;\n  }\n\n  hide(): this {\n    this.data.hidden = true;\n    return this;\n  }\n\n  show(): this {\n    this.data.hidden = false;\n    return this;\n  }\n\n  /**\n   * Invert color order\n   *\n   * @returns {this}\n   * @memberof Rule\n   */\n  invertColorOrder(): this {\n    // const ref = this.data.colors;\n    // const copy = ref[0];\n    // ref[0] = ref[2];\n    // ref[2] = copy;\n    this.data.colors.reverse();\n    // this.data.invert = !this.data.invert;\n    // if (this.data.invert) {\n    //   this.data.invert = false;\n    // } else {\n    //   this.data.invert = true;\n    // }\n    return this;\n  }\n\n  /**\n   * Invert threshold\n   *\n   * @returns {this}\n   * @memberof Rule\n   */\n  invertThesholds(): this {\n    this.invertColorOrder();\n    this.data.invert = !this.data.invert;\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {number} index\n   * @returns {this}\n   * @memberof Rule\n   */\n  addColor(index: number): this {\n    const thresholds = this.data.thresholds;\n    const colors = this.data.colors;\n    const colorStart: string = colors[index];\n    let color: string;\n    let value: any;\n    if (index !== colors.length - 1) {\n      const ratio = 0.5;\n      let colorEnd = colors[index + 1];\n      try {\n        // color = $GF.utils.getRatioColor(ratio, colorStart, colorEnd);\n        let f = chroma.scale([colorStart, colorEnd]).mode('lrgb');\n        color = f(ratio).hex();\n      } catch (error) {\n        $GF.log.error(error);\n        color = colorStart;\n      }\n      if (this.data.type === 'number') {\n        let absoluteDistance = thresholds[index] - thresholds[index - 1];\n        value = absoluteDistance / 2 + thresholds[index - 1];\n      } else {\n        value = this.data.stringThresholds[index - 1];\n      }\n    } else {\n      color = colorStart;\n    }\n    this.data.colors.splice(index + 1, 0, color);\n    if (this.data.type === 'number') {\n      this.data.thresholds.splice(index, 0, value);\n    } else if (this.data.type === 'string') {\n      this.data.stringThresholds.splice(index, 0, value);\n    }\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {number} index\n   * @returns {this}\n   * @memberof Rule\n   */\n  removeColor(index: number): this {\n    this.data.thresholds.splice(index - 1, 1);\n    this.data.stringThresholds.splice(index - 1, 1);\n    this.data.colors.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Return a color\n   *\n   * @param {number} index\n   * @returns {string} html color\n   * @memberof Rule\n   */\n  getColor(index: number): string {\n    return this.data.colors[index];\n  }\n\n  /**\n   * Return Array of html colors\n   *\n   * @returns {string[]}\n   * @memberof Rule\n   */\n  getColors(): string[] {\n    return this.data.colors;\n  }\n\n  /**\n   * Return number of colors\n   *\n   * @returns {number}\n   * @memberof Rule\n   */\n  getColorsCount(): number {\n    return this.data.colors.length;\n  }\n\n  //\n  // Conditions\n  //\n\n  /**\n   * Return true or false for condition to display icon warning\n   *\n   * @param {level} level\n   * @returns {boolean}\n   * @memberof Rule\n   */\n  toIconize(level: number): boolean {\n    if (this.data.overlayIcon === false) {\n      return false;\n    }\n    if (this.data.overlayIcon === true && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Return true or false for condition to display tooltip with values\n   *\n   * @param {number} level\n   * @returns\n   * @memberof Rule\n   */\n  toTooltipize(level: number): boolean {\n    if (this.data.tooltip === false) {\n      return false;\n    }\n    if (this.data.tooltipOn === 'a') {\n      return true;\n    }\n    if (this.data.tooltipOn === 'wc' && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n\n  //\n  // Series|Tables\n  //\n  /**\n   * Return boolean if metrics is matched by rule\n   *\n   * @param {Metric} metric\n   * @returns {boolean}\n   * @memberof Rule\n   */\n  matchMetric(metric: Metric): boolean {\n    if (this.data.metricType === 'serie' && metric.type === 'serie') {\n      return $GF.utils.matchString(metric.getName(), this.data.pattern);\n    }\n    if (this.data.metricType === 'table' && metric.type === 'table') {\n      return metric.getName() === this.data.refId;\n    }\n    return false;\n  }\n\n  //\n  // SHAPE MAPS\n  //\n  /**\n   * Add new shape for rule\n   *\n   * @param {string} pattern\n   * @memberof Rule\n   */\n  addShapeMap(pattern: string): ShapeMap {\n    const data = ShapeMap.getDefaultData();\n    const m = new ShapeMap(pattern, data);\n    this.shapeMaps.push(m);\n    this.data.shapeData.push(data);\n    return m;\n  }\n\n  /**\n   * Remove shape for rule\n   *\n   * @returns {this}\n   * @param {number} index\n   * @memberof Rule\n   */\n  removeShapeMap(index: number): this {\n    this.data.shapeData.splice(index, 1);\n    this.shapeMaps.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Return shape objet in index position\n   *\n   * @param {number} index\n   * @returns {ShapeMap}\n   * @memberof Rule\n   */\n  getShapeMap(index: number): ShapeMap {\n    return this.shapeMaps[index];\n  }\n\n  /**\n   * Return all ShapeMaps\n   *\n   * @returns {Array<ShapeMap>}\n   * @memberof Rule\n   */\n  getShapeMaps(): ShapeMap[] {\n    return this.shapeMaps;\n  }\n\n  /**\n   * Return bool if shape name (value|id) is in rule\n   *\n   * @param {string} pattern\n   * @returns {boolean}\n   * @memberof Rule\n   */\n  matchShape(pattern: string | null): boolean {\n    let found = false;\n    this.shapeMaps.forEach(element => {\n      if (element.match(pattern, this.data.shapeRegEx)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // TEXT MAPS\n  //\n  addTextMap(pattern: string): TextMap {\n    const data = TextMap.getDefaultData();\n    const m = new TextMap(pattern, data);\n    this.textMaps.push(m);\n    this.data.textData.push(data);\n    return m;\n  }\n\n  removeTextMap(index: number) {\n    this.data.textData.splice(index, 1);\n    this.textMaps.splice(index, 1);\n  }\n\n  getTextMap(index: number): TextMap {\n    return this.textMaps[index];\n  }\n\n  getTextMaps(): TextMap[] {\n    return this.textMaps;\n  }\n\n  matchText(pattern: string | null): boolean {\n    let found = false;\n    this.textMaps.forEach(element => {\n      if (element.match(pattern)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // Event MAPS\n  //\n  addEventMap(pattern: string): EventMap {\n    const data = EventMap.getDefaultData();\n    const m = new EventMap(pattern, data);\n    this.eventMaps.push(m);\n    this.data.eventData.push(data);\n    return m;\n  }\n\n  removeEventMap(index: number) {\n    this.data.eventData.splice(index, 1);\n    this.eventMaps.splice(index, 1);\n  }\n\n  getEventMap(index: number): EventMap {\n    return this.eventMaps[index];\n  }\n\n  getEventMaps(): EventMap[] {\n    return this.eventMaps;\n  }\n\n  matchEvent(pattern: string | null): boolean {\n    let found = false;\n    this.eventMaps.forEach(element => {\n      if (element.match(pattern)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // LINK MAPS\n  //\n  addLinkMap(pattern: string): LinkMap {\n    $GF.log.info('Rule.addLinkMap()');\n    const data = LinkMap.getDefaultData();\n    const m = new LinkMap(pattern, data);\n    m.import(data);\n    this.linkMaps.push(m);\n    this.data.linkData.push(data);\n    return m;\n  }\n\n  removeLinkMap(index: number) {\n    this.data.linkData.splice(index, 1);\n    this.linkMaps.splice(index, 1);\n  }\n\n  getLinkMap(index: number): LinkMap {\n    return this.linkMaps[index];\n  }\n\n  getLinkMaps(): LinkMap[] {\n    return this.linkMaps;\n  }\n\n  matchLink(pattern: string | null): boolean {\n    let found = false;\n    this.linkMaps.forEach(element => {\n      if (element.match(pattern)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  //\n  // STRING VALUE MAPS\n  //\n  addValueMap(value: any, text: string): ValueMap {\n    const data: gf.TValueMapData = ValueMap.getDefaultdata();\n    const m = new ValueMap(value, text, data);\n    this.valueMaps.push(m);\n    this.data.valueData.push(data);\n    return m;\n  }\n\n  removeValueMap(index) {\n    this.data.valueData.splice(index, 1);\n    this.valueMaps.splice(index, 1);\n  }\n\n  getValueMap(index): ValueMap {\n    return this.valueMaps[index];\n  }\n\n  getValueMaps(): ValueMap[] {\n    return this.valueMaps;\n  }\n\n  //\n  // STRING RANGE VALUE MAPS\n  //\n  addRangeMap(from, to, text): RangeMap {\n    const data = RangeMap.getDefaultData();\n    const m = new RangeMap(from, to, text, data);\n    this.rangeMaps.push(m);\n    this.data.rangeData.push(data);\n    return m;\n  }\n\n  removeRangeMap(index) {\n    this.data.rangeData.splice(index, 1);\n    this.rangeMaps.splice(index, 1);\n  }\n\n  getRangeMap(index): RangeMap {\n    return this.rangeMaps[index];\n  }\n\n  getRangeMaps(): RangeMap[] {\n    return this.rangeMaps;\n  }\n\n  hideRangeMap(index): this {\n    this.rangeMaps[index].hide();\n    return this;\n  }\n\n  showRangeMap(index): this {\n    this.rangeMaps[index].show();\n    return this;\n  }\n\n  getExectedTime(): string {\n    return typeof this.execTimes === 'number' ? `${this.execTimes.toFixed(2)} ms` : `${this.execTimes} ms`;\n  }\n\n  //\n  // Format value\n  //\n  /**\n   * Get color according to value\n   *\n   * @param {number} value\n   * @returns {string} html color\n   * @memberof Rule\n   */\n  getColorForValue(value: any): string {\n    if (!this.data.gradient || this.data.type !== 'number') {\n      let level = this.getThresholdLevel(value);\n      return this.getColorForLevel(level);\n    }\n    if (this.data.type === 'number') {\n      const thresholds = this.data.thresholds;\n      const colors = this.data.colors;\n      let l = thresholds.length;\n      // No Thresholds\n      if (thresholds === undefined || l === 0) {\n        return colors[0];\n      }\n\n      let cursor = 0;\n      for (let index = 0; index < l; index++) {\n        const t = thresholds[index];\n        if (value < t) {\n          break;\n        }\n        cursor = index;\n      }\n      // value Lower than min level\n      if (cursor === 0 && value <= thresholds[0]) {\n        return colors[0];\n      }\n      // value upper then max level\n      if (cursor === l - 1) {\n        return colors[cursor + 1];\n      }\n      // Or\n      let absoluteDistance = thresholds[cursor + 1] - thresholds[cursor];\n      let valueDistanceFromMin = value - thresholds[cursor];\n      let ratio = valueDistanceFromMin / absoluteDistance;\n      // let color = $GF.utils.getRatioColor(ratio, colors[cursor + 1], colors[cursor + 2]);\n      let color = colors[cursor + 1];\n      try {\n        color = chroma\n          .scale([colors[cursor + 1], colors[cursor + 2]])\n          .mode('lrgb')(ratio)\n          .hex();\n      } catch (error) {\n        color = colors[cursor + 1];\n      }\n      return color;\n    }\n    return '';\n  }\n\n  /**\n   * Get color according level (-1,0,1,2)\n   *\n   * @param {*} level\n   * @returns\n   * @memberof Rule\n   */\n  getColorForLevel(level: number): string {\n    const colors = this.data.colors;\n    if (level < 0) {\n      return colors[0];\n    }\n    let l = level;\n    if (!this.data.invert) {\n      l = this.data.colors.length - 1 - level;\n    }\n    if (colors[l] !== undefined) {\n      return colors[l];\n    }\n    return colors[0];\n  }\n\n  /**\n   * Return Level according to value and rule options\n   *\n   * @param {number} value\n   * @returns 0, 1 or 2\n   * @memberof Rule\n   */\n  getThresholdLevel(value: any): number {\n    // NUMBER\n    if (this.data.type === 'number') {\n      let thresholdLevel = 0;\n      let thresholds = this.data.thresholds;\n\n      if (thresholds === undefined || thresholds.length === 0) {\n        return 0;\n      }\n\n      let l = thresholds.length;\n      for (let index = 0; index < l; index++) {\n        const t = thresholds[index];\n        if (value < t) {\n          break;\n        }\n        thresholdLevel = index + 1;\n      }\n\n      if (!this.data.invert) {\n        thresholdLevel = this.data.colors.length - 1 - thresholdLevel;\n      }\n      return thresholdLevel;\n    }\n    // STRING\n    if (this.data.type === 'string') {\n      let thresholdLevel = 0;\n      const formatedValue = this.getFormattedValue(value);\n      let thresholds = this.data.stringThresholds;\n      if (thresholds === undefined || thresholds.length === 0) {\n        return 0;\n      }\n      let l = thresholds.length;\n      for (let index = 0; index < l; index++) {\n        const t = thresholds[index];\n        if ($GF.utils.matchString(value, t) || $GF.utils.matchString(formatedValue, t)) {\n          thresholdLevel = index + 1;\n          break;\n        }\n      }\n\n      if (!this.data.invert) {\n        thresholdLevel = this.data.colors.length - 1 - thresholdLevel;\n      }\n      return thresholdLevel;\n    }\n    return 0;\n  }\n\n  /**\n   * Get value for this metric\n   *\n   * @param {Metric} metric\n   * @returns {(string | number | null)}\n   * @memberof Rule\n   */\n  getValueForMetric(metric: Metric): string | number | null {\n    if (this.matchMetric(metric)) {\n      try {\n        const value = metric.getValue(this.data.aggregation, this.data.column);\n        return value;\n      } catch (error) {\n        $GF.log.error('datapoint for metric is null', error);\n        return null;\n      }\n    }\n    return '-';\n  }\n\n  /**\n   * Get formatting value according unit\n   *\n   * @param {Metric} metric\n   * @returns {string}\n   * @memberof Rule\n   */\n  getFormattedValueForMetric(metric: Metric): string {\n    const formattedValue = this.getValueForMetric(metric);\n    return this.getFormattedValue(formattedValue);\n  }\n\n  /**\n   * Format a one value according rule\n   *\n   * @param {*} value\n   * @returns\n   * @memberof Rule\n   */\n  getFormattedValue(value: any) {\n    // Number\n    if (this.data.type === 'number') {\n      if (!_.isFinite(value)) {\n        return 'null';\n      }\n      if (value === null || value === void 0) {\n        return '-';\n      }\n      let decimals = this.decimalPlaces(value);\n      decimals = typeof this.data.decimals === 'number' ? Math.min(this.data.decimals, decimals) : decimals;\n      return grafana.formatValue(value, this.data.unit, this.data.decimals);\n    }\n\n    if (this.data.type === 'string') {\n      if (value === null || value === void 0) {\n        value = 'null';\n      }\n\n      if (_.isArray(value)) {\n        value = value.join(', ');\n      }\n      const mappingType = this.data.mappingType || 0;\n      if (mappingType === 1 && this.valueMaps) {\n        for (let i = 0; i < this.valueMaps.length; i += 1) {\n          const map = this.valueMaps[i];\n          if (map.match(value)) {\n            return map.getFormattedText(value);\n          }\n        }\n        return value.toString();\n      }\n\n      if (mappingType === 2 && this.rangeMaps) {\n        for (let i = 0; i < this.rangeMaps.length; i += 1) {\n          const map = this.rangeMaps[i];\n          if (map.match(value)) {\n            return map.getFormattedText(value);\n          }\n        }\n        return value.toString();\n      }\n\n      if (value === null || value === void 0) {\n        return 'null';\n      }\n    }\n\n    if (this.data.type === 'date') {\n      if (value === undefined || value === null) {\n        return '-';\n      }\n\n      if (_.isArray(value)) {\n        value = value[0];\n      }\n\n      let d = grafana.getFormatedDate(value, this.data.dateFormat);\n      return d;\n    }\n    return value;\n  }\n\n  defaultValueFormatter(value: any) {\n    if (value === null || value === void 0 || value === undefined) {\n      return '';\n    }\n\n    if (_.isArray(value)) {\n      value = value.join(', ');\n    }\n\n    if (this.data.sanitize) {\n      return this.$sanitize(value);\n    }\n    return _.escape(value);\n  }\n  $sanitize(value: any) {\n    throw new Error('Method not implemented.');\n  }\n\n  decimalPlaces(num) {\n    const match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(\n      0,\n      // Number of digits right of decimal point.\n      (match[1] ? match[1].length : 0) -\n        // Adjust for scientific notation.\n        (match[2] ? +match[2] : 0)\n    );\n  }\n}\n\nexport class GFMap {\n  data: gf.TGFMapData;\n  id: string;\n  static methods: any[] = [];\n  constructor(pattern, data: gf.TGFMapData) {\n    this.data = data;\n    this.data.pattern = pattern;\n    this.id = $GF.utils.uniqueID();\n    // this.import(data);\n  }\n\n  /**\n   * Import data from panel\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof GFMap\n   */\n  import(obj: any): this {\n    if (!!obj.pattern) {\n      this.data.pattern = obj.pattern;\n    }\n    if (!!obj.hidden) {\n      this.data.hidden = obj.hidden;\n    }\n    return this;\n  }\n\n  static getDefaultMethods() {\n    return this.methods;\n  }\n\n  static getDefaultPlaceHolder(value: string): string | undefined {\n    const elt = this.methods.find(x => x.value === value);\n    if (elt !== undefined) {\n      return elt.placeholder;\n    }\n    return undefined;\n  }\n\n  static getDefaultValue(value: string): string | undefined {\n    const elt = this.methods.find(x => x.value === value);\n    if (elt !== undefined) {\n      return elt.default;\n    }\n    return undefined;\n  }\n\n  /**\n   * Return if text match pattern\n   *\n   * @param {(string | null)} text\n   * @returns {boolean}\n   * @memberof GFMap\n   */\n  match(text: string | null, regex = true): boolean {\n    if (text === undefined || text === null || text.length === 0) {\n      return false;\n    }\n    return $GF.utils.matchString(text, this.data.pattern, regex);\n  }\n\n  /**\n   * Return uniq ID\n   *\n   * @returns {string}\n   * @memberof GFMap\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Show/enable\n   *\n   * @returns {this}\n   * @memberof GFMap\n   */\n  show(): this {\n    this.data.hidden = false;\n    return this;\n  }\n\n  /**\n   * Hide/disable\n   *\n   * @returns {this}\n   * @memberof GFMap\n   */\n  hide(): this {\n    this.data.hidden = true;\n    return this;\n  }\n\n  /**\n   * Return if hidden\n   *\n   * @returns {boolean}\n   * @memberof GFMap\n   */\n  isHidden(): boolean {\n    if (this.data.hidden === undefined) {\n      return false;\n    }\n    return this.data.hidden;\n  }\n\n  /**\n   * Toggle Visible/Hide\n   *\n   * @returns {boolean}\n   * @memberof GFMap\n   */\n  toVisible(): boolean {\n    if (this.data.hidden) {\n      return false;\n    }\n    return true;\n  }\n\n  export(): gf.TGFMapData {\n    return {\n      pattern: this.data.pattern,\n      hidden: this.data.hidden,\n    };\n  }\n}\n\n/**\n * ShapeMap class for mapping\n * @class ShapeMap\n * @extends GFMap\n */\nexport class ShapeMap extends GFMap {\n  data: gf.TShapeMapData;\n\n  /**\n   * Creates an instance of ShapeMap.\n   * @param {string} pattern\n   * @param {gf.TShapeMapData} data\n   * @memberof ShapeMap\n   */\n  constructor(pattern: string, data: gf.TShapeMapData) {\n    super(pattern, data);\n    this.data = data;\n  }\n\n  /**\n   * Return default data\n   *\n   * @static\n   * @returns {gf.TShapeMapData}\n   * @memberof ShapeMap\n   */\n  static getDefaultData(): gf.TShapeMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      style: 'fillColor',\n      colorOn: 'a',\n    };\n  }\n\n  /**\n   * Return true or false for condition to colorize\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof ShapeMap\n   * 0.7.0 : Moved to shape\n   */\n  toColorize(level: number): boolean {\n    if (level === -1) {\n      return false;\n    }\n    if (this.data.colorOn === 'n') {\n      return false;\n    }\n    if (this.data.colorOn === 'a') {\n      return true;\n    }\n    if (this.data.colorOn === 'wc' && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Import data\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof ShapeMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.style) {\n      this.data.style = obj.style;\n    }\n    if (!!obj.colorOn) {\n      this.data.colorOn = obj.colorOn;\n    }\n    return this;\n  }\n}\n\n/**\n * TextMap class for mapping\n * @class TextMap\n * @extends GFMap\n */\nexport class TextMap extends GFMap {\n  data: gf.TTextMapData;\n\n  constructor(pattern: string, data: gf.TTextMapData) {\n    super(pattern, data);\n    this.data = data;\n  }\n\n  /**\n   * Return default data\n   *\n   * @static\n   * @returns {gf.TTextMapData}\n   * @memberof TextMap\n   */\n  static getDefaultData(): gf.TTextMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      textReplace: 'content',\n      textPattern: '/.*/',\n      textOn: 'wmd',\n    };\n  }\n\n  /**\n   * Return true or false for condition to change label\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof TextMap\n   */\n  toLabelize(level: number): boolean {\n    // if (this.data.textOn === 'wmd' && level > 0) return true;\n    // if (this.data.textOn === 'wmd' && level === -1) return false;\n    if (this.data.textOn === 'wmd') {\n      return true;\n    }\n    if (this.data.textOn === 'n') {\n      return false;\n    }\n    if (this.data.textOn === 'wc' && level >= 1) {\n      return true;\n    }\n    if (this.data.textOn === 'co' && level >= 2) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Import data from current or old version\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof TextMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.textReplace) {\n      this.data.textReplace = obj.textReplace;\n    }\n    if (!!obj.textPattern) {\n      this.data.textPattern = obj.textPattern;\n    }\n    if (!!obj.textOn) {\n      this.data.textOn = obj.textOn;\n    }\n\n    return this;\n  }\n\n  /**\n   * Replace text according text options\n   *\n   * @param {string} text\n   * @param {string} FormattedValue\n   * @returns\n   * @memberof Rule\n   */\n  getReplaceText(text: string, FormattedValue: string): string {\n    if (this.data.textReplace === 'content') {\n      return FormattedValue;\n    }\n    if (this.data.textReplace === 'pattern') {\n      const regexVal = $GF.utils.stringToJsRegex(this.data.textPattern);\n      if (text.toString().match(regexVal)) {\n        return text.toString().replace(regexVal, FormattedValue);\n      }\n      return text;\n    }\n    if (this.data.textReplace === 'as') {\n      return `${text} ${FormattedValue}`;\n    }\n    if (this.data.textReplace === 'anl') {\n      return `${text}\\n${FormattedValue}`;\n    }\n    return text;\n  }\n}\n\n/**\n * LinkMap class for mapping\n * @class LinkMap\n * @extends GFMap\n */\nexport class LinkMap extends GFMap {\n  data: gf.TlinkMapData;\n\n  constructor(pattern: string, data: gf.TlinkMapData) {\n    super(pattern, data);\n    this.data = data;\n  }\n\n  static getDefaultData(): gf.TlinkMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      linkUrl: '',\n      linkParams: false,\n      linkOn: 'a',\n    };\n  }\n\n  /**\n   * Get defined link\n   *\n   * @returns\n   * @memberof Rule\n   */\n  getLink() {\n    if (this.data.linkParams) {\n      return this.data.linkUrl + window.location.search;\n    }\n    return this.data.linkUrl;\n  }\n\n  /**\n   * Import data to Link\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof LinkMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.linkUrl) {\n      this.data.linkUrl = obj.linkUrl;\n    }\n    if (!!obj.linkParams) {\n      this.data.linkParams = obj.linkParams;\n    }\n    if (!!obj.linkOn) {\n      this.data.linkOn = obj.linkOn;\n    }\n    return this;\n  }\n\n  /**\n   * Return true or false for condition to add/replace link\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof LinkMap\n   */\n  toLinkable(level: number): boolean {\n    if (this.data.linkOn === 'a') {\n      return true;\n    }\n    if (this.data.linkOn === 'wc' && level >= 1) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport class EventMap extends GFMap {\n  data: gf.TEventMapData;\n  static methods = $GF.CONSTANTS.EVENTMETHODS;\n  // static shapes: string[] = EventMap.getFormNames();\n  static shapes: string[] = [];\n\n  /**\n   * Creates an instance of EventMap.\n   * @param {string} pattern\n   * @param {gf.TEventMapData} data\n   * @memberof EventMap\n   */\n  constructor(pattern: string, data: gf.TEventMapData) {\n    super(pattern, data);\n    this.data = data;\n    // GFGlobal.loadFile(_GF.CONSTANTS.VAR_STG_SHAPES, _GF.CONSTANTS.CONF_FILE_SHAPES);\n  }\n\n  /**\n   * Return default data\n   *\n   * @static\n   * @returns {gf.TShapeMapData}\n   * @memberof ShapeMap\n   */\n  static getDefaultData(): gf.TEventMapData {\n    return {\n      pattern: '',\n      hidden: false,\n      style: 'shape',\n      eventOn: 0,\n      value: '',\n    };\n  }\n\n  getPlaceHolder(): string {\n    const ph = EventMap.getDefaultPlaceHolder(this.data.style);\n    return ph !== undefined ? ph : '';\n  }\n\n  getTypeahead(): string[] {\n    const self = this;\n    let result = $GF.getFullAvailableVarNames();\n    const elt: gf.TStyleEventElt | undefined = EventMap.methods.find(x => x.value === self.data.style);\n    if (elt !== undefined && elt.typeahead !== undefined) {\n      result = result.concat(elt.typeahead.split('|'));\n      return result;\n    }\n    if (this.data.style === 'shape') {\n      const shapes = EventMap.getFormNames();\n      Array.prototype.push.apply(result, shapes);\n    }\n    return result;\n  }\n\n  getValueByDefault(): string {\n    const vbd = EventMap.getDefaultValue(this.data.style);\n    return vbd !== undefined ? vbd : '';\n  }\n\n  static getFormNames(): string[] {\n    // if (EventMap.shapes === undefined) {\n    //   EventMap.shapes = [];\n    // }\n\n    if (EventMap.shapes.length > 0) {\n      return EventMap.shapes;\n    }\n    // _GF.loadLocalFile(_GF.CONSTANTS.VAR_STG_SHAPES, _GF.CONSTANTS.CONF_FILE_SHAPES);\n    // const shapesText: string = _GF.getVar(_GF.CONSTANTS.VAR_STG_SHAPES);\n    const shapesText = $GF.utils.loadFile(\n      $GF.getVar($GF.CONSTANTS.VAR_STG_CTXROOT) + $GF.CONSTANTS.CONF_FILE_SHAPESTXT\n    );\n    if (shapesText !== undefined) {\n      if (EventMap.shapes.length === 0) {\n        EventMap.shapes = EventMap.shapes.concat(shapesText.split(/\\n/));\n        // _GF.unsetVar(_GF.CONSTANTS.VAR_STG_SHAPES);\n        return EventMap.shapes;\n      }\n    }\n    return EventMap.shapes;\n  }\n\n  /**\n   * Return true or false for condition to colorize\n   *\n   * @param {number} level\n   * @returns {boolean}\n   * @memberof ShapeMap\n   * 0.7.0 : Moved to shape\n   */\n  toEventable(level: number): boolean {\n    return this.data.eventOn === -1 || level === this.data.eventOn;\n  }\n\n  /**\n   * Import data\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof ShapeMap\n   */\n  import(obj: any): this {\n    super.import(obj);\n    if (!!obj.style) {\n      this.data.style = obj.style;\n    }\n    if (!!obj.eventOn) {\n      this.data.eventOn = obj.eventOn;\n    }\n    if (!!obj.value) {\n      this.data.value = obj.value;\n    }\n    return this;\n  }\n}\n\n/**\n * TextMap class for Range Value\n * @class RangeMap\n */\nclass RangeMap {\n  data: gf.TRangeMapData;\n  constructor(from: string, to: string, text: string, data: gf.TRangeMapData) {\n    this.data = data;\n    this.data.from = from;\n    this.data.to = to;\n    this.data.text = text;\n    this.data.hidden = false;\n    // this.import(data);\n  }\n\n  /**\n   * import data from panel\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof RangeMap\n   */\n  import(obj: any): this {\n    this.data.from = !!obj.from ? obj.from : undefined;\n    this.data.to = !!obj.to ? obj.to : undefined;\n    this.data.text = !!obj.text ? obj.text : undefined;\n    this.data.hidden = !!obj.hidden || obj.hidden === false ? obj.hidden : false;\n    return this;\n  }\n\n  /**\n   * Get default data\n   *\n   * @static\n   * @returns {gf.TRangeMapData}\n   * @memberof RangeMap\n   */\n  static getDefaultData(): gf.TRangeMapData {\n    return {\n      from: undefined,\n      to: undefined,\n      text: undefined,\n      hidden: false,\n    };\n  }\n\n  /**\n   * Match value\n   *\n   * @param {*} value\n   * @returns {boolean}\n   * @memberof RangeMap\n   */\n  match(value: any): boolean {\n    if (\n      (value !== undefined && typeof value === 'string' && value.length > 0) ||\n      (value !== undefined && typeof value === 'number')\n    ) {\n      let v: number = Number(value);\n      if (\n        (this.data.from !== undefined && typeof value === 'string' && this.data.from.length > 0) ||\n        (this.data.from !== undefined && typeof value === 'number')\n      ) {\n        let from = Number(this.data.from);\n        if (v >= from) {\n          if (\n            (this.data.to !== undefined && typeof this.data.to === 'string' && this.data.to.length > 0) ||\n            (this.data.from !== undefined && typeof this.data.to === 'number')\n          ) {\n            let to = Number(this.data.to);\n            return v < to;\n          }\n          return true;\n        }\n        return false;\n      }\n      // from is empty here\n      if (\n        (this.data.to !== undefined && typeof this.data.to === 'string' && this.data.to.length > 0) ||\n        (this.data.to !== undefined && typeof this.data.to === 'number')\n      ) {\n        let to = Number(this.data.to);\n        return v < to;\n      }\n      // from and to is empty\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Return Formatted value\n   *\n   * @param {*} value\n   * @returns {(string | null)}\n   * @memberof RangeMap\n   */\n  getFormattedText(value: any): string | undefined {\n    if (this.match(value)) {\n      return this.data.text;\n    }\n    return value;\n  }\n\n  /**\n   * Show/enable range\n   *\n   * @memberof RangeMap\n   */\n  show() {\n    this.data.hidden = false;\n  }\n\n  /**\n   * Hide/disable range\n   *\n   * @memberof RangeMap\n   */\n  hide() {\n    this.data.hidden = true;\n  }\n\n  /**\n   * Is hidden\n   *\n   * @returns\n   * @memberof RangeMap\n   */\n  isHidden() {\n    return this.data.hidden;\n  }\n\n  /**\n   * is visible\n   *\n   * @returns\n   * @memberof RangeMap\n   */\n  toVisible() {\n    if (this.data.hidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Export current data\n   *\n   * @returns\n   * @memberof RangeMap\n   */\n  export() {\n    return {\n      from: this.data.from,\n      to: this.data.to,\n      text: this.data.text,\n      hidden: this.data.hidden,\n    };\n  }\n}\n\nclass ValueMap {\n  data: gf.TValueMapData;\n  constructor(value: string, text: string, data: gf.TValueMapData) {\n    this.data = data;\n    this.data.value = value;\n    this.data.text = text;\n    this.data.hidden = false;\n    this.import(data);\n  }\n\n  /**\n   * Get default data\n   *\n   * @static\n   * @returns\n   * @memberof ValueMap\n   */\n  static getDefaultdata() {\n    return {\n      value: undefined,\n      text: undefined,\n      hidden: false,\n    };\n  }\n\n  /**\n   * import data from panel\n   *\n   * @param {*} obj\n   * @returns {this}\n   * @memberof ValueMap\n   */\n  import(obj: any): this {\n    this.data.value = obj.value || this.data.value || undefined;\n    this.data.text = obj.text || this.data.text || undefined;\n    this.data.hidden = obj.hidden || this.data.hidden || false;\n    return this;\n  }\n\n  /**\n   * Match value with datas\n   *\n   * @param {any} value\n   * @returns {boolean}\n   * @memberof ValueMap\n   */\n  match(value: any): boolean {\n    if (value === null || value === undefined) {\n      if (this.data.value === 'null') {\n        return true;\n      }\n      return false;\n    }\n\n    if (!_.isString(value) && Number(this.data.value) === Number(value)) {\n      return true;\n    }\n    return $GF.utils.matchString(value.toString(), this.data.value);\n  }\n\n  /**\n   * Get formatted value\n   *\n   * @param {any} value\n   * @returns\n   * @memberof ValueMap\n   */\n  getFormattedText(value: any): string {\n    if (value === null || value === undefined) {\n      if (this.data.value === 'null' || this.data.value === 'undefined') {\n        return !!this.data.text ? this.data.text : '';\n      }\n    }\n    if (this.match(value)) {\n      return !!this.data.text ? this.data.text : '';\n    }\n    return `${value}`;\n  }\n\n  /**\n   * Show/enable valuemap\n   *\n   * @memberof ValueMap\n   */\n  show() {\n    this.data.hidden = false;\n  }\n\n  /**\n   * Hide/disable valuemap\n   *\n   * @memberof ValueMap\n   */\n  hide() {\n    this.data.hidden = true;\n  }\n\n  /**\n   * Is hidden/disable\n   *\n   * @returns\n   * @memberof ValueMap\n   */\n  isHidden() {\n    return this.data.hidden;\n  }\n\n  /**\n   * export data\n   *\n   * @returns\n   * @memberof ValueMap\n   */\n  export() {\n    return {\n      value: this.data.value,\n      text: this.data.text,\n      hidden: this.data.hidden,\n    };\n  }\n}\n","import { FlowchartHandler } from './flowchartHandler';\nimport { RulesHandler } from 'rulesHandler';\nimport { Rule, EventMap } from 'rule_class';\nimport { $GF } from 'globals_class';\nimport grafana from 'grafana_func';\nimport _ from 'lodash';\nimport { MetricHandler } from './metricHandler';\n\nexport class MappingOptionsCtrl {\n  $scope: gf.TMappingOptionsScope;\n  ctrl: any;\n  panel: any;\n  flowchartHandler: FlowchartHandler;\n  rulesHandler: RulesHandler;\n  metricHandler: MetricHandler;\n  unitFormats: any;\n  style = $GF.CONSTANTS.COLORMETHODS;\n  metricType: gf.TSelectString[] = $GF.CONSTANTS.METRIC_TYPES;\n  colorOn = $GF.CONSTANTS.COLOR_APPLYON;\n  linkOn = $GF.CONSTANTS.LINK_APPLYON;\n  tooltipOn = $GF.CONSTANTS.TOOLTIP_APPLYON;\n  textOn = $GF.CONSTANTS.TEXT_APPLYON;\n  textReplace = $GF.CONSTANTS.TEXTMETHODS;\n  EventType = EventMap.getDefaultMethods();\n  tpDirection: gf.TSelectString[] = $GF.CONSTANTS.TOOLTIP_DIRECTION_TYPES;\n  propTypes: gf.TSelectString[] = $GF.CONSTANTS.IDENT_TYPES;\n  textPattern = '/.*/';\n  metricTypes = $GF.CONSTANTS.VALUE_TYPES;\n  dateFormats: gf.TSelectString[] = $GF.CONSTANTS.VALUE_DATEFORMAT_TYPES;\n  aggregationTypes = $GF.CONSTANTS.AGGREGATION_TYPES;\n  mappingTypes = $GF.CONSTANTS.VALUEMAPPINGTYPES;\n  tpGraphType = $GF.CONSTANTS.TOOLTIP_GRAPH_TYPES;\n  tpGraphScale = $GF.CONSTANTS.TOOLTIP_GRAPH_SCALE_TYPES;\n  tpGraphSize = $GF.CONSTANTS.TOOLTIP_GRAPH_SIZE_TYPES;\n  getMetricNames: () => any[];\n  getCellNames: (prop: gf.TPropertieKey) => any[];\n  getCellNamesById: () => any[];\n  getCellNamesByValue: () => any[];\n  getVariables: () => any;\n  // getEventValues: () => any;\n  getEventValues: string[];\n\n  /** @ngInject */\n  constructor($scope: gf.TMappingOptionsScope) {\n    $scope.editor = this;\n    $scope.$GF = $GF.me();\n    this.$scope = $scope;\n    this.ctrl = $scope.ctrl;\n    this.panel = this.ctrl.panel;\n    this.rulesHandler = this.ctrl.rulesHandler;\n    this.flowchartHandler = this.ctrl.flowchartHandler;\n    this.rulesHandler = this.ctrl.rulesHandler;\n    this.metricHandler = this.ctrl.metricHandler;\n    this.unitFormats = grafana.getUnitFormats();\n    this.tpGraphSize = $GF.CONSTANTS.TOOLTIP_GRAPH_SIZE_TYPES;\n\n    this.getMetricNames = (): string[] => {\n      return this.metricHandler.getNames('serie');\n    };\n\n    this.getCellNames = (prop: gf.TPropertieKey = 'id'): string[] => {\n      const flowchart = this.flowchartHandler.getFlowchart();\n      const cells = flowchart.getNamesByProp(prop);\n      const uniq = new Set(cells);\n      let filter = [...uniq];\n      filter = filter.filter(e => e !== undefined && e.length > 0);\n      return filter;\n    };\n\n    this.getCellNamesById = (): string[] => {\n      return this.getCellNames('id');\n    };\n\n    this.getCellNamesByValue = (): string[] => {\n      return this.getCellNames('value');\n    };\n\n    this.getVariables = () => {\n      return $GF.getFullAvailableVarNames();\n    };\n\n    this.getEventValues = [];\n  }\n\n  isFirstRule(index: number): boolean {\n    if (index === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  isOnlySeries(): boolean {\n    const bool = this.metricHandler.isTypeOf('serie') && !this.metricHandler.isTypeOf('table');\n    return bool;\n  }\n\n  isOnlyTables(): boolean {\n    const bool = !this.metricHandler.isTypeOf('serie') && this.metricHandler.isTypeOf('table');\n    return bool;\n  }\n\n  isMultipleType(): boolean {\n    const bool = this.metricHandler.isTypeOf('serie') && this.metricHandler.isTypeOf('table');\n    return bool;\n  }\n\n  initType(rule: Rule) {\n    if (this.isOnlyTables()) {\n      rule.data.metricType = 'table';\n    } else if (this.isOnlySeries()) {\n      rule.data.metricType = 'serie';\n    }\n  }\n\n  getTablesName(): string[] {\n    return this.metricHandler.getNames('table');\n  }\n\n  getColumnsForTable(tableName: string): string[] {\n    return this.metricHandler.getColumnsName(tableName, 'table');\n  }\n\n  isLastRule(index: number): boolean {\n    const count = this.rulesHandler.countRules();\n    if (index === count - 1) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    this.ctrl.render();\n  }\n\n  setUnitFormat(rule: Rule, subItem: any) {\n    rule.data.unit = subItem.value;\n    this.onRulesChange();\n  }\n\n  onRulesChange() {\n    $GF.log.info('MappingOptionsCtrl.onRulesChange()');\n    this.flowchartHandler.onRulesChange();\n    this.render();\n    return true;\n  }\n\n  getLevels(rule: Rule): gf.TSelectNumber[] {\n    let lvl: gf.TSelectNumber[] = [];\n    let count = rule.data.colors.length;\n    for (let index = 0; index < count; index++) {\n      lvl.push({ text: `${index}`, value: index });\n    }\n    return lvl;\n  }\n\n  removeShapeMap(rule: Rule, index: number) {\n    const shape = rule.getShapeMap(index);\n    this.unselectCell(rule.data.shapeProp, shape.data.pattern);\n    rule.removeShapeMap(index);\n  }\n\n  removeTextMap(rule: Rule, index: number) {\n    const txt = rule.getTextMap(index);\n    this.unselectCell(rule.data.textProp, txt.data.pattern);\n    rule.removeTextMap(index);\n  }\n\n  removeLinkMap(rule: Rule, index: number) {\n    const lnk = rule.getLinkMap(index);\n    this.unselectCell(rule.data.linkProp, lnk.data.pattern);\n    rule.removeLinkMap(index);\n  }\n\n  removeEventMap(rule: Rule, index: number) {\n    const evt = rule.getEventMap(index);\n    this.unselectCell(rule.data.eventProp, evt.data.pattern);\n    rule.removeEventMap(index);\n  }\n\n  /**\n   * Add Color\n   *\n   * @param {Number} ruleIndex\n   * @param {Number} colorIndex\n   * @memberof MappingOptionsCtrl\n   */\n  onColorChange(ruleIndex: number, colorIndex: number) {\n    return (newColor: any) => {\n      const rule = this.rulesHandler.getRule(ruleIndex);\n      rule.data.colors[colorIndex] = newColor;\n      this.onRulesChange();\n    };\n  }\n\n  /**\n   * Display cell selection in graph\n   * @param  {} prop\n   * @param  {} value\n   */\n  async selectCell(prop: gf.TPropertieKey, value: string) {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const xgraph = flowchart.getXGraph();\n    if (xgraph) {\n      xgraph.selectMxCells(prop, value);\n    }\n  }\n\n  /**\n   * Undisplay cell selection\n   *\n   * @memberof MappingOptionsCtrl\n   */\n  async unselectCell(prop: gf.TPropertieKey, value: string) {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const xgraph = flowchart.getXGraph();\n    if (xgraph) {\n      xgraph.unselectMxCells(prop, value);\n    }\n  }\n\n  /**\n   * Disable/Enable rule\n   *\n   * @param {Rule} rule\n   * @param {boolean} bool\n   * @memberof MappingOptionsCtrl\n   */\n  toggleShow(rule: Rule, bool: boolean) {\n    rule.data.hidden = bool;\n    this.onRulesChange();\n  }\n\n  /**\n   * Turn Highlight on of cells in rule\n   *\n   * @param {*} rule\n   * @memberof MappingOptionsCtrl\n   */\n  async highlightCells(rule: Rule) {\n    rule.highlightCells();\n  }\n\n  /**\n   * Turn Highlight off of cells in rule\n   *\n   * @param {*} rule\n   * @memberof MappingOptionsCtrl\n   */\n  async unhighlightCells(rule: Rule) {\n    rule.unhighlightCells();\n  }\n\n  /**\n   * Turn Highlight off all cells\n   *\n   * @param {*} rule\n   * @memberof MappingOptionsCtrl\n   */\n  async unhighlightAllCells() {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const xgraph = flowchart.getXGraph();\n    if (xgraph) {\n      xgraph.unhighlightCells();\n    }\n  }\n\n  //\n  // RULE\n  //\n\n  /**\n   * Remove a rule\n   *\n   * @param {Rule} rule\n   * @param {boolean} [force]\n   * @memberof MappingOptionsCtrl\n   */\n  removeRule(rule: Rule, force?: boolean) {\n    if (rule.removeClick === 1 || force) {\n      this.rulesHandler.removeRule(rule);\n      this.onRulesChange();\n    }\n    rule.removeClick = 1;\n    window.setInterval(() => {\n      if (rule) {\n        rule.removeClick = 2;\n      }\n    }, 2000);\n  }\n\n  /**\n   * Clone a rule\n   *\n   * @param {Rule} rule\n   * @memberof MappingOptionsCtrl\n   */\n  cloneRule(rule: Rule) {\n    this.rulesHandler.cloneRule(rule);\n    this.onRulesChange();\n  }\n\n  /**\n   * Move rule up or down\n   *\n   * @param {Rule} rule\n   * @param {boolean} up\n   * @memberof MappingOptionsCtrl\n   */\n  moveRule(rule: Rule, up: boolean) {\n    if (up) {\n      this.rulesHandler.moveRuleToUp(rule);\n    } else {\n      this.rulesHandler.moveRuleToDown(rule);\n    }\n    this.onRulesChange();\n  }\n\n  //\n  // Events\n  //\n  onEventValue(event: EventMap) {\n    this.getEventValues = event.getTypeahead();\n  }\n}\n\n/** @ngInject */\nexport function mappingOptionsTab($q, uiSegmentSrv) {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: `${$GF.plugin.getPartialPath()}/mapping/index.html`,\n    controller: MappingOptionsCtrl,\n  };\n}\n","import _ from 'lodash';\nimport { $GF } from 'globals_class';\nimport * as Drawio from 'drawio_custom';\nimport chroma from 'chroma-js';\nimport { customize, evalCode } from 'mxgraph_custom';\n\ndeclare var mxEvent: any;\ndeclare var mxClient: any;\ndeclare var mxCodec: any;\ndeclare var mxUrlConverter: any;\ndeclare var mxCellOverlay: any;\ndeclare var mxConstants: any;\ndeclare var mxCellHighlight: any;\ndeclare var mxRectangle: any;\ndeclare var mxUtils: any;\ndeclare var Graph: any;\ndeclare var mxTooltipHandler: any;\n\n/**\n * mxGraph interface class\n *\n * @export\n * @class XGraph\n */\nexport default class XGraph {\n  static initialized = false;\n  container: HTMLDivElement;\n  xmlGraph = '';\n  csvGraph = '';\n  type: gf.TSourceTypeKeys = 'xml';\n  graph: any = undefined;\n  scale = true;\n  tooltip = true;\n  lock = true;\n  center = true;\n  animation = true;\n  zoom = false;\n  zoomFactor = 1.2;\n  cumulativeZoomFactor = 1;\n  grid = false;\n  bgColor: string | null = null;\n  zoomPercent = '1';\n  cells: { id: string[]; value: string[] } = {\n    id: [],\n    value: [],\n  };\n  clickBackup: any;\n  dbclickBackup: any;\n  onMapping: gf.TIOnMappingObj;\n  /**\n   * Creates an instance of XGraph.\n   * @param {DOM} container\n   * @param {string} definition\n   * @memberof XGraph\n   */\n  constructor(container: HTMLDivElement, type: gf.TSourceTypeKeys, definition: string) {\n    this.container = container;\n    this.type = type;\n    this.onMapping = {\n      active: false,\n      $scope: null,\n      value: null,\n      prop: 'id',\n      object: null,\n    };\n\n    // END ZOOM MouseWheele\n    XGraph.initMxGraph();\n    if (type === 'xml') {\n      if ($GF.utils.isencoded(definition)) {\n        this.xmlGraph = $GF.utils.decode(definition, true, true, true);\n      } else {\n        this.xmlGraph = definition;\n      }\n    }\n    if (type === 'csv') {\n      this.csvGraph = definition;\n    }\n    this.initGraph();\n    const self = this;\n    if ($GF.DEBUG) {\n      console.log('DEBUG ON');\n      this.graph.addListener(mxEvent.CLICK, (_sender, _evt) => {\n        console.log('DEBUG CLICK');\n        this.eventDebug(_evt);\n        if (_evt.properties.cell) {\n          const id = _evt.properties.cell.id;\n          const state = $GF.getVar(`STATE_${id}`);\n          console.log('DEBUG GF STATE', state);\n          const view = self.graph.view;\n          console.log('DEBUG CELL STATE', view.getState(_evt.properties.cell));\n        }\n      });\n    }\n  }\n\n  /**\n   * Valided XML definition\n   *\n   * @static\n   * @param {string} source\n   * @returns\n   * @memberof XGraph\n   */\n  static isValidXml(source: string) {\n    try {\n      const div = document.createElement('div');\n      const g = new Graph(div);\n      if ($GF.utils.isencoded(source)) {\n        source = $GF.utils.decode(source, true, true, true);\n      }\n      const xmlDoc = mxUtils.parseXml(source);\n      const codec = new mxCodec(xmlDoc);\n      g.getModel().beginUpdate();\n      codec.decode(xmlDoc.documentElement, g.getModel());\n      g.getModel().endUpdate();\n      g.destroy();\n      return true;\n    } catch (error) {\n      $GF.log.error('isValidXml', error);\n      return false;\n    }\n  }\n\n  /**\n   * Anonymize Graph\n   *\n   * @memberof XGraph\n   */\n  async anonymize() {\n    Drawio.anonymize(this.graph);\n  }\n\n  /**\n   * Init Global vars an libs for mxgraph\n   *\n   * @static\n   * @returns\n   * @memberof XGraph\n   */\n  static async initMxGraph() {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initMxGgraph()');\n    let myWindow: any = window;\n    if (!XGraph.initialized) {\n      if (myWindow.mxGraph === undefined || myWindow.mxGraph === undefined) {\n        XGraph.preInitGlobalVars();\n        // let code = $GF.utils.$loadFile(`${$GF.plugin.getDrawioPath()}js/viewer.min.js`);\n        // $GF.utils.evalRaw(code);\n        // $GF.utils.$evalFile(`${$GF.plugin.getDrawioPath()}js/viewer.min.js`);\n        evalCode();\n        customize();\n        XGraph.postInitGlobalVars();\n        // let code = $GF.utils.$loadFile(`${$GF.plugin.getLibsPath()}/Graph_custom.js`);\n        // $GF.utils.evalRaw(code);\n        mxTooltipHandler.prototype.delay = $GF.CONSTANTS.CONF_TOOLTIPS_DELAY;\n      }\n      XGraph.initialized = true;\n    }\n    trc.after();\n  }\n\n  /**\n   * Init Vars for mxGraph\n   *\n   * @static\n   * @memberof XGraph\n   */\n  static preInitGlobalVars() {\n    const myWindow: any = window;\n    myWindow.BASE_PATH = $GF.plugin.getMxBasePath();\n    myWindow.RESOURCES_PATH = $GF.plugin.getMxResourcePath();\n    myWindow.RESOURCE_BASE = $GF.plugin.getMxResourcePath();\n    myWindow.STENCIL_PATH = $GF.plugin.getStencilsPath();\n    myWindow.SHAPES_PATH = $GF.plugin.getShapesPath();\n    myWindow.IMAGE_PATH = $GF.plugin.getMxImagePath();\n    myWindow.STYLE_PATH = $GF.plugin.getMxStylePath();\n    myWindow.CSS_PATH = $GF.plugin.getMxCssPath();\n    myWindow.mxLanguages = ['en'];\n    myWindow.DRAWIO_BASE_URL = $GF.plugin.getDrawioPath(); // Replace with path to base of deployment, e.g. https://www.example.com/folder\n    myWindow.DRAW_MATH_URL = $GF.plugin.getDrawioPath(); // Replace with path to base of deployment, e.g. https://www.example.com/folder\n    myWindow.DRAWIO_VIEWER_URL = $GF.plugin.getDrawioPath() + 'viewer.min.js'; // Replace your path to the viewer js, e.g. https://www.example.com/js/viewer.min.js\n    myWindow.DRAW_MATH_URL = $GF.plugin.getDrawioPath() + 'math/';\n    myWindow.DRAWIO_CONFIG = null; // Replace with your custom draw.io configurations. For more details, https://desk.draw.io/support/solutions/articles/16000058316\n    const urlParams = new Object();\n    myWindow.urlParams = urlParams;\n    urlParams['sync'] = 'none'; // Disabled realtime\n    urlParams['lightbox'] = '1'; // Uses lightbox in chromeless mode (larger zoom, no page visible, chromeless)\n    urlParams['nav'] = '1'; // Enables folding in chromeless mode\n    urlParams['local'] = '1'; // Uses device mode only\n    urlParams['embed'] = '1'; // Runs in embed mode\n    // const theme = $GF.getTheme();\n    // switch (theme) {\n    //   case 'dark':\n    //     urlParams['ui'] = 'dark';\n    //     break;\n\n    //   case 'light':\n    //     urlParams['ui'] = 'kennedy';\n    //     break;\n\n    //   default:\n    //     urlParams['ui'] = 'dark';\n    //     break;\n    // }\n    urlParams['ui'] = 'min';\n    myWindow.mxImageBasePath = $GF.plugin.getMxImagePath();\n    myWindow.mxBasePath = $GF.plugin.getMxBasePath();\n    myWindow.mxLoadStylesheets = true;\n    myWindow.mxLanguage = 'en';\n    myWindow.mxLoadResources = true;\n  }\n\n  static postInitGlobalVars() {\n    const myWindow: any = window;\n    myWindow.mxClient.mxBasePath = $GF.plugin.getMxBasePath();\n    myWindow.mxClient.mxImageBasePath = $GF.plugin.getMxImagePath();\n    myWindow.mxClient.mxLoadResources = true;\n    myWindow.mxClient.mxLanguage = 'en';\n    myWindow.mxClient.mxLoadStylesheets = true;\n    myWindow.VSD_CONVERT_URL = null;\n    myWindow.EMF_CONVERT_URL = null;\n    myWindow.ICONSEARCH_PATH = null;\n  }\n\n  /**\n   * Graph initilisation and reset\n   *\n   * @memberof XGraph\n   */\n  initGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initGraph()');\n    this.graph = new Graph(this.container);\n\n    // /!\\ What is setPannig\n    this.graph.setPanning(true);\n\n    // Backup funtions of clicks\n    this.clickBackup = this.graph.click;\n    this.dbclickBackup = this.graph.dblClick;\n\n    // EVENTS\n\n    // CTRL+MOUSEWHEEL\n    mxEvent.addMouseWheelListener(mxUtils.bind(this, this.eventMouseWheel), this.container);\n    if (mxClient.IS_IE || mxClient.IS_EDGE) {\n      mxEvent.addListener(this.container, 'wheel', mxUtils.bind(this, this.eventMouseWheel));\n    }\n\n    // KEYS\n    mxEvent.addListener(document, 'keydown', mxUtils.bind(this, this.eventKey));\n\n    // CONTEXT MENU\n    this.container.addEventListener('contextmenu', e => e.preventDefault());\n\n    // DB CLICK\n    this.graph.dblClick = this.eventDbClick.bind(this);\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Draw graph\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  drawGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'drawGraph()');\n    this.graph.getModel().beginUpdate();\n    this.graph.getModel().clear();\n    try {\n      if (this.type === 'xml') {\n        const xmlDoc = mxUtils.parseXml(this.xmlGraph);\n        const codec = new mxCodec(xmlDoc);\n        this.graph.model.clear();\n        this.graph.view.scale = 1;\n        codec.decode(xmlDoc.documentElement, this.graph.getModel());\n        this.loadExtFont();\n        this.graph.updateCssTransform();\n        this.graph.selectUnlockedLayer();\n      }\n      if (this.type === 'csv') {\n        try {\n          Drawio.importCsv(this.graph, this.csvGraph);\n          this.refresh();\n        } catch (error) {\n          $GF.log.error('Bad CSV format', error);\n          $GF.message.setMessage('Bad CSV format');\n        }\n      }\n    } catch (error) {\n      $GF.log.error('Error in draw', error);\n    } finally {\n      this.cells['id'] = this.getCurrentCells('id');\n      this.cells['value'] = this.getCurrentCells('value');\n      this.graph.getModel().endUpdate();\n    }\n    trc.after();\n    return this;\n  }\n\n  async loadExtFont() {\n    const model = this.graph.getModel();\n    let extFonts = model.extFonts;\n    if (extFonts) {\n      try {\n        extFonts = extFonts.split('|').map(function(ef) {\n          var parts = ef.split('^');\n          return { name: parts[0], url: parts[1] };\n        });\n\n        for (var i = 0; i < extFonts.length; i++) {\n          // Drawio.addExtFont(extFonts[i].name, extFonts[i].url);\n          this.graph.addExtFont(extFonts[i].name, extFonts[i].url);\n        }\n      } catch (e) {\n        $GF.log.error('ExtFonts format error:', e.message);\n      }\n    }\n  }\n\n  /**\n   * Apply options on graph\n   *\n   * @return this\n   * @memberof XGraph\n   */\n  applyGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyGraph()');\n    if (!this.scale) {\n      this.zoomGraph(this.zoomPercent);\n    } else {\n      this.unzoomGraph();\n    }\n    this.tooltipGraph(this.tooltip);\n    this.lockGraph(this.lock);\n    if (this.scale && this.center) {\n      this.fitGraph();\n    } else {\n      this.scaleGraph(this.scale);\n      this.centerGraph(this.center);\n    }\n    this.gridGraph(this.grid);\n    this.bgGraph(this.bgColor);\n    this.graph.foldingEnabled = true;\n    this.graph.cellRenderer.forceControlClickHandler = true;\n    this.refresh();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Refresh graph\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  refresh(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'refresh()');\n    this.graph.refresh();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Destroy Graph object and DOM\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  destroyGraph(): this {\n    this.graph.destroy();\n    this.graph = undefined;\n    return this;\n  }\n\n  /**\n   * lock cells\n   *\n   * @returns {this}\n   * @param {Boolean} bool\n   * @memberof XGraph\n   */\n  lockGraph(bool: boolean): this {\n    if (bool) {\n      this.graph.setEnabled(false);\n    } else {\n      this.graph.setEnabled(true);\n    }\n    this.lock = bool;\n    return this;\n  }\n\n  /**\n   * Enable tooltip\n   *\n   * @returns {this}\n   * @param {Boolean} bool\n   * @memberof XGraph\n   */\n  tooltipGraph(bool: boolean): this {\n    if (bool) {\n      this.graph.setTooltips(true);\n    } else {\n      this.graph.setTooltips(false);\n    }\n    this.tooltip = bool;\n    return this;\n  }\n\n  /**\n   * Allow downloads images from site draw.io\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof XGraph\n   */\n  allowDrawio(bool: boolean): this {\n    if (bool) {\n      mxUrlConverter.prototype.baseUrl = 'http://draw.io/';\n      mxUrlConverter.prototype.baseDomain = '';\n    } else {\n      mxUrlConverter.prototype.baseUrl = null;\n      mxUrlConverter.prototype.baseDomain = null;\n    }\n    return this;\n  }\n\n  enableAnim(bool: boolean): this {\n    this.animation = bool;\n    return this;\n  }\n\n  /**\n   * Center graph in panel\n   *\n   * @returns {this}\n   * @param {Boolean} bool\n   * @memberof XGraph\n   */\n  centerGraph(bool: boolean): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'centerGraph()');\n    this.graph.centerZoom = false;\n    if (bool) {\n      this.graph.center(true, true);\n    } else {\n      this.graph.center(false, false);\n    }\n    this.center = bool;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Scale graph in panel\n   *\n   * @returns {this}\n   * @param {boolean} bool\n   * @memberof XGraph\n   */\n  scaleGraph(bool: boolean): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'scaleGraph()');\n    if (bool) {\n      this.unzoomGraph();\n      this.graph.fit();\n      this.graph.view.rendering = true;\n    }\n    this.scale = bool;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Scale graph into container\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  fitGraph(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'fitGraph()');\n    const margin = 2;\n    const max = 3;\n\n    const bounds = this.graph.getGraphBounds();\n    const cw = this.graph.container.clientWidth - margin;\n    const ch = this.graph.container.clientHeight - margin;\n    const w = bounds.width / this.graph.view.scale;\n    const h = bounds.height / this.graph.view.scale;\n    const s = Math.min(max, Math.min(cw / w, ch / h));\n\n    this.graph.view.scaleAndTranslate(\n      s,\n      (margin + cw - w * s) / (2 * s) - bounds.x / this.graph.view.scale,\n      (margin + ch - h * s) / (2 * s) - bounds.y / this.graph.view.scale\n    );\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Display grid in panel\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof XGraph\n   */\n  gridGraph(bool: boolean): this {\n    if (bool) {\n      this.container.style.backgroundImage =\n        \"url('data:image/gif;base64,R0lGODlhCgAKAJEAAAAAAP///8zMzP///yH5BAEAAAMALAAAAAAKAAoAAAIJ1I6py+0Po2wFADs=')\";\n    } else {\n      this.container.style.backgroundImage = '';\n    }\n    this.grid = bool;\n    return this;\n  }\n\n  /**\n   * Zoom/unzoom\n   *\n   * @param {string} percent\n   * @returns {this}\n   * @memberof XGraph\n   */\n  zoomGraph(percent: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'zoomGraph()');\n    if (!this.scale && percent && percent.length > 0 && percent !== '100%' && percent !== '0%') {\n      const ratio: number = Number(percent.replace('%', '')) / 100;\n      this.graph.zoomTo(ratio, true);\n      this.zoomPercent = percent;\n    } else {\n      this.unzoomGraph();\n    }\n    this.zoom = true;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Restore initial size\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  unzoomGraph(): this {\n    this.zoom = false;\n    this.graph.zoomActual();\n    return this;\n  }\n\n  /**\n   * Define background color\n   *\n   * @param {this} bgColor\n   * @memberof XGraph\n   */\n  bgGraph(bgColor): this {\n    const $div = $(this.container);\n    if (bgColor) {\n      this.bgColor = bgColor;\n      $div.css('background-color', bgColor);\n    } else {\n      $div.css('background-color', '');\n    }\n    return this;\n  }\n\n  /**\n   * Return mxgraph object\n   *\n   * @returns\n   * @memberof XGraph\n   */\n  getMxGraph() {\n    return this.graph;\n  }\n\n  /**\n   * Return xml definition\n   *\n   * @returns {string}\n   * @memberof XGraph\n   */\n  getxmlGraph(): string {\n    return this.xmlGraph;\n  }\n\n  /**\n   * Assign source definition and redraw graph\n   *\n   * @param {string} xmlGraph\n   * @returns {this}\n   * @memberof XGraph\n   */\n  setContent(content: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setContent()');\n    if (this.type === 'xml') {\n      if ($GF.utils.isencoded(content)) {\n        this.xmlGraph = $GF.utils.decode(content, true, true, true);\n      } else {\n        this.xmlGraph = content;\n      }\n    }\n    if (this.type === 'csv') {\n      this.csvGraph = content;\n    }\n    this.drawGraph();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Get list of values or id\n   *\n   * @param { gf.TPropertieKey} prop\n   * @returns {string[]}\n   * @memberof XGraph\n   */\n  getCurrentCells(prop: gf.TPropertieKey): string[] {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getCurrentCells()');\n    const cellIds: string[] = [];\n    const model = this.graph.getModel();\n    const cells = model.cells;\n    if (prop === 'id') {\n      _.each(cells, (mxcell: mxCell) => {\n        cellIds.push(this.getId(mxcell));\n      });\n    } else if (prop === 'value') {\n      _.each(cells, (mxcell: mxCell) => {\n        cellIds.push(this.getLabelCell(mxcell));\n      });\n    }\n    trc.after();\n    return cellIds;\n  }\n\n  /**\n   * Get list of mxCell\n   *\n   * @param {string} prop - id|value\n   * @param {string} pattern - regex like or string\n   * @returns {mxCell[]}\n   * @memberof XGraph\n   */\n  findMxCells(prop: gf.TPropertieKey, pattern: string): mxCell[] {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'findMxCells()');\n    const mxcells = this.getMxCells();\n    const result: any[] = [];\n    if (prop === 'id') {\n      _.each(mxcells, (mxcell: mxCell) => {\n        if ($GF.utils.matchString(mxcell.id, pattern)) {\n          result.push(mxcell);\n        }\n      });\n    } else if (prop === 'value') {\n      _.each(mxcells, (mxcell: mxCell) => {\n        if ($GF.utils.matchString(this.getLabelCell(mxcell), pattern)) {\n          result.push(mxcell);\n        }\n      });\n    }\n    trc.after();\n    return result;\n  }\n\n  /**\n   * Select cells in graph with pattern for id or value\n   *\n   * @param {string} prop - \"id\"|\"value\"\n   * @param {string} pattern - regex like\n   * @memberof XGraph\n   */\n  async selectMxCells(prop: gf.TPropertieKey, pattern: string) {\n    const mxcells = this.findMxCells(prop, pattern);\n    if (mxcells) {\n      this.highlightCells(mxcells);\n    }\n  }\n\n  /**\n   * Unselect cells\n   *\n   * @returns {this}\n   * @memberof XGraph\n   */\n  async unselectMxCells(prop: gf.TPropertieKey, pattern: string) {\n    const mxcells = this.findMxCells(prop, pattern);\n    if (mxcells) {\n      this.unhighlightCells(mxcells);\n    }\n  }\n\n  /**\n   * Create tooltip on image\n   *\n   * @param {*} image\n   * @param {*} tooltip\n   * @returns {mxCellOverlay}\n   * @memberof XGraph\n   */\n  createOverlay(image, tooltip): any {\n    const overlay = new mxCellOverlay(image, tooltip);\n    overlay.addListener(mxEvent.CLICK, (_sender, _evt) => {\n      mxUtils.alert(`${tooltip}\\nLast update: ${new Date()}`);\n    });\n    return overlay;\n  }\n\n  /**\n   * Add Warning icon\n   *\n   * @param {string} state (OK|WARN|ERROR)\n   * @param {mxCell} mxcell\n   * @returns {this}\n   * @memberof XGraph\n   */\n  addOverlay(state: string, mxcell: mxCell) {\n    this.graph.addCellOverlay(mxcell, this.createOverlay(this.graph.warningImage, `State: ${state}`));\n    return this;\n  }\n\n  /**\n   * Remove Warning icon\n   *\n   * @param {mxCell} mxcell\n   * @returns {this}\n   * @memberof XGraph\n   */\n  removeOverlay(mxcell: mxCell): this {\n    this.graph.removeCellOverlays(mxcell);\n    return this;\n  }\n\n  /**\n   * Add link to cell\n   *\n   * @param {mxCell} mxcell\n   * @param {string} link - Url\n   * @returns {this}\n   * @memberof XGraph\n   */\n  addLink(mxcell: mxCell, link): this {\n    this.graph.setLinkForCell(mxcell, link);\n    return this;\n  }\n\n  /**\n   * Get link from cell\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  getLink(mxcell: mxCell): string | null {\n    return this.graph.getLinkForCell(mxcell);\n  }\n\n  /**\n   * Remove link of cell\n   *\n   * @param {mxCell} mxcell\n   * @returns {this}\n   * @memberof XGraph\n   */\n  removeLink(mxcell: mxCell): this {\n    this.graph.setLinkForCell(mxcell, null);\n    return this;\n  }\n\n  /**\n   * Get value or id from cell source\n   *\n   * @param { gf.TPropertieKey} prop\n   * @returns {string[]} value of labels or id frome source\n   * @memberof XGraph\n   */\n  getOrignalCells(prop: gf.TPropertieKey): string[] {\n    if (prop === 'id' || prop === 'value') {\n      return this.cells[prop];\n    }\n    // TODO: attributs\n    return [];\n  }\n\n  /**\n   * Rename Id of cell\n   * Must be uniq\n   * @param {string} oldId\n   * @param {string} newId\n   * @returns {this} XGraph\n   * @memberof XGraph\n   */\n  renameId(oldId: string, newId: string): this {\n    const cells = this.findMxCells('id', oldId);\n    if (cells !== undefined && cells.length > 0) {\n      cells.forEach(cell => {\n        cell.id = newId;\n      });\n    } else {\n      $GF.log.warn(`Cell ${oldId} not found`);\n    }\n    return this;\n  }\n\n  /**\n   * Get xml definition from current graph\n   *\n   * @returns\n   * @memberof XGraph\n   */\n  getXmlModel() {\n    const encoder = new mxCodec();\n    const node = encoder.encode(this.graph.getModel());\n    return mxUtils.getXml(node);\n  }\n\n  /**\n   * Return all cells\n   *\n   * @returns {Map<mxCell>} mxCells\n   * @memberof XGraph\n   */\n  getMxCells(): any {\n    return this.graph.getModel().cells;\n  }\n\n  /**\n   * Return value of id or value of mxcell\n   *\n   * @param {string} prop - \"id\"|\"value\"\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  getValuePropOfMxCell(prop: gf.TPropertieKey, mxcell: mxCell): string | null {\n    if (prop === 'id') {\n      return this.getId(mxcell);\n    }\n    if (prop === 'value') {\n      return this.getLabelCell(mxcell);\n    }\n    return null;\n  }\n\n  getStyleCell(mxcell: mxCell, style: any): string | null {\n    const state = this.graph.view.getState(mxcell);\n    if (state) {\n      return state.style[style];\n    }\n    return null;\n  }\n\n  isAnimated() {\n    return this.animation;\n  }\n\n  /**\n   * Apply color style on Cell\n   *\n   * @param {mxCell} mxcell\n   * @param {gf.TStyleColor.Keys} style\n   * @param {(string | null)} color\n   * @param {boolean} [animate=false]\n   * @returns {this}\n   * @memberof XGraph\n   */\n  // setColorAnimCell(mxcell: mxCell, style: gf.TStyleColorKeys, color: string | null): this {\n  //   const trc = $GF.trace.before(this.constructor.name + '.' + 'setColorAnimCell()');\n  //   if (this.isAnimated() && color) {\n  //     try {\n  //       const startColor = this.getStyleCell(mxcell, style);\n  //       if (startColor) {\n  //         const endColor = color;\n  //         const steps = chroma\n  //           .scale([startColor, endColor])\n  //           .mode('lrgb')\n  //           .colors($GF.CONSTANTS.CONF_COLORS_STEPS + 1);\n  //         const count = 1;\n  //         const self = this;\n  //         const lg = steps.length;\n  //         function graduate(count, steps) {\n  //           if (count < lg) {\n  //             self.setStyleCell(mxcell, style, steps[count]);\n  //             window.setTimeout(() => {\n  //               graduate(count + 1, steps);\n  //             }, $GF.CONSTANTS.CONF_COLORS_MS);\n  //           }\n  //         }\n  //         graduate(count, steps);\n  //       } else {\n  //         // let hex = Color(color).hex();\n  //         let hex = chroma(color).hex();\n  //         this.setStyleCell(mxcell, style, hex);\n  //       }\n  //     } catch (error) {\n  //       $GF.log.error('Error on graduate color', error);\n  //       this.setStyleCell(mxcell, style, color);\n  //     }\n  //   } else {\n  //     if (color !== null) {\n  //       try {\n  //         color = chroma(color).hex();\n  //       } catch (error) {\n  //         $GF.log.error('Invalid Color', color);\n  //       }\n  //     }\n  //     this.setStyleCell(mxcell, style, color);\n  //   }\n  //   trc.after();\n  //   return this;\n  // }\n  setColorAnimCell(mxcell: mxCell, style: gf.TStyleColorKeys, color: string | null): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setColorAnimCell()');\n    const id = `${style}_${mxcell.id}`;\n    // Cancel Previous anim\n    $GF.clearUniqTimeOut(id);\n    if (this.isAnimated() && color) {\n      try {\n        const startColor = this.getStyleCell(mxcell, style);\n        if (startColor) {\n          const endColor = color;\n          const steps = chroma\n            .scale([startColor, endColor])\n            .mode('lrgb')\n            .colors($GF.CONSTANTS.CONF_COLORS_STEPS + 1);\n          let count = 1;\n          const self = this;\n          const lg = steps.length;\n          function graduate() {\n            if (count < lg) {\n              self.setStyleCell(mxcell, style, steps[count]);\n              count += 1;\n              $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_COLORS_MS, id);\n            } else {\n              $GF.clearUniqTimeOut(id);\n            }\n          }\n          graduate();\n        } else {\n          // let hex = Color(color).hex();\n          let hex = chroma(color).hex();\n          this.setStyleCell(mxcell, style, hex);\n        }\n      } catch (error) {\n        $GF.log.error('Error on graduate color', error);\n        this.setStyleCell(mxcell, style, color);\n      }\n    } else {\n      if (color !== null) {\n        try {\n          color = chroma(color).hex();\n        } catch (error) {\n          $GF.log.error('Invalid Color', color);\n        }\n      }\n      this.setStyleCell(mxcell, style, color);\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Change or apply style\n   *\n   * @param {mxCell} mxcell\n   * @param {gf.TStyleColor.Keys} style\n   * @param {(string | null)} value\n   * @returns {this}\n   * @memberof XGraph\n   */\n  setStyleCell(mxcell: mxCell, style: any, value: string | null): this {\n    this.graph.setCellStyles(style, value, [mxcell]);\n    return this;\n  }\n\n  /**\n   * Change style with steps to anime\n   *\n   * @param {mxCell} mxcell\n   * @param {*} style\n   * @param {(string | null)} endValue\n   * @param {string} [beginValue]\n   * @memberof XGraph\n   */\n  async setStyleAnimCell(mxcell: mxCell, style: any, endValue: string | null, beginValue?: string) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setStyleAnimCell()');\n    if (this.isAnimated() && endValue !== null) {\n      try {\n        const end = Number(endValue);\n        const begin = beginValue !== undefined ? Number(beginValue) : Number(this.getStyleCell(mxcell, style));\n        if (end !== begin) {\n          const id = `${style}_${mxcell.id}`;\n          // Cancel Previous anim\n          $GF.clearUniqTimeOut(id);\n          const steps = $GF.getIntervalCounter(begin, end, $GF.CONSTANTS.CONF_ANIMS_STEP);\n          const lg = steps.length;\n          let count = 0;\n          const self = this;\n          function graduate() {\n            if (count < lg) {\n              self.setStyleCell(mxcell, style, steps[count].toString());\n              count += 1;\n              $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_ANIMS_MS, id);\n            } else {\n              $GF.clearUniqTimeOut(id);\n            }\n          }\n          graduate();\n        }\n      } catch (error) {\n        this.graph.setCellStyles(style, endValue, [mxcell]);\n      }\n    } else {\n      this.graph.setCellStyles(style, endValue, [mxcell]);\n    }\n    trc.after();\n  }\n\n  /**\n   * Apply the styles to mxcell\n   *\n   * @param {mxCell} mxcell\n   * @param {string} styles\n   * @memberof XGraph\n   */\n  setStyles(mxcell: mxCell, styles: string): this {\n    this.graph.getModel().setStyle(mxcell, styles);\n    return this;\n  }\n\n  setClassCell(mxcell: mxCell, className: string): this {\n    var state = this.graph.view.getState(mxcell);\n    if (state && state.shape !== null) {\n      const paths = state.shape.node.getElementsByTagName('path');\n      if (paths.length > 1) {\n        let currentClass: string = paths[1].getAttribute('class');\n        let classes: string[] = [];\n        if (currentClass !== null && currentClass !== undefined) {\n          classes = currentClass.split(' ');\n        }\n        if (!classes.includes(className)) {\n          classes.push(className);\n          currentClass = classes.join(' ');\n          paths[1].setAttribute('class', currentClass);\n          if (mxUtils.getValue(state.style, mxConstants.STYLE_DASHED, '0') !== '1') {\n            paths[1].setAttribute('stroke-dasharray', '8');\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  unsetClassCell(mxcell: mxCell, className: string): this {\n    var state = this.graph.view.getState(mxcell);\n    if (state && state.shape !== null) {\n      const paths = state.shape.node.getElementsByTagName('path');\n      if (paths.length > 1) {\n        let currentClass: string = paths[1].getAttribute('class');\n        let classes: string[] = [];\n        if (currentClass !== null && currentClass !== undefined) {\n          classes = currentClass.split(' ');\n        }\n        if (classes.includes(className)) {\n          classes = classes.filter(c => c !== className);\n          if (classes.length > 1) {\n            currentClass = classes.join(' ');\n            paths[1].setAttribute('class', currentClass);\n          } else {\n            paths[1].removeAttribute('class');\n          }\n          if (mxUtils.getValue(state.style, mxConstants.STYLE_DASHED, '0') !== '1') {\n            paths[1].removeAttribute('stroke-dasharray');\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Return Label/value of mxcell\n   *\n   * @param {mxCell} mxcell\n   * @returns {string} Label of current cell\n   * @memberof XGraph\n   */\n  getLabelCell(mxcell: mxCell): string {\n    if (mxUtils.isNode(mxcell.value)) {\n      return mxcell.value.getAttribute('label');\n    }\n    return mxcell.getValue(mxcell);\n  }\n\n  /**\n   * Assign new label for mxcell\n   *\n   * @param {mxCell} mxcell\n   * @param {string} text - New label\n   * @returns {this}\n   * @memberof XGraph\n   */\n  setLabelCell(mxcell: mxCell, text: string): this {\n    this.graph.cellLabelChanged(mxcell, text, false);\n    return this;\n  }\n\n  /**\n   * Return Id of mxCell\n   *\n   * @param {mxCell} mxcell\n   * @returns {string} Id of mxCell\n   * @memberof XGraph\n   */\n  getId(mxcell): string {\n    return mxcell.getId();\n  }\n\n  /**\n   * Active mapping option when user click on mapping\n   *\n   * @param {Object} onMappingObj\n   * @memberof XGraph\n   */\n  setMap(onMappingObj: gf.TIOnMappingObj) {\n    $GF.log.info('XGraph.setMapping()');\n    this.onMapping = onMappingObj;\n    if (this.onMapping.active === true) {\n      this.container.style.cursor = 'crosshair';\n      this.graph.click = this.eventClick.bind(this);\n    }\n  }\n\n  /**\n   * Disable mapping when user click on mapping\n   *\n   * @memberof XGraph\n   */\n  unsetMap() {\n    $GF.log.info('XGraph.unsetMapping()');\n    this.onMapping.active = false;\n    this.container.style.cursor = 'auto';\n    this.graph.click = this.clickBackup;\n    if (this.onMapping.$scope) {\n      this.onMapping.$scope.$applyAsync();\n    }\n  }\n\n  //\n  // GRAPH HANDLER\n  //\n\n  /**\n   * Event for click on graph\n   *\n   * @param {MouseEvent} me\n   * @memberof XGraph\n   */\n  eventClick(me: mxMouseEvent) {\n    if (this.onMapping.active) {\n      const state = me.getState();\n      if (state) {\n        const prop = this.onMapping.prop !== null ? this.onMapping.prop : 'id';\n        const value = this.getValuePropOfMxCell(prop, state.cell);\n        if (this.onMapping.object) {\n          this.onMapping.object.data.pattern = value;\n        }\n        if (this.onMapping.value) {\n          const elt = document.getElementById(this.onMapping.value);\n          if (elt) {\n            setTimeout(() => {\n              elt.focus();\n            }, 100);\n          }\n        }\n        this.unsetMap();\n      }\n    }\n  }\n\n  eventDebug(me: mxMouseEvent) {\n    console.log('DEBUG mxMouseEvent', me);\n    // const state = me.getState();\n    // if (state) {\n    //   console.log(\"DEBUG state\",state);\n    // }\n  }\n\n  /**\n   * Event for double click on graph\n   *\n   * @param {MouseEvent} evt\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  eventDbClick(evt: MouseEvent, mxcell: mxCell) {\n    if (mxcell !== undefined) {\n      this.lazyZoomCell(mxcell);\n    }\n  }\n\n  /**\n   * Event for mouse wheel on graph\n   *\n   * @param {Event} evt\n   * @param {boolean} up\n   * @memberof XGraph\n   */\n  eventMouseWheel(evt: WheelEvent, up: boolean) {\n    if (this.graph.isZoomWheelEvent(evt)) {\n      if (up === null || up === undefined) {\n        if (evt.deltaY < 0) {\n          up = true;\n        } else {\n          up = false;\n        }\n      }\n      const rect = this.container.getBoundingClientRect();\n      const x = evt.clientX - rect.left;\n      const y = evt.clientY - rect.top;\n\n      if (up) {\n        this.cumulativeZoomFactor = this.cumulativeZoomFactor * 1.2;\n      } else {\n        this.cumulativeZoomFactor = this.cumulativeZoomFactor * 0.8;\n      }\n      this.lazyZoomPointer(this.cumulativeZoomFactor, x, y);\n      mxEvent.consume(evt);\n    }\n  }\n\n  /**\n   * Event for key on graph\n   *\n   * @param {KeyboardEvent} evt\n   * @memberof XGraph\n   */\n  eventKey(evt: KeyboardEvent) {\n    if (!mxEvent.isConsumed(evt) && evt.keyCode === 27 /* Escape */) {\n      this.cumulativeZoomFactor = 1;\n      if (this.graph) {\n        this.graph.zoomActual();\n        this.applyGraph();\n      }\n    }\n  }\n\n  /**\n   * Zoom/Unzoom on graph on center\n   *\n   * @param {number} factor - 1 = 100%\n   * @memberof XGraph\n   */\n  async lazyZoomCenter(factor: number) {\n    this.graph.zoomTo(factor, true);\n  }\n\n  /**\n   * Zoom/Unzoom on graph on mouse pointer\n   *\n   * @param {number} factor\n   * @param {number} offsetX\n   * @param {number} offsetY\n   * @memberof XGraph\n   */\n  async lazyZoomPointer(factor: number, offsetX: number, offsetY: number) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'lazyZoomPointer()');\n    let dx = offsetX * 2;\n    let dy = offsetY * 2;\n\n    factor = Math.max(0.01, Math.min(this.graph.view.scale * factor, 160)) / this.graph.view.scale;\n    factor = this.cumulativeZoomFactor / this.graph.view.scale;\n    const scale = Math.round(this.graph.view.scale * factor * 100) / 100;\n    factor = scale / this.graph.view.scale;\n\n    if (factor > 1) {\n      const f = (factor - 1) / (scale * 2);\n      dx *= -f;\n      dy *= -f;\n    } else {\n      const f = (1 / factor - 1) / (this.graph.view.scale * 2);\n      dx *= f;\n      dy *= f;\n    }\n    this.graph.view.scaleAndTranslate(scale, this.graph.view.translate.x + dx, this.graph.view.translate.y + dy);\n    trc.after();\n  }\n\n  /**\n   * Highlights the given cell.\n   *\n   * @param {mxCell[]} cells\n   * @memberof XGraph\n   */\n  async highlightCells(cells: mxCell[] = this.getMxCells()) {\n    for (let i = 0; i < cells.length; i++) {\n      this.highlightCell(cells[i]);\n    }\n  }\n\n  /**\n   * UnHighlights the given array of cells.\n   *\n   * @param {mxCell[]} cells\n   * @memberof XGraph\n   */\n  async unhighlightCells(mxcells: mxCell[] = this.getMxCells()) {\n    _.each(mxcells, (mxcell: mxCell) => {\n      this.unhighlightCell(mxcell);\n    });\n  }\n\n  /**\n   * Highlights the given cell.\n   *\n   * @param {*} cell\n   * @returns\n   * @memberof XGraph\n   */\n  async highlightCell(cell: mxCell) {\n    if (!cell.highlight) {\n      const color = '#99ff33';\n      const opacity = 100;\n      const state = this.graph.view.getState(cell);\n\n      if (state != null) {\n        const sw = Math.max(5, mxUtils.getValue(state.style, mxConstants.STYLE_STROKEWIDTH, 1) + 4);\n        const hl = new mxCellHighlight(this.graph, color, sw, false);\n\n        if (opacity != null) {\n          hl.opacity = opacity;\n        }\n\n        hl.highlight(state);\n        cell.highlight = hl;\n      }\n    }\n  }\n\n  /**\n   * UnHighlights the given cell.\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async unhighlightCell(mxcell: mxCell) {\n    if (mxcell && mxcell.highlight) {\n      const hl = mxcell.highlight;\n      // Fades out the highlight after a duration\n      if (hl.shape != null) {\n        mxUtils.setPrefixedStyle(hl.shape.node.style, 'transition', 'all 500ms ease-in-out');\n        hl.shape.node.style.opacity = 0;\n      }\n      // Destroys the highlight after the fade\n      window.setTimeout(() => {\n        hl.destroy();\n      }, 500);\n      mxcell.highlight = null;\n    }\n  }\n\n  // BLINK\n  async blinkCell(mxcell: mxCell, ms: number) {\n    if (!mxcell.blink) {\n      mxcell.blink = true;\n      const self = this;\n      const id = `blink_${mxcell.id}`;\n      // Cancel Previous anim\n      $GF.clearUniqTimeOut(id);\n      const bl_on = function() {\n        const color = '#f5f242';\n        const opacity = 100;\n        const state = self.graph.view.getState(mxcell);\n\n        if (state != null) {\n          const sw = Math.max(5, mxUtils.getValue(state.style, mxConstants.STYLE_STROKEWIDTH, 1) + 4);\n          const hl = new mxCellHighlight(self.graph, color, sw, false);\n\n          if (opacity != null) {\n            hl.opacity = opacity;\n          }\n\n          hl.highlight(state);\n          mxcell.blink_on = hl;\n          mxcell.blink_ms = ms;\n          $GF.setUniqTimeOut(bl_off, ms, id);\n        }\n      };\n      const bl_off = function() {\n        if (mxcell && mxcell.blink) {\n          // console.log('bl_off');\n          const hl = mxcell.blink_on;\n          // Fades out the highlight after a duration\n          if (hl.shape != null) {\n            mxUtils.setPrefixedStyle(hl.shape.node.style, `transition`, `all ${ms}ms ease-in-out`);\n            hl.shape.node.style.opacity = 0;\n          }\n          // Destroys the highlight after the fade\n          // window.setTimeout(() => {\n          //   hl.destroy();\n          //   cell.blink_on = null;\n          // }, ms);\n          hl.destroy();\n          mxcell.blink_on = null;\n          $GF.setUniqTimeOut(bl_on, ms, id);\n        }\n      };\n      bl_on();\n    }\n  }\n\n  async unblinkCell(mxcell: mxCell) {\n    const id = `blink_${mxcell.id}`;\n    if (mxcell.blink) {\n      if (mxcell.blink_on) {\n        const hl = mxcell.blink_on;\n        if (hl.shape != null) {\n          hl.shape.node.style.opacity = 0;\n          hl.destroy();\n          mxcell.blink_on = null;\n          mxcell.blink_ms = 0;\n        }\n      }\n      mxcell.blink = null;\n    }\n    // Cancel Previous anim\n    $GF.clearUniqTimeOut(id);\n  }\n\n  isBlinkCell(mxcell: mxCell): boolean {\n    return !!mxcell.blink;\n  }\n\n  geBlinkMxCell(mxcell: mxCell): number {\n    return !!mxcell.blink ? mxcell.blink_ms : 0;\n  }\n\n  // COLLAPSE\n  isCollapsedCell(mxcell: mxCell): boolean {\n    return this.graph.isCellCollapsed(mxcell);\n  }\n\n  collapseCell(mxcell: mxCell) {\n    if (!this.isCollapsedCell(mxcell)) {\n      this.graph.foldCells(true, false, [mxcell], null, null);\n    }\n  }\n\n  expandCell(mxcell: mxCell) {\n    if (this.isCollapsedCell(mxcell)) {\n      this.graph.foldCells(false, false, [mxcell], null, null);\n    }\n  }\n\n  toggleFoldCell(mxcell: mxCell) {\n    const collapse: boolean = !this.isCollapsedCell(mxcell);\n    this.graph.foldCells(collapse, false, [mxcell], null, null);\n  }\n\n  // VISIBLE\n\n  /**\n   * Hide cell/shape\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async hideCell(mxcell: mxCell) {\n    if (this.isVisibleCell(mxcell)) {\n      this.graph.model.setVisible(mxcell, false);\n    }\n  }\n\n  /**\n   * Show/unhide cell/shape\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async showCell(mxcell: mxCell) {\n    if (!this.isVisibleCell(mxcell)) {\n      this.graph.model.setVisible(mxcell, true);\n    }\n  }\n\n  /**\n   * Cell is visible ?\n   *\n   * @param {mxCell} mxcell\n   * @returns {boolean}\n   * @memberof XGraph\n   */\n  isVisibleCell(mxcell: mxCell): boolean {\n    return this.graph.model.isVisible(mxcell);\n  }\n\n  // async resizeCell(mxcell: mxCell, percent: number, origine?: mxGeometry) {\n  //   const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n  //   const geo = this.graph.model.getGeometry(mxcell);\n  //   if (geo !== null) {\n  //     let _x = origine !== undefined ? origine.x : geo.x;\n  //     let _ow = origine !== undefined ? origine.width : geo.x;\n  //     let _y = origine !== undefined ? origine.y : geo.y;\n  //     let _oh = origine !== undefined ? origine.height : geo.y;\n  //     let _w = _ow * (percent / 100);\n  //     let _h = _oh * (percent / 100);\n  //     _x = _x - (_w - _ow) / 2;\n  //     _y = _y - (_h - _oh) / 2;\n  //     if (this.isAnimated()) {\n  //       const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const l = steps_x.length;\n  //       let count = 0;\n  //       const self = this;\n  //       function graduate(count, steps_x, steps_y, steps_w, steps_h) {\n  //         if (count < l) {\n  //           window.setTimeout(() => {\n  //             const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n  //             self.graph.resizeCell(mxcell, _rec, true);\n  //             graduate(count + 1, steps_x, steps_y, steps_w, steps_h);\n  //           }, $GF.CONSTANTS.CONF_ANIMS_MS);\n  //         }\n  //       }\n  //       graduate(count, steps_x, steps_y, steps_w, steps_h);\n  //     } else {\n  //       const _rec = new mxRectangle(_x, _y, _w, _h);\n  //       this.graph.resizeCell(mxcell, _rec, true);\n  //     }\n  //   }\n  //   trc.after();\n  // }\n  async resizeCell(mxcell: mxCell, percent: number, origine?: mxGeometry) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n    const geo = this.graph.model.getGeometry(mxcell);\n    if (geo !== null) {\n      const id = `resize_${mxcell.id}`;\n      // Cancel Previous anim\n      $GF.clearUniqTimeOut(id);\n      let _x = origine !== undefined ? origine.x : geo.x;\n      let _ow = origine !== undefined ? origine.width : geo.x;\n      let _y = origine !== undefined ? origine.y : geo.y;\n      let _oh = origine !== undefined ? origine.height : geo.y;\n      let _w = _ow * (percent / 100);\n      let _h = _oh * (percent / 100);\n      _x = _x - (_w - _ow) / 2;\n      _y = _y - (_h - _oh) / 2;\n      if (this.isAnimated()) {\n        const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const lg = steps_x.length;\n        let count = 0;\n        const self = this;\n        function graduate() {\n          if (count < lg) {\n            const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n            self.graph.resizeCell(mxcell, _rec, true);\n            count += 1;\n            $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_ANIMS_MS, id);\n          } else {\n            $GF.clearUniqTimeOut(id);\n          }\n        }\n        graduate();\n      } else {\n        const _rec = new mxRectangle(_x, _y, _w, _h);\n        this.graph.resizeCell(mxcell, _rec, true);\n      }\n    }\n    trc.after();\n  }\n  // WIDTH AND HEIGHT\n  // async changeSizeCell(mxcell: mxCell, width: number | undefined, height: number | undefined, origine?: mxGeometry) {\n  //   const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n  //   const geo = this.graph.model.getGeometry(mxcell);\n  //   if (geo !== null) {\n  //     let _x = origine !== undefined ? origine.x : geo.x;\n  //     let _ow = origine !== undefined ? origine.width : geo.x;\n  //     let _y = origine !== undefined ? origine.y : geo.y;\n  //     let _oh = origine !== undefined ? origine.height : geo.y;\n  //     _x = width !== undefined && width < 0 ? _x + width + _ow : _x;\n  //     _y = height !== undefined && height < 0 ? _y + height + _oh : _y;\n  //     let _h = height !== undefined ? Math.abs(height) : origine !== undefined ? origine.height : geo.height;\n  //     let _w = width !== undefined ? Math.abs(width) : origine !== undefined ? origine.width : geo.width;\n  //     if (this.isAnimated()) {\n  //       const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n  //       const l = steps_x.length;\n  //       let count = 0;\n  //       const self = this;\n  //       function graduate(count, steps_x, steps_y, steps_w, steps_h) {\n  //         if (count < l) {\n  //           window.setTimeout(() => {\n  //             const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n  //             self.graph.resizeCell(mxcell, _rec, true);\n  //             graduate(count + 1, steps_x, steps_y, steps_w, steps_h);\n  //           }, $GF.CONSTANTS.CONF_ANIMS_MS);\n  //         }\n  //       }\n  //       graduate(count, steps_x, steps_y, steps_w, steps_h);\n  //     } else {\n  //       const _rec = new mxRectangle(_x, _y, _w, _h);\n  //       this.graph.resizeCell(mxcell, _rec, true);\n  //     }\n  //   }\n  //   trc.after();\n  // }\n  async changeSizeCell(mxcell: mxCell, width: number | undefined, height: number | undefined, origine?: mxGeometry) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'resizeCell()');\n    const geo = this.graph.model.getGeometry(mxcell);\n    if (geo !== null) {\n      const id = `resize_${mxcell.id}`;\n      // Cancel Previous anim\n      $GF.clearUniqTimeOut(id);\n      let _x = origine !== undefined ? origine.x : geo.x;\n      let _ow = origine !== undefined ? origine.width : geo.x;\n      let _y = origine !== undefined ? origine.y : geo.y;\n      let _oh = origine !== undefined ? origine.height : geo.y;\n      _x = width !== undefined && width < 0 ? _x + width + _ow : _x;\n      _y = height !== undefined && height < 0 ? _y + height + _oh : _y;\n      let _h = height !== undefined ? Math.abs(height) : origine !== undefined ? origine.height : geo.height;\n      let _w = width !== undefined ? Math.abs(width) : origine !== undefined ? origine.width : geo.width;\n      if (this.isAnimated()) {\n        const steps_x = $GF.getIntervalCounter(geo.x, _x, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_y = $GF.getIntervalCounter(geo.y, _y, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_w = $GF.getIntervalCounter(geo.width, _w, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const steps_h = $GF.getIntervalCounter(geo.height, _h, $GF.CONSTANTS.CONF_ANIMS_STEP);\n        const lg = steps_x.length;\n        let count = 0;\n        const self = this;\n        function graduate() {\n          if (count < lg) {\n            const _rec = new mxRectangle(steps_x[count], steps_y[count], steps_w[count], steps_h[count]);\n            self.graph.resizeCell(mxcell, _rec, true);\n            count += 1;\n            $GF.setUniqTimeOut(graduate, $GF.CONSTANTS.CONF_ANIMS_MS, id);\n          } else {\n            $GF.clearUniqTimeOut(id);\n          }\n        }\n        graduate();\n      } else {\n        const _rec = new mxRectangle(_x, _y, _w, _h);\n        this.graph.resizeCell(mxcell, _rec, true);\n      }\n    }\n    trc.after();\n  }\n\n  getSizeCell(mxcell: mxCell): mxGeometry {\n    return this.graph.model.getGeometry(mxcell);\n  }\n\n  async resetSizeCell(mxcell: mxCell, mxgeo: mxGeometry) {\n    const rec = new mxRectangle(mxgeo.x, mxgeo.y, mxgeo.width, mxgeo.height);\n    this.graph.resizeCell(mxcell, rec, true);\n  }\n\n  /**\n   * Zoom cell on full panel\n   *\n   * @param {mxCell} mxcell\n   * @memberof XGraph\n   */\n  async lazyZoomCell(mxcell: mxCell) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'lazyZoomCell()');\n    if (mxcell !== undefined && mxcell !== null && mxcell.isVertex()) {\n      const state = this.graph.view.getState(mxcell);\n      if (state !== null) {\n        let rect: any;\n        if (state.width !== undefined && state.width > 0 && state.height !== undefined && state.height > 0) {\n          // const x = state.x;\n          // const y = state.y;\n          // const width = state.width;\n          // const height = state.height;\n          // rect = new mxRectangle(x, y, width, height);\n          rect = state.shape.bounds;\n        } else {\n          rect = state.text.boundingBox;\n        }\n        this.graph.zoomToRect(rect);\n        this.cumulativeZoomFactor = this.graph.view.scale;\n      }\n    }\n    trc.after();\n  }\n\n  static loadXml(url: string): string | null {\n    try {\n      const req: any = mxUtils.load(url);\n      if (req.getStatus() >= 200 && req.getStatus() <= 299) {\n        return req.getText();\n      } else {\n        $GF.log.error('Cannot load ' + url, req.getStatus());\n      }\n    } catch (error) {\n      $GF.log.error('Cannot load ' + url, error);\n    }\n    return null;\n  }\n\n  static compress(source: string): string {\n    return Graph.compress(source, true);\n  }\n\n  static decompress(source: string): string {\n    return Graph.decompress(source, true);\n  }\n}\n","const customize = () => {\n  mxTooltipHandler.prototype.show = function (tip, x, y) {\n    // TYPE STRING\n    if (this.destroyed) {\n      return;\n    }\n    if (tip === null) {\n      return;\n    }\n    if (tip.length === 0) {\n      return;\n    }\n    // Initializes the DOM nodes if required\n    if (this.div == null) {\n      this.init();\n    }\n    if (!mxUtils.isNode(tip)) {\n      this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n    } else {\n      this.div.innerHTML = '';\n      this.div.appendChild(tip);\n    }\n    this.$div.place_tt(x + 20, y);\n    this.div.style.visibility = '';\n    mxUtils.fit(this.div);\n  };\n\n  mxTooltipHandler.prototype.init = function () {\n    if (this.div === null || this.div === undefined) {\n      this.$div = $('<div class=\"graph-tooltip\">');\n      this.div = this.$div[0];\n      mxEvent.addGestureListeners(\n        this.div,\n        mxUtils.bind(this, function (evt) {\n          this.hideTooltip();\n        })\n      );\n    }\n  };\n\n  mxTooltipHandler.prototype.hideTooltip = function () {\n    if (this.div != null) {\n      this.div.style.visibility = 'hidden';\n      this.div.innerHTML = '';\n    }\n  };\n\n  mxTooltipHandler.prototype.delay = 200;\n\n  Graph.prototype.getTooltipForCell = function (cell) {\n    let hasTips = false;\n    let div = document.createElement('div');\n    if (mxUtils.isNode(cell.value)) {\n      let tmp = cell.value.getAttribute('tooltip');\n      // Tooltip\n      if (tmp != null) {\n        hasTips = true;\n        if (tmp !== null && this.isReplacePlaceholders(cell)) {\n          tmp = this.replacePlaceholders(cell, tmp);\n        }\n        let ttDiv = document.createElement('div');\n        ttDiv.className = 'tooltip-text';\n        ttDiv.innerHTML = this.sanitizeHtml(tmp);\n        div.appendChild(ttDiv);\n      }\n\n      let ignored = this.builtInProperties;\n      let attrs = cell.value.attributes;\n      let temp = [];\n\n      // Hides links in edit mode\n      // if (this.isEnabled()) {\n      ignored.push('link');\n      // }\n\n      // Attributes\n      for (var i = 0; i < attrs.length; i++) {\n        if (mxUtils.indexOf(ignored, attrs[i].nodeName) < 0 && attrs[i].nodeValue.length > 0) {\n          temp.push({ name: attrs[i].nodeName, value: attrs[i].nodeValue });\n        }\n      }\n\n      // Sorts by name\n      temp.sort(function (a, b) {\n        if (a.name < b.name) {\n          return -1;\n        } else if (a.name > b.name) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n      if (temp.length > 0) {\n        hasTips = true;\n        var attrDiv = document.createElement('div');\n        var attrString = '';\n        for (let i = 0; i < temp.length; i++) {\n          if (temp[i].name !== 'link' || !this.isCustomLink(temp[i].value)) {\n            attrString +=\n              (temp[i].name !== 'link' ? '<b>' + temp[i].name + ':</b> ' : '') +\n              mxUtils.htmlEntities(temp[i].value) +\n              '\\n';\n          }\n        }\n        attrDiv.innerHTML = attrString;\n        div.appendChild(attrDiv);\n      }\n    }\n\n    // GF Tooltips\n    if (cell.GF_tooltipHandler != null) {\n      let tooltipHandler = cell.GF_tooltipHandler;\n      let gfDiv = tooltipHandler.getDiv(div);\n      if (gfDiv !== null) {\n        hasTips = true;\n      }\n    }\n    if (hasTips) {\n      return div;\n    }\n    return '';\n  };\n\n  mxEvent.addMouseWheelListener = function (func, container) {\n    if (null != func) {\n      var c = function (container) {\n        null == container && (container = window.event);\n        var c;\n        c = mxClient.IS_FF ? -container.detail / 2 : container.wheelDelta / 120;\n        0 !== c && func(container, 0 < c);\n      };\n      mxClient.IS_NS && null == document.documentMode\n        ? mxEvent.addListener(\n          mxClient.IS_GC && null != container ? container : window,\n          mxClient.IS_SF || mxClient.IS_GC ? 'mousewheel' : 'DOMMouseScroll',\n          c\n        )\n        : mxEvent.addListener(document, 'mousewheel', c);\n    }\n  };\n};\n\nconst viewerCode = \"d2luZG93LlNURU5DSUxfUEFUSD13aW5kb3cuU1RFTkNJTF9QQVRIfHwiaHR0cHM6Ly93d3cuZHJhdy5pby9zdGVuY2lscyI7d2luZG93LlNIQVBFU19QQVRIPXdpbmRvdy5TSEFQRVNfUEFUSHx8Imh0dHBzOi8vd3d3LmRyYXcuaW8vc2hhcGVzIjt3aW5kb3cubXhCYXNlUGF0aD13aW5kb3cubXhCYXNlUGF0aHx8Imh0dHBzOi8vd3d3LmRyYXcuaW8vbXhncmFwaC8iO3dpbmRvdy5teExvYWRTdHlsZXNoZWV0cz13aW5kb3cubXhMb2FkU3R5bGVzaGVldHN8fCExOwovL2ZnbmFzcy5naXRodWIuY29tL3NwaW4uanMjdjIuMC4wCiFmdW5jdGlvbihhLGIpeyJvYmplY3QiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1iKCk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoYik6YS5TcGlubmVyPWIoKX0odGhpcyxmdW5jdGlvbigpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBhKGEsYil7dmFyIGMsZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGF8fCJkaXYiKTtmb3IoYyBpbiBiKWRbY109YltjXTtyZXR1cm4gZH1mdW5jdGlvbiBiKGEpe2Zvcih2YXIgYj0xLGM9YXJndW1lbnRzLmxlbmd0aDtjPmI7YisrKWEuYXBwZW5kQ2hpbGQoYXJndW1lbnRzW2JdKTtyZXR1cm4gYX1mdW5jdGlvbiBjKGEsYixjLGQpe3ZhciBlPVsib3BhY2l0eSIsYix+figxMDAqYSksYyxkXS5qb2luKCItIiksZj0uMDErYy9kKjEwMCxnPU1hdGgubWF4KDEtKDEtYSkvYiooMTAwLWYpLGEpLGg9ai5zdWJzdHJpbmcoMCxqLmluZGV4T2YoIkFuaW1hdGlvbiIpKS50b0xvd2VyQ2FzZSgpLGk9aCYmIi0iK2grIi0ifHwiIjtyZXR1cm4gbFtlXXx8KG0uaW5zZXJ0UnVsZSgiQCIraSsia2V5ZnJhbWVzICIrZSsiezAle29wYWNpdHk6IitnKyJ9IitmKyIle29wYWNpdHk6IithKyJ9IisoZisuMDEpKyIle29wYWNpdHk6MX0iKyhmK2IpJTEwMCsiJXtvcGFjaXR5OiIrYSsifTEwMCV7b3BhY2l0eToiK2crIn19IixtLmNzc1J1bGVzLmxlbmd0aCksbFtlXT0xKSxlfWZ1bmN0aW9uIGQoYSxiKXt2YXIgYyxkLGU9YS5zdHlsZTtmb3IoYj1iLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Iuc2xpY2UoMSksZD0wO2Q8ay5sZW5ndGg7ZCsrKWlmKGM9a1tkXStiLHZvaWQgMCE9PWVbY10pcmV0dXJuIGM7cmV0dXJuIHZvaWQgMCE9PWVbYl0/Yjp2b2lkIDB9ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYyBpbiBiKWEuc3R5bGVbZChhLGMpfHxjXT1iW2NdO3JldHVybiBhfWZ1bmN0aW9uIGYoYSl7Zm9yKHZhciBiPTE7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKyl7dmFyIGM9YXJndW1lbnRzW2JdO2Zvcih2YXIgZCBpbiBjKXZvaWQgMD09PWFbZF0mJihhW2RdPWNbZF0pfXJldHVybiBhfWZ1bmN0aW9uIGcoYSxiKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGE/YTphW2IlYS5sZW5ndGhdfWZ1bmN0aW9uIGgoYSl7dGhpcy5vcHRzPWYoYXx8e30saC5kZWZhdWx0cyxuKX1mdW5jdGlvbiBpKCl7ZnVuY3Rpb24gYyhiLGMpe3JldHVybiBhKCI8IitiKycgeG1sbnM9InVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sIiBjbGFzcz0ic3Bpbi12bWwiPicsYyl9bS5hZGRSdWxlKCIuc3Bpbi12bWwiLCJiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKSIpLGgucHJvdG90eXBlLmxpbmVzPWZ1bmN0aW9uKGEsZCl7ZnVuY3Rpb24gZigpe3JldHVybiBlKGMoImdyb3VwIix7Y29vcmRzaXplOmsrIiAiK2ssY29vcmRvcmlnaW46LWorIiAiKy1qfSkse3dpZHRoOmssaGVpZ2h0Omt9KX1mdW5jdGlvbiBoKGEsaCxpKXtiKG0sYihlKGYoKSx7cm90YXRpb246MzYwL2QubGluZXMqYSsiZGVnIixsZWZ0On5+aH0pLGIoZShjKCJyb3VuZHJlY3QiLHthcmNzaXplOmQuY29ybmVyc30pLHt3aWR0aDpqLGhlaWdodDpkLndpZHRoLGxlZnQ6ZC5yYWRpdXMsdG9wOi1kLndpZHRoPj4xLGZpbHRlcjppfSksYygiZmlsbCIse2NvbG9yOmcoZC5jb2xvcixhKSxvcGFjaXR5OmQub3BhY2l0eX0pLGMoInN0cm9rZSIse29wYWNpdHk6MH0pKSkpfXZhciBpLGo9ZC5sZW5ndGgrZC53aWR0aCxrPTIqaixsPTIqLShkLndpZHRoK2QubGVuZ3RoKSsicHgiLG09ZShmKCkse3Bvc2l0aW9uOiJhYnNvbHV0ZSIsdG9wOmwsbGVmdDpsfSk7aWYoZC5zaGFkb3cpZm9yKGk9MTtpPD1kLmxpbmVzO2krKyloKGksLTIsInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CbHVyKHBpeGVscmFkaXVzPTIsbWFrZXNoYWRvdz0xLHNoYWRvd29wYWNpdHk9LjMpIik7Zm9yKGk9MTtpPD1kLmxpbmVzO2krKyloKGkpO3JldHVybiBiKGEsbSl9LGgucHJvdG90eXBlLm9wYWNpdHk9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5maXJzdENoaWxkO2Q9ZC5zaGFkb3cmJmQubGluZXN8fDAsZSYmYitkPGUuY2hpbGROb2Rlcy5sZW5ndGgmJihlPWUuY2hpbGROb2Rlc1tiK2RdLGU9ZSYmZS5maXJzdENoaWxkLGU9ZSYmZS5maXJzdENoaWxkLGUmJihlLm9wYWNpdHk9YykpfX12YXIgaixrPVsid2Via2l0IiwiTW96IiwibXMiLCJPIl0sbD17fSxtPWZ1bmN0aW9uKCl7dmFyIGM9YSgic3R5bGUiLHt0eXBlOiJ0ZXh0L2NzcyJ9KTtyZXR1cm4gYihkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaGVhZCIpWzBdLGMpLGMuc2hlZXR8fGMuc3R5bGVTaGVldH0oKSxuPXtsaW5lczoxMixsZW5ndGg6Nyx3aWR0aDo1LHJhZGl1czoxMCxyb3RhdGU6MCxjb3JuZXJzOjEsY29sb3I6IiMwMDAiLGRpcmVjdGlvbjoxLHNwZWVkOjEsdHJhaWw6MTAwLG9wYWNpdHk6LjI1LGZwczoyMCx6SW5kZXg6MmU5LGNsYXNzTmFtZToic3Bpbm5lciIsdG9wOiI1MCUiLGxlZnQ6IjUwJSIscG9zaXRpb246ImFic29sdXRlIn07aC5kZWZhdWx0cz17fSxmKGgucHJvdG90eXBlLHtzcGluOmZ1bmN0aW9uKGIpe3RoaXMuc3RvcCgpO3t2YXIgYz10aGlzLGQ9Yy5vcHRzLGY9Yy5lbD1lKGEoMCx7Y2xhc3NOYW1lOmQuY2xhc3NOYW1lfSkse3Bvc2l0aW9uOmQucG9zaXRpb24sd2lkdGg6MCx6SW5kZXg6ZC56SW5kZXh9KTtkLnJhZGl1cytkLmxlbmd0aCtkLndpZHRofWlmKGImJihiLmluc2VydEJlZm9yZShmLGIuZmlyc3RDaGlsZHx8bnVsbCksZShmLHtsZWZ0OmQubGVmdCx0b3A6ZC50b3B9KSksZi5zZXRBdHRyaWJ1dGUoInJvbGUiLCJwcm9ncmVzc2JhciIpLGMubGluZXMoZixjLm9wdHMpLCFqKXt2YXIgZyxoPTAsaT0oZC5saW5lcy0xKSooMS1kLmRpcmVjdGlvbikvMixrPWQuZnBzLGw9ay9kLnNwZWVkLG09KDEtZC5vcGFjaXR5KS8obCpkLnRyYWlsLzEwMCksbj1sL2QubGluZXM7IWZ1bmN0aW9uIG8oKXtoKys7Zm9yKHZhciBhPTA7YTxkLmxpbmVzO2ErKylnPU1hdGgubWF4KDEtKGgrKGQubGluZXMtYSkqbiklbCptLGQub3BhY2l0eSksYy5vcGFjaXR5KGYsYSpkLmRpcmVjdGlvbitpLGcsZCk7Yy50aW1lb3V0PWMuZWwmJnNldFRpbWVvdXQobyx+figxZTMvaykpfSgpfXJldHVybiBjfSxzdG9wOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbDtyZXR1cm4gYSYmKGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLHRoaXMuZWw9dm9pZCAwKSx0aGlzfSxsaW5lczpmdW5jdGlvbihkLGYpe2Z1bmN0aW9uIGgoYixjKXtyZXR1cm4gZShhKCkse3Bvc2l0aW9uOiJhYnNvbHV0ZSIsd2lkdGg6Zi5sZW5ndGgrZi53aWR0aCsicHgiLGhlaWdodDpmLndpZHRoKyJweCIsYmFja2dyb3VuZDpiLGJveFNoYWRvdzpjLHRyYW5zZm9ybU9yaWdpbjoibGVmdCIsdHJhbnNmb3JtOiJyb3RhdGUoIit+figzNjAvZi5saW5lcyprK2Yucm90YXRlKSsiZGVnKSB0cmFuc2xhdGUoIitmLnJhZGl1cysicHgsMCkiLGJvcmRlclJhZGl1czooZi5jb3JuZXJzKmYud2lkdGg+PjEpKyJweCJ9KX1mb3IodmFyIGksaz0wLGw9KGYubGluZXMtMSkqKDEtZi5kaXJlY3Rpb24pLzI7azxmLmxpbmVzO2srKylpPWUoYSgpLHtwb3NpdGlvbjoiYWJzb2x1dGUiLHRvcDoxK34oZi53aWR0aC8yKSsicHgiLHRyYW5zZm9ybTpmLmh3YWNjZWw/InRyYW5zbGF0ZTNkKDAsMCwwKSI6IiIsb3BhY2l0eTpmLm9wYWNpdHksYW5pbWF0aW9uOmomJmMoZi5vcGFjaXR5LGYudHJhaWwsbCtrKmYuZGlyZWN0aW9uLGYubGluZXMpKyIgIisxL2Yuc3BlZWQrInMgbGluZWFyIGluZmluaXRlIn0pLGYuc2hhZG93JiZiKGksZShoKCIjMDAwIiwiMCAwIDRweCAjMDAwIikse3RvcDoiMnB4In0pKSxiKGQsYihpLGgoZyhmLmNvbG9yLGspLCIwIDAgMXB4IHJnYmEoMCwwLDAsLjEpIikpKTtyZXR1cm4gZH0sb3BhY2l0eTpmdW5jdGlvbihhLGIsYyl7YjxhLmNoaWxkTm9kZXMubGVuZ3RoJiYoYS5jaGlsZE5vZGVzW2JdLnN0eWxlLm9wYWNpdHk9Yyl9fSk7dmFyIG89ZShhKCJncm91cCIpLHtiZWhhdmlvcjoidXJsKCNkZWZhdWx0I1ZNTCkifSk7cmV0dXJuIWQobywidHJhbnNmb3JtIikmJm8uYWRqP2koKTpqPWQobywiYW5pbWF0aW9uIiksaH0pOwovLyBOT1RFOiBNb2RpZmllZCB0byBzdXBwb3J0IGRhdGEgVVJJcyBmb3IgaW1hZ2VzLCBpZS4gZGF0YTppbWFnZS8qCi8vIE1vZGlmaWVkIHRvIGFsbG93ICJ3b3JkLWJyZWFrOiBicmVhay13b3JkIiBpbiBzdHlsZXMuIEl0IGlzIGRvbmUgYnkgYWRkaW5nICJicmVhay13b3JkIiB3aGljaCBpcyBhdCBpbmRleCA1NSBvZiBKIGFycmF5IEpbNTVdIHRvICJjc3NMaXRHcm91cCIgb2YgIndvcmQtYnJlYWsiCihmdW5jdGlvbigpe3ZhciBjPXZvaWQgMCxuPSEwLHM9bnVsbCxDPSExLEo9WyJhbGljZWJsdWUsYW50aXF1ZXdoaXRlLGFxdWEsYXF1YW1hcmluZSxhenVyZSxiZWlnZSxiaXNxdWUsYmxhY2ssYmxhbmNoZWRhbG1vbmQsYmx1ZSxibHVldmlvbGV0LGJyb3duLGJ1cmx5d29vZCxjYWRldGJsdWUsY2hhcnRyZXVzZSxjaG9jb2xhdGUsY29yYWwsY29ybmZsb3dlcmJsdWUsY29ybnNpbGssY3JpbXNvbixjeWFuLGRhcmtibHVlLGRhcmtjeWFuLGRhcmtnb2xkZW5yb2QsZGFya2dyYXksZGFya2dyZWVuLGRhcmtraGFraSxkYXJrbWFnZW50YSxkYXJrb2xpdmVncmVlbixkYXJrb3JhbmdlLGRhcmtvcmNoaWQsZGFya3JlZCxkYXJrc2FsbW9uLGRhcmtzZWFncmVlbixkYXJrc2xhdGVibHVlLGRhcmtzbGF0ZWdyYXksZGFya3R1cnF1b2lzZSxkYXJrdmlvbGV0LGRlZXBwaW5rLGRlZXBza3libHVlLGRpbWdyYXksZG9kZ2VyYmx1ZSxmaXJlYnJpY2ssZmxvcmFsd2hpdGUsZm9yZXN0Z3JlZW4sZnVjaHNpYSxnYWluc2Jvcm8sZ2hvc3R3aGl0ZSxnb2xkLGdvbGRlbnJvZCxncmF5LGdyZWVuLGdyZWVueWVsbG93LGhvbmV5ZGV3LGhvdHBpbmssaW5kaWFucmVkLGluZGlnbyxpdm9yeSxraGFraSxsYXZlbmRlcixsYXZlbmRlcmJsdXNoLGxhd25ncmVlbixsZW1vbmNoaWZmb24sbGlnaHRibHVlLGxpZ2h0Y29yYWwsbGlnaHRjeWFuLGxpZ2h0Z29sZGVucm9keWVsbG93LGxpZ2h0Z3JlZW4sbGlnaHRncmV5LGxpZ2h0cGluayxsaWdodHNhbG1vbixsaWdodHNlYWdyZWVuLGxpZ2h0c2t5Ymx1ZSxsaWdodHNsYXRlZ3JheSxsaWdodHN0ZWVsYmx1ZSxsaWdodHllbGxvdyxsaW1lLGxpbWVncmVlbixsaW5lbixtYWdlbnRhLG1hcm9vbixtZWRpdW1hcXVhbWFyaW5lLG1lZGl1bWJsdWUsbWVkaXVtb3JjaGlkLG1lZGl1bXB1cnBsZSxtZWRpdW1zZWFncmVlbixtZWRpdW1zbGF0ZWJsdWUsbWVkaXVtc3ByaW5nZ3JlZW4sbWVkaXVtdHVycXVvaXNlLG1lZGl1bXZpb2xldHJlZCxtaWRuaWdodGJsdWUsbWludGNyZWFtLG1pc3R5cm9zZSxtb2NjYXNpbixuYXZham93aGl0ZSxuYXZ5LG9sZGxhY2Usb2xpdmUsb2xpdmVkcmFiLG9yYW5nZSxvcmFuZ2VyZWQsb3JjaGlkLHBhbGVnb2xkZW5yb2QscGFsZWdyZWVuLHBhbGV0dXJxdW9pc2UscGFsZXZpb2xldHJlZCxwYXBheWF3aGlwLHBlYWNocHVmZixwZXJ1LHBpbmsscGx1bSxwb3dkZXJibHVlLHB1cnBsZSxyZWQscm9zeWJyb3duLHJveWFsYmx1ZSxzYWRkbGVicm93bixzYWxtb24sc2FuZHlicm93bixzZWFncmVlbixzZWFzaGVsbCxzaWVubmEsc2lsdmVyLHNreWJsdWUsc2xhdGVibHVlLHNsYXRlZ3JheSxzbm93LHNwcmluZ2dyZWVuLHN0ZWVsYmx1ZSx0YW4sdGVhbCx0aGlzdGxlLHRvbWF0byx0cmFuc3BhcmVudCx0dXJxdW9pc2UsdmlvbGV0LHdoZWF0LHdoaXRlLHdoaXRlc21va2UseWVsbG93LHllbGxvd2dyZWVuIi5zcGxpdCgiLCIpLAoiYWxsLXNjcm9sbCxjb2wtcmVzaXplLGNyb3NzaGFpcixkZWZhdWx0LGUtcmVzaXplLGhhbmQsaGVscCxtb3ZlLG4tcmVzaXplLG5lLXJlc2l6ZSxuby1kcm9wLG5vdC1hbGxvd2VkLG53LXJlc2l6ZSxwb2ludGVyLHByb2dyZXNzLHJvdy1yZXNpemUscy1yZXNpemUsc2UtcmVzaXplLHN3LXJlc2l6ZSx0ZXh0LHZlcnRpY2FsLXRleHQsdy1yZXNpemUsd2FpdCIuc3BsaXQoIiwiKSwiYXJtZW5pYW4sZGVjaW1hbCxkZWNpbWFsLWxlYWRpbmctemVybyxkaXNjLGdlb3JnaWFuLGxvd2VyLWFscGhhLGxvd2VyLWdyZWVrLGxvd2VyLWxhdGluLGxvd2VyLXJvbWFuLHNxdWFyZSx1cHBlci1hbHBoYSx1cHBlci1sYXRpbix1cHBlci1yb21hbiIuc3BsaXQoIiwiKSwiMTAwLDIwMCwzMDAsNDAwLDUwMCw2MDAsNzAwLDgwMCw5MDAsYm9sZCxib2xkZXIsbGlnaHRlciIuc3BsaXQoIiwiKSwiYmxvY2stbGV2ZWwsaW5saW5lLWxldmVsLHRhYmxlLWNhcHRpb24sdGFibGUtY2VsbCx0YWJsZS1jb2x1bW4sdGFibGUtY29sdW1uLWdyb3VwLHRhYmxlLWZvb3Rlci1ncm91cCx0YWJsZS1oZWFkZXItZ3JvdXAsdGFibGUtcm93LHRhYmxlLXJvdy1ncm91cCIuc3BsaXQoIiwiKSwKImNvbmRlbnNlZCxleHBhbmRlZCxleHRyYS1jb25kZW5zZWQsZXh0cmEtZXhwYW5kZWQsbmFycm93ZXIsc2VtaS1jb25kZW5zZWQsc2VtaS1leHBhbmRlZCx1bHRyYS1jb25kZW5zZWQsdWx0cmEtZXhwYW5kZWQsd2lkZXIiLnNwbGl0KCIsIiksImluaGVyaXQsaW5saW5lLGlubGluZS1ibG9jayxpbmxpbmUtYm94LGlubGluZS1mbGV4LGlubGluZS1ncmlkLGlubGluZS1saXN0LWl0ZW0saW5saW5lLXN0YWNrLGlubGluZS10YWJsZSxydW4taW4iLnNwbGl0KCIsIiksImJlaGluZCxjZW50ZXItbGVmdCxjZW50ZXItcmlnaHQsZmFyLWxlZnQsZmFyLXJpZ2h0LGxlZnQtc2lkZSxsZWZ0d2FyZHMscmlnaHQtc2lkZSxyaWdodHdhcmRzIi5zcGxpdCgiLCIpLCJsYXJnZSxsYXJnZXIsc21hbGwsc21hbGxlcix4LWxhcmdlLHgtc21hbGwseHgtbGFyZ2UseHgtc21hbGwiLnNwbGl0KCIsIiksImRhc2hlZCxkb3R0ZWQsZG91YmxlLGdyb292ZSxvdXRzZXQscmlkZ2Usc29saWQiLnNwbGl0KCIsIiksCiJlYXNlLGVhc2UtaW4sZWFzZS1pbi1vdXQsZWFzZS1vdXQsbGluZWFyLHN0ZXAtZW5kLHN0ZXAtc3RhcnQiLnNwbGl0KCIsIiksImF0LGNsb3Nlc3QtY29ybmVyLGNsb3Nlc3Qtc2lkZSxlbGxpcHNlLGZhcnRoZXN0LWNvcm5lcixmYXJ0aGVzdC1zaWRlIi5zcGxpdCgiLCIpLCJiYXNlbGluZSxtaWRkbGUsc3ViLHN1cGVyLHRleHQtYm90dG9tLHRleHQtdG9wIi5zcGxpdCgiLCIpLCJjYXB0aW9uLGljb24sbWVudSxtZXNzYWdlLWJveCxzbWFsbC1jYXB0aW9uLHN0YXR1cy1iYXIiLnNwbGl0KCIsIiksImZhc3QsZmFzdGVyLHNsb3csc2xvd2VyLHgtZmFzdCx4LXNsb3ciLnNwbGl0KCIsIiksWyJhYm92ZSIsImJlbG93IiwiaGlnaGVyIiwibGV2ZWwiLCJsb3dlciJdLFsiY3Vyc2l2ZSIsImZhbnRhc3kiLCJtb25vc3BhY2UiLCJzYW5zLXNlcmlmIiwic2VyaWYiXSxbImxvdWQiLCJzaWxlbnQiLCJzb2Z0IiwieC1sb3VkIiwieC1zb2Z0Il0sWyJuby1yZXBlYXQiLCJyZXBlYXQteCIsInJlcGVhdC15IiwKInJvdW5kIiwic3BhY2UiXSxbImJsaW5rIiwibGluZS10aHJvdWdoIiwib3ZlcmxpbmUiLCJ1bmRlcmxpbmUiXSxbImJsb2NrIiwiZmxleCIsImdyaWQiLCJ0YWJsZSJdLFsiaGlnaCIsImxvdyIsIngtaGlnaCIsIngtbG93Il0sWyJub3dyYXAiLCJwcmUiLCJwcmUtbGluZSIsInByZS13cmFwIl0sWyJhYnNvbHV0ZSIsInJlbGF0aXZlIiwic3RhdGljIl0sWyJhbHRlcm5hdGUiLCJhbHRlcm5hdGUtcmV2ZXJzZSIsInJldmVyc2UiXSxbImJvcmRlci1ib3giLCJjb250ZW50LWJveCIsInBhZGRpbmctYm94Il0sWyJjYXBpdGFsaXplIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIl0sWyJjaGlsZCIsImZlbWFsZSIsIm1hbGUiXSxbIj0iLCJvcGFjaXR5Il0sWyJiYWNrd2FyZHMiLCJmb3J3YXJkcyJdLFsiYmlkaS1vdmVycmlkZSIsImVtYmVkIl0sWyJib3R0b20iLCJ0b3AiXSxbImJyZWFrLWFsbCIsImtlZXAtYWxsIl0sWyJjbGlwIiwiZWxsaXBzaXMiXSxbImNvbnRhaW4iLCJjb3ZlciJdLApbImNvbnRpbnVvdXMiLCJkaWdpdHMiXSxbImVuZCIsInN0YXJ0Il0sWyJmbGF0IiwicHJlc2VydmUtM2QiXSxbImhpZGUiLCJzaG93Il0sWyJob3Jpem9udGFsIiwidmVydGljYWwiXSxbImluc2lkZSIsIm91dHNpZGUiXSxbIml0YWxpYyIsIm9ibGlxdWUiXSxbImxlZnQiLCJyaWdodCJdLFsibHRyIiwicnRsIl0sWyJuby1jb250ZW50Iiwibm8tZGlzcGxheSJdLFsicGF1c2VkIiwicnVubmluZyJdLFsic3VwcHJlc3MiLCJ1bnJlc3RyaWN0ZWQiXSxbInRoaWNrIiwidGhpbiJdLFsiLCJdLFsiLyJdLFsiYWxsIl0sWyJhbHdheXMiXSxbImF1dG8iXSxbImF2b2lkIl0sWyJib3RoIl0sWyJicmVhay13b3JkIl0sWyJjZW50ZXIiXSxbImNpcmNsZSJdLFsiY29kZSJdLFsiY29sbGFwc2UiXSxbImNvbnRlbnRzIl0sWyJmaXhlZCJdLFsiaGlkZGVuIl0sWyJpbmZpbml0ZSJdLFsiaW5zZXQiXSxbImludmVydCJdLFsianVzdGlmeSJdLFsibGlzdC1pdGVtIl0sWyJsb2NhbCJdLFsibWVkaXVtIl0sClsibWl4Il0sWyJub25lIl0sWyJub3JtYWwiXSxbIm9uY2UiXSxbInJlcGVhdCJdLFsic2Nyb2xsIl0sWyJzZXBhcmF0ZSJdLFsic21hbGwtY2FwcyJdLFsic3BlbGwtb3V0Il0sWyJ0byJdLFsidmlzaWJsZSJdXSxMPXthbmltYXRpb246e2Nzc1Byb3BCaXRzOjUxNyxjc3NMaXRHcm91cDpbSlsxMF0sSlsyNF0sSlsyOV0sSls0NV0sSls0OF0sSls1NF0sSls2M10sSls3MV0sSls3Ml1dLGNzc0ZuczpbImN1YmljLWJlemllcigpIiwic3RlcHMoKSJdfSwiYW5pbWF0aW9uLWRlbGF5Ijp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSls0OF1dLGNzc0ZuczpbXX0sImFuaW1hdGlvbi1kaXJlY3Rpb24iOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzI0XSxKWzQ4XSxKWzcyXV0sY3NzRm5zOltdfSwiYW5pbWF0aW9uLWR1cmF0aW9uIjoiYW5pbWF0aW9uLWRlbGF5IiwiYW5pbWF0aW9uLWZpbGwtbW9kZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMjldLEpbNDhdLApKWzU0XSxKWzcxXV0sY3NzRm5zOltdfSwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNDhdLEpbNjNdXSxjc3NGbnM6W119LCJhbmltYXRpb24tbmFtZSI6e2Nzc1Byb3BCaXRzOjUxMixjc3NMaXRHcm91cDpbSls0OF0sSls3MV1dLGNzc0ZuczpbXX0sImFuaW1hdGlvbi1wbGF5LXN0YXRlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0NV0sSls0OF1dLGNzc0ZuczpbXX0sImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24iOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzEwXSxKWzQ4XV0sY3NzRm5zOlsiY3ViaWMtYmV6aWVyKCkiLCJzdGVwcygpIl19LGFwcGVhcmFuY2U6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNzFdXSxjc3NGbnM6W119LGF6aW11dGg6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbN10sSls0Ml0sSls1Nl1dLGNzc0ZuczpbXX0sImJhY2tmYWNlLXZpc2liaWxpdHkiOntjc3NQcm9wQml0czowLApjc3NMaXRHcm91cDpbSls1OV0sSls2Ml0sSls4MF1dLGNzc0ZuczpbXX0sYmFja2dyb3VuZDp7Y3NzUHJvcEJpdHM6MjMsY3NzTGl0R3JvdXA6W0pbMF0sSlsxOF0sSlsyNV0sSlszMV0sSlszNF0sSls0Ml0sSls0OF0sSls0OV0sSls1Ml0sSls1Nl0sSls2MV0sSls2OF0sSls3MV0sSls3NF0sSls3NV1dLGNzc0ZuczoiaW1hZ2UoKSxsaW5lYXItZ3JhZGllbnQoKSxyYWRpYWwtZ3JhZGllbnQoKSxyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KCkscmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudCgpLHJnYigpLHJnYmEoKSIuc3BsaXQoIiwiKX0sImJhY2tncm91bmQtYXR0YWNobWVudCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNDhdLEpbNjFdLEpbNjhdLEpbNzVdXSxjc3NGbnM6W119LCJiYWNrZ3JvdW5kLWNvbG9yIjp7Y3NzUHJvcEJpdHM6Mixjc3NMaXRHcm91cDpbSlswXV0sY3NzRm5zOlsicmdiKCkiLCJyZ2JhKCkiXX0sImJhY2tncm91bmQtaW1hZ2UiOntjc3NQcm9wQml0czoxNiwKY3NzTGl0R3JvdXA6W0pbNDhdLEpbNzFdXSxjc3NGbnM6WyJpbWFnZSgpIiwibGluZWFyLWdyYWRpZW50KCkiLCJyYWRpYWwtZ3JhZGllbnQoKSIsInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoKSIsInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQoKSJdfSwiYmFja2dyb3VuZC1wb3NpdGlvbiI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbMzFdLEpbNDJdLEpbNDhdLEpbNTZdXSxjc3NGbnM6W119LCJiYWNrZ3JvdW5kLXJlcGVhdCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMThdLEpbNDhdLEpbNzRdXSxjc3NGbnM6W119LCJiYWNrZ3JvdW5kLXNpemUiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltKWzM0XSxKWzQ4XSxKWzUyXV0sY3NzRm5zOltdfSxib3JkZXI6e2Nzc1Byb3BCaXRzOjcsY3NzTGl0R3JvdXA6W0pbMF0sSls5XSxKWzQ3XSxKWzYyXSxKWzY0XSxKWzY5XSxKWzcxXV0sY3NzRm5zOlsicmdiKCkiLCJyZ2JhKCkiXX0sImJvcmRlci1ib3R0b20iOiJib3JkZXIiLAoiYm9yZGVyLWJvdHRvbS1jb2xvciI6ImJhY2tncm91bmQtY29sb3IiLCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIjp7Y3NzUHJvcEJpdHM6NSxjc3NGbnM6W119LCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJib3JkZXItYm90dG9tLXN0eWxlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls5XSxKWzYyXSxKWzY0XSxKWzcxXV0sY3NzRm5zOltdfSwiYm9yZGVyLWJvdHRvbS13aWR0aCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNDddLEpbNjldXSxjc3NGbnM6W119LCJib3JkZXItY29sbGFwc2UiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzU5XSxKWzc2XV0sY3NzRm5zOltdfSwiYm9yZGVyLWNvbG9yIjoiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci1sZWZ0IjoiYm9yZGVyIiwiYm9yZGVyLWxlZnQtY29sb3IiOiJiYWNrZ3JvdW5kLWNvbG9yIiwiYm9yZGVyLWxlZnQtc3R5bGUiOiJib3JkZXItYm90dG9tLXN0eWxlIiwKImJvcmRlci1sZWZ0LXdpZHRoIjoiYm9yZGVyLWJvdHRvbS13aWR0aCIsImJvcmRlci1yYWRpdXMiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltKWzQ5XV0sY3NzRm5zOltdfSwiYm9yZGVyLXJpZ2h0IjoiYm9yZGVyIiwiYm9yZGVyLXJpZ2h0LWNvbG9yIjoiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci1yaWdodC1zdHlsZSI6ImJvcmRlci1ib3R0b20tc3R5bGUiLCJib3JkZXItcmlnaHQtd2lkdGgiOiJib3JkZXItYm90dG9tLXdpZHRoIiwiYm9yZGVyLXNwYWNpbmciOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwiYm9yZGVyLXN0eWxlIjoiYm9yZGVyLWJvdHRvbS1zdHlsZSIsImJvcmRlci10b3AiOiJib3JkZXIiLCJib3JkZXItdG9wLWNvbG9yIjoiYmFja2dyb3VuZC1jb2xvciIsImJvcmRlci10b3AtbGVmdC1yYWRpdXMiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwKImJvcmRlci10b3Atc3R5bGUiOiJib3JkZXItYm90dG9tLXN0eWxlIiwiYm9yZGVyLXRvcC13aWR0aCI6ImJvcmRlci1ib3R0b20td2lkdGgiLCJib3JkZXItd2lkdGgiOiJib3JkZXItYm90dG9tLXdpZHRoIixib3R0b206e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNTJdXSxjc3NGbnM6W119LGJveDp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls2MF0sSls3MV0sSls3Ml1dLGNzc0ZuczpbXX0sImJveC1zaGFkb3ciOntjc3NQcm9wQml0czo3LGNzc0xpdEdyb3VwOltKWzBdLEpbNDhdLEpbNjRdLEpbNzFdXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwiYm94LXNpemluZyI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMjVdXSxjc3NGbnM6W119LCJjYXB0aW9uLXNpZGUiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzMxXV0sY3NzRm5zOltdfSxjbGVhcjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0Ml0sSls1NF0sSls3MV1dLGNzc0ZuczpbXX0sCmNsaXA6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdXSxjc3NGbnM6WyJyZWN0KCkiXX0sY29sb3I6ImJhY2tncm91bmQtY29sb3IiLGNvbnRlbnQ6e2Nzc1Byb3BCaXRzOjgsY3NzTGl0R3JvdXA6W0pbNzFdLEpbNzJdXSxjc3NGbnM6W119LGN1ZTp7Y3NzUHJvcEJpdHM6MTYsY3NzTGl0R3JvdXA6W0pbNzFdXSxjc3NGbnM6W119LCJjdWUtYWZ0ZXIiOiJjdWUiLCJjdWUtYmVmb3JlIjoiY3VlIixjdXJzb3I6e2Nzc1Byb3BCaXRzOjE2LGNzc0xpdEdyb3VwOltKWzFdLEpbNDhdLEpbNTJdXSxjc3NGbnM6W119LGRpcmVjdGlvbjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0M11dLGNzc0ZuczpbXX0sZGlzcGxheTp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0XSxKWzZdLEpbMjBdLEpbNTJdLEpbNjddLEpbNzFdXSxjc3NGbnM6W119LCJkaXNwbGF5LWV4dHJhcyI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNjddLEpbNzFdXSxjc3NGbnM6W119LAoiZGlzcGxheS1pbnNpZGUiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzIwXSxKWzUyXV0sY3NzRm5zOltdfSwiZGlzcGxheS1vdXRzaWRlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0XSxKWzcxXV0sY3NzRm5zOltdfSxlbGV2YXRpb246e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbMTVdXSxjc3NGbnM6W119LCJlbXB0eS1jZWxscyI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzhdXSxjc3NGbnM6W119LGZpbHRlcjp7Y3NzUHJvcEJpdHM6MCxjc3NGbnM6WyJhbHBoYSgpIl19LCJmbG9hdCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNDJdLEpbNzFdXSxjc3NGbnM6W119LGZvbnQ6e2Nzc1Byb3BCaXRzOjczLGNzc0xpdEdyb3VwOltKWzNdLEpbOF0sSlsxM10sSlsxNl0sSls0MV0sSls0OF0sSls0OV0sSls2OV0sSls3Ml0sSls3N11dLGNzc0ZuczpbXX0sImZvbnQtZmFtaWx5Ijp7Y3NzUHJvcEJpdHM6NzIsY3NzTGl0R3JvdXA6W0pbMTZdLApKWzQ4XV0sY3NzRm5zOltdfSwiZm9udC1zaXplIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbSls4XSxKWzY5XV0sY3NzRm5zOltdfSwiZm9udC1zdHJldGNoIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls1XSxKWzcyXV0sY3NzRm5zOltdfSwiZm9udC1zdHlsZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNDFdLEpbNzJdXSxjc3NGbnM6W119LCJmb250LXZhcmlhbnQiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzcyXSxKWzc3XV0sY3NzRm5zOltdfSwiZm9udC13ZWlnaHQiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzNdLEpbNzJdXSxjc3NGbnM6W119LGhlaWdodDoiYm90dG9tIixsZWZ0OiJib3R0b20iLCJsZXR0ZXItc3BhY2luZyI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNzJdXSxjc3NGbnM6W119LCJsaW5lLWhlaWdodCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0pbNzJdXSxjc3NGbnM6W119LCJsaXN0LXN0eWxlIjp7Y3NzUHJvcEJpdHM6MTYsCmNzc0xpdEdyb3VwOltKWzJdLEpbNDBdLEpbNTddLEpbNzFdXSxjc3NGbnM6WyJpbWFnZSgpIiwibGluZWFyLWdyYWRpZW50KCkiLCJyYWRpYWwtZ3JhZGllbnQoKSIsInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoKSIsInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQoKSJdfSwibGlzdC1zdHlsZS1pbWFnZSI6e2Nzc1Byb3BCaXRzOjE2LGNzc0xpdEdyb3VwOltKWzcxXV0sY3NzRm5zOlsiaW1hZ2UoKSIsImxpbmVhci1ncmFkaWVudCgpIiwicmFkaWFsLWdyYWRpZW50KCkiLCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KCkiLCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KCkiXX0sImxpc3Qtc3R5bGUtcG9zaXRpb24iOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzQwXV0sY3NzRm5zOltdfSwibGlzdC1zdHlsZS10eXBlIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlsyXSxKWzU3XSxKWzcxXV0sY3NzRm5zOltdfSxtYXJnaW46ImJvdHRvbSIsIm1hcmdpbi1ib3R0b20iOiJib3R0b20iLAoibWFyZ2luLWxlZnQiOiJib3R0b20iLCJtYXJnaW4tcmlnaHQiOiJib3R0b20iLCJtYXJnaW4tdG9wIjoiYm90dG9tIiwibWF4LWhlaWdodCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNzFdXSxjc3NGbnM6W119LCJtYXgtd2lkdGgiOiJtYXgtaGVpZ2h0IiwibWluLWhlaWdodCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0pbNTJdXSxjc3NGbnM6W119LCJtaW4td2lkdGgiOiJtaW4taGVpZ2h0IixvcGFjaXR5Ontjc3NQcm9wQml0czoxLGNzc0ZuczpbXX0sb3V0bGluZTp7Y3NzUHJvcEJpdHM6Nyxjc3NMaXRHcm91cDpbSlswXSxKWzldLEpbNDddLEpbNjJdLEpbNjRdLEpbNjVdLEpbNjldLEpbNzFdXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwib3V0bGluZS1jb2xvciI6e2Nzc1Byb3BCaXRzOjIsY3NzTGl0R3JvdXA6W0pbMF0sSls2NV1dLGNzc0ZuczpbInJnYigpIiwicmdiYSgpIl19LCJvdXRsaW5lLXN0eWxlIjoiYm9yZGVyLWJvdHRvbS1zdHlsZSIsCiJvdXRsaW5lLXdpZHRoIjoiYm9yZGVyLWJvdHRvbS13aWR0aCIsb3ZlcmZsb3c6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNjJdLEpbNzVdLEpbODBdXSxjc3NGbnM6W119LCJvdmVyZmxvdy13cmFwIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls1NV0sSls3Ml1dLGNzc0ZuczpbXX0sIm92ZXJmbG93LXgiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzQ0XSxKWzUyXSxKWzYyXSxKWzc1XSxKWzgwXV0sY3NzRm5zOltdfSwib3ZlcmZsb3cteSI6Im92ZXJmbG93LXgiLHBhZGRpbmc6Im9wYWNpdHkiLCJwYWRkaW5nLWJvdHRvbSI6Im9wYWNpdHkiLCJwYWRkaW5nLWxlZnQiOiJvcGFjaXR5IiwicGFkZGluZy1yaWdodCI6Im9wYWNpdHkiLCJwYWRkaW5nLXRvcCI6Im9wYWNpdHkiLCJwYWdlLWJyZWFrLWFmdGVyIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0Ml0sSls1MV0sSls1Ml0sSls1M11dLGNzc0ZuczpbXX0sInBhZ2UtYnJlYWstYmVmb3JlIjoicGFnZS1icmVhay1hZnRlciIsCiJwYWdlLWJyZWFrLWluc2lkZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNTNdXSxjc3NGbnM6W119LHBhdXNlOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwicGF1c2UtYWZ0ZXIiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwicGF1c2UtYmVmb3JlIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIscGVyc3BlY3RpdmU6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbNzFdXSxjc3NGbnM6W119LCJwZXJzcGVjdGl2ZS1vcmlnaW4iOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltKWzMxXSxKWzQyXSxKWzU2XV0sY3NzRm5zOltdfSxwaXRjaDp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSlsyMV0sSls2OV1dLGNzc0ZuczpbXX0sInBpdGNoLXJhbmdlIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInBsYXktZHVyaW5nIjp7Y3NzUHJvcEJpdHM6MTYsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNzBdLEpbNzFdLEpbNzRdXSxjc3NGbnM6W119LApwb3NpdGlvbjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlsyM11dLGNzc0ZuczpbXX0scXVvdGVzOntjc3NQcm9wQml0czo4LGNzc0xpdEdyb3VwOltKWzcxXV0sY3NzRm5zOltdfSxyZXNpemU6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzldLEpbNTRdLEpbNzFdXSxjc3NGbnM6W119LHJpY2huZXNzOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIixyaWdodDoiYm90dG9tIixzcGVhazp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls3MV0sSls3Ml0sSls3OF1dLGNzc0ZuczpbXX0sInNwZWFrLWhlYWRlciI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTFdLEpbNzNdXSxjc3NGbnM6W119LCJzcGVhay1udW1lcmFsIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlszNV1dLGNzc0ZuczpbXX0sInNwZWFrLXB1bmN0dWF0aW9uIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls1OF0sSls3MV1dLGNzc0ZuczpbXX0sInNwZWVjaC1yYXRlIjp7Y3NzUHJvcEJpdHM6NSwKY3NzTGl0R3JvdXA6W0pbMTRdLEpbNjldXSxjc3NGbnM6W119LHN0cmVzczoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInRhYmxlLWxheW91dCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbNTJdLEpbNjFdXSxjc3NGbnM6W119LCJ0ZXh0LWFsaWduIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSls0Ml0sSls1Nl0sSls2Nl1dLGNzc0ZuczpbXX0sInRleHQtZGVjb3JhdGlvbiI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMTldLEpbNzFdXSxjc3NGbnM6W119LCJ0ZXh0LWluZGVudCI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJ0ZXh0LW92ZXJmbG93Ijp7Y3NzUHJvcEJpdHM6OCxjc3NMaXRHcm91cDpbSlszM11dLGNzc0ZuczpbXX0sInRleHQtc2hhZG93IjoiYm94LXNoYWRvdyIsInRleHQtdHJhbnNmb3JtIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlsyNl0sSls3MV1dLGNzc0ZuczpbXX0sInRleHQtd3JhcCI6e2Nzc1Byb3BCaXRzOjAsCmNzc0xpdEdyb3VwOltKWzQ2XSxKWzcxXSxKWzcyXV0sY3NzRm5zOltdfSx0b3A6ImJvdHRvbSIsdHJhbnNmb3JtOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltKWzcxXV0sY3NzRm5zOiJtYXRyaXgoKSxwZXJzcGVjdGl2ZSgpLHJvdGF0ZSgpLHJvdGF0ZTNkKCkscm90YXRleCgpLHJvdGF0ZXkoKSxyb3RhdGV6KCksc2NhbGUoKSxzY2FsZTNkKCksc2NhbGV4KCksc2NhbGV5KCksc2NhbGV6KCksc2tldygpLHNrZXd4KCksc2tld3koKSx0cmFuc2xhdGUoKSx0cmFuc2xhdGUzZCgpLHRyYW5zbGF0ZXgoKSx0cmFuc2xhdGV5KCksdHJhbnNsYXRleigpIi5zcGxpdCgiLCIpfSwidHJhbnNmb3JtLW9yaWdpbiI6InBlcnNwZWN0aXZlLW9yaWdpbiIsInRyYW5zZm9ybS1zdHlsZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzddXSxjc3NGbnM6W119LHRyYW5zaXRpb246e2Nzc1Byb3BCaXRzOjEwMjksY3NzTGl0R3JvdXA6W0pbMTBdLEpbNDhdLEpbNTBdLEpbNzFdXSxjc3NGbnM6WyJjdWJpYy1iZXppZXIoKSIsCiJzdGVwcygpIl19LCJ0cmFuc2l0aW9uLWRlbGF5IjoiYW5pbWF0aW9uLWRlbGF5IiwidHJhbnNpdGlvbi1kdXJhdGlvbiI6ImFuaW1hdGlvbi1kZWxheSIsInRyYW5zaXRpb24tcHJvcGVydHkiOntjc3NQcm9wQml0czoxMDI0LGNzc0xpdEdyb3VwOltKWzQ4XSxKWzUwXV0sY3NzRm5zOltdfSwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24iOiJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uIiwidW5pY29kZS1iaWRpIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbSlszMF0sSls3Ml1dLGNzc0ZuczpbXX0sInZlcnRpY2FsLWFsaWduIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSlsxMl0sSlszMV1dLGNzc0ZuczpbXX0sdmlzaWJpbGl0eToiYmFja2ZhY2UtdmlzaWJpbGl0eSIsInZvaWNlLWZhbWlseSI6e2Nzc1Byb3BCaXRzOjgsY3NzTGl0R3JvdXA6W0pbMjddLEpbNDhdXSxjc3NGbnM6W119LHZvbHVtZTp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbSlsxN10sSls2OV1dLApjc3NGbnM6W119LCJ3aGl0ZS1zcGFjZSI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMjJdLEpbNzJdXSxjc3NGbnM6W119LHdpZHRoOiJtaW4taGVpZ2h0Iiwid29yZC1icmVhayI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0pbMzJdLEpbNzJdLEpbNTVdXSxjc3NGbnM6W119LCJ3b3JkLXNwYWNpbmciOiJsZXR0ZXItc3BhY2luZyIsIndvcmQtd3JhcCI6Im92ZXJmbG93LXdyYXAiLCJ6LWluZGV4IjoiYm90dG9tIix6b29tOiJsaW5lLWhlaWdodCIsImN1YmljLWJlemllcigpIjoiYW5pbWF0aW9uLWRlbGF5Iiwic3RlcHMoKSI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0pbMzZdLEpbNDhdXSxjc3NGbnM6W119LCJpbWFnZSgpIjp7Y3NzUHJvcEJpdHM6MTgsY3NzTGl0R3JvdXA6W0pbMF0sSls0OF1dLGNzc0ZuczpbInJnYigpIiwicmdiYSgpIl19LCJsaW5lYXItZ3JhZGllbnQoKSI6e2Nzc1Byb3BCaXRzOjcsY3NzTGl0R3JvdXA6W0pbMF0sSlszMV0sSls0Ml0sSls0OF0sCkpbNzldXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwicmFkaWFsLWdyYWRpZW50KCkiOntjc3NQcm9wQml0czo3LGNzc0xpdEdyb3VwOltKWzBdLEpbMTFdLEpbMzFdLEpbNDJdLEpbNDhdLEpbNTZdLEpbNTddXSxjc3NGbnM6WyJyZ2IoKSIsInJnYmEoKSJdfSwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCgpIjoibGluZWFyLWdyYWRpZW50KCkiLCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KCkiOiJyYWRpYWwtZ3JhZGllbnQoKSIsInJnYigpIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbSls0OF1dLGNzc0ZuczpbXX0sInJnYmEoKSI6InJnYigpIiwicmVjdCgpIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbSls0OF0sSls1Ml1dLGNzc0ZuczpbXX0sImFscGhhKCkiOntjc3NQcm9wQml0czoxLGNzc0xpdEdyb3VwOltKWzI4XV0sY3NzRm5zOltdfSwibWF0cml4KCkiOiJhbmltYXRpb24tZGVsYXkiLCJwZXJzcGVjdGl2ZSgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsCiJyb3RhdGUoKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJyb3RhdGUzZCgpIjoiYW5pbWF0aW9uLWRlbGF5Iiwicm90YXRleCgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInJvdGF0ZXkoKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJyb3RhdGV6KCkiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwic2NhbGUoKSI6ImFuaW1hdGlvbi1kZWxheSIsInNjYWxlM2QoKSI6ImFuaW1hdGlvbi1kZWxheSIsInNjYWxleCgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInNjYWxleSgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInNjYWxleigpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInNrZXcoKSI6ImFuaW1hdGlvbi1kZWxheSIsInNrZXd4KCkiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIiwic2tld3koKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJ0cmFuc2xhdGUoKSI6ImFuaW1hdGlvbi1kZWxheSIsInRyYW5zbGF0ZTNkKCkiOiJhbmltYXRpb24tZGVsYXkiLAoidHJhbnNsYXRleCgpIjoiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyIsInRyYW5zbGF0ZXkoKSI6ImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMiLCJ0cmFuc2xhdGV6KCkiOiJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzIn0sTztmb3IoTyBpbiBMKSJzdHJpbmciPT09dHlwZW9mIExbT10mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKEwsTykmJihMW09dPUxbTFtPXV0pOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5jc3NTY2hlbWE9TCk7dmFyIFUsWDsKKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhhKXt2YXIgZj1wYXJzZUludChhLnN1YnN0cmluZygxKSwxNik7cmV0dXJuIDY1NTM1PGY/KGYtPTY1NTM2LFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGY+PjEwKSw1NjMyMCsoZiYxMDIzKSkpOmY9PWY/U3RyaW5nLmZyb21DaGFyQ29kZShmKToiICI+YVsxXT8iIjphWzFdfWZ1bmN0aW9uIHcoYSxmKXtyZXR1cm4nIicrYS5yZXBsYWNlKC9bXHUwMDAwLVx1MDAxZlxcXCI8Pl0vZyxmKSsnIid9ZnVuY3Rpb24gTShhKXtyZXR1cm4gRVthXXx8KEVbYV09IlxcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKyIgIil9ZnVuY3Rpb24geChhKXtyZXR1cm4gZVthXXx8KGVbYV09KCJcdTAwMTAiPmE/IiUwIjoiJSIpK2EuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpfXZhciBFPXsiXFwiOiJcXFxcIn0sZT17IlxcIjoiJTVjIn0sdj1SZWdFeHAoIlxcdUZFRkZ8VVsrXVswLTlBLUY/XXsxLDZ9KD86LVswLTlBLUZdezEsNn0pP3x1cmxbKF1bXFx0XFxuXFxmIF0qKD86XCIoPzonfFteJ1wiXFxuXFxmXFxcXF18XFxcXFtcXHNcXFNdKSpcInwnKD86XCJ8W14nXCJcXG5cXGZcXFxcXXxcXFxcW1xcc1xcU10pKid8KD86W1xcdFxceDIxXFx4MjMtXFx4MjZcXHgyOC1cXHg1YlxceDVkLVxceDdlXXxbXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFxcXFwoPzpbMC05YS1mQS1GXXsxLDZ9W1xcdFxcblxcZiBdP3xbXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMFxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pKSopW1xcdFxcblxcZiBdKlspXXwoPyF1cmxbKF0pLT8oPzpbYS16QS1aX118W1xcdTAwODAtXFx1ZDdmZlxcdWUwMDAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxcXFxcKD86WzAtOWEtZkEtRl17MSw2fVtcXHRcXG5cXGYgXT98W1xcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1ZDdmZlxcdWUwMDBcXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKSkoPzpbYS16QS1aMC05Xy1dfFtcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18XFxcXCg/OlswLTlhLWZBLUZdezEsNn1bXFx0XFxuXFxmIF0/fFtcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSkpKlsoXXwoPzpAPy0/KD86W2EtekEtWl9dfFtcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18XFxcXCg/OlswLTlhLWZBLUZdezEsNn1bXFx0XFxuXFxmIF0/fFtcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSkpfCMpKD86W2EtekEtWjAtOV8tXXxbXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFxcXFwoPzpbMC05YS1mQS1GXXsxLDZ9W1xcdFxcblxcZiBdP3xbXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMFxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pKSp8XCIoPzonfFteJ1wiXFxuXFxmXFxcXF18XFxcXFtcXHNcXFNdKSpcInwnKD86XCJ8W14nXCJcXG5cXGZcXFxcXXxcXFxcW1xcc1xcU10pKid8Wy0rXT8oPzpbMC05XSsoPzpbLl1bMC05XSspP3xbLl1bMC05XSspKD86JXwtPyg/OlthLXpBLVpfXXxbXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFxcXFwoPzpbMC05YS1mQS1GXXsxLDZ9W1xcdFxcblxcZiBdP3xbXFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHVkN2ZmXFx1ZTAwMFxcdWZmZmRdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pKSg/OlthLXpBLVowLTlfLV18W1xcdTAwODAtXFx1ZDdmZlxcdWUwMDAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXxcXFxcKD86WzAtOWEtZkEtRl17MSw2fVtcXHRcXG5cXGYgXT98W1xcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1ZDdmZlxcdWUwMDBcXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKSkqKT98PFwhLS18LS1cPnxbXFx0XFxuXFxmIF0rfC8oPzpbKl1bXipdKlsqXSsoPzpbXi9dW14qXSpbKl0rKSovfC9bXlxcblxcZl0qKXxbfnxeJCpdPXxbXlwiJ1xcXFwvXXwvKD8hWy8qXSkiLCJnaSIpLApiPVJlZ0V4cCgiXFxcXCg/Oig/OlswLTlhLWZBLUZdezEsNn1bXFx0XFxuXFxmIF0/fFtcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdWQ3ZmZcXHVlMDAwXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSl8W1xcblxcZl0pIiwiZyIpLGE9UmVnRXhwKCJedXJsXFwoW1xcdFxcblxcZiBdKltcIiddP3xbXCInXT9bXFx0XFxuXFxmIF0qXFwpJCIsImdpIik7WD1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKGIsZyl9O1U9ZnVuY3Rpb24oYil7Zm9yKHZhciBiPSgiIitiKS5yZXBsYWNlKC9cclxuPy9nLCJcbiIpLm1hdGNoKHYpfHxbXSxmPTAsaD0iICIsZD0wLHk9Yi5sZW5ndGg7ZDx5OysrZCl7dmFyIGw9WChiW2RdKSxWPWwubGVuZ3RoLGc9bC5jaGFyQ29kZUF0KDApLGw9MzQ9PWd8fDM5PT1nP3cobC5zdWJzdHJpbmcoMSxWLTEpLE0pOjQ3PT1nJiYxPFZ8fCJcXCI9PWx8fCItLVw+Ij09bHx8IjxcIS0tIj09bHx8Ilx1ZmVmZiI9PWx8fDMyPj1nPyIgIjoKL3VybFwoL2kudGVzdChsKT8idXJsKCIrdyhsLnJlcGxhY2UoYSwiIikseCkrIikiOmw7aWYoaCE9bHx8IiAiIT1sKWJbZisrXT1oPWx9Yi5sZW5ndGg9ZjtyZXR1cm4gYn19KSgpOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5sZXhDc3M9VSx3aW5kb3cuZGVjb2RlQ3NzPVgpO3ZhciBZPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZyhkKXtkPSgiIitkKS5tYXRjaChrKTtyZXR1cm4hZD9zOm5ldyBlKHYoZFsxXSksdihkWzJdKSx2KGRbM10pLHYoZFs0XSksdihkWzVdKSx2KGRbNl0pLHYoZFs3XSkpfWZ1bmN0aW9uIHcoZCxhKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGQ/ZW5jb2RlVVJJKGQpLnJlcGxhY2UoYSxNKTpzfWZ1bmN0aW9uIE0oZCl7ZD1kLmNoYXJDb2RlQXQoMCk7cmV0dXJuIiUiKyIwMTIzNDU2Nzg5QUJDREVGIi5jaGFyQXQoZD4+NCYxNSkrIjAxMjM0NTY3ODlBQkNERUYiLmNoYXJBdChkJjE1KX1mdW5jdGlvbiB4KGQpe2lmKGQ9PT1zKXJldHVybiBzO2Zvcih2YXIgZD1kLnJlcGxhY2UoLyhefFwvKVwuKD86XC98JCkvZywiJDEiKS5yZXBsYWNlKC9cL3syLH0vZywiLyIpLGE9YixoOyhoPWQucmVwbGFjZShhLCIkMSIpKSE9ZDtkPWgpO3JldHVybiBkfWZ1bmN0aW9uIEUoZCxoKXt2YXIgYj1kLlQoKSxmPWguSygpO2Y/Yi5nYShoLmopOmY9aC5YKCk7CmY/Yi5kYShoLm4pOmY9aC5ZKCk7Zj9iLmVhKGguayk6Zj1oLiQoKTt2YXIgZz1oLmcsaz14KGcpO2lmKGYpYi5jYShoLlYoKSksaz1rJiZrLnJlcGxhY2UoYSwiIik7ZWxzZSBpZihmPSEhZyl7aWYoNDchPT1rLmNoYXJDb2RlQXQoMCkpdmFyIGs9eChiLmd8fCIiKS5yZXBsYWNlKGEsIiIpLGU9ay5sYXN0SW5kZXhPZigiLyIpKzEsaz14KChlP2suc3Vic3RyaW5nKDAsZSk6IiIpK3goZykpLnJlcGxhY2UoYSwiIil9ZWxzZSBrPWsmJmsucmVwbGFjZShhLCIiKSxrIT09ZyYmYi5HKGspO2Y/Yi5HKGspOmY9aC5hYSgpO2Y/Yi5PKGgubCk6Zj1oLlooKTtmJiZiLmZhKGgubyk7cmV0dXJuIGJ9ZnVuY3Rpb24gZShkLGEsaCxmLGIsZyxrKXt0aGlzLmo9ZDt0aGlzLm49YTt0aGlzLms9aDt0aGlzLmg9Zjt0aGlzLmc9Yjt0aGlzLmw9Zzt0aGlzLm89a31mdW5jdGlvbiB2KGQpe3JldHVybiJzdHJpbmciPT10eXBlb2YgZCYmMDxkLmxlbmd0aD9kOnN9dmFyIGI9UmVnRXhwKC8oXC98XikoPzpbXi4vXVteL10qfFwuezIsfSg/OlteLi9dW14vXSopfFwuezMsfVteL10qKVwvXC5cLig/OlwvfCQpLyksCmE9L14oPzpcLlwuXC8pKig/OlwuXC4kKT8vO2UucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGQ9W107cyE9PXRoaXMuaiYmZC5wdXNoKHRoaXMuaiwiOiIpO3MhPT10aGlzLmsmJihkLnB1c2goIi8vIikscyE9PXRoaXMubiYmZC5wdXNoKHRoaXMubiwiQCIpLGQucHVzaCh0aGlzLmspLHMhPT10aGlzLmgmJmQucHVzaCgiOiIsdGhpcy5oLnRvU3RyaW5nKCkpKTtzIT09dGhpcy5nJiZkLnB1c2godGhpcy5nKTtzIT09dGhpcy5sJiZkLnB1c2goIj8iLHRoaXMubCk7cyE9PXRoaXMubyYmZC5wdXNoKCIjIix0aGlzLm8pO3JldHVybiBkLmpvaW4oIiIpfTtlLnByb3RvdHlwZS5UPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlKHRoaXMuaix0aGlzLm4sdGhpcy5rLHRoaXMuaCx0aGlzLmcsdGhpcy5sLHRoaXMubyl9O2UucHJvdG90eXBlLlc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5qJiZkZWNvZGVVUklDb21wb25lbnQodGhpcy5qKS50b0xvd2VyQ2FzZSgpfTtlLnByb3RvdHlwZS5nYT0KZnVuY3Rpb24oZCl7dGhpcy5qPWQ/ZDpzfTtlLnByb3RvdHlwZS5LPWZ1bmN0aW9uKCl7cmV0dXJuIHMhPT10aGlzLmp9O2UucHJvdG90eXBlLmRhPWZ1bmN0aW9uKGQpe3RoaXMubj1kP2Q6c307ZS5wcm90b3R5cGUuWD1mdW5jdGlvbigpe3JldHVybiBzIT09dGhpcy5ufTtlLnByb3RvdHlwZS5lYT1mdW5jdGlvbihkKXt0aGlzLms9ZD9kOnM7dGhpcy5HKHRoaXMuZyl9O2UucHJvdG90eXBlLlk9ZnVuY3Rpb24oKXtyZXR1cm4gcyE9PXRoaXMua307ZS5wcm90b3R5cGUuVj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmgmJmRlY29kZVVSSUNvbXBvbmVudCh0aGlzLmgpfTtlLnByb3RvdHlwZS5jYT1mdW5jdGlvbihkKXtpZihkKXtkPU51bWJlcihkKTtpZihkIT09KGQmNjU1MzUpKXRocm93IEVycm9yKCJCYWQgcG9ydCBudW1iZXIgIitkKTt0aGlzLmg9IiIrZH1lbHNlIHRoaXMuaD1zfTtlLnByb3RvdHlwZS4kPWZ1bmN0aW9uKCl7cmV0dXJuIHMhPT10aGlzLmh9O2UucHJvdG90eXBlLlU9CmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZyYmZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuZyl9O2UucHJvdG90eXBlLkc9ZnVuY3Rpb24oZCl7ZD8oZD0iIitkLHRoaXMuZz0hdGhpcy5rfHwvXlwvLy50ZXN0KGQpP2Q6Ii8iK2QpOnRoaXMuZz1zfTtlLnByb3RvdHlwZS5PPWZ1bmN0aW9uKGQpe3RoaXMubD1kP2Q6c307ZS5wcm90b3R5cGUuYWE9ZnVuY3Rpb24oKXtyZXR1cm4gcyE9PXRoaXMubH07ZS5wcm90b3R5cGUuYmE9ZnVuY3Rpb24oZCl7aWYoIm9iamVjdCI9PT10eXBlb2YgZCYmIShkIGluc3RhbmNlb2YgQXJyYXkpJiYoZCBpbnN0YW5jZW9mIE9iamVjdHx8IltvYmplY3QgQXJyYXldIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSkpe3ZhciBhPVtdLGg9LTEsZjtmb3IoZiBpbiBkKXt2YXIgYj1kW2ZdOyJzdHJpbmciPT09dHlwZW9mIGImJihhWysraF09ZixhWysraF09Yil9ZD1hfWZvcih2YXIgYT1bXSxoPSIiLGc9MDtnPGQubGVuZ3RoOylmPWRbZysrXSwKYj1kW2crK10sYS5wdXNoKGgsZW5jb2RlVVJJQ29tcG9uZW50KGYudG9TdHJpbmcoKSkpLGg9IiYiLGImJmEucHVzaCgiPSIsZW5jb2RlVVJJQ29tcG9uZW50KGIudG9TdHJpbmcoKSkpO3RoaXMubD1hLmpvaW4oIiIpfTtlLnByb3RvdHlwZS5mYT1mdW5jdGlvbihkKXt0aGlzLm89ZD9kOnN9O2UucHJvdG90eXBlLlo9ZnVuY3Rpb24oKXtyZXR1cm4gcyE9PXRoaXMub307dmFyIGs9L14oPzooW146Lz8jXSspOik/KD86XC9cLyg/OihbXi8/I10qKUApPyhbXi8/IzpAXSopKD86OihbMC05XSspKT8pPyhbXj8jXSspPyg/Olw/KFteI10qKSk/KD86IyguKikpPyQvLGY9L1sjXC9cP0BdL2csaD0vW1wjXD9dL2c7ZS5wYXJzZT1nO2UuY3JlYXRlPWZ1bmN0aW9uKGQsYSxiLGcsayxRLE4pe2Q9bmV3IGUodyhkLGYpLHcoYSxmKSwic3RyaW5nIj09dHlwZW9mIGI/ZW5jb2RlVVJJQ29tcG9uZW50KGIpOnMsMDxnP2cudG9TdHJpbmcoKTpzLHcoayxoKSxzLCJzdHJpbmciPT10eXBlb2YgTj9lbmNvZGVVUklDb21wb25lbnQoTik6CnMpO1EmJigic3RyaW5nIj09PXR5cGVvZiBRP2QuTyhRLnJlcGxhY2UoL1tePyY9MC05QS1aYS16X1wtfi4lXS9nLE0pKTpkLmJhKFEpKTtyZXR1cm4gZH07ZS5OPUU7ZS5tYT14O2UuaGE9e3VhOmZ1bmN0aW9uKGQpe3JldHVybi9cLmh0bWwkLy50ZXN0KGcoZCkuVSgpKT8idGV4dC9odG1sIjoiYXBwbGljYXRpb24vamF2YXNjcmlwdCJ9LE46ZnVuY3Rpb24oZCxhKXtyZXR1cm4gZD9FKGcoZCksZyhhKSkudG9TdHJpbmcoKToiIithfX07cmV0dXJuIGV9KCk7InVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93JiYod2luZG93LlVSST1ZKTt2YXIgYWE9YyxiYT1jLGRhPWMsWj1jOwooZnVuY3Rpb24oKXtmdW5jdGlvbiBnKGEpe3JldHVybiJzdHJpbmciPT09dHlwZW9mIGE/J3VybCgiJythLnJlcGxhY2UoZSx3KSsnIiknOid1cmwoImFib3V0OmJsYW5rIiknfWZ1bmN0aW9uIHcoYSl7cmV0dXJuIHZbYV19ZnVuY3Rpb24gTShhLGQpe3JldHVybiBhP1kuaGEuTihhLGQpOmR9ZnVuY3Rpb24geChoLGQsZil7aWYoIWYpcmV0dXJuIHM7dmFyIGc9KCIiK2gpLm1hdGNoKGIpO3JldHVybiBnJiYoIWdbMV18fGEudGVzdChnWzFdKSk/ZihoLGQpOnN9ZnVuY3Rpb24gRShhKXtyZXR1cm4gYS5yZXBsYWNlKC9eLSg/OmFwcGxlfGNzc3xlcHVifGtodG1sfG1venxtc28/fG98cmltfHdhcHx3ZWJraXR8eHYpLSg/PVthLXpdKS8sIiIpfXZhciBlPS9bXG5cZlxyXCJcJygpKjw+XS9nLHY9eyJcbiI6IiUwYSIsIlx1MDAwYyI6IiUwYyIsIlxyIjoiJTBkIiwnIic6IiUyMiIsIiciOiIlMjciLCIoIjoiJTI4IiwiKSI6IiUyOSIsIioiOiIlMmEiLCI8IjoiJTNjIiwiPiI6IiUzZSJ9LApiPS9eKD86KFteOi8/IyBdKyk6KT8vLGE9L14oPzpodHRwcz98bWFpbHRvfGRhdGEpJC9pO2FhPWZ1bmN0aW9uKCl7dmFyIGE9e307cmV0dXJuIGZ1bmN0aW9uIHkoZixiLGssZSxOKXt2YXIgZj1FKGYpLHU9TFtmXTtpZighdXx8Im9iamVjdCIhPT10eXBlb2YgdSliLmxlbmd0aD0wO2Vsc2V7Zm9yKHZhciBpPXUuY3NzUHJvcEJpdHMscT1pJjgwLEI9aSYxNTM2LEY9TmFOLHI9MCxvPTA7cjxiLmxlbmd0aDsrK3Ipe3ZhciBqPWJbcl0udG9Mb3dlckNhc2UoKSxJPWouY2hhckNvZGVBdCgwKSxSLHYsUCxTLEQsdztpZigzMj09PUkpaj0iIjtlbHNlIGlmKDM0PT09SSlqPTE2PT09cT9rP2coeChNKGUsWChiW3JdLnN1YnN0cmluZygxLGoubGVuZ3RoLTEpKSksZixrKSk6IiI6aSY4JiYhKHEmcS0xKT9qOiIiO2Vsc2UgaWYoImluaGVyaXQiIT09ail7aWYoRD11LmNzc0xpdEdyb3VwKXt2YXIgRztpZighKEc9dS5jc3NMaXRNYXApKXtHPXt9O2Zvcih2YXIgSz1ELmxlbmd0aDswPD0tLUs7KWZvcih2YXIgQT0KRFtLXSxUPUEubGVuZ3RoOzA8PS0tVDspR1tBW1RdXT1hO0c9dS5jc3NMaXRNYXA9R31EPUd9ZWxzZSBEPWE7aWYoISh3PUQsd1tFKGopXT09PWEpKWlmKDM1PT09SSYmL14jKD86WzAtOWEtZl17M30pezEsMn0kLy50ZXN0KGopKWo9aSYyP2o6IiI7ZWxzZSBpZig0ODw9SSYmNTc+PUkpaj1pJjE/ajoiIjtlbHNlIGlmKFI9ai5jaGFyQ29kZUF0KDEpLHY9ai5jaGFyQ29kZUF0KDIpLFA9NDg8PVImJjU3Pj1SLFM9NDg8PXYmJjU3Pj12LDQzPT09SSYmKFB8fDQ2PT09UiYmUykpaj1pJjE/KFA/IiI6IjAiKStqLnN1YnN0cmluZygxKToiIjtlbHNlIGlmKDQ1PT09SSYmKFB8fDQ2PT09UiYmUykpaj1pJjQ/KFA/Ii0iOiItMCIpK2ouc3Vic3RyaW5nKDEpOmkmMT8iMCI6IiI7ZWxzZSBpZig0Nj09PUkmJlApaj1pJjE/IjAiK2o6IiI7ZWxzZSBpZigndXJsKCInPT09ai5zdWJzdHJpbmcoMCw1KSlqPWsmJmkmMTY/Zyh4KE0oZSxiW3JdLnN1YnN0cmluZyg1LGoubGVuZ3RoLTIpKSxmLGspKToKIiI7ZWxzZSBpZigiKCI9PT1qLmNoYXJBdChqLmxlbmd0aC0xKSlhOntEPWI7Rz1yO2o9MTtLPUcrMTtmb3IoST1ELmxlbmd0aDtLPEkmJmo7KUE9RFtLKytdLGorPSIpIj09PUE/LTE6L15bXiInXSpcKCQvLnRlc3QoQSk7aWYoIWope2o9RFtHXS50b0xvd2VyQ2FzZSgpO0k9RShqKTtEPUQuc3BsaWNlKEcsSy1HLCIiKTtHPXUuY3NzRm5zO0s9MDtmb3IoQT1HLmxlbmd0aDtLPEE7KytLKWlmKEdbS10uc3Vic3RyaW5nKDAsSS5sZW5ndGgpPT1JKXtEWzBdPURbRC5sZW5ndGgtMV09IiI7eShHW0tdLEQsayxlKTtqPWorRC5qb2luKCIgIikrIikiO2JyZWFrIGF9fWo9IiJ9ZWxzZSBqPUImJi9eLT9bYS16X11bXHdcLV0qJC8udGVzdChqKSYmIS9fXyQvLnRlc3Qoaik/TiYmNTEyPT09Qj9iW3JdK046MTAyND09PUImJkxbal0mJiJudW1iZXIiPT09dHlwZW9mIExbal0ub2E/ajoiIjovXlx3KyQvLnRlc3QoaikmJjY0PT09cSYmaSY4P0YrMT09PW8/KGJbRl09YltGXS5zdWJzdHJpbmcoMCwKYltGXS5sZW5ndGgtMSkrIiAiK2orJyInLCIiKTooRj1vLCciJytqKyciJyk6IiJ9aiYmKGJbbysrXT1qKX0xPT09byYmJ3VybCgiYWJvdXQ6YmxhbmsiKSc9PT1iWzBdJiYobz0wKTtiLmxlbmd0aD1vfX19KCk7dmFyIGs9UmVnRXhwKCJeKGFjdGl2ZXxhZnRlcnxiZWZvcmV8Ymxhbmt8Y2hlY2tlZHxkZWZhdWx0fGRpc2FibGVkfGRyb3B8ZW1wdHl8ZW5hYmxlZHxmaXJzdHxmaXJzdC1jaGlsZHxmaXJzdC1sZXR0ZXJ8Zmlyc3QtbGluZXxmaXJzdC1vZi10eXBlfGZ1bGxzY3JlZW58Zm9jdXN8aG92ZXJ8aW4tcmFuZ2V8aW5kZXRlcm1pbmF0ZXxpbnZhbGlkfGxhc3QtY2hpbGR8bGFzdC1vZi10eXBlfGxlZnR8bGlua3xvbmx5LWNoaWxkfG9ubHktb2YtdHlwZXxvcHRpb25hbHxvdXQtb2YtcmFuZ2V8cGxhY2Vob2xkZXItc2hvd258cmVhZC1vbmx5fHJlYWQtd3JpdGV8cmVxdWlyZWR8cmlnaHR8cm9vdHxzY29wZXx1c2VyLWVycm9yfHZhbGlkfHZpc2l0ZWQpJCIpLGY9e307ZlsiPiJdPQpmWyIrIl09ZlsifiJdPWY7YmE9ZnVuY3Rpb24oYSxkLGIpe2Z1bmN0aW9uIGcoaSxyKXtmdW5jdGlvbiBvKGIsZixnKXt2YXIgeSxlLGksbCxvLG09bjt5PSIiO2lmKGI8ZilpZihvPWFbYl0sIioiPT09bykrK2IseT1vO2Vsc2UgaWYoL15bYS16QS1aXS8udGVzdChvKSYmKGU9eChvLnRvTG93ZXJDYXNlKCksW10pKSkidGFnTmFtZSJpbiBlJiYobz1lLnRhZ05hbWUpLCsrYix5PW87Zm9yKGw9aT1lPSIiO20mJmI8ZjsrK2IpaWYobz1hW2JdLCIjIj09PW8uY2hhckF0KDApKS9eI198X18kfFteXHcjOlwtXS8udGVzdChvKT9tPUM6ZSs9byt2O2Vsc2UgaWYoIi4iPT09bykrK2I8ZiYmL15bMC05QS1aYS16Ol9cLV0rJC8udGVzdChvPWFbYl0pJiYhL15ffF9fJC8udGVzdChvKT9lKz0iLiIrbzptPUM7ZWxzZSBpZihiKzE8ZiYmIlsiPT09YVtiXSl7KytiO3ZhciBIPWFbYisrXS50b0xvd2VyQ2FzZSgpO289JC5tW3krIjo6IitIXTtvIT09K28mJihvPSQubVsiKjo6IitIXSk7dmFyIFc7CmQuaWE/KFc9ZC5pYSh5LEgpLCJzdHJpbmciIT09dHlwZW9mIFcmJihtPUMsVz1IKSxtJiZvIT09K28mJihvPSQuZC5OT05FKSk6KFc9SCxvIT09K28mJihtPUMpKTt2YXIgcD1IPSIiLGNhPUM7L15bfl4kKnxdPz0kLy50ZXN0KGFbYl0pJiYoSD1hW2IrK10scD1hW2IrK10sL15bMC05QS1aYS16Ol9cLV0rJC8udGVzdChwKT9wPSciJytwKyciJzoiXSI9PT1wJiYocD0nIiInLC0tYiksL14iKFteXCJcXF18XFwuKSoiJC8udGVzdChwKXx8KG09QyksKGNhPSJpIj09PWFbYl0pJiYrK2IpOyJdIiE9PWFbYl0mJigrK2IsbT1DKTtzd2l0Y2gobyl7Y2FzZSAkLmQuQ0xBU1NFUzpjYXNlICQuZC5MT0NBTF9OQU1FOmNhc2UgJC5kLk5PTkU6YnJlYWs7Y2FzZSAkLmQuR0xPQkFMX05BTUU6Y2FzZSAkLmQuSUQ6Y2FzZSAkLmQuSURSRUY6KCI9Ij09PUh8fCJ+PSI9PT1IfHwiJD0iPT09SCkmJiciIichPXAmJiFjYT9wPSciJytwLnN1YnN0cmluZygxLHAubGVuZ3RoLTEpK3YrJyInOiJ8PSI9PT0KSHx8IiI9PT1IfHwobT1DKTticmVhaztjYXNlICQuZC5VUkk6Y2FzZSAkLmQuVVJJX0ZSQUdNRU5UOiIiIT09SCYmKG09Qyk7YnJlYWs7ZGVmYXVsdDptPUN9bSYmKGkrPSJbIitXLnJlcGxhY2UoL1teXHctXS9nLCJcXCQmIikrSCtwKyhjYT8iIGldIjoiXSIpKX1lbHNlIGlmKGI8ZiYmIjoiPT09YVtiXSlpZihvPWFbKytiXSxrLnRlc3QobykpbCs9IjoiK287ZWxzZSBicmVhaztlbHNlIGJyZWFrO2IhPT1mJiYobT1DKTttJiYoYj0oeStlKS5yZXBsYWNlKC9bXiAuKiNcdy1dL2csIlxcJCYiKStpK2wrZykmJmoucHVzaChiKTtyZXR1cm4gbX0iICI9PT1hW2ldJiYrK2k7ci0xIT09aSYmIiAiPT09YVtyXSYmLS1yO2Zvcih2YXIgaj1bXSxsPWkscT1uLHU9aTtxJiZ1PHI7Kyt1KXt2YXIgQj1hW3VdO2lmKGZbQl09PT1mfHwiICI9PT1CKW8obCx1LEIpP2w9dSsxOnE9Q31vKGwsciwiIil8fChxPUMpO3JldHVybiBxPyhqLmxlbmd0aCYmKGw9ai5qb2luKCIiKSxlIT09cyYmKGw9Ii4iKwplKyIgIitsKSxOLnB1c2gobCkpLG4pOiFifHxiKGEuc2xpY2UoaSxyKSl9dmFyIGU9ZC5uYSx2PWQuTCx4PWQuQWEsTj1bXSx1PTAsaSxxPTAsQjtmb3IoaT0wO2k8YS5sZW5ndGg7KytpKWlmKEI9YVtpXSwiKCI9PUJ8fCJbIj09Qj8oKytxLG4pOiIpIj09Qnx8Il0iPT1CPyhxJiYtLXEsbik6ISgiICI9PWFbaV0mJihxfHxmW2FbaS0xXV09PT1mfHxmW2FbaSsxXV09PT1mKSkpYVt1KytdPWFbaV07YS5sZW5ndGg9dTt1PWEubGVuZ3RoO2ZvcihpPXE9MDtpPHU7KytpKWlmKCIsIj09PWFbaV0pe2lmKCFnKHEsaSkpcmV0dXJuIHM7cT1pKzF9cmV0dXJuIWcocSx1KT9zOk59OyhmdW5jdGlvbigpe3ZhciBhPS9eXHcvLGQ9UmVnRXhwKCJeKD86KD86KD86KD86b25seXxub3QpICk/KD86YWxsfGF1cmFsfGJyYWlsbGV8ZW1ib3NzZWR8aGFuZGhlbGR8cHJpbnR8cHJvamVjdGlvbnxzY3JlZW58c3BlZWNofHR0eXx0dil8XFwoICg/Oig/Om1pbi18bWF4LSk/KD86KD86ZGV2aWNlLSk/KD86YXNwZWN0LXJhdGlvfGhlaWdodHx3aWR0aCl8Y29sb3IoPzotaW5kZXgpP3xtb25vY2hyb21lfG9yaWVudGF0aW9ufHJlc29sdXRpb24pfGdyaWR8aG92ZXJ8bHVtaW5vc2l0eXxwb2ludGVyfHNjYW58c2NyaXB0KSAoPzo6IC0/KD86W2Etel1cXHcrKD86LVxcdyspKnxcXGQrKD86IC8gXFxkK3woPzpcXC5cXGQrKT8oPzpwW2N4dF18W2NlbV1tfGlufGRwaXxkcHB4fGRwY218JSk/KSkgKT9cXCkpKD86IGFuZCA/XFwoICg/Oig/Om1pbi18bWF4LSk/KD86KD86ZGV2aWNlLSk/KD86YXNwZWN0LXJhdGlvfGhlaWdodHx3aWR0aCl8Y29sb3IoPzotaW5kZXgpP3xtb25vY2hyb21lfG9yaWVudGF0aW9ufHJlc29sdXRpb24pfGdyaWR8aG92ZXJ8bHVtaW5vc2l0eXxwb2ludGVyfHNjYW58c2NyaXB0KSAoPzo6IC0/KD86W2Etel1cXHcrKD86LVxcdyspKnxcXGQrKD86IC8gXFxkK3woPzpcXC5cXGQrKT8oPzpwW2N4dF18W2NlbV1tfGlufGRwaXxkcHB4fGRwY218JSk/KSkgKT9cXCkpKikoPzogLCAoPzooPzooPzooPzpvbmx5fG5vdCkgKT8oPzphbGx8YXVyYWx8YnJhaWxsZXxlbWJvc3NlZHxoYW5kaGVsZHxwcmludHxwcm9qZWN0aW9ufHNjcmVlbnxzcGVlY2h8dHR5fHR2KXxcXCggKD86KD86bWluLXxtYXgtKT8oPzooPzpkZXZpY2UtKT8oPzphc3BlY3QtcmF0aW98aGVpZ2h0fHdpZHRoKXxjb2xvcig/Oi1pbmRleCk/fG1vbm9jaHJvbWV8b3JpZW50YXRpb258cmVzb2x1dGlvbil8Z3JpZHxob3ZlcnxsdW1pbm9zaXR5fHBvaW50ZXJ8c2NhbnxzY3JpcHQpICg/OjogLT8oPzpbYS16XVxcdysoPzotXFx3KykqfFxcZCsoPzogLyBcXGQrfCg/OlxcLlxcZCspPyg/OnBbY3h0XXxbY2VtXW18aW58ZHBpfGRwcHh8ZHBjbXwlKT8pKSApP1xcKSkoPzogYW5kID9cXCggKD86KD86bWluLXxtYXgtKT8oPzooPzpkZXZpY2UtKT8oPzphc3BlY3QtcmF0aW98aGVpZ2h0fHdpZHRoKXxjb2xvcig/Oi1pbmRleCk/fG1vbm9jaHJvbWV8b3JpZW50YXRpb258cmVzb2x1dGlvbil8Z3JpZHxob3ZlcnxsdW1pbm9zaXR5fHBvaW50ZXJ8c2NhbnxzY3JpcHQpICg/OjogLT8oPzpbYS16XVxcdysoPzotXFx3KykqfFxcZCsoPzogLyBcXGQrfCg/OlxcLlxcZCspPyg/OnBbY3h0XXxbY2VtXW18aW58ZHBpfGRwcHh8ZHBjbXwlKT8pKSApP1xcKSkqKSkqJCIsCiJpIik7Wj1mdW5jdGlvbihiKXtmb3IodmFyIGI9Yi5zbGljZSgpLGY9Yi5sZW5ndGgsZz0wLGs9MDtrPGY7KytrKXt2YXIgZT1iW2tdOyIgIiE9ZSYmKGJbZysrXT1lKX1iLmxlbmd0aD1nO2I9Yi5qb2luKCIgIik7cmV0dXJuIGI9IWIubGVuZ3RoPyIiOiFkLnRlc3QoYik/Im5vdCBhbGwiOmEudGVzdChiKT9iOiJub3QgYWxsICwgIitifX0pKCk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShiKXt2YXIgZD0vXlxzKlsnXShbXiddKilbJ11ccyokLyxmPS9eXHMqdXJsXHMqWyhdWyJdKFteIl0qKVsiXVspXVxzKiQvLGc9L15ccyp1cmxccypbKF1bJ10oW14nXSopWyddWyldXHMqJC8saD0vXlxzKnVybFxzKlsoXShbXildKilbKV1ccyokLyxrO3JldHVybihrPS9eXHMqWyJdKFteIl0qKVsiXVxzKiQvLmV4ZWMoYikpfHwoaz1kLmV4ZWMoYikpfHwoaz1mLmV4ZWMoYikpfHwoaz1nLmV4ZWMoYikpfHwoaz1oLmV4ZWMoYikpP2tbMV06c31mdW5jdGlvbiBiKGYsZyxrLGUsdix3LHUpe2Z1bmN0aW9uIGkoKXtyPQpGLmxlbmd0aCYmRltGLmxlbmd0aC0xXT09PXN9dmFyIHE9YyxCPXV8fFswXSxGPVtdLHI9QztmYShnLHtzdGFydFN0eWxlc2hlZXQ6ZnVuY3Rpb24oKXtxPVtdfSxlbmRTdHlsZXNoZWV0OmZ1bmN0aW9uKCl7fSxzdGFydEF0cnVsZTpmdW5jdGlvbihnLGope2lmKHIpZz1zO2Vsc2UgaWYoIkBtZWRpYSI9PT1nKXEucHVzaCgiQG1lZGlhIiwiICIsWihqKSk7ZWxzZSBpZigiQGtleWZyYW1lcyI9PT1nfHwiQC13ZWJraXQta2V5ZnJhbWVzIj09PWcpe3ZhciBpPWpbMF07MT09PWoubGVuZ3RoJiYhL19fJHxbXlx3XC1dLy50ZXN0KGkpPyhxLnB1c2goZywiICIsaStrLkwpLGc9IkBrZXlmcmFtZXMiKTpnPXN9ZWxzZSBpZigiQGltcG9ydCI9PT1nJiYwPGoubGVuZ3RoKWlmKGc9cywiZnVuY3Rpb24iPT09dHlwZW9mIHcpe3ZhciBsPVooai5zbGljZSgxKSk7aWYoIm5vdCBhbGwiIT09bCl7KytCWzBdO3ZhciB1PVtdO3EucHVzaCh1KTt2YXIgRT14KE0oZixhKGpbMF0pKSxmdW5jdGlvbihhKXt2YXIgZj0KYihFLGEucWEsayxlLHYsdyxCKTstLUJbMF07YT1sP3t0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiJAbWVkaWEgIitsKyIgeyIrZi5yZXN1bHQrIn0ifX06Zi5yZXN1bHQ7dVswXT1hO3coYSwhIUJbMF0pfSx2KX19ZWxzZSB3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nKCJAaW1wb3J0ICIrai5qb2luKCIgIikrIiBlbGlkZWQiKTtyPSFnO0YucHVzaChnKX0sZW5kQXRydWxlOmZ1bmN0aW9uKCl7Ri5wb3AoKTtyfHxxLnB1c2goIjsiKTtpKCl9LHN0YXJ0QmxvY2s6ZnVuY3Rpb24oKXtyfHxxLnB1c2goInsiKX0sZW5kQmxvY2s6ZnVuY3Rpb24oKXtyfHwocS5wdXNoKCJ9Iikscj1uKX0sc3RhcnRSdWxlc2V0OmZ1bmN0aW9uKGEpe2lmKCFyKXt2YXIgYj1jOyJAa2V5ZnJhbWVzIj09PUZbRi5sZW5ndGgtMV0/KGI9YS5qb2luKCIgIikubWF0Y2goL14gKig/OmZyb218dG98XGQrKD86XC5cZCspPyUpICooPzosICooPzpmcm9tfHRvfFxkKyg/OlwuXGQrKT8lKSAqKSokL2kpLApyPSFiLGImJihiPWJbMF0ucmVwbGFjZSgvICsvZywiIikpKTooYT1iYShhLGspLCFhfHwhYS5sZW5ndGg/cj1uOmI9YS5qb2luKCIsICIpKTtyfHxxLnB1c2goYiwieyIpfUYucHVzaChzKX0sZW5kUnVsZXNldDpmdW5jdGlvbigpe0YucG9wKCk7cnx8cS5wdXNoKCJ9Iik7aSgpfSxkZWNsYXJhdGlvbjpmdW5jdGlvbihhLGIpe2lmKCFyKXt2YXIgZD1DLGc9Yi5sZW5ndGg7Mjw9ZyYmIiEiPT09YltnLTJdJiYiaW1wb3J0YW50Ij09PWJbZy0xXS50b0xvd2VyQ2FzZSgpJiYoZD1uLGIubGVuZ3RoLT0yKTthYShhLGIsZSxmLGsuTCk7Yi5sZW5ndGgmJnEucHVzaChhLCI6IixiLmpvaW4oIiAiKSxkPyIgIWltcG9ydGFudDsiOiI7Iil9fX0pO3JldHVybntyZXN1bHQ6e3RvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHEuam9pbigiIil9fSx2YTohIUJbMF19fWRhPWZ1bmN0aW9uKGEsZixnLGspe3JldHVybiBiKGEsZixnLGssYyxjKS5yZXN1bHQudG9TdHJpbmcoKX19KSgpfSkoKTsKInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93JiYod2luZG93LnNhbml0aXplQ3NzUHJvcGVydHk9YWEsd2luZG93LnNhbml0aXplQ3NzU2VsZWN0b3JMaXN0PWJhLHdpbmRvdy5zYW5pdGl6ZVN0eWxlc2hlZXQ9ZGEsd2luZG93LnNhbml0aXplTWVkaWFRdWVyeT1aKTt2YXIgZmEsZ2E7CihmdW5jdGlvbigpe2Z1bmN0aW9uIGcoYixhLGcsZixoKXtmb3IodmFyIGQ9YSsrO2E8ZyYmInsiIT09YlthXSYmIjsiIT09YlthXTspKythO2lmKGE8ZyYmKGh8fCI7Ij09PWJbYV0pKXt2YXIgaD1kKzEsZT1hO2g8ZyYmIiAiPT09YltoXSYmKytoO2U+aCYmIiAiPT09YltlLTFdJiYtLWU7Zi5zdGFydEF0cnVsZSYmZi5zdGFydEF0cnVsZShiW2RdLnRvTG93ZXJDYXNlKCksYi5zbGljZShoLGUpKTthPSJ7Ij09PWJbYV0/dyhiLGEsZyxmKTphKzE7Zi5lbmRBdHJ1bGUmJmYuZW5kQXRydWxlKCl9cmV0dXJuIGF9ZnVuY3Rpb24gdyhiLGEsayxmKXsrK2E7Zm9yKGYuc3RhcnRCbG9jayYmZi5zdGFydEJsb2NrKCk7YTxrOyl7dmFyIGg9YlthXS5jaGFyQXQoMCk7aWYoIn0iPT1oKXsrK2E7YnJlYWt9YT0iICI9PT1ofHwiOyI9PT1oP2ErMToiQCI9PT1oP2coYixhLGssZixDKToieyI9PT1oP3coYixhLGssZik6TShiLGEsayxmKX1mLmVuZEJsb2NrJiZmLmVuZEJsb2NrKCk7cmV0dXJuIGF9CmZ1bmN0aW9uIE0oYixhLGcsZil7dmFyIGg9YSxkPXgoYixhLGcsbik7aWYoMD5kKXJldHVybiBkPX5kLGQ9PT1oP2QrMTpkO3ZhciB5PWJbZF07aWYoInsiIT09eSlyZXR1cm4gZD09PWg/ZCsxOmQ7YT1kKzE7ZD5oJiYiICI9PT1iW2QtMV0mJi0tZDtmb3IoZi5zdGFydFJ1bGVzZXQmJmYuc3RhcnRSdWxlc2V0KGIuc2xpY2UoaCxkKSk7YTxnOyl7eT1iW2FdO2lmKCJ9Ij09PXkpeysrYTticmVha31hPSIgIj09PXk/YSsxOmUoYixhLGcsZil9Zi5lbmRSdWxlc2V0JiZmLmVuZFJ1bGVzZXQoKTtyZXR1cm4gYX1mdW5jdGlvbiB4KGIsYSxnLGYpe2Zvcih2YXIgaCxkPVtdLGU9LTE7YTxnOysrYSlpZihoPWJbYV0uY2hhckF0KDApLCJbIj09PWh8fCIoIj09PWgpZFsrK2VdPWg7ZWxzZSBpZigiXSI9PT1oJiYiWyI9PT1kW2VdfHwiKSI9PT1oJiYiKCI9PT1kW2VdKS0tZTtlbHNlIGlmKCJ7Ij09PWh8fCJ9Ij09PWh8fCI7Ij09PWh8fCJAIj09PWh8fCI6Ij09PWgmJiFmKWJyZWFrOzA8PQplJiYoYT1+KGErMSkpO3JldHVybiBhfWZ1bmN0aW9uIEUoYixhLGcpe2Zvcig7YTxnJiYiOyIhPT1iW2FdJiYifSIhPT1iW2FdOykrK2E7cmV0dXJuIGE8ZyYmIjsiPT09YlthXT9hKzE6YX1mdW5jdGlvbiBlKGIsYSxnLGYpe3ZhciBoPWJbYSsrXTtpZighdi50ZXN0KGgpKXJldHVybiBFKGIsYSxnKTthPGcmJiIgIj09PWJbYV0mJisrYTtpZihhPT1nfHwiOiIhPT1iW2FdKXJldHVybiBFKGIsYSxnKTsrK2E7YTxnJiYiICI9PT1iW2FdJiYrK2E7dmFyIGQ9eChiLGEsZyxDKTtpZigwPmQpZD1+ZDtlbHNle2Zvcih2YXIgZT1bXSxsPTAsdz1hO3c8ZDsrK3cpYT1iW3ddLCIgIiE9PWEmJihlW2wrK109YSk7aWYoZDxnKXtkb3thPWJbZF07aWYoIjsiPT09YXx8In0iPT09YSlicmVhaztsPTB9d2hpbGUoKytkPGcpOyI7Ij09PWEmJisrZH1sJiZmLmRlY2xhcmF0aW9uJiZmLmRlY2xhcmF0aW9uKGgudG9Mb3dlckNhc2UoKSxlKX1yZXR1cm4gZH1mYT1mdW5jdGlvbihiLGEpe3ZhciBlPVUoYik7CmEuc3RhcnRTdHlsZXNoZWV0JiZhLnN0YXJ0U3R5bGVzaGVldCgpO2Zvcih2YXIgZj0wLGg9ZS5sZW5ndGg7ZjxoOylmPSIgIj09PWVbZl0/ZisxOmY8aD8iQCI9PT1lW2ZdLmNoYXJBdCgwKT9nKGUsZixoLGEsbik6TShlLGYsaCxhKTpmO2EuZW5kU3R5bGVzaGVldCYmYS5lbmRTdHlsZXNoZWV0KCl9O3ZhciB2PS9eLT9bYS16XS9pO2dhPWZ1bmN0aW9uKGIsYSl7Zm9yKHZhciBnPVUoYiksZj0wLGg9Zy5sZW5ndGg7ZjxoOylmPSIgIiE9PWdbZl0/ZShnLGYsaCxhKTpmKzF9fSkoKTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cmJih3aW5kb3cucGFyc2VDc3NTdHlsZXNoZWV0PWZhLHdpbmRvdy5wYXJzZUNzc0RlY2xhcmF0aW9ucz1nYSk7dmFyICQ9e2Q6e05PTkU6MCxVUkk6MSxVUklfRlJBR01FTlQ6MTEsU0NSSVBUOjIsU1RZTEU6MyxIVE1MOjEyLElEOjQsSURSRUY6NSxJRFJFRlM6NixHTE9CQUxfTkFNRTo3LExPQ0FMX05BTUU6OCxDTEFTU0VTOjksRlJBTUVfVEFSR0VUOjEwLE1FRElBX1FVRVJZOjEzfX07JC5hdHlwZT0kLmQ7CiQubT17Iio6OmNsYXNzIjo5LCIqOjpkaXIiOjAsIio6OmRyYWdnYWJsZSI6MCwiKjo6aGlkZGVuIjowLCIqOjppZCI6NCwiKjo6aW5lcnQiOjAsIio6Oml0ZW1wcm9wIjowLCIqOjppdGVtcmVmIjo2LCIqOjppdGVtc2NvcGUiOjAsIio6OmxhbmciOjAsIio6Om9uYmx1ciI6MiwiKjo6b25jaGFuZ2UiOjIsIio6Om9uY2xpY2siOjIsIio6Om9uZGJsY2xpY2siOjIsIio6Om9uZXJyb3IiOjIsIio6Om9uZm9jdXMiOjIsIio6Om9ua2V5ZG93biI6MiwiKjo6b25rZXlwcmVzcyI6MiwiKjo6b25rZXl1cCI6MiwiKjo6b25sb2FkIjoyLCIqOjpvbm1vdXNlZG93biI6MiwiKjo6b25tb3VzZW1vdmUiOjIsIio6Om9ubW91c2VvdXQiOjIsIio6Om9ubW91c2VvdmVyIjoyLCIqOjpvbm1vdXNldXAiOjIsIio6Om9ucmVzZXQiOjIsIio6Om9uc2Nyb2xsIjoyLCIqOjpvbnNlbGVjdCI6MiwiKjo6b25zdWJtaXQiOjIsIio6Om9udG91Y2hjYW5jZWwiOjIsIio6Om9udG91Y2hlbmQiOjIsIio6Om9udG91Y2hlbnRlciI6MiwKIio6Om9udG91Y2hsZWF2ZSI6MiwiKjo6b250b3VjaG1vdmUiOjIsIio6Om9udG91Y2hzdGFydCI6MiwiKjo6b251bmxvYWQiOjIsIio6OnNwZWxsY2hlY2siOjAsIio6OnN0eWxlIjozLCIqOjp0YWJpbmRleCI6MCwiKjo6dGl0bGUiOjAsIio6OnRyYW5zbGF0ZSI6MCwiYTo6YWNjZXNza2V5IjowLCJhOjpjb29yZHMiOjAsImE6OmhyZWYiOjEsImE6OmhyZWZsYW5nIjowLCJhOjpuYW1lIjo3LCJhOjpvbmJsdXIiOjIsImE6Om9uZm9jdXMiOjIsImE6OnNoYXBlIjowLCJhOjp0YXJnZXQiOjEwLCJhOjp0eXBlIjowLCJhcmVhOjphY2Nlc3NrZXkiOjAsImFyZWE6OmFsdCI6MCwiYXJlYTo6Y29vcmRzIjowLCJhcmVhOjpocmVmIjoxLCJhcmVhOjpub2hyZWYiOjAsImFyZWE6Om9uYmx1ciI6MiwiYXJlYTo6b25mb2N1cyI6MiwiYXJlYTo6c2hhcGUiOjAsImFyZWE6OnRhcmdldCI6MTAsImF1ZGlvOjpjb250cm9scyI6MCwiYXVkaW86Omxvb3AiOjAsImF1ZGlvOjptZWRpYWdyb3VwIjo1LAoiYXVkaW86Om11dGVkIjowLCJhdWRpbzo6cHJlbG9hZCI6MCwiYXVkaW86OnNyYyI6MSwiYmRvOjpkaXIiOjAsImJsb2NrcXVvdGU6OmNpdGUiOjEsImJyOjpjbGVhciI6MCwiYnV0dG9uOjphY2Nlc3NrZXkiOjAsImJ1dHRvbjo6ZGlzYWJsZWQiOjAsImJ1dHRvbjo6bmFtZSI6OCwiYnV0dG9uOjpvbmJsdXIiOjIsImJ1dHRvbjo6b25mb2N1cyI6MiwiYnV0dG9uOjp0eXBlIjowLCJidXR0b246OnZhbHVlIjowLCJjYW52YXM6OmhlaWdodCI6MCwiY2FudmFzOjp3aWR0aCI6MCwiY2FwdGlvbjo6YWxpZ24iOjAsImNvbDo6YWxpZ24iOjAsImNvbDo6Y2hhciI6MCwiY29sOjpjaGFyb2ZmIjowLCJjb2w6OnNwYW4iOjAsImNvbDo6dmFsaWduIjowLCJjb2w6OndpZHRoIjowLCJjb2xncm91cDo6YWxpZ24iOjAsImNvbGdyb3VwOjpjaGFyIjowLCJjb2xncm91cDo6Y2hhcm9mZiI6MCwiY29sZ3JvdXA6OnNwYW4iOjAsImNvbGdyb3VwOjp2YWxpZ24iOjAsImNvbGdyb3VwOjp3aWR0aCI6MCwKImNvbW1hbmQ6OmNoZWNrZWQiOjAsImNvbW1hbmQ6OmNvbW1hbmQiOjUsImNvbW1hbmQ6OmRpc2FibGVkIjowLCJjb21tYW5kOjppY29uIjoxLCJjb21tYW5kOjpsYWJlbCI6MCwiY29tbWFuZDo6cmFkaW9ncm91cCI6MCwiY29tbWFuZDo6dHlwZSI6MCwiZGF0YTo6dmFsdWUiOjAsImRlbDo6Y2l0ZSI6MSwiZGVsOjpkYXRldGltZSI6MCwiZGV0YWlsczo6b3BlbiI6MCwiZGlyOjpjb21wYWN0IjowLCJkaXY6OmFsaWduIjowLCJkbDo6Y29tcGFjdCI6MCwiZmllbGRzZXQ6OmRpc2FibGVkIjowLCJmb250Ojpjb2xvciI6MCwiZm9udDo6ZmFjZSI6MCwiZm9udDo6c2l6ZSI6MCwiZm9ybTo6YWNjZXB0IjowLCJmb3JtOjphY3Rpb24iOjEsImZvcm06OmF1dG9jb21wbGV0ZSI6MCwiZm9ybTo6ZW5jdHlwZSI6MCwiZm9ybTo6bWV0aG9kIjowLCJmb3JtOjpuYW1lIjo3LCJmb3JtOjpub3ZhbGlkYXRlIjowLCJmb3JtOjpvbnJlc2V0IjoyLCJmb3JtOjpvbnN1Ym1pdCI6MiwiZm9ybTo6dGFyZ2V0IjoxMCwKImgxOjphbGlnbiI6MCwiaDI6OmFsaWduIjowLCJoMzo6YWxpZ24iOjAsImg0OjphbGlnbiI6MCwiaDU6OmFsaWduIjowLCJoNjo6YWxpZ24iOjAsImhyOjphbGlnbiI6MCwiaHI6Om5vc2hhZGUiOjAsImhyOjpzaXplIjowLCJocjo6d2lkdGgiOjAsImlmcmFtZTo6YWxpZ24iOjAsImlmcmFtZTo6ZnJhbWVib3JkZXIiOjAsImlmcmFtZTo6aGVpZ2h0IjowLCJpZnJhbWU6Om1hcmdpbmhlaWdodCI6MCwiaWZyYW1lOjptYXJnaW53aWR0aCI6MCwiaWZyYW1lOjp3aWR0aCI6MCwiaW1nOjphbGlnbiI6MCwiaW1nOjphbHQiOjAsImltZzo6Ym9yZGVyIjowLCJpbWc6OmhlaWdodCI6MCwiaW1nOjpoc3BhY2UiOjAsImltZzo6aXNtYXAiOjAsImltZzo6bmFtZSI6NywiaW1nOjpzcmMiOjEsImltZzo6dXNlbWFwIjoxMSwiaW1nOjp2c3BhY2UiOjAsImltZzo6d2lkdGgiOjAsImlucHV0OjphY2NlcHQiOjAsImlucHV0OjphY2Nlc3NrZXkiOjAsImlucHV0OjphbGlnbiI6MCwiaW5wdXQ6OmFsdCI6MCwKImlucHV0OjphdXRvY29tcGxldGUiOjAsImlucHV0OjpjaGVja2VkIjowLCJpbnB1dDo6ZGlzYWJsZWQiOjAsImlucHV0OjppbnB1dG1vZGUiOjAsImlucHV0Ojppc21hcCI6MCwiaW5wdXQ6Omxpc3QiOjUsImlucHV0OjptYXgiOjAsImlucHV0OjptYXhsZW5ndGgiOjAsImlucHV0OjptaW4iOjAsImlucHV0OjptdWx0aXBsZSI6MCwiaW5wdXQ6Om5hbWUiOjgsImlucHV0OjpvbmJsdXIiOjIsImlucHV0OjpvbmNoYW5nZSI6MiwiaW5wdXQ6Om9uZm9jdXMiOjIsImlucHV0OjpvbnNlbGVjdCI6MiwiaW5wdXQ6OnBhdHRlcm4iOjAsImlucHV0OjpwbGFjZWhvbGRlciI6MCwiaW5wdXQ6OnJlYWRvbmx5IjowLCJpbnB1dDo6cmVxdWlyZWQiOjAsImlucHV0OjpzaXplIjowLCJpbnB1dDo6c3JjIjoxLCJpbnB1dDo6c3RlcCI6MCwiaW5wdXQ6OnR5cGUiOjAsImlucHV0Ojp1c2VtYXAiOjExLCJpbnB1dDo6dmFsdWUiOjAsImluczo6Y2l0ZSI6MSwiaW5zOjpkYXRldGltZSI6MCwibGFiZWw6OmFjY2Vzc2tleSI6MCwKImxhYmVsOjpmb3IiOjUsImxhYmVsOjpvbmJsdXIiOjIsImxhYmVsOjpvbmZvY3VzIjoyLCJsZWdlbmQ6OmFjY2Vzc2tleSI6MCwibGVnZW5kOjphbGlnbiI6MCwibGk6OnR5cGUiOjAsImxpOjp2YWx1ZSI6MCwibWFwOjpuYW1lIjo3LCJtZW51Ojpjb21wYWN0IjowLCJtZW51OjpsYWJlbCI6MCwibWVudTo6dHlwZSI6MCwibWV0ZXI6OmhpZ2giOjAsIm1ldGVyOjpsb3ciOjAsIm1ldGVyOjptYXgiOjAsIm1ldGVyOjptaW4iOjAsIm1ldGVyOjp2YWx1ZSI6MCwib2w6OmNvbXBhY3QiOjAsIm9sOjpyZXZlcnNlZCI6MCwib2w6OnN0YXJ0IjowLCJvbDo6dHlwZSI6MCwib3B0Z3JvdXA6OmRpc2FibGVkIjowLCJvcHRncm91cDo6bGFiZWwiOjAsIm9wdGlvbjo6ZGlzYWJsZWQiOjAsIm9wdGlvbjo6bGFiZWwiOjAsIm9wdGlvbjo6c2VsZWN0ZWQiOjAsIm9wdGlvbjo6dmFsdWUiOjAsIm91dHB1dDo6Zm9yIjo2LCJvdXRwdXQ6Om5hbWUiOjgsInA6OmFsaWduIjowLCJwcmU6OndpZHRoIjowLAoicHJvZ3Jlc3M6Om1heCI6MCwicHJvZ3Jlc3M6Om1pbiI6MCwicHJvZ3Jlc3M6OnZhbHVlIjowLCJxOjpjaXRlIjoxLCJzZWxlY3Q6OmF1dG9jb21wbGV0ZSI6MCwic2VsZWN0OjpkaXNhYmxlZCI6MCwic2VsZWN0OjptdWx0aXBsZSI6MCwic2VsZWN0OjpuYW1lIjo4LCJzZWxlY3Q6Om9uYmx1ciI6Miwic2VsZWN0OjpvbmNoYW5nZSI6Miwic2VsZWN0OjpvbmZvY3VzIjoyLCJzZWxlY3Q6OnJlcXVpcmVkIjowLCJzZWxlY3Q6OnNpemUiOjAsInNvdXJjZTo6dHlwZSI6MCwidGFibGU6OmFsaWduIjowLCJ0YWJsZTo6Ymdjb2xvciI6MCwidGFibGU6OmJvcmRlciI6MCwidGFibGU6OmNlbGxwYWRkaW5nIjowLCJ0YWJsZTo6Y2VsbHNwYWNpbmciOjAsInRhYmxlOjpmcmFtZSI6MCwidGFibGU6OnJ1bGVzIjowLCJ0YWJsZTo6c3VtbWFyeSI6MCwidGFibGU6OndpZHRoIjowLCJ0Ym9keTo6YWxpZ24iOjAsInRib2R5OjpjaGFyIjowLCJ0Ym9keTo6Y2hhcm9mZiI6MCwidGJvZHk6OnZhbGlnbiI6MCwKInRkOjphYmJyIjowLCJ0ZDo6YWxpZ24iOjAsInRkOjpheGlzIjowLCJ0ZDo6Ymdjb2xvciI6MCwidGQ6OmNoYXIiOjAsInRkOjpjaGFyb2ZmIjowLCJ0ZDo6Y29sc3BhbiI6MCwidGQ6OmhlYWRlcnMiOjYsInRkOjpoZWlnaHQiOjAsInRkOjpub3dyYXAiOjAsInRkOjpyb3dzcGFuIjowLCJ0ZDo6c2NvcGUiOjAsInRkOjp2YWxpZ24iOjAsInRkOjp3aWR0aCI6MCwidGV4dGFyZWE6OmFjY2Vzc2tleSI6MCwidGV4dGFyZWE6OmF1dG9jb21wbGV0ZSI6MCwidGV4dGFyZWE6OmNvbHMiOjAsInRleHRhcmVhOjpkaXNhYmxlZCI6MCwidGV4dGFyZWE6OmlucHV0bW9kZSI6MCwidGV4dGFyZWE6Om5hbWUiOjgsInRleHRhcmVhOjpvbmJsdXIiOjIsInRleHRhcmVhOjpvbmNoYW5nZSI6MiwidGV4dGFyZWE6Om9uZm9jdXMiOjIsInRleHRhcmVhOjpvbnNlbGVjdCI6MiwidGV4dGFyZWE6OnBsYWNlaG9sZGVyIjowLCJ0ZXh0YXJlYTo6cmVhZG9ubHkiOjAsInRleHRhcmVhOjpyZXF1aXJlZCI6MCwKInRleHRhcmVhOjpyb3dzIjowLCJ0ZXh0YXJlYTo6d3JhcCI6MCwidGZvb3Q6OmFsaWduIjowLCJ0Zm9vdDo6Y2hhciI6MCwidGZvb3Q6OmNoYXJvZmYiOjAsInRmb290Ojp2YWxpZ24iOjAsInRoOjphYmJyIjowLCJ0aDo6YWxpZ24iOjAsInRoOjpheGlzIjowLCJ0aDo6Ymdjb2xvciI6MCwidGg6OmNoYXIiOjAsInRoOjpjaGFyb2ZmIjowLCJ0aDo6Y29sc3BhbiI6MCwidGg6OmhlYWRlcnMiOjYsInRoOjpoZWlnaHQiOjAsInRoOjpub3dyYXAiOjAsInRoOjpyb3dzcGFuIjowLCJ0aDo6c2NvcGUiOjAsInRoOjp2YWxpZ24iOjAsInRoOjp3aWR0aCI6MCwidGhlYWQ6OmFsaWduIjowLCJ0aGVhZDo6Y2hhciI6MCwidGhlYWQ6OmNoYXJvZmYiOjAsInRoZWFkOjp2YWxpZ24iOjAsInRyOjphbGlnbiI6MCwidHI6OmJnY29sb3IiOjAsInRyOjpjaGFyIjowLCJ0cjo6Y2hhcm9mZiI6MCwidHI6OnZhbGlnbiI6MCwidHJhY2s6OmRlZmF1bHQiOjAsInRyYWNrOjpraW5kIjowLCJ0cmFjazo6bGFiZWwiOjAsCiJ0cmFjazo6c3JjbGFuZyI6MCwidWw6OmNvbXBhY3QiOjAsInVsOjp0eXBlIjowLCJ2aWRlbzo6Y29udHJvbHMiOjAsInZpZGVvOjpoZWlnaHQiOjAsInZpZGVvOjpsb29wIjowLCJ2aWRlbzo6bWVkaWFncm91cCI6NSwidmlkZW86Om11dGVkIjowLCJ2aWRlbzo6cG9zdGVyIjoxLCJ2aWRlbzo6cHJlbG9hZCI6MCwidmlkZW86OnNyYyI6MSwidmlkZW86OndpZHRoIjowfTskLkFUVFJJQlM9JC5tOyQuYz17T1BUSU9OQUxfRU5EVEFHOjEsRU1QVFk6MixDREFUQTo0LFJDREFUQTo4LFVOU0FGRToxNixGT0xEQUJMRTozMixTQ1JJUFQ6NjQsU1RZTEU6MTI4LFZJUlRVQUxJWkVEOjI1Nn07JC5lZmxhZ3M9JC5jOwokLmY9e2E6MCxhYmJyOjAsYWNyb255bTowLGFkZHJlc3M6MCxhcHBsZXQ6MjcyLGFyZWE6MixhcnRpY2xlOjAsYXNpZGU6MCxhdWRpbzowLGI6MCxiYXNlOjI3NCxiYXNlZm9udDoyNzQsYmRpOjAsYmRvOjAsYmlnOjAsYmxvY2txdW90ZTowLGJvZHk6MzA1LGJyOjIsYnV0dG9uOjAsY2FudmFzOjAsY2FwdGlvbjowLGNlbnRlcjowLGNpdGU6MCxjb2RlOjAsY29sOjIsY29sZ3JvdXA6MSxjb21tYW5kOjIsZGF0YTowLGRhdGFsaXN0OjAsZGQ6MSxkZWw6MCxkZXRhaWxzOjAsZGZuOjAsZGlhbG9nOjI3MixkaXI6MCxkaXY6MCxkbDowLGR0OjEsZW06MCxmaWVsZHNldDowLGZpZ2NhcHRpb246MCxmaWd1cmU6MCxmb250OjAsZm9vdGVyOjAsZm9ybTowLGZyYW1lOjI3NCxmcmFtZXNldDoyNzIsaDE6MCxoMjowLGgzOjAsaDQ6MCxoNTowLGg2OjAsaGVhZDozMDUsaGVhZGVyOjAsaGdyb3VwOjAsaHI6MixodG1sOjMwNSxpOjAsaWZyYW1lOjQsaW1nOjIsaW5wdXQ6MixpbnM6MCxpc2luZGV4OjI3NCwKa2JkOjAsa2V5Z2VuOjI3NCxsYWJlbDowLGxlZ2VuZDowLGxpOjEsbGluazoyNzQsbWFwOjAsbWFyazowLG1lbnU6MCxtZXRhOjI3NCxtZXRlcjowLG5hdjowLG5vYnI6MCxub2VtYmVkOjI3Nixub2ZyYW1lczoyNzYsbm9zY3JpcHQ6Mjc2LG9iamVjdDoyNzIsb2w6MCxvcHRncm91cDowLG9wdGlvbjoxLG91dHB1dDowLHA6MSxwYXJhbToyNzQscHJlOjAscHJvZ3Jlc3M6MCxxOjAsczowLHNhbXA6MCxzY3JpcHQ6ODQsc2VjdGlvbjowLHNlbGVjdDowLHNtYWxsOjAsc291cmNlOjIsc3BhbjowLHN0cmlrZTowLHN0cm9uZzowLHN0eWxlOjE0OCxzdWI6MCxzdW1tYXJ5OjAsc3VwOjAsdGFibGU6MCx0Ym9keToxLHRkOjEsdGV4dGFyZWE6OCx0Zm9vdDoxLHRoOjEsdGhlYWQ6MSx0aW1lOjAsdGl0bGU6MjgwLHRyOjEsdHJhY2s6Mix0dDowLHU6MCx1bDowLCJ2YXIiOjAsdmlkZW86MCx3YnI6Mn07JC5FTEVNRU5UUz0kLmY7CiQuUT17YToiSFRNTEFuY2hvckVsZW1lbnQiLGFiYnI6IkhUTUxFbGVtZW50IixhY3JvbnltOiJIVE1MRWxlbWVudCIsYWRkcmVzczoiSFRNTEVsZW1lbnQiLGFwcGxldDoiSFRNTEFwcGxldEVsZW1lbnQiLGFyZWE6IkhUTUxBcmVhRWxlbWVudCIsYXJ0aWNsZToiSFRNTEVsZW1lbnQiLGFzaWRlOiJIVE1MRWxlbWVudCIsYXVkaW86IkhUTUxBdWRpb0VsZW1lbnQiLGI6IkhUTUxFbGVtZW50IixiYXNlOiJIVE1MQmFzZUVsZW1lbnQiLGJhc2Vmb250OiJIVE1MQmFzZUZvbnRFbGVtZW50IixiZGk6IkhUTUxFbGVtZW50IixiZG86IkhUTUxFbGVtZW50IixiaWc6IkhUTUxFbGVtZW50IixibG9ja3F1b3RlOiJIVE1MUXVvdGVFbGVtZW50Iixib2R5OiJIVE1MQm9keUVsZW1lbnQiLGJyOiJIVE1MQlJFbGVtZW50IixidXR0b246IkhUTUxCdXR0b25FbGVtZW50IixjYW52YXM6IkhUTUxDYW52YXNFbGVtZW50IixjYXB0aW9uOiJIVE1MVGFibGVDYXB0aW9uRWxlbWVudCIsY2VudGVyOiJIVE1MRWxlbWVudCIsCmNpdGU6IkhUTUxFbGVtZW50Iixjb2RlOiJIVE1MRWxlbWVudCIsY29sOiJIVE1MVGFibGVDb2xFbGVtZW50Iixjb2xncm91cDoiSFRNTFRhYmxlQ29sRWxlbWVudCIsY29tbWFuZDoiSFRNTENvbW1hbmRFbGVtZW50IixkYXRhOiJIVE1MRWxlbWVudCIsZGF0YWxpc3Q6IkhUTUxEYXRhTGlzdEVsZW1lbnQiLGRkOiJIVE1MRWxlbWVudCIsZGVsOiJIVE1MTW9kRWxlbWVudCIsZGV0YWlsczoiSFRNTERldGFpbHNFbGVtZW50IixkZm46IkhUTUxFbGVtZW50IixkaWFsb2c6IkhUTUxEaWFsb2dFbGVtZW50IixkaXI6IkhUTUxEaXJlY3RvcnlFbGVtZW50IixkaXY6IkhUTUxEaXZFbGVtZW50IixkbDoiSFRNTERMaXN0RWxlbWVudCIsZHQ6IkhUTUxFbGVtZW50IixlbToiSFRNTEVsZW1lbnQiLGZpZWxkc2V0OiJIVE1MRmllbGRTZXRFbGVtZW50IixmaWdjYXB0aW9uOiJIVE1MRWxlbWVudCIsZmlndXJlOiJIVE1MRWxlbWVudCIsZm9udDoiSFRNTEZvbnRFbGVtZW50Iixmb290ZXI6IkhUTUxFbGVtZW50IiwKZm9ybToiSFRNTEZvcm1FbGVtZW50IixmcmFtZToiSFRNTEZyYW1lRWxlbWVudCIsZnJhbWVzZXQ6IkhUTUxGcmFtZVNldEVsZW1lbnQiLGgxOiJIVE1MSGVhZGluZ0VsZW1lbnQiLGgyOiJIVE1MSGVhZGluZ0VsZW1lbnQiLGgzOiJIVE1MSGVhZGluZ0VsZW1lbnQiLGg0OiJIVE1MSGVhZGluZ0VsZW1lbnQiLGg1OiJIVE1MSGVhZGluZ0VsZW1lbnQiLGg2OiJIVE1MSGVhZGluZ0VsZW1lbnQiLGhlYWQ6IkhUTUxIZWFkRWxlbWVudCIsaGVhZGVyOiJIVE1MRWxlbWVudCIsaGdyb3VwOiJIVE1MRWxlbWVudCIsaHI6IkhUTUxIUkVsZW1lbnQiLGh0bWw6IkhUTUxIdG1sRWxlbWVudCIsaToiSFRNTEVsZW1lbnQiLGlmcmFtZToiSFRNTElGcmFtZUVsZW1lbnQiLGltZzoiSFRNTEltYWdlRWxlbWVudCIsaW5wdXQ6IkhUTUxJbnB1dEVsZW1lbnQiLGluczoiSFRNTE1vZEVsZW1lbnQiLGlzaW5kZXg6IkhUTUxVbmtub3duRWxlbWVudCIsa2JkOiJIVE1MRWxlbWVudCIsa2V5Z2VuOiJIVE1MS2V5Z2VuRWxlbWVudCIsCmxhYmVsOiJIVE1MTGFiZWxFbGVtZW50IixsZWdlbmQ6IkhUTUxMZWdlbmRFbGVtZW50IixsaToiSFRNTExJRWxlbWVudCIsbGluazoiSFRNTExpbmtFbGVtZW50IixtYXA6IkhUTUxNYXBFbGVtZW50IixtYXJrOiJIVE1MRWxlbWVudCIsbWVudToiSFRNTE1lbnVFbGVtZW50IixtZXRhOiJIVE1MTWV0YUVsZW1lbnQiLG1ldGVyOiJIVE1MTWV0ZXJFbGVtZW50IixuYXY6IkhUTUxFbGVtZW50Iixub2JyOiJIVE1MRWxlbWVudCIsbm9lbWJlZDoiSFRNTEVsZW1lbnQiLG5vZnJhbWVzOiJIVE1MRWxlbWVudCIsbm9zY3JpcHQ6IkhUTUxFbGVtZW50IixvYmplY3Q6IkhUTUxPYmplY3RFbGVtZW50IixvbDoiSFRNTE9MaXN0RWxlbWVudCIsb3B0Z3JvdXA6IkhUTUxPcHRHcm91cEVsZW1lbnQiLG9wdGlvbjoiSFRNTE9wdGlvbkVsZW1lbnQiLG91dHB1dDoiSFRNTE91dHB1dEVsZW1lbnQiLHA6IkhUTUxQYXJhZ3JhcGhFbGVtZW50IixwYXJhbToiSFRNTFBhcmFtRWxlbWVudCIscHJlOiJIVE1MUHJlRWxlbWVudCIsCnByb2dyZXNzOiJIVE1MUHJvZ3Jlc3NFbGVtZW50IixxOiJIVE1MUXVvdGVFbGVtZW50IixzOiJIVE1MRWxlbWVudCIsc2FtcDoiSFRNTEVsZW1lbnQiLHNjcmlwdDoiSFRNTFNjcmlwdEVsZW1lbnQiLHNlY3Rpb246IkhUTUxFbGVtZW50IixzZWxlY3Q6IkhUTUxTZWxlY3RFbGVtZW50IixzbWFsbDoiSFRNTEVsZW1lbnQiLHNvdXJjZToiSFRNTFNvdXJjZUVsZW1lbnQiLHNwYW46IkhUTUxTcGFuRWxlbWVudCIsc3RyaWtlOiJIVE1MRWxlbWVudCIsc3Ryb25nOiJIVE1MRWxlbWVudCIsc3R5bGU6IkhUTUxTdHlsZUVsZW1lbnQiLHN1YjoiSFRNTEVsZW1lbnQiLHN1bW1hcnk6IkhUTUxFbGVtZW50IixzdXA6IkhUTUxFbGVtZW50Iix0YWJsZToiSFRNTFRhYmxlRWxlbWVudCIsdGJvZHk6IkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50Iix0ZDoiSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50Iix0ZXh0YXJlYToiSFRNTFRleHRBcmVhRWxlbWVudCIsdGZvb3Q6IkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50IiwKdGg6IkhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50Iix0aGVhZDoiSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQiLHRpbWU6IkhUTUxUaW1lRWxlbWVudCIsdGl0bGU6IkhUTUxUaXRsZUVsZW1lbnQiLHRyOiJIVE1MVGFibGVSb3dFbGVtZW50Iix0cmFjazoiSFRNTFRyYWNrRWxlbWVudCIsdHQ6IkhUTUxFbGVtZW50Iix1OiJIVE1MRWxlbWVudCIsdWw6IkhUTUxVTGlzdEVsZW1lbnQiLCJ2YXIiOiJIVE1MRWxlbWVudCIsdmlkZW86IkhUTUxWaWRlb0VsZW1lbnQiLHdicjoiSFRNTEVsZW1lbnQifTskLkVMRU1FTlRfRE9NX0lOVEVSRkFDRVM9JC5ROyQuUD17Tk9UX0xPQURFRDowLFNBTUVfRE9DVU1FTlQ6MSxORVdfRE9DVU1FTlQ6Mn07JC51ZWZmZWN0cz0kLlA7CiQuSj17ImE6OmhyZWYiOjIsImFyZWE6OmhyZWYiOjIsImF1ZGlvOjpzcmMiOjEsImJsb2NrcXVvdGU6OmNpdGUiOjAsImNvbW1hbmQ6Omljb24iOjEsImRlbDo6Y2l0ZSI6MCwiZm9ybTo6YWN0aW9uIjoyLCJpbWc6OnNyYyI6MSwiaW5wdXQ6OnNyYyI6MSwiaW5zOjpjaXRlIjowLCJxOjpjaXRlIjowLCJ2aWRlbzo6cG9zdGVyIjoxLCJ2aWRlbzo6c3JjIjoxfTskLlVSSUVGRkVDVFM9JC5KOyQuTT17VU5TQU5EQk9YRUQ6MixTQU5EQk9YRUQ6MSxEQVRBOjB9OyQubHR5cGVzPSQuTTskLkk9eyJhOjpocmVmIjoyLCJhcmVhOjpocmVmIjoyLCJhdWRpbzo6c3JjIjoyLCJibG9ja3F1b3RlOjpjaXRlIjoyLCJjb21tYW5kOjppY29uIjoxLCJkZWw6OmNpdGUiOjIsImZvcm06OmFjdGlvbiI6MiwiaW1nOjpzcmMiOjEsImlucHV0OjpzcmMiOjEsImluczo6Y2l0ZSI6MiwicTo6Y2l0ZSI6MiwidmlkZW86OnBvc3RlciI6MSwidmlkZW86OnNyYyI6Mn07JC5MT0FERVJUWVBFUz0kLkk7CiJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5odG1sND0kKTt2YXIgaGE9ZnVuY3Rpb24oZyl7ZnVuY3Rpb24gdyhhKXtpZihpLmhhc093blByb3BlcnR5KGEpKXJldHVybiBpW2FdO3ZhciBiPWEubWF0Y2gocSk7cmV0dXJuIGI/U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChiWzFdLDEwKSk6KGI9YS5tYXRjaChCKSk/U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChiWzFdLDE2KSk6ciYmRi50ZXN0KGEpPyhyLmlubmVySFRNTD0iJiIrYSsiOyIsYj1yLnRleHRDb250ZW50LGlbYV09Yik6IiYiK2ErIjsifWZ1bmN0aW9uIE0oYSxiKXtyZXR1cm4gdyhiKX1mdW5jdGlvbiB4KGEpe3JldHVybiBhLnJlcGxhY2UoaixNKX1mdW5jdGlvbiBFKGEpe3JldHVybigiIithKS5yZXBsYWNlKFIsIiZhbXA7IikucmVwbGFjZShQLCImbHQ7IikucmVwbGFjZShTLCImZ3Q7IikucmVwbGFjZShELCImIzM0OyIpfWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGEucmVwbGFjZShpYSwiJmFtcDskMSIpLnJlcGxhY2UoUCwiJmx0OyIpLnJlcGxhY2UoUywiJmd0OyIpfQpmdW5jdGlvbiB2KGIpe3ZhciBkPXt6OmIuenx8Yi5jZGF0YSxBOmIuQXx8Yi5jb21tZW50LEI6Yi5CfHxiLmVuZERvYyx0OmIudHx8Yi5lbmRUYWcsZTpiLmV8fGIucGNkYXRhLEY6Yi5GfHxiLnJjZGF0YSxIOmIuSHx8Yi5zdGFydERvYyx3OmIud3x8Yi5zdGFydFRhZ307cmV0dXJuIGZ1bmN0aW9uKGIsZyl7dmFyIGY7dmFyIEg9Lyg8XC98PFwhLS18PFshP118WyY8Pl0pL2c7Zj1iKyIiO2lmKEcpZj1mLnNwbGl0KEgpO2Vsc2V7Zm9yKHZhciBlPVtdLGg9MCxqOyhqPUguZXhlYyhmKSkhPT1zOyllLnB1c2goZi5zdWJzdHJpbmcoaCxqLmluZGV4KSksZS5wdXNoKGpbMF0pLGg9ai5pbmRleCtqWzBdLmxlbmd0aDtlLnB1c2goZi5zdWJzdHJpbmcoaCkpO2Y9ZX1hKGQsZiwwLHtyOkMsQzpDfSxnKX19ZnVuY3Rpb24gYihiLGQsZyxmLHQpe3JldHVybiBmdW5jdGlvbigpe2EoYixkLGcsZix0KX19ZnVuY3Rpb24gYShhLGQscCxlLHQpe3RyeXthLkgmJjA9PXAmJmEuSCh0KTtmb3IodmFyIGgsCnosaixpPWQubGVuZ3RoO3A8aTspe3ZhciBvPWRbcCsrXSxsPWRbcF07c3dpdGNoKG8pe2Nhc2UgIiYiOkkudGVzdChsKT8oYS5lJiZhLmUoIiYiK2wsdCxBLGIoYSxkLHAsZSx0KSkscCsrKTphLmUmJmEuZSgiJmFtcDsiLHQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIjwvIjppZihoPS9eKFstXHc6XSspW15cJ1wiXSovLmV4ZWMobCkpaWYoaFswXS5sZW5ndGg9PT1sLmxlbmd0aCYmIj4iPT09ZFtwKzFdKXArPTIsaj1oWzFdLnRvTG93ZXJDYXNlKCksYS50JiZhLnQoaix0LEEsYihhLGQscCxlLHQpKTtlbHNle3ZhciBtPWQscT1wLHI9YSx1PXQsdj1BLHk9ZSx3PWYobSxxKTt3PyhyLnQmJnIudCh3Lm5hbWUsdSx2LGIocixtLHEseSx1KSkscD13Lm5leHQpOnA9bS5sZW5ndGh9ZWxzZSBhLmUmJmEuZSgiJmx0Oy8iLHQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIjwiOmlmKGg9L14oWy1cdzpdKylccypcLz8vLmV4ZWMobCkpaWYoaFswXS5sZW5ndGg9PT1sLmxlbmd0aCYmCiI+Ij09PWRbcCsxXSl7cCs9MjtqPWhbMV0udG9Mb3dlckNhc2UoKTthLncmJmEudyhqLFtdLHQsQSxiKGEsZCxwLGUsdCkpO3ZhciBCPWcuZltqXTtCJksmJihwPWsoZCx7bmFtZTpqLG5leHQ6cCxjOkJ9LGEsdCxBLGUpKX1lbHNle3ZhciBtPWQscT1hLHI9dCx1PUEsdj1lLHg9ZihtLHApO3g/KHEudyYmcS53KHgubmFtZSx4LlIscix1LGIocSxtLHgubmV4dCx2LHIpKSxwPXguYyZLP2sobSx4LHEscix1LHYpOngubmV4dCk6cD1tLmxlbmd0aH1lbHNlIGEuZSYmYS5lKCImbHQ7Iix0LEEsYihhLGQscCxlLHQpKTticmVhaztjYXNlICI8XCEtLSI6aWYoIWUuQyl7Zm9yKHo9cCsxO3o8aSYmISgiPiI9PT1kW3pdJiYvLS0kLy50ZXN0KGRbei0xXSkpO3orKyk7aWYoejxpKXtpZihhLkEpe3ZhciBEPWQuc2xpY2UocCx6KS5qb2luKCIiKTthLkEoRC5zdWJzdHIoMCxELmxlbmd0aC0yKSx0LEEsYihhLGQseisxLGUsdCkpfXA9eisxfWVsc2UgZS5DPW59ZS5DJiZhLmUmJmEuZSgiJmx0OyEtLSIsCnQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIjwhIjppZigvXlx3Ly50ZXN0KGwpKXtpZighZS5yKXtmb3Ioej1wKzE7ejxpJiYiPiIhPT1kW3pdO3orKyk7ejxpP3A9eisxOmUucj1ufWUuciYmYS5lJiZhLmUoIiZsdDshIix0LEEsYihhLGQscCxlLHQpKX1lbHNlIGEuZSYmYS5lKCImbHQ7ISIsdCxBLGIoYSxkLHAsZSx0KSk7YnJlYWs7Y2FzZSAiPD8iOmlmKCFlLnIpe2Zvcih6PXArMTt6PGkmJiI+IiE9PWRbel07eisrKTt6PGk/cD16KzE6ZS5yPW59ZS5yJiZhLmUmJmEuZSgiJmx0Oz8iLHQsQSxiKGEsZCxwLGUsdCkpO2JyZWFrO2Nhc2UgIj4iOmEuZSYmYS5lKCImZ3Q7Iix0LEEsYihhLGQscCxlLHQpKTticmVhaztjYXNlICIiOmJyZWFrO2RlZmF1bHQ6YS5lJiZhLmUobyx0LEEsYihhLGQscCxlLHQpKX19YS5CJiZhLkIodCl9Y2F0Y2goRSl7aWYoRSE9PUEpdGhyb3cgRTt9fWZ1bmN0aW9uIGsoYSxkLGYsaCx0LGope3ZhciB6PWEubGVuZ3RoO1QuaGFzT3duUHJvcGVydHkoZC5uYW1lKXx8CihUW2QubmFtZV09UmVnRXhwKCJeIitkLm5hbWUrIig/OltcXHNcXC9dfCQpIiwiaSIpKTtmb3IodmFyIGk9VFtkLm5hbWVdLGs9ZC5uZXh0LGw9ZC5uZXh0KzE7bDx6JiYhKCI8LyI9PT1hW2wtMV0mJmkudGVzdChhW2xdKSk7bCsrKTtsPHomJihsLT0xKTt6PWEuc2xpY2UoayxsKS5qb2luKCIiKTtpZihkLmMmZy5jLkNEQVRBKWYueiYmZi56KHosaCx0LGIoZixhLGwsaixoKSk7ZWxzZSBpZihkLmMmZy5jLlJDREFUQSlmLkYmJmYuRihlKHopLGgsdCxiKGYsYSxsLGosaCkpO2Vsc2UgdGhyb3cgRXJyb3IoImJ1ZyIpO3JldHVybiBsfWZ1bmN0aW9uIGYoYSxiKXt2YXIgZD0vXihbLVx3Ol0rKS8uZXhlYyhhW2JdKSxmPXt9O2YubmFtZT1kWzFdLnRvTG93ZXJDYXNlKCk7Zi5jPWcuZltmLm5hbWVdO2Zvcih2YXIgZT1hW2JdLnN1YnN0cihkWzBdLmxlbmd0aCksaD1iKzEsaj1hLmxlbmd0aDtoPGomJiI+IiE9PWFbaF07aCsrKWUrPWFbaF07aWYoIShqPD1oKSl7Zm9yKHZhciBsPVtdOyIiIT09CmU7KWlmKGQ9amEuZXhlYyhlKSlpZihkWzRdJiYhZFs1XXx8ZFs2XSYmIWRbN10pe2Zvcih2YXIgZD1kWzRdfHxkWzZdLGk9QyxlPVtlLGFbaCsrXV07aDxqO2grKyl7aWYoaSl7aWYoIj4iPT09YVtoXSlicmVha31lbHNlIDA8PWFbaF0uaW5kZXhPZihkKSYmKGk9bik7ZS5wdXNoKGFbaF0pfWlmKGo8PWgpYnJlYWs7ZT1lLmpvaW4oIiIpfWVsc2V7dmFyIGk9ZFsxXS50b0xvd2VyQ2FzZSgpLGs7aWYoZFsyXSl7az1kWzNdO3ZhciBtPWsuY2hhckNvZGVBdCgwKTtpZigzND09PW18fDM5PT09bSlrPWsuc3Vic3RyKDEsay5sZW5ndGgtMik7az14KGsucmVwbGFjZShvLCIiKSl9ZWxzZSBrPSIiO2wucHVzaChpLGspO2U9ZS5zdWJzdHIoZFswXS5sZW5ndGgpfWVsc2UgZT1lLnJlcGxhY2UoL15bXHNcU11bXmEtelxzXSovLCIiKTtmLlI9bDtmLm5leHQ9aCsxO3JldHVybiBmfX1mdW5jdGlvbiBoKGEpe2Z1bmN0aW9uIGIoYSxkKXtmfHxkLnB1c2goYSl9dmFyIGQsZjtyZXR1cm4gdih7c3RhcnREb2M6ZnVuY3Rpb24oKXtkPQpbXTtmPUN9LHN0YXJ0VGFnOmZ1bmN0aW9uKGIsZSxoKXtpZighZiYmZy5mLmhhc093blByb3BlcnR5KGIpKXt2YXIgaj1nLmZbYl07aWYoIShqJmcuYy5GT0xEQUJMRSkpe3ZhciBrPWEoYixlKTtpZihrKXtpZigib2JqZWN0IiE9PXR5cGVvZiBrKXRocm93IEVycm9yKCJ0YWdQb2xpY3kgZGlkIG5vdCByZXR1cm4gb2JqZWN0IChvbGQgQVBJPykiKTtpZigiYXR0cmlicyJpbiBrKWU9ay5hdHRyaWJzO2Vsc2UgdGhyb3cgRXJyb3IoInRhZ1BvbGljeSBnYXZlIG5vIGF0dHJpYnMiKTt2YXIgaTsidGFnTmFtZSJpbiBrPyhpPWsudGFnTmFtZSxrPWcuZltpXSk6KGk9YixrPWopO2lmKGomZy5jLk9QVElPTkFMX0VORFRBRyl7dmFyIGw9ZFtkLmxlbmd0aC0xXTtsJiZsLkQ9PT1iJiYobC52IT09aXx8YiE9PWkpJiZoLnB1c2goIjwvIixsLnYsIj4iKX1qJmcuYy5FTVBUWXx8ZC5wdXNoKHtEOmIsdjppfSk7aC5wdXNoKCI8IixpKTtiPTA7Zm9yKGw9ZS5sZW5ndGg7YjxsO2IrPTIpe3ZhciBtPQplW2JdLG89ZVtiKzFdO28hPT1zJiZvIT09YyYmaC5wdXNoKCIgIixtLCc9IicsRShvKSwnIicpfWgucHVzaCgiPiIpO2omZy5jLkVNUFRZJiYhKGsmZy5jLkVNUFRZKSYmaC5wdXNoKCI8LyIsaSwiPiIpfWVsc2UgZj0hKGomZy5jLkVNUFRZKX19fSxlbmRUYWc6ZnVuY3Rpb24oYSxiKXtpZihmKWY9QztlbHNlIGlmKGcuZi5oYXNPd25Qcm9wZXJ0eShhKSl7dmFyIGU9Zy5mW2FdO2lmKCEoZSYoZy5jLkVNUFRZfGcuYy5GT0xEQUJMRSkpKXtpZihlJmcuYy5PUFRJT05BTF9FTkRUQUcpZm9yKGU9ZC5sZW5ndGg7MDw9LS1lOyl7dmFyIGg9ZFtlXS5EO2lmKGg9PT1hKWJyZWFrO2lmKCEoZy5mW2hdJmcuYy5PUFRJT05BTF9FTkRUQUcpKXJldHVybn1lbHNlIGZvcihlPWQubGVuZ3RoOzA8PS0tZSYmZFtlXS5EIT09YTspO2lmKCEoMD5lKSl7Zm9yKGg9ZC5sZW5ndGg7LS1oPmU7KXt2YXIgaj1kW2hdLnY7Zy5mW2pdJmcuYy5PUFRJT05BTF9FTkRUQUd8fGIucHVzaCgiPC8iLGosIj4iKX1lPApkLmxlbmd0aCYmKGE9ZFtlXS52KTtkLmxlbmd0aD1lO2IucHVzaCgiPC8iLGEsIj4iKX19fX0scGNkYXRhOmIscmNkYXRhOmIsY2RhdGE6YixlbmREb2M6ZnVuY3Rpb24oYSl7Zm9yKDtkLmxlbmd0aDtkLmxlbmd0aC0tKWEucHVzaCgiPC8iLGRbZC5sZW5ndGgtMV0udiwiPiIpfX0pfWZ1bmN0aW9uIGQoYSxiLGQsZixlKXtpZighZSlyZXR1cm4gczt0cnl7dmFyIGc9WS5wYXJzZSgiIithKTtpZihnJiYoIWcuSygpfHxrYS50ZXN0KGcuVygpKSkpe3ZhciBoPWUoZyxiLGQsZik7cmV0dXJuIGg/aC50b1N0cmluZygpOnN9fWNhdGNoKGope31yZXR1cm4gc31mdW5jdGlvbiB5KGEsYixkLGYsZSl7ZHx8YShiKyIgcmVtb3ZlZCIse1M6InJlbW92ZWQiLHRhZ05hbWU6Yn0pO2lmKGYhPT1lKXt2YXIgZz0iY2hhbmdlZCI7ZiYmIWU/Zz0icmVtb3ZlZCI6IWYmJmUmJihnPSJhZGRlZCIpO2EoYisiLiIrZCsiICIrZyx7UzpnLHRhZ05hbWU6YixsYTpkLG9sZFZhbHVlOmYsbmV3VmFsdWU6ZX0pfX0KZnVuY3Rpb24gbChhLGIsZCl7Yj1iKyI6OiIrZDtpZihhLmhhc093blByb3BlcnR5KGIpKXJldHVybiBhW2JdO2I9Iio6OiIrZDtpZihhLmhhc093blByb3BlcnR5KGIpKXJldHVybiBhW2JdfWZ1bmN0aW9uIFYoYSxiLGYsZSxoKXtmb3IodmFyIGo9MDtqPGIubGVuZ3RoO2orPTIpe3ZhciBrPWJbal0saT1iW2orMV0sbT1pLG89cyxxO2lmKChxPWErIjo6IitrLGcubS5oYXNPd25Qcm9wZXJ0eShxKSl8fChxPSIqOjoiK2ssZy5tLmhhc093blByb3BlcnR5KHEpKSlvPWcubVtxXTtpZihvIT09cylzd2l0Y2gobyl7Y2FzZSBnLmQuTk9ORTpicmVhaztjYXNlIGcuZC5TQ1JJUFQ6aT1zO2gmJnkoaCxhLGssbSxpKTticmVhaztjYXNlIGcuZC5TVFlMRTppZigidW5kZWZpbmVkIj09PXR5cGVvZiBOKXtpPXM7aCYmeShoLGEsayxtLGkpO2JyZWFrfXZhciByPVtdO04oaSx7ZGVjbGFyYXRpb246ZnVuY3Rpb24oYSxiKXt2YXIgZT1hLnRvTG93ZXJDYXNlKCk7dShlLGIsZj9mdW5jdGlvbihhKXtyZXR1cm4gZChhLApnLlAuamEsZy5NLmthLHtUWVBFOiJDU1MiLENTU19QUk9QOmV9LGYpfTpzKTtiLmxlbmd0aCYmci5wdXNoKGUrIjogIitiLmpvaW4oIiAiKSl9fSk7aT0wPHIubGVuZ3RoP3Iuam9pbigiIDsgIik6cztoJiZ5KGgsYSxrLG0saSk7YnJlYWs7Y2FzZSBnLmQuSUQ6Y2FzZSBnLmQuSURSRUY6Y2FzZSBnLmQuSURSRUZTOmNhc2UgZy5kLkdMT0JBTF9OQU1FOmNhc2UgZy5kLkxPQ0FMX05BTUU6Y2FzZSBnLmQuQ0xBU1NFUzppPWU/ZShpKTppO2gmJnkoaCxhLGssbSxpKTticmVhaztjYXNlIGcuZC5VUkk6aT1kKGksbChnLkosYSxrKSxsKGcuSSxhLGspLHtUWVBFOiJNQVJLVVAiLFhNTF9BVFRSOmssWE1MX1RBRzphfSxmKTtoJiZ5KGgsYSxrLG0saSk7YnJlYWs7Y2FzZSBnLmQuVVJJX0ZSQUdNRU5UOmkmJiIjIj09PWkuY2hhckF0KDApPyhpPWkuc3Vic3RyaW5nKDEpLGk9ZT9lKGkpOmksaSE9PXMmJmkhPT1jJiYoaT0iIyIraSkpOmk9cztoJiZ5KGgsYSxrLG0saSk7YnJlYWs7ZGVmYXVsdDppPQpzLGgmJnkoaCxhLGssbSxpKX1lbHNlIGk9cyxoJiZ5KGgsYSxrLG0saSk7YltqKzFdPWl9cmV0dXJuIGJ9ZnVuY3Rpb24gZWEoYSxiLGQpe3JldHVybiBmdW5jdGlvbihlLGYpe2lmKGcuZltlXSZnLmMuVU5TQUZFKWQmJnkoZCxlLGMsYyxjKTtlbHNlIHJldHVybnthdHRyaWJzOlYoZSxmLGEsYixkKX19fWZ1bmN0aW9uIFEoYSxiKXt2YXIgZD1bXTtoKGIpKGEsZCk7cmV0dXJuIGQuam9pbigiIil9dmFyIE4sdTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cmJihOPXdpbmRvdy5wYXJzZUNzc0RlY2xhcmF0aW9ucyx1PXdpbmRvdy5zYW5pdGl6ZUNzc1Byb3BlcnR5KTt2YXIgaT17bHQ6IjwiLExUOiI8IixndDoiPiIsR1Q6Ij4iLGFtcDoiJiIsQU1QOiImIixxdW90OiciJyxhcG9zOiInIixuYnNwOiJcdTAwYTAifSxxPS9eIyhcZCspJC8sQj0vXiN4KFswLTlBLUZhLWZdKykkLyxGPS9eW0EtWmEtel1bQS16YS16MC05XSskLyxyPSJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmCndpbmRvdy5kb2N1bWVudD93aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTpzLG89L1wwL2csaj0vJigjWzAtOV0rfCNbeFhdWzAtOUEtRmEtZl0rfFx3Kyk7L2csST0vXigjWzAtOV0rfCNbeFhdWzAtOUEtRmEtZl0rfFx3Kyk7LyxSPS8mL2csaWE9LyYoW15hLXojXXwjKD86W14wLTl4XXx4KD86W14wLTlhLWZdfCQpfCQpfCQpL2dpLFA9L1s8XS9nLFM9Lz4vZyxEPS9cIi9nLGphPS9eXHMqKFstLjpcd10rKSg/OlxzKig9KVxzKigoIilbXiJdKigifCQpfCgnKVteJ10qKCd8JCl8KD89W2Etel1bLVx3XSpccyo9KXxbXiInXHNdKikpPy9pLEc9Mz09PSJhLGIiLnNwbGl0KC8oLCkvKS5sZW5ndGgsSz1nLmMuQ0RBVEF8Zy5jLlJDREFUQSxBPXt9LFQ9e30sa2E9L14oPzpodHRwcz98bWFpbHRvfGRhdGEpJC9pLG09e307bS5wYT1tLmVzY2FwZUF0dHJpYj1FO20ucmE9bS5tYWtlSHRtbFNhbml0aXplcj1oO20uc2E9bS5tYWtlU2F4UGFyc2VyPXY7bS50YT1tLm1ha2VUYWdQb2xpY3k9CmVhO20ud2E9bS5ub3JtYWxpemVSQ0RhdGE9ZTttLnhhPW0uc2FuaXRpemU9ZnVuY3Rpb24oYSxiLGQsZSl7cmV0dXJuIFEoYSxlYShiLGQsZSkpfTttLnlhPW0uc2FuaXRpemVBdHRyaWJzPVY7bS56YT1tLnNhbml0aXplV2l0aFBvbGljeT1RO20uQmE9bS51bmVzY2FwZUVudGl0aWVzPXg7cmV0dXJuIG19KCQpLGxhPWhhLnNhbml0aXplOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5odG1sPWhhLHdpbmRvdy5odG1sX3Nhbml0aXplPWxhKTt9KSgpOwohZnVuY3Rpb24odCl7aWYoIm9iamVjdCI9PXR5cGVvZiBleHBvcnRzJiYidW5kZWZpbmVkIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz10KCk7ZWxzZSBpZigiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSx0KTtlbHNleygidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6InVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOiJ1bmRlZmluZWQiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMpLnBha289dCgpfX0oZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gcihzLG8sbCl7ZnVuY3Rpb24gaChlLHQpe2lmKCFvW2VdKXtpZighc1tlXSl7dmFyIGE9ImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXQmJmEpcmV0dXJuIGEoZSwhMCk7aWYoZClyZXR1cm4gZChlLCEwKTt2YXIgaT1uZXcgRXJyb3IoIkNhbm5vdCBmaW5kIG1vZHVsZSAnIitlKyInIik7dGhyb3cgaS5jb2RlPSJNT0RVTEVfTk9UX0ZPVU5EIixpfXZhciBuPW9bZV09e2V4cG9ydHM6e319O3NbZV1bMF0uY2FsbChuLmV4cG9ydHMsZnVuY3Rpb24odCl7cmV0dXJuIGgoc1tlXVsxXVt0XXx8dCl9LG4sbi5leHBvcnRzLHIscyxvLGwpfXJldHVybiBvW2VdLmV4cG9ydHN9Zm9yKHZhciBkPSJmdW5jdGlvbiI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHQ9MDt0PGwubGVuZ3RoO3QrKyloKGxbdF0pO3JldHVybiBofSh7MTpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcz10KCIuL3psaWIvZGVmbGF0ZSIpLG89dCgiLi91dGlscy9jb21tb24iKSxsPXQoIi4vdXRpbHMvc3RyaW5ncyIpLG49dCgiLi96bGliL21lc3NhZ2VzIikscj10KCIuL3psaWIvenN0cmVhbSIpLGg9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxkPTAsZj0tMSxfPTAsdT04O2Z1bmN0aW9uIGModCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYykpcmV0dXJuIG5ldyBjKHQpO3RoaXMub3B0aW9ucz1vLmFzc2lnbih7bGV2ZWw6ZixtZXRob2Q6dSxjaHVua1NpemU6MTYzODQsd2luZG93Qml0czoxNSxtZW1MZXZlbDo4LHN0cmF0ZWd5Ol8sdG86IiJ9LHR8fHt9KTt2YXIgZT10aGlzLm9wdGlvbnM7ZS5yYXcmJjA8ZS53aW5kb3dCaXRzP2Uud2luZG93Qml0cz0tZS53aW5kb3dCaXRzOmUuZ3ppcCYmMDxlLndpbmRvd0JpdHMmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cys9MTYpLHRoaXMuZXJyPTAsdGhpcy5tc2c9IiIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IHIsdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBhPXMuZGVmbGF0ZUluaXQyKHRoaXMuc3RybSxlLmxldmVsLGUubWV0aG9kLGUud2luZG93Qml0cyxlLm1lbUxldmVsLGUuc3RyYXRlZ3kpO2lmKGEhPT1kKXRocm93IG5ldyBFcnJvcihuW2FdKTtpZihlLmhlYWRlciYmcy5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSxlLmhlYWRlciksZS5kaWN0aW9uYXJ5KXt2YXIgaTtpZihpPSJzdHJpbmciPT10eXBlb2YgZS5kaWN0aW9uYXJ5P2wuc3RyaW5nMmJ1ZihlLmRpY3Rpb25hcnkpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1oLmNhbGwoZS5kaWN0aW9uYXJ5KT9uZXcgVWludDhBcnJheShlLmRpY3Rpb25hcnkpOmUuZGljdGlvbmFyeSwoYT1zLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSxpKSkhPT1kKXRocm93IG5ldyBFcnJvcihuW2FdKTt0aGlzLl9kaWN0X3NldD0hMH19ZnVuY3Rpb24gaSh0LGUpe3ZhciBhPW5ldyBjKGUpO2lmKGEucHVzaCh0LCEwKSxhLmVycil0aHJvdyBhLm1zZ3x8blthLmVycl07cmV0dXJuIGEucmVzdWx0fWMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG49dGhpcy5zdHJtLHI9dGhpcy5vcHRpb25zLmNodW5rU2l6ZTtpZih0aGlzLmVuZGVkKXJldHVybiExO2k9ZT09PX5+ZT9lOiEwPT09ZT80OjAsInN0cmluZyI9PXR5cGVvZiB0P24uaW5wdXQ9bC5zdHJpbmcyYnVmKHQpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1oLmNhbGwodCk/bi5pbnB1dD1uZXcgVWludDhBcnJheSh0KTpuLmlucHV0PXQsbi5uZXh0X2luPTAsbi5hdmFpbF9pbj1uLmlucHV0Lmxlbmd0aDtkb3tpZigwPT09bi5hdmFpbF9vdXQmJihuLm91dHB1dD1uZXcgby5CdWY4KHIpLG4ubmV4dF9vdXQ9MCxuLmF2YWlsX291dD1yKSwxIT09KGE9cy5kZWZsYXRlKG4saSkpJiZhIT09ZClyZXR1cm4gdGhpcy5vbkVuZChhKSwhKHRoaXMuZW5kZWQ9ITApOzAhPT1uLmF2YWlsX291dCYmKDAhPT1uLmF2YWlsX2lufHw0IT09aSYmMiE9PWkpfHwoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5vbkRhdGEobC5idWYyYmluc3RyaW5nKG8uc2hyaW5rQnVmKG4ub3V0cHV0LG4ubmV4dF9vdXQpKSk6dGhpcy5vbkRhdGEoby5zaHJpbmtCdWYobi5vdXRwdXQsbi5uZXh0X291dCkpKX13aGlsZSgoMDxuLmF2YWlsX2lufHwwPT09bi5hdmFpbF9vdXQpJiYxIT09YSk7cmV0dXJuIDQ9PT1pPyhhPXMuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pLHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCxhPT09ZCk6MiE9PWl8fCh0aGlzLm9uRW5kKGQpLCEobi5hdmFpbF9vdXQ9MCkpfSxjLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaHVua3MucHVzaCh0KX0sYy5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24odCl7dD09PWQmJigic3RyaW5nIj09PXRoaXMub3B0aW9ucy50bz90aGlzLnJlc3VsdD10aGlzLmNodW5rcy5qb2luKCIiKTp0aGlzLnJlc3VsdD1vLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSx0aGlzLmNodW5rcz1bXSx0aGlzLmVycj10LHRoaXMubXNnPXRoaXMuc3RybS5tc2d9LGEuRGVmbGF0ZT1jLGEuZGVmbGF0ZT1pLGEuZGVmbGF0ZVJhdz1mdW5jdGlvbih0LGUpe3JldHVybihlPWV8fHt9KS5yYXc9ITAsaSh0LGUpfSxhLmd6aXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT1lfHx7fSkuZ3ppcD0hMCxpKHQsZSl9fSx7Ii4vdXRpbHMvY29tbW9uIjozLCIuL3V0aWxzL3N0cmluZ3MiOjQsIi4vemxpYi9kZWZsYXRlIjo4LCIuL3psaWIvbWVzc2FnZXMiOjEzLCIuL3psaWIvenN0cmVhbSI6MTV9XSwyOltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBmPXQoIi4vemxpYi9pbmZsYXRlIiksXz10KCIuL3V0aWxzL2NvbW1vbiIpLHU9dCgiLi91dGlscy9zdHJpbmdzIiksYz10KCIuL3psaWIvY29uc3RhbnRzIiksaT10KCIuL3psaWIvbWVzc2FnZXMiKSxuPXQoIi4vemxpYi96c3RyZWFtIikscj10KCIuL3psaWIvZ3poZWFkZXIiKSxiPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gcyh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBzKSlyZXR1cm4gbmV3IHModCk7dGhpcy5vcHRpb25zPV8uYXNzaWduKHtjaHVua1NpemU6MTYzODQsd2luZG93Qml0czowLHRvOiIifSx0fHx7fSk7dmFyIGU9dGhpcy5vcHRpb25zO2UucmF3JiYwPD1lLndpbmRvd0JpdHMmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cz0tZS53aW5kb3dCaXRzLDA9PT1lLndpbmRvd0JpdHMmJihlLndpbmRvd0JpdHM9LTE1KSksISgwPD1lLndpbmRvd0JpdHMmJmUud2luZG93Qml0czwxNil8fHQmJnQud2luZG93Qml0c3x8KGUud2luZG93Qml0cys9MzIpLDE1PGUud2luZG93Qml0cyYmZS53aW5kb3dCaXRzPDQ4JiYwPT0oMTUmZS53aW5kb3dCaXRzKSYmKGUud2luZG93Qml0c3w9MTUpLHRoaXMuZXJyPTAsdGhpcy5tc2c9IiIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IG4sdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBhPWYuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSxlLndpbmRvd0JpdHMpO2lmKGEhPT1jLlpfT0spdGhyb3cgbmV3IEVycm9yKGlbYV0pO2lmKHRoaXMuaGVhZGVyPW5ldyByLGYuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sdGhpcy5oZWFkZXIpLGUuZGljdGlvbmFyeSYmKCJzdHJpbmciPT10eXBlb2YgZS5kaWN0aW9uYXJ5P2UuZGljdGlvbmFyeT11LnN0cmluZzJidWYoZS5kaWN0aW9uYXJ5KToiW29iamVjdCBBcnJheUJ1ZmZlcl0iPT09Yi5jYWxsKGUuZGljdGlvbmFyeSkmJihlLmRpY3Rpb25hcnk9bmV3IFVpbnQ4QXJyYXkoZS5kaWN0aW9uYXJ5KSksZS5yYXcmJihhPWYuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLGUuZGljdGlvbmFyeSkpIT09Yy5aX09LKSl0aHJvdyBuZXcgRXJyb3IoaVthXSl9ZnVuY3Rpb24gbyh0LGUpe3ZhciBhPW5ldyBzKGUpO2lmKGEucHVzaCh0LCEwKSxhLmVycil0aHJvdyBhLm1zZ3x8aVthLmVycl07cmV0dXJuIGEucmVzdWx0fXMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzLG89dGhpcy5zdHJtLGw9dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxoPXRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5LGQ9ITE7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtpPWU9PT1+fmU/ZTohMD09PWU/Yy5aX0ZJTklTSDpjLlpfTk9fRkxVU0gsInN0cmluZyI9PXR5cGVvZiB0P28uaW5wdXQ9dS5iaW5zdHJpbmcyYnVmKHQpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1iLmNhbGwodCk/by5pbnB1dD1uZXcgVWludDhBcnJheSh0KTpvLmlucHV0PXQsby5uZXh0X2luPTAsby5hdmFpbF9pbj1vLmlucHV0Lmxlbmd0aDtkb3tpZigwPT09by5hdmFpbF9vdXQmJihvLm91dHB1dD1uZXcgXy5CdWY4KGwpLG8ubmV4dF9vdXQ9MCxvLmF2YWlsX291dD1sKSwoYT1mLmluZmxhdGUobyxjLlpfTk9fRkxVU0gpKT09PWMuWl9ORUVEX0RJQ1QmJmgmJihhPWYuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLGgpKSxhPT09Yy5aX0JVRl9FUlJPUiYmITA9PT1kJiYoYT1jLlpfT0ssZD0hMSksYSE9PWMuWl9TVFJFQU1fRU5EJiZhIT09Yy5aX09LKXJldHVybiB0aGlzLm9uRW5kKGEpLCEodGhpcy5lbmRlZD0hMCk7by5uZXh0X291dCYmKDAhPT1vLmF2YWlsX291dCYmYSE9PWMuWl9TVFJFQU1fRU5EJiYoMCE9PW8uYXZhaWxfaW58fGkhPT1jLlpfRklOSVNIJiZpIT09Yy5aX1NZTkNfRkxVU0gpfHwoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/KG49dS51dGY4Ym9yZGVyKG8ub3V0cHV0LG8ubmV4dF9vdXQpLHI9by5uZXh0X291dC1uLHM9dS5idWYyc3RyaW5nKG8ub3V0cHV0LG4pLG8ubmV4dF9vdXQ9cixvLmF2YWlsX291dD1sLXIsciYmXy5hcnJheVNldChvLm91dHB1dCxvLm91dHB1dCxuLHIsMCksdGhpcy5vbkRhdGEocykpOnRoaXMub25EYXRhKF8uc2hyaW5rQnVmKG8ub3V0cHV0LG8ubmV4dF9vdXQpKSkpLDA9PT1vLmF2YWlsX2luJiYwPT09by5hdmFpbF9vdXQmJihkPSEwKX13aGlsZSgoMDxvLmF2YWlsX2lufHwwPT09by5hdmFpbF9vdXQpJiZhIT09Yy5aX1NUUkVBTV9FTkQpO3JldHVybiBhPT09Yy5aX1NUUkVBTV9FTkQmJihpPWMuWl9GSU5JU0gpLGk9PT1jLlpfRklOSVNIPyhhPWYuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pLHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCxhPT09Yy5aX09LKTppIT09Yy5aX1NZTkNfRkxVU0h8fCh0aGlzLm9uRW5kKGMuWl9PSyksIShvLmF2YWlsX291dD0wKSl9LHMucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbih0KXt0aGlzLmNodW5rcy5wdXNoKHQpfSxzLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbih0KXt0PT09Yy5aX09LJiYoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbigiIik6dGhpcy5yZXN1bHQ9Xy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKSksdGhpcy5jaHVua3M9W10sdGhpcy5lcnI9dCx0aGlzLm1zZz10aGlzLnN0cm0ubXNnfSxhLkluZmxhdGU9cyxhLmluZmxhdGU9byxhLmluZmxhdGVSYXc9ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT1lfHx7fSkucmF3PSEwLG8odCxlKX0sYS51bmd6aXA9b30seyIuL3V0aWxzL2NvbW1vbiI6MywiLi91dGlscy9zdHJpbmdzIjo0LCIuL3psaWIvY29uc3RhbnRzIjo2LCIuL3psaWIvZ3poZWFkZXIiOjksIi4vemxpYi9pbmZsYXRlIjoxMSwiLi96bGliL21lc3NhZ2VzIjoxMywiLi96bGliL3pzdHJlYW0iOjE1fV0sMzpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgaT0idW5kZWZpbmVkIiE9dHlwZW9mIFVpbnQ4QXJyYXkmJiJ1bmRlZmluZWQiIT10eXBlb2YgVWludDE2QXJyYXkmJiJ1bmRlZmluZWQiIT10eXBlb2YgSW50MzJBcnJheTthLmFzc2lnbj1mdW5jdGlvbih0KXtmb3IodmFyIGUsYSxpPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtpLmxlbmd0aDspe3ZhciBuPWkuc2hpZnQoKTtpZihuKXtpZigib2JqZWN0IiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcihuKyJtdXN0IGJlIG5vbi1vYmplY3QiKTtmb3IodmFyIHIgaW4gbillPW4sYT1yLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGEpJiYodFtyXT1uW3JdKX19cmV0dXJuIHR9LGEuc2hyaW5rQnVmPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZT90OnQuc3ViYXJyYXk/dC5zdWJhcnJheSgwLGUpOih0Lmxlbmd0aD1lLHQpfTt2YXIgbj17YXJyYXlTZXQ6ZnVuY3Rpb24odCxlLGEsaSxuKXtpZihlLnN1YmFycmF5JiZ0LnN1YmFycmF5KXQuc2V0KGUuc3ViYXJyYXkoYSxhK2kpLG4pO2Vsc2UgZm9yKHZhciByPTA7cjxpO3IrKyl0W24rcl09ZVthK3JdfSxmbGF0dGVuQ2h1bmtzOmZ1bmN0aW9uKHQpe3ZhciBlLGEsaSxuLHIscztmb3IoZT1pPTAsYT10Lmxlbmd0aDtlPGE7ZSsrKWkrPXRbZV0ubGVuZ3RoO2ZvcihzPW5ldyBVaW50OEFycmF5KGkpLGU9bj0wLGE9dC5sZW5ndGg7ZTxhO2UrKylyPXRbZV0scy5zZXQocixuKSxuKz1yLmxlbmd0aDtyZXR1cm4gc319LHI9e2FycmF5U2V0OmZ1bmN0aW9uKHQsZSxhLGksbil7Zm9yKHZhciByPTA7cjxpO3IrKyl0W24rcl09ZVthK3JdfSxmbGF0dGVuQ2h1bmtzOmZ1bmN0aW9uKHQpe3JldHVybltdLmNvbmNhdC5hcHBseShbXSx0KX19O2Euc2V0VHlwZWQ9ZnVuY3Rpb24odCl7dD8oYS5CdWY4PVVpbnQ4QXJyYXksYS5CdWYxNj1VaW50MTZBcnJheSxhLkJ1ZjMyPUludDMyQXJyYXksYS5hc3NpZ24oYSxuKSk6KGEuQnVmOD1BcnJheSxhLkJ1ZjE2PUFycmF5LGEuQnVmMzI9QXJyYXksYS5hc3NpZ24oYSxyKSl9LGEuc2V0VHlwZWQoaSl9LHt9XSw0OltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBsPXQoIi4vY29tbW9uIiksbj0hMCxyPSEwO3RyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsWzBdKX1jYXRjaCh0KXtuPSExfXRyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoMSkpfWNhdGNoKHQpe3I9ITF9Zm9yKHZhciBoPW5ldyBsLkJ1ZjgoMjU2KSxpPTA7aTwyNTY7aSsrKWhbaV09MjUyPD1pPzY6MjQ4PD1pPzU6MjQwPD1pPzQ6MjI0PD1pPzM6MTkyPD1pPzI6MTtmdW5jdGlvbiBkKHQsZSl7aWYoZTw2NTUzNCYmKHQuc3ViYXJyYXkmJnJ8fCF0LnN1YmFycmF5JiZuKSlyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGwuc2hyaW5rQnVmKHQsZSkpO2Zvcih2YXIgYT0iIixpPTA7aTxlO2krKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiBhfWhbMjU0XT1oWzI1NF09MSxhLnN0cmluZzJidWY9ZnVuY3Rpb24odCl7dmFyIGUsYSxpLG4scixzPXQubGVuZ3RoLG89MDtmb3Iobj0wO248cztuKyspNTUyOTY9PSg2NDUxMiYoYT10LmNoYXJDb2RlQXQobikpKSYmbisxPHMmJjU2MzIwPT0oNjQ1MTImKGk9dC5jaGFyQ29kZUF0KG4rMSkpKSYmKGE9NjU1MzYrKGEtNTUyOTY8PDEwKSsoaS01NjMyMCksbisrKSxvKz1hPDEyOD8xOmE8MjA0OD8yOmE8NjU1MzY/Mzo0O2ZvcihlPW5ldyBsLkJ1Zjgobyksbj1yPTA7cjxvO24rKyk1NTI5Nj09KDY0NTEyJihhPXQuY2hhckNvZGVBdChuKSkpJiZuKzE8cyYmNTYzMjA9PSg2NDUxMiYoaT10LmNoYXJDb2RlQXQobisxKSkpJiYoYT02NTUzNisoYS01NTI5Njw8MTApKyhpLTU2MzIwKSxuKyspLGE8MTI4P2VbcisrXT1hOihhPDIwNDg/ZVtyKytdPTE5MnxhPj4+NjooYTw2NTUzNj9lW3IrK109MjI0fGE+Pj4xMjooZVtyKytdPTI0MHxhPj4+MTgsZVtyKytdPTEyOHxhPj4+MTImNjMpLGVbcisrXT0xMjh8YT4+PjYmNjMpLGVbcisrXT0xMjh8NjMmYSk7cmV0dXJuIGV9LGEuYnVmMmJpbnN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gZCh0LHQubGVuZ3RoKX0sYS5iaW5zdHJpbmcyYnVmPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgbC5CdWY4KHQubGVuZ3RoKSxhPTAsaT1lLmxlbmd0aDthPGk7YSsrKWVbYV09dC5jaGFyQ29kZUF0KGEpO3JldHVybiBlfSxhLmJ1ZjJzdHJpbmc9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzPWV8fHQubGVuZ3RoLG89bmV3IEFycmF5KDIqcyk7Zm9yKGE9aT0wO2E8czspaWYoKG49dFthKytdKTwxMjgpb1tpKytdPW47ZWxzZSBpZig0PChyPWhbbl0pKW9baSsrXT02NTUzMyxhKz1yLTE7ZWxzZXtmb3IobiY9Mj09PXI/MzE6Mz09PXI/MTU6NzsxPHImJmE8czspbj1uPDw2fDYzJnRbYSsrXSxyLS07MTxyP29baSsrXT02NTUzMzpuPDY1NTM2P29baSsrXT1uOihuLT02NTUzNixvW2krK109NTUyOTZ8bj4+MTAmMTAyMyxvW2krK109NTYzMjB8MTAyMyZuKX1yZXR1cm4gZChvLGkpfSxhLnV0Zjhib3JkZXI9ZnVuY3Rpb24odCxlKXt2YXIgYTtmb3IoKGU9ZXx8dC5sZW5ndGgpPnQubGVuZ3RoJiYoZT10Lmxlbmd0aCksYT1lLTE7MDw9YSYmMTI4PT0oMTkyJnRbYV0pOylhLS07cmV0dXJuIGE8MD9lOjA9PT1hP2U6YStoW3RbYV1dPmU/YTplfX0seyIuL2NvbW1vbiI6M31dLDU6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxhLGkpe2Zvcih2YXIgbj02NTUzNSZ0fDAscj10Pj4+MTYmNjU1MzV8MCxzPTA7MCE9PWE7KXtmb3IoYS09cz0yZTM8YT8yZTM6YTtyPXIrKG49bitlW2krK118MCl8MCwtLXM7KTtuJT02NTUyMSxyJT02NTUyMX1yZXR1cm4gbnxyPDwxNnwwfX0se31dLDY6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9fSx7fV0sNzpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgbz1mdW5jdGlvbigpe2Zvcih2YXIgdCxlPVtdLGE9MDthPDI1NjthKyspe3Q9YTtmb3IodmFyIGk9MDtpPDg7aSsrKXQ9MSZ0PzM5ODgyOTIzODRedD4+PjE6dD4+PjE7ZVthXT10fXJldHVybiBlfSgpO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUsYSxpKXt2YXIgbj1vLHI9aSthO3RePS0xO2Zvcih2YXIgcz1pO3M8cjtzKyspdD10Pj4+OF5uWzI1NSYodF5lW3NdKV07cmV0dXJuLTFedH19LHt9XSw4OltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBsLF89dCgiLi4vdXRpbHMvY29tbW9uIiksaD10KCIuL3RyZWVzIiksdT10KCIuL2FkbGVyMzIiKSxjPXQoIi4vY3JjMzIiKSxpPXQoIi4vbWVzc2FnZXMiKSxkPTAsZj00LGI9MCxnPS0yLG09LTEsdz00LG49MixwPTgsdj05LHI9Mjg2LHM9MzAsbz0xOSxrPTIqcisxLHk9MTUseD0zLHo9MjU4LEI9eit4KzEsUz00MixFPTExMyxBPTEsWj0yLFI9MyxDPTQ7ZnVuY3Rpb24gTih0LGUpe3JldHVybiB0Lm1zZz1pW2VdLGV9ZnVuY3Rpb24gTyh0KXtyZXR1cm4odDw8MSktKDQ8dD85OjApfWZ1bmN0aW9uIEQodCl7Zm9yKHZhciBlPXQubGVuZ3RoOzA8PS0tZTspdFtlXT0wfWZ1bmN0aW9uIEkodCl7dmFyIGU9dC5zdGF0ZSxhPWUucGVuZGluZzthPnQuYXZhaWxfb3V0JiYoYT10LmF2YWlsX291dCksMCE9PWEmJihfLmFycmF5U2V0KHQub3V0cHV0LGUucGVuZGluZ19idWYsZS5wZW5kaW5nX291dCxhLHQubmV4dF9vdXQpLHQubmV4dF9vdXQrPWEsZS5wZW5kaW5nX291dCs9YSx0LnRvdGFsX291dCs9YSx0LmF2YWlsX291dC09YSxlLnBlbmRpbmctPWEsMD09PWUucGVuZGluZyYmKGUucGVuZGluZ19vdXQ9MCkpfWZ1bmN0aW9uIFUodCxlKXtoLl90cl9mbHVzaF9ibG9jayh0LDA8PXQuYmxvY2tfc3RhcnQ/dC5ibG9ja19zdGFydDotMSx0LnN0cnN0YXJ0LXQuYmxvY2tfc3RhcnQsZSksdC5ibG9ja19zdGFydD10LnN0cnN0YXJ0LEkodC5zdHJtKX1mdW5jdGlvbiBUKHQsZSl7dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZX1mdW5jdGlvbiBGKHQsZSl7dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZT4+PjgmMjU1LHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPTI1NSZlfWZ1bmN0aW9uIEwodCxlKXt2YXIgYSxpLG49dC5tYXhfY2hhaW5fbGVuZ3RoLHI9dC5zdHJzdGFydCxzPXQucHJldl9sZW5ndGgsbz10Lm5pY2VfbWF0Y2gsbD10LnN0cnN0YXJ0PnQud19zaXplLUI/dC5zdHJzdGFydC0odC53X3NpemUtQik6MCxoPXQud2luZG93LGQ9dC53X21hc2ssZj10LnByZXYsXz10LnN0cnN0YXJ0K3osdT1oW3Ircy0xXSxjPWhbcitzXTt0LnByZXZfbGVuZ3RoPj10Lmdvb2RfbWF0Y2gmJihuPj49Miksbz50Lmxvb2thaGVhZCYmKG89dC5sb29rYWhlYWQpO2Rve2lmKGhbKGE9ZSkrc109PT1jJiZoW2Ercy0xXT09PXUmJmhbYV09PT1oW3JdJiZoWysrYV09PT1oW3IrMV0pe3IrPTIsYSsrO2Rve313aGlsZShoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmcjxfKTtpZihpPXotKF8tcikscj1fLXosczxpKXtpZih0Lm1hdGNoX3N0YXJ0PWUsbzw9KHM9aSkpYnJlYWs7dT1oW3Ircy0xXSxjPWhbcitzXX19fXdoaWxlKChlPWZbZSZkXSk+bCYmMCE9LS1uKTtyZXR1cm4gczw9dC5sb29rYWhlYWQ/czp0Lmxvb2thaGVhZH1mdW5jdGlvbiBIKHQpe3ZhciBlLGEsaSxuLHIscyxvLGwsaCxkLGY9dC53X3NpemU7ZG97aWYobj10LndpbmRvd19zaXplLXQubG9va2FoZWFkLXQuc3Ryc3RhcnQsdC5zdHJzdGFydD49ZisoZi1CKSl7Zm9yKF8uYXJyYXlTZXQodC53aW5kb3csdC53aW5kb3csZixmLDApLHQubWF0Y2hfc3RhcnQtPWYsdC5zdHJzdGFydC09Zix0LmJsb2NrX3N0YXJ0LT1mLGU9YT10Lmhhc2hfc2l6ZTtpPXQuaGVhZFstLWVdLHQuaGVhZFtlXT1mPD1pP2ktZjowLC0tYTspO2ZvcihlPWE9ZjtpPXQucHJldlstLWVdLHQucHJldltlXT1mPD1pP2ktZjowLC0tYTspO24rPWZ9aWYoMD09PXQuc3RybS5hdmFpbF9pbilicmVhaztpZihzPXQuc3RybSxvPXQud2luZG93LGw9dC5zdHJzdGFydCt0Lmxvb2thaGVhZCxoPW4sZD12b2lkIDAsZD1zLmF2YWlsX2luLGg8ZCYmKGQ9aCksYT0wPT09ZD8wOihzLmF2YWlsX2luLT1kLF8uYXJyYXlTZXQobyxzLmlucHV0LHMubmV4dF9pbixkLGwpLDE9PT1zLnN0YXRlLndyYXA/cy5hZGxlcj11KHMuYWRsZXIsbyxkLGwpOjI9PT1zLnN0YXRlLndyYXAmJihzLmFkbGVyPWMocy5hZGxlcixvLGQsbCkpLHMubmV4dF9pbis9ZCxzLnRvdGFsX2luKz1kLGQpLHQubG9va2FoZWFkKz1hLHQubG9va2FoZWFkK3QuaW5zZXJ0Pj14KWZvcihyPXQuc3Ryc3RhcnQtdC5pbnNlcnQsdC5pbnNfaD10LndpbmRvd1tyXSx0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbcisxXSkmdC5oYXNoX21hc2s7dC5pbnNlcnQmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbcit4LTFdKSZ0Lmhhc2hfbWFzayx0LnByZXZbciZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT1yLHIrKyx0Lmluc2VydC0tLCEodC5sb29rYWhlYWQrdC5pbnNlcnQ8eCkpOyk7fXdoaWxlKHQubG9va2FoZWFkPEImJjAhPT10LnN0cm0uYXZhaWxfaW4pfWZ1bmN0aW9uIGoodCxlKXtmb3IodmFyIGEsaTs7KXtpZih0Lmxvb2thaGVhZDxCKXtpZihIKHQpLHQubG9va2FoZWFkPEImJmU9PT1kKXJldHVybiBBO2lmKDA9PT10Lmxvb2thaGVhZClicmVha31pZihhPTAsdC5sb29rYWhlYWQ+PXgmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCt4LTFdKSZ0Lmhhc2hfbWFzayxhPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpLDAhPT1hJiZ0LnN0cnN0YXJ0LWE8PXQud19zaXplLUImJih0Lm1hdGNoX2xlbmd0aD1MKHQsYSkpLHQubWF0Y2hfbGVuZ3RoPj14KWlmKGk9aC5fdHJfdGFsbHkodCx0LnN0cnN0YXJ0LXQubWF0Y2hfc3RhcnQsdC5tYXRjaF9sZW5ndGgteCksdC5sb29rYWhlYWQtPXQubWF0Y2hfbGVuZ3RoLHQubWF0Y2hfbGVuZ3RoPD10Lm1heF9sYXp5X21hdGNoJiZ0Lmxvb2thaGVhZD49eCl7Zm9yKHQubWF0Y2hfbGVuZ3RoLS07dC5zdHJzdGFydCsrLHQuaW5zX2g9KHQuaW5zX2g8PHQuaGFzaF9zaGlmdF50LndpbmRvd1t0LnN0cnN0YXJ0K3gtMV0pJnQuaGFzaF9tYXNrLGE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCwwIT0tLXQubWF0Y2hfbGVuZ3RoOyk7dC5zdHJzdGFydCsrfWVsc2UgdC5zdHJzdGFydCs9dC5tYXRjaF9sZW5ndGgsdC5tYXRjaF9sZW5ndGg9MCx0Lmluc19oPXQud2luZG93W3Quc3Ryc3RhcnRdLHQuaW5zX2g9KHQuaW5zX2g8PHQuaGFzaF9zaGlmdF50LndpbmRvd1t0LnN0cnN0YXJ0KzFdKSZ0Lmhhc2hfbWFzaztlbHNlIGk9aC5fdHJfdGFsbHkodCwwLHQud2luZG93W3Quc3Ryc3RhcnRdKSx0Lmxvb2thaGVhZC0tLHQuc3Ryc3RhcnQrKztpZihpJiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8eC0xP3Quc3Ryc3RhcnQ6eC0xLGU9PT1mPyhVKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P1I6Qyk6dC5sYXN0X2xpdCYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6Wn1mdW5jdGlvbiBLKHQsZSl7Zm9yKHZhciBhLGksbjs7KXtpZih0Lmxvb2thaGVhZDxCKXtpZihIKHQpLHQubG9va2FoZWFkPEImJmU9PT1kKXJldHVybiBBO2lmKDA9PT10Lmxvb2thaGVhZClicmVha31pZihhPTAsdC5sb29rYWhlYWQ+PXgmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCt4LTFdKSZ0Lmhhc2hfbWFzayxhPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpLHQucHJldl9sZW5ndGg9dC5tYXRjaF9sZW5ndGgsdC5wcmV2X21hdGNoPXQubWF0Y2hfc3RhcnQsdC5tYXRjaF9sZW5ndGg9eC0xLDAhPT1hJiZ0LnByZXZfbGVuZ3RoPHQubWF4X2xhenlfbWF0Y2gmJnQuc3Ryc3RhcnQtYTw9dC53X3NpemUtQiYmKHQubWF0Y2hfbGVuZ3RoPUwodCxhKSx0Lm1hdGNoX2xlbmd0aDw9NSYmKDE9PT10LnN0cmF0ZWd5fHx0Lm1hdGNoX2xlbmd0aD09PXgmJjQwOTY8dC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0KSYmKHQubWF0Y2hfbGVuZ3RoPXgtMSkpLHQucHJldl9sZW5ndGg+PXgmJnQubWF0Y2hfbGVuZ3RoPD10LnByZXZfbGVuZ3RoKXtmb3Iobj10LnN0cnN0YXJ0K3QubG9va2FoZWFkLXgsaT1oLl90cl90YWxseSh0LHQuc3Ryc3RhcnQtMS10LnByZXZfbWF0Y2gsdC5wcmV2X2xlbmd0aC14KSx0Lmxvb2thaGVhZC09dC5wcmV2X2xlbmd0aC0xLHQucHJldl9sZW5ndGgtPTI7Kyt0LnN0cnN0YXJ0PD1uJiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQreC0xXSkmdC5oYXNoX21hc2ssYT10LnByZXZbdC5zdHJzdGFydCZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT10LnN0cnN0YXJ0KSwwIT0tLXQucHJldl9sZW5ndGg7KTtpZih0Lm1hdGNoX2F2YWlsYWJsZT0wLHQubWF0Y2hfbGVuZ3RoPXgtMSx0LnN0cnN0YXJ0KyssaSYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBBfWVsc2UgaWYodC5tYXRjaF9hdmFpbGFibGUpe2lmKChpPWguX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0LTFdKSkmJlUodCwhMSksdC5zdHJzdGFydCsrLHQubG9va2FoZWFkLS0sMD09PXQuc3RybS5hdmFpbF9vdXQpcmV0dXJuIEF9ZWxzZSB0Lm1hdGNoX2F2YWlsYWJsZT0xLHQuc3Ryc3RhcnQrKyx0Lmxvb2thaGVhZC0tfXJldHVybiB0Lm1hdGNoX2F2YWlsYWJsZSYmKGk9aC5fdHJfdGFsbHkodCwwLHQud2luZG93W3Quc3Ryc3RhcnQtMV0pLHQubWF0Y2hfYXZhaWxhYmxlPTApLHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8eC0xP3Quc3Ryc3RhcnQ6eC0xLGU9PT1mPyhVKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P1I6Qyk6dC5sYXN0X2xpdCYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6Wn1mdW5jdGlvbiBNKHQsZSxhLGksbil7dGhpcy5nb29kX2xlbmd0aD10LHRoaXMubWF4X2xhenk9ZSx0aGlzLm5pY2VfbGVuZ3RoPWEsdGhpcy5tYXhfY2hhaW49aSx0aGlzLmZ1bmM9bn1mdW5jdGlvbiBQKCl7dGhpcy5zdHJtPW51bGwsdGhpcy5zdGF0dXM9MCx0aGlzLnBlbmRpbmdfYnVmPW51bGwsdGhpcy5wZW5kaW5nX2J1Zl9zaXplPTAsdGhpcy5wZW5kaW5nX291dD0wLHRoaXMucGVuZGluZz0wLHRoaXMud3JhcD0wLHRoaXMuZ3poZWFkPW51bGwsdGhpcy5nemluZGV4PTAsdGhpcy5tZXRob2Q9cCx0aGlzLmxhc3RfZmx1c2g9LTEsdGhpcy53X3NpemU9MCx0aGlzLndfYml0cz0wLHRoaXMud19tYXNrPTAsdGhpcy53aW5kb3c9bnVsbCx0aGlzLndpbmRvd19zaXplPTAsdGhpcy5wcmV2PW51bGwsdGhpcy5oZWFkPW51bGwsdGhpcy5pbnNfaD0wLHRoaXMuaGFzaF9zaXplPTAsdGhpcy5oYXNoX2JpdHM9MCx0aGlzLmhhc2hfbWFzaz0wLHRoaXMuaGFzaF9zaGlmdD0wLHRoaXMuYmxvY2tfc3RhcnQ9MCx0aGlzLm1hdGNoX2xlbmd0aD0wLHRoaXMucHJldl9tYXRjaD0wLHRoaXMubWF0Y2hfYXZhaWxhYmxlPTAsdGhpcy5zdHJzdGFydD0wLHRoaXMubWF0Y2hfc3RhcnQ9MCx0aGlzLmxvb2thaGVhZD0wLHRoaXMucHJldl9sZW5ndGg9MCx0aGlzLm1heF9jaGFpbl9sZW5ndGg9MCx0aGlzLm1heF9sYXp5X21hdGNoPTAsdGhpcy5sZXZlbD0wLHRoaXMuc3RyYXRlZ3k9MCx0aGlzLmdvb2RfbWF0Y2g9MCx0aGlzLm5pY2VfbWF0Y2g9MCx0aGlzLmR5bl9sdHJlZT1uZXcgXy5CdWYxNigyKmspLHRoaXMuZHluX2R0cmVlPW5ldyBfLkJ1ZjE2KDIqKDIqcysxKSksdGhpcy5ibF90cmVlPW5ldyBfLkJ1ZjE2KDIqKDIqbysxKSksRCh0aGlzLmR5bl9sdHJlZSksRCh0aGlzLmR5bl9kdHJlZSksRCh0aGlzLmJsX3RyZWUpLHRoaXMubF9kZXNjPW51bGwsdGhpcy5kX2Rlc2M9bnVsbCx0aGlzLmJsX2Rlc2M9bnVsbCx0aGlzLmJsX2NvdW50PW5ldyBfLkJ1ZjE2KHkrMSksdGhpcy5oZWFwPW5ldyBfLkJ1ZjE2KDIqcisxKSxEKHRoaXMuaGVhcCksdGhpcy5oZWFwX2xlbj0wLHRoaXMuaGVhcF9tYXg9MCx0aGlzLmRlcHRoPW5ldyBfLkJ1ZjE2KDIqcisxKSxEKHRoaXMuZGVwdGgpLHRoaXMubF9idWY9MCx0aGlzLmxpdF9idWZzaXplPTAsdGhpcy5sYXN0X2xpdD0wLHRoaXMuZF9idWY9MCx0aGlzLm9wdF9sZW49MCx0aGlzLnN0YXRpY19sZW49MCx0aGlzLm1hdGNoZXM9MCx0aGlzLmluc2VydD0wLHRoaXMuYmlfYnVmPTAsdGhpcy5iaV92YWxpZD0wfWZ1bmN0aW9uIFkodCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KHQudG90YWxfaW49dC50b3RhbF9vdXQ9MCx0LmRhdGFfdHlwZT1uLChlPXQuc3RhdGUpLnBlbmRpbmc9MCxlLnBlbmRpbmdfb3V0PTAsZS53cmFwPDAmJihlLndyYXA9LWUud3JhcCksZS5zdGF0dXM9ZS53cmFwP1M6RSx0LmFkbGVyPTI9PT1lLndyYXA/MDoxLGUubGFzdF9mbHVzaD1kLGguX3RyX2luaXQoZSksYik6Tih0LGcpfWZ1bmN0aW9uIHEodCl7dmFyIGUsYT1ZKHQpO3JldHVybiBhPT09YiYmKChlPXQuc3RhdGUpLndpbmRvd19zaXplPTIqZS53X3NpemUsRChlLmhlYWQpLGUubWF4X2xhenlfbWF0Y2g9bFtlLmxldmVsXS5tYXhfbGF6eSxlLmdvb2RfbWF0Y2g9bFtlLmxldmVsXS5nb29kX2xlbmd0aCxlLm5pY2VfbWF0Y2g9bFtlLmxldmVsXS5uaWNlX2xlbmd0aCxlLm1heF9jaGFpbl9sZW5ndGg9bFtlLmxldmVsXS5tYXhfY2hhaW4sZS5zdHJzdGFydD0wLGUuYmxvY2tfc3RhcnQ9MCxlLmxvb2thaGVhZD0wLGUuaW5zZXJ0PTAsZS5tYXRjaF9sZW5ndGg9ZS5wcmV2X2xlbmd0aD14LTEsZS5tYXRjaF9hdmFpbGFibGU9MCxlLmluc19oPTApLGF9ZnVuY3Rpb24gRyh0LGUsYSxpLG4scil7aWYoIXQpcmV0dXJuIGc7dmFyIHM9MTtpZihlPT09bSYmKGU9NiksaTwwPyhzPTAsaT0taSk6MTU8aSYmKHM9MixpLT0xNiksbjwxfHx2PG58fGEhPT1wfHxpPDh8fDE1PGl8fGU8MHx8OTxlfHxyPDB8fHc8cilyZXR1cm4gTih0LGcpOzg9PT1pJiYoaT05KTt2YXIgbz1uZXcgUDtyZXR1cm4odC5zdGF0ZT1vKS5zdHJtPXQsby53cmFwPXMsby5nemhlYWQ9bnVsbCxvLndfYml0cz1pLG8ud19zaXplPTE8PG8ud19iaXRzLG8ud19tYXNrPW8ud19zaXplLTEsby5oYXNoX2JpdHM9bis3LG8uaGFzaF9zaXplPTE8PG8uaGFzaF9iaXRzLG8uaGFzaF9tYXNrPW8uaGFzaF9zaXplLTEsby5oYXNoX3NoaWZ0PX5+KChvLmhhc2hfYml0cyt4LTEpL3gpLG8ud2luZG93PW5ldyBfLkJ1ZjgoMipvLndfc2l6ZSksby5oZWFkPW5ldyBfLkJ1ZjE2KG8uaGFzaF9zaXplKSxvLnByZXY9bmV3IF8uQnVmMTYoby53X3NpemUpLG8ubGl0X2J1ZnNpemU9MTw8bis2LG8ucGVuZGluZ19idWZfc2l6ZT00Km8ubGl0X2J1ZnNpemUsby5wZW5kaW5nX2J1Zj1uZXcgXy5CdWY4KG8ucGVuZGluZ19idWZfc2l6ZSksby5kX2J1Zj0xKm8ubGl0X2J1ZnNpemUsby5sX2J1Zj0zKm8ubGl0X2J1ZnNpemUsby5sZXZlbD1lLG8uc3RyYXRlZ3k9cixvLm1ldGhvZD1hLHEodCl9bD1bbmV3IE0oMCwwLDAsMCxmdW5jdGlvbih0LGUpe3ZhciBhPTY1NTM1O2ZvcihhPnQucGVuZGluZ19idWZfc2l6ZS01JiYoYT10LnBlbmRpbmdfYnVmX3NpemUtNSk7Oyl7aWYodC5sb29rYWhlYWQ8PTEpe2lmKEgodCksMD09PXQubG9va2FoZWFkJiZlPT09ZClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9dC5zdHJzdGFydCs9dC5sb29rYWhlYWQsdC5sb29rYWhlYWQ9MDt2YXIgaT10LmJsb2NrX3N0YXJ0K2E7aWYoKDA9PT10LnN0cnN0YXJ0fHx0LnN0cnN0YXJ0Pj1pKSYmKHQubG9va2FoZWFkPXQuc3Ryc3RhcnQtaSx0LnN0cnN0YXJ0PWksVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEE7aWYodC5zdHJzdGFydC10LmJsb2NrX3N0YXJ0Pj10Lndfc2l6ZS1CJiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWY/KFUodCwhMCksMD09PXQuc3RybS5hdmFpbF9vdXQ/UjpDKToodC5zdHJzdGFydD50LmJsb2NrX3N0YXJ0JiYoVSh0LCExKSx0LnN0cm0uYXZhaWxfb3V0KSxBKX0pLG5ldyBNKDQsNCw4LDQsaiksbmV3IE0oNCw1LDE2LDgsaiksbmV3IE0oNCw2LDMyLDMyLGopLG5ldyBNKDQsNCwxNiwxNixLKSxuZXcgTSg4LDE2LDMyLDMyLEspLG5ldyBNKDgsMTYsMTI4LDEyOCxLKSxuZXcgTSg4LDMyLDEyOCwyNTYsSyksbmV3IE0oMzIsMTI4LDI1OCwxMDI0LEspLG5ldyBNKDMyLDI1OCwyNTgsNDA5NixLKV0sYS5kZWZsYXRlSW5pdD1mdW5jdGlvbih0LGUpe3JldHVybiBHKHQsZSxwLDE1LDgsMCl9LGEuZGVmbGF0ZUluaXQyPUcsYS5kZWZsYXRlUmVzZXQ9cSxhLmRlZmxhdGVSZXNldEtlZXA9WSxhLmRlZmxhdGVTZXRIZWFkZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmdC5zdGF0ZT8yIT09dC5zdGF0ZS53cmFwP2c6KHQuc3RhdGUuZ3poZWFkPWUsYik6Z30sYS5kZWZsYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuLHI7aWYoIXR8fCF0LnN0YXRlfHw1PGV8fGU8MClyZXR1cm4gdD9OKHQsZyk6ZztpZihpPXQuc3RhdGUsIXQub3V0cHV0fHwhdC5pbnB1dCYmMCE9PXQuYXZhaWxfaW58fDY2Nj09PWkuc3RhdHVzJiZlIT09ZilyZXR1cm4gTih0LDA9PT10LmF2YWlsX291dD8tNTpnKTtpZihpLnN0cm09dCxhPWkubGFzdF9mbHVzaCxpLmxhc3RfZmx1c2g9ZSxpLnN0YXR1cz09PVMpaWYoMj09PWkud3JhcCl0LmFkbGVyPTAsVChpLDMxKSxUKGksMTM5KSxUKGksOCksaS5nemhlYWQ/KFQoaSwoaS5nemhlYWQudGV4dD8xOjApKyhpLmd6aGVhZC5oY3JjPzI6MCkrKGkuZ3poZWFkLmV4dHJhPzQ6MCkrKGkuZ3poZWFkLm5hbWU/ODowKSsoaS5nemhlYWQuY29tbWVudD8xNjowKSksVChpLDI1NSZpLmd6aGVhZC50aW1lKSxUKGksaS5nemhlYWQudGltZT4+OCYyNTUpLFQoaSxpLmd6aGVhZC50aW1lPj4xNiYyNTUpLFQoaSxpLmd6aGVhZC50aW1lPj4yNCYyNTUpLFQoaSw5PT09aS5sZXZlbD8yOjI8PWkuc3RyYXRlZ3l8fGkubGV2ZWw8Mj80OjApLFQoaSwyNTUmaS5nemhlYWQub3MpLGkuZ3poZWFkLmV4dHJhJiZpLmd6aGVhZC5leHRyYS5sZW5ndGgmJihUKGksMjU1JmkuZ3poZWFkLmV4dHJhLmxlbmd0aCksVChpLGkuZ3poZWFkLmV4dHJhLmxlbmd0aD4+OCYyNTUpKSxpLmd6aGVhZC5oY3JjJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmcsMCkpLGkuZ3ppbmRleD0wLGkuc3RhdHVzPTY5KTooVChpLDApLFQoaSwwKSxUKGksMCksVChpLDApLFQoaSwwKSxUKGksOT09PWkubGV2ZWw/MjoyPD1pLnN0cmF0ZWd5fHxpLmxldmVsPDI/NDowKSxUKGksMyksaS5zdGF0dXM9RSk7ZWxzZXt2YXIgcz1wKyhpLndfYml0cy04PDw0KTw8ODtzfD0oMjw9aS5zdHJhdGVneXx8aS5sZXZlbDwyPzA6aS5sZXZlbDw2PzE6Nj09PWkubGV2ZWw/MjozKTw8NiwwIT09aS5zdHJzdGFydCYmKHN8PTMyKSxzKz0zMS1zJTMxLGkuc3RhdHVzPUUsRihpLHMpLDAhPT1pLnN0cnN0YXJ0JiYoRihpLHQuYWRsZXI+Pj4xNiksRihpLDY1NTM1JnQuYWRsZXIpKSx0LmFkbGVyPTF9aWYoNjk9PT1pLnN0YXR1cylpZihpLmd6aGVhZC5leHRyYSl7Zm9yKG49aS5wZW5kaW5nO2kuZ3ppbmRleDwoNjU1MzUmaS5nemhlYWQuZXh0cmEubGVuZ3RoKSYmKGkucGVuZGluZyE9PWkucGVuZGluZ19idWZfc2l6ZXx8KGkuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksSSh0KSxuPWkucGVuZGluZyxpLnBlbmRpbmchPT1pLnBlbmRpbmdfYnVmX3NpemUpKTspVChpLDI1NSZpLmd6aGVhZC5leHRyYVtpLmd6aW5kZXhdKSxpLmd6aW5kZXgrKztpLmd6aGVhZC5oY3JjJiZpLnBlbmRpbmc+biYmKHQuYWRsZXI9Yyh0LmFkbGVyLGkucGVuZGluZ19idWYsaS5wZW5kaW5nLW4sbikpLGkuZ3ppbmRleD09PWkuZ3poZWFkLmV4dHJhLmxlbmd0aCYmKGkuZ3ppbmRleD0wLGkuc3RhdHVzPTczKX1lbHNlIGkuc3RhdHVzPTczO2lmKDczPT09aS5zdGF0dXMpaWYoaS5nemhlYWQubmFtZSl7bj1pLnBlbmRpbmc7ZG97aWYoaS5wZW5kaW5nPT09aS5wZW5kaW5nX2J1Zl9zaXplJiYoaS5nemhlYWQuaGNyYyYmaS5wZW5kaW5nPm4mJih0LmFkbGVyPWModC5hZGxlcixpLnBlbmRpbmdfYnVmLGkucGVuZGluZy1uLG4pKSxJKHQpLG49aS5wZW5kaW5nLGkucGVuZGluZz09PWkucGVuZGluZ19idWZfc2l6ZSkpe3I9MTticmVha31UKGkscj1pLmd6aW5kZXg8aS5nemhlYWQubmFtZS5sZW5ndGg/MjU1JmkuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChpLmd6aW5kZXgrKyk6MCl9d2hpbGUoMCE9PXIpO2kuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksMD09PXImJihpLmd6aW5kZXg9MCxpLnN0YXR1cz05MSl9ZWxzZSBpLnN0YXR1cz05MTtpZig5MT09PWkuc3RhdHVzKWlmKGkuZ3poZWFkLmNvbW1lbnQpe249aS5wZW5kaW5nO2Rve2lmKGkucGVuZGluZz09PWkucGVuZGluZ19idWZfc2l6ZSYmKGkuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1jKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksSSh0KSxuPWkucGVuZGluZyxpLnBlbmRpbmc9PT1pLnBlbmRpbmdfYnVmX3NpemUpKXtyPTE7YnJlYWt9VChpLHI9aS5nemluZGV4PGkuZ3poZWFkLmNvbW1lbnQubGVuZ3RoPzI1NSZpLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQoaS5nemluZGV4KyspOjApfXdoaWxlKDAhPT1yKTtpLmd6aGVhZC5oY3JjJiZpLnBlbmRpbmc+biYmKHQuYWRsZXI9Yyh0LmFkbGVyLGkucGVuZGluZ19idWYsaS5wZW5kaW5nLW4sbikpLDA9PT1yJiYoaS5zdGF0dXM9MTAzKX1lbHNlIGkuc3RhdHVzPTEwMztpZigxMDM9PT1pLnN0YXR1cyYmKGkuZ3poZWFkLmhjcmM/KGkucGVuZGluZysyPmkucGVuZGluZ19idWZfc2l6ZSYmSSh0KSxpLnBlbmRpbmcrMjw9aS5wZW5kaW5nX2J1Zl9zaXplJiYoVChpLDI1NSZ0LmFkbGVyKSxUKGksdC5hZGxlcj4+OCYyNTUpLHQuYWRsZXI9MCxpLnN0YXR1cz1FKSk6aS5zdGF0dXM9RSksMCE9PWkucGVuZGluZyl7aWYoSSh0KSwwPT09dC5hdmFpbF9vdXQpcmV0dXJuIGkubGFzdF9mbHVzaD0tMSxifWVsc2UgaWYoMD09PXQuYXZhaWxfaW4mJk8oZSk8PU8oYSkmJmUhPT1mKXJldHVybiBOKHQsLTUpO2lmKDY2Nj09PWkuc3RhdHVzJiYwIT09dC5hdmFpbF9pbilyZXR1cm4gTih0LC01KTtpZigwIT09dC5hdmFpbF9pbnx8MCE9PWkubG9va2FoZWFkfHxlIT09ZCYmNjY2IT09aS5zdGF0dXMpe3ZhciBvPTI9PT1pLnN0cmF0ZWd5P2Z1bmN0aW9uKHQsZSl7Zm9yKHZhciBhOzspe2lmKDA9PT10Lmxvb2thaGVhZCYmKEgodCksMD09PXQubG9va2FoZWFkKSl7aWYoZT09PWQpcmV0dXJuIEE7YnJlYWt9aWYodC5tYXRjaF9sZW5ndGg9MCxhPWguX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0KyssYSYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBBfXJldHVybiB0Lmluc2VydD0wLGU9PT1mPyhVKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P1I6Qyk6dC5sYXN0X2xpdCYmKFUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6Wn0oaSxlKTozPT09aS5zdHJhdGVneT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgYSxpLG4scixzPXQud2luZG93Ozspe2lmKHQubG9va2FoZWFkPD16KXtpZihIKHQpLHQubG9va2FoZWFkPD16JiZlPT09ZClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9aWYodC5tYXRjaF9sZW5ndGg9MCx0Lmxvb2thaGVhZD49eCYmMDx0LnN0cnN0YXJ0JiYoaT1zW249dC5zdHJzdGFydC0xXSk9PT1zWysrbl0mJmk9PT1zWysrbl0mJmk9PT1zWysrbl0pe3I9dC5zdHJzdGFydCt6O2Rve313aGlsZShpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZpPT09c1srK25dJiZuPHIpO3QubWF0Y2hfbGVuZ3RoPXotKHItbiksdC5tYXRjaF9sZW5ndGg+dC5sb29rYWhlYWQmJih0Lm1hdGNoX2xlbmd0aD10Lmxvb2thaGVhZCl9aWYodC5tYXRjaF9sZW5ndGg+PXg/KGE9aC5fdHJfdGFsbHkodCwxLHQubWF0Y2hfbGVuZ3RoLXgpLHQubG9va2FoZWFkLT10Lm1hdGNoX2xlbmd0aCx0LnN0cnN0YXJ0Kz10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aD0wKTooYT1oLl90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydF0pLHQubG9va2FoZWFkLS0sdC5zdHJzdGFydCsrKSxhJiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWY/KFUodCwhMCksMD09PXQuc3RybS5hdmFpbF9vdXQ/UjpDKTp0Lmxhc3RfbGl0JiYoVSh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCk/QTpafShpLGUpOmxbaS5sZXZlbF0uZnVuYyhpLGUpO2lmKG8hPT1SJiZvIT09Q3x8KGkuc3RhdHVzPTY2Niksbz09PUF8fG89PT1SKXJldHVybiAwPT09dC5hdmFpbF9vdXQmJihpLmxhc3RfZmx1c2g9LTEpLGI7aWYobz09PVomJigxPT09ZT9oLl90cl9hbGlnbihpKTo1IT09ZSYmKGguX3RyX3N0b3JlZF9ibG9jayhpLDAsMCwhMSksMz09PWUmJihEKGkuaGVhZCksMD09PWkubG9va2FoZWFkJiYoaS5zdHJzdGFydD0wLGkuYmxvY2tfc3RhcnQ9MCxpLmluc2VydD0wKSkpLEkodCksMD09PXQuYXZhaWxfb3V0KSlyZXR1cm4gaS5sYXN0X2ZsdXNoPS0xLGJ9cmV0dXJuIGUhPT1mP2I6aS53cmFwPD0wPzE6KDI9PT1pLndyYXA/KFQoaSwyNTUmdC5hZGxlciksVChpLHQuYWRsZXI+PjgmMjU1KSxUKGksdC5hZGxlcj4+MTYmMjU1KSxUKGksdC5hZGxlcj4+MjQmMjU1KSxUKGksMjU1JnQudG90YWxfaW4pLFQoaSx0LnRvdGFsX2luPj44JjI1NSksVChpLHQudG90YWxfaW4+PjE2JjI1NSksVChpLHQudG90YWxfaW4+PjI0JjI1NSkpOihGKGksdC5hZGxlcj4+PjE2KSxGKGksNjU1MzUmdC5hZGxlcikpLEkodCksMDxpLndyYXAmJihpLndyYXA9LWkud3JhcCksMCE9PWkucGVuZGluZz9iOjEpfSxhLmRlZmxhdGVFbmQ9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KGU9dC5zdGF0ZS5zdGF0dXMpIT09UyYmNjkhPT1lJiY3MyE9PWUmJjkxIT09ZSYmMTAzIT09ZSYmZSE9PUUmJjY2NiE9PWU/Tih0LGcpOih0LnN0YXRlPW51bGwsZT09PUU/Tih0LC0zKTpiKTpnfSxhLmRlZmxhdGVTZXREaWN0aW9uYXJ5PWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuLHIscyxvLGwsaCxkPWUubGVuZ3RoO2lmKCF0fHwhdC5zdGF0ZSlyZXR1cm4gZztpZigyPT09KHI9KGE9dC5zdGF0ZSkud3JhcCl8fDE9PT1yJiZhLnN0YXR1cyE9PVN8fGEubG9va2FoZWFkKXJldHVybiBnO2ZvcigxPT09ciYmKHQuYWRsZXI9dSh0LmFkbGVyLGUsZCwwKSksYS53cmFwPTAsZD49YS53X3NpemUmJigwPT09ciYmKEQoYS5oZWFkKSxhLnN0cnN0YXJ0PTAsYS5ibG9ja19zdGFydD0wLGEuaW5zZXJ0PTApLGg9bmV3IF8uQnVmOChhLndfc2l6ZSksXy5hcnJheVNldChoLGUsZC1hLndfc2l6ZSxhLndfc2l6ZSwwKSxlPWgsZD1hLndfc2l6ZSkscz10LmF2YWlsX2luLG89dC5uZXh0X2luLGw9dC5pbnB1dCx0LmF2YWlsX2luPWQsdC5uZXh0X2luPTAsdC5pbnB1dD1lLEgoYSk7YS5sb29rYWhlYWQ+PXg7KXtmb3IoaT1hLnN0cnN0YXJ0LG49YS5sb29rYWhlYWQtKHgtMSk7YS5pbnNfaD0oYS5pbnNfaDw8YS5oYXNoX3NoaWZ0XmEud2luZG93W2kreC0xXSkmYS5oYXNoX21hc2ssYS5wcmV2W2kmYS53X21hc2tdPWEuaGVhZFthLmluc19oXSxhLmhlYWRbYS5pbnNfaF09aSxpKyssLS1uOyk7YS5zdHJzdGFydD1pLGEubG9va2FoZWFkPXgtMSxIKGEpfXJldHVybiBhLnN0cnN0YXJ0Kz1hLmxvb2thaGVhZCxhLmJsb2NrX3N0YXJ0PWEuc3Ryc3RhcnQsYS5pbnNlcnQ9YS5sb29rYWhlYWQsYS5sb29rYWhlYWQ9MCxhLm1hdGNoX2xlbmd0aD1hLnByZXZfbGVuZ3RoPXgtMSxhLm1hdGNoX2F2YWlsYWJsZT0wLHQubmV4dF9pbj1vLHQuaW5wdXQ9bCx0LmF2YWlsX2luPXMsYS53cmFwPXIsYn0sYS5kZWZsYXRlSW5mbz0icGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSJ9LHsiLi4vdXRpbHMvY29tbW9uIjozLCIuL2FkbGVyMzIiOjUsIi4vY3JjMzIiOjcsIi4vbWVzc2FnZXMiOjEzLCIuL3RyZWVzIjoxNH1dLDk6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7dGhpcy50ZXh0PTAsdGhpcy50aW1lPTAsdGhpcy54ZmxhZ3M9MCx0aGlzLm9zPTAsdGhpcy5leHRyYT1udWxsLHRoaXMuZXh0cmFfbGVuPTAsdGhpcy5uYW1lPSIiLHRoaXMuY29tbWVudD0iIix0aGlzLmhjcmM9MCx0aGlzLmRvbmU9ITF9fSx7fV0sMTA6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuLHIscyxvLGwsaCxkLGYsXyx1LGMsYixnLG0sdyxwLHYsayx5LHgseixCLFM7YT10LnN0YXRlLGk9dC5uZXh0X2luLEI9dC5pbnB1dCxuPWkrKHQuYXZhaWxfaW4tNSkscj10Lm5leHRfb3V0LFM9dC5vdXRwdXQscz1yLShlLXQuYXZhaWxfb3V0KSxvPXIrKHQuYXZhaWxfb3V0LTI1NyksbD1hLmRtYXgsaD1hLndzaXplLGQ9YS53aGF2ZSxmPWEud25leHQsXz1hLndpbmRvdyx1PWEuaG9sZCxjPWEuYml0cyxiPWEubGVuY29kZSxnPWEuZGlzdGNvZGUsbT0oMTw8YS5sZW5iaXRzKS0xLHc9KDE8PGEuZGlzdGJpdHMpLTE7dDpkb3tjPDE1JiYodSs9QltpKytdPDxjLGMrPTgsdSs9QltpKytdPDxjLGMrPTgpLHA9Ylt1Jm1dO2U6Zm9yKDs7KXtpZih1Pj4+PXY9cD4+PjI0LGMtPXYsMD09PSh2PXA+Pj4xNiYyNTUpKVNbcisrXT02NTUzNSZwO2Vsc2V7aWYoISgxNiZ2KSl7aWYoMD09KDY0JnYpKXtwPWJbKDY1NTM1JnApKyh1JigxPDx2KS0xKV07Y29udGludWUgZX1pZigzMiZ2KXthLm1vZGU9MTI7YnJlYWsgdH10Lm1zZz0iaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIixhLm1vZGU9MzA7YnJlYWsgdH1rPTY1NTM1JnAsKHYmPTE1KSYmKGM8diYmKHUrPUJbaSsrXTw8YyxjKz04KSxrKz11JigxPDx2KS0xLHU+Pj49dixjLT12KSxjPDE1JiYodSs9QltpKytdPDxjLGMrPTgsdSs9QltpKytdPDxjLGMrPTgpLHA9Z1t1JnddO2E6Zm9yKDs7KXtpZih1Pj4+PXY9cD4+PjI0LGMtPXYsISgxNiYodj1wPj4+MTYmMjU1KSkpe2lmKDA9PSg2NCZ2KSl7cD1nWyg2NTUzNSZwKSsodSYoMTw8diktMSldO2NvbnRpbnVlIGF9dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgY29kZSIsYS5tb2RlPTMwO2JyZWFrIHR9aWYoeT02NTUzNSZwLGM8KHYmPTE1KSYmKHUrPUJbaSsrXTw8YywoYys9OCk8diYmKHUrPUJbaSsrXTw8YyxjKz04KSksbDwoeSs9dSYoMTw8diktMSkpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsYS5tb2RlPTMwO2JyZWFrIHR9aWYodT4+Pj12LGMtPXYsKHY9ci1zKTx5KXtpZihkPCh2PXktdikmJmEuc2FuZSl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixhLm1vZGU9MzA7YnJlYWsgdH1pZih6PV8sKHg9MCk9PT1mKXtpZih4Kz1oLXYsdjxrKXtmb3Ioay09djtTW3IrK109X1t4KytdLC0tdjspO3g9ci15LHo9U319ZWxzZSBpZihmPHYpe2lmKHgrPWgrZi12LCh2LT1mKTxrKXtmb3Ioay09djtTW3IrK109X1t4KytdLC0tdjspO2lmKHg9MCxmPGspe2ZvcihrLT12PWY7U1tyKytdPV9beCsrXSwtLXY7KTt4PXIteSx6PVN9fX1lbHNlIGlmKHgrPWYtdix2PGspe2ZvcihrLT12O1NbcisrXT1fW3grK10sLS12Oyk7eD1yLXksej1TfWZvcig7MjxrOylTW3IrK109elt4KytdLFNbcisrXT16W3grK10sU1tyKytdPXpbeCsrXSxrLT0zO2smJihTW3IrK109elt4KytdLDE8ayYmKFNbcisrXT16W3grK10pKX1lbHNle2Zvcih4PXIteTtTW3IrK109U1t4KytdLFNbcisrXT1TW3grK10sU1tyKytdPVNbeCsrXSwyPChrLT0zKTspO2smJihTW3IrK109U1t4KytdLDE8ayYmKFNbcisrXT1TW3grK10pKX1icmVha319YnJlYWt9fXdoaWxlKGk8biYmcjxvKTtpLT1rPWM+PjMsdSY9KDE8PChjLT1rPDwzKSktMSx0Lm5leHRfaW49aSx0Lm5leHRfb3V0PXIsdC5hdmFpbF9pbj1pPG4/bi1pKzU6NS0oaS1uKSx0LmF2YWlsX291dD1yPG8/by1yKzI1NzoyNTctKHItbyksYS5ob2xkPXUsYS5iaXRzPWN9fSx7fV0sMTE6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7dmFyIFo9dCgiLi4vdXRpbHMvY29tbW9uIiksUj10KCIuL2FkbGVyMzIiKSxDPXQoIi4vY3JjMzIiKSxOPXQoIi4vaW5mZmFzdCIpLE89dCgiLi9pbmZ0cmVlcyIpLEQ9MSxJPTIsVT0wLFQ9LTIsRj0xLGk9ODUyLG49NTkyO2Z1bmN0aW9uIEwodCl7cmV0dXJuKHQ+Pj4yNCYyNTUpKyh0Pj4+OCY2NTI4MCkrKCg2NTI4MCZ0KTw8OCkrKCgyNTUmdCk8PDI0KX1mdW5jdGlvbiByKCl7dGhpcy5tb2RlPTAsdGhpcy5sYXN0PSExLHRoaXMud3JhcD0wLHRoaXMuaGF2ZWRpY3Q9ITEsdGhpcy5mbGFncz0wLHRoaXMuZG1heD0wLHRoaXMuY2hlY2s9MCx0aGlzLnRvdGFsPTAsdGhpcy5oZWFkPW51bGwsdGhpcy53Yml0cz0wLHRoaXMud3NpemU9MCx0aGlzLndoYXZlPTAsdGhpcy53bmV4dD0wLHRoaXMud2luZG93PW51bGwsdGhpcy5ob2xkPTAsdGhpcy5iaXRzPTAsdGhpcy5sZW5ndGg9MCx0aGlzLm9mZnNldD0wLHRoaXMuZXh0cmE9MCx0aGlzLmxlbmNvZGU9bnVsbCx0aGlzLmRpc3Rjb2RlPW51bGwsdGhpcy5sZW5iaXRzPTAsdGhpcy5kaXN0Yml0cz0wLHRoaXMubmNvZGU9MCx0aGlzLm5sZW49MCx0aGlzLm5kaXN0PTAsdGhpcy5oYXZlPTAsdGhpcy5uZXh0PW51bGwsdGhpcy5sZW5zPW5ldyBaLkJ1ZjE2KDMyMCksdGhpcy53b3JrPW5ldyBaLkJ1ZjE2KDI4OCksdGhpcy5sZW5keW49bnVsbCx0aGlzLmRpc3RkeW49bnVsbCx0aGlzLnNhbmU9MCx0aGlzLmJhY2s9MCx0aGlzLndhcz0wfWZ1bmN0aW9uIHModCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KGU9dC5zdGF0ZSx0LnRvdGFsX2luPXQudG90YWxfb3V0PWUudG90YWw9MCx0Lm1zZz0iIixlLndyYXAmJih0LmFkbGVyPTEmZS53cmFwKSxlLm1vZGU9RixlLmxhc3Q9MCxlLmhhdmVkaWN0PTAsZS5kbWF4PTMyNzY4LGUuaGVhZD1udWxsLGUuaG9sZD0wLGUuYml0cz0wLGUubGVuY29kZT1lLmxlbmR5bj1uZXcgWi5CdWYzMihpKSxlLmRpc3Rjb2RlPWUuZGlzdGR5bj1uZXcgWi5CdWYzMihuKSxlLnNhbmU9MSxlLmJhY2s9LTEsVSk6VH1mdW5jdGlvbiBvKHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPygoZT10LnN0YXRlKS53c2l6ZT0wLGUud2hhdmU9MCxlLnduZXh0PTAscyh0KSk6VH1mdW5jdGlvbiBsKHQsZSl7dmFyIGEsaTtyZXR1cm4gdCYmdC5zdGF0ZT8oaT10LnN0YXRlLGU8MD8oYT0wLGU9LWUpOihhPTErKGU+PjQpLGU8NDgmJihlJj0xNSkpLGUmJihlPDh8fDE1PGUpP1Q6KG51bGwhPT1pLndpbmRvdyYmaS53Yml0cyE9PWUmJihpLndpbmRvdz1udWxsKSxpLndyYXA9YSxpLndiaXRzPWUsbyh0KSkpOlR9ZnVuY3Rpb24gaCh0LGUpe3ZhciBhLGk7cmV0dXJuIHQ/KGk9bmV3IHIsKHQuc3RhdGU9aSkud2luZG93PW51bGwsKGE9bCh0LGUpKSE9PVUmJih0LnN0YXRlPW51bGwpLGEpOlR9dmFyIGQsZixfPSEwO2Z1bmN0aW9uIEgodCl7aWYoXyl7dmFyIGU7Zm9yKGQ9bmV3IFouQnVmMzIoNTEyKSxmPW5ldyBaLkJ1ZjMyKDMyKSxlPTA7ZTwxNDQ7KXQubGVuc1tlKytdPTg7Zm9yKDtlPDI1NjspdC5sZW5zW2UrK109OTtmb3IoO2U8MjgwOyl0LmxlbnNbZSsrXT03O2Zvcig7ZTwyODg7KXQubGVuc1tlKytdPTg7Zm9yKE8oRCx0LmxlbnMsMCwyODgsZCwwLHQud29yayx7Yml0czo5fSksZT0wO2U8MzI7KXQubGVuc1tlKytdPTU7TyhJLHQubGVucywwLDMyLGYsMCx0Lndvcmsse2JpdHM6NX0pLF89ITF9dC5sZW5jb2RlPWQsdC5sZW5iaXRzPTksdC5kaXN0Y29kZT1mLHQuZGlzdGJpdHM9NX1mdW5jdGlvbiBqKHQsZSxhLGkpe3ZhciBuLHI9dC5zdGF0ZTtyZXR1cm4gbnVsbD09PXIud2luZG93JiYoci53c2l6ZT0xPDxyLndiaXRzLHIud25leHQ9MCxyLndoYXZlPTAsci53aW5kb3c9bmV3IFouQnVmOChyLndzaXplKSksaT49ci53c2l6ZT8oWi5hcnJheVNldChyLndpbmRvdyxlLGEtci53c2l6ZSxyLndzaXplLDApLHIud25leHQ9MCxyLndoYXZlPXIud3NpemUpOihpPChuPXIud3NpemUtci53bmV4dCkmJihuPWkpLFouYXJyYXlTZXQoci53aW5kb3csZSxhLWksbixyLnduZXh0KSwoaS09bik/KFouYXJyYXlTZXQoci53aW5kb3csZSxhLWksaSwwKSxyLnduZXh0PWksci53aGF2ZT1yLndzaXplKTooci53bmV4dCs9bixyLnduZXh0PT09ci53c2l6ZSYmKHIud25leHQ9MCksci53aGF2ZTxyLndzaXplJiYoci53aGF2ZSs9bikpKSwwfWEuaW5mbGF0ZVJlc2V0PW8sYS5pbmZsYXRlUmVzZXQyPWwsYS5pbmZsYXRlUmVzZXRLZWVwPXMsYS5pbmZsYXRlSW5pdD1mdW5jdGlvbih0KXtyZXR1cm4gaCh0LDE1KX0sYS5pbmZsYXRlSW5pdDI9aCxhLmluZmxhdGU9ZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzLG8sbCxoLGQsZixfLHUsYyxiLGcsbSx3LHAsdixrLHkseCx6LEIsUz0wLEU9bmV3IFouQnVmOCg0KSxBPVsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtpZighdHx8IXQuc3RhdGV8fCF0Lm91dHB1dHx8IXQuaW5wdXQmJjAhPT10LmF2YWlsX2luKXJldHVybiBUOzEyPT09KGE9dC5zdGF0ZSkubW9kZSYmKGEubW9kZT0xMykscz10Lm5leHRfb3V0LG49dC5vdXRwdXQsbD10LmF2YWlsX291dCxyPXQubmV4dF9pbixpPXQuaW5wdXQsbz10LmF2YWlsX2luLGg9YS5ob2xkLGQ9YS5iaXRzLGY9byxfPWwseD1VO3Q6Zm9yKDs7KXN3aXRjaChhLm1vZGUpe2Nhc2UgRjppZigwPT09YS53cmFwKXthLm1vZGU9MTM7YnJlYWt9Zm9yKDtkPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9aWYoMiZhLndyYXAmJjM1NjE1PT09aCl7RVthLmNoZWNrPTBdPTI1NSZoLEVbMV09aD4+PjgmMjU1LGEuY2hlY2s9QyhhLmNoZWNrLEUsMiwwKSxkPWg9MCxhLm1vZGU9MjticmVha31pZihhLmZsYWdzPTAsYS5oZWFkJiYoYS5oZWFkLmRvbmU9ITEpLCEoMSZhLndyYXApfHwoKCgyNTUmaCk8PDgpKyhoPj44KSklMzEpe3QubXNnPSJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrIixhLm1vZGU9MzA7YnJlYWt9aWYoOCE9KDE1JmgpKXt0Lm1zZz0idW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiLGEubW9kZT0zMDticmVha31pZihkLT00LHk9OCsoMTUmKGg+Pj49NCkpLDA9PT1hLndiaXRzKWEud2JpdHM9eTtlbHNlIGlmKHk+YS53Yml0cyl7dC5tc2c9ImludmFsaWQgd2luZG93IHNpemUiLGEubW9kZT0zMDticmVha31hLmRtYXg9MTw8eSx0LmFkbGVyPWEuY2hlY2s9MSxhLm1vZGU9NTEyJmg/MTA6MTIsZD1oPTA7YnJlYWs7Y2FzZSAyOmZvcig7ZDwxNjspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKGEuZmxhZ3M9aCw4IT0oMjU1JmEuZmxhZ3MpKXt0Lm1zZz0idW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiLGEubW9kZT0zMDticmVha31pZig1NzM0NCZhLmZsYWdzKXt0Lm1zZz0idW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IixhLm1vZGU9MzA7YnJlYWt9YS5oZWFkJiYoYS5oZWFkLnRleHQ9aD4+OCYxKSw1MTImYS5mbGFncyYmKEVbMF09MjU1JmgsRVsxXT1oPj4+OCYyNTUsYS5jaGVjaz1DKGEuY2hlY2ssRSwyLDApKSxkPWg9MCxhLm1vZGU9MztjYXNlIDM6Zm9yKDtkPDMyOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5oZWFkJiYoYS5oZWFkLnRpbWU9aCksNTEyJmEuZmxhZ3MmJihFWzBdPTI1NSZoLEVbMV09aD4+PjgmMjU1LEVbMl09aD4+PjE2JjI1NSxFWzNdPWg+Pj4yNCYyNTUsYS5jaGVjaz1DKGEuY2hlY2ssRSw0LDApKSxkPWg9MCxhLm1vZGU9NDtjYXNlIDQ6Zm9yKDtkPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5oZWFkJiYoYS5oZWFkLnhmbGFncz0yNTUmaCxhLmhlYWQub3M9aD4+OCksNTEyJmEuZmxhZ3MmJihFWzBdPTI1NSZoLEVbMV09aD4+PjgmMjU1LGEuY2hlY2s9QyhhLmNoZWNrLEUsMiwwKSksZD1oPTAsYS5tb2RlPTU7Y2FzZSA1OmlmKDEwMjQmYS5mbGFncyl7Zm9yKDtkPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5sZW5ndGg9aCxhLmhlYWQmJihhLmhlYWQuZXh0cmFfbGVuPWgpLDUxMiZhLmZsYWdzJiYoRVswXT0yNTUmaCxFWzFdPWg+Pj44JjI1NSxhLmNoZWNrPUMoYS5jaGVjayxFLDIsMCkpLGQ9aD0wfWVsc2UgYS5oZWFkJiYoYS5oZWFkLmV4dHJhPW51bGwpO2EubW9kZT02O2Nhc2UgNjppZigxMDI0JmEuZmxhZ3MmJihvPCh1PWEubGVuZ3RoKSYmKHU9byksdSYmKGEuaGVhZCYmKHk9YS5oZWFkLmV4dHJhX2xlbi1hLmxlbmd0aCxhLmhlYWQuZXh0cmF8fChhLmhlYWQuZXh0cmE9bmV3IEFycmF5KGEuaGVhZC5leHRyYV9sZW4pKSxaLmFycmF5U2V0KGEuaGVhZC5leHRyYSxpLHIsdSx5KSksNTEyJmEuZmxhZ3MmJihhLmNoZWNrPUMoYS5jaGVjayxpLHUscikpLG8tPXUscis9dSxhLmxlbmd0aC09dSksYS5sZW5ndGgpKWJyZWFrIHQ7YS5sZW5ndGg9MCxhLm1vZGU9NztjYXNlIDc6aWYoMjA0OCZhLmZsYWdzKXtpZigwPT09bylicmVhayB0O2Zvcih1PTA7eT1pW3IrdSsrXSxhLmhlYWQmJnkmJmEubGVuZ3RoPDY1NTM2JiYoYS5oZWFkLm5hbWUrPVN0cmluZy5mcm9tQ2hhckNvZGUoeSkpLHkmJnU8bzspO2lmKDUxMiZhLmZsYWdzJiYoYS5jaGVjaz1DKGEuY2hlY2ssaSx1LHIpKSxvLT11LHIrPXUseSlicmVhayB0fWVsc2UgYS5oZWFkJiYoYS5oZWFkLm5hbWU9bnVsbCk7YS5sZW5ndGg9MCxhLm1vZGU9ODtjYXNlIDg6aWYoNDA5NiZhLmZsYWdzKXtpZigwPT09bylicmVhayB0O2Zvcih1PTA7eT1pW3IrdSsrXSxhLmhlYWQmJnkmJmEubGVuZ3RoPDY1NTM2JiYoYS5oZWFkLmNvbW1lbnQrPVN0cmluZy5mcm9tQ2hhckNvZGUoeSkpLHkmJnU8bzspO2lmKDUxMiZhLmZsYWdzJiYoYS5jaGVjaz1DKGEuY2hlY2ssaSx1LHIpKSxvLT11LHIrPXUseSlicmVhayB0fWVsc2UgYS5oZWFkJiYoYS5oZWFkLmNvbW1lbnQ9bnVsbCk7YS5tb2RlPTk7Y2FzZSA5OmlmKDUxMiZhLmZsYWdzKXtmb3IoO2Q8MTY7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1pZihoIT09KDY1NTM1JmEuY2hlY2spKXt0Lm1zZz0iaGVhZGVyIGNyYyBtaXNtYXRjaCIsYS5tb2RlPTMwO2JyZWFrfWQ9aD0wfWEuaGVhZCYmKGEuaGVhZC5oY3JjPWEuZmxhZ3M+PjkmMSxhLmhlYWQuZG9uZT0hMCksdC5hZGxlcj1hLmNoZWNrPTAsYS5tb2RlPTEyO2JyZWFrO2Nhc2UgMTA6Zm9yKDtkPDMyOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9dC5hZGxlcj1hLmNoZWNrPUwoaCksZD1oPTAsYS5tb2RlPTExO2Nhc2UgMTE6aWYoMD09PWEuaGF2ZWRpY3QpcmV0dXJuIHQubmV4dF9vdXQ9cyx0LmF2YWlsX291dD1sLHQubmV4dF9pbj1yLHQuYXZhaWxfaW49byxhLmhvbGQ9aCxhLmJpdHM9ZCwyO3QuYWRsZXI9YS5jaGVjaz0xLGEubW9kZT0xMjtjYXNlIDEyOmlmKDU9PT1lfHw2PT09ZSlicmVhayB0O2Nhc2UgMTM6aWYoYS5sYXN0KXtoPj4+PTcmZCxkLT03JmQsYS5tb2RlPTI3O2JyZWFrfWZvcig7ZDwzOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9c3dpdGNoKGEubGFzdD0xJmgsZC09MSwzJihoPj4+PTEpKXtjYXNlIDA6YS5tb2RlPTE0O2JyZWFrO2Nhc2UgMTppZihIKGEpLGEubW9kZT0yMCw2IT09ZSlicmVhaztoPj4+PTIsZC09MjticmVhayB0O2Nhc2UgMjphLm1vZGU9MTc7YnJlYWs7Y2FzZSAzOnQubXNnPSJpbnZhbGlkIGJsb2NrIHR5cGUiLGEubW9kZT0zMH1oPj4+PTIsZC09MjticmVhaztjYXNlIDE0OmZvcihoPj4+PTcmZCxkLT03JmQ7ZDwzMjspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKCg2NTUzNSZoKSE9KGg+Pj4xNl42NTUzNSkpe3QubXNnPSJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIixhLm1vZGU9MzA7YnJlYWt9aWYoYS5sZW5ndGg9NjU1MzUmaCxkPWg9MCxhLm1vZGU9MTUsNj09PWUpYnJlYWsgdDtjYXNlIDE1OmEubW9kZT0xNjtjYXNlIDE2OmlmKHU9YS5sZW5ndGgpe2lmKG88dSYmKHU9byksbDx1JiYodT1sKSwwPT09dSlicmVhayB0O1ouYXJyYXlTZXQobixpLHIsdSxzKSxvLT11LHIrPXUsbC09dSxzKz11LGEubGVuZ3RoLT11O2JyZWFrfWEubW9kZT0xMjticmVhaztjYXNlIDE3OmZvcig7ZDwxNDspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKGEubmxlbj0yNTcrKDMxJmgpLGg+Pj49NSxkLT01LGEubmRpc3Q9MSsoMzEmaCksaD4+Pj01LGQtPTUsYS5uY29kZT00KygxNSZoKSxoPj4+PTQsZC09NCwyODY8YS5ubGVufHwzMDxhLm5kaXN0KXt0Lm1zZz0idG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMiLGEubW9kZT0zMDticmVha31hLmhhdmU9MCxhLm1vZGU9MTg7Y2FzZSAxODpmb3IoO2EuaGF2ZTxhLm5jb2RlOyl7Zm9yKDtkPDM7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1hLmxlbnNbQVthLmhhdmUrK11dPTcmaCxoPj4+PTMsZC09M31mb3IoO2EuaGF2ZTwxOTspYS5sZW5zW0FbYS5oYXZlKytdXT0wO2lmKGEubGVuY29kZT1hLmxlbmR5bixhLmxlbmJpdHM9Nyx6PXtiaXRzOmEubGVuYml0c30seD1PKDAsYS5sZW5zLDAsMTksYS5sZW5jb2RlLDAsYS53b3JrLHopLGEubGVuYml0cz16LmJpdHMseCl7dC5tc2c9ImludmFsaWQgY29kZSBsZW5ndGhzIHNldCIsYS5tb2RlPTMwO2JyZWFrfWEuaGF2ZT0wLGEubW9kZT0xOTtjYXNlIDE5OmZvcig7YS5oYXZlPGEubmxlbithLm5kaXN0Oyl7Zm9yKDttPShTPWEubGVuY29kZVtoJigxPDxhLmxlbmJpdHMpLTFdKT4+PjE2JjI1NSx3PTY1NTM1JlMsISgoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKHc8MTYpaD4+Pj1nLGQtPWcsYS5sZW5zW2EuaGF2ZSsrXT13O2Vsc2V7aWYoMTY9PT13KXtmb3IoQj1nKzI7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9aWYoaD4+Pj1nLGQtPWcsMD09PWEuaGF2ZSl7dC5tc2c9ImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiLGEubW9kZT0zMDticmVha315PWEubGVuc1thLmhhdmUtMV0sdT0zKygzJmgpLGg+Pj49MixkLT0yfWVsc2UgaWYoMTc9PT13KXtmb3IoQj1nKzM7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9ZC09Zyx5PTAsdT0zKyg3JihoPj4+PWcpKSxoPj4+PTMsZC09M31lbHNle2ZvcihCPWcrNztkPEI7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1kLT1nLHk9MCx1PTExKygxMjcmKGg+Pj49ZykpLGg+Pj49NyxkLT03fWlmKGEuaGF2ZSt1PmEubmxlbithLm5kaXN0KXt0Lm1zZz0iaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCIsYS5tb2RlPTMwO2JyZWFrfWZvcig7dS0tOylhLmxlbnNbYS5oYXZlKytdPXl9fWlmKDMwPT09YS5tb2RlKWJyZWFrO2lmKDA9PT1hLmxlbnNbMjU2XSl7dC5tc2c9ImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayIsYS5tb2RlPTMwO2JyZWFrfWlmKGEubGVuYml0cz05LHo9e2JpdHM6YS5sZW5iaXRzfSx4PU8oRCxhLmxlbnMsMCxhLm5sZW4sYS5sZW5jb2RlLDAsYS53b3JrLHopLGEubGVuYml0cz16LmJpdHMseCl7dC5tc2c9ImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCIsYS5tb2RlPTMwO2JyZWFrfWlmKGEuZGlzdGJpdHM9NixhLmRpc3Rjb2RlPWEuZGlzdGR5bix6PXtiaXRzOmEuZGlzdGJpdHN9LHg9TyhJLGEubGVucyxhLm5sZW4sYS5uZGlzdCxhLmRpc3Rjb2RlLDAsYS53b3JrLHopLGEuZGlzdGJpdHM9ei5iaXRzLHgpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlcyBzZXQiLGEubW9kZT0zMDticmVha31pZihhLm1vZGU9MjAsNj09PWUpYnJlYWsgdDtjYXNlIDIwOmEubW9kZT0yMTtjYXNlIDIxOmlmKDY8PW8mJjI1ODw9bCl7dC5uZXh0X291dD1zLHQuYXZhaWxfb3V0PWwsdC5uZXh0X2luPXIsdC5hdmFpbF9pbj1vLGEuaG9sZD1oLGEuYml0cz1kLE4odCxfKSxzPXQubmV4dF9vdXQsbj10Lm91dHB1dCxsPXQuYXZhaWxfb3V0LHI9dC5uZXh0X2luLGk9dC5pbnB1dCxvPXQuYXZhaWxfaW4saD1hLmhvbGQsZD1hLmJpdHMsMTI9PT1hLm1vZGUmJihhLmJhY2s9LTEpO2JyZWFrfWZvcihhLmJhY2s9MDttPShTPWEubGVuY29kZVtoJigxPDxhLmxlbmJpdHMpLTFdKT4+PjE2JjI1NSx3PTY1NTM1JlMsISgoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKG0mJjA9PSgyNDAmbSkpe2ZvcihwPWcsdj1tLGs9dzttPShTPWEubGVuY29kZVtrKygoaCYoMTw8cCt2KS0xKT4+cCldKT4+PjE2JjI1NSx3PTY1NTM1JlMsIShwKyhnPVM+Pj4yNCk8PWQpOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9aD4+Pj1wLGQtPXAsYS5iYWNrKz1wfWlmKGg+Pj49ZyxkLT1nLGEuYmFjays9ZyxhLmxlbmd0aD13LDA9PT1tKXthLm1vZGU9MjY7YnJlYWt9aWYoMzImbSl7YS5iYWNrPS0xLGEubW9kZT0xMjticmVha31pZig2NCZtKXt0Lm1zZz0iaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIixhLm1vZGU9MzA7YnJlYWt9YS5leHRyYT0xNSZtLGEubW9kZT0yMjtjYXNlIDIyOmlmKGEuZXh0cmEpe2ZvcihCPWEuZXh0cmE7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5sZW5ndGgrPWgmKDE8PGEuZXh0cmEpLTEsaD4+Pj1hLmV4dHJhLGQtPWEuZXh0cmEsYS5iYWNrKz1hLmV4dHJhfWEud2FzPWEubGVuZ3RoLGEubW9kZT0yMztjYXNlIDIzOmZvcig7bT0oUz1hLmRpc3Rjb2RlW2gmKDE8PGEuZGlzdGJpdHMpLTFdKT4+PjE2JjI1NSx3PTY1NTM1JlMsISgoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWlmKDA9PSgyNDAmbSkpe2ZvcihwPWcsdj1tLGs9dzttPShTPWEuZGlzdGNvZGVbaysoKGgmKDE8PHArdiktMSk+PnApXSk+Pj4xNiYyNTUsdz02NTUzNSZTLCEocCsoZz1TPj4+MjQpPD1kKTspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLGgrPWlbcisrXTw8ZCxkKz04fWg+Pj49cCxkLT1wLGEuYmFjays9cH1pZihoPj4+PWcsZC09ZyxhLmJhY2srPWcsNjQmbSl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgY29kZSIsYS5tb2RlPTMwO2JyZWFrfWEub2Zmc2V0PXcsYS5leHRyYT0xNSZtLGEubW9kZT0yNDtjYXNlIDI0OmlmKGEuZXh0cmEpe2ZvcihCPWEuZXh0cmE7ZDxCOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0saCs9aVtyKytdPDxkLGQrPTh9YS5vZmZzZXQrPWgmKDE8PGEuZXh0cmEpLTEsaD4+Pj1hLmV4dHJhLGQtPWEuZXh0cmEsYS5iYWNrKz1hLmV4dHJhfWlmKGEub2Zmc2V0PmEuZG1heCl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixhLm1vZGU9MzA7YnJlYWt9YS5tb2RlPTI1O2Nhc2UgMjU6aWYoMD09PWwpYnJlYWsgdDtpZih1PV8tbCxhLm9mZnNldD51KXtpZigodT1hLm9mZnNldC11KT5hLndoYXZlJiZhLnNhbmUpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsYS5tb2RlPTMwO2JyZWFrfXU+YS53bmV4dD8odS09YS53bmV4dCxjPWEud3NpemUtdSk6Yz1hLnduZXh0LXUsdT5hLmxlbmd0aCYmKHU9YS5sZW5ndGgpLGI9YS53aW5kb3d9ZWxzZSBiPW4sYz1zLWEub2Zmc2V0LHU9YS5sZW5ndGg7Zm9yKGw8dSYmKHU9bCksbC09dSxhLmxlbmd0aC09dTtuW3MrK109YltjKytdLC0tdTspOzA9PT1hLmxlbmd0aCYmKGEubW9kZT0yMSk7YnJlYWs7Y2FzZSAyNjppZigwPT09bClicmVhayB0O25bcysrXT1hLmxlbmd0aCxsLS0sYS5tb2RlPTIxO2JyZWFrO2Nhc2UgMjc6aWYoYS53cmFwKXtmb3IoO2Q8MzI7KXtpZigwPT09bylicmVhayB0O28tLSxofD1pW3IrK108PGQsZCs9OH1pZihfLT1sLHQudG90YWxfb3V0Kz1fLGEudG90YWwrPV8sXyYmKHQuYWRsZXI9YS5jaGVjaz1hLmZsYWdzP0MoYS5jaGVjayxuLF8scy1fKTpSKGEuY2hlY2ssbixfLHMtXykpLF89bCwoYS5mbGFncz9oOkwoaCkpIT09YS5jaGVjayl7dC5tc2c9ImluY29ycmVjdCBkYXRhIGNoZWNrIixhLm1vZGU9MzA7YnJlYWt9ZD1oPTB9YS5tb2RlPTI4O2Nhc2UgMjg6aWYoYS53cmFwJiZhLmZsYWdzKXtmb3IoO2Q8MzI7KXtpZigwPT09bylicmVhayB0O28tLSxoKz1pW3IrK108PGQsZCs9OH1pZihoIT09KDQyOTQ5NjcyOTUmYS50b3RhbCkpe3QubXNnPSJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrIixhLm1vZGU9MzA7YnJlYWt9ZD1oPTB9YS5tb2RlPTI5O2Nhc2UgMjk6eD0xO2JyZWFrIHQ7Y2FzZSAzMDp4PS0zO2JyZWFrIHQ7Y2FzZSAzMTpyZXR1cm4tNDtjYXNlIDMyOmRlZmF1bHQ6cmV0dXJuIFR9cmV0dXJuIHQubmV4dF9vdXQ9cyx0LmF2YWlsX291dD1sLHQubmV4dF9pbj1yLHQuYXZhaWxfaW49byxhLmhvbGQ9aCxhLmJpdHM9ZCwoYS53c2l6ZXx8XyE9PXQuYXZhaWxfb3V0JiZhLm1vZGU8MzAmJihhLm1vZGU8Mjd8fDQhPT1lKSkmJmoodCx0Lm91dHB1dCx0Lm5leHRfb3V0LF8tdC5hdmFpbF9vdXQpPyhhLm1vZGU9MzEsLTQpOihmLT10LmF2YWlsX2luLF8tPXQuYXZhaWxfb3V0LHQudG90YWxfaW4rPWYsdC50b3RhbF9vdXQrPV8sYS50b3RhbCs9XyxhLndyYXAmJl8mJih0LmFkbGVyPWEuY2hlY2s9YS5mbGFncz9DKGEuY2hlY2ssbixfLHQubmV4dF9vdXQtXyk6UihhLmNoZWNrLG4sXyx0Lm5leHRfb3V0LV8pKSx0LmRhdGFfdHlwZT1hLmJpdHMrKGEubGFzdD82NDowKSsoMTI9PT1hLm1vZGU/MTI4OjApKygyMD09PWEubW9kZXx8MTU9PT1hLm1vZGU/MjU2OjApLCgwPT09ZiYmMD09PV98fDQ9PT1lKSYmeD09PVUmJih4PS01KSx4KX0sYS5pbmZsYXRlRW5kPWZ1bmN0aW9uKHQpe2lmKCF0fHwhdC5zdGF0ZSlyZXR1cm4gVDt2YXIgZT10LnN0YXRlO3JldHVybiBlLndpbmRvdyYmKGUud2luZG93PW51bGwpLHQuc3RhdGU9bnVsbCxVfSxhLmluZmxhdGVHZXRIZWFkZXI9ZnVuY3Rpb24odCxlKXt2YXIgYTtyZXR1cm4gdCYmdC5zdGF0ZT8wPT0oMiYoYT10LnN0YXRlKS53cmFwKT9UOigoYS5oZWFkPWUpLmRvbmU9ITEsVSk6VH0sYS5pbmZsYXRlU2V0RGljdGlvbmFyeT1mdW5jdGlvbih0LGUpe3ZhciBhLGk9ZS5sZW5ndGg7cmV0dXJuIHQmJnQuc3RhdGU/MCE9PShhPXQuc3RhdGUpLndyYXAmJjExIT09YS5tb2RlP1Q6MTE9PT1hLm1vZGUmJlIoMSxlLGksMCkhPT1hLmNoZWNrPy0zOmoodCxlLGksaSk/KGEubW9kZT0zMSwtNCk6KGEuaGF2ZWRpY3Q9MSxVKTpUfSxhLmluZmxhdGVJbmZvPSJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIn0seyIuLi91dGlscy9jb21tb24iOjMsIi4vYWRsZXIzMiI6NSwiLi9jcmMzMiI6NywiLi9pbmZmYXN0IjoxMCwiLi9pbmZ0cmVlcyI6MTJ9XSwxMjpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgRD10KCIuLi91dGlscy9jb21tb24iKSxJPVszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDAsMF0sVT1bMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTcsMTcsMTcsMTcsMTgsMTgsMTgsMTgsMTksMTksMTksMTksMjAsMjAsMjAsMjAsMjEsMjEsMjEsMjEsMTYsNzIsNzhdLFQ9WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3NywwLDBdLEY9WzE2LDE2LDE2LDE2LDE3LDE3LDE4LDE4LDE5LDE5LDIwLDIwLDIxLDIxLDIyLDIyLDIzLDIzLDI0LDI0LDI1LDI1LDI2LDI2LDI3LDI3LDI4LDI4LDI5LDI5LDY0LDY0XTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlLGEsaSxuLHIscyxvKXt2YXIgbCxoLGQsZixfLHUsYyxiLGcsbT1vLmJpdHMsdz0wLHA9MCx2PTAsaz0wLHk9MCx4PTAsej0wLEI9MCxTPTAsRT0wLEE9bnVsbCxaPTAsUj1uZXcgRC5CdWYxNigxNiksQz1uZXcgRC5CdWYxNigxNiksTj1udWxsLE89MDtmb3Iodz0wO3c8PTE1O3crKylSW3ddPTA7Zm9yKHA9MDtwPGk7cCsrKVJbZVthK3BdXSsrO2Zvcih5PW0saz0xNTsxPD1rJiYwPT09UltrXTtrLS0pO2lmKGs8eSYmKHk9ayksMD09PWspcmV0dXJuIG5bcisrXT0yMDk3MTUyMCxuW3IrK109MjA5NzE1MjAsby5iaXRzPTEsMDtmb3Iodj0xO3Y8ayYmMD09PVJbdl07disrKTtmb3IoeTx2JiYoeT12KSx3PUI9MTt3PD0xNTt3KyspaWYoQjw8PTEsKEItPVJbd10pPDApcmV0dXJuLTE7aWYoMDxCJiYoMD09PXR8fDEhPT1rKSlyZXR1cm4tMTtmb3IoQ1sxXT0wLHc9MTt3PDE1O3crKylDW3crMV09Q1t3XStSW3ddO2ZvcihwPTA7cDxpO3ArKykwIT09ZVthK3BdJiYoc1tDW2VbYStwXV0rK109cCk7aWYoMD09PXQ/KEE9Tj1zLHU9MTkpOjE9PT10PyhBPUksWi09MjU3LE49VSxPLT0yNTcsdT0yNTYpOihBPVQsTj1GLHU9LTEpLHc9dixfPXIsej1wPUU9MCxkPS0xLGY9KFM9MTw8KHg9eSkpLTEsMT09PXQmJjg1MjxTfHwyPT09dCYmNTkyPFMpcmV0dXJuIDE7Zm9yKDs7KXtmb3IoYz13LXosc1twXTx1PyhiPTAsZz1zW3BdKTpzW3BdPnU/KGI9TltPK3NbcF1dLGc9QVtaK3NbcF1dKTooYj05NixnPTApLGw9MTw8dy16LHY9aD0xPDx4O25bXysoRT4+eikrKGgtPWwpXT1jPDwyNHxiPDwxNnxnfDAsMCE9PWg7KTtmb3IobD0xPDx3LTE7RSZsOylsPj49MTtpZigwIT09bD8oRSY9bC0xLEUrPWwpOkU9MCxwKyssMD09LS1SW3ddKXtpZih3PT09aylicmVhazt3PWVbYStzW3BdXX1pZih5PHcmJihFJmYpIT09ZCl7Zm9yKDA9PT16JiYoej15KSxfKz12LEI9MTw8KHg9dy16KTt4K3o8ayYmISgoQi09Ult4K3pdKTw9MCk7KXgrKyxCPDw9MTtpZihTKz0xPDx4LDE9PT10JiY4NTI8U3x8Mj09PXQmJjU5MjxTKXJldHVybiAxO25bZD1FJmZdPXk8PDI0fHg8PDE2fF8tcnwwfX1yZXR1cm4gMCE9PUUmJihuW18rRV09dy16PDwyNHw2NDw8MTZ8MCksby5iaXRzPXksMH19LHsiLi4vdXRpbHMvY29tbW9uIjozfV0sMTM6W2Z1bmN0aW9uKHQsZSxhKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPXsyOiJuZWVkIGRpY3Rpb25hcnkiLDE6InN0cmVhbSBlbmQiLDA6IiIsIi0xIjoiZmlsZSBlcnJvciIsIi0yIjoic3RyZWFtIGVycm9yIiwiLTMiOiJkYXRhIGVycm9yIiwiLTQiOiJpbnN1ZmZpY2llbnQgbWVtb3J5IiwiLTUiOiJidWZmZXIgZXJyb3IiLCItNiI6ImluY29tcGF0aWJsZSB2ZXJzaW9uIn19LHt9XSwxNDpbZnVuY3Rpb24odCxlLGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgbD10KCIuLi91dGlscy9jb21tb24iKSxvPTAsaD0xO2Z1bmN0aW9uIGkodCl7Zm9yKHZhciBlPXQubGVuZ3RoOzA8PS0tZTspdFtlXT0wfXZhciBkPTAscz0yOSxmPTI1NixfPWYrMStzLHU9MzAsYz0xOSxnPTIqXysxLG09MTUsbj0xNixiPTcsdz0yNTYscD0xNix2PTE3LGs9MTgseT1bMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSx4PVswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSx6PVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XSxCPVsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSxTPW5ldyBBcnJheSgyKihfKzIpKTtpKFMpO3ZhciBFPW5ldyBBcnJheSgyKnUpO2koRSk7dmFyIEE9bmV3IEFycmF5KDUxMik7aShBKTt2YXIgWj1uZXcgQXJyYXkoMjU2KTtpKFopO3ZhciBSPW5ldyBBcnJheShzKTtpKFIpO3ZhciBDLE4sTyxEPW5ldyBBcnJheSh1KTtmdW5jdGlvbiBJKHQsZSxhLGksbil7dGhpcy5zdGF0aWNfdHJlZT10LHRoaXMuZXh0cmFfYml0cz1lLHRoaXMuZXh0cmFfYmFzZT1hLHRoaXMuZWxlbXM9aSx0aGlzLm1heF9sZW5ndGg9bix0aGlzLmhhc19zdHJlZT10JiZ0Lmxlbmd0aH1mdW5jdGlvbiByKHQsZSl7dGhpcy5keW5fdHJlZT10LHRoaXMubWF4X2NvZGU9MCx0aGlzLnN0YXRfZGVzYz1lfWZ1bmN0aW9uIFUodCl7cmV0dXJuIHQ8MjU2P0FbdF06QVsyNTYrKHQ+Pj43KV19ZnVuY3Rpb24gVCh0LGUpe3QucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPTI1NSZlLHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPWU+Pj44JjI1NX1mdW5jdGlvbiBGKHQsZSxhKXt0LmJpX3ZhbGlkPm4tYT8odC5iaV9idWZ8PWU8PHQuYmlfdmFsaWQmNjU1MzUsVCh0LHQuYmlfYnVmKSx0LmJpX2J1Zj1lPj5uLXQuYmlfdmFsaWQsdC5iaV92YWxpZCs9YS1uKToodC5iaV9idWZ8PWU8PHQuYmlfdmFsaWQmNjU1MzUsdC5iaV92YWxpZCs9YSl9ZnVuY3Rpb24gTCh0LGUsYSl7Rih0LGFbMiplXSxhWzIqZSsxXSl9ZnVuY3Rpb24gSCh0LGUpe2Zvcih2YXIgYT0wO2F8PTEmdCx0Pj4+PTEsYTw8PTEsMDwtLWU7KTtyZXR1cm4gYT4+PjF9ZnVuY3Rpb24gaih0LGUsYSl7dmFyIGksbixyPW5ldyBBcnJheShtKzEpLHM9MDtmb3IoaT0xO2k8PW07aSsrKXJbaV09cz1zK2FbaS0xXTw8MTtmb3Iobj0wO248PWU7bisrKXt2YXIgbz10WzIqbisxXTswIT09byYmKHRbMipuXT1IKHJbb10rKyxvKSl9fWZ1bmN0aW9uIEsodCl7dmFyIGU7Zm9yKGU9MDtlPF87ZSsrKXQuZHluX2x0cmVlWzIqZV09MDtmb3IoZT0wO2U8dTtlKyspdC5keW5fZHRyZWVbMiplXT0wO2ZvcihlPTA7ZTxjO2UrKyl0LmJsX3RyZWVbMiplXT0wO3QuZHluX2x0cmVlWzIqd109MSx0Lm9wdF9sZW49dC5zdGF0aWNfbGVuPTAsdC5sYXN0X2xpdD10Lm1hdGNoZXM9MH1mdW5jdGlvbiBNKHQpezg8dC5iaV92YWxpZD9UKHQsdC5iaV9idWYpOjA8dC5iaV92YWxpZCYmKHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPXQuYmlfYnVmKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MH1mdW5jdGlvbiBQKHQsZSxhLGkpe3ZhciBuPTIqZSxyPTIqYTtyZXR1cm4gdFtuXTx0W3JdfHx0W25dPT09dFtyXSYmaVtlXTw9aVthXX1mdW5jdGlvbiBZKHQsZSxhKXtmb3IodmFyIGk9dC5oZWFwW2FdLG49YTw8MTtuPD10LmhlYXBfbGVuJiYobjx0LmhlYXBfbGVuJiZQKGUsdC5oZWFwW24rMV0sdC5oZWFwW25dLHQuZGVwdGgpJiZuKyssIVAoZSxpLHQuaGVhcFtuXSx0LmRlcHRoKSk7KXQuaGVhcFthXT10LmhlYXBbbl0sYT1uLG48PD0xO3QuaGVhcFthXT1pfWZ1bmN0aW9uIHEodCxlLGEpe3ZhciBpLG4scixzLG89MDtpZigwIT09dC5sYXN0X2xpdClmb3IoO2k9dC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqb108PDh8dC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqbysxXSxuPXQucGVuZGluZ19idWZbdC5sX2J1ZitvXSxvKyssMD09PWk/TCh0LG4sZSk6KEwodCwocj1aW25dKStmKzEsZSksMCE9PShzPXlbcl0pJiZGKHQsbi09UltyXSxzKSxMKHQscj1VKC0taSksYSksMCE9PShzPXhbcl0pJiZGKHQsaS09RFtyXSxzKSksbzx0Lmxhc3RfbGl0Oyk7TCh0LHcsZSl9ZnVuY3Rpb24gRyh0LGUpe3ZhciBhLGksbixyPWUuZHluX3RyZWUscz1lLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxvPWUuc3RhdF9kZXNjLmhhc19zdHJlZSxsPWUuc3RhdF9kZXNjLmVsZW1zLGg9LTE7Zm9yKHQuaGVhcF9sZW49MCx0LmhlYXBfbWF4PWcsYT0wO2E8bDthKyspMCE9PXJbMiphXT8odC5oZWFwWysrdC5oZWFwX2xlbl09aD1hLHQuZGVwdGhbYV09MCk6clsyKmErMV09MDtmb3IoO3QuaGVhcF9sZW48MjspclsyKihuPXQuaGVhcFsrK3QuaGVhcF9sZW5dPWg8Mj8rK2g6MCldPTEsdC5kZXB0aFtuXT0wLHQub3B0X2xlbi0tLG8mJih0LnN0YXRpY19sZW4tPXNbMipuKzFdKTtmb3IoZS5tYXhfY29kZT1oLGE9dC5oZWFwX2xlbj4+MTsxPD1hO2EtLSlZKHQscixhKTtmb3Iobj1sO2E9dC5oZWFwWzFdLHQuaGVhcFsxXT10LmhlYXBbdC5oZWFwX2xlbi0tXSxZKHQsciwxKSxpPXQuaGVhcFsxXSx0LmhlYXBbLS10LmhlYXBfbWF4XT1hLHQuaGVhcFstLXQuaGVhcF9tYXhdPWksclsyKm5dPXJbMiphXStyWzIqaV0sdC5kZXB0aFtuXT0odC5kZXB0aFthXT49dC5kZXB0aFtpXT90LmRlcHRoW2FdOnQuZGVwdGhbaV0pKzEsclsyKmErMV09clsyKmkrMV09bix0LmhlYXBbMV09bisrLFkodCxyLDEpLDI8PXQuaGVhcF9sZW47KTt0LmhlYXBbLS10LmhlYXBfbWF4XT10LmhlYXBbMV0sZnVuY3Rpb24odCxlKXt2YXIgYSxpLG4scixzLG8sbD1lLmR5bl90cmVlLGg9ZS5tYXhfY29kZSxkPWUuc3RhdF9kZXNjLnN0YXRpY190cmVlLGY9ZS5zdGF0X2Rlc2MuaGFzX3N0cmVlLF89ZS5zdGF0X2Rlc2MuZXh0cmFfYml0cyx1PWUuc3RhdF9kZXNjLmV4dHJhX2Jhc2UsYz1lLnN0YXRfZGVzYy5tYXhfbGVuZ3RoLGI9MDtmb3Iocj0wO3I8PW07cisrKXQuYmxfY291bnRbcl09MDtmb3IobFsyKnQuaGVhcFt0LmhlYXBfbWF4XSsxXT0wLGE9dC5oZWFwX21heCsxO2E8ZzthKyspYzwocj1sWzIqbFsyKihpPXQuaGVhcFthXSkrMV0rMV0rMSkmJihyPWMsYisrKSxsWzIqaSsxXT1yLGg8aXx8KHQuYmxfY291bnRbcl0rKyxzPTAsdTw9aSYmKHM9X1tpLXVdKSxvPWxbMippXSx0Lm9wdF9sZW4rPW8qKHIrcyksZiYmKHQuc3RhdGljX2xlbis9byooZFsyKmkrMV0rcykpKTtpZigwIT09Yil7ZG97Zm9yKHI9Yy0xOzA9PT10LmJsX2NvdW50W3JdOylyLS07dC5ibF9jb3VudFtyXS0tLHQuYmxfY291bnRbcisxXSs9Mix0LmJsX2NvdW50W2NdLS0sYi09Mn13aGlsZSgwPGIpO2ZvcihyPWM7MCE9PXI7ci0tKWZvcihpPXQuYmxfY291bnRbcl07MCE9PWk7KWg8KG49dC5oZWFwWy0tYV0pfHwobFsyKm4rMV0hPT1yJiYodC5vcHRfbGVuKz0oci1sWzIqbisxXSkqbFsyKm5dLGxbMipuKzFdPXIpLGktLSl9fSh0LGUpLGoocixoLHQuYmxfY291bnQpfWZ1bmN0aW9uIFgodCxlLGEpe3ZhciBpLG4scj0tMSxzPWVbMV0sbz0wLGw9NyxoPTQ7Zm9yKDA9PT1zJiYobD0xMzgsaD0zKSxlWzIqKGErMSkrMV09NjU1MzUsaT0wO2k8PWE7aSsrKW49cyxzPWVbMiooaSsxKSsxXSwrK288bCYmbj09PXN8fChvPGg/dC5ibF90cmVlWzIqbl0rPW86MCE9PW4/KG4hPT1yJiZ0LmJsX3RyZWVbMipuXSsrLHQuYmxfdHJlZVsyKnBdKyspOm88PTEwP3QuYmxfdHJlZVsyKnZdKys6dC5ibF90cmVlWzIqa10rKyxyPW4sKG89MCk9PT1zPyhsPTEzOCxoPTMpOm49PT1zPyhsPTYsaD0zKToobD03LGg9NCkpfWZ1bmN0aW9uIFcodCxlLGEpe3ZhciBpLG4scj0tMSxzPWVbMV0sbz0wLGw9NyxoPTQ7Zm9yKDA9PT1zJiYobD0xMzgsaD0zKSxpPTA7aTw9YTtpKyspaWYobj1zLHM9ZVsyKihpKzEpKzFdLCEoKytvPGwmJm49PT1zKSl7aWYobzxoKWZvcig7TCh0LG4sdC5ibF90cmVlKSwwIT0tLW87KTtlbHNlIDAhPT1uPyhuIT09ciYmKEwodCxuLHQuYmxfdHJlZSksby0tKSxMKHQscCx0LmJsX3RyZWUpLEYodCxvLTMsMikpOm88PTEwPyhMKHQsdix0LmJsX3RyZWUpLEYodCxvLTMsMykpOihMKHQsayx0LmJsX3RyZWUpLEYodCxvLTExLDcpKTtyPW4sKG89MCk9PT1zPyhsPTEzOCxoPTMpOm49PT1zPyhsPTYsaD0zKToobD03LGg9NCl9fWkoRCk7dmFyIEo9ITE7ZnVuY3Rpb24gUSh0LGUsYSxpKXt2YXIgbixyLHMsbztGKHQsKGQ8PDEpKyhpPzE6MCksMykscj1lLHM9YSxvPSEwLE0obj10KSxvJiYoVChuLHMpLFQobix+cykpLGwuYXJyYXlTZXQobi5wZW5kaW5nX2J1ZixuLndpbmRvdyxyLHMsbi5wZW5kaW5nKSxuLnBlbmRpbmcrPXN9YS5fdHJfaW5pdD1mdW5jdGlvbih0KXtKfHwoZnVuY3Rpb24oKXt2YXIgdCxlLGEsaSxuLHI9bmV3IEFycmF5KG0rMSk7Zm9yKGk9YT0wO2k8cy0xO2krKylmb3IoUltpXT1hLHQ9MDt0PDE8PHlbaV07dCsrKVpbYSsrXT1pO2ZvcihaW2EtMV09aSxpPW49MDtpPDE2O2krKylmb3IoRFtpXT1uLHQ9MDt0PDE8PHhbaV07dCsrKUFbbisrXT1pO2ZvcihuPj49NztpPHU7aSsrKWZvcihEW2ldPW48PDcsdD0wO3Q8MTw8eFtpXS03O3QrKylBWzI1NituKytdPWk7Zm9yKGU9MDtlPD1tO2UrKylyW2VdPTA7Zm9yKHQ9MDt0PD0xNDM7KVNbMip0KzFdPTgsdCsrLHJbOF0rKztmb3IoO3Q8PTI1NTspU1syKnQrMV09OSx0Kysscls5XSsrO2Zvcig7dDw9Mjc5OylTWzIqdCsxXT03LHQrKyxyWzddKys7Zm9yKDt0PD0yODc7KVNbMip0KzFdPTgsdCsrLHJbOF0rKztmb3IoaihTLF8rMSxyKSx0PTA7dDx1O3QrKylFWzIqdCsxXT01LEVbMip0XT1IKHQsNSk7Qz1uZXcgSShTLHksZisxLF8sbSksTj1uZXcgSShFLHgsMCx1LG0pLE89bmV3IEkobmV3IEFycmF5KDApLHosMCxjLGIpfSgpLEo9ITApLHQubF9kZXNjPW5ldyByKHQuZHluX2x0cmVlLEMpLHQuZF9kZXNjPW5ldyByKHQuZHluX2R0cmVlLE4pLHQuYmxfZGVzYz1uZXcgcih0LmJsX3RyZWUsTyksdC5iaV9idWY9MCx0LmJpX3ZhbGlkPTAsSyh0KX0sYS5fdHJfc3RvcmVkX2Jsb2NrPVEsYS5fdHJfZmx1c2hfYmxvY2s9ZnVuY3Rpb24odCxlLGEsaSl7dmFyIG4scixzPTA7MDx0LmxldmVsPygyPT09dC5zdHJtLmRhdGFfdHlwZSYmKHQuc3RybS5kYXRhX3R5cGU9ZnVuY3Rpb24odCl7dmFyIGUsYT00MDkzNjI0NDQ3O2ZvcihlPTA7ZTw9MzE7ZSsrLGE+Pj49MSlpZigxJmEmJjAhPT10LmR5bl9sdHJlZVsyKmVdKXJldHVybiBvO2lmKDAhPT10LmR5bl9sdHJlZVsxOF18fDAhPT10LmR5bl9sdHJlZVsyMF18fDAhPT10LmR5bl9sdHJlZVsyNl0pcmV0dXJuIGg7Zm9yKGU9MzI7ZTxmO2UrKylpZigwIT09dC5keW5fbHRyZWVbMiplXSlyZXR1cm4gaDtyZXR1cm4gb30odCkpLEcodCx0LmxfZGVzYyksRyh0LHQuZF9kZXNjKSxzPWZ1bmN0aW9uKHQpe3ZhciBlO2ZvcihYKHQsdC5keW5fbHRyZWUsdC5sX2Rlc2MubWF4X2NvZGUpLFgodCx0LmR5bl9kdHJlZSx0LmRfZGVzYy5tYXhfY29kZSksRyh0LHQuYmxfZGVzYyksZT1jLTE7Mzw9ZSYmMD09PXQuYmxfdHJlZVsyKkJbZV0rMV07ZS0tKTtyZXR1cm4gdC5vcHRfbGVuKz0zKihlKzEpKzUrNSs0LGV9KHQpLG49dC5vcHRfbGVuKzMrNz4+PjMsKHI9dC5zdGF0aWNfbGVuKzMrNz4+PjMpPD1uJiYobj1yKSk6bj1yPWErNSxhKzQ8PW4mJi0xIT09ZT9RKHQsZSxhLGkpOjQ9PT10LnN0cmF0ZWd5fHxyPT09bj8oRih0LDIrKGk/MTowKSwzKSxxKHQsUyxFKSk6KEYodCw0KyhpPzE6MCksMyksZnVuY3Rpb24odCxlLGEsaSl7dmFyIG47Zm9yKEYodCxlLTI1Nyw1KSxGKHQsYS0xLDUpLEYodCxpLTQsNCksbj0wO248aTtuKyspRih0LHQuYmxfdHJlZVsyKkJbbl0rMV0sMyk7Vyh0LHQuZHluX2x0cmVlLGUtMSksVyh0LHQuZHluX2R0cmVlLGEtMSl9KHQsdC5sX2Rlc2MubWF4X2NvZGUrMSx0LmRfZGVzYy5tYXhfY29kZSsxLHMrMSkscSh0LHQuZHluX2x0cmVlLHQuZHluX2R0cmVlKSksSyh0KSxpJiZNKHQpfSxhLl90cl90YWxseT1mdW5jdGlvbih0LGUsYSl7cmV0dXJuIHQucGVuZGluZ19idWZbdC5kX2J1ZisyKnQubGFzdF9saXRdPWU+Pj44JjI1NSx0LnBlbmRpbmdfYnVmW3QuZF9idWYrMip0Lmxhc3RfbGl0KzFdPTI1NSZlLHQucGVuZGluZ19idWZbdC5sX2J1Zit0Lmxhc3RfbGl0XT0yNTUmYSx0Lmxhc3RfbGl0KyssMD09PWU/dC5keW5fbHRyZWVbMiphXSsrOih0Lm1hdGNoZXMrKyxlLS0sdC5keW5fbHRyZWVbMiooWlthXStmKzEpXSsrLHQuZHluX2R0cmVlWzIqVShlKV0rKyksdC5sYXN0X2xpdD09PXQubGl0X2J1ZnNpemUtMX0sYS5fdHJfYWxpZ249ZnVuY3Rpb24odCl7dmFyIGU7Rih0LDIsMyksTCh0LHcsUyksMTY9PT0oZT10KS5iaV92YWxpZD8oVChlLGUuYmlfYnVmKSxlLmJpX2J1Zj0wLGUuYmlfdmFsaWQ9MCk6ODw9ZS5iaV92YWxpZCYmKGUucGVuZGluZ19idWZbZS5wZW5kaW5nKytdPTI1NSZlLmJpX2J1ZixlLmJpX2J1Zj4+PTgsZS5iaV92YWxpZC09OCl9fSx7Ii4uL3V0aWxzL2NvbW1vbiI6M31dLDE1OltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz0iIix0aGlzLnN0YXRlPW51bGwsdGhpcy5kYXRhX3R5cGU9Mix0aGlzLmFkbGVyPTB9fSx7fV0sIi8iOltmdW5jdGlvbih0LGUsYSl7InVzZSBzdHJpY3QiO3ZhciBpPXt9OygwLHQoIi4vbGliL3V0aWxzL2NvbW1vbiIpLmFzc2lnbikoaSx0KCIuL2xpYi9kZWZsYXRlIiksdCgiLi9saWIvaW5mbGF0ZSIpLHQoIi4vbGliL3psaWIvY29uc3RhbnRzIikpLGUuZXhwb3J0cz1pfSx7Ii4vbGliL2RlZmxhdGUiOjEsIi4vbGliL2luZmxhdGUiOjIsIi4vbGliL3V0aWxzL2NvbW1vbiI6MywiLi9saWIvemxpYi9jb25zdGFudHMiOjZ9XX0se30sW10pKCIvIil9KTsKdmFyIEJhc2U2ND17X2tleVN0cjoiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0iLGVuY29kZTpmdW5jdGlvbihhLGIpe3ZhciBjPSIiLGQsZSxmLGcsayxsLG09MDtmb3IobnVsbCE9YiYmYnx8KGE9QmFzZTY0Ll91dGY4X2VuY29kZShhKSk7bTxhLmxlbmd0aDspZD1hLmNoYXJDb2RlQXQobSsrKSxlPWEuY2hhckNvZGVBdChtKyspLGY9YS5jaGFyQ29kZUF0KG0rKyksZz1kPj4yLGQ9KGQmMyk8PDR8ZT4+NCxrPShlJjE1KTw8MnxmPj42LGw9ZiY2Myxpc05hTihlKT9rPWw9NjQ6aXNOYU4oZikmJihsPTY0KSxjPWMrdGhpcy5fa2V5U3RyLmNoYXJBdChnKSt0aGlzLl9rZXlTdHIuY2hhckF0KGQpK3RoaXMuX2tleVN0ci5jaGFyQXQoaykrdGhpcy5fa2V5U3RyLmNoYXJBdChsKTtyZXR1cm4gY30sZGVjb2RlOmZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6ITE7dmFyIGM9IiIsZCxlLGYsZyxrLGw9MDtmb3IoYT1hLnJlcGxhY2UoL1teQS1aYS16MC05XCtcL1w9XS9nLAoiIik7bDxhLmxlbmd0aDspZD10aGlzLl9rZXlTdHIuaW5kZXhPZihhLmNoYXJBdChsKyspKSxlPXRoaXMuX2tleVN0ci5pbmRleE9mKGEuY2hhckF0KGwrKykpLGc9dGhpcy5fa2V5U3RyLmluZGV4T2YoYS5jaGFyQXQobCsrKSksaz10aGlzLl9rZXlTdHIuaW5kZXhPZihhLmNoYXJBdChsKyspKSxkPWQ8PDJ8ZT4+NCxlPShlJjE1KTw8NHxnPj4yLGY9KGcmMyk8PDZ8ayxjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQpLDY0IT1nJiYoYys9U3RyaW5nLmZyb21DaGFyQ29kZShlKSksNjQhPWsmJihjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGYpKTtifHwoYz1CYXNlNjQuX3V0ZjhfZGVjb2RlKGMpKTtyZXR1cm4gY30sX3V0ZjhfZW5jb2RlOmZ1bmN0aW9uKGEpe2E9YS5yZXBsYWNlKC9cclxuL2csIlxuIik7Zm9yKHZhciBiPSIiLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGFyQ29kZUF0KGMpOzEyOD5kP2IrPVN0cmluZy5mcm9tQ2hhckNvZGUoZCk6KDEyNzxkJiYyMDQ4PmQ/Yis9ClN0cmluZy5mcm9tQ2hhckNvZGUoZD4+NnwxOTIpOihiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQ+PjEyfDIyNCksYis9U3RyaW5nLmZyb21DaGFyQ29kZShkPj42JjYzfDEyOCkpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoZCY2M3wxMjgpKX1yZXR1cm4gYn0sX3V0ZjhfZGVjb2RlOmZ1bmN0aW9uKGEpe3ZhciBiPSIiLGM9MCxkO2ZvcihjMT1jMj0wO2M8YS5sZW5ndGg7KWQ9YS5jaGFyQ29kZUF0KGMpLDEyOD5kPyhiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQpLGMrKyk6MTkxPGQmJjIyND5kPyhjMj1hLmNoYXJDb2RlQXQoYysxKSxiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChkJjMxKTw8NnxjMiY2MyksYys9Mik6KGMyPWEuY2hhckNvZGVBdChjKzEpLGMzPWEuY2hhckNvZGVBdChjKzIpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGQmMTUpPDwxMnwoYzImNjMpPDw2fGMzJjYzKSxjKz0zKTtyZXR1cm4gYn19O3dpbmRvdy51cmxQYXJhbXM9d2luZG93LnVybFBhcmFtc3x8e307d2luZG93LmlzTG9jYWxTdG9yYWdlPXdpbmRvdy5pc0xvY2FsU3RvcmFnZXx8ITE7d2luZG93Lm14TG9hZFNldHRpbmdzPXdpbmRvdy5teExvYWRTZXR0aW5nc3x8IjEiIT11cmxQYXJhbXMuY29uZmlndXJlO3dpbmRvdy5pc1N2Z0Jyb3dzZXI9d2luZG93LmlzU3ZnQnJvd3Nlcnx8bnVsbD09bmF2aWdhdG9yLnVzZXJBZ2VudHx8MD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUiKXx8OTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlO3dpbmRvdy5EUkFXSU9fQkFTRV9VUkw9d2luZG93LkRSQVdJT19CQVNFX1VSTHx8KC8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk/d2luZG93LmxvY2F0aW9uLnByb3RvY29sKyIvLyIrd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lOiJodHRwczovL2FwcC5kaWFncmFtcy5uZXQiKTsKd2luZG93LkVYUE9SVF9VUkw9d2luZG93LkVYUE9SVF9VUkx8fCJodHRwczovL2V4cC5kcmF3LmlvL0ltYWdlRXhwb3J0NC9leHBvcnQiO3dpbmRvdy5QTEFOVF9VUkw9d2luZG93LlBMQU5UX1VSTHx8Imh0dHBzOi8vZXhwLXBsYW50LmRyYXcuaW8vcGxhbnR1bWwtMS0yMDIwLTIiO3dpbmRvdy5EUkFXX01BVEhfVVJMPXdpbmRvdy5EUkFXX01BVEhfVVJMfHx3aW5kb3cuRFJBV0lPX0JBU0VfVVJMKyIvbWF0aCI7d2luZG93LlZTRF9DT05WRVJUX1VSTD13aW5kb3cuVlNEX0NPTlZFUlRfVVJMfHwiaHR0cHM6Ly9jb252ZXJ0LmRyYXcuaW8vVnNkQ29udmVydGVyL2FwaS9jb252ZXJ0ZXIiO3dpbmRvdy5FTUZfQ09OVkVSVF9VUkw9d2luZG93LkVNRl9DT05WRVJUX1VSTHx8Imh0dHBzOi8vY29udmVydC5kcmF3LmlvL2VtZjJwbmcvY29udmVydEVNRiI7d2luZG93LlJFQUxUSU1FX1VSTD13aW5kb3cuUkVBTFRJTUVfVVJMfHwiY2FjaGUiOwp3aW5kb3cuRFJBV0lPX0dJVExBQl9VUkw9d2luZG93LkRSQVdJT19HSVRMQUJfVVJMfHwiaHR0cHM6Ly9naXRsYWIuY29tIjt3aW5kb3cuRFJBV0lPX0dJVExBQl9JRD13aW5kb3cuRFJBV0lPX0dJVExBQl9JRHx8IjVjZGMwMThhMzJhY2RkZjZlYmEzNzU5MmQ5Mzc0OTQ1MjQxZTY0NGI4MzY4YWY4NDc0MjJkNzRjODcwOWJjNDQiO3dpbmRvdy5TQVZFX1VSTD13aW5kb3cuU0FWRV9VUkx8fCJzYXZlIjt3aW5kb3cuT1BFTl9VUkw9d2luZG93Lk9QRU5fVVJMfHwiaW1wb3J0Ijt3aW5kb3cuUFJPWFlfVVJMPXdpbmRvdy5QUk9YWV9VUkx8fCJwcm94eSI7d2luZG93LkRSQVdJT19WSUVXRVJfVVJMPXdpbmRvdy5EUkFXSU9fVklFV0VSX1VSTHx8bnVsbDt3aW5kb3cuU0hBUEVTX1BBVEg9d2luZG93LlNIQVBFU19QQVRIfHwic2hhcGVzIjt3aW5kb3cuR1JBUEhfSU1BR0VfUEFUSD13aW5kb3cuR1JBUEhfSU1BR0VfUEFUSHx8ImltZyI7CndpbmRvdy5JQ09OU0VBUkNIX1BBVEg9d2luZG93LklDT05TRUFSQ0hfUEFUSHx8KChudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUiKXx8dXJsUGFyYW1zLmRldikmJiJmaWxlOiIhPXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbD8iaWNvblNlYXJjaCI6d2luZG93LkRSQVdJT19CQVNFX1VSTCsiL2ljb25TZWFyY2giKTt3aW5kb3cuVEVNUExBVEVfUEFUSD13aW5kb3cuVEVNUExBVEVfUEFUSHx8InRlbXBsYXRlcyI7d2luZG93Lk5FV19ESUFHUkFNX0NBVFNfUEFUSD13aW5kb3cuTkVXX0RJQUdSQU1fQ0FUU19QQVRIfHwibmV3RGlhZ3JhbUNhdHMiO3dpbmRvdy5QTFVHSU5TX0JBU0VfUEFUSD13aW5kb3cuUExVR0lOU19CQVNFX1BBVEh8fCIiO3dpbmRvdy5SRVNPVVJDRVNfUEFUSD13aW5kb3cuUkVTT1VSQ0VTX1BBVEh8fCJyZXNvdXJjZXMiOwp3aW5kb3cuUkVTT1VSQ0VfQkFTRT13aW5kb3cuUkVTT1VSQ0VfQkFTRXx8UkVTT1VSQ0VTX1BBVEgrIi9kaWEiO3dpbmRvdy5EUkFXSU9fQ09ORklHPXdpbmRvdy5EUkFXSU9fQ09ORklHfHxudWxsO3dpbmRvdy5teExvYWRSZXNvdXJjZXM9d2luZG93Lm14TG9hZFJlc291cmNlc3x8ITE7d2luZG93Lm14TGFuZ3VhZ2U9d2luZG93Lm14TGFuZ3VhZ2V8fGZ1bmN0aW9uKCl7dmFyIGE9dXJsUGFyYW1zLmxhbmc7aWYobnVsbD09YSYmInVuZGVmaW5lZCIhPXR5cGVvZiBKU09OJiZpc0xvY2FsU3RvcmFnZSl0cnl7dmFyIGI9bG9jYWxTdG9yYWdlLmdldEl0ZW0oIi5kcmF3aW8tY29uZmlnIik7bnVsbCE9YiYmKGE9SlNPTi5wYXJzZShiKS5sYW5ndWFnZXx8bnVsbCl9Y2F0Y2goYyl7aXNMb2NhbFN0b3JhZ2U9ITF9cmV0dXJuIGF9KCk7CndpbmRvdy5teExhbmd1YWdlTWFwPXdpbmRvdy5teExhbmd1YWdlTWFwfHx7aTE4bjoiIixpZDoiQmFoYXNhIEluZG9uZXNpYSIsbXM6IkJhaGFzYSBNZWxheXUiLGJzOiJCb3NhbnNraSIsYmc6IkJ1bGdhcmlhbiIsY2E6IkNhdGFsw6AiLGNzOiLEjGXFoXRpbmEiLGRhOiJEYW5zayIsZGU6IkRldXRzY2giLGV0OiJFZXN0aSIsZW46IkVuZ2xpc2giLGVzOiJFc3Bhw7FvbCIsZXU6IkV1c2thZGkiLGZpbDoiRmlsaXBpbm8iLGZyOiJGcmFuw6dhaXMiLGdsOiJHYWxlZ28iLGl0OiJJdGFsaWFubyIsaHU6Ik1hZ3lhciIsbmw6Ik5lZGVybGFuZHMiLG5vOiJOb3JzayIscGw6IlBvbHNraSIsInB0LWJyIjoiUG9ydHVndcOqcyAoQnJhc2lsKSIscHQ6IlBvcnR1Z3XDqnMgKFBvcnR1Z2FsKSIscm86IlJvbcOibsSDIixmaToiU3VvbWkiLHN2OiJTdmVuc2thIix2aToiVGnhur9uZyBWaeG7h3QiLHRyOiJUw7xya8OnZSIsZWw6Is6VzrvOu863zr3Ouc66zqwiLHJ1OiLQoNGD0YHRgdC60LjQuSIsc3I6ItCh0YDQv9GB0LrQuCIsdWs6ItCj0LrRgNCw0ZfQvdGB0YzQutCwIiwKaGU6Itei15HXqNeZ16oiLGFyOiLYp9mE2LnYsdio2YrYqSIsdGg6IuC5hOC4l+C4oiIsa286Iu2VnOq1reyWtCIsamE6IuaXpeacrOiqniIsemg6IueugOS9k+S4reaWhyIsInpoLXR3Ijoi57mB6auU5Lit5paHIn07InVuZGVmaW5lZCI9PT10eXBlb2Ygd2luZG93Lm14QmFzZVBhdGgmJih3aW5kb3cubXhCYXNlUGF0aD0ibXhncmFwaCIpO2lmKG51bGw9PXdpbmRvdy5teExhbmd1YWdlcyl7d2luZG93Lm14TGFuZ3VhZ2VzPVtdO2Zvcih2YXIgbGFuZyBpbiBteExhbmd1YWdlTWFwKSJlbiIhPWxhbmcmJndpbmRvdy5teExhbmd1YWdlcy5wdXNoKGxhbmcpfQp3aW5kb3cudWlUaGVtZT13aW5kb3cudWlUaGVtZXx8ZnVuY3Rpb24oKXt2YXIgYT11cmxQYXJhbXMudWk7aWYobnVsbD09YSYmInVuZGVmaW5lZCIhPT10eXBlb2YgSlNPTiYmaXNMb2NhbFN0b3JhZ2UpdHJ5e3ZhciBiPWxvY2FsU3RvcmFnZS5nZXRJdGVtKCIuZHJhd2lvLWNvbmZpZyIpO251bGwhPWImJihhPUpTT04ucGFyc2UoYikudWl8fG51bGwpfWNhdGNoKGMpe2lzTG9jYWxTdG9yYWdlPSExfXRyeXtudWxsPT1hJiY0MTQ+PSh3aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHxkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSYmKGE9Im1pbiIpfWNhdGNoKGMpe31yZXR1cm4gYX0oKTtmdW5jdGlvbiBzZXRDdXJyZW50WG1sKGEsYil7bnVsbCE9d2luZG93LnBhcmVudCYmbnVsbCE9d2luZG93LnBhcmVudC5vcGVuRmlsZSYmd2luZG93LnBhcmVudC5vcGVuRmlsZS5zZXREYXRhKGEsYil9CihmdW5jdGlvbigpe2lmKCJ1bmRlZmluZWQiIT09dHlwZW9mIEpTT04mJmlzTG9jYWxTdG9yYWdlKXRyeXt2YXIgYT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgiLmRyYXdpby1jb25maWciKSxiPSEwO251bGwhPWEmJihiPUpTT04ucGFyc2UoYSkuc2hvd1N0YXJ0U2NyZWVuKTswPT1iJiYodXJsUGFyYW1zLnNwbGFzaD0iMCIpfWNhdGNoKGQpe31hPXVybFBhcmFtc1siZXhwb3J0Il07bnVsbCE9YSYmKGE9ZGVjb2RlVVJJQ29tcG9uZW50KGEpLCJodHRwOi8vIiE9YS5zdWJzdHJpbmcoMCw3KSYmImh0dHBzOi8vIiE9YS5zdWJzdHJpbmcoMCw4KSYmKGE9Imh0dHA6Ly8iK2EpLEVYUE9SVF9VUkw9YSk7YT11cmxQYXJhbXMuZ2l0bGFiO251bGwhPWEmJihhPWRlY29kZVVSSUNvbXBvbmVudChhKSwiaHR0cDovLyIhPWEuc3Vic3RyaW5nKDAsNykmJiJodHRwczovLyIhPWEuc3Vic3RyaW5nKDAsOCkmJihhPSJodHRwOi8vIithKSxEUkFXSU9fR0lUTEFCX1VSTD1hKTthPXVybFBhcmFtc1siZ2l0bGFiLWlkIl07Cm51bGwhPWEmJihEUkFXSU9fR0lUTEFCX0lEPWEpO3dpbmRvdy5EUkFXSU9fTE9HX1VSTD13aW5kb3cuRFJBV0lPX0xPR19VUkx8fCIiO2E9d2luZG93LmxvY2F0aW9uLmhvc3Q7aWYoInRlc3QuZHJhdy5pbyIhPWEpe3ZhciBjPSJkaWFncmFtcy5uZXQiLGI9YS5sZW5ndGgtYy5sZW5ndGgsYz1hLmxhc3RJbmRleE9mKGMsYik7LTEhPT1jJiZjPT09Yj93aW5kb3cuRFJBV0lPX0xPR19VUkw9Imh0dHBzOi8vbG9nLmRpYWdyYW1zLm5ldCI6KGM9ImRyYXcuaW8iLGI9YS5sZW5ndGgtYy5sZW5ndGgsYz1hLmxhc3RJbmRleE9mKGMsYiksLTEhPT1jJiZjPT09YiYmKHdpbmRvdy5EUkFXSU9fTE9HX1VSTD0iaHR0cHM6Ly9sb2cuZHJhdy5pbyIpKX19KSgpOwppZigiMSI9PXVybFBhcmFtcy5vZmZsaW5lfHwiMSI9PXVybFBhcmFtcy5kZW1vfHwiMSI9PXVybFBhcmFtcy5zdGVhbHRofHwiMSI9PXVybFBhcmFtcy5sb2NhbCl1cmxQYXJhbXMucGlja2VyPSIwIix1cmxQYXJhbXMuZ2FwaT0iMCIsdXJsUGFyYW1zLmRiPSIwIix1cmxQYXJhbXMub2Q9IjAiLHVybFBhcmFtcy5naD0iMCIsdXJsUGFyYW1zLmdsPSIwIix1cmxQYXJhbXMudHI9IjAiO2lmKCIxIj09dXJsUGFyYW1zLm9mZmxpbmV8fCIxIj09dXJsUGFyYW1zLmxvY2FsKXVybFBhcmFtcy5tYXRoPSIwIjsiMSI9PXVybFBhcmFtcy5saWdodGJveCYmKHVybFBhcmFtcy5jaHJvbWU9IjAiKTsobnVsbD09d2luZG93LmxvY2F0aW9uLmhhc2h8fDE+PXdpbmRvdy5sb2NhdGlvbi5oYXNoLmxlbmd0aCkmJm51bGwhPXVybFBhcmFtcy5vcGVuJiYod2luZG93LmxvY2F0aW9uLmhhc2g9dXJsUGFyYW1zLm9wZW4pO3dpbmRvdy51cmxQYXJhbXM9d2luZG93LnVybFBhcmFtc3x8e307d2luZG93Lk1BWF9SRVFVRVNUX1NJWkU9d2luZG93Lk1BWF9SRVFVRVNUX1NJWkV8fDEwNDg1NzYwO3dpbmRvdy5NQVhfQVJFQT13aW5kb3cuTUFYX0FSRUF8fDIyNUU2O3dpbmRvdy5FWFBPUlRfVVJMPXdpbmRvdy5FWFBPUlRfVVJMfHwiL2V4cG9ydCI7d2luZG93LlNBVkVfVVJMPXdpbmRvdy5TQVZFX1VSTHx8Ii9zYXZlIjt3aW5kb3cuT1BFTl9VUkw9d2luZG93Lk9QRU5fVVJMfHwiL29wZW4iO3dpbmRvdy5SRVNPVVJDRVNfUEFUSD13aW5kb3cuUkVTT1VSQ0VTX1BBVEh8fCJyZXNvdXJjZXMiO3dpbmRvdy5SRVNPVVJDRV9CQVNFPXdpbmRvdy5SRVNPVVJDRV9CQVNFfHx3aW5kb3cuUkVTT1VSQ0VTX1BBVEgrIi9ncmFwaGVkaXRvciI7d2luZG93LlNURU5DSUxfUEFUSD13aW5kb3cuU1RFTkNJTF9QQVRIfHwic3RlbmNpbHMiO3dpbmRvdy5JTUFHRV9QQVRIPXdpbmRvdy5JTUFHRV9QQVRIfHwiaW1hZ2VzIjsKd2luZG93LlNUWUxFX1BBVEg9d2luZG93LlNUWUxFX1BBVEh8fCJzdHlsZXMiO3dpbmRvdy5DU1NfUEFUSD13aW5kb3cuQ1NTX1BBVEh8fCJzdHlsZXMiO3dpbmRvdy5PUEVOX0ZPUk09d2luZG93Lk9QRU5fRk9STXx8Im9wZW4uaHRtbCI7d2luZG93Lm14QmFzZVBhdGg9d2luZG93Lm14QmFzZVBhdGh8fCIuLi8uLi8uLi9zcmMiO3dpbmRvdy5teExhbmd1YWdlPXdpbmRvdy5teExhbmd1YWdlfHx1cmxQYXJhbXMubGFuZzt3aW5kb3cubXhMYW5ndWFnZXM9d2luZG93Lm14TGFuZ3VhZ2VzfHxbImRlIiwic2UiXTt2YXIgbXhDbGllbnQ9e1ZFUlNJT046IjQuMi4wIixJU19JRTpudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUiKSxJU19JRTY6bnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmMDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDYiKSxJU19JRTExOm51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJiEhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudFwvN1wuLyksSVNfRURHRTpudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYhIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcLy8pLElTX1FVSVJLUzpudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUiKSYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8NT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSxJU19FTToic3BlbGxjaGVjayJpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZXh0YXJlYSIpJiYKOD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLFZNTF9QUkVGSVg6InYiLE9GRklDRV9QUkVGSVg6Im8iLElTX05TOm51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJjA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTW96aWxsYS8iKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUiKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIkVkZ2UvIiksSVNfT1A6bnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmKDA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiT3BlcmEvIil8fDA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiT1BSLyIpKSxJU19PVDpudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8iKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8yLjQuIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJQcmVzdG8vMi4zLiIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiUHJlc3RvLzIuMi4iKSYmCjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJQcmVzdG8vMi4xLiIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiUHJlc3RvLzIuMC4iKSYmMD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8xLiIpLElTX1NGOi9BcHBsZSBDb21wdXRlciwgSW5jLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpLElTX0FORFJPSUQ6MDw9bmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZigiQW5kcm9pZCIpLElTX0lPUzovaVAoaG9uZXxvZHxhZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSxJU19HQzovR29vZ2xlIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSxJU19DSFJPTUVBUFA6bnVsbCE9d2luZG93LmNocm9tZSYmbnVsbCE9Y2hyb21lLmFwcCYmbnVsbCE9Y2hyb21lLmFwcC5ydW50aW1lLElTX0ZGOiJ1bmRlZmluZWQiIT09dHlwZW9mIEluc3RhbGxUcmlnZ2VyLElTX01UOjA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiRmlyZWZveC8iKSYmMD4KbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJGaXJlZm94LzEuIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJGaXJlZm94LzIuIil8fDA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiSWNld2Vhc2VsLyIpJiYwPm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiSWNld2Vhc2VsLzEuIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJJY2V3ZWFzZWwvMi4iKXx8MDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJTZWFNb25rZXkvIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJTZWFNb25rZXkvMS4iKXx8MDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJJY2VhcGUvIikmJjA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJJY2VhcGUvMS4iKSxJU19WTUw6Ik1JQ1JPU09GVCBJTlRFUk5FVCBFWFBMT1JFUiI9PW5hdmlnYXRvci5hcHBOYW1lLnRvVXBwZXJDYXNlKCksSVNfU1ZHOiJNSUNST1NPRlQgSU5URVJORVQgRVhQTE9SRVIiIT0KbmF2aWdhdG9yLmFwcE5hbWUudG9VcHBlckNhc2UoKSxOT19GTzohZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TfHwiW29iamVjdCBTVkdGb3JlaWduT2JqZWN0RWxlbWVudF0iIT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiwiZm9yZWlnbk9iamVjdCIpfHwwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk9wZXJhLyIpLElTX1dJTjowPG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoIldpbiIpLElTX01BQzowPG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoIk1hYyIpLElTX0NIUk9NRU9TOi9cYkNyT1NcYi8udGVzdChuYXZpZ2F0b3IuYXBwVmVyc2lvbiksSVNfVE9VQ0g6Im9udG91Y2hzdGFydCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsSVNfUE9JTlRFUjpudWxsIT13aW5kb3cuUG9pbnRlckV2ZW50JiYhKDA8bmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZigiTWFjIikpLElTX0xPQ0FMOjA+ZG9jdW1lbnQubG9jYXRpb24uaHJlZi5pbmRleE9mKCJodHRwOi8vIikmJgowPmRvY3VtZW50LmxvY2F0aW9uLmhyZWYuaW5kZXhPZigiaHR0cHM6Ly8iKSxkZWZhdWx0QnVuZGxlczpbXSxpc0Jyb3dzZXJTdXBwb3J0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbXhDbGllbnQuSVNfVk1MfHxteENsaWVudC5JU19TVkd9LGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7Yz1jfHxkb2N1bWVudDtpZihteENsaWVudC5JU19JRTYpYy53cml0ZSgnPGxpbmsgcmVsPSInK2ErJyIgaHJlZj0iJytiKyciIGNoYXJzZXQ9IlVURi04IiB0eXBlPSJ0ZXh0L2NzcyIvPicpO2Vsc2V7dmFyIGU9Yy5jcmVhdGVFbGVtZW50KCJsaW5rIik7ZS5zZXRBdHRyaWJ1dGUoInJlbCIsYSk7ZS5zZXRBdHRyaWJ1dGUoImhyZWYiLGIpO2Uuc2V0QXR0cmlidXRlKCJjaGFyc2V0IiwiVVRGLTgiKTtlLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQvY3NzIik7ZCYmZS5zZXRBdHRyaWJ1dGUoImlkIixkKTtjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQoZSl9fSxsb2FkUmVzb3VyY2VzOmZ1bmN0aW9uKGEsCmIpe2Z1bmN0aW9uIGMoKXswPT0tLWQmJmEoKX1mb3IodmFyIGQ9bXhDbGllbnQuZGVmYXVsdEJ1bmRsZXMubGVuZ3RoLGU9MDtlPG14Q2xpZW50LmRlZmF1bHRCdW5kbGVzLmxlbmd0aDtlKyspbXhSZXNvdXJjZXMuYWRkKG14Q2xpZW50LmRlZmF1bHRCdW5kbGVzW2VdLGIsYyl9LGluY2x1ZGU6ZnVuY3Rpb24oYSl7ZG9jdW1lbnQud3JpdGUoJzxzY3JpcHQgc3JjPSInK2ErJyI+XHgzYy9zY3JpcHQ+Jyl9fTsidW5kZWZpbmVkIj09dHlwZW9mIG14TG9hZFJlc291cmNlcyYmKG14TG9hZFJlc291cmNlcz0hMCk7InVuZGVmaW5lZCI9PXR5cGVvZiBteEZvcmNlSW5jbHVkZXMmJihteEZvcmNlSW5jbHVkZXM9ITEpOyJ1bmRlZmluZWQiPT10eXBlb2YgbXhSZXNvdXJjZUV4dGVuc2lvbiYmKG14UmVzb3VyY2VFeHRlbnNpb249Ii50eHQiKTsidW5kZWZpbmVkIj09dHlwZW9mIG14TG9hZFN0eWxlc2hlZXRzJiYobXhMb2FkU3R5bGVzaGVldHM9ITApOwoidW5kZWZpbmVkIiE9dHlwZW9mIG14QmFzZVBhdGgmJjA8bXhCYXNlUGF0aC5sZW5ndGg/KCIvIj09bXhCYXNlUGF0aC5zdWJzdHJpbmcobXhCYXNlUGF0aC5sZW5ndGgtMSkmJihteEJhc2VQYXRoPW14QmFzZVBhdGguc3Vic3RyaW5nKDAsbXhCYXNlUGF0aC5sZW5ndGgtMSkpLG14Q2xpZW50LmJhc2VQYXRoPW14QmFzZVBhdGgpOm14Q2xpZW50LmJhc2VQYXRoPSIuIjsidW5kZWZpbmVkIiE9dHlwZW9mIG14SW1hZ2VCYXNlUGF0aCYmMDxteEltYWdlQmFzZVBhdGgubGVuZ3RoPygiLyI9PW14SW1hZ2VCYXNlUGF0aC5zdWJzdHJpbmcobXhJbWFnZUJhc2VQYXRoLmxlbmd0aC0xKSYmKG14SW1hZ2VCYXNlUGF0aD1teEltYWdlQmFzZVBhdGguc3Vic3RyaW5nKDAsbXhJbWFnZUJhc2VQYXRoLmxlbmd0aC0xKSksbXhDbGllbnQuaW1hZ2VCYXNlUGF0aD1teEltYWdlQmFzZVBhdGgpOm14Q2xpZW50LmltYWdlQmFzZVBhdGg9bXhDbGllbnQuYmFzZVBhdGgrIi9pbWFnZXMiOwpteENsaWVudC5sYW5ndWFnZT0idW5kZWZpbmVkIiE9dHlwZW9mIG14TGFuZ3VhZ2UmJm51bGwhPW14TGFuZ3VhZ2U/bXhMYW5ndWFnZTpteENsaWVudC5JU19JRT9uYXZpZ2F0b3IudXNlckxhbmd1YWdlOm5hdmlnYXRvci5sYW5ndWFnZTtteENsaWVudC5kZWZhdWx0TGFuZ3VhZ2U9InVuZGVmaW5lZCIhPXR5cGVvZiBteERlZmF1bHRMYW5ndWFnZSYmbnVsbCE9bXhEZWZhdWx0TGFuZ3VhZ2U/bXhEZWZhdWx0TGFuZ3VhZ2U6ImVuIjtteExvYWRTdHlsZXNoZWV0cyYmbXhDbGllbnQubGluaygic3R5bGVzaGVldCIsbXhDbGllbnQuYmFzZVBhdGgrIi9jc3MvY29tbW9uLmNzcyIpOyJ1bmRlZmluZWQiIT10eXBlb2YgbXhMYW5ndWFnZXMmJm51bGwhPW14TGFuZ3VhZ2VzJiYobXhDbGllbnQubGFuZ3VhZ2VzPW14TGFuZ3VhZ2VzKTsKbXhDbGllbnQuSVNfVk1MJiYobXhDbGllbnQuSVNfU1ZHP214Q2xpZW50LklTX1ZNTD0hMToobnVsbCE9ZG9jdW1lbnQubmFtZXNwYWNlcyYmKDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZT8oZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQobXhDbGllbnQuVk1MX1BSRUZJWCwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwiLCIjZGVmYXVsdCNWTUwiKSxkb2N1bWVudC5uYW1lc3BhY2VzLmFkZChteENsaWVudC5PRkZJQ0VfUFJFRklYLCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2UiLCIjZGVmYXVsdCNWTUwiKSk6KGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKG14Q2xpZW50LlZNTF9QUkVGSVgsInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sIiksZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQobXhDbGllbnQuT0ZGSUNFX1BSRUZJWCwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlIikpKSxteENsaWVudC5JU19RVUlSS1MmJjMwPD1kb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg/CmZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTthLnR5cGU9InRleHQvY3NzIjthLnN0eWxlU2hlZXQuY3NzVGV4dD1teENsaWVudC5WTUxfUFJFRklYKyJcXDoqe2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpfSIrbXhDbGllbnQuT0ZGSUNFX1BSRUZJWCsiXFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX0iO2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQoYSl9KCk6ZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCgpLmNzc1RleHQ9bXhDbGllbnQuVk1MX1BSRUZJWCsiXFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX0iK214Q2xpZW50Lk9GRklDRV9QUkVGSVgrIlxcOip7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCl9IixteExvYWRTdHlsZXNoZWV0cyYmbXhDbGllbnQubGluaygic3R5bGVzaGVldCIsbXhDbGllbnQuYmFzZVBhdGgrIi9jc3MvZXhwbG9yZXIuY3NzIikpKTsKdmFyIG14TG9nPXtjb25zb2xlTmFtZToiQ29uc29sZSIsVFJBQ0U6ITEsREVCVUc6ITAsV0FSTjohMCxidWZmZXI6IiIsaW5pdDpmdW5jdGlvbigpe2lmKG51bGw9PW14TG9nLndpbmRvdyYmbnVsbCE9ZG9jdW1lbnQuYm9keSl7dmFyIGE9bXhMb2cuY29uc29sZU5hbWUrIiAtIG14R3JhcGggIitteENsaWVudC5WRVJTSU9OLGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTtiLnNldEF0dHJpYnV0ZSgid2lkdGgiLCIxMDAlIik7Yi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIjEwMCUiKTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0Ym9keSIpLGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKSxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7ZS5zdHlsZS52ZXJ0aWNhbEFsaWduPSJ0b3AiO214TG9nLnRleHRhcmVhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIik7bXhMb2cudGV4dGFyZWEuc2V0QXR0cmlidXRlKCJ3cmFwIiwib2ZmIik7Cm14TG9nLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgicmVhZE9ubHkiLCJ0cnVlIik7bXhMb2cudGV4dGFyZWEuc3R5bGUuaGVpZ2h0PSIxMDAlIjtteExvZy50ZXh0YXJlYS5zdHlsZS5yZXNpemU9Im5vbmUiO214TG9nLnRleHRhcmVhLnZhbHVlPW14TG9nLmJ1ZmZlcjtteExvZy50ZXh0YXJlYS5zdHlsZS53aWR0aD1teENsaWVudC5JU19OUyYmIkJhY2tDb21wYXQiIT1kb2N1bWVudC5jb21wYXRNb2RlPyI5OSUiOiIxMDAlIjtlLmFwcGVuZENoaWxkKG14TG9nLnRleHRhcmVhKTtkLmFwcGVuZENoaWxkKGUpO2MuYXBwZW5kQ2hpbGQoZCk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO214TG9nLnRkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7bXhMb2cudGQuc3R5bGUudmVydGljYWxBbGlnbj0idG9wIjtteExvZy50ZC5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIjMwcHgiKTtkLmFwcGVuZENoaWxkKG14TG9nLnRkKTtjLmFwcGVuZENoaWxkKGQpO2IuYXBwZW5kQ2hpbGQoYyk7Cm14TG9nLmFkZEJ1dHRvbigiSW5mbyIsZnVuY3Rpb24oYSl7bXhMb2cuaW5mbygpfSk7bXhMb2cuYWRkQnV0dG9uKCJET00iLGZ1bmN0aW9uKGEpe2E9bXhVdGlscy5nZXRJbm5lckh0bWwoZG9jdW1lbnQuYm9keSk7bXhMb2cuZGVidWcoYSl9KTtteExvZy5hZGRCdXR0b24oIlRyYWNlIixmdW5jdGlvbihhKXtteExvZy5UUkFDRT0hbXhMb2cuVFJBQ0U7bXhMb2cuVFJBQ0U/bXhMb2cuZGVidWcoIlRyYWNpbmcgZW5hYmxlZCIpOm14TG9nLmRlYnVnKCJUcmFjaW5nIGRpc2FibGVkIil9KTtteExvZy5hZGRCdXR0b24oIkNvcHkiLGZ1bmN0aW9uKGEpe3RyeXtteFV0aWxzLmNvcHkobXhMb2cudGV4dGFyZWEudmFsdWUpfWNhdGNoKGspe214VXRpbHMuYWxlcnQoayl9fSk7bXhMb2cuYWRkQnV0dG9uKCJTaG93IixmdW5jdGlvbihhKXt0cnl7bXhVdGlscy5wb3B1cChteExvZy50ZXh0YXJlYS52YWx1ZSl9Y2F0Y2goayl7bXhVdGlscy5hbGVydChrKX19KTtteExvZy5hZGRCdXR0b24oIkNsZWFyIiwKZnVuY3Rpb24oYSl7bXhMb2cudGV4dGFyZWEudmFsdWU9IiJ9KTtkPWM9MDsibnVtYmVyIj09PXR5cGVvZiB3aW5kb3cuaW5uZXJXaWR0aD8oYz13aW5kb3cuaW5uZXJIZWlnaHQsZD13aW5kb3cuaW5uZXJXaWR0aCk6KGM9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQsZD1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKTtteExvZy53aW5kb3c9bmV3IG14V2luZG93KGEsYixNYXRoLm1heCgwLGQtMzIwKSxNYXRoLm1heCgwLGMtMjEwKSwzMDAsMTYwKTtteExvZy53aW5kb3cuc2V0TWF4aW1pemFibGUoITApO214TG9nLndpbmRvdy5zZXRTY3JvbGxhYmxlKCExKTtteExvZy53aW5kb3cuc2V0UmVzaXphYmxlKCEwKTtteExvZy53aW5kb3cuc2V0Q2xvc2FibGUoITApO214TG9nLndpbmRvdy5kZXN0cm95T25DbG9zZT0hMTtpZigobXhDbGllbnQuSVNfTlN8fG14Q2xpZW50LklTX0lFKSYmIW14Q2xpZW50LklTX0dDJiYKIW14Q2xpZW50LklTX1NGJiYiQmFja0NvbXBhdCIhPWRvY3VtZW50LmNvbXBhdE1vZGV8fDExPT1kb2N1bWVudC5kb2N1bWVudE1vZGUpe3ZhciBmPW14TG9nLndpbmRvdy5nZXRFbGVtZW50KCksYT1mdW5jdGlvbihhLGIpe214TG9nLnRleHRhcmVhLnN0eWxlLmhlaWdodD1NYXRoLm1heCgwLGYub2Zmc2V0SGVpZ2h0LTcwKSsicHgifTtteExvZy53aW5kb3cuYWRkTGlzdGVuZXIobXhFdmVudC5SRVNJWkVfRU5ELGEpO214TG9nLndpbmRvdy5hZGRMaXN0ZW5lcihteEV2ZW50Lk1BWElNSVpFLGEpO214TG9nLndpbmRvdy5hZGRMaXN0ZW5lcihteEV2ZW50Lk5PUk1BTElaRSxhKTtteExvZy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9IjkycHgifX19LGluZm86ZnVuY3Rpb24oKXtteExvZy53cml0ZWxuKG14VXRpbHMudG9TdHJpbmcobmF2aWdhdG9yKSl9LGFkZEJ1dHRvbjpmdW5jdGlvbihhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJ1dHRvbiIpO214VXRpbHMud3JpdGUoYywKYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsYik7bXhMb2cudGQuYXBwZW5kQ2hpbGQoYyl9LGlzVmlzaWJsZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT1teExvZy53aW5kb3c/bXhMb2cud2luZG93LmlzVmlzaWJsZSgpOiExfSxzaG93OmZ1bmN0aW9uKCl7bXhMb2cuc2V0VmlzaWJsZSghMCl9LHNldFZpc2libGU6ZnVuY3Rpb24oYSl7bnVsbD09bXhMb2cud2luZG93JiZteExvZy5pbml0KCk7bnVsbCE9bXhMb2cud2luZG93JiZteExvZy53aW5kb3cuc2V0VmlzaWJsZShhKX0sZW50ZXI6ZnVuY3Rpb24oYSl7aWYobXhMb2cuVFJBQ0UpcmV0dXJuIG14TG9nLndyaXRlbG4oIkVudGVyaW5nICIrYSksKG5ldyBEYXRlKS5nZXRUaW1lKCl9LGxlYXZlOmZ1bmN0aW9uKGEsYil7aWYobXhMb2cuVFJBQ0Upe3ZhciBjPTAhPWI/IiAoIisoKG5ldyBEYXRlKS5nZXRUaW1lKCktYikrIiBtcykiOiIiO214TG9nLndyaXRlbG4oIkxlYXZpbmcgIithK2MpfX0sZGVidWc6ZnVuY3Rpb24oKXtteExvZy5ERUJVRyYmCm14TG9nLndyaXRlbG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfSx3YXJuOmZ1bmN0aW9uKCl7bXhMb2cuV0FSTiYmbXhMb2cud3JpdGVsbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHdyaXRlOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPSIiLGI9MDtiPGFyZ3VtZW50cy5sZW5ndGg7YisrKWErPWFyZ3VtZW50c1tiXSxiPGFyZ3VtZW50cy5sZW5ndGgtMSYmKGErPSIgIik7bnVsbCE9bXhMb2cudGV4dGFyZWE/KG14TG9nLnRleHRhcmVhLnZhbHVlKz1hLG51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJjA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiUHJlc3RvLzIuNSIpJiYobXhMb2cudGV4dGFyZWEuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIixteExvZy50ZXh0YXJlYS5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIiksbXhMb2cudGV4dGFyZWEuc2Nyb2xsVG9wPW14TG9nLnRleHRhcmVhLnNjcm9sbEhlaWdodCk6bXhMb2cuYnVmZmVyKz1hfSx3cml0ZWxuOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPQoiIixiPTA7Yjxhcmd1bWVudHMubGVuZ3RoO2IrKylhKz1hcmd1bWVudHNbYl0sYjxhcmd1bWVudHMubGVuZ3RoLTEmJihhKz0iICIpO214TG9nLndyaXRlKGErIlxuIil9fSxteE9iamVjdElkZW50aXR5PXtGSUVMRF9OQU1FOiJteE9iamVjdElkIixjb3VudGVyOjAsZ2V0OmZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe2lmKG51bGw9PWFbbXhPYmplY3RJZGVudGl0eS5GSUVMRF9OQU1FXSlpZigib2JqZWN0Ij09PXR5cGVvZiBhKXt2YXIgYj1teFV0aWxzLmdldEZ1bmN0aW9uTmFtZShhLmNvbnN0cnVjdG9yKTthW214T2JqZWN0SWRlbnRpdHkuRklFTERfTkFNRV09YisiIyIrbXhPYmplY3RJZGVudGl0eS5jb3VudGVyKyt9ZWxzZSJmdW5jdGlvbiI9PT10eXBlb2YgYSYmKGFbbXhPYmplY3RJZGVudGl0eS5GSUVMRF9OQU1FXT0iRnVuY3Rpb24jIitteE9iamVjdElkZW50aXR5LmNvdW50ZXIrKyk7cmV0dXJuIGFbbXhPYmplY3RJZGVudGl0eS5GSUVMRF9OQU1FXX1yZXR1cm4gbnVsbH0sCmNsZWFyOmZ1bmN0aW9uKGEpeyJvYmplY3QiIT09dHlwZW9mIGEmJiJmdW5jdGlvbiIhPT10eXBlb2YgYXx8ZGVsZXRlIGFbbXhPYmplY3RJZGVudGl0eS5GSUVMRF9OQU1FXX19O2Z1bmN0aW9uIG14RGljdGlvbmFyeSgpe3RoaXMuY2xlYXIoKX1teERpY3Rpb25hcnkucHJvdG90eXBlLm1hcD1udWxsO214RGljdGlvbmFyeS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLm1hcD17fX07bXhEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7YT1teE9iamVjdElkZW50aXR5LmdldChhKTtyZXR1cm4gdGhpcy5tYXBbYV19O214RGljdGlvbmFyeS5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKGEsYil7dmFyIGM9bXhPYmplY3RJZGVudGl0eS5nZXQoYSksZD10aGlzLm1hcFtjXTt0aGlzLm1hcFtjXT1iO3JldHVybiBkfTsKbXhEaWN0aW9uYXJ5LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7YT1teE9iamVjdElkZW50aXR5LmdldChhKTt2YXIgYj10aGlzLm1hcFthXTtkZWxldGUgdGhpcy5tYXBbYV07cmV0dXJuIGJ9O214RGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0S2V5cz1mdW5jdGlvbigpe3ZhciBhPVtdLGI7Zm9yKGIgaW4gdGhpcy5tYXApYS5wdXNoKGIpO3JldHVybiBhfTtteERpY3Rpb25hcnkucHJvdG90eXBlLmdldFZhbHVlcz1mdW5jdGlvbigpe3ZhciBhPVtdLGI7Zm9yKGIgaW4gdGhpcy5tYXApYS5wdXNoKHRoaXMubWFwW2JdKTtyZXR1cm4gYX07bXhEaWN0aW9uYXJ5LnByb3RvdHlwZS52aXNpdD1mdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gdGhpcy5tYXApYShiLHRoaXMubWFwW2JdKX07CnZhciBteFJlc291cmNlcz17cmVzb3VyY2VzOnt9LGV4dGVuc2lvbjpteFJlc291cmNlRXh0ZW5zaW9uLHJlc291cmNlc0VuY29kZWQ6ITEsbG9hZERlZmF1bHRCdW5kbGU6ITAsbG9hZFNwZWNpYWxCdW5kbGU6ITAsaXNMYW5ndWFnZVN1cHBvcnRlZDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9bXhDbGllbnQubGFuZ3VhZ2VzPzA8PW14VXRpbHMuaW5kZXhPZihteENsaWVudC5sYW5ndWFnZXMsYSk6ITB9LGdldERlZmF1bHRCdW5kbGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbXhSZXNvdXJjZXMubG9hZERlZmF1bHRCdW5kbGV8fCFteFJlc291cmNlcy5pc0xhbmd1YWdlU3VwcG9ydGVkKGIpP2ErbXhSZXNvdXJjZXMuZXh0ZW5zaW9uOm51bGx9LGdldFNwZWNpYWxCdW5kbGU6ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1teENsaWVudC5sYW5ndWFnZXN8fCF0aGlzLmlzTGFuZ3VhZ2VTdXBwb3J0ZWQoYikpe3ZhciBjPWIuaW5kZXhPZigiLSIpOzA8YyYmKGI9Yi5zdWJzdHJpbmcoMCxjKSl9cmV0dXJuIG14UmVzb3VyY2VzLmxvYWRTcGVjaWFsQnVuZGxlJiYKbXhSZXNvdXJjZXMuaXNMYW5ndWFnZVN1cHBvcnRlZChiKSYmYiE9bXhDbGllbnQuZGVmYXVsdExhbmd1YWdlP2ErIl8iK2IrbXhSZXNvdXJjZXMuZXh0ZW5zaW9uOm51bGx9LGFkZDpmdW5jdGlvbihhLGIsYyl7Yj1udWxsIT1iP2I6bnVsbCE9bXhDbGllbnQubGFuZ3VhZ2U/bXhDbGllbnQubGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTpteENvbnN0YW50cy5OT05FO2lmKGIhPW14Q29uc3RhbnRzLk5PTkUpe3ZhciBkPW14UmVzb3VyY2VzLmdldERlZmF1bHRCdW5kbGUoYSxiKSxlPW14UmVzb3VyY2VzLmdldFNwZWNpYWxCdW5kbGUoYSxiKSxmPWZ1bmN0aW9uKCl7aWYobnVsbCE9ZSlpZihjKW14VXRpbHMuZ2V0KGUsZnVuY3Rpb24oYSl7bXhSZXNvdXJjZXMucGFyc2UoYS5nZXRUZXh0KCkpO2MoKX0sZnVuY3Rpb24oKXtjKCl9KTtlbHNlIHRyeXt2YXIgYT1teFV0aWxzLmxvYWQoZSk7YS5pc1JlYWR5KCkmJm14UmVzb3VyY2VzLnBhcnNlKGEuZ2V0VGV4dCgpKX1jYXRjaChsKXt9ZWxzZSBudWxsIT0KYyYmYygpfTtpZihudWxsIT1kKWlmKGMpbXhVdGlscy5nZXQoZCxmdW5jdGlvbihhKXtteFJlc291cmNlcy5wYXJzZShhLmdldFRleHQoKSk7ZigpfSxmdW5jdGlvbigpe2YoKX0pO2Vsc2UgdHJ5e3ZhciBnPW14VXRpbHMubG9hZChkKTtnLmlzUmVhZHkoKSYmbXhSZXNvdXJjZXMucGFyc2UoZy5nZXRUZXh0KCkpO2YoKX1jYXRjaChrKXt9ZWxzZSBmKCl9fSxwYXJzZTpmdW5jdGlvbihhKXtpZihudWxsIT1hKXthPWEuc3BsaXQoIlxuIik7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspaWYoIiMiIT1hW2JdLmNoYXJBdCgwKSl7dmFyIGM9YVtiXS5pbmRleE9mKCI9Iik7aWYoMDxjKXt2YXIgZD1hW2JdLnN1YnN0cmluZygwLGMpLGU9YVtiXS5sZW5ndGg7MTM9PWFbYl0uY2hhckNvZGVBdChlLTEpJiZlLS07Yz1hW2JdLnN1YnN0cmluZyhjKzEsZSk7dGhpcy5yZXNvdXJjZXNFbmNvZGVkPyhjPWMucmVwbGFjZSgvXFwoPz11W2EtZkEtRlxkXXs0fSkvZywiJSIpLG14UmVzb3VyY2VzLnJlc291cmNlc1tkXT0KdW5lc2NhcGUoYykpOm14UmVzb3VyY2VzLnJlc291cmNlc1tkXT1jfX19fSxnZXQ6ZnVuY3Rpb24oYSxiLGMpe2E9bXhSZXNvdXJjZXMucmVzb3VyY2VzW2FdO251bGw9PWEmJihhPWMpO251bGwhPWEmJm51bGwhPWImJihhPW14UmVzb3VyY2VzLnJlcGxhY2VQbGFjZWhvbGRlcnMoYSxiKSk7cmV0dXJuIGF9LHJlcGxhY2VQbGFjZWhvbGRlcnM6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD1udWxsLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGY9YS5jaGFyQXQoZSk7InsiPT1mP2Q9IiI6bnVsbCE9ZCYmIn0iPT1mPyhkPXBhcnNlSW50KGQpLTEsMDw9ZCYmZDxiLmxlbmd0aCYmYy5wdXNoKGJbZF0pLGQ9bnVsbCk6bnVsbCE9ZD9kKz1mOmMucHVzaChmKX1yZXR1cm4gYy5qb2luKCIiKX0sbG9hZFJlc291cmNlczpmdW5jdGlvbihhKXtteFJlc291cmNlcy5hZGQobXhDbGllbnQuYmFzZVBhdGgrIi9yZXNvdXJjZXMvZWRpdG9yIixudWxsLGZ1bmN0aW9uKCl7bXhSZXNvdXJjZXMuYWRkKG14Q2xpZW50LmJhc2VQYXRoKwoiL3Jlc291cmNlcy9ncmFwaCIsbnVsbCxhKX0pfX07ZnVuY3Rpb24gbXhQb2ludChhLGIpe3RoaXMueD1udWxsIT1hP2E6MDt0aGlzLnk9bnVsbCE9Yj9iOjB9bXhQb2ludC5wcm90b3R5cGUueD1udWxsO214UG9pbnQucHJvdG90eXBlLnk9bnVsbDtteFBvaW50LnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJmEueD09dGhpcy54JiZhLnk9PXRoaXMueX07bXhQb2ludC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbXhVdGlscy5jbG9uZSh0aGlzKX07ZnVuY3Rpb24gbXhSZWN0YW5nbGUoYSxiLGMsZCl7bXhQb2ludC5jYWxsKHRoaXMsYSxiKTt0aGlzLndpZHRoPW51bGwhPWM/YzowO3RoaXMuaGVpZ2h0PW51bGwhPWQ/ZDowfW14UmVjdGFuZ2xlLnByb3RvdHlwZT1uZXcgbXhQb2ludDtteFJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhSZWN0YW5nbGU7bXhSZWN0YW5nbGUucHJvdG90eXBlLndpZHRoPW51bGw7Cm14UmVjdGFuZ2xlLnByb3RvdHlwZS5oZWlnaHQ9bnVsbDtteFJlY3RhbmdsZS5wcm90b3R5cGUuc2V0UmVjdD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLng9YTt0aGlzLnk9Yjt0aGlzLndpZHRoPWM7dGhpcy5oZWlnaHQ9ZH07bXhSZWN0YW5nbGUucHJvdG90eXBlLmdldENlbnRlclg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54K3RoaXMud2lkdGgvMn07bXhSZWN0YW5nbGUucHJvdG90eXBlLmdldENlbnRlclk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy55K3RoaXMuaGVpZ2h0LzJ9OwpteFJlY3RhbmdsZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPU1hdGgubWluKHRoaXMueCxhLngpLGM9TWF0aC5taW4odGhpcy55LGEueSksZD1NYXRoLm1heCh0aGlzLngrdGhpcy53aWR0aCxhLngrYS53aWR0aCk7YT1NYXRoLm1heCh0aGlzLnkrdGhpcy5oZWlnaHQsYS55K2EuaGVpZ2h0KTt0aGlzLng9Yjt0aGlzLnk9Yzt0aGlzLndpZHRoPWQtYjt0aGlzLmhlaWdodD1hLWN9fTtteFJlY3RhbmdsZS5wcm90b3R5cGUuaW50ZXJzZWN0PWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPXRoaXMueCt0aGlzLndpZHRoLGM9YS54K2Eud2lkdGgsZD10aGlzLnkrdGhpcy5oZWlnaHQsZT1hLnkrYS5oZWlnaHQ7dGhpcy54PU1hdGgubWF4KHRoaXMueCxhLngpO3RoaXMueT1NYXRoLm1heCh0aGlzLnksYS55KTt0aGlzLndpZHRoPU1hdGgubWluKGIsYyktdGhpcy54O3RoaXMuaGVpZ2h0PU1hdGgubWluKGQsZSktdGhpcy55fX07Cm14UmVjdGFuZ2xlLnByb3RvdHlwZS5ncm93PWZ1bmN0aW9uKGEpe3RoaXMueC09YTt0aGlzLnktPWE7dGhpcy53aWR0aCs9MiphO3RoaXMuaGVpZ2h0Kz0yKmE7cmV0dXJuIHRoaXN9O214UmVjdGFuZ2xlLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQb2ludCh0aGlzLngsdGhpcy55KX07bXhSZWN0YW5nbGUucHJvdG90eXBlLnJvdGF0ZTkwPWZ1bmN0aW9uKCl7dmFyIGE9KHRoaXMud2lkdGgtdGhpcy5oZWlnaHQpLzI7dGhpcy54Kz1hO3RoaXMueS09YTthPXRoaXMud2lkdGg7dGhpcy53aWR0aD10aGlzLmhlaWdodDt0aGlzLmhlaWdodD1hfTtteFJlY3RhbmdsZS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZhLng9PXRoaXMueCYmYS55PT10aGlzLnkmJmEud2lkdGg9PXRoaXMud2lkdGgmJmEuaGVpZ2h0PT10aGlzLmhlaWdodH07Cm14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpfTsKdmFyIG14RWZmZWN0cz17YW5pbWF0ZUNoYW5nZXM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPTAsZT1mdW5jdGlvbigpe2Zvcih2YXIgZz0hMSxrPTA7azxiLmxlbmd0aDtrKyspe3ZhciBsPWJba107aWYobCBpbnN0YW5jZW9mIG14R2VvbWV0cnlDaGFuZ2V8fGwgaW5zdGFuY2VvZiBteFRlcm1pbmFsQ2hhbmdlfHxsIGluc3RhbmNlb2YgbXhWYWx1ZUNoYW5nZXx8bCBpbnN0YW5jZW9mIG14Q2hpbGRDaGFuZ2V8fGwgaW5zdGFuY2VvZiBteFN0eWxlQ2hhbmdlKXt2YXIgbT1hLmdldFZpZXcoKS5nZXRTdGF0ZShsLmNlbGx8fGwuY2hpbGQsITEpO2lmKG51bGwhPW0paWYoZz0hMCxsLmNvbnN0cnVjdG9yIT1teEdlb21ldHJ5Q2hhbmdlfHxhLm1vZGVsLmlzRWRnZShsLmNlbGwpKW14VXRpbHMuc2V0T3BhY2l0eShtLnNoYXBlLm5vZGUsMTAwKmQvMTApO2Vsc2V7dmFyIG49YS5nZXRWaWV3KCkuc2NhbGUscD0obC5nZW9tZXRyeS54LWwucHJldmlvdXMueCkqbixxPShsLmdlb21ldHJ5LnktCmwucHJldmlvdXMueSkqbixyPShsLmdlb21ldHJ5LndpZHRoLWwucHJldmlvdXMud2lkdGgpKm4sbj0obC5nZW9tZXRyeS5oZWlnaHQtbC5wcmV2aW91cy5oZWlnaHQpKm47MD09ZD8obS54LT1wLG0ueS09cSxtLndpZHRoLT1yLG0uaGVpZ2h0LT1uKToobS54Kz1wLzEwLG0ueSs9cS8xMCxtLndpZHRoKz1yLzEwLG0uaGVpZ2h0Kz1uLzEwKTthLmNlbGxSZW5kZXJlci5yZWRyYXcobSk7bXhFZmZlY3RzLmNhc2NhZGVPcGFjaXR5KGEsbC5jZWxsLDEwMCpkLzEwKX19fTEwPmQmJmc/KGQrKyx3aW5kb3cuc2V0VGltZW91dChlLGYpKTpudWxsIT1jJiZjKCl9LGY9MzA7ZSgpfSxjYXNjYWRlT3BhY2l0eTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubW9kZWwuZ2V0Q2hpbGRDb3VudChiKSxlPTA7ZTxkO2UrKyl7dmFyIGY9YS5tb2RlbC5nZXRDaGlsZEF0KGIsZSksZz1hLmdldFZpZXcoKS5nZXRTdGF0ZShmKTtudWxsIT1nJiYobXhVdGlscy5zZXRPcGFjaXR5KGcuc2hhcGUubm9kZSwKYyksbXhFZmZlY3RzLmNhc2NhZGVPcGFjaXR5KGEsZixjKSl9Yj1hLm1vZGVsLmdldEVkZ2VzKGIpO2lmKG51bGwhPWIpZm9yKGU9MDtlPGIubGVuZ3RoO2UrKylkPWEuZ2V0VmlldygpLmdldFN0YXRlKGJbZV0pLG51bGwhPWQmJm14VXRpbHMuc2V0T3BhY2l0eShkLnNoYXBlLm5vZGUsYyl9LGZhZGVPdXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2Q9ZHx8NDA7ZT1lfHwzMDt2YXIgZz1ifHwxMDA7bXhVdGlscy5zZXRPcGFjaXR5KGEsZyk7aWYoZnx8bnVsbD09Zil7dmFyIGs9ZnVuY3Rpb24oKXtnPU1hdGgubWF4KGctZCwwKTtteFV0aWxzLnNldE9wYWNpdHkoYSxnKTswPGc/d2luZG93LnNldFRpbWVvdXQoayxlKTooYS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLGMmJmEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKX07d2luZG93LnNldFRpbWVvdXQoayxlKX1lbHNlIGEuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIixjJiZhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX19LApteFV0aWxzPXtlcnJvclJlc291cmNlOiJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImVycm9yIjoiIixjbG9zZVJlc291cmNlOiJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImNsb3NlIjoiIixlcnJvckltYWdlOm14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9lcnJvci5naWYiLHJlbW92ZUN1cnNvcnM6ZnVuY3Rpb24oYSl7bnVsbCE9YS5zdHlsZSYmKGEuc3R5bGUuY3Vyc29yPSIiKTthPWEuY2hpbGROb2RlcztpZihudWxsIT1hKWZvcih2YXIgYj1hLmxlbmd0aCxjPTA7YzxiO2MrPTEpbXhVdGlscy5yZW1vdmVDdXJzb3JzKGFbY10pfSxnZXRDdXJyZW50U3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm4gbXhDbGllbnQuSVNfSUUmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDk+ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKT9mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmN1cnJlbnRTdHlsZTpudWxsfTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLAoiIik6bnVsbH19KCkscGFyc2VDc3NOdW1iZXI6ZnVuY3Rpb24oYSl7InRoaW4iPT1hP2E9IjIiOiJtZWRpdW0iPT1hP2E9IjQiOiJ0aGljayI9PWEmJihhPSI2Iik7YT1wYXJzZUZsb2F0KGEpO2lzTmFOKGEpJiYoYT0wKTtyZXR1cm4gYX0sc2V0UHJlZml4ZWRTdHlsZTpmdW5jdGlvbigpe3ZhciBhPW51bGw7bXhDbGllbnQuSVNfT1Q/YT0iTyI6bXhDbGllbnQuSVNfU0Z8fG14Q2xpZW50LklTX0dDP2E9IldlYmtpdCI6bXhDbGllbnQuSVNfTVQ/YT0iTW96IjpteENsaWVudC5JU19JRSYmOTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYxMD5kb2N1bWVudC5kb2N1bWVudE1vZGUmJihhPSJtcyIpO3JldHVybiBmdW5jdGlvbihiLGMsZCl7YltjXT1kO251bGwhPWEmJjA8Yy5sZW5ndGgmJihjPWErYy5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpK2Muc3Vic3RyaW5nKDEpLGJbY109ZCl9fSgpLGhhc1Njcm9sbGJhcnM6ZnVuY3Rpb24oYSl7YT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShhKTsKcmV0dXJuIG51bGwhPWEmJigic2Nyb2xsIj09YS5vdmVyZmxvd3x8ImF1dG8iPT1hLm92ZXJmbG93KX0sYmluZDpmdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBiLmFwcGx5KGEsYXJndW1lbnRzKX19LGV2YWw6ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZigwPD1hLmluZGV4T2YoImZ1bmN0aW9uIikpdHJ5e2V2YWwoInZhciBfbXhKYXZhU2NyaXB0RXhwcmVzc2lvbj0iK2EpLGI9X214SmF2YVNjcmlwdEV4cHJlc3Npb24sX214SmF2YVNjcmlwdEV4cHJlc3Npb249bnVsbH1jYXRjaChjKXtteExvZy53YXJuKGMubWVzc2FnZSsiIHdoaWxlIGV2YWx1YXRpbmcgIithKX1lbHNlIHRyeXtiPWV2YWwoYSl9Y2F0Y2goYyl7bXhMb2cud2FybihjLm1lc3NhZ2UrIiB3aGlsZSBldmFsdWF0aW5nICIrYSl9cmV0dXJuIGJ9LGZpbmROb2RlOmZ1bmN0aW9uKGEsYixjKXtpZihhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXt2YXIgZD1hLmdldEF0dHJpYnV0ZShiKTsKaWYobnVsbCE9ZCYmZD09YylyZXR1cm4gYX1mb3IoYT1hLmZpcnN0Q2hpbGQ7bnVsbCE9YTspe2Q9bXhVdGlscy5maW5kTm9kZShhLGIsYyk7aWYobnVsbCE9ZClyZXR1cm4gZDthPWEubmV4dFNpYmxpbmd9cmV0dXJuIG51bGx9LGdldEZ1bmN0aW9uTmFtZTpmdW5jdGlvbihhKXt2YXIgYj1udWxsO251bGwhPWEmJihudWxsIT1hLm5hbWU/Yj1hLm5hbWU6KGI9bXhVdGlscy50cmltKGEudG9TdHJpbmcoKSksL15mdW5jdGlvblxzLy50ZXN0KGIpJiYoYj1teFV0aWxzLmx0cmltKGIuc3Vic3RyaW5nKDkpKSxhPWIuaW5kZXhPZigiKCIpLDA8YSYmKGI9Yi5zdWJzdHJpbmcoMCxhKSkpKSk7cmV0dXJuIGJ9LGluZGV4T2Y6ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiZudWxsIT1iKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKGFbY109PWIpcmV0dXJuIGM7cmV0dXJuLTF9LGZvckVhY2g6ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiZudWxsIT1iKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWIoYVtjXSk7CnJldHVybiBhfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsO2lmKCJvYmplY3QiPT10eXBlb2YgYilmb3IodmFyIGQ9bXhVdGlscy5pbmRleE9mKGIsYSk7MDw9ZDspYi5zcGxpY2UoZCwxKSxjPWEsZD1teFV0aWxzLmluZGV4T2YoYixhKTtmb3IodmFyIGUgaW4gYiliW2VdPT1hJiYoZGVsZXRlIGJbZV0sYz1hKTtyZXR1cm4gY30saXNOb2RlOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBudWxsPT1hfHxpc05hTihhLm5vZGVUeXBlKXx8bnVsbCE9YiYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIT1iLnRvTG93ZXJDYXNlKCk/ITE6bnVsbD09Y3x8YS5nZXRBdHRyaWJ1dGUoYyk9PWR9LGlzQW5jZXN0b3JOb2RlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWI7bnVsbCE9Yzspe2lmKGM9PWEpcmV0dXJuITA7Yz1jLnBhcmVudE5vZGV9cmV0dXJuITF9LGdldENoaWxkTm9kZXM6ZnVuY3Rpb24oYSxiKXtiPWJ8fG14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQ7Zm9yKHZhciBjPQpbXSxkPWEuZmlyc3RDaGlsZDtudWxsIT1kOylkLm5vZGVUeXBlPT1iJiZjLnB1c2goZCksZD1kLm5leHRTaWJsaW5nO3JldHVybiBjfSxpbXBvcnROb2RlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbXhDbGllbnQuSVNfSUUmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDEwPmRvY3VtZW50LmRvY3VtZW50TW9kZSk/bXhVdGlscy5pbXBvcnROb2RlSW1wbGVtZW50YXRpb24oYSxiLGMpOmEuaW1wb3J0Tm9kZShiLGMpfSxpbXBvcnROb2RlSW1wbGVtZW50YXRpb246ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiLm5vZGVUeXBlKXtjYXNlIDE6dmFyIGQ9YS5jcmVhdGVFbGVtZW50KGIubm9kZU5hbWUpO2lmKGIuYXR0cmlidXRlcyYmMDxiLmF0dHJpYnV0ZXMubGVuZ3RoKWZvcih2YXIgZT0wO2U8Yi5hdHRyaWJ1dGVzLmxlbmd0aDtlKyspZC5zZXRBdHRyaWJ1dGUoYi5hdHRyaWJ1dGVzW2VdLm5vZGVOYW1lLGIuZ2V0QXR0cmlidXRlKGIuYXR0cmlidXRlc1tlXS5ub2RlTmFtZSkpOwppZihjJiZiLmNoaWxkTm9kZXMmJjA8Yi5jaGlsZE5vZGVzLmxlbmd0aClmb3IoZT0wO2U8Yi5jaGlsZE5vZGVzLmxlbmd0aDtlKyspZC5hcHBlbmRDaGlsZChteFV0aWxzLmltcG9ydE5vZGVJbXBsZW1lbnRhdGlvbihhLGIuY2hpbGROb2Rlc1tlXSxjKSk7cmV0dXJuIGQ7Y2FzZSAzOmNhc2UgNDpjYXNlIDg6cmV0dXJuIGEuY3JlYXRlVGV4dE5vZGUobnVsbCE9Yi5ub2RlVmFsdWU/Yi5ub2RlVmFsdWU6Yi52YWx1ZSl9fSxjcmVhdGVYbWxEb2N1bWVudDpmdW5jdGlvbigpe3ZhciBhPW51bGw7ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50P2E9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoIiIsIiIsbnVsbCk6IkFjdGl2ZVhPYmplY3QiaW4gd2luZG93JiYoYT1teFV0aWxzLmNyZWF0ZU1zWG1sRG9jdW1lbnQoKSk7cmV0dXJuIGF9LGNyZWF0ZU1zWG1sRG9jdW1lbnQ6ZnVuY3Rpb24oKXt2YXIgYT0KbmV3IEFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxET00iKTthLmFzeW5jPSExO2EudmFsaWRhdGVPblBhcnNlPSExO2EucmVzb2x2ZUV4dGVybmFscz0hMTtyZXR1cm4gYX0scGFyc2VYbWw6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LkRPTVBhcnNlcj9mdW5jdGlvbihhKXtyZXR1cm4obmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGEsInRleHQveG1sIil9OmZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuY3JlYXRlTXNYbWxEb2N1bWVudCgpO2IubG9hZFhNTChhKTtyZXR1cm4gYn19KCksY2xlYXJTZWxlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuc2VsZWN0aW9uP2Z1bmN0aW9uKCl7ZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCl9OndpbmRvdy5nZXRTZWxlY3Rpb24/ZnVuY3Rpb24oKXt3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZW1wdHk/d2luZG93LmdldFNlbGVjdGlvbigpLmVtcHR5KCk6d2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcyYmCndpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKX06ZnVuY3Rpb24oKXt9fSgpLHJlbW92ZVdoaXRlc3BhY2U6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yj9hLnByZXZpb3VzU2libGluZzphLm5leHRTaWJsaW5nO251bGwhPWMmJmMubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX1RFWFQ7KXt2YXIgZD1iP2MucHJldmlvdXNTaWJsaW5nOmMubmV4dFNpYmxpbmcsZT1teFV0aWxzLmdldFRleHRDb250ZW50KGMpOzA9PW14VXRpbHMudHJpbShlKS5sZW5ndGgmJmMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTtjPWR9fSxodG1sRW50aXRpZXM6ZnVuY3Rpb24oYSxiKXthPVN0cmluZyhhfHwiIik7YT1hLnJlcGxhY2UoLyYvZywiJmFtcDsiKTthPWEucmVwbGFjZSgvIi9nLCImcXVvdDsiKTthPWEucmVwbGFjZSgvXCcvZywiJiMzOTsiKTthPWEucmVwbGFjZSgvPC9nLCImbHQ7Iik7YT1hLnJlcGxhY2UoLz4vZywiJmd0OyIpO2lmKG51bGw9PWJ8fGIpYT1hLnJlcGxhY2UoL1xuL2csCiImI3hhOyIpO3JldHVybiBhfSxpc1ZtbDpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sIj09YS50YWdVcm59LGdldFhtbDpmdW5jdGlvbihhLGIpe3ZhciBjPSIiO214Q2xpZW50LklTX0lFfHxteENsaWVudC5JU19JRTExP2M9bXhVdGlscy5nZXRQcmV0dHlYbWwoYSwiIiwiIiwiIik6bnVsbCE9d2luZG93LlhNTFNlcmlhbGl6ZXI/Yz0obmV3IFhNTFNlcmlhbGl6ZXIpLnNlcmlhbGl6ZVRvU3RyaW5nKGEpOm51bGwhPWEueG1sJiYoYz1hLnhtbC5yZXBsYWNlKC9cclxuXHRbXHRdKi9nLCIiKS5yZXBsYWNlKC8+XHJcbi9nLCI+IikucmVwbGFjZSgvXHJcbi9nLCJcbiIpKTtyZXR1cm4gYy5yZXBsYWNlKC9cbi9nLGJ8fCImI3hhOyIpfSxnZXRQcmV0dHlYbWw6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1bXTtpZihudWxsIT1hKWlmKGI9bnVsbCE9Yj9iOiIgICIsYz1udWxsIT1jP2M6IiIsZD1udWxsIT1kP2Q6IlxuIixudWxsIT0KYS5uYW1lc3BhY2VVUkkmJmEubmFtZXNwYWNlVVJJIT1lJiYoZT1hLm5hbWVzcGFjZVVSSSxudWxsPT1hLmdldEF0dHJpYnV0ZSgieG1sbnMiKSYmYS5zZXRBdHRyaWJ1dGUoInhtbG5zIixhLm5hbWVzcGFjZVVSSSkpLGEubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0RPQ1VNRU5UKWYucHVzaChteFV0aWxzLmdldFByZXR0eVhtbChhLmRvY3VtZW50RWxlbWVudCxiLGMsZCxlKSk7ZWxzZSBpZihhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9ET0NVTUVOVF9GUkFHTUVOVCl7dmFyIGc9YS5maXJzdENoaWxkO2lmKG51bGwhPWcpZm9yKDtudWxsIT1nOylmLnB1c2gobXhVdGlscy5nZXRQcmV0dHlYbWwoZyxiLGMsZCxlKSksZz1nLm5leHRTaWJsaW5nfWVsc2UgaWYoYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfQ09NTUVOVClhPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYSksMDxhLmxlbmd0aCYmZi5wdXNoKGMrIlx4M2MhLS0iK2ErIi0tXHgzZSIrCmQpO2Vsc2UgaWYoYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfVEVYVClhPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYSksMDxhLmxlbmd0aCYmZi5wdXNoKGMrbXhVdGlscy5odG1sRW50aXRpZXMobXhVdGlscy50cmltKGEpLCExKStkKTtlbHNlIGlmKGEubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0NEQVRBKWE9bXhVdGlscy5nZXRUZXh0Q29udGVudChhKSwwPGEubGVuZ3RoJiZmLnB1c2goYysiPCFbQ0RBVEFbIithKyJdXSIrZCk7ZWxzZXtmLnB1c2goYysiPCIrYS5ub2RlTmFtZSk7Zz1hLmF0dHJpYnV0ZXM7aWYobnVsbCE9Zylmb3IodmFyIGs9MDtrPGcubGVuZ3RoO2srKyl7dmFyIGw9bXhVdGlscy5odG1sRW50aXRpZXMoZ1trXS52YWx1ZSk7Zi5wdXNoKCIgIitnW2tdLm5vZGVOYW1lKyc9IicrbCsnIicpfWc9YS5maXJzdENoaWxkO2lmKG51bGwhPWcpe2ZvcihmLnB1c2goIj4iK2QpO251bGwhPWc7KWYucHVzaChteFV0aWxzLmdldFByZXR0eVhtbChnLApiLGMrYixkLGUpKSxnPWcubmV4dFNpYmxpbmc7Zi5wdXNoKGMrIjwvIithLm5vZGVOYW1lKyI+IitkKX1lbHNlIGYucHVzaCgiIC8+IitkKX1yZXR1cm4gZi5qb2luKCIiKX0sZXh0cmFjdFRleHRXaXRoV2hpdGVzcGFjZTpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2lmKDEhPWEubGVuZ3RofHwiQlIiIT1hWzBdLm5vZGVOYW1lJiYiXG4iIT1hWzBdLmlubmVySFRNTClmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGc9YVtlXTsiQlIiPT1nLm5vZGVOYW1lfHwiXG4iPT1nLmlubmVySFRNTHx8KDE9PWEubGVuZ3RofHwwPT1lKSYmIkRJViI9PWcubm9kZU5hbWUmJiI8YnI+Ij09Zy5pbm5lckhUTUwudG9Mb3dlckNhc2UoKT9kLnB1c2goIlxuIik6KDM9PT1nLm5vZGVUeXBlfHw0PT09Zy5ub2RlVHlwZT8wPGcubm9kZVZhbHVlLmxlbmd0aCYmZC5wdXNoKGcubm9kZVZhbHVlKTo4IT09Zy5ub2RlVHlwZSYmMDxnLmNoaWxkTm9kZXMubGVuZ3RoJiZiKGcuY2hpbGROb2RlcyksCmU8YS5sZW5ndGgtMSYmMDw9bXhVdGlscy5pbmRleE9mKGMsYVtlKzFdLm5vZGVOYW1lKSYmZC5wdXNoKCJcbiIpKX19dmFyIGM9IkJMT0NLUVVPVEUgRElWIEgxIEgyIEgzIEg0IEg1IEg2IE9MIFAgUFJFIFRBQkxFIFVMIi5zcGxpdCgiICIpLGQ9W107YihhKTtyZXR1cm4gZC5qb2luKCIiKX0scmVwbGFjZVRyYWlsaW5nTmV3bGluZXM6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9IiI7MDxhLmxlbmd0aCYmIlxuIj09YS5jaGFyQXQoYS5sZW5ndGgtMSk7KWE9YS5zdWJzdHJpbmcoMCxhLmxlbmd0aC0xKSxjKz1iO3JldHVybiBhK2N9LGdldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe3JldHVybiBteENsaWVudC5JU19JRSYmdm9pZCAwIT09YS5pbm5lclRleHQ/YS5pbm5lclRleHQ6bnVsbCE9YT9hW3ZvaWQgMD09PWEudGV4dENvbnRlbnQ/InRleHQiOiJ0ZXh0Q29udGVudCJdOiIifSxzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhLGIpe3ZvaWQgMCE9PWEuaW5uZXJUZXh0P2EuaW5uZXJUZXh0PQpiOmFbdm9pZCAwPT09YS50ZXh0Q29udGVudD8idGV4dCI6InRleHRDb250ZW50Il09Yn0sZ2V0SW5uZXJIdG1sOmZ1bmN0aW9uKCl7cmV0dXJuIG14Q2xpZW50LklTX0lFP2Z1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuaW5uZXJIVE1MOiIifTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT8obmV3IFhNTFNlcmlhbGl6ZXIpLnNlcmlhbGl6ZVRvU3RyaW5nKGEpOiIifX0oKSxnZXRPdXRlckh0bWw6ZnVuY3Rpb24oKXtyZXR1cm4gbXhDbGllbnQuSVNfSUU/ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7aWYobnVsbCE9YS5vdXRlckhUTUwpcmV0dXJuIGEub3V0ZXJIVE1MO3ZhciBiPVtdO2IucHVzaCgiPCIrYS5ub2RlTmFtZSk7dmFyIGM9YS5hdHRyaWJ1dGVzO2lmKG51bGwhPWMpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0udmFsdWU7bnVsbCE9ZSYmMDxlLmxlbmd0aCYmKGIucHVzaCgiICIpLGIucHVzaChjW2RdLm5vZGVOYW1lKSxiLnB1c2goJz0iJyksCmIucHVzaChlKSxiLnB1c2goJyInKSl9MD09YS5pbm5lckhUTUwubGVuZ3RoP2IucHVzaCgiLz4iKTooYi5wdXNoKCI+IiksYi5wdXNoKGEuaW5uZXJIVE1MKSxiLnB1c2goIjwvIithLm5vZGVOYW1lKyI+IikpO3JldHVybiBiLmpvaW4oIiIpfXJldHVybiIifTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT8obmV3IFhNTFNlcmlhbGl6ZXIpLnNlcmlhbGl6ZVRvU3RyaW5nKGEpOiIifX0oKSx3cml0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShiKTtudWxsIT1hJiZhLmFwcGVuZENoaWxkKGMpO3JldHVybiBjfSx3cml0ZWxuOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGIpO251bGwhPWEmJihhLmFwcGVuZENoaWxkKGMpLGEuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKSkpO3JldHVybiBjfSxicjpmdW5jdGlvbihhLGIpe2I9Ynx8MTtmb3IodmFyIGM9bnVsbCwKZD0wO2Q8YjtkKyspbnVsbCE9YSYmKGM9YS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJyIiksYS5hcHBlbmRDaGlsZChjKSk7cmV0dXJuIGN9LGJ1dHRvbjpmdW5jdGlvbihhLGIsYyl7Yz1udWxsIT1jP2M6ZG9jdW1lbnQ7Yz1jLmNyZWF0ZUVsZW1lbnQoImJ1dHRvbiIpO214VXRpbHMud3JpdGUoYyxhKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixmdW5jdGlvbihhKXtiKGEpfSk7cmV0dXJuIGN9LHBhcmE6ZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJwIik7bXhVdGlscy53cml0ZShjLGIpO251bGwhPWEmJmEuYXBwZW5kQ2hpbGQoYyk7cmV0dXJuIGN9LGFkZFRyYW5zcGFyZW50QmFja2dyb3VuZEZpbHRlcjpmdW5jdGlvbihhKXthLnN0eWxlLmZpbHRlcis9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYUltYWdlTG9hZGVyKHNyYz0nIitteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvdHJhbnNwYXJlbnQuZ2lmJywgc2l6aW5nTWV0aG9kPSdzY2FsZScpIn0sCmxpbmtBY3Rpb246ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbXhVdGlscy5saW5rKGEsYixmdW5jdGlvbigpe2MuZXhlY3V0ZShkKX0sZSl9LGxpbmtJbnZva2U6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JldHVybiBteFV0aWxzLmxpbmsoYSxiLGZ1bmN0aW9uKCl7Y1tkXShlKX0sZil9LGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO2Uuc3R5bGUuY29sb3I9ImJsdWUiO2Uuc3R5bGUudGV4dERlY29yYXRpb249InVuZGVybGluZSI7ZS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO251bGwhPWQmJihlLnN0eWxlLnBhZGRpbmdMZWZ0PWQrInB4Iik7bXhFdmVudC5hZGRMaXN0ZW5lcihlLCJjbGljayIsYyk7bXhVdGlscy53cml0ZShlLGIpO251bGwhPWEmJmEuYXBwZW5kQ2hpbGQoZSk7cmV0dXJuIGV9LGdldERvY3VtZW50U2l6ZTpmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmJvZHksYj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7CnRyeXtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCxhLmNsaWVudFdpZHRofHxiLmNsaWVudFdpZHRoLE1hdGgubWF4KGEuY2xpZW50SGVpZ2h0fHwwLGIuY2xpZW50SGVpZ2h0KSl9Y2F0Y2goYyl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZX19LGZpdDpmdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldERvY3VtZW50U2l6ZSgpLGM9cGFyc2VJbnQoYS5vZmZzZXRMZWZ0KSxkPXBhcnNlSW50KGEub2Zmc2V0V2lkdGgpLGU9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihhLm93bmVyRG9jdW1lbnQpLGY9ZS54LGU9ZS55LGc9ZitiLndpZHRoO2MrZD5nJiYoYS5zdHlsZS5sZWZ0PU1hdGgubWF4KGYsZy1kKSsicHgiKTtjPXBhcnNlSW50KGEub2Zmc2V0VG9wKTtkPXBhcnNlSW50KGEub2Zmc2V0SGVpZ2h0KTtiPWUrYi5oZWlnaHQ7YytkPmImJihhLnN0eWxlLnRvcD1NYXRoLm1heChlLGItZCkrInB4Iil9LGxvYWQ6ZnVuY3Rpb24oYSl7YT1uZXcgbXhYbWxSZXF1ZXN0KGEsbnVsbCwKIkdFVCIsITEpO2Euc2VuZCgpO3JldHVybiBhfSxnZXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7YT1uZXcgbXhYbWxSZXF1ZXN0KGEsbnVsbCwiR0VUIik7dmFyIGs9YS5zZXRSZXF1ZXN0SGVhZGVycztnJiYoYS5zZXRSZXF1ZXN0SGVhZGVycz1mdW5jdGlvbihhLGIpe2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2Zvcih2YXIgYyBpbiBnKWEuc2V0UmVxdWVzdEhlYWRlcihjLGdbY10pfSk7bnVsbCE9ZCYmYS5zZXRCaW5hcnkoZCk7YS5zZW5kKGIsYyxlLGYpO3JldHVybiBhfSxnZXRBbGw6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVtdLGY9MCxnPWZ1bmN0aW9uKCl7MD09ZiYmbnVsbCE9YyYmYygpO2YrK30saz0wO2s8YS5sZW5ndGg7aysrKShmdW5jdGlvbihhLGMpe214VXRpbHMuZ2V0KGEsZnVuY3Rpb24oYSl7dmFyIGY9YS5nZXRTdGF0dXMoKTsyMDA+Znx8Mjk5PGY/ZygpOihlW2NdPWEsZC0tLDA9PWQmJmIoZSkpfSxnKX0pKGFba10sayk7MD09ZCYmCmIoZSl9LHBvc3Q6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuKG5ldyBteFhtbFJlcXVlc3QoYSxiKSkuc2VuZChjLGQpfSxzdWJtaXQ6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuKG5ldyBteFhtbFJlcXVlc3QoYSxiKSkuc2ltdWxhdGUoYyxkKX0sbG9hZEludG86ZnVuY3Rpb24oYSxiLGMpe214Q2xpZW50LklTX0lFP2Iub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ND09Yi5yZWFkeVN0YXRlJiZjKCl9OmIuYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsYywhMSk7Yi5sb2FkKGEpfSxnZXRWYWx1ZTpmdW5jdGlvbihhLGIsYyl7YT1udWxsIT1hP2FbYl06bnVsbDtudWxsPT1hJiYoYT1jKTtyZXR1cm4gYX0sZ2V0TnVtYmVyOmZ1bmN0aW9uKGEsYixjKXthPW51bGwhPWE/YVtiXTpudWxsO251bGw9PWEmJihhPWN8fDApO3JldHVybiBOdW1iZXIoYSl9LGdldENvbG9yOmZ1bmN0aW9uKGEsYixjKXthPW51bGwhPWE/YVtiXTpudWxsO251bGw9PWE/YT1jOmE9PW14Q29uc3RhbnRzLk5PTkUmJgooYT1udWxsKTtyZXR1cm4gYX0sY2xvbmU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOiExO3ZhciBkPW51bGw7aWYobnVsbCE9YSYmImZ1bmN0aW9uIj09dHlwZW9mIGEuY29uc3RydWN0b3Ipe3ZhciBkPW5ldyBhLmNvbnN0cnVjdG9yLGU7Zm9yKGUgaW4gYSllIT1teE9iamVjdElkZW50aXR5LkZJRUxEX05BTUUmJihudWxsPT1ifHwwPm14VXRpbHMuaW5kZXhPZihiLGUpKSYmKGRbZV09Y3x8Im9iamVjdCIhPXR5cGVvZiBhW2VdP2FbZV06bXhVdGlscy5jbG9uZShhW2VdKSl9cmV0dXJuIGR9LGVxdWFsUG9pbnRzOmZ1bmN0aW9uKGEsYil7aWYobnVsbD09YSYmbnVsbCE9Ynx8bnVsbCE9YSYmbnVsbD09Ynx8bnVsbCE9YSYmbnVsbCE9YiYmYS5sZW5ndGghPWIubGVuZ3RoKXJldHVybiExO2lmKG51bGwhPWEmJm51bGwhPWIpZm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYobnVsbCE9YVtjXSYmbnVsbD09YltjXXx8bnVsbD09YVtjXSYmbnVsbCE9YltjXXx8bnVsbCE9YVtjXSYmCm51bGwhPWJbY10mJihhW2NdLnghPWJbY10ueHx8YVtjXS55IT1iW2NdLnkpKXJldHVybiExO3JldHVybiEwfSxlcXVhbEVudHJpZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz0wO2lmKG51bGw9PWEmJm51bGwhPWJ8fG51bGwhPWEmJm51bGw9PWJ8fG51bGwhPWEmJm51bGwhPWImJmEubGVuZ3RoIT1iLmxlbmd0aClyZXR1cm4hMTtpZihudWxsIT1hJiZudWxsIT1iKXtmb3IodmFyIGQgaW4gYiljKys7Zm9yKGQgaW4gYSlpZihjLS0sIShteFV0aWxzLmlzTmFOKGFbZF0pJiZteFV0aWxzLmlzTmFOKGJbZF0pfHxhW2RdPT1iW2RdKSlyZXR1cm4hMX1yZXR1cm4gMD09Y30scmVtb3ZlRHVwbGljYXRlczpmdW5jdGlvbihhKXtmb3IodmFyIGI9bmV3IG14RGljdGlvbmFyeSxjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKyliLmdldChhW2RdKXx8KGMucHVzaChhW2RdKSxiLnB1dChhW2RdLCEwKSk7cmV0dXJuIGN9LGlzTmFOOmZ1bmN0aW9uKGEpe3JldHVybiJudW1iZXIiPT10eXBlb2YgYSYmaXNOYU4oYSl9LApleHRlbmQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1mdW5jdGlvbigpe307Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YX0sdG9TdHJpbmc6ZnVuY3Rpb24oYSl7dmFyIGI9IiIsYztmb3IoYyBpbiBhKXRyeXtpZihudWxsPT1hW2NdKWIrPWMrIiA9IFtudWxsXVxuIjtlbHNlIGlmKCJmdW5jdGlvbiI9PXR5cGVvZiBhW2NdKWIrPWMrIiA9PiBbRnVuY3Rpb25dXG4iO2Vsc2UgaWYoIm9iamVjdCI9PXR5cGVvZiBhW2NdKXZhciBkPW14VXRpbHMuZ2V0RnVuY3Rpb25OYW1lKGFbY10uY29uc3RydWN0b3IpLGI9YisoYysiID0+IFsiK2QrIl1cbiIpO2Vsc2UgYis9YysiID0gIithW2NdKyJcbiJ9Y2F0Y2goZSl7Yis9YysiPSIrZS5tZXNzYWdlfXJldHVybiBifSx0b1JhZGlhbnM6ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguUEkqYS8xODB9LHRvRGVncmVlOmZ1bmN0aW9uKGEpe3JldHVybiAxODAqYS9NYXRoLlBJfSxhcmNUb0N1cnZlczpmdW5jdGlvbihhLApiLGMsZCxlLGYsZyxrLGwpe2stPWE7bC09YjtpZigwPT09Y3x8MD09PWQpcmV0dXJuIHE7Yz1NYXRoLmFicyhjKTtkPU1hdGguYWJzKGQpO3ZhciBtPS1rLzIsbj0tbC8yLHA9TWF0aC5jb3MoZSpNYXRoLlBJLzE4MCkscT1NYXRoLnNpbihlKk1hdGguUEkvMTgwKTtlPXAqbStxKm47dmFyIG09LTEqcSptK3AqbixuPWUqZSxyPW0qbSx0PWMqYyx1PWQqZCx4PW4vdCtyL3U7MTx4PyhjKj1NYXRoLnNxcnQoeCksZCo9TWF0aC5zcXJ0KHgpLGY9MCk6KHg9MSxmPT09ZyYmKHg9LTEpLGY9eCpNYXRoLnNxcnQoKHQqdS10KnItdSpuKS8odCpyK3UqbikpKTtuPWYqYyptL2Q7cj0tMSpmKmQqZS9jO2s9cCpuLXEqcitrLzI7bD1xKm4rcCpyK2wvMjt0PU1hdGguYXRhbjIoKG0tcikvZCwoZS1uKS9jKS1NYXRoLmF0YW4yKDAsMSk7Zj0wPD10P3Q6MipNYXRoLlBJK3Q7dD1NYXRoLmF0YW4yKCgtbS1yKS9kLCgtZS1uKS9jKS1NYXRoLmF0YW4yKChtLXIpL2QsKGUtbikvYyk7ZT0wPD10P3Q6MioKTWF0aC5QSSt0OzA9PWcmJjA8ZT9lLT0yKk1hdGguUEk6MCE9ZyYmMD5lJiYoZSs9MipNYXRoLlBJKTtnPTIqZS9NYXRoLlBJO2c9TWF0aC5jZWlsKDA+Zz8tMSpnOmcpO2UvPWc7bT04LzMqTWF0aC5zaW4oZS80KSpNYXRoLnNpbihlLzQpL01hdGguc2luKGUvMik7bj1wKmM7cCo9ZDtjKj1xO2QqPXE7Zm9yKHZhciB5PU1hdGguY29zKGYpLEI9TWF0aC5zaW4oZikscj0tbSoobipCK2QqeSksdD0tbSooYypCLXAqeSkscT1bXSxBPTA7QTxnOysrQSl7Zis9ZTt2YXIgeT1NYXRoLmNvcyhmKSxCPU1hdGguc2luKGYpLHU9bip5LWQqQitrLHg9Yyp5K3AqQitsLHo9LW0qKG4qQitkKnkpLHk9LW0qKGMqQi1wKnkpLEI9NipBO3FbQl09TnVtYmVyKHIrYSk7cVtCKzFdPU51bWJlcih0K2IpO3FbQisyXT1OdW1iZXIodS16K2EpO3FbQiszXT1OdW1iZXIoeC15K2IpO3FbQis0XT1OdW1iZXIodSthKTtxW0IrNV09TnVtYmVyKHgrYik7cj11K3o7dD14K3l9cmV0dXJuIHF9LGdldEJvdW5kaW5nQm94OmZ1bmN0aW9uKGEsCmIsYyl7dmFyIGQ9bnVsbDtpZihudWxsIT1hJiZudWxsIT1iJiYwIT1iKXtiPW14VXRpbHMudG9SYWRpYW5zKGIpO3ZhciBkPU1hdGguY29zKGIpLGU9TWF0aC5zaW4oYik7Yz1udWxsIT1jP2M6bmV3IG14UG9pbnQoYS54K2Eud2lkdGgvMixhLnkrYS5oZWlnaHQvMik7dmFyIGY9bmV3IG14UG9pbnQoYS54LGEueSk7Yj1uZXcgbXhQb2ludChhLngrYS53aWR0aCxhLnkpO3ZhciBnPW5ldyBteFBvaW50KGIueCxhLnkrYS5oZWlnaHQpO2E9bmV3IG14UG9pbnQoYS54LGcueSk7Zj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChmLGQsZSxjKTtiPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KGIsZCxlLGMpO2c9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZyxkLGUsYyk7YT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChhLGQsZSxjKTtkPW5ldyBteFJlY3RhbmdsZShmLngsZi55LDAsMCk7ZC5hZGQobmV3IG14UmVjdGFuZ2xlKGIueCxiLnksMCwwKSk7ZC5hZGQobmV3IG14UmVjdGFuZ2xlKGcueCwKZy55LDAsMCkpO2QuYWRkKG5ldyBteFJlY3RhbmdsZShhLngsYS55LDAsMCkpfXJldHVybiBkfSxnZXRSb3RhdGVkUG9pbnQ6ZnVuY3Rpb24oYSxiLGMsZCl7ZD1udWxsIT1kP2Q6bmV3IG14UG9pbnQ7dmFyIGU9YS54LWQueDthPWEueS1kLnk7cmV0dXJuIG5ldyBteFBvaW50KGUqYi1hKmMrZC54LGEqYitlKmMrZC55KX0sZ2V0UG9ydENvbnN0cmFpbnRzOmZ1bmN0aW9uKGEsYixjLGQpe2I9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPUlRfQ09OU1RSQUlOVCxteFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsYz9teENvbnN0YW50cy5TVFlMRV9TT1VSQ0VfUE9SVF9DT05TVFJBSU5UOm14Q29uc3RhbnRzLlNUWUxFX1RBUkdFVF9QT1JUX0NPTlNUUkFJTlQsbnVsbCkpO2lmKG51bGw9PWIpcmV0dXJuIGQ7ZD1iLnRvU3RyaW5nKCk7Yj1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT05FO2M9MDsxPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUE9SVF9DT05TVFJBSU5UX1JPVEFUSU9OLAowKSYmKGM9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApKTthPTA7NDU8Yz8oYT0xLDEzNTw9YyYmKGE9MikpOi00NT5jJiYoYT0zLC0xMzU+PWMmJihhPTIpKTtpZigwPD1kLmluZGV4T2YobXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIKSlzd2l0Y2goYSl7Y2FzZSAwOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PUlRIO2JyZWFrO2Nhc2UgMTpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUO2JyZWFrO2Nhc2UgMjpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSDticmVhaztjYXNlIDM6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVH1pZigwPD1kLmluZGV4T2YobXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpKXN3aXRjaChhKXtjYXNlIDA6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDticmVhaztjYXNlIDE6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9SVEg7CmJyZWFrO2Nhc2UgMjpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUO2JyZWFrO2Nhc2UgMzpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSH1pZigwPD1kLmluZGV4T2YobXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKSlzd2l0Y2goYSl7Y2FzZSAwOmJ8PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1NPVVRIO2JyZWFrO2Nhc2UgMTpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUO2JyZWFrO2Nhc2UgMjpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT1JUSDticmVhaztjYXNlIDM6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVH1pZigwPD1kLmluZGV4T2YobXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpKXN3aXRjaChhKXtjYXNlIDA6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVDticmVhaztjYXNlIDE6Ynw9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfU09VVEg7YnJlYWs7Y2FzZSAyOmJ8PQpteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUO2JyZWFrO2Nhc2UgMzpifD1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT1JUSH1yZXR1cm4gYn0scmV2ZXJzZVBvcnRDb25zdHJhaW50czpmdW5jdGlvbihhKXt2YXIgYjtiPShhJm14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1QpPDwzO2J8PShhJm14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PUlRIKTw8MTtifD0oYSZteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSCk+PjE7cmV0dXJuIGJ8KGEmbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVCk+PjN9LGZpbmROZWFyZXN0U2VnbWVudDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9LTE7aWYoMDxhLmFic29sdXRlUG9pbnRzLmxlbmd0aClmb3IodmFyIGU9YS5hYnNvbHV0ZVBvaW50c1swXSxmPW51bGwsZz0xO2c8YS5hYnNvbHV0ZVBvaW50cy5sZW5ndGg7ZysrKXt2YXIgaz1hLmFic29sdXRlUG9pbnRzW2ddLGU9bXhVdGlscy5wdFNlZ0Rpc3RTcShlLngsCmUueSxrLngsay55LGIsYyk7aWYobnVsbD09Znx8ZTxmKWY9ZSxkPWctMTtlPWt9cmV0dXJuIGR9LGdldERpcmVjdGVkQm91bmRzOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9bXhVdGlscy5nZXRWYWx1ZShjLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCk7ZD1udWxsIT1kP2Q6bXhVdGlscy5nZXRWYWx1ZShjLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILCExKTtlPW51bGwhPWU/ZTpteFV0aWxzLmdldFZhbHVlKGMsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsITEpO2IueD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxiLngpKSk7Yi55PU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxiLnkpKSk7Yi53aWR0aD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxiLndpZHRoKSkpO2IuaGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCwKYi5oZWlnaHQpKSk7aWYoZSYmKGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSHx8Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIKXx8ZCYmKGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUfHxmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCkpYz1iLngsYi54PWIud2lkdGgsYi53aWR0aD1jO2lmKGQmJihmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCl8fGUmJihmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVHx8Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpKWM9Yi55LGIueT1iLmhlaWdodCxiLmhlaWdodD1jO2Q9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShiKTtmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KGQueT1iLngsZC54PWIuaGVpZ2h0LGQud2lkdGg9Yi55LGQuaGVpZ2h0PWIud2lkdGgpOmY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUPyhkLnk9Yi5oZWlnaHQsCmQueD1iLndpZHRoLGQud2lkdGg9Yi54LGQuaGVpZ2h0PWIueSk6Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIJiYoZC55PWIud2lkdGgsZC54PWIueSxkLndpZHRoPWIuaGVpZ2h0LGQuaGVpZ2h0PWIueCk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngrZC54LGEueStkLnksYS53aWR0aC1kLndpZHRoLWQueCxhLmhlaWdodC1kLmhlaWdodC1kLnkpfSxnZXRQZXJpbWV0ZXJQb2ludDpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPW51bGwsZT0wO2U8YS5sZW5ndGgtMTtlKyspe3ZhciBmPW14VXRpbHMuaW50ZXJzZWN0aW9uKGFbZV0ueCxhW2VdLnksYVtlKzFdLngsYVtlKzFdLnksYi54LGIueSxjLngsYy55KTtpZihudWxsIT1mKXt2YXIgZz1jLngtZi54LGs9Yy55LWYueSxmPXtwOmYsZGlzdFNxOmsqaytnKmd9O251bGwhPWYmJihudWxsPT1kfHxkLmRpc3RTcT5mLmRpc3RTcSkmJihkPWYpfX1yZXR1cm4gbnVsbCE9ZD9kLnA6bnVsbH0scmVjdGFuZ2xlSW50ZXJzZWN0c1NlZ21lbnQ6ZnVuY3Rpb24oYSwKYixjKXt2YXIgZD1hLnksZT1hLngsZj1kK2EuaGVpZ2h0LGc9ZSthLndpZHRoO2E9Yi54O3ZhciBrPWMueDtiLng+Yy54JiYoYT1jLngsaz1iLngpO2s+ZyYmKGs9Zyk7YTxlJiYoYT1lKTtpZihhPmspcmV0dXJuITE7dmFyIGU9Yi55LGc9Yy55LGw9Yy54LWIueDsxRS03PE1hdGguYWJzKGwpJiYoYz0oYy55LWIueSkvbCxiPWIueS1jKmIueCxlPWMqYStiLGc9YyprK2IpO2U+ZyYmKGI9ZyxnPWUsZT1iKTtnPmYmJihnPWYpO2U8ZCYmKGU9ZCk7cmV0dXJuIGU+Zz8hMTohMH0sY29udGFpbnM6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhLng8PWImJmEueCthLndpZHRoPj1iJiZhLnk8PWMmJmEueSthLmhlaWdodD49Y30saW50ZXJzZWN0czpmdW5jdGlvbihhLGIpe3ZhciBjPWEud2lkdGgsZD1hLmhlaWdodCxlPWIud2lkdGgsZj1iLmhlaWdodDtpZigwPj1lfHwwPj1mfHwwPj1jfHwwPj1kKXJldHVybiExO3ZhciBnPWEueCxrPWEueSxsPWIueCxtPWIueSxlPWUrbCxmPWYrbSxjPWMrCmcsZD1kK2s7cmV0dXJuKGU8bHx8ZT5nKSYmKGY8bXx8Zj5rKSYmKGM8Z3x8Yz5sKSYmKGQ8a3x8ZD5tKX0saW50ZXJzZWN0c0hvdHNwb3Q6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2Q9bnVsbCE9ZD9kOjE7ZT1udWxsIT1lP2U6MDtmPW51bGwhPWY/ZjowO2lmKDA8ZCl7dmFyIGc9YS5nZXRDZW50ZXJYKCksaz1hLmdldENlbnRlclkoKSxsPWEud2lkdGgsbT1hLmhlaWdodCxuPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUpKmEudmlldy5zY2FsZTswPG4mJihteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwhMCk/KGs9YS55K24vMixtPW4pOihnPWEueCtuLzIsbD1uKSk7bD1NYXRoLm1heChlLGwqZCk7bT1NYXRoLm1heChlLG0qZCk7MDxmJiYobD1NYXRoLm1pbihsLGYpLG09TWF0aC5taW4obSxmKSk7ZD1uZXcgbXhSZWN0YW5nbGUoZy1sLzIsay1tLzIsbCxtKTtnPW14VXRpbHMudG9SYWRpYW5zKG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwKbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04pfHwwKTswIT1nJiYoZT1NYXRoLmNvcygtZyksZj1NYXRoLnNpbigtZyksZz1uZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLmdldENlbnRlclkoKSksYT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChiLGMpLGUsZixnKSxiPWEueCxjPWEueSk7cmV0dXJuIG14VXRpbHMuY29udGFpbnMoZCxiLGMpfXJldHVybiEwfSxnZXRPZmZzZXQ6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MCxkPTAsZT0hMSxmPWEsZz1kb2N1bWVudC5ib2R5LGs9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O251bGwhPWYmJmYhPWcmJmYhPWsmJiFlOyl7dmFyIGw9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUoZik7bnVsbCE9bCYmKGU9ZXx8ImZpeGVkIj09bC5wb3NpdGlvbik7Zj1mLnBhcmVudE5vZGV9Ynx8ZXx8KGU9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihhLm93bmVyRG9jdW1lbnQpLGMrPWUueCxkKz1lLnkpO2U9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKbnVsbCE9ZSYmKGMrPWUubGVmdCxkKz1lLnRvcCk7cmV0dXJuIG5ldyBteFBvaW50KGMsZCl9LGdldERvY3VtZW50U2Nyb2xsT3JpZ2luOmZ1bmN0aW9uKGEpe2lmKG14Q2xpZW50LklTX1FVSVJLUylyZXR1cm4gbmV3IG14UG9pbnQoYS5ib2R5LnNjcm9sbExlZnQsYS5ib2R5LnNjcm9sbFRvcCk7YT1hLmRlZmF1bHRWaWV3fHxhLnBhcmVudFdpbmRvdztyZXR1cm4gbmV3IG14UG9pbnQobnVsbCE9YSYmdm9pZCAwIT09d2luZG93LnBhZ2VYT2Zmc2V0P3dpbmRvdy5wYWdlWE9mZnNldDooZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxkb2N1bWVudC5ib2R5LnBhcmVudE5vZGV8fGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnQsbnVsbCE9YSYmdm9pZCAwIT09d2luZG93LnBhZ2VZT2Zmc2V0P3dpbmRvdy5wYWdlWU9mZnNldDooZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHxkb2N1bWVudC5ib2R5LnBhcmVudE5vZGV8fGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcCl9LGdldFNjcm9sbE9yaWdpbjpmdW5jdGlvbihhLApiLGMpe2I9bnVsbCE9Yj9iOiExO2M9bnVsbCE9Yz9jOiEwO2Zvcih2YXIgZD1udWxsIT1hP2Eub3duZXJEb2N1bWVudDpkb2N1bWVudCxlPWQuYm9keSxmPWQuZG9jdW1lbnRFbGVtZW50LGc9bmV3IG14UG9pbnQsaz0hMTtudWxsIT1hJiZhIT1lJiZhIT1mOyl7aXNOYU4oYS5zY3JvbGxMZWZ0KXx8aXNOYU4oYS5zY3JvbGxUb3ApfHwoZy54Kz1hLnNjcm9sbExlZnQsZy55Kz1hLnNjcm9sbFRvcCk7dmFyIGw9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUoYSk7bnVsbCE9bCYmKGs9a3x8ImZpeGVkIj09bC5wb3NpdGlvbik7YT1iP2EucGFyZW50Tm9kZTpudWxsfSFrJiZjJiYoYT1teFV0aWxzLmdldERvY3VtZW50U2Nyb2xsT3JpZ2luKGQpLGcueCs9YS54LGcueSs9YS55KTtyZXR1cm4gZ30sY29udmVydFBvaW50OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1teFV0aWxzLmdldFNjcm9sbE9yaWdpbihhLCExKTthPW14VXRpbHMuZ2V0T2Zmc2V0KGEpO2EueC09ZC54O2EueS09ZC55O3JldHVybiBuZXcgbXhQb2ludChiLQphLngsYy1hLnkpfSxsdHJpbTpmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hP2EucmVwbGFjZShuZXcgUmVnRXhwKCJeWyIrKGJ8fCJcXHMiKSsiXSsiLCJnIiksIiIpOm51bGx9LHJ0cmltOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWE/YS5yZXBsYWNlKG5ldyBSZWdFeHAoIlsiKyhifHwiXFxzIikrIl0rJCIsImciKSwiIik6bnVsbH0sdHJpbTpmdW5jdGlvbihhLGIpe3JldHVybiBteFV0aWxzLmx0cmltKG14VXRpbHMucnRyaW0oYSxiKSxiKX0saXNOdW1lcmljOmZ1bmN0aW9uKGEpe3JldHVybiFpc05hTihwYXJzZUZsb2F0KGEpKSYmaXNGaW5pdGUoYSkmJigic3RyaW5nIiE9dHlwZW9mIGF8fDA+YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoIjB4IikpfSxpc0ludGVnZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIFN0cmluZyhwYXJzZUludChhKSk9PT1TdHJpbmcoYSl9LG1vZDpmdW5jdGlvbihhLGIpe3JldHVybihhJWIrYiklYn0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKGEsYiwKYyxkLGUsZixnLGspe3ZhciBsPShrLWYpKihjLWEpLShnLWUpKihkLWIpO2c9KChnLWUpKihiLWYpLShrLWYpKihhLWUpKS9sO2U9KChjLWEpKihiLWYpLShkLWIpKihhLWUpKS9sO3JldHVybiAwPD1nJiYxPj1nJiYwPD1lJiYxPj1lP25ldyBteFBvaW50KGErZyooYy1hKSxiK2cqKGQtYikpOm51bGx9LHB0U2VnRGlzdFNxOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtjLT1hO2QtPWI7ZS09YTtmLT1iOzA+PWUqYytmKmQ/Yz0wOihlPWMtZSxmPWQtZixhPWUqYytmKmQsYz0wPj1hPzA6YSphLyhjKmMrZCpkKSk7ZT1lKmUrZipmLWM7MD5lJiYoZT0wKTtyZXR1cm4gZX0scHRMaW5lRGlzdDpmdW5jdGlvbihhLGIsYyxkLGUsZil7cmV0dXJuIE1hdGguYWJzKChkLWIpKmUtKGMtYSkqZitjKmItZCphKS9NYXRoLnNxcnQoKGQtYikqKGQtYikrKGMtYSkqKGMtYSkpfSxyZWxhdGl2ZUNjdzpmdW5jdGlvbihhLGIsYyxkLGUsZil7Yy09YTtkLT1iO2UtPWE7Zi09YjthPWUqZC1mKmM7MD09YSYmCihhPWUqYytmKmQsMDxhJiYoYT0oZS1jKSpjKyhmLWQpKmQsMD5hJiYoYT0wKSkpO3JldHVybiAwPmE/LTE6MDxhPzE6MH0sYW5pbWF0ZUNoYW5nZXM6ZnVuY3Rpb24oYSxiKXtteEVmZmVjdHMuYW5pbWF0ZUNoYW5nZXMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjYXNjYWRlT3BhY2l0eTpmdW5jdGlvbihhLGIsYyl7bXhFZmZlY3RzLmNhc2NhZGVPcGFjaXR5LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZmFkZU91dDpmdW5jdGlvbihhLGIsYyxkLGUsZil7bXhFZmZlY3RzLmZhZGVPdXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxzZXRPcGFjaXR5OmZ1bmN0aW9uKGEsYil7bXhVdGlscy5pc1ZtbChhKT9hLnN0eWxlLmZpbHRlcj0xMDA8PWI/IiI6ImFscGhhKG9wYWNpdHk9IitiLzUrIikiOm14Q2xpZW50LklTX0lFJiYoInVuZGVmaW5lZCI9PT10eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PmRvY3VtZW50LmRvY3VtZW50TW9kZSk/YS5zdHlsZS5maWx0ZXI9MTAwPD1iPyIiOgoiYWxwaGEob3BhY2l0eT0iK2IrIikiOmEuc3R5bGUub3BhY2l0eT1iLzEwMH0sY3JlYXRlSW1hZ2U6ZnVuY3Rpb24oYSl7dmFyIGI7bXhDbGllbnQuSVNfSUU2JiYiQ1NTMUNvbXBhdCIhPWRvY3VtZW50LmNvbXBhdE1vZGU/KGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChteENsaWVudC5WTUxfUFJFRklYKyI6aW1hZ2UiKSxiLnNldEF0dHJpYnV0ZSgic3JjIixhKSxiLnN0eWxlLmJvcmRlclN0eWxlPSJub25lIik6KGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIiksYi5zZXRBdHRyaWJ1dGUoInNyYyIsYSksYi5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKSk7cmV0dXJuIGJ9LHNvcnRDZWxsczpmdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiEwO3ZhciBjPW5ldyBteERpY3Rpb25hcnk7YS5zb3J0KGZ1bmN0aW9uKGEsZSl7dmFyIGQ9Yy5nZXQoYSk7bnVsbD09ZCYmKGQ9bXhDZWxsUGF0aC5jcmVhdGUoYSkuc3BsaXQobXhDZWxsUGF0aC5QQVRIX1NFUEFSQVRPUiksYy5wdXQoYSwKZCkpO3ZhciBnPWMuZ2V0KGUpO251bGw9PWcmJihnPW14Q2VsbFBhdGguY3JlYXRlKGUpLnNwbGl0KG14Q2VsbFBhdGguUEFUSF9TRVBBUkFUT1IpLGMucHV0KGUsZykpO2Q9bXhDZWxsUGF0aC5jb21wYXJlKGQsZyk7cmV0dXJuIDA9PWQ/MDowPGQ9PWI/MTotMX0pO3JldHVybiBhfSxnZXRTdHlsZW5hbWU6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJihhPWEuc3BsaXQoIjsiKVswXSwwPmEuaW5kZXhPZigiPSIpKT9hOiIifSxnZXRTdHlsZW5hbWVzOmZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKG51bGwhPWEpe2E9YS5zcGxpdCgiOyIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKTA+YVtjXS5pbmRleE9mKCI9IikmJmIucHVzaChhW2NdKX1yZXR1cm4gYn0saW5kZXhPZlN0eWxlbmFtZTpmdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJm51bGwhPWIpZm9yKHZhciBjPWEuc3BsaXQoIjsiKSxkPTAsZT0wO2U8Yy5sZW5ndGg7ZSsrKXtpZihjW2VdPT1iKXJldHVybiBkO2QrPWNbZV0ubGVuZ3RoKwoxfXJldHVybi0xfSxhZGRTdHlsZW5hbWU6ZnVuY3Rpb24oYSxiKXswPm14VXRpbHMuaW5kZXhPZlN0eWxlbmFtZShhLGIpJiYobnVsbD09YT9hPSIiOjA8YS5sZW5ndGgmJiI7IiE9YS5jaGFyQXQoYS5sZW5ndGgtMSkmJihhKz0iOyIpLGErPWIpO3JldHVybiBhfSxyZW1vdmVTdHlsZW5hbWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTtpZihudWxsIT1hKWZvcih2YXIgZD1hLnNwbGl0KCI7IiksZT0wO2U8ZC5sZW5ndGg7ZSsrKWRbZV0hPWImJmMucHVzaChkW2VdKTtyZXR1cm4gYy5qb2luKCI7Iil9LHJlbW92ZUFsbFN0eWxlbmFtZXM6ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYobnVsbCE9YSl7YT1hLnNwbGl0KCI7Iik7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspMDw9YVtjXS5pbmRleE9mKCI9IikmJmIucHVzaChhW2NdKX1yZXR1cm4gYi5qb2luKCI7Iil9LHNldENlbGxTdHlsZXM6ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9YiYmMDxiLmxlbmd0aCl7YS5iZWdpblVwZGF0ZSgpOwp0cnl7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspaWYobnVsbCE9YltlXSl7dmFyIGY9bXhVdGlscy5zZXRTdHlsZShhLmdldFN0eWxlKGJbZV0pLGMsZCk7YS5zZXRTdHlsZShiW2VdLGYpfX1maW5hbGx5e2EuZW5kVXBkYXRlKCl9fX0sc2V0U3R5bGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwhPWMmJigidW5kZWZpbmVkIj09dHlwZW9mIGMubGVuZ3RofHwwPGMubGVuZ3RoKTtpZihudWxsPT1hfHwwPT1hLmxlbmd0aClkJiYoYT1iKyI9IitjKyI7Iik7ZWxzZSBpZihhLnN1YnN0cmluZygwLGIubGVuZ3RoKzEpPT1iKyI9Iil7dmFyIGU9YS5pbmRleE9mKCI7Iik7YT1kP2IrIj0iK2MrKDA+ZT8iOyI6YS5zdWJzdHJpbmcoZSkpOjA+ZXx8ZT09YS5sZW5ndGgtMT8iIjphLnN1YnN0cmluZyhlKzEpfWVsc2V7dmFyIGY9YS5pbmRleE9mKCI7IitiKyI9Iik7MD5mP2QmJihkPSI7Ij09YS5jaGFyQXQoYS5sZW5ndGgtMSk/IiI6IjsiLGE9YStkK2IrIj0iK2MrIjsiKTooZT1hLmluZGV4T2YoIjsiLApmKzEpLGE9ZD9hLnN1YnN0cmluZygwLGYrMSkrYisiPSIrYysoMD5lPyI7IjphLnN1YnN0cmluZyhlKSk6YS5zdWJzdHJpbmcoMCxmKSsoMD5lPyI7IjphLnN1YnN0cmluZyhlKSkpfXJldHVybiBhfSxzZXRDZWxsU3R5bGVGbGFnczpmdW5jdGlvbihhLGIsYyxkLGUpe2lmKG51bGwhPWImJjA8Yi5sZW5ndGgpe2EuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspaWYobnVsbCE9YltmXSl7dmFyIGc9bXhVdGlscy5zZXRTdHlsZUZsYWcoYS5nZXRTdHlsZShiW2ZdKSxjLGQsZSk7YS5zZXRTdHlsZShiW2ZdLGcpfX1maW5hbGx5e2EuZW5kVXBkYXRlKCl9fX0sc2V0U3R5bGVGbGFnOmZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGw9PWF8fDA9PWEubGVuZ3RoKWE9ZHx8bnVsbD09ZD9iKyI9IitjOmIrIj0wIjtlbHNle3ZhciBlPWEuaW5kZXhPZihiKyI9Iik7aWYoMD5lKWU9IjsiPT1hLmNoYXJBdChhLmxlbmd0aC0xKT8iIjoiOyIsYT1kfHxudWxsPT1kP2ErCmUrYisiPSIrYzphK2UrYisiPTAiO2Vsc2V7dmFyIGY9YS5pbmRleE9mKCI7IixlKSxnO2c9MD5mP2Euc3Vic3RyaW5nKGUrYi5sZW5ndGgrMSk6YS5zdWJzdHJpbmcoZStiLmxlbmd0aCsxLGYpO2c9bnVsbD09ZD9wYXJzZUludChnKV5jOmQ/cGFyc2VJbnQoZyl8YzpwYXJzZUludChnKSZ+YzthPWEuc3Vic3RyaW5nKDAsZSkrYisiPSIrZysoMDw9Zj9hLnN1YnN0cmluZyhmKToiIil9fXJldHVybiBhfSxnZXRBbGlnbm1lbnRBc1BvaW50OmZ1bmN0aW9uKGEsYil7dmFyIGM9LS41LGQ9LS41O2E9PW14Q29uc3RhbnRzLkFMSUdOX0xFRlQ/Yz0wOmE9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoYz0tMSk7Yj09bXhDb25zdGFudHMuQUxJR05fVE9QP2Q9MDpiPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00mJihkPS0xKTtyZXR1cm4gbmV3IG14UG9pbnQoYyxkKX0sZ2V0U2l6ZUZvclN0cmluZzpmdW5jdGlvbihhLGIsYyxkLGUpe2I9bnVsbCE9Yj9iOm14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNJWkU7CmM9bnVsbCE9Yz9jOm14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWTt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtmLnN0eWxlLmZvbnRGYW1pbHk9YztmLnN0eWxlLmZvbnRTaXplPU1hdGgucm91bmQoYikrInB4IjtmLnN0eWxlLmxpbmVIZWlnaHQ9TWF0aC5yb3VuZChiKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKSsicHgiO251bGwhPWUmJigoZSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQmJihmLnN0eWxlLmZvbnRXZWlnaHQ9ImJvbGQiKSwoZSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDJiYoZi5zdHlsZS5mb250U3R5bGU9Iml0YWxpYyIpLGI9W10sKGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmYi5wdXNoKCJ1bmRlcmxpbmUiKSwoZSZteENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gpPT1teENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gmJgpiLnB1c2goImxpbmUtdGhyb3VnaCIpLDA8Yi5sZW5ndGgmJihmLnN0eWxlLnRleHREZWNvcmF0aW9uPWIuam9pbigiICIpKSk7Zi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Yuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIjtmLnN0eWxlLmRpc3BsYXk9bXhDbGllbnQuSVNfUVVJUktTPyJpbmxpbmUiOiJpbmxpbmUtYmxvY2siO2Yuc3R5bGUuem9vbT0iMSI7bnVsbCE9ZD8oZi5zdHlsZS53aWR0aD1kKyJweCIsZi5zdHlsZS53aGl0ZVNwYWNlPSJub3JtYWwiKTpmLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7Zi5pbm5lckhUTUw9YTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpO2E9bmV3IG14UmVjdGFuZ2xlKDAsMCxmLm9mZnNldFdpZHRoLGYub2Zmc2V0SGVpZ2h0KTtkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGYpO3JldHVybiBhfSxnZXRWaWV3WG1sOmZ1bmN0aW9uKGEsYixjLGQsZSl7ZD1udWxsIT1kP2Q6MDtlPW51bGwhPWU/ZTowO2I9bnVsbCE9Yj9iOjE7bnVsbD09CmMmJihjPVthLmdldE1vZGVsKCkuZ2V0Um9vdCgpXSk7dmFyIGY9YS5nZXRWaWV3KCksZz1udWxsLGs9Zi5pc0V2ZW50c0VuYWJsZWQoKTtmLnNldEV2ZW50c0VuYWJsZWQoITEpO3ZhciBsPWYuZHJhd1BhbmUsbT1mLm92ZXJsYXlQYW5lO2EuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/KGYuZHJhd1BhbmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpLGYuY2FudmFzLmFwcGVuZENoaWxkKGYuZHJhd1BhbmUpLGYub3ZlcmxheVBhbmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpKTooZi5kcmF3UGFuZT1mLmRyYXdQYW5lLmNsb25lTm9kZSghMSksZi5jYW52YXMuYXBwZW5kQ2hpbGQoZi5kcmF3UGFuZSksZi5vdmVybGF5UGFuZT1mLm92ZXJsYXlQYW5lLmNsb25lTm9kZSghMSkpO2YuY2FudmFzLmFwcGVuZENoaWxkKGYub3ZlcmxheVBhbmUpO3ZhciBuPWYuZ2V0VHJhbnNsYXRlKCk7Zi50cmFuc2xhdGU9Cm5ldyBteFBvaW50KGQsZSk7Yj1uZXcgbXhUZW1wb3JhcnlDZWxsU3RhdGVzKGEuZ2V0VmlldygpLGIsYyk7dHJ5e2c9KG5ldyBteENvZGVjKS5lbmNvZGUoYS5nZXRWaWV3KCkpfWZpbmFsbHl7Yi5kZXN0cm95KCksZi50cmFuc2xhdGU9bixmLmNhbnZhcy5yZW1vdmVDaGlsZChmLmRyYXdQYW5lKSxmLmNhbnZhcy5yZW1vdmVDaGlsZChmLm92ZXJsYXlQYW5lKSxmLmRyYXdQYW5lPWwsZi5vdmVybGF5UGFuZT1tLGYuc2V0RXZlbnRzRW5hYmxlZChrKX1yZXR1cm4gZ30sZ2V0U2NhbGVGb3JQYWdlQ291bnQ6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoMT5hKXJldHVybiAxO2M9bnVsbCE9Yz9jOm14Q29uc3RhbnRzLlBBR0VfRk9STUFUX0E0X1BPUlRSQUlUO2Q9bnVsbCE9ZD9kOjA7dmFyIGU9Yy53aWR0aC0yKmQ7Yz1jLmhlaWdodC0yKmQ7ZD1iLmdldEdyYXBoQm91bmRzKCkuY2xvbmUoKTtiPWIuZ2V0VmlldygpLmdldFNjYWxlKCk7ZC53aWR0aC89YjtkLmhlaWdodC89YjtiPWQud2lkdGg7CnZhciBmPU1hdGguc3FydChhKTtkPU1hdGguc3FydChiL2QuaGVpZ2h0LyhlL2MpKTtjPWYqZDtkPWYvZDtpZigxPmMmJmQ+YSl7dmFyIGc9ZC9hO2Q9YTtjLz1nfTE+ZCYmYz5hJiYoZz1jL2EsYz1hLGQvPWcpO2c9TWF0aC5jZWlsKGMpKk1hdGguY2VpbChkKTtmb3IoZj0wO2c+YTspe3ZhciBnPU1hdGguZmxvb3IoYykvYyxrPU1hdGguZmxvb3IoZCkvZDsxPT1nJiYoZz1NYXRoLmZsb29yKGMtMSkvYyk7MT09ayYmKGs9TWF0aC5mbG9vcihkLTEpL2QpO2c9Zz5rP2c6aztjKj1nO2QqPWc7Zz1NYXRoLmNlaWwoYykqTWF0aC5jZWlsKGQpO2YrKztpZigxMDxmKWJyZWFrfXJldHVybiBlKmMvYiouOTk5OTl9LHNob3c6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2M9bnVsbCE9Yz9jOjA7ZD1udWxsIT1kP2Q6MDtudWxsPT1iP2I9d2luZG93Lm9wZW4oKS5kb2N1bWVudDpiLm9wZW4oKTs5PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJmIud3JpdGVsbignXHgzYyEtLVtpZiBJRV0+PG1ldGEgaHR0cC1lcXVpdj0iWC1VQS1Db21wYXRpYmxlIiBjb250ZW50PSJJRT05Ij48IVtlbmRpZl0tLVx4M2UnKTsKdmFyIGc9YS5nZXRHcmFwaEJvdW5kcygpLGs9TWF0aC5jZWlsKGMtZy54KSxsPU1hdGguY2VpbChkLWcueSk7bnVsbD09ZSYmKGU9TWF0aC5jZWlsKGcud2lkdGgrYykrTWF0aC5jZWlsKE1hdGguY2VpbChnLngpLWcueCkpO251bGw9PWYmJihmPU1hdGguY2VpbChnLmhlaWdodCtkKStNYXRoLmNlaWwoTWF0aC5jZWlsKGcueSktZy55KSk7aWYobXhDbGllbnQuSVNfSUV8fDExPT1kb2N1bWVudC5kb2N1bWVudE1vZGUpe2Q9IjxodG1sPjxoZWFkPiI7Zz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYmFzZSIpO2ZvcihjPTA7YzxnLmxlbmd0aDtjKyspZCs9Z1tjXS5vdXRlckhUTUw7ZCs9IjxzdHlsZT4iO2ZvcihjPTA7Yzxkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7YysrKXRyeXtkKz1kb2N1bWVudC5zdHlsZVNoZWV0c1tjXS5jc3NUZXh0fWNhdGNoKG0pe31kPWQrJzwvc3R5bGU+PC9oZWFkPjxib2R5IHN0eWxlPSJtYXJnaW46MHB4OyI+JysoJzxkaXYgc3R5bGU9InBvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjt3aWR0aDonKwplKyJweDtoZWlnaHQ6IitmKydweDsiPjxkaXYgc3R5bGU9InBvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6JytrKyJweDt0b3A6IitsKydweDsiPicpK2EuY29udGFpbmVyLmlubmVySFRNTDtiLndyaXRlbG4oZCsiPC9kaXY+PC9kaXY+PC9ib2R5PjxodG1sPiIpO2IuY2xvc2UoKX1lbHNle2Iud3JpdGVsbigiPGh0bWw+PGhlYWQ+Iik7Zz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYmFzZSIpO2ZvcihjPTA7YzxnLmxlbmd0aDtjKyspYi53cml0ZWxuKG14VXRpbHMuZ2V0T3V0ZXJIdG1sKGdbY10pKTtkPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJsaW5rIik7Zm9yKGM9MDtjPGQubGVuZ3RoO2MrKyliLndyaXRlbG4obXhVdGlscy5nZXRPdXRlckh0bWwoZFtjXSkpO2Q9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInN0eWxlIik7Zm9yKGM9MDtjPGQubGVuZ3RoO2MrKyliLndyaXRlbG4obXhVdGlscy5nZXRPdXRlckh0bWwoZFtjXSkpO2Iud3JpdGVsbignPC9oZWFkPjxib2R5IHN0eWxlPSJtYXJnaW46MHB4OyI+PC9ib2R5PjwvaHRtbD4nKTsKYi5jbG9zZSgpO2M9Yi5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLnBvc2l0aW9uPSJhYnNvbHV0ZSI7Yy5vdmVyZmxvdz0iaGlkZGVuIjtjLnN0eWxlLndpZHRoPWUrInB4IjtjLnN0eWxlLmhlaWdodD1mKyJweCI7ZT1iLmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Uuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtlLnN0eWxlLmxlZnQ9aysicHgiO2Uuc3R5bGUudG9wPWwrInB4IjtmPWEuY29udGFpbmVyLmZpcnN0Q2hpbGQ7Zm9yKGQ9bnVsbDtudWxsIT1mOylnPWYuY2xvbmVOb2RlKCEwKSxmPT1hLnZpZXcuZHJhd1BhbmUub3duZXJTVkdFbGVtZW50PyhjLmFwcGVuZENoaWxkKGcpLGQ9Zyk6ZS5hcHBlbmRDaGlsZChnKSxmPWYubmV4dFNpYmxpbmc7Yi5ib2R5LmFwcGVuZENoaWxkKGMpO251bGwhPWUuZmlyc3RDaGlsZCYmYi5ib2R5LmFwcGVuZENoaWxkKGUpO251bGwhPWQmJihkLnN0eWxlLm1pbldpZHRoPSIiLGQuc3R5bGUubWluSGVpZ2h0PSIiLGQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsCiJ0cmFuc2xhdGUoIitrKyIsIitsKyIpIikpfW14VXRpbHMucmVtb3ZlQ3Vyc29ycyhiLmJvZHkpO3JldHVybiBifSxwcmludFNjcmVlbjpmdW5jdGlvbihhKXt2YXIgYj13aW5kb3cub3BlbigpO2EuZ2V0R3JhcGhCb3VuZHMoKTtteFV0aWxzLnNob3coYSxiLmRvY3VtZW50KTthPWZ1bmN0aW9uKCl7Yi5mb2N1cygpO2IucHJpbnQoKTtiLmNsb3NlKCl9O214Q2xpZW50LklTX0dDP2Iuc2V0VGltZW91dChhLDUwMCk6YSgpfSxwb3B1cDpmdW5jdGlvbihhLGIpe2lmKGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Muc3R5bGUub3ZlcmZsb3c9InNjcm9sbCI7Yy5zdHlsZS53aWR0aD0iNjM2cHgiO2Muc3R5bGUuaGVpZ2h0PSI0NjBweCI7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicHJlIik7ZC5pbm5lckhUTUw9bXhVdGlscy5odG1sRW50aXRpZXMoYSwhMSkucmVwbGFjZSgvXG4vZywiPGJyPiIpLnJlcGxhY2UoLyAvZywiJm5ic3A7Iik7Yy5hcHBlbmRDaGlsZChkKTsKYz1uZXcgbXhXaW5kb3coIlBvcHVwIFdpbmRvdyIsYyxkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoLzItMzIwLE1hdGgubWF4KGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0fHwwLGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpLzItMjQwLDY0MCw0ODAsITEsITApO2Muc2V0Q2xvc2FibGUoITApO2Muc2V0VmlzaWJsZSghMCl9ZWxzZSBteENsaWVudC5JU19OUz8oYz13aW5kb3cub3BlbigpLGMuZG9jdW1lbnQud3JpdGVsbigiPHByZT4iK214VXRpbHMuaHRtbEVudGl0aWVzKGEpKyI8L3ByZSIpLGMuZG9jdW1lbnQuY2xvc2UoKSk6KGM9d2luZG93Lm9wZW4oKSxkPWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicHJlIiksZC5pbm5lckhUTUw9bXhVdGlscy5odG1sRW50aXRpZXMoYSwhMSkucmVwbGFjZSgvXG4vZywiPGJyPiIpLnJlcGxhY2UoLyAvZywiJm5ic3A7IiksYy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGQpKX0sYWxlcnQ6ZnVuY3Rpb24oYSl7YWxlcnQoYSl9LApwcm9tcHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gcHJvbXB0KGEsbnVsbCE9Yj9iOiIiKX0sY29uZmlybTpmdW5jdGlvbihhKXtyZXR1cm4gY29uZmlybShhKX0sZXJyb3I6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZS5zdHlsZS5wYWRkaW5nPSIyMHB4Ijt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtmLnNldEF0dHJpYnV0ZSgic3JjIixkfHxteFV0aWxzLmVycm9ySW1hZ2UpO2Yuc2V0QXR0cmlidXRlKCJ2YWxpZ24iLCJib3R0b20iKTtmLnN0eWxlLnZlcnRpY2FsQWxpZ249Im1pZGRsZSI7ZS5hcHBlbmRDaGlsZChmKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCLCoCIpKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCLCoCIpKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCLCoCIpKTtteFV0aWxzLndyaXRlKGUsYSk7YT1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoOwpkPWRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3ZhciBnPW5ldyBteFdpbmRvdyhteFJlc291cmNlcy5nZXQobXhVdGlscy5lcnJvclJlc291cmNlKXx8bXhVdGlscy5lcnJvclJlc291cmNlLGUsKGEtYikvMixkLzQsYixudWxsLCExLCEwKTtjJiYobXhVdGlscy5icihlKSxiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInAiKSxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJ1dHRvbiIpLG14Q2xpZW50LklTX0lFP2Muc3R5bGUuY3NzVGV4dD0iZmxvYXQ6cmlnaHQiOmMuc2V0QXR0cmlidXRlKCJzdHlsZSIsImZsb2F0OnJpZ2h0IiksbXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsZnVuY3Rpb24oYSl7Zy5kZXN0cm95KCl9KSxteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KG14VXRpbHMuY2xvc2VSZXNvdXJjZSl8fG14VXRpbHMuY2xvc2VSZXNvdXJjZSksYi5hcHBlbmRDaGlsZChjKSxlLmFwcGVuZENoaWxkKGIpLApteFV0aWxzLmJyKGUpLGcuc2V0Q2xvc2FibGUoITApKTtnLnNldFZpc2libGUoITApO3JldHVybiBnfSxtYWtlRHJhZ2dhYmxlOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0pe2E9bmV3IG14RHJhZ1NvdXJjZShhLGMpO2EuZHJhZ09mZnNldD1uZXcgbXhQb2ludChudWxsIT1lP2U6MCxudWxsIT1mP2Y6bXhDb25zdGFudHMuVE9PTFRJUF9WRVJUSUNBTF9PRkZTRVQpO2EuYXV0b3Njcm9sbD1nO2Euc2V0R3VpZGVzRW5hYmxlZCghMSk7bnVsbCE9bCYmKGEuaGlnaGxpZ2h0RHJvcFRhcmdldHM9bCk7bnVsbCE9bSYmKGEuZ2V0RHJvcFRhcmdldD1tKTthLmdldEdyYXBoRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIGI/YihhKTpifTtudWxsIT1kJiYoYS5jcmVhdGVEcmFnRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiBkLmNsb25lTm9kZSghMCl9LGsmJihhLmNyZWF0ZVByZXZpZXdFbGVtZW50PWZ1bmN0aW9uKGEpe3ZhciBiPWQuY2xvbmVOb2RlKCEwKSwKYz1wYXJzZUludChiLnN0eWxlLndpZHRoKSxlPXBhcnNlSW50KGIuc3R5bGUuaGVpZ2h0KTtiLnN0eWxlLndpZHRoPU1hdGgucm91bmQoYyphLnZpZXcuc2NhbGUpKyJweCI7Yi5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZChlKmEudmlldy5zY2FsZSkrInB4IjtyZXR1cm4gYn0pKTtyZXR1cm4gYX19LG14Q29uc3RhbnRzPXtERUZBVUxUX0hPVFNQT1Q6LjMsTUlOX0hPVFNQT1RfU0laRTo4LE1BWF9IT1RTUE9UX1NJWkU6MCxSRU5ERVJJTkdfSElOVF9FWEFDVDoiZXhhY3QiLFJFTkRFUklOR19ISU5UX0ZBU1RFUjoiZmFzdGVyIixSRU5ERVJJTkdfSElOVF9GQVNURVNUOiJmYXN0ZXN0IixESUFMRUNUX1NWRzoic3ZnIixESUFMRUNUX1ZNTDoidm1sIixESUFMRUNUX01JWEVESFRNTDoibWl4ZWRIdG1sIixESUFMRUNUX1BSRUZFUkhUTUw6InByZWZlckh0bWwiLERJQUxFQ1RfU1RSSUNUSFRNTDoic3RyaWN0SHRtbCIsTlNfU1ZHOiJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIsTlNfWEhUTUw6Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiLApOU19YTElOSzoiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIsU0hBRE9XQ09MT1I6ImdyYXkiLFZNTF9TSEFET1dDT0xPUjoiZ3JheSIsU0hBRE9XX09GRlNFVF9YOjIsU0hBRE9XX09GRlNFVF9ZOjMsU0hBRE9XX09QQUNJVFk6MSxOT0RFVFlQRV9FTEVNRU5UOjEsTk9ERVRZUEVfQVRUUklCVVRFOjIsTk9ERVRZUEVfVEVYVDozLE5PREVUWVBFX0NEQVRBOjQsTk9ERVRZUEVfRU5USVRZX1JFRkVSRU5DRTo1LE5PREVUWVBFX0VOVElUWTo2LE5PREVUWVBFX1BST0NFU1NJTkdfSU5TVFJVQ1RJT046NyxOT0RFVFlQRV9DT01NRU5UOjgsTk9ERVRZUEVfRE9DVU1FTlQ6OSxOT0RFVFlQRV9ET0NVTUVOVFRZUEU6MTAsTk9ERVRZUEVfRE9DVU1FTlRfRlJBR01FTlQ6MTEsTk9ERVRZUEVfTk9UQVRJT046MTIsVE9PTFRJUF9WRVJUSUNBTF9PRkZTRVQ6MTYsREVGQVVMVF9WQUxJRF9DT0xPUjoiIzAwRkYwMCIsREVGQVVMVF9JTlZBTElEX0NPTE9SOiIjRkYwMDAwIixPVVRMSU5FX0hJR0hMSUdIVF9DT0xPUjoiIzAwRkYwMCIsCk9VVExJTkVfSElHSExJR0hUX1NUUk9LRVdJRFRIOjUsSElHSExJR0hUX1NUUk9LRVdJRFRIOjMsSElHSExJR0hUX1NJWkU6MixISUdITElHSFRfT1BBQ0lUWToxMDAsQ1VSU09SX01PVkFCTEVfVkVSVEVYOiJtb3ZlIixDVVJTT1JfTU9WQUJMRV9FREdFOiJtb3ZlIixDVVJTT1JfTEFCRUxfSEFORExFOiJkZWZhdWx0IixDVVJTT1JfVEVSTUlOQUxfSEFORExFOiJwb2ludGVyIixDVVJTT1JfQkVORF9IQU5ETEU6ImNyb3NzaGFpciIsQ1VSU09SX1ZJUlRVQUxfQkVORF9IQU5ETEU6ImNyb3NzaGFpciIsQ1VSU09SX0NPTk5FQ1Q6InBvaW50ZXIiLEhJR0hMSUdIVF9DT0xPUjoiIzAwRkYwMCIsQ09OTkVDVF9UQVJHRVRfQ09MT1I6IiMwMDAwRkYiLElOVkFMSURfQ09OTkVDVF9UQVJHRVRfQ09MT1I6IiNGRjAwMDAiLERST1BfVEFSR0VUX0NPTE9SOiIjMDAwMEZGIixWQUxJRF9DT0xPUjoiIzAwRkYwMCIsSU5WQUxJRF9DT0xPUjoiI0ZGMDAwMCIsRURHRV9TRUxFQ1RJT05fQ09MT1I6IiMwMEZGMDAiLApWRVJURVhfU0VMRUNUSU9OX0NPTE9SOiIjMDBGRjAwIixWRVJURVhfU0VMRUNUSU9OX1NUUk9LRVdJRFRIOjEsRURHRV9TRUxFQ1RJT05fU1RST0tFV0lEVEg6MSxWRVJURVhfU0VMRUNUSU9OX0RBU0hFRDohMCxFREdFX1NFTEVDVElPTl9EQVNIRUQ6ITAsR1VJREVfQ09MT1I6IiNGRjAwMDAiLEdVSURFX1NUUk9LRVdJRFRIOjEsT1VUTElORV9DT0xPUjoiIzAwOTlGRiIsT1VUTElORV9TVFJPS0VXSURUSDpteENsaWVudC5JU19JRT8yOjMsSEFORExFX1NJWkU6NixMQUJFTF9IQU5ETEVfU0laRTo0LEhBTkRMRV9GSUxMQ09MT1I6IiMwMEZGMDAiLEhBTkRMRV9TVFJPS0VDT0xPUjoiYmxhY2siLExBQkVMX0hBTkRMRV9GSUxMQ09MT1I6InllbGxvdyIsQ09OTkVDVF9IQU5ETEVfRklMTENPTE9SOiIjMDAwMEZGIixMT0NLRURfSEFORExFX0ZJTExDT0xPUjoiI0ZGMDAwMCIsT1VUTElORV9IQU5ETEVfRklMTENPTE9SOiIjMDBGRkZGIixPVVRMSU5FX0hBTkRMRV9TVFJPS0VDT0xPUjoiIzAwMzNGRiIsCkRFRkFVTFRfRk9OVEZBTUlMWToiQXJpYWwsSGVsdmV0aWNhIixERUZBVUxUX0ZPTlRTSVpFOjExLERFRkFVTFRfVEVYVF9ESVJFQ1RJT046IiIsTElORV9IRUlHSFQ6MS4yLFdPUkRfV1JBUDoibm9ybWFsIixBQlNPTFVURV9MSU5FX0hFSUdIVDohMSxERUZBVUxUX0ZPTlRTVFlMRTowLERFRkFVTFRfU1RBUlRTSVpFOjQwLERFRkFVTFRfTUFSS0VSU0laRTo2LERFRkFVTFRfSU1BR0VTSVpFOjI0LEVOVElUWV9TRUdNRU5UOjMwLFJFQ1RBTkdMRV9ST1VORElOR19GQUNUT1I6LjE1LExJTkVfQVJDU0laRToyMCxBUlJPV19TUEFDSU5HOjAsQVJST1dfV0lEVEg6MzAsQVJST1dfU0laRTozMCxQQUdFX0ZPUk1BVF9BNF9QT1JUUkFJVDpuZXcgbXhSZWN0YW5nbGUoMCwwLDgyNywxMTY5KSxQQUdFX0ZPUk1BVF9BNF9MQU5EU0NBUEU6bmV3IG14UmVjdGFuZ2xlKDAsMCwxMTY5LDgyNyksUEFHRV9GT1JNQVRfTEVUVEVSX1BPUlRSQUlUOm5ldyBteFJlY3RhbmdsZSgwLDAsODUwLDExMDApLApQQUdFX0ZPUk1BVF9MRVRURVJfTEFORFNDQVBFOm5ldyBteFJlY3RhbmdsZSgwLDAsMTEwMCw4NTApLE5PTkU6Im5vbmUiLFNUWUxFX1BFUklNRVRFUjoicGVyaW1ldGVyIixTVFlMRV9TT1VSQ0VfUE9SVDoic291cmNlUG9ydCIsU1RZTEVfVEFSR0VUX1BPUlQ6InRhcmdldFBvcnQiLFNUWUxFX1BPUlRfQ09OU1RSQUlOVDoicG9ydENvbnN0cmFpbnQiLFNUWUxFX1BPUlRfQ09OU1RSQUlOVF9ST1RBVElPTjoicG9ydENvbnN0cmFpbnRSb3RhdGlvbiIsU1RZTEVfU09VUkNFX1BPUlRfQ09OU1RSQUlOVDoic291cmNlUG9ydENvbnN0cmFpbnQiLFNUWUxFX1RBUkdFVF9QT1JUX0NPTlNUUkFJTlQ6InRhcmdldFBvcnRDb25zdHJhaW50IixTVFlMRV9PUEFDSVRZOiJvcGFjaXR5IixTVFlMRV9GSUxMX09QQUNJVFk6ImZpbGxPcGFjaXR5IixTVFlMRV9TVFJPS0VfT1BBQ0lUWToic3Ryb2tlT3BhY2l0eSIsU1RZTEVfVEVYVF9PUEFDSVRZOiJ0ZXh0T3BhY2l0eSIsU1RZTEVfVEVYVF9ESVJFQ1RJT046InRleHREaXJlY3Rpb24iLApTVFlMRV9PVkVSRkxPVzoib3ZlcmZsb3ciLFNUWUxFX09SVEhPR09OQUw6Im9ydGhvZ29uYWwiLFNUWUxFX0VYSVRfWDoiZXhpdFgiLFNUWUxFX0VYSVRfWToiZXhpdFkiLFNUWUxFX0VYSVRfRFg6ImV4aXREeCIsU1RZTEVfRVhJVF9EWToiZXhpdER5IixTVFlMRV9FWElUX1BFUklNRVRFUjoiZXhpdFBlcmltZXRlciIsU1RZTEVfRU5UUllfWDoiZW50cnlYIixTVFlMRV9FTlRSWV9ZOiJlbnRyeVkiLFNUWUxFX0VOVFJZX0RYOiJlbnRyeUR4IixTVFlMRV9FTlRSWV9EWToiZW50cnlEeSIsU1RZTEVfRU5UUllfUEVSSU1FVEVSOiJlbnRyeVBlcmltZXRlciIsU1RZTEVfV0hJVEVfU1BBQ0U6IndoaXRlU3BhY2UiLFNUWUxFX1JPVEFUSU9OOiJyb3RhdGlvbiIsU1RZTEVfRklMTENPTE9SOiJmaWxsQ29sb3IiLFNUWUxFX1BPSU5URVJfRVZFTlRTOiJwb2ludGVyRXZlbnRzIixTVFlMRV9TV0lNTEFORV9GSUxMQ09MT1I6InN3aW1sYW5lRmlsbENvbG9yIixTVFlMRV9NQVJHSU46Im1hcmdpbiIsClNUWUxFX0dSQURJRU5UQ09MT1I6ImdyYWRpZW50Q29sb3IiLFNUWUxFX0dSQURJRU5UX0RJUkVDVElPTjoiZ3JhZGllbnREaXJlY3Rpb24iLFNUWUxFX1NUUk9LRUNPTE9SOiJzdHJva2VDb2xvciIsU1RZTEVfU0VQQVJBVE9SQ09MT1I6InNlcGFyYXRvckNvbG9yIixTVFlMRV9TVFJPS0VXSURUSDoic3Ryb2tlV2lkdGgiLFNUWUxFX0FMSUdOOiJhbGlnbiIsU1RZTEVfVkVSVElDQUxfQUxJR046InZlcnRpY2FsQWxpZ24iLFNUWUxFX0xBQkVMX1dJRFRIOiJsYWJlbFdpZHRoIixTVFlMRV9MQUJFTF9QT1NJVElPTjoibGFiZWxQb3NpdGlvbiIsU1RZTEVfVkVSVElDQUxfTEFCRUxfUE9TSVRJT046InZlcnRpY2FsTGFiZWxQb3NpdGlvbiIsU1RZTEVfSU1BR0VfQVNQRUNUOiJpbWFnZUFzcGVjdCIsU1RZTEVfSU1BR0VfQUxJR046ImltYWdlQWxpZ24iLFNUWUxFX0lNQUdFX1ZFUlRJQ0FMX0FMSUdOOiJpbWFnZVZlcnRpY2FsQWxpZ24iLFNUWUxFX0dMQVNTOiJnbGFzcyIsU1RZTEVfSU1BR0U6ImltYWdlIiwKU1RZTEVfSU1BR0VfV0lEVEg6ImltYWdlV2lkdGgiLFNUWUxFX0lNQUdFX0hFSUdIVDoiaW1hZ2VIZWlnaHQiLFNUWUxFX0lNQUdFX0JBQ0tHUk9VTkQ6ImltYWdlQmFja2dyb3VuZCIsU1RZTEVfSU1BR0VfQk9SREVSOiJpbWFnZUJvcmRlciIsU1RZTEVfRkxJUEg6ImZsaXBIIixTVFlMRV9GTElQVjoiZmxpcFYiLFNUWUxFX05PTEFCRUw6Im5vTGFiZWwiLFNUWUxFX05PRURHRVNUWUxFOiJub0VkZ2VTdHlsZSIsU1RZTEVfTEFCRUxfQkFDS0dST1VORENPTE9SOiJsYWJlbEJhY2tncm91bmRDb2xvciIsU1RZTEVfTEFCRUxfQk9SREVSQ09MT1I6ImxhYmVsQm9yZGVyQ29sb3IiLFNUWUxFX0xBQkVMX1BBRERJTkc6ImxhYmVsUGFkZGluZyIsU1RZTEVfSU5ESUNBVE9SX1NIQVBFOiJpbmRpY2F0b3JTaGFwZSIsU1RZTEVfSU5ESUNBVE9SX0lNQUdFOiJpbmRpY2F0b3JJbWFnZSIsU1RZTEVfSU5ESUNBVE9SX0NPTE9SOiJpbmRpY2F0b3JDb2xvciIsU1RZTEVfSU5ESUNBVE9SX1NUUk9LRUNPTE9SOiJpbmRpY2F0b3JTdHJva2VDb2xvciIsClNUWUxFX0lORElDQVRPUl9HUkFESUVOVENPTE9SOiJpbmRpY2F0b3JHcmFkaWVudENvbG9yIixTVFlMRV9JTkRJQ0FUT1JfU1BBQ0lORzoiaW5kaWNhdG9yU3BhY2luZyIsU1RZTEVfSU5ESUNBVE9SX1dJRFRIOiJpbmRpY2F0b3JXaWR0aCIsU1RZTEVfSU5ESUNBVE9SX0hFSUdIVDoiaW5kaWNhdG9ySGVpZ2h0IixTVFlMRV9JTkRJQ0FUT1JfRElSRUNUSU9OOiJpbmRpY2F0b3JEaXJlY3Rpb24iLFNUWUxFX1NIQURPVzoic2hhZG93IixTVFlMRV9TRUdNRU5UOiJzZWdtZW50IixTVFlMRV9FTkRBUlJPVzoiZW5kQXJyb3ciLFNUWUxFX1NUQVJUQVJST1c6InN0YXJ0QXJyb3ciLFNUWUxFX0VORFNJWkU6ImVuZFNpemUiLFNUWUxFX1NUQVJUU0laRToic3RhcnRTaXplIixTVFlMRV9TV0lNTEFORV9MSU5FOiJzd2ltbGFuZUxpbmUiLFNUWUxFX0VOREZJTEw6ImVuZEZpbGwiLFNUWUxFX1NUQVJURklMTDoic3RhcnRGaWxsIixTVFlMRV9EQVNIRUQ6ImRhc2hlZCIsU1RZTEVfREFTSF9QQVRURVJOOiJkYXNoUGF0dGVybiIsClNUWUxFX0ZJWF9EQVNIOiJmaXhEYXNoIixTVFlMRV9ST1VOREVEOiJyb3VuZGVkIixTVFlMRV9DVVJWRUQ6ImN1cnZlZCIsU1RZTEVfQVJDU0laRToiYXJjU2l6ZSIsU1RZTEVfQUJTT0xVVEVfQVJDU0laRToiYWJzb2x1dGVBcmNTaXplIixTVFlMRV9TT1VSQ0VfUEVSSU1FVEVSX1NQQUNJTkc6InNvdXJjZVBlcmltZXRlclNwYWNpbmciLFNUWUxFX1RBUkdFVF9QRVJJTUVURVJfU1BBQ0lORzoidGFyZ2V0UGVyaW1ldGVyU3BhY2luZyIsU1RZTEVfUEVSSU1FVEVSX1NQQUNJTkc6InBlcmltZXRlclNwYWNpbmciLFNUWUxFX1NQQUNJTkc6InNwYWNpbmciLFNUWUxFX1NQQUNJTkdfVE9QOiJzcGFjaW5nVG9wIixTVFlMRV9TUEFDSU5HX0xFRlQ6InNwYWNpbmdMZWZ0IixTVFlMRV9TUEFDSU5HX0JPVFRPTToic3BhY2luZ0JvdHRvbSIsU1RZTEVfU1BBQ0lOR19SSUdIVDoic3BhY2luZ1JpZ2h0IixTVFlMRV9IT1JJWk9OVEFMOiJob3Jpem9udGFsIixTVFlMRV9ESVJFQ1RJT046ImRpcmVjdGlvbiIsClNUWUxFX0FOQ0hPUl9QT0lOVF9ESVJFQ1RJT046ImFuY2hvclBvaW50RGlyZWN0aW9uIixTVFlMRV9FTEJPVzoiZWxib3ciLFNUWUxFX0ZPTlRDT0xPUjoiZm9udENvbG9yIixTVFlMRV9GT05URkFNSUxZOiJmb250RmFtaWx5IixTVFlMRV9GT05UU0laRToiZm9udFNpemUiLFNUWUxFX0ZPTlRTVFlMRToiZm9udFN0eWxlIixTVFlMRV9BU1BFQ1Q6ImFzcGVjdCIsU1RZTEVfQVVUT1NJWkU6ImF1dG9zaXplIixTVFlMRV9GT0xEQUJMRToiZm9sZGFibGUiLFNUWUxFX0VESVRBQkxFOiJlZGl0YWJsZSIsU1RZTEVfQkFDS0dST1VORF9PVVRMSU5FOiJiYWNrZ3JvdW5kT3V0bGluZSIsU1RZTEVfQkVOREFCTEU6ImJlbmRhYmxlIixTVFlMRV9NT1ZBQkxFOiJtb3ZhYmxlIixTVFlMRV9SRVNJWkFCTEU6InJlc2l6YWJsZSIsU1RZTEVfUkVTSVpFX1dJRFRIOiJyZXNpemVXaWR0aCIsU1RZTEVfUkVTSVpFX0hFSUdIVDoicmVzaXplSGVpZ2h0IixTVFlMRV9ST1RBVEFCTEU6InJvdGF0YWJsZSIsClNUWUxFX0NMT05FQUJMRToiY2xvbmVhYmxlIixTVFlMRV9ERUxFVEFCTEU6ImRlbGV0YWJsZSIsU1RZTEVfU0hBUEU6InNoYXBlIixTVFlMRV9FREdFOiJlZGdlU3R5bGUiLFNUWUxFX0pFVFRZX1NJWkU6ImpldHR5U2l6ZSIsU1RZTEVfU09VUkNFX0pFVFRZX1NJWkU6InNvdXJjZUpldHR5U2l6ZSIsU1RZTEVfVEFSR0VUX0pFVFRZX1NJWkU6InRhcmdldEpldHR5U2l6ZSIsU1RZTEVfTE9PUDoibG9vcFN0eWxlIixTVFlMRV9PUlRIT0dPTkFMX0xPT1A6Im9ydGhvZ29uYWxMb29wIixTVFlMRV9ST1VUSU5HX0NFTlRFUl9YOiJyb3V0aW5nQ2VudGVyWCIsU1RZTEVfUk9VVElOR19DRU5URVJfWToicm91dGluZ0NlbnRlclkiLEZPTlRfQk9MRDoxLEZPTlRfSVRBTElDOjIsRk9OVF9VTkRFUkxJTkU6NCxGT05UX1NUUklLRVRIUk9VR0g6OCxTSEFQRV9SRUNUQU5HTEU6InJlY3RhbmdsZSIsU0hBUEVfRUxMSVBTRToiZWxsaXBzZSIsU0hBUEVfRE9VQkxFX0VMTElQU0U6ImRvdWJsZUVsbGlwc2UiLApTSEFQRV9SSE9NQlVTOiJyaG9tYnVzIixTSEFQRV9MSU5FOiJsaW5lIixTSEFQRV9JTUFHRToiaW1hZ2UiLFNIQVBFX0FSUk9XOiJhcnJvdyIsU0hBUEVfQVJST1dfQ09OTkVDVE9SOiJhcnJvd0Nvbm5lY3RvciIsU0hBUEVfTEFCRUw6ImxhYmVsIixTSEFQRV9DWUxJTkRFUjoiY3lsaW5kZXIiLFNIQVBFX1NXSU1MQU5FOiJzd2ltbGFuZSIsU0hBUEVfQ09OTkVDVE9SOiJjb25uZWN0b3IiLFNIQVBFX0FDVE9SOiJhY3RvciIsU0hBUEVfQ0xPVUQ6ImNsb3VkIixTSEFQRV9UUklBTkdMRToidHJpYW5nbGUiLFNIQVBFX0hFWEFHT046ImhleGFnb24iLEFSUk9XX0NMQVNTSUM6ImNsYXNzaWMiLEFSUk9XX0NMQVNTSUNfVEhJTjoiY2xhc3NpY1RoaW4iLEFSUk9XX0JMT0NLOiJibG9jayIsQVJST1dfQkxPQ0tfVEhJTjoiYmxvY2tUaGluIixBUlJPV19PUEVOOiJvcGVuIixBUlJPV19PUEVOX1RISU46Im9wZW5UaGluIixBUlJPV19PVkFMOiJvdmFsIixBUlJPV19ESUFNT05EOiJkaWFtb25kIiwKQVJST1dfRElBTU9ORF9USElOOiJkaWFtb25kVGhpbiIsQUxJR05fTEVGVDoibGVmdCIsQUxJR05fQ0VOVEVSOiJjZW50ZXIiLEFMSUdOX1JJR0hUOiJyaWdodCIsQUxJR05fVE9QOiJ0b3AiLEFMSUdOX01JRERMRToibWlkZGxlIixBTElHTl9CT1RUT006ImJvdHRvbSIsRElSRUNUSU9OX05PUlRIOiJub3J0aCIsRElSRUNUSU9OX1NPVVRIOiJzb3V0aCIsRElSRUNUSU9OX0VBU1Q6ImVhc3QiLERJUkVDVElPTl9XRVNUOiJ3ZXN0IixURVhUX0RJUkVDVElPTl9ERUZBVUxUOiIiLFRFWFRfRElSRUNUSU9OX0FVVE86ImF1dG8iLFRFWFRfRElSRUNUSU9OX0xUUjoibHRyIixURVhUX0RJUkVDVElPTl9SVEw6InJ0bCIsRElSRUNUSU9OX01BU0tfTk9ORTowLERJUkVDVElPTl9NQVNLX1dFU1Q6MSxESVJFQ1RJT05fTUFTS19OT1JUSDoyLERJUkVDVElPTl9NQVNLX1NPVVRIOjQsRElSRUNUSU9OX01BU0tfRUFTVDo4LERJUkVDVElPTl9NQVNLX0FMTDoxNSxFTEJPV19WRVJUSUNBTDoidmVydGljYWwiLApFTEJPV19IT1JJWk9OVEFMOiJob3Jpem9udGFsIixFREdFU1RZTEVfRUxCT1c6ImVsYm93RWRnZVN0eWxlIixFREdFU1RZTEVfRU5USVRZX1JFTEFUSU9OOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsRURHRVNUWUxFX0xPT1A6Imxvb3BFZGdlU3R5bGUiLEVER0VTVFlMRV9TSURFVE9TSURFOiJzaWRlVG9TaWRlRWRnZVN0eWxlIixFREdFU1RZTEVfVE9QVE9CT1RUT006InRvcFRvQm90dG9tRWRnZVN0eWxlIixFREdFU1RZTEVfT1JUSE9HT05BTDoib3J0aG9nb25hbEVkZ2VTdHlsZSIsRURHRVNUWUxFX1NFR01FTlQ6InNlZ21lbnRFZGdlU3R5bGUiLFBFUklNRVRFUl9FTExJUFNFOiJlbGxpcHNlUGVyaW1ldGVyIixQRVJJTUVURVJfUkVDVEFOR0xFOiJyZWN0YW5nbGVQZXJpbWV0ZXIiLFBFUklNRVRFUl9SSE9NQlVTOiJyaG9tYnVzUGVyaW1ldGVyIixQRVJJTUVURVJfSEVYQUdPTjoiaGV4YWdvblBlcmltZXRlciIsUEVSSU1FVEVSX1RSSUFOR0xFOiJ0cmlhbmdsZVBlcmltZXRlciJ9OwpmdW5jdGlvbiBteEV2ZW50T2JqZWN0KGEpe3RoaXMubmFtZT1hO3RoaXMucHJvcGVydGllcz1bXTtmb3IodmFyIGI9MTtiPGFyZ3VtZW50cy5sZW5ndGg7Yis9MiludWxsIT1hcmd1bWVudHNbYisxXSYmKHRoaXMucHJvcGVydGllc1thcmd1bWVudHNbYl1dPWFyZ3VtZW50c1tiKzFdKX1teEV2ZW50T2JqZWN0LnByb3RvdHlwZS5uYW1lPW51bGw7bXhFdmVudE9iamVjdC5wcm90b3R5cGUucHJvcGVydGllcz1udWxsO214RXZlbnRPYmplY3QucHJvdG90eXBlLmNvbnN1bWVkPSExO214RXZlbnRPYmplY3QucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfTtteEV2ZW50T2JqZWN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0aWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcGVydGllc307bXhFdmVudE9iamVjdC5wcm90b3R5cGUuZ2V0UHJvcGVydHk9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHJvcGVydGllc1thXX07Cm14RXZlbnRPYmplY3QucHJvdG90eXBlLmlzQ29uc3VtZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lZH07bXhFdmVudE9iamVjdC5wcm90b3R5cGUuY29uc3VtZT1mdW5jdGlvbigpe3RoaXMuY29uc3VtZWQ9ITB9O2Z1bmN0aW9uIG14TW91c2VFdmVudChhLGIpe3RoaXMuZXZ0PWE7dGhpcy5zb3VyY2VTdGF0ZT10aGlzLnN0YXRlPWJ9bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5jb25zdW1lZD0hMTtteE1vdXNlRXZlbnQucHJvdG90eXBlLmV2dD1udWxsO214TW91c2VFdmVudC5wcm90b3R5cGUuZ3JhcGhYPW51bGw7bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5ncmFwaFk9bnVsbDtteE1vdXNlRXZlbnQucHJvdG90eXBlLnN0YXRlPW51bGw7bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5zb3VyY2VTdGF0ZT1udWxsO214TW91c2VFdmVudC5wcm90b3R5cGUuZ2V0RXZlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldnR9OwpteE1vdXNlRXZlbnQucHJvdG90eXBlLmdldFNvdXJjZT1mdW5jdGlvbigpe3JldHVybiBteEV2ZW50LmdldFNvdXJjZSh0aGlzLmV2dCl9O214TW91c2VFdmVudC5wcm90b3R5cGUuaXNTb3VyY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/bXhVdGlscy5pc0FuY2VzdG9yTm9kZShhLm5vZGUsdGhpcy5nZXRTb3VyY2UoKSk6ITF9O214TW91c2VFdmVudC5wcm90b3R5cGUuZ2V0WD1mdW5jdGlvbigpe3JldHVybiBteEV2ZW50LmdldENsaWVudFgodGhpcy5nZXRFdmVudCgpKX07bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXRZPWZ1bmN0aW9uKCl7cmV0dXJuIG14RXZlbnQuZ2V0Q2xpZW50WSh0aGlzLmdldEV2ZW50KCkpfTtteE1vdXNlRXZlbnQucHJvdG90eXBlLmdldEdyYXBoWD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoWH07bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5nZXRHcmFwaFk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaFl9OwpteE1vdXNlRXZlbnQucHJvdG90eXBlLmdldFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGV9O214TW91c2VFdmVudC5wcm90b3R5cGUuZ2V0Q2VsbD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U3RhdGUoKTtyZXR1cm4gbnVsbCE9YT9hLmNlbGw6bnVsbH07bXhNb3VzZUV2ZW50LnByb3RvdHlwZS5pc1BvcHVwVHJpZ2dlcj1mdW5jdGlvbigpe3JldHVybiBteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKHRoaXMuZ2V0RXZlbnQoKSl9O214TW91c2VFdmVudC5wcm90b3R5cGUuaXNDb25zdW1lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN1bWVkfTsKbXhNb3VzZUV2ZW50LnByb3RvdHlwZS5jb25zdW1lPWZ1bmN0aW9uKGEpeyhudWxsIT1hP2E6bnVsbCE9dGhpcy5ldnQudG91Y2hlc3x8bXhFdmVudC5pc01vdXNlRXZlbnQodGhpcy5ldnQpKSYmdGhpcy5ldnQucHJldmVudERlZmF1bHQmJnRoaXMuZXZ0LnByZXZlbnREZWZhdWx0KCk7bXhDbGllbnQuSVNfSUUmJih0aGlzLmV2dC5yZXR1cm5WYWx1ZT0hMCk7dGhpcy5jb25zdW1lZD0hMH07ZnVuY3Rpb24gbXhFdmVudFNvdXJjZShhKXt0aGlzLnNldEV2ZW50U291cmNlKGEpfW14RXZlbnRTb3VyY2UucHJvdG90eXBlLmV2ZW50TGlzdGVuZXJzPW51bGw7bXhFdmVudFNvdXJjZS5wcm90b3R5cGUuZXZlbnRzRW5hYmxlZD0hMDtteEV2ZW50U291cmNlLnByb3RvdHlwZS5ldmVudFNvdXJjZT1udWxsO214RXZlbnRTb3VyY2UucHJvdG90eXBlLmlzRXZlbnRzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV2ZW50c0VuYWJsZWR9OwpteEV2ZW50U291cmNlLnByb3RvdHlwZS5zZXRFdmVudHNFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZXZlbnRzRW5hYmxlZD1hfTtteEV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV2ZW50U291cmNlfTtteEV2ZW50U291cmNlLnByb3RvdHlwZS5zZXRFdmVudFNvdXJjZT1mdW5jdGlvbihhKXt0aGlzLmV2ZW50U291cmNlPWF9O214RXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKGEsYil7bnVsbD09dGhpcy5ldmVudExpc3RlbmVycyYmKHRoaXMuZXZlbnRMaXN0ZW5lcnM9W10pO3RoaXMuZXZlbnRMaXN0ZW5lcnMucHVzaChhKTt0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goYil9OwpteEV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmV2ZW50TGlzdGVuZXJzKWZvcih2YXIgYj0wO2I8dGhpcy5ldmVudExpc3RlbmVycy5sZW5ndGg7KXRoaXMuZXZlbnRMaXN0ZW5lcnNbYisxXT09YT90aGlzLmV2ZW50TGlzdGVuZXJzLnNwbGljZShiLDIpOmIrPTJ9OwpteEV2ZW50U291cmNlLnByb3RvdHlwZS5maXJlRXZlbnQ9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLmV2ZW50TGlzdGVuZXJzJiZ0aGlzLmlzRXZlbnRzRW5hYmxlZCgpKXtudWxsPT1hJiYoYT1uZXcgbXhFdmVudE9iamVjdCk7bnVsbD09YiYmKGI9dGhpcy5nZXRFdmVudFNvdXJjZSgpKTtudWxsPT1iJiYoYj10aGlzKTtmb3IodmFyIGM9W2IsYV0sZD0wO2Q8dGhpcy5ldmVudExpc3RlbmVycy5sZW5ndGg7ZCs9Mil7dmFyIGU9dGhpcy5ldmVudExpc3RlbmVyc1tkXTtudWxsIT1lJiZlIT1hLmdldE5hbWUoKXx8dGhpcy5ldmVudExpc3RlbmVyc1tkKzFdLmFwcGx5KHRoaXMsYyl9fX07CnZhciBteEV2ZW50PXthZGRMaXN0ZW5lcjpmdW5jdGlvbigpe3JldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcj9mdW5jdGlvbihhLGIsYyl7YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSk7bnVsbD09YS5teExpc3RlbmVyTGlzdCYmKGEubXhMaXN0ZW5lckxpc3Q9W10pO2EubXhMaXN0ZW5lckxpc3QucHVzaCh7bmFtZTpiLGY6Y30pfTpmdW5jdGlvbihhLGIsYyl7YS5hdHRhY2hFdmVudCgib24iK2IsYyk7bnVsbD09YS5teExpc3RlbmVyTGlzdCYmKGEubXhMaXN0ZW5lckxpc3Q9W10pO2EubXhMaXN0ZW5lckxpc3QucHVzaCh7bmFtZTpiLGY6Y30pfX0oKSxyZW1vdmVMaXN0ZW5lcjpmdW5jdGlvbigpe3ZhciBhPWZ1bmN0aW9uKGEsYyxkKXtpZihudWxsIT1hLm14TGlzdGVuZXJMaXN0KXtjPWEubXhMaXN0ZW5lckxpc3QubGVuZ3RoO2Zvcih2YXIgYj0wO2I8YztiKyspaWYoYS5teExpc3RlbmVyTGlzdFtiXS5mPT1kKXthLm14TGlzdGVuZXJMaXN0LnNwbGljZShiLDEpO2JyZWFrfTA9PQphLm14TGlzdGVuZXJMaXN0Lmxlbmd0aCYmKGEubXhMaXN0ZW5lckxpc3Q9bnVsbCl9fTtyZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXI/ZnVuY3Rpb24oYixjLGQpe2IucmVtb3ZlRXZlbnRMaXN0ZW5lcihjLGQsITEpO2EoYixjLGQpfTpmdW5jdGlvbihiLGMsZCl7Yi5kZXRhY2hFdmVudCgib24iK2MsZCk7YShiLGMsZCl9fSgpLHJlbW92ZUFsbExpc3RlbmVyczpmdW5jdGlvbihhKXt2YXIgYj1hLm14TGlzdGVuZXJMaXN0O2lmKG51bGwhPWIpZm9yKDswPGIubGVuZ3RoOyl7dmFyIGM9YlswXTtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGEsYy5uYW1lLGMuZil9fSxhZGRHZXN0dXJlTGlzdGVuZXJzOmZ1bmN0aW9uKGEsYixjLGQpe251bGwhPWImJm14RXZlbnQuYWRkTGlzdGVuZXIoYSxteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVyZG93biI6Im1vdXNlZG93biIsYik7bnVsbCE9YyYmbXhFdmVudC5hZGRMaXN0ZW5lcihhLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJtb3ZlIjoKIm1vdXNlbW92ZSIsYyk7bnVsbCE9ZCYmbXhFdmVudC5hZGRMaXN0ZW5lcihhLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJ1cCI6Im1vdXNldXAiLGQpOyFteENsaWVudC5JU19QT0lOVEVSJiZteENsaWVudC5JU19UT1VDSCYmKG51bGwhPWImJm14RXZlbnQuYWRkTGlzdGVuZXIoYSwidG91Y2hzdGFydCIsYiksbnVsbCE9YyYmbXhFdmVudC5hZGRMaXN0ZW5lcihhLCJ0b3VjaG1vdmUiLGMpLG51bGwhPWQmJm14RXZlbnQuYWRkTGlzdGVuZXIoYSwidG91Y2hlbmQiLGQpKX0scmVtb3ZlR2VzdHVyZUxpc3RlbmVyczpmdW5jdGlvbihhLGIsYyxkKXtudWxsIT1iJiZteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGEsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcmRvd24iOiJtb3VzZWRvd24iLGIpO251bGwhPWMmJm14RXZlbnQucmVtb3ZlTGlzdGVuZXIoYSxteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVybW92ZSI6Im1vdXNlbW92ZSIsYyk7bnVsbCE9ZCYmbXhFdmVudC5yZW1vdmVMaXN0ZW5lcihhLApteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVydXAiOiJtb3VzZXVwIixkKTshbXhDbGllbnQuSVNfUE9JTlRFUiYmbXhDbGllbnQuSVNfVE9VQ0gmJihudWxsIT1iJiZteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGEsInRvdWNoc3RhcnQiLGIpLG51bGwhPWMmJm14RXZlbnQucmVtb3ZlTGlzdGVuZXIoYSwidG91Y2htb3ZlIixjKSxudWxsIT1kJiZteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGEsInRvdWNoZW5kIixkKSl9LHJlZGlyZWN0TW91c2VFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7dmFyIGs9ZnVuY3Rpb24oYSl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIGM/YyhhKTpjfTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYSxmdW5jdGlvbihhKXtudWxsIT1kP2QoYSk6bXhFdmVudC5pc0NvbnN1bWVkKGEpfHxiLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGEsayhhKSkpfSxmdW5jdGlvbihhKXtudWxsIT1lP2UoYSk6bXhFdmVudC5pc0NvbnN1bWVkKGEpfHwKYi5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChhLGsoYSkpKX0sZnVuY3Rpb24oYSl7bnVsbCE9Zj9mKGEpOm14RXZlbnQuaXNDb25zdW1lZChhKXx8Yi5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoYSxrKGEpKSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImRibGNsaWNrIixmdW5jdGlvbihhKXtpZihudWxsIT1nKWcoYSk7ZWxzZSBpZighbXhFdmVudC5pc0NvbnN1bWVkKGEpKXt2YXIgYz1rKGEpO2IuZGJsQ2xpY2soYSxudWxsIT1jP2MuY2VsbDpudWxsKX19KX0scmVsZWFzZTpmdW5jdGlvbihhKXt0cnl7aWYobnVsbCE9YSl7bXhFdmVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoYSk7dmFyIGI9YS5jaGlsZE5vZGVzO2lmKG51bGwhPWIpe3ZhciBjPWIubGVuZ3RoO2ZvcihhPTA7YTxjO2ErPTEpbXhFdmVudC5yZWxlYXNlKGJbYV0pfX19Y2F0Y2goZCl7fX0sYWRkTW91c2VXaGVlbExpc3RlbmVyOmZ1bmN0aW9uKGEsCmIpe2lmKG51bGwhPWEpe2I9bnVsbCE9Yj9iOndpbmRvdztpZihteENsaWVudC5JU19TRiYmIW14Q2xpZW50LklTX1RPVUNIKXt2YXIgYz0xO214RXZlbnQuYWRkTGlzdGVuZXIoYiwiZ2VzdHVyZXN0YXJ0IixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSk7Yz0xfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJnZXN0dXJlY2hhbmdlIixmdW5jdGlvbihiKXtteEV2ZW50LmNvbnN1bWUoYik7dmFyIGQ9Yy1iLnNjYWxlOy4yPE1hdGguYWJzKGQpJiYoYShiLDA+ZCwhMCksYz1iLnNjYWxlKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYiwiZ2VzdHVyZWVuZCIsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpfSl9bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJ3aGVlbCIsZnVuY3Rpb24oYil7bnVsbD09YiYmKGI9d2luZG93LmV2ZW50KTtiLmN0cmxLZXkmJmIucHJldmVudERlZmF1bHQoKTsoLjU8TWF0aC5hYnMoYi5kZWx0YVgpfHwuNTxNYXRoLmFicyhiLmRlbHRhWSkpJiZhKGIsMD09CmIuZGVsdGFZPzA8LWIuZGVsdGFYOjA8LWIuZGVsdGFZKX0pfX0sZGlzYWJsZUNvbnRleHRNZW51OmZ1bmN0aW9uKGEpe214RXZlbnQuYWRkTGlzdGVuZXIoYSwiY29udGV4dG1lbnUiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQmJmEucHJldmVudERlZmF1bHQoKTtyZXR1cm4hMX0pfSxnZXRTb3VyY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEuc3JjRWxlbWVudD9hLnNyY0VsZW1lbnQ6YS50YXJnZXR9LGlzQ29uc3VtZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEuaXNDb25zdW1lZCYmYS5pc0NvbnN1bWVkfSxpc1RvdWNoRXZlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEucG9pbnRlclR5cGU/InRvdWNoIj09YS5wb2ludGVyVHlwZXx8YS5wb2ludGVyVHlwZT09PWEuTVNQT0lOVEVSX1RZUEVfVE9VQ0g6bnVsbCE9YS5tb3pJbnB1dFNvdXJjZT81PT1hLm1veklucHV0U291cmNlOjA9PWEudHlwZS5pbmRleE9mKCJ0b3VjaCIpfSxpc1BlbkV2ZW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT0KYS5wb2ludGVyVHlwZT8icGVuIj09YS5wb2ludGVyVHlwZXx8YS5wb2ludGVyVHlwZT09PWEuTVNQT0lOVEVSX1RZUEVfUEVOOm51bGwhPWEubW96SW5wdXRTb3VyY2U/Mj09YS5tb3pJbnB1dFNvdXJjZTowPT1hLnR5cGUuaW5kZXhPZigicGVuIil9LGlzTXVsdGlUb3VjaEV2ZW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnR5cGUmJjA9PWEudHlwZS5pbmRleE9mKCJ0b3VjaCIpJiZudWxsIT1hLnRvdWNoZXMmJjE8YS50b3VjaGVzLmxlbmd0aH0saXNNb3VzZUV2ZW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnBvaW50ZXJUeXBlPyJtb3VzZSI9PWEucG9pbnRlclR5cGV8fGEucG9pbnRlclR5cGU9PT1hLk1TUE9JTlRFUl9UWVBFX01PVVNFOm51bGwhPWEubW96SW5wdXRTb3VyY2U/MT09YS5tb3pJbnB1dFNvdXJjZTowPT1hLnR5cGUuaW5kZXhPZigibW91c2UiKX0saXNMZWZ0TW91c2VCdXR0b246ZnVuY3Rpb24oYSl7cmV0dXJuImJ1dHRvbnMiaW4gYSYmKCJtb3VzZWRvd24iPT0KYS50eXBlfHwibW91c2Vtb3ZlIj09YS50eXBlKT8xPT1hLmJ1dHRvbnM6IndoaWNoImluIGE/MT09PWEud2hpY2g6MT09PWEuYnV0dG9ufSxpc01pZGRsZU1vdXNlQnV0dG9uOmZ1bmN0aW9uKGEpe3JldHVybiJ3aGljaCJpbiBhPzI9PT1hLndoaWNoOjQ9PT1hLmJ1dHRvbn0saXNSaWdodE1vdXNlQnV0dG9uOmZ1bmN0aW9uKGEpe3JldHVybiJ3aGljaCJpbiBhPzM9PT1hLndoaWNoOjI9PT1hLmJ1dHRvbn0saXNQb3B1cFRyaWdnZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNSaWdodE1vdXNlQnV0dG9uKGEpfHxteENsaWVudC5JU19NQUMmJm14RXZlbnQuaXNDb250cm9sRG93bihhKSYmIW14RXZlbnQuaXNTaGlmdERvd24oYSkmJiFteEV2ZW50LmlzTWV0YURvd24oYSkmJiFteEV2ZW50LmlzQWx0RG93bihhKX0saXNTaGlmdERvd246ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5zaGlmdEtleTohMX0saXNBbHREb3duOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hPwphLmFsdEtleTohMX0saXNDb250cm9sRG93bjpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmN0cmxLZXk6ITF9LGlzTWV0YURvd246ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5tZXRhS2V5OiExfSxnZXRNYWluRXZlbnQ6ZnVuY3Rpb24oYSl7InRvdWNoc3RhcnQiIT1hLnR5cGUmJiJ0b3VjaG1vdmUiIT1hLnR5cGV8fG51bGw9PWEudG91Y2hlc3x8bnVsbD09YS50b3VjaGVzWzBdPyJ0b3VjaGVuZCI9PWEudHlwZSYmbnVsbCE9YS5jaGFuZ2VkVG91Y2hlcyYmbnVsbCE9YS5jaGFuZ2VkVG91Y2hlc1swXSYmKGE9YS5jaGFuZ2VkVG91Y2hlc1swXSk6YT1hLnRvdWNoZXNbMF07cmV0dXJuIGF9LGdldENsaWVudFg6ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuZ2V0TWFpbkV2ZW50KGEpLmNsaWVudFh9LGdldENsaWVudFk6ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuZ2V0TWFpbkV2ZW50KGEpLmNsaWVudFl9LGNvbnN1bWU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9CmM/YzohMDtpZihudWxsIT1iP2I6MSlhLnByZXZlbnREZWZhdWx0PyhjJiZhLnN0b3BQcm9wYWdhdGlvbigpLGEucHJldmVudERlZmF1bHQoKSk6YyYmKGEuY2FuY2VsQnViYmxlPSEwKTthLmlzQ29uc3VtZWQ9ITA7YS5wcmV2ZW50RGVmYXVsdHx8KGEucmV0dXJuVmFsdWU9ITEpfSxMQUJFTF9IQU5ETEU6LTEsUk9UQVRJT05fSEFORExFOi0yLENVU1RPTV9IQU5ETEU6LTEwMCxWSVJUVUFMX0hBTkRMRTotMUU1LE1PVVNFX0RPV046Im1vdXNlRG93biIsTU9VU0VfTU9WRToibW91c2VNb3ZlIixNT1VTRV9VUDoibW91c2VVcCIsQUNUSVZBVEU6ImFjdGl2YXRlIixSRVNJWkVfU1RBUlQ6InJlc2l6ZVN0YXJ0IixSRVNJWkU6InJlc2l6ZSIsUkVTSVpFX0VORDoicmVzaXplRW5kIixNT1ZFX1NUQVJUOiJtb3ZlU3RhcnQiLE1PVkU6Im1vdmUiLE1PVkVfRU5EOiJtb3ZlRW5kIixQQU5fU1RBUlQ6InBhblN0YXJ0IixQQU46InBhbiIsUEFOX0VORDoicGFuRW5kIixNSU5JTUlaRToibWluaW1pemUiLApOT1JNQUxJWkU6Im5vcm1hbGl6ZSIsTUFYSU1JWkU6Im1heGltaXplIixISURFOiJoaWRlIixTSE9XOiJzaG93IixDTE9TRToiY2xvc2UiLERFU1RST1k6ImRlc3Ryb3kiLFJFRlJFU0g6InJlZnJlc2giLFNJWkU6InNpemUiLFNFTEVDVDoic2VsZWN0IixGSVJFRDoiZmlyZWQiLEZJUkVfTU9VU0VfRVZFTlQ6ImZpcmVNb3VzZUV2ZW50IixHRVNUVVJFOiJnZXN0dXJlIixUQVBfQU5EX0hPTEQ6InRhcEFuZEhvbGQiLEdFVDoiZ2V0IixSRUNFSVZFOiJyZWNlaXZlIixDT05ORUNUOiJjb25uZWN0IixESVNDT05ORUNUOiJkaXNjb25uZWN0IixTVVNQRU5EOiJzdXNwZW5kIixSRVNVTUU6InJlc3VtZSIsTUFSSzoibWFyayIsUk9PVDoicm9vdCIsUE9TVDoicG9zdCIsT1BFTjoib3BlbiIsU0FWRToic2F2ZSIsQkVGT1JFX0FERF9WRVJURVg6ImJlZm9yZUFkZFZlcnRleCIsQUREX1ZFUlRFWDoiYWRkVmVydGV4IixBRlRFUl9BRERfVkVSVEVYOiJhZnRlckFkZFZlcnRleCIsRE9ORToiZG9uZSIsCkVYRUNVVEU6ImV4ZWN1dGUiLEVYRUNVVEVEOiJleGVjdXRlZCIsQkVHSU5fVVBEQVRFOiJiZWdpblVwZGF0ZSIsU1RBUlRfRURJVDoic3RhcnRFZGl0IixFTkRfVVBEQVRFOiJlbmRVcGRhdGUiLEVORF9FRElUOiJlbmRFZGl0IixCRUZPUkVfVU5ETzoiYmVmb3JlVW5kbyIsVU5ETzoidW5kbyIsUkVETzoicmVkbyIsQ0hBTkdFOiJjaGFuZ2UiLE5PVElGWToibm90aWZ5IixMQVlPVVRfQ0VMTFM6ImxheW91dENlbGxzIixDTElDSzoiY2xpY2siLFNDQUxFOiJzY2FsZSIsVFJBTlNMQVRFOiJ0cmFuc2xhdGUiLFNDQUxFX0FORF9UUkFOU0xBVEU6InNjYWxlQW5kVHJhbnNsYXRlIixVUDoidXAiLERPV046ImRvd24iLEFERDoiYWRkIixSRU1PVkU6InJlbW92ZSIsQ0xFQVI6ImNsZWFyIixBRERfQ0VMTFM6ImFkZENlbGxzIixDRUxMU19BRERFRDoiY2VsbHNBZGRlZCIsTU9WRV9DRUxMUzoibW92ZUNlbGxzIixDRUxMU19NT1ZFRDoiY2VsbHNNb3ZlZCIsUkVTSVpFX0NFTExTOiJyZXNpemVDZWxscyIsCkNFTExTX1JFU0laRUQ6ImNlbGxzUmVzaXplZCIsVE9HR0xFX0NFTExTOiJ0b2dnbGVDZWxscyIsQ0VMTFNfVE9HR0xFRDoiY2VsbHNUb2dnbGVkIixPUkRFUl9DRUxMUzoib3JkZXJDZWxscyIsQ0VMTFNfT1JERVJFRDoiY2VsbHNPcmRlcmVkIixSRU1PVkVfQ0VMTFM6InJlbW92ZUNlbGxzIixDRUxMU19SRU1PVkVEOiJjZWxsc1JlbW92ZWQiLEdST1VQX0NFTExTOiJncm91cENlbGxzIixVTkdST1VQX0NFTExTOiJ1bmdyb3VwQ2VsbHMiLFJFTU9WRV9DRUxMU19GUk9NX1BBUkVOVDoicmVtb3ZlQ2VsbHNGcm9tUGFyZW50IixGT0xEX0NFTExTOiJmb2xkQ2VsbHMiLENFTExTX0ZPTERFRDoiY2VsbHNGb2xkZWQiLEFMSUdOX0NFTExTOiJhbGlnbkNlbGxzIixMQUJFTF9DSEFOR0VEOiJsYWJlbENoYW5nZWQiLENPTk5FQ1RfQ0VMTDoiY29ubmVjdENlbGwiLENFTExfQ09OTkVDVEVEOiJjZWxsQ29ubmVjdGVkIixTUExJVF9FREdFOiJzcGxpdEVkZ2UiLEZMSVBfRURHRToiZmxpcEVkZ2UiLApTVEFSVF9FRElUSU5HOiJzdGFydEVkaXRpbmciLEVESVRJTkdfU1RBUlRFRDoiZWRpdGluZ1N0YXJ0ZWQiLEVESVRJTkdfU1RPUFBFRDoiZWRpdGluZ1N0b3BwZWQiLEFERF9PVkVSTEFZOiJhZGRPdmVybGF5IixSRU1PVkVfT1ZFUkxBWToicmVtb3ZlT3ZlcmxheSIsVVBEQVRFX0NFTExfU0laRToidXBkYXRlQ2VsbFNpemUiLEVTQ0FQRToiZXNjYXBlIixET1VCTEVfQ0xJQ0s6ImRvdWJsZUNsaWNrIixTVEFSVDoic3RhcnQiLFJFU0VUOiJyZXNldCJ9O2Z1bmN0aW9uIG14WG1sUmVxdWVzdChhLGIsYyxkLGUsZil7dGhpcy51cmw9YTt0aGlzLnBhcmFtcz1iO3RoaXMubWV0aG9kPWN8fCJQT1NUIjt0aGlzLmFzeW5jPW51bGwhPWQ/ZDohMDt0aGlzLnVzZXJuYW1lPWU7dGhpcy5wYXNzd29yZD1mfW14WG1sUmVxdWVzdC5wcm90b3R5cGUudXJsPW51bGw7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5wYXJhbXM9bnVsbDtteFhtbFJlcXVlc3QucHJvdG90eXBlLm1ldGhvZD1udWxsOwpteFhtbFJlcXVlc3QucHJvdG90eXBlLmFzeW5jPW51bGw7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5iaW5hcnk9ITE7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHM9ITE7bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS51c2VybmFtZT1udWxsO214WG1sUmVxdWVzdC5wcm90b3R5cGUucGFzc3dvcmQ9bnVsbDtteFhtbFJlcXVlc3QucHJvdG90eXBlLnJlcXVlc3Q9bnVsbDtteFhtbFJlcXVlc3QucHJvdG90eXBlLmRlY29kZVNpbXVsYXRlVmFsdWVzPSExO214WG1sUmVxdWVzdC5wcm90b3R5cGUuaXNCaW5hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iaW5hcnl9O214WG1sUmVxdWVzdC5wcm90b3R5cGUuc2V0QmluYXJ5PWZ1bmN0aW9uKGEpe3RoaXMuYmluYXJ5PWF9O214WG1sUmVxdWVzdC5wcm90b3R5cGUuZ2V0VGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVlc3QucmVzcG9uc2VUZXh0fTsKbXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuIDQ9PXRoaXMucmVxdWVzdC5yZWFkeVN0YXRlfTtteFhtbFJlcXVlc3QucHJvdG90eXBlLmdldERvY3VtZW50RWxlbWVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0WG1sKCk7cmV0dXJuIG51bGwhPWE/YS5kb2N1bWVudEVsZW1lbnQ6bnVsbH07bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5nZXRYbWw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJlcXVlc3QucmVzcG9uc2VYTUw7aWYoOTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxudWxsPT1hfHxudWxsPT1hLmRvY3VtZW50RWxlbWVudClhPW14VXRpbHMucGFyc2VYbWwodGhpcy5yZXF1ZXN0LnJlc3BvbnNlVGV4dCk7cmV0dXJuIGF9O214WG1sUmVxdWVzdC5wcm90b3R5cGUuZ2V0VGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcXVlc3QucmVzcG9uc2VUZXh0fTsKbXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5nZXRTdGF0dXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5yZXF1ZXN0P3RoaXMucmVxdWVzdC5zdGF0dXM6bnVsbH07bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oKXtpZih3aW5kb3cuWE1MSHR0cFJlcXVlc3QpcmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGE9bmV3IFhNTEh0dHBSZXF1ZXN0O3RoaXMuaXNCaW5hcnkoKSYmYS5vdmVycmlkZU1pbWVUeXBlJiZhLm92ZXJyaWRlTWltZVR5cGUoInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQiKTtyZXR1cm4gYX07aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBBY3RpdmVYT2JqZWN0KXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgQWN0aXZlWE9iamVjdCgiTWljcm9zb2Z0LlhNTEhUVFAiKX19KCk7Cm14WG1sUmVxdWVzdC5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLnJlcXVlc3Q9dGhpcy5jcmVhdGUoKTtudWxsIT10aGlzLnJlcXVlc3QmJihudWxsIT1hJiYodGhpcy5yZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaXNSZWFkeSgpJiYoYSh0aGlzKSx0aGlzLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlPW51bGwpfSkpLHRoaXMucmVxdWVzdC5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLHRoaXMuYXN5bmMsdGhpcy51c2VybmFtZSx0aGlzLnBhc3N3b3JkKSx0aGlzLnNldFJlcXVlc3RIZWFkZXJzKHRoaXMucmVxdWVzdCx0aGlzLnBhcmFtcyksd2luZG93LlhNTEh0dHBSZXF1ZXN0JiZ0aGlzLndpdGhDcmVkZW50aWFscyYmKHRoaXMucmVxdWVzdC53aXRoQ3JlZGVudGlhbHM9InRydWUiKSwhbXhDbGllbnQuSVNfUVVJUktTJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9kZSkmJgp3aW5kb3cuWE1MSHR0cFJlcXVlc3QmJm51bGwhPWMmJm51bGwhPWQmJih0aGlzLnJlcXVlc3QudGltZW91dD1jLHRoaXMucmVxdWVzdC5vbnRpbWVvdXQ9ZCksdGhpcy5yZXF1ZXN0LnNlbmQodGhpcy5wYXJhbXMpKX07bXhYbWxSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVycz1mdW5jdGlvbihhLGIpe251bGwhPWImJmEuc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1UeXBlIiwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIil9OwpteFhtbFJlcXVlc3QucHJvdG90eXBlLnNpbXVsYXRlPWZ1bmN0aW9uKGEsYil7YT1hfHxkb2N1bWVudDt2YXIgYz1udWxsO2E9PWRvY3VtZW50JiYoYz13aW5kb3cub25iZWZvcmV1bmxvYWQsd2luZG93Lm9uYmVmb3JldW5sb2FkPW51bGwpO3ZhciBkPWEuY3JlYXRlRWxlbWVudCgiZm9ybSIpO2Quc2V0QXR0cmlidXRlKCJtZXRob2QiLHRoaXMubWV0aG9kKTtkLnNldEF0dHJpYnV0ZSgiYWN0aW9uIix0aGlzLnVybCk7bnVsbCE9YiYmZC5zZXRBdHRyaWJ1dGUoInRhcmdldCIsYik7ZC5zdHlsZS5kaXNwbGF5PSJub25lIjtkLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiI7Zm9yKHZhciBlPTA8dGhpcy5wYXJhbXMuaW5kZXhPZigiJiIpP3RoaXMucGFyYW1zLnNwbGl0KCImIik6dGhpcy5wYXJhbXMuc3BsaXQoKSxmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl0uaW5kZXhPZigiPSIpO2lmKDA8Zyl7dmFyIGs9ZVtmXS5zdWJzdHJpbmcoMCxnKSxnPWVbZl0uc3Vic3RyaW5nKGcrCjEpO3RoaXMuZGVjb2RlU2ltdWxhdGVWYWx1ZXMmJihnPWRlY29kZVVSSUNvbXBvbmVudChnKSk7dmFyIGw9YS5jcmVhdGVFbGVtZW50KCJ0ZXh0YXJlYSIpO2wuc2V0QXR0cmlidXRlKCJ3cmFwIiwib2ZmIik7bC5zZXRBdHRyaWJ1dGUoIm5hbWUiLGspO214VXRpbHMud3JpdGUobCxnKTtkLmFwcGVuZENoaWxkKGwpfX1hLmJvZHkuYXBwZW5kQ2hpbGQoZCk7ZC5zdWJtaXQoKTtudWxsIT1kLnBhcmVudE5vZGUmJmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKTtudWxsIT1jJiYod2luZG93Lm9uYmVmb3JldW5sb2FkPWMpfTsKdmFyIG14Q2xpcGJvYXJkPXtTVEVQU0laRToxMCxpbnNlcnRDb3VudDoxLGNlbGxzOm51bGwsc2V0Q2VsbHM6ZnVuY3Rpb24oYSl7bXhDbGlwYm9hcmQuY2VsbHM9YX0sZ2V0Q2VsbHM6ZnVuY3Rpb24oKXtyZXR1cm4gbXhDbGlwYm9hcmQuY2VsbHN9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09bXhDbGlwYm9hcmQuZ2V0Q2VsbHMoKX0sY3V0OmZ1bmN0aW9uKGEsYil7Yj1teENsaXBib2FyZC5jb3B5KGEsYik7bXhDbGlwYm9hcmQuaW5zZXJ0Q291bnQ9MDtteENsaXBib2FyZC5yZW1vdmVDZWxscyhhLGIpO3JldHVybiBifSxyZW1vdmVDZWxsczpmdW5jdGlvbihhLGIpe2EucmVtb3ZlQ2VsbHMoYil9LGNvcHk6ZnVuY3Rpb24oYSxiKXtiPWJ8fGEuZ2V0U2VsZWN0aW9uQ2VsbHMoKTt2YXIgYz1hLmdldEV4cG9ydGFibGVDZWxscyhhLm1vZGVsLmdldFRvcG1vc3RDZWxscyhiKSk7bXhDbGlwYm9hcmQuaW5zZXJ0Q291bnQ9MTtteENsaXBib2FyZC5zZXRDZWxscyhhLmNsb25lQ2VsbHMoYykpOwpyZXR1cm4gY30scGFzdGU6ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZighbXhDbGlwYm9hcmQuaXNFbXB0eSgpKXt2YXIgYj1hLmdldEltcG9ydGFibGVDZWxscyhteENsaXBib2FyZC5nZXRDZWxscygpKSxjPW14Q2xpcGJvYXJkLmluc2VydENvdW50Km14Q2xpcGJvYXJkLlNURVBTSVpFLGQ9YS5nZXREZWZhdWx0UGFyZW50KCksYj1hLmltcG9ydENlbGxzKGIsYyxjLGQpO214Q2xpcGJvYXJkLmluc2VydENvdW50Kys7YS5zZXRTZWxlY3Rpb25DZWxscyhiKX1yZXR1cm4gYn19OwpmdW5jdGlvbiBteFdpbmRvdyhhLGIsYyxkLGUsZixnLGssbCxtKXtudWxsIT1iJiYoZz1udWxsIT1nP2c6ITAsdGhpcy5jb250ZW50PWIsdGhpcy5pbml0KGMsZCxlLGYsbSksdGhpcy5pbnN0YWxsTWF4aW1pemVIYW5kbGVyKCksdGhpcy5pbnN0YWxsTWluaW1pemVIYW5kbGVyKCksdGhpcy5pbnN0YWxsQ2xvc2VIYW5kbGVyKCksdGhpcy5zZXRNaW5pbWl6YWJsZShnKSx0aGlzLnNldFRpdGxlKGEpLChudWxsPT1rfHxrKSYmdGhpcy5pbnN0YWxsTW92ZUhhbmRsZXIoKSxudWxsIT1sJiZudWxsIT1sLnBhcmVudE5vZGU/bC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLmRpdixsKTpkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGl2KSl9bXhXaW5kb3cucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlO214V2luZG93LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teFdpbmRvdztteFdpbmRvdy5wcm90b3R5cGUuY2xvc2VJbWFnZT1teENsaWVudC5pbWFnZUJhc2VQYXRoKyIvY2xvc2UuZ2lmIjsKbXhXaW5kb3cucHJvdG90eXBlLm1pbmltaXplSW1hZ2U9bXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL21pbmltaXplLmdpZiI7bXhXaW5kb3cucHJvdG90eXBlLm5vcm1hbGl6ZUltYWdlPW14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9ub3JtYWxpemUuZ2lmIjtteFdpbmRvdy5wcm90b3R5cGUubWF4aW1pemVJbWFnZT1teENsaWVudC5pbWFnZUJhc2VQYXRoKyIvbWF4aW1pemUuZ2lmIjtteFdpbmRvdy5wcm90b3R5cGUucmVzaXplSW1hZ2U9bXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL3Jlc2l6ZS5naWYiO214V2luZG93LnByb3RvdHlwZS52aXNpYmxlPSExO214V2luZG93LnByb3RvdHlwZS5taW5pbXVtU2l6ZT1uZXcgbXhSZWN0YW5nbGUoMCwwLDUwLDQwKTtteFdpbmRvdy5wcm90b3R5cGUuZGVzdHJveU9uQ2xvc2U9ITA7Cm14V2luZG93LnByb3RvdHlwZS5jb250ZW50SGVpZ2h0Q29ycmVjdGlvbj04PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDc9PWRvY3VtZW50LmRvY3VtZW50TW9kZT82OjI7bXhXaW5kb3cucHJvdG90eXBlLnRpdGxlPW51bGw7bXhXaW5kb3cucHJvdG90eXBlLmNvbnRlbnQ9bnVsbDsKbXhXaW5kb3cucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXtlPW51bGwhPWU/ZToibXhXaW5kb3ciO3RoaXMuZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3RoaXMuZGl2LmNsYXNzTmFtZT1lO3RoaXMuZGl2LnN0eWxlLmxlZnQ9YSsicHgiO3RoaXMuZGl2LnN0eWxlLnRvcD1iKyJweCI7dGhpcy50YWJsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0YWJsZSIpO3RoaXMudGFibGUuY2xhc3NOYW1lPWU7bXhDbGllbnQuSVNfUE9JTlRFUiYmKHRoaXMuZGl2LnN0eWxlLnRvdWNoQWN0aW9uPSJub25lIik7bnVsbCE9YyYmKG14Q2xpZW50LklTX1FVSVJLU3x8KHRoaXMuZGl2LnN0eWxlLndpZHRoPWMrInB4IiksdGhpcy50YWJsZS5zdHlsZS53aWR0aD1jKyJweCIpO251bGwhPWQmJihteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmRpdi5zdHlsZS5oZWlnaHQ9ZCsicHgiKSx0aGlzLnRhYmxlLnN0eWxlLmhlaWdodD1kKyJweCIpO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKTsKYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO3RoaXMudGl0bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTt0aGlzLnRpdGxlLmNsYXNzTmFtZT1lKyJUaXRsZSI7dGhpcy5idXR0b25zPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3RoaXMuYnV0dG9ucy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3RoaXMuYnV0dG9ucy5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO3RoaXMuYnV0dG9ucy5zdHlsZS5yaWdodD0iNHB4Ijt0aGlzLmJ1dHRvbnMuc3R5bGUudG9wPSI1cHgiO3RoaXMudGl0bGUuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25zKTtiLmFwcGVuZENoaWxkKHRoaXMudGl0bGUpO2EuYXBwZW5kQ2hpbGQoYik7Yj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO3RoaXMudGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTt0aGlzLnRkLmNsYXNzTmFtZT1lKyJQYW5lIjs3PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJih0aGlzLnRkLnN0eWxlLmhlaWdodD0KIjEwMCUiKTt0aGlzLmNvbnRlbnRXcmFwcGVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3RoaXMuY29udGVudFdyYXBwZXIuY2xhc3NOYW1lPWUrIlBhbmUiO3RoaXMuY29udGVudFdyYXBwZXIuc3R5bGUud2lkdGg9IjEwMCUiO3RoaXMuY29udGVudFdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtpZihteENsaWVudC5JU19RVUlSS1N8fCJESVYiIT10aGlzLmNvbnRlbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSl0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodD0iMTAwJSI7dGhpcy50ZC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRXcmFwcGVyKTtiLmFwcGVuZENoaWxkKHRoaXMudGQpO2EuYXBwZW5kQ2hpbGQoYik7dGhpcy50YWJsZS5hcHBlbmRDaGlsZChhKTt0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlKTtlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuYWN0aXZhdGUoKX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLnRpdGxlLAplKTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy50YWJsZSxlKTt0aGlzLmhpZGUoKX07bXhXaW5kb3cucHJvdG90eXBlLnNldFRpdGxlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLnRpdGxlLmZpcnN0Q2hpbGQ7bnVsbCE9Yjspe3ZhciBjPWIubmV4dFNpYmxpbmc7Yi5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfVEVYVCYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2I9Y31teFV0aWxzLndyaXRlKHRoaXMudGl0bGUsYXx8IiIpO3RoaXMudGl0bGUuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25zKX07bXhXaW5kb3cucHJvdG90eXBlLnNldFNjcm9sbGFibGU9ZnVuY3Rpb24oYSl7aWYobnVsbD09bmF2aWdhdG9yLnVzZXJBZ2VudHx8MD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlByZXN0by8yLjUiKSl0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLm92ZXJmbG93PWE/ImF1dG8iOiJoaWRkZW4ifTsKbXhXaW5kb3cucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKCl7aWYobXhXaW5kb3cuYWN0aXZlV2luZG93IT10aGlzKXt2YXIgYT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZSh0aGlzLmdldEVsZW1lbnQoKSksYT1udWxsIT1hP2EuekluZGV4OjM7aWYobXhXaW5kb3cuYWN0aXZlV2luZG93KXt2YXIgYj1teFdpbmRvdy5hY3RpdmVXaW5kb3cuZ2V0RWxlbWVudCgpO251bGwhPWImJm51bGwhPWIuc3R5bGUmJihiLnN0eWxlLnpJbmRleD1hKX1iPW14V2luZG93LmFjdGl2ZVdpbmRvdzt0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS56SW5kZXg9cGFyc2VJbnQoYSkrMTtteFdpbmRvdy5hY3RpdmVXaW5kb3c9dGhpczt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFDVElWQVRFLCJwcmV2aW91c1dpbmRvdyIsYikpfX07bXhXaW5kb3cucHJvdG90eXBlLmdldEVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXZ9OwpteFdpbmRvdy5wcm90b3R5cGUuZml0PWZ1bmN0aW9uKCl7bXhVdGlscy5maXQodGhpcy5kaXYpfTtteFdpbmRvdy5wcm90b3R5cGUuaXNSZXNpemFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5yZXNpemU/Im5vbmUiIT10aGlzLnJlc2l6ZS5zdHlsZS5kaXNwbGF5OiExfTsKbXhXaW5kb3cucHJvdG90eXBlLnNldFJlc2l6YWJsZT1mdW5jdGlvbihhKXtpZihhKWlmKG51bGw9PXRoaXMucmVzaXplKXt0aGlzLnJlc2l6ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTt0aGlzLnJlc2l6ZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3RoaXMucmVzaXplLnN0eWxlLmJvdHRvbT0iMnB4Ijt0aGlzLnJlc2l6ZS5zdHlsZS5yaWdodD0iMnB4Ijt0aGlzLnJlc2l6ZS5zZXRBdHRyaWJ1dGUoInNyYyIsdGhpcy5yZXNpemVJbWFnZSk7dGhpcy5yZXNpemUuc3R5bGUuY3Vyc29yPSJudy1yZXNpemUiO3ZhciBiPW51bGwsYz1udWxsLGQ9bnVsbCxlPW51bGw7YT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGl2YXRlKCk7Yj1teEV2ZW50LmdldENsaWVudFgoYSk7Yz1teEV2ZW50LmdldENsaWVudFkoYSk7ZD10aGlzLmRpdi5vZmZzZXRXaWR0aDtlPXRoaXMuZGl2Lm9mZnNldEhlaWdodDtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsCm51bGwsZixnKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFU0laRV9TVEFSVCwiZXZlbnQiLGEpKTtteEV2ZW50LmNvbnN1bWUoYSl9KTt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZihudWxsIT1iJiZudWxsIT1jKXt2YXIgZj1teEV2ZW50LmdldENsaWVudFgoYSktYixnPW14RXZlbnQuZ2V0Q2xpZW50WShhKS1jO3RoaXMuc2V0U2l6ZShkK2YsZStnKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFU0laRSwiZXZlbnQiLGEpKTtteEV2ZW50LmNvbnN1bWUoYSl9fSksZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1iJiZudWxsIT1jJiYoYz1iPW51bGwsbXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsZixnKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFU0laRV9FTkQsImV2ZW50IixhKSksbXhFdmVudC5jb25zdW1lKGEpKX0pOwpteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy5yZXNpemUsYSxmLGcpO3RoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMucmVzaXplKX1lbHNlIHRoaXMucmVzaXplLnN0eWxlLmRpc3BsYXk9ImlubGluZSI7ZWxzZSBudWxsIT10aGlzLnJlc2l6ZSYmKHRoaXMucmVzaXplLnN0eWxlLmRpc3BsYXk9Im5vbmUiKX07Cm14V2luZG93LnByb3RvdHlwZS5zZXRTaXplPWZ1bmN0aW9uKGEsYil7YT1NYXRoLm1heCh0aGlzLm1pbmltdW1TaXplLndpZHRoLGEpO2I9TWF0aC5tYXgodGhpcy5taW5pbXVtU2l6ZS5oZWlnaHQsYik7bXhDbGllbnQuSVNfUVVJUktTfHwodGhpcy5kaXYuc3R5bGUud2lkdGg9YSsicHgiLHRoaXMuZGl2LnN0eWxlLmhlaWdodD1iKyJweCIpO3RoaXMudGFibGUuc3R5bGUud2lkdGg9YSsicHgiO3RoaXMudGFibGUuc3R5bGUuaGVpZ2h0PWIrInB4IjtteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodD10aGlzLmRpdi5vZmZzZXRIZWlnaHQtdGhpcy50aXRsZS5vZmZzZXRIZWlnaHQtdGhpcy5jb250ZW50SGVpZ2h0Q29ycmVjdGlvbisicHgiKX07bXhXaW5kb3cucHJvdG90eXBlLnNldE1pbmltaXphYmxlPWZ1bmN0aW9uKGEpe3RoaXMubWluaW1pemUuc3R5bGUuZGlzcGxheT1hPyIiOiJub25lIn07Cm14V2luZG93LnByb3RvdHlwZS5nZXRNaW5pbXVtU2l6ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLDAsdGhpcy50aXRsZS5vZmZzZXRIZWlnaHQpfTsKbXhXaW5kb3cucHJvdG90eXBlLmluc3RhbGxNaW5pbWl6ZUhhbmRsZXI9ZnVuY3Rpb24oKXt0aGlzLm1pbmltaXplPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO3RoaXMubWluaW1pemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMubWluaW1pemVJbWFnZSk7dGhpcy5taW5pbWl6ZS5zZXRBdHRyaWJ1dGUoInRpdGxlIiwiTWluaW1pemUiKTt0aGlzLm1pbmltaXplLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7dGhpcy5taW5pbWl6ZS5zdHlsZS5tYXJnaW5MZWZ0PSIycHgiO3RoaXMubWluaW1pemUuc3R5bGUuZGlzcGxheT0ibm9uZSI7dGhpcy5idXR0b25zLmFwcGVuZENoaWxkKHRoaXMubWluaW1pemUpO3ZhciBhPSExLGI9bnVsbCxjPW51bGwsZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihkKXt0aGlzLmFjdGl2YXRlKCk7aWYoYSlhPSExLHRoaXMubWluaW1pemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMubWluaW1pemVJbWFnZSksdGhpcy5taW5pbWl6ZS5zZXRBdHRyaWJ1dGUoInRpdGxlIiwKIk1pbmltaXplIiksdGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5kaXNwbGF5PSIiLHRoaXMubWF4aW1pemUuc3R5bGUuZGlzcGxheT1iLG14Q2xpZW50LklTX1FVSVJLU3x8KHRoaXMuZGl2LnN0eWxlLmhlaWdodD1jKSx0aGlzLnRhYmxlLnN0eWxlLmhlaWdodD1jLG51bGwhPXRoaXMucmVzaXplJiYodGhpcy5yZXNpemUuc3R5bGUudmlzaWJpbGl0eT0iIiksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5OT1JNQUxJWkUsImV2ZW50IixkKSk7ZWxzZXthPSEwO3RoaXMubWluaW1pemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMubm9ybWFsaXplSW1hZ2UpO3RoaXMubWluaW1pemUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIk5vcm1hbGl6ZSIpO3RoaXMuY29udGVudFdyYXBwZXIuc3R5bGUuZGlzcGxheT0ibm9uZSI7Yj10aGlzLm1heGltaXplLnN0eWxlLmRpc3BsYXk7dGhpcy5tYXhpbWl6ZS5zdHlsZS5kaXNwbGF5PSJub25lIjtjPXRoaXMudGFibGUuc3R5bGUuaGVpZ2h0Owp2YXIgZT10aGlzLmdldE1pbmltdW1TaXplKCk7MDxlLmhlaWdodCYmKG14Q2xpZW50LklTX1FVSVJLU3x8KHRoaXMuZGl2LnN0eWxlLmhlaWdodD1lLmhlaWdodCsicHgiKSx0aGlzLnRhYmxlLnN0eWxlLmhlaWdodD1lLmhlaWdodCsicHgiKTswPGUud2lkdGgmJihteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmRpdi5zdHlsZS53aWR0aD1lLndpZHRoKyJweCIpLHRoaXMudGFibGUuc3R5bGUud2lkdGg9ZS53aWR0aCsicHgiKTtudWxsIT10aGlzLnJlc2l6ZSYmKHRoaXMucmVzaXplLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuTUlOSU1JWkUsImV2ZW50IixkKSl9bXhFdmVudC5jb25zdW1lKGQpfSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMubWluaW1pemUsZCl9OwpteFdpbmRvdy5wcm90b3R5cGUuc2V0TWF4aW1pemFibGU9ZnVuY3Rpb24oYSl7dGhpcy5tYXhpbWl6ZS5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUifTsKbXhXaW5kb3cucHJvdG90eXBlLmluc3RhbGxNYXhpbWl6ZUhhbmRsZXI9ZnVuY3Rpb24oKXt0aGlzLm1heGltaXplPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO3RoaXMubWF4aW1pemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMubWF4aW1pemVJbWFnZSk7dGhpcy5tYXhpbWl6ZS5zZXRBdHRyaWJ1dGUoInRpdGxlIiwiTWF4aW1pemUiKTt0aGlzLm1heGltaXplLnN0eWxlLmN1cnNvcj0iZGVmYXVsdCI7dGhpcy5tYXhpbWl6ZS5zdHlsZS5tYXJnaW5MZWZ0PSIycHgiO3RoaXMubWF4aW1pemUuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjt0aGlzLm1heGltaXplLnN0eWxlLmRpc3BsYXk9Im5vbmUiO3RoaXMuYnV0dG9ucy5hcHBlbmRDaGlsZCh0aGlzLm1heGltaXplKTt2YXIgYT0hMSxiPW51bGwsYz1udWxsLGQ9bnVsbCxlPW51bGwsZj1udWxsLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZyl7dGhpcy5hY3RpdmF0ZSgpO2lmKCJub25lIiE9dGhpcy5tYXhpbWl6ZS5zdHlsZS5kaXNwbGF5KXtpZihhKWE9CiExLHRoaXMubWF4aW1pemUuc2V0QXR0cmlidXRlKCJzcmMiLHRoaXMubWF4aW1pemVJbWFnZSksdGhpcy5tYXhpbWl6ZS5zZXRBdHRyaWJ1dGUoInRpdGxlIiwiTWF4aW1pemUiKSx0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLmRpc3BsYXk9IiIsdGhpcy5taW5pbWl6ZS5zdHlsZS5kaXNwbGF5PWYsdGhpcy5kaXYuc3R5bGUubGVmdD1iKyJweCIsdGhpcy5kaXYuc3R5bGUudG9wPWMrInB4IixteENsaWVudC5JU19RVUlSS1N8fCh0aGlzLmRpdi5zdHlsZS5oZWlnaHQ9ZCx0aGlzLmRpdi5zdHlsZS53aWR0aD1lLGs9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUodGhpcy5jb250ZW50V3JhcHBlciksImF1dG8iIT1rLm92ZXJmbG93JiZudWxsPT10aGlzLnJlc2l6ZSl8fCh0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodD10aGlzLmRpdi5vZmZzZXRIZWlnaHQtdGhpcy50aXRsZS5vZmZzZXRIZWlnaHQtdGhpcy5jb250ZW50SGVpZ2h0Q29ycmVjdGlvbisicHgiKSx0aGlzLnRhYmxlLnN0eWxlLmhlaWdodD0KZCx0aGlzLnRhYmxlLnN0eWxlLndpZHRoPWUsbnVsbCE9dGhpcy5yZXNpemUmJih0aGlzLnJlc2l6ZS5zdHlsZS52aXNpYmlsaXR5PSIiKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk5PUk1BTElaRSwiZXZlbnQiLGcpKTtlbHNle2E9ITA7dGhpcy5tYXhpbWl6ZS5zZXRBdHRyaWJ1dGUoInNyYyIsdGhpcy5ub3JtYWxpemVJbWFnZSk7dGhpcy5tYXhpbWl6ZS5zZXRBdHRyaWJ1dGUoInRpdGxlIiwiTm9ybWFsaXplIik7dGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5kaXNwbGF5PSIiO2Y9dGhpcy5taW5pbWl6ZS5zdHlsZS5kaXNwbGF5O3RoaXMubWluaW1pemUuc3R5bGUuZGlzcGxheT0ibm9uZSI7Yj1wYXJzZUludCh0aGlzLmRpdi5zdHlsZS5sZWZ0KTtjPXBhcnNlSW50KHRoaXMuZGl2LnN0eWxlLnRvcCk7ZD10aGlzLnRhYmxlLnN0eWxlLmhlaWdodDtlPXRoaXMudGFibGUuc3R5bGUud2lkdGg7dGhpcy5kaXYuc3R5bGUubGVmdD0iMHB4Ijt0aGlzLmRpdi5zdHlsZS50b3A9CiIwcHgiO2s9TWF0aC5tYXgoZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHR8fDAsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodHx8MCk7bXhDbGllbnQuSVNfUVVJUktTfHwodGhpcy5kaXYuc3R5bGUud2lkdGg9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aC0yKyJweCIsdGhpcy5kaXYuc3R5bGUuaGVpZ2h0PWstMisicHgiKTt0aGlzLnRhYmxlLnN0eWxlLndpZHRoPWRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgtMisicHgiO3RoaXMudGFibGUuc3R5bGUuaGVpZ2h0PWstMisicHgiO251bGwhPXRoaXMucmVzaXplJiYodGhpcy5yZXNpemUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIik7aWYoIW14Q2xpZW50LklTX1FVSVJLUyl7dmFyIGs9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUodGhpcy5jb250ZW50V3JhcHBlcik7aWYoImF1dG8iPT1rLm92ZXJmbG93fHxudWxsIT10aGlzLnJlc2l6ZSl0aGlzLmNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodD10aGlzLmRpdi5vZmZzZXRIZWlnaHQtCnRoaXMudGl0bGUub2Zmc2V0SGVpZ2h0LXRoaXMuY29udGVudEhlaWdodENvcnJlY3Rpb24rInB4In10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk1BWElNSVpFLCJldmVudCIsZykpfW14RXZlbnQuY29uc3VtZShnKX19KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy5tYXhpbWl6ZSxnKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMudGl0bGUsImRibGNsaWNrIixnKX07Cm14V2luZG93LnByb3RvdHlwZS5pbnN0YWxsTW92ZUhhbmRsZXI9ZnVuY3Rpb24oKXt0aGlzLnRpdGxlLnN0eWxlLmN1cnNvcj0ibW92ZSI7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMudGl0bGUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9bXhFdmVudC5nZXRDbGllbnRYKGEpLGM9bXhFdmVudC5nZXRDbGllbnRZKGEpLGQ9dGhpcy5nZXRYKCksZT10aGlzLmdldFkoKSxmPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBmPW14RXZlbnQuZ2V0Q2xpZW50WChhKS1iLGc9bXhFdmVudC5nZXRDbGllbnRZKGEpLWM7dGhpcy5zZXRMb2NhdGlvbihkK2YsZStnKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk1PVkUsImV2ZW50IixhKSk7bXhFdmVudC5jb25zdW1lKGEpfSksZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LnJlbW92ZUdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsbnVsbCxmLApnKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk1PVkVfRU5ELCJldmVudCIsYSkpO214RXZlbnQuY29uc3VtZShhKX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLGYsZyk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5NT1ZFX1NUQVJULCJldmVudCIsYSkpO214RXZlbnQuY29uc3VtZShhKX0pKTtteENsaWVudC5JU19QT0lOVEVSJiYodGhpcy50aXRsZS5zdHlsZS50b3VjaEFjdGlvbj0ibm9uZSIpfTtteFdpbmRvdy5wcm90b3R5cGUuc2V0TG9jYXRpb249ZnVuY3Rpb24oYSxiKXt0aGlzLmRpdi5zdHlsZS5sZWZ0PWErInB4Ijt0aGlzLmRpdi5zdHlsZS50b3A9YisicHgifTtteFdpbmRvdy5wcm90b3R5cGUuZ2V0WD1mdW5jdGlvbigpe3JldHVybiBwYXJzZUludCh0aGlzLmRpdi5zdHlsZS5sZWZ0KX07bXhXaW5kb3cucHJvdG90eXBlLmdldFk9ZnVuY3Rpb24oKXtyZXR1cm4gcGFyc2VJbnQodGhpcy5kaXYuc3R5bGUudG9wKX07Cm14V2luZG93LnByb3RvdHlwZS5pbnN0YWxsQ2xvc2VIYW5kbGVyPWZ1bmN0aW9uKCl7dGhpcy5jbG9zZUltZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTt0aGlzLmNsb3NlSW1nLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLmNsb3NlSW1hZ2UpO3RoaXMuY2xvc2VJbWcuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIkNsb3NlIik7dGhpcy5jbG9zZUltZy5zdHlsZS5tYXJnaW5MZWZ0PSIycHgiO3RoaXMuY2xvc2VJbWcuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjt0aGlzLmNsb3NlSW1nLnN0eWxlLmRpc3BsYXk9Im5vbmUiO3RoaXMuYnV0dG9ucy5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlSW1nKTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy5jbG9zZUltZyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNMT1NFLCJldmVudCIsYSkpO3RoaXMuZGVzdHJveU9uQ2xvc2U/dGhpcy5kZXN0cm95KCk6CnRoaXMuc2V0VmlzaWJsZSghMSk7bXhFdmVudC5jb25zdW1lKGEpfSkpfTtteFdpbmRvdy5wcm90b3R5cGUuc2V0SW1hZ2U9ZnVuY3Rpb24oYSl7dGhpcy5pbWFnZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTt0aGlzLmltYWdlLnNldEF0dHJpYnV0ZSgic3JjIixhKTt0aGlzLmltYWdlLnNldEF0dHJpYnV0ZSgiYWxpZ24iLCJsZWZ0Iik7dGhpcy5pbWFnZS5zdHlsZS5tYXJnaW5SaWdodD0iNHB4Ijt0aGlzLmltYWdlLnN0eWxlLm1hcmdpbkxlZnQ9IjBweCI7dGhpcy5pbWFnZS5zdHlsZS5tYXJnaW5Ub3A9Ii0ycHgiO3RoaXMudGl0bGUuaW5zZXJ0QmVmb3JlKHRoaXMuaW1hZ2UsdGhpcy50aXRsZS5maXJzdENoaWxkKX07bXhXaW5kb3cucHJvdG90eXBlLnNldENsb3NhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2xvc2VJbWcuc3R5bGUuZGlzcGxheT1hPyIiOiJub25lIn07Cm14V2luZG93LnByb3RvdHlwZS5pc1Zpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5kaXY/Im5vbmUiIT10aGlzLmRpdi5zdHlsZS5kaXNwbGF5OiExfTtteFdpbmRvdy5wcm90b3R5cGUuc2V0VmlzaWJsZT1mdW5jdGlvbihhKXtudWxsIT10aGlzLmRpdiYmdGhpcy5pc1Zpc2libGUoKSE9YSYmKGE/dGhpcy5zaG93KCk6dGhpcy5oaWRlKCkpfTsKbXhXaW5kb3cucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXt0aGlzLmRpdi5zdHlsZS5kaXNwbGF5PSIiO3RoaXMuYWN0aXZhdGUoKTt2YXIgYT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZSh0aGlzLmNvbnRlbnRXcmFwcGVyKTtteENsaWVudC5JU19RVUlSS1N8fCJhdXRvIiE9YS5vdmVyZmxvdyYmbnVsbD09dGhpcy5yZXNpemV8fCJub25lIj09dGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5kaXNwbGF5fHwodGhpcy5jb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQ9dGhpcy5kaXYub2Zmc2V0SGVpZ2h0LXRoaXMudGl0bGUub2Zmc2V0SGVpZ2h0LXRoaXMuY29udGVudEhlaWdodENvcnJlY3Rpb24rInB4Iik7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TSE9XKSl9O214V2luZG93LnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKCl7dGhpcy5kaXYuc3R5bGUuZGlzcGxheT0ibm9uZSI7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ISURFKSl9OwpteFdpbmRvdy5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuREVTVFJPWSkpO251bGwhPXRoaXMuZGl2JiYobXhFdmVudC5yZWxlYXNlKHRoaXMuZGl2KSx0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KSx0aGlzLmRpdj1udWxsKTt0aGlzLmNvbnRlbnRXcmFwcGVyPXRoaXMuY29udGVudD10aGlzLnRpdGxlPW51bGx9O2Z1bmN0aW9uIG14Rm9ybShhKXt0aGlzLnRhYmxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7dGhpcy50YWJsZS5jbGFzc05hbWU9YTt0aGlzLmJvZHk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKTt0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRoaXMuYm9keSl9bXhGb3JtLnByb3RvdHlwZS50YWJsZT1udWxsO214Rm9ybS5wcm90b3R5cGUuYm9keT0hMTtteEZvcm0ucHJvdG90eXBlLmdldFRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFibGV9OwpteEZvcm0ucHJvdG90eXBlLmFkZEJ1dHRvbnM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpLGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtjLmFwcGVuZENoaWxkKGQpO3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIiksZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtteFV0aWxzLndyaXRlKGUsbXhSZXNvdXJjZXMuZ2V0KCJvayIpfHwiT0siKTtkLmFwcGVuZENoaWxkKGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLGZ1bmN0aW9uKCl7YSgpfSk7ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtteFV0aWxzLndyaXRlKGUsbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKXx8IkNhbmNlbCIpO2QuYXBwZW5kQ2hpbGQoZSk7bXhFdmVudC5hZGRMaXN0ZW5lcihlLCJjbGljayIsZnVuY3Rpb24oKXtiKCl9KTtjLmFwcGVuZENoaWxkKGQpO3RoaXMuYm9keS5hcHBlbmRDaGlsZChjKX07Cm14Rm9ybS5wcm90b3R5cGUuYWRkVGV4dD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtkLnNldEF0dHJpYnV0ZSgidHlwZSIsY3x8InRleHQiKTtkLnZhbHVlPWI7cmV0dXJuIHRoaXMuYWRkRmllbGQoYSxkKX07bXhGb3JtLnByb3RvdHlwZS5hZGRDaGVja2JveD1mdW5jdGlvbihhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7Yy5zZXRBdHRyaWJ1dGUoInR5cGUiLCJjaGVja2JveCIpO3RoaXMuYWRkRmllbGQoYSxjKTtiJiYoYy5jaGVja2VkPSEwKTtyZXR1cm4gY307bXhGb3JtLnByb3RvdHlwZS5hZGRUZXh0YXJlYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTtteENsaWVudC5JU19OUyYmYy0tO2Quc2V0QXR0cmlidXRlKCJyb3dzIixjfHwyKTtkLnZhbHVlPWI7cmV0dXJuIHRoaXMuYWRkRmllbGQoYSxkKX07Cm14Rm9ybS5wcm90b3R5cGUuYWRkQ29tYm89ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpO251bGwhPWMmJmQuc2V0QXR0cmlidXRlKCJzaXplIixjKTtiJiZkLnNldEF0dHJpYnV0ZSgibXVsdGlwbGUiLCJ0cnVlIik7cmV0dXJuIHRoaXMuYWRkRmllbGQoYSxkKX07bXhGb3JtLnByb3RvdHlwZS5hZGRPcHRpb249ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7bXhVdGlscy53cml0ZWxuKGUsYik7ZS5zZXRBdHRyaWJ1dGUoInZhbHVlIixjKTtkJiZlLnNldEF0dHJpYnV0ZSgic2VsZWN0ZWQiLGQpO2EuYXBwZW5kQ2hpbGQoZSl9OwpteEZvcm0ucHJvdG90eXBlLmFkZEZpZWxkPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKSxkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7bXhVdGlscy53cml0ZShkLGEpO2MuYXBwZW5kQ2hpbGQoZCk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO2QuYXBwZW5kQ2hpbGQoYik7Yy5hcHBlbmRDaGlsZChkKTt0aGlzLmJvZHkuYXBwZW5kQ2hpbGQoYyk7cmV0dXJuIGJ9O2Z1bmN0aW9uIG14SW1hZ2UoYSxiLGMpe3RoaXMuc3JjPWE7dGhpcy53aWR0aD1iO3RoaXMuaGVpZ2h0PWN9bXhJbWFnZS5wcm90b3R5cGUuc3JjPW51bGw7bXhJbWFnZS5wcm90b3R5cGUud2lkdGg9bnVsbDtteEltYWdlLnByb3RvdHlwZS5oZWlnaHQ9bnVsbDsKZnVuY3Rpb24gbXhEaXZSZXNpemVyKGEsYil7aWYoImRpdiI9PWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7bnVsbD09YiYmKGI9d2luZG93KTt0aGlzLmRpdj1hO3ZhciBjPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKGEpO251bGwhPWMmJih0aGlzLnJlc2l6ZVdpZHRoPSJhdXRvIj09Yy53aWR0aCx0aGlzLnJlc2l6ZUhlaWdodD0iYXV0byI9PWMuaGVpZ2h0KTtteEV2ZW50LmFkZExpc3RlbmVyKGIsInJlc2l6ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGluZ1Jlc2l6ZXx8KHRoaXMuaGFuZGxpbmdSZXNpemU9ITAsdGhpcy5yZXNpemUoKSx0aGlzLmhhbmRsaW5nUmVzaXplPSExKX0pKTt0aGlzLnJlc2l6ZSgpfX1teERpdlJlc2l6ZXIucHJvdG90eXBlLnJlc2l6ZVdpZHRoPSEwO214RGl2UmVzaXplci5wcm90b3R5cGUucmVzaXplSGVpZ2h0PSEwO214RGl2UmVzaXplci5wcm90b3R5cGUuaGFuZGxpbmdSZXNpemU9ITE7Cm14RGl2UmVzaXplci5wcm90b3R5cGUucmVzaXplPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXREb2N1bWVudFdpZHRoKCksYj10aGlzLmdldERvY3VtZW50SGVpZ2h0KCksYz1wYXJzZUludCh0aGlzLmRpdi5zdHlsZS5sZWZ0KSxkPXBhcnNlSW50KHRoaXMuZGl2LnN0eWxlLnJpZ2h0KSxlPXBhcnNlSW50KHRoaXMuZGl2LnN0eWxlLnRvcCksZj1wYXJzZUludCh0aGlzLmRpdi5zdHlsZS5ib3R0b20pO3RoaXMucmVzaXplV2lkdGgmJiFpc05hTihjKSYmIWlzTmFOKGQpJiYwPD1jJiYwPD1kJiYwPGEtZC1jJiYodGhpcy5kaXYuc3R5bGUud2lkdGg9YS1kLWMrInB4Iik7dGhpcy5yZXNpemVIZWlnaHQmJiFpc05hTihlKSYmIWlzTmFOKGYpJiYwPD1lJiYwPD1mJiYwPGItZS1mJiYodGhpcy5kaXYuc3R5bGUuaGVpZ2h0PWItZS1mKyJweCIpfTtteERpdlJlc2l6ZXIucHJvdG90eXBlLmdldERvY3VtZW50V2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aH07Cm14RGl2UmVzaXplci5wcm90b3R5cGUuZ2V0RG9jdW1lbnRIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHR9O2Z1bmN0aW9uIG14RHJhZ1NvdXJjZShhLGIpe3RoaXMuZWxlbWVudD1hO3RoaXMuZHJvcEhhbmRsZXI9YjtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLm1vdXNlRG93bihhKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImRyYWdzdGFydCIsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpfSk7dGhpcy5ldmVudENvbnN1bWVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5nZXRQcm9wZXJ0eSgiZXZlbnROYW1lIiksZD1iLmdldFByb3BlcnR5KCJldmVudCIpO2MhPW14RXZlbnQuTU9VU0VfRE9XTiYmZC5jb25zdW1lKCl9fW14RHJhZ1NvdXJjZS5wcm90b3R5cGUuZWxlbWVudD1udWxsO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuZHJvcEhhbmRsZXI9bnVsbDsKbXhEcmFnU291cmNlLnByb3RvdHlwZS5kcmFnT2Zmc2V0PW51bGw7bXhEcmFnU291cmNlLnByb3RvdHlwZS5kcmFnRWxlbWVudD1udWxsO214RHJhZ1NvdXJjZS5wcm90b3R5cGUucHJldmlld0VsZW1lbnQ9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5jdXJyZW50R3JhcGg9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLmN1cnJlbnREcm9wVGFyZ2V0PW51bGw7bXhEcmFnU291cmNlLnByb3RvdHlwZS5jdXJyZW50UG9pbnQ9bnVsbDtteERyYWdTb3VyY2UucHJvdG90eXBlLmN1cnJlbnRHdWlkZT1udWxsO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuY3VycmVudEhpZ2hsaWdodD1udWxsO214RHJhZ1NvdXJjZS5wcm90b3R5cGUuYXV0b3Njcm9sbD0hMDtteERyYWdTb3VyY2UucHJvdG90eXBlLmd1aWRlc0VuYWJsZWQ9ITA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5ncmlkRW5hYmxlZD0hMDsKbXhEcmFnU291cmNlLnByb3RvdHlwZS5oaWdobGlnaHREcm9wVGFyZ2V0cz0hMDtteERyYWdTb3VyY2UucHJvdG90eXBlLmRyYWdFbGVtZW50WkluZGV4PTEwMDtteERyYWdTb3VyY2UucHJvdG90eXBlLmRyYWdFbGVtZW50T3BhY2l0eT03MDtteERyYWdTb3VyY2UucHJvdG90eXBlLmNoZWNrRXZlbnRTb3VyY2U9ITA7bXhEcmFnU291cmNlLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteERyYWdTb3VyY2UucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuaXNHdWlkZXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3VpZGVzRW5hYmxlZH07bXhEcmFnU291cmNlLnByb3RvdHlwZS5zZXRHdWlkZXNFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZ3VpZGVzRW5hYmxlZD1hfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmlzR3JpZEVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmlkRW5hYmxlZH07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuc2V0R3JpZEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5ncmlkRW5hYmxlZD1hfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmdldEdyYXBoRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuZ2V0RHJvcFRhcmdldD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYS5nZXRDZWxsQXQoYixjKX07bXhEcmFnU291cmNlLnByb3RvdHlwZS5jcmVhdGVEcmFnRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lbGVtZW50LmNsb25lTm9kZSghMCl9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuY3JlYXRlUHJldmlld0VsZW1lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O214RHJhZ1NvdXJjZS5wcm90b3R5cGUuaXNBY3RpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5tb3VzZU1vdmVIYW5kbGVyfTsKbXhEcmFnU291cmNlLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe251bGwhPXRoaXMuY3VycmVudEdyYXBoJiYodGhpcy5kcmFnRXhpdCh0aGlzLmN1cnJlbnRHcmFwaCksdGhpcy5jdXJyZW50R3JhcGg9bnVsbCk7dGhpcy5yZW1vdmVEcmFnRWxlbWVudCgpO3RoaXMucmVtb3ZlTGlzdGVuZXJzKCk7dGhpcy5zdG9wRHJhZygpfTsKbXhEcmFnU291cmNlLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkJiYhbXhFdmVudC5pc0NvbnN1bWVkKGEpJiZudWxsPT10aGlzLm1vdXNlTW92ZUhhbmRsZXImJih0aGlzLnN0YXJ0RHJhZyhhKSx0aGlzLm1vdXNlTW92ZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsdGhpcy5tb3VzZU1vdmUpLHRoaXMubW91c2VVcEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsdGhpcy5tb3VzZVVwKSxteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsbnVsbCx0aGlzLm1vdXNlTW92ZUhhbmRsZXIsdGhpcy5tb3VzZVVwSGFuZGxlciksbXhDbGllbnQuSVNfVE9VQ0gmJiFteEV2ZW50LmlzTW91c2VFdmVudChhKSYmKHRoaXMuZXZlbnRTb3VyY2U9bXhFdmVudC5nZXRTb3VyY2UoYSksbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuZXZlbnRTb3VyY2UsbnVsbCx0aGlzLm1vdXNlTW92ZUhhbmRsZXIsdGhpcy5tb3VzZVVwSGFuZGxlcikpKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuc3RhcnREcmFnPWZ1bmN0aW9uKGEpe3RoaXMuZHJhZ0VsZW1lbnQ9dGhpcy5jcmVhdGVEcmFnRWxlbWVudChhKTt0aGlzLmRyYWdFbGVtZW50LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7dGhpcy5kcmFnRWxlbWVudC5zdHlsZS56SW5kZXg9dGhpcy5kcmFnRWxlbWVudFpJbmRleDtteFV0aWxzLnNldE9wYWNpdHkodGhpcy5kcmFnRWxlbWVudCx0aGlzLmRyYWdFbGVtZW50T3BhY2l0eSk7dGhpcy5jaGVja0V2ZW50U291cmNlJiZteENsaWVudC5JU19TVkcmJih0aGlzLmRyYWdFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHM9Im5vbmUiKX07bXhEcmFnU291cmNlLnByb3RvdHlwZS5zdG9wRHJhZz1mdW5jdGlvbigpe3RoaXMucmVtb3ZlRHJhZ0VsZW1lbnQoKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUucmVtb3ZlRHJhZ0VsZW1lbnQ9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmRyYWdFbGVtZW50JiYobnVsbCE9dGhpcy5kcmFnRWxlbWVudC5wYXJlbnROb2RlJiZ0aGlzLmRyYWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kcmFnRWxlbWVudCksdGhpcy5kcmFnRWxlbWVudD1udWxsKX07bXhEcmFnU291cmNlLnByb3RvdHlwZS5nZXRFbGVtZW50Rm9yRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHxteEV2ZW50LmlzUGVuRXZlbnQoYSk/ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChteEV2ZW50LmdldENsaWVudFgoYSksbXhFdmVudC5nZXRDbGllbnRZKGEpKTpteEV2ZW50LmdldFNvdXJjZShhKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuZ3JhcGhDb250YWluc0V2ZW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9bXhFdmVudC5nZXRDbGllbnRYKGIpLGQ9bXhFdmVudC5nZXRDbGllbnRZKGIpLGU9bXhVdGlscy5nZXRPZmZzZXQoYS5jb250YWluZXIpLGY9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oKSxnPXRoaXMuZ2V0RWxlbWVudEZvckV2ZW50KGIpO2lmKHRoaXMuY2hlY2tFdmVudFNvdXJjZSlmb3IoO251bGwhPWcmJmchPWEuY29udGFpbmVyOylnPWcucGFyZW50Tm9kZTtyZXR1cm4gbnVsbCE9ZyYmYz49ZS54LWYueCYmZD49ZS55LWYueSYmYzw9ZS54LWYueCthLmNvbnRhaW5lci5vZmZzZXRXaWR0aCYmZDw9ZS55LWYueSthLmNvbnRhaW5lci5vZmZzZXRIZWlnaHR9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldEdyYXBoRm9yRXZlbnQoYSk7bnVsbD09Ynx8dGhpcy5ncmFwaENvbnRhaW5zRXZlbnQoYixhKXx8KGI9bnVsbCk7YiE9dGhpcy5jdXJyZW50R3JhcGgmJihudWxsIT10aGlzLmN1cnJlbnRHcmFwaCYmdGhpcy5kcmFnRXhpdCh0aGlzLmN1cnJlbnRHcmFwaCxhKSx0aGlzLmN1cnJlbnRHcmFwaD1iLG51bGwhPXRoaXMuY3VycmVudEdyYXBoJiZ0aGlzLmRyYWdFbnRlcih0aGlzLmN1cnJlbnRHcmFwaCxhKSk7bnVsbCE9dGhpcy5jdXJyZW50R3JhcGgmJnRoaXMuZHJhZ092ZXIodGhpcy5jdXJyZW50R3JhcGgsYSk7aWYobnVsbD09dGhpcy5kcmFnRWxlbWVudHx8bnVsbCE9dGhpcy5wcmV2aWV3RWxlbWVudCYmInZpc2libGUiPT10aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkpbnVsbCE9dGhpcy5kcmFnRWxlbWVudCYmKHRoaXMuZHJhZ0VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eT0KImhpZGRlbiIpO2Vsc2V7dmFyIGI9bXhFdmVudC5nZXRDbGllbnRYKGEpLGM9bXhFdmVudC5nZXRDbGllbnRZKGEpO251bGw9PXRoaXMuZHJhZ0VsZW1lbnQucGFyZW50Tm9kZSYmZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdFbGVtZW50KTt0aGlzLmRyYWdFbGVtZW50LnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiO251bGwhPXRoaXMuZHJhZ09mZnNldCYmKGIrPXRoaXMuZHJhZ09mZnNldC54LGMrPXRoaXMuZHJhZ09mZnNldC55KTt2YXIgZD1teFV0aWxzLmdldERvY3VtZW50U2Nyb2xsT3JpZ2luKGRvY3VtZW50KTt0aGlzLmRyYWdFbGVtZW50LnN0eWxlLmxlZnQ9YitkLngrInB4Ijt0aGlzLmRyYWdFbGVtZW50LnN0eWxlLnRvcD1jK2QueSsicHgifW14RXZlbnQuY29uc3VtZShhKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUubW91c2VVcD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmN1cnJlbnRHcmFwaCl7aWYobnVsbCE9dGhpcy5jdXJyZW50UG9pbnQmJihudWxsPT10aGlzLnByZXZpZXdFbGVtZW50fHwiaGlkZGVuIiE9dGhpcy5wcmV2aWV3RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5KSl7dmFyIGI9dGhpcy5jdXJyZW50R3JhcGgudmlldy5zY2FsZSxjPXRoaXMuY3VycmVudEdyYXBoLnZpZXcudHJhbnNsYXRlO3RoaXMuZHJvcCh0aGlzLmN1cnJlbnRHcmFwaCxhLHRoaXMuY3VycmVudERyb3BUYXJnZXQsdGhpcy5jdXJyZW50UG9pbnQueC9iLWMueCx0aGlzLmN1cnJlbnRQb2ludC55L2ItYy55KX10aGlzLmRyYWdFeGl0KHRoaXMuY3VycmVudEdyYXBoKTt0aGlzLmN1cnJlbnRHcmFwaD1udWxsfXRoaXMuc3RvcERyYWcoKTt0aGlzLnJlbW92ZUxpc3RlbmVycygpO214RXZlbnQuY29uc3VtZShhKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXJzPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5ldmVudFNvdXJjZSYmKG14RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyh0aGlzLmV2ZW50U291cmNlLG51bGwsdGhpcy5tb3VzZU1vdmVIYW5kbGVyLHRoaXMubW91c2VVcEhhbmRsZXIpLHRoaXMuZXZlbnRTb3VyY2U9bnVsbCk7bXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsdGhpcy5tb3VzZU1vdmVIYW5kbGVyLHRoaXMubW91c2VVcEhhbmRsZXIpO3RoaXMubW91c2VVcEhhbmRsZXI9dGhpcy5tb3VzZU1vdmVIYW5kbGVyPW51bGx9OwpteERyYWdTb3VyY2UucHJvdG90eXBlLmRyYWdFbnRlcj1mdW5jdGlvbihhLGIpe2EuaXNNb3VzZURvd249ITA7YS5pc01vdXNlVHJpZ2dlcj1teEV2ZW50LmlzTW91c2VFdmVudChiKTt0aGlzLnByZXZpZXdFbGVtZW50PXRoaXMuY3JlYXRlUHJldmlld0VsZW1lbnQoYSk7bnVsbCE9dGhpcy5wcmV2aWV3RWxlbWVudCYmdGhpcy5jaGVja0V2ZW50U291cmNlJiZteENsaWVudC5JU19TVkcmJih0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHM9Im5vbmUiKTt0aGlzLmlzR3VpZGVzRW5hYmxlZCgpJiZudWxsIT10aGlzLnByZXZpZXdFbGVtZW50JiYodGhpcy5jdXJyZW50R3VpZGU9bmV3IG14R3VpZGUoYSxhLmdyYXBoSGFuZGxlci5nZXRHdWlkZVN0YXRlcygpKSk7dGhpcy5oaWdobGlnaHREcm9wVGFyZ2V0cyYmKHRoaXMuY3VycmVudEhpZ2hsaWdodD1uZXcgbXhDZWxsSGlnaGxpZ2h0KGEsbXhDb25zdGFudHMuRFJPUF9UQVJHRVRfQ09MT1IpKTthLmFkZExpc3RlbmVyKG14RXZlbnQuRklSRV9NT1VTRV9FVkVOVCwKdGhpcy5ldmVudENvbnN1bWVyKX07bXhEcmFnU291cmNlLnByb3RvdHlwZS5kcmFnRXhpdD1mdW5jdGlvbihhLGIpe3RoaXMuY3VycmVudFBvaW50PXRoaXMuY3VycmVudERyb3BUYXJnZXQ9bnVsbDthLmlzTW91c2VEb3duPSExO2EucmVtb3ZlTGlzdGVuZXIodGhpcy5ldmVudENvbnN1bWVyKTtudWxsIT10aGlzLnByZXZpZXdFbGVtZW50JiYobnVsbCE9dGhpcy5wcmV2aWV3RWxlbWVudC5wYXJlbnROb2RlJiZ0aGlzLnByZXZpZXdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wcmV2aWV3RWxlbWVudCksdGhpcy5wcmV2aWV3RWxlbWVudD1udWxsKTtudWxsIT10aGlzLmN1cnJlbnRHdWlkZSYmKHRoaXMuY3VycmVudEd1aWRlLmRlc3Ryb3koKSx0aGlzLmN1cnJlbnRHdWlkZT1udWxsKTtudWxsIT10aGlzLmN1cnJlbnRIaWdobGlnaHQmJih0aGlzLmN1cnJlbnRIaWdobGlnaHQuZGVzdHJveSgpLHRoaXMuY3VycmVudEhpZ2hsaWdodD1udWxsKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuZHJhZ092ZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1teFV0aWxzLmdldE9mZnNldChhLmNvbnRhaW5lciksZD1teFV0aWxzLmdldFNjcm9sbE9yaWdpbihhLmNvbnRhaW5lciksZT1teEV2ZW50LmdldENsaWVudFgoYiktYy54K2QueC1hLnBhbkR4LGM9bXhFdmVudC5nZXRDbGllbnRZKGIpLWMueStkLnktYS5wYW5EeTthLmF1dG9TY3JvbGwmJihudWxsPT10aGlzLmF1dG9zY3JvbGx8fHRoaXMuYXV0b3Njcm9sbCkmJmEuc2Nyb2xsUG9pbnRUb1Zpc2libGUoZSxjLGEuYXV0b0V4dGVuZCk7bnVsbCE9dGhpcy5jdXJyZW50SGlnaGxpZ2h0JiZhLmlzRHJvcEVuYWJsZWQoKSYmKHRoaXMuY3VycmVudERyb3BUYXJnZXQ9dGhpcy5nZXREcm9wVGFyZ2V0KGEsZSxjLGIpLGQ9YS5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5jdXJyZW50RHJvcFRhcmdldCksdGhpcy5jdXJyZW50SGlnaGxpZ2h0LmhpZ2hsaWdodChkKSk7aWYobnVsbCE9dGhpcy5wcmV2aWV3RWxlbWVudCl7bnVsbD09CnRoaXMucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZSYmKGEuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJldmlld0VsZW1lbnQpLHRoaXMucHJldmlld0VsZW1lbnQuc3R5bGUuekluZGV4PSIzIix0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpO3ZhciBkPXRoaXMuaXNHcmlkRW5hYmxlZCgpJiZhLmlzR3JpZEVuYWJsZWRFdmVudChiKSxmPSEwO2lmKG51bGwhPXRoaXMuY3VycmVudEd1aWRlJiZ0aGlzLmN1cnJlbnRHdWlkZS5pc0VuYWJsZWRGb3JFdmVudChiKSl2YXIgZj1wYXJzZUludCh0aGlzLnByZXZpZXdFbGVtZW50LnN0eWxlLndpZHRoKSxnPXBhcnNlSW50KHRoaXMucHJldmlld0VsZW1lbnQuc3R5bGUuaGVpZ2h0KSxmPW5ldyBteFJlY3RhbmdsZSgwLDAsZixnKSxjPW5ldyBteFBvaW50KGUsYyksYz10aGlzLmN1cnJlbnRHdWlkZS5tb3ZlKGYsYyxkLCEwKSxmPSExLGU9Yy54LGM9Yy55O2Vsc2UgaWYoZCl2YXIgZD1hLnZpZXcuc2NhbGUsCmc9YS52aWV3LnRyYW5zbGF0ZSxrPWEuZ3JpZFNpemUvMixlPShhLnNuYXAoZS9kLWcueC1rKStnLngpKmQsYz0oYS5zbmFwKGMvZC1nLnktaykrZy55KSpkO251bGwhPXRoaXMuY3VycmVudEd1aWRlJiZmJiZ0aGlzLmN1cnJlbnRHdWlkZS5oaWRlKCk7bnVsbCE9dGhpcy5wcmV2aWV3T2Zmc2V0JiYoZSs9dGhpcy5wcmV2aWV3T2Zmc2V0LngsYys9dGhpcy5wcmV2aWV3T2Zmc2V0LnkpO3RoaXMucHJldmlld0VsZW1lbnQuc3R5bGUubGVmdD1NYXRoLnJvdW5kKGUpKyJweCI7dGhpcy5wcmV2aWV3RWxlbWVudC5zdHlsZS50b3A9TWF0aC5yb3VuZChjKSsicHgiO3RoaXMucHJldmlld0VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSJ9dGhpcy5jdXJyZW50UG9pbnQ9bmV3IG14UG9pbnQoZSxjKX07Cm14RHJhZ1NvdXJjZS5wcm90b3R5cGUuZHJvcD1mdW5jdGlvbihhLGIsYyxkLGUpe3RoaXMuZHJvcEhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyJoaWRkZW4iIT1hLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5JiZhLmNvbnRhaW5lci5mb2N1cygpfTtmdW5jdGlvbiBteFRvb2xiYXIoYSl7dGhpcy5jb250YWluZXI9YX1teFRvb2xiYXIucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlO214VG9vbGJhci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhUb29sYmFyO214VG9vbGJhci5wcm90b3R5cGUuY29udGFpbmVyPW51bGw7bXhUb29sYmFyLnByb3RvdHlwZS5lbmFibGVkPSEwO214VG9vbGJhci5wcm90b3R5cGUubm9SZXNldD0hMTtteFRvb2xiYXIucHJvdG90eXBlLnVwZGF0ZURlZmF1bHRNb2RlPSEwOwpteFRvb2xiYXIucHJvdG90eXBlLmFkZEl0ZW09ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobnVsbCE9Yj8iaW1nIjoiYnV0dG9uIiksaz1lfHwobnVsbCE9Zj8ibXhUb29sYmFyTW9kZSI6Im14VG9vbGJhckl0ZW0iKTtnLmNsYXNzTmFtZT1rO2cuc2V0QXR0cmlidXRlKCJzcmMiLGIpO251bGwhPWEmJihudWxsIT1iP2cuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYSk6bXhVdGlscy53cml0ZShnLGEpKTt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChnKTtudWxsIT1jJiYobXhFdmVudC5hZGRMaXN0ZW5lcihnLCJjbGljayIsYyksbXhDbGllbnQuSVNfVE9VQ0gmJm14RXZlbnQuYWRkTGlzdGVuZXIoZywidG91Y2hlbmQiLGMpKTthPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWQ/Zy5zZXRBdHRyaWJ1dGUoInNyYyIsYik6Zy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiJ9KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZywKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9ZD9nLnNldEF0dHJpYnV0ZSgic3JjIixkKTpnLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iZ3JheSI7aWYobnVsbCE9Zil7bnVsbD09dGhpcy5tZW51JiYodGhpcy5tZW51PW5ldyBteFBvcHVwTWVudSx0aGlzLm1lbnUuaW5pdCgpKTt2YXIgYj10aGlzLmN1cnJlbnRJbWc7dGhpcy5tZW51LmlzTWVudVNob3dpbmcoKSYmdGhpcy5tZW51LmhpZGVNZW51KCk7YiE9ZyYmKHRoaXMuY3VycmVudEltZz1nLHRoaXMubWVudS5mYWN0b3J5TWV0aG9kPWYsYj1uZXcgbXhQb2ludChnLm9mZnNldExlZnQsZy5vZmZzZXRUb3ArZy5vZmZzZXRIZWlnaHQpLHRoaXMubWVudS5wb3B1cChiLngsYi55LG51bGwsYSksdGhpcy5tZW51LmlzTWVudVNob3dpbmcoKSYmKGcuY2xhc3NOYW1lPWsrIlNlbGVjdGVkIix0aGlzLm1lbnUuaGlkZU1lbnU9ZnVuY3Rpb24oKXtteFBvcHVwTWVudS5wcm90b3R5cGUuaGlkZU1lbnUuYXBwbHkodGhpcyk7CmcuY2xhc3NOYW1lPWs7dGhpcy5jdXJyZW50SW1nPW51bGx9KSl9fSksbnVsbCxhKTtteEV2ZW50LmFkZExpc3RlbmVyKGcsIm1vdXNlb3V0IixhKTtyZXR1cm4gZ307bXhUb29sYmFyLnByb3RvdHlwZS5hZGRDb21ibz1mdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLnN0eWxlLmRpc3BsYXk9ImlubGluZSI7Yi5jbGFzc05hbWU9Im14VG9vbGJhckNvbWJvQ29udGFpbmVyIjt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtjLmNsYXNzTmFtZT1hfHwibXhUb29sYmFyQ29tYm8iO2IuYXBwZW5kQ2hpbGQoYyk7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoYik7cmV0dXJuIGN9OwpteFRvb2xiYXIucHJvdG90eXBlLmFkZEFjdGlvbkNvbWJvPWZ1bmN0aW9uKGEsYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7Yy5jbGFzc05hbWU9Ynx8Im14VG9vbGJhckNvbWJvIjt0aGlzLmFkZE9wdGlvbihjLGEsbnVsbCk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjaGFuZ2UiLGZ1bmN0aW9uKGEpe3ZhciBiPWMub3B0aW9uc1tjLnNlbGVjdGVkSW5kZXhdO2Muc2VsZWN0ZWRJbmRleD0wO251bGwhPWIuZnVuY3QmJmIuZnVuY3QoYSl9KTt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjKTtyZXR1cm4gY307bXhUb29sYmFyLnByb3RvdHlwZS5hZGRPcHRpb249ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpO214VXRpbHMud3JpdGVsbihkLGIpOyJmdW5jdGlvbiI9PXR5cGVvZiBjP2QuZnVuY3Q9YzpkLnNldEF0dHJpYnV0ZSgidmFsdWUiLGMpO2EuYXBwZW5kQ2hpbGQoZCk7cmV0dXJuIGR9OwpteFRvb2xiYXIucHJvdG90eXBlLmFkZFN3aXRjaE1vZGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtmLmluaXRpYWxDbGFzc05hbWU9ZXx8Im14VG9vbGJhck1vZGUiO2YuY2xhc3NOYW1lPWYuaW5pdGlhbENsYXNzTmFtZTtmLnNldEF0dHJpYnV0ZSgic3JjIixiKTtmLmFsdEljb249ZDtudWxsIT1hJiZmLnNldEF0dHJpYnV0ZSgidGl0bGUiLGEpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2E9dGhpcy5zZWxlY3RlZE1vZGUuYWx0SWNvbjtudWxsIT1hPyh0aGlzLnNlbGVjdGVkTW9kZS5hbHRJY29uPXRoaXMuc2VsZWN0ZWRNb2RlLmdldEF0dHJpYnV0ZSgic3JjIiksdGhpcy5zZWxlY3RlZE1vZGUuc2V0QXR0cmlidXRlKCJzcmMiLGEpKTp0aGlzLnNlbGVjdGVkTW9kZS5jbGFzc05hbWU9dGhpcy5zZWxlY3RlZE1vZGUuaW5pdGlhbENsYXNzTmFtZTt0aGlzLnVwZGF0ZURlZmF1bHRNb2RlJiYKKHRoaXMuZGVmYXVsdE1vZGU9Zik7dGhpcy5zZWxlY3RlZE1vZGU9ZjthPWYuYWx0SWNvbjtudWxsIT1hPyhmLmFsdEljb249Zi5nZXRBdHRyaWJ1dGUoInNyYyIpLGYuc2V0QXR0cmlidXRlKCJzcmMiLGEpKTpmLmNsYXNzTmFtZT1mLmluaXRpYWxDbGFzc05hbWUrIlNlbGVjdGVkIjt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNFTEVDVCkpO2MoKX0pKTt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChmKTtudWxsPT10aGlzLmRlZmF1bHRNb2RlJiYodGhpcy5kZWZhdWx0TW9kZT1mLHRoaXMuc2VsZWN0TW9kZShmKSxjKCkpO3JldHVybiBmfTsKbXhUb29sYmFyLnByb3RvdHlwZS5hZGRNb2RlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtmPW51bGwhPWY/ZjohMDt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG51bGwhPWI/ImltZyI6ImJ1dHRvbiIpO2cuaW5pdGlhbENsYXNzTmFtZT1lfHwibXhUb29sYmFyTW9kZSI7Zy5jbGFzc05hbWU9Zy5pbml0aWFsQ2xhc3NOYW1lO2cuc2V0QXR0cmlidXRlKCJzcmMiLGIpO2cuYWx0SWNvbj1kO251bGwhPWEmJmcuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYSk7dGhpcy5lbmFibGVkJiZmJiYobXhFdmVudC5hZGRMaXN0ZW5lcihnLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RNb2RlKGcsYyk7dGhpcy5ub1Jlc2V0PSExfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoZywiZGJsY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc2VsZWN0TW9kZShnLGMpO3RoaXMubm9SZXNldD0hMH0pKSxudWxsPT10aGlzLmRlZmF1bHRNb2RlJiYKKHRoaXMuZGVmYXVsdE1vZGU9Zyx0aGlzLmRlZmF1bHRGdW5jdGlvbj1jLHRoaXMuc2VsZWN0TW9kZShnLGMpKSk7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZyk7cmV0dXJuIGd9OwpteFRvb2xiYXIucHJvdG90eXBlLnNlbGVjdE1vZGU9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLnNlbGVjdGVkTW9kZSE9YSl7aWYobnVsbCE9dGhpcy5zZWxlY3RlZE1vZGUpe3ZhciBjPXRoaXMuc2VsZWN0ZWRNb2RlLmFsdEljb247bnVsbCE9Yz8odGhpcy5zZWxlY3RlZE1vZGUuYWx0SWNvbj10aGlzLnNlbGVjdGVkTW9kZS5nZXRBdHRyaWJ1dGUoInNyYyIpLHRoaXMuc2VsZWN0ZWRNb2RlLnNldEF0dHJpYnV0ZSgic3JjIixjKSk6dGhpcy5zZWxlY3RlZE1vZGUuY2xhc3NOYW1lPXRoaXMuc2VsZWN0ZWRNb2RlLmluaXRpYWxDbGFzc05hbWV9dGhpcy5zZWxlY3RlZE1vZGU9YTtjPXRoaXMuc2VsZWN0ZWRNb2RlLmFsdEljb247bnVsbCE9Yz8odGhpcy5zZWxlY3RlZE1vZGUuYWx0SWNvbj10aGlzLnNlbGVjdGVkTW9kZS5nZXRBdHRyaWJ1dGUoInNyYyIpLHRoaXMuc2VsZWN0ZWRNb2RlLnNldEF0dHJpYnV0ZSgic3JjIixjKSk6dGhpcy5zZWxlY3RlZE1vZGUuY2xhc3NOYW1lPXRoaXMuc2VsZWN0ZWRNb2RlLmluaXRpYWxDbGFzc05hbWUrCiJTZWxlY3RlZCI7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TRUxFQ1QsImZ1bmN0aW9uIixiKSl9fTtteFRvb2xiYXIucHJvdG90eXBlLnJlc2V0TW9kZT1mdW5jdGlvbihhKXshYSYmdGhpcy5ub1Jlc2V0fHx0aGlzLnNlbGVjdGVkTW9kZT09dGhpcy5kZWZhdWx0TW9kZXx8dGhpcy5zZWxlY3RNb2RlKHRoaXMuZGVmYXVsdE1vZGUsdGhpcy5kZWZhdWx0RnVuY3Rpb24pfTtteFRvb2xiYXIucHJvdG90eXBlLmFkZFNlcGFyYXRvcj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRJdGVtKG51bGwsYSxudWxsKX07bXhUb29sYmFyLnByb3RvdHlwZS5hZGRCcmVhaz1mdW5jdGlvbigpe214VXRpbHMuYnIodGhpcy5jb250YWluZXIpfTsKbXhUb29sYmFyLnByb3RvdHlwZS5hZGRMaW5lPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaHIiKTthLnN0eWxlLm1hcmdpblJpZ2h0PSI2cHgiO2Euc2V0QXR0cmlidXRlKCJzaXplIiwiMSIpO3RoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGEpfTtteFRvb2xiYXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtteEV2ZW50LnJlbGVhc2UodGhpcy5jb250YWluZXIpO3RoaXMuc2VsZWN0ZWRNb2RlPXRoaXMuZGVmYXVsdEZ1bmN0aW9uPXRoaXMuZGVmYXVsdE1vZGU9dGhpcy5jb250YWluZXI9bnVsbDtudWxsIT10aGlzLm1lbnUmJnRoaXMubWVudS5kZXN0cm95KCl9O2Z1bmN0aW9uIG14VW5kb2FibGVFZGl0KGEsYil7dGhpcy5zb3VyY2U9YTt0aGlzLmNoYW5nZXM9W107dGhpcy5zaWduaWZpY2FudD1udWxsIT1iP2I6ITB9bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLnNvdXJjZT1udWxsOwpteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUuY2hhbmdlcz1udWxsO214VW5kb2FibGVFZGl0LnByb3RvdHlwZS5zaWduaWZpY2FudD1udWxsO214VW5kb2FibGVFZGl0LnByb3RvdHlwZS51bmRvbmU9ITE7bXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLnJlZG9uZT0hMTtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLmNoYW5nZXMubGVuZ3RofTtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUuaXNTaWduaWZpY2FudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpZ25pZmljYW50fTtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3RoaXMuY2hhbmdlcy5wdXNoKGEpfTtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUubm90aWZ5PWZ1bmN0aW9uKCl7fTtteFVuZG9hYmxlRWRpdC5wcm90b3R5cGUuZGllPWZ1bmN0aW9uKCl7fTsKbXhVbmRvYWJsZUVkaXQucHJvdG90eXBlLnVuZG89ZnVuY3Rpb24oKXtpZighdGhpcy51bmRvbmUpe3RoaXMuc291cmNlLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNUQVJUX0VESVQpKTtmb3IodmFyIGE9dGhpcy5jaGFuZ2VzLmxlbmd0aC0xOzA8PWE7YS0tKXt2YXIgYj10aGlzLmNoYW5nZXNbYV07bnVsbCE9Yi5leGVjdXRlP2IuZXhlY3V0ZSgpOm51bGwhPWIudW5kbyYmYi51bmRvKCk7dGhpcy5zb3VyY2UuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRVhFQ1VURUQsImNoYW5nZSIsYikpfXRoaXMudW5kb25lPSEwO3RoaXMucmVkb25lPSExO3RoaXMuc291cmNlLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVORF9FRElUKSl9dGhpcy5ub3RpZnkoKX07Cm14VW5kb2FibGVFZGl0LnByb3RvdHlwZS5yZWRvPWZ1bmN0aW9uKCl7aWYoIXRoaXMucmVkb25lKXt0aGlzLnNvdXJjZS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TVEFSVF9FRElUKSk7Zm9yKHZhciBhPXRoaXMuY2hhbmdlcy5sZW5ndGgsYj0wO2I8YTtiKyspe3ZhciBjPXRoaXMuY2hhbmdlc1tiXTtudWxsIT1jLmV4ZWN1dGU/Yy5leGVjdXRlKCk6bnVsbCE9Yy5yZWRvJiZjLnJlZG8oKTt0aGlzLnNvdXJjZS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5FWEVDVVRFRCwiY2hhbmdlIixjKSl9dGhpcy51bmRvbmU9ITE7dGhpcy5yZWRvbmU9ITA7dGhpcy5zb3VyY2UuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRU5EX0VESVQpKX10aGlzLm5vdGlmeSgpfTtmdW5jdGlvbiBteFVuZG9NYW5hZ2VyKGEpe3RoaXMuc2l6ZT1udWxsIT1hP2E6MTAwO3RoaXMuY2xlYXIoKX1teFVuZG9NYW5hZ2VyLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTsKbXhVbmRvTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhVbmRvTWFuYWdlcjtteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5zaXplPW51bGw7bXhVbmRvTWFuYWdlci5wcm90b3R5cGUuaGlzdG9yeT1udWxsO214VW5kb01hbmFnZXIucHJvdG90eXBlLmluZGV4T2ZOZXh0QWRkPTA7bXhVbmRvTWFuYWdlci5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLmhpc3RvcnkubGVuZ3RofTtteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuaGlzdG9yeT1bXTt0aGlzLmluZGV4T2ZOZXh0QWRkPTA7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DTEVBUikpfTtteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5jYW5VbmRvPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5pbmRleE9mTmV4dEFkZH07Cm14VW5kb01hbmFnZXIucHJvdG90eXBlLnVuZG89ZnVuY3Rpb24oKXtmb3IoOzA8dGhpcy5pbmRleE9mTmV4dEFkZDspe3ZhciBhPXRoaXMuaGlzdG9yeVstLXRoaXMuaW5kZXhPZk5leHRBZGRdO2EudW5kbygpO2lmKGEuaXNTaWduaWZpY2FudCgpKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlVORE8sImVkaXQiLGEpKTticmVha319fTtteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS5jYW5SZWRvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5kZXhPZk5leHRBZGQ8dGhpcy5oaXN0b3J5Lmxlbmd0aH07Cm14VW5kb01hbmFnZXIucHJvdG90eXBlLnJlZG89ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5oaXN0b3J5Lmxlbmd0aDt0aGlzLmluZGV4T2ZOZXh0QWRkPGE7KXt2YXIgYj10aGlzLmhpc3RvcnlbdGhpcy5pbmRleE9mTmV4dEFkZCsrXTtiLnJlZG8oKTtpZihiLmlzU2lnbmlmaWNhbnQoKSl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRURPLCJlZGl0IixiKSk7YnJlYWt9fX07bXhVbmRvTWFuYWdlci5wcm90b3R5cGUudW5kb2FibGVFZGl0SGFwcGVuZWQ9ZnVuY3Rpb24oYSl7dGhpcy50cmltKCk7MDx0aGlzLnNpemUmJnRoaXMuc2l6ZT09dGhpcy5oaXN0b3J5Lmxlbmd0aCYmdGhpcy5oaXN0b3J5LnNoaWZ0KCk7dGhpcy5oaXN0b3J5LnB1c2goYSk7dGhpcy5pbmRleE9mTmV4dEFkZD10aGlzLmhpc3RvcnkubGVuZ3RoO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQURELCJlZGl0IixhKSl9OwpteFVuZG9NYW5hZ2VyLnByb3RvdHlwZS50cmltPWZ1bmN0aW9uKCl7aWYodGhpcy5oaXN0b3J5Lmxlbmd0aD50aGlzLmluZGV4T2ZOZXh0QWRkKWZvcih2YXIgYT10aGlzLmhpc3Rvcnkuc3BsaWNlKHRoaXMuaW5kZXhPZk5leHRBZGQsdGhpcy5oaXN0b3J5Lmxlbmd0aC10aGlzLmluZGV4T2ZOZXh0QWRkKSxiPTA7YjxhLmxlbmd0aDtiKyspYVtiXS5kaWUoKX07dmFyIG14VXJsQ29udmVydGVyPWZ1bmN0aW9uKCl7fTtteFVybENvbnZlcnRlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFVybENvbnZlcnRlci5wcm90b3R5cGUuYmFzZVVybD1udWxsO214VXJsQ29udmVydGVyLnByb3RvdHlwZS5iYXNlRG9tYWluPW51bGw7Cm14VXJsQ29udmVydGVyLnByb3RvdHlwZS51cGRhdGVCYXNlVXJsPWZ1bmN0aW9uKCl7dGhpcy5iYXNlRG9tYWluPWxvY2F0aW9uLnByb3RvY29sKyIvLyIrbG9jYXRpb24uaG9zdDt0aGlzLmJhc2VVcmw9dGhpcy5iYXNlRG9tYWluK2xvY2F0aW9uLnBhdGhuYW1lO3ZhciBhPXRoaXMuYmFzZVVybC5sYXN0SW5kZXhPZigiLyIpOzA8YSYmKHRoaXMuYmFzZVVybD10aGlzLmJhc2VVcmwuc3Vic3RyaW5nKDAsYSsxKSl9O214VXJsQ29udmVydGVyLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteFVybENvbnZlcnRlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhVcmxDb252ZXJ0ZXIucHJvdG90eXBlLmdldEJhc2VVcmw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYXNlVXJsfTtteFVybENvbnZlcnRlci5wcm90b3R5cGUuc2V0QmFzZVVybD1mdW5jdGlvbihhKXt0aGlzLmJhc2VVcmw9YX07Cm14VXJsQ29udmVydGVyLnByb3RvdHlwZS5nZXRCYXNlRG9tYWluPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmFzZURvbWFpbn07bXhVcmxDb252ZXJ0ZXIucHJvdG90eXBlLnNldEJhc2VEb21haW49ZnVuY3Rpb24oYSl7dGhpcy5iYXNlRG9tYWluPWF9O214VXJsQ29udmVydGVyLnByb3RvdHlwZS5pc1JlbGF0aXZlVXJsPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYiLy8iIT1hLnN1YnN0cmluZygwLDIpJiYiaHR0cDovLyIhPWEuc3Vic3RyaW5nKDAsNykmJiJodHRwczovLyIhPWEuc3Vic3RyaW5nKDAsOCkmJiJkYXRhOmltYWdlIiE9YS5zdWJzdHJpbmcoMCwxMCkmJiJmaWxlOi8vIiE9YS5zdWJzdHJpbmcoMCw3KX07Cm14VXJsQ29udmVydGVyLnByb3RvdHlwZS5jb252ZXJ0PWZ1bmN0aW9uKGEpe3RoaXMuaXNFbmFibGVkKCkmJnRoaXMuaXNSZWxhdGl2ZVVybChhKSYmKG51bGw9PXRoaXMuZ2V0QmFzZVVybCgpJiZ0aGlzLnVwZGF0ZUJhc2VVcmwoKSxhPSIvIj09YS5jaGFyQXQoMCk/dGhpcy5nZXRCYXNlRG9tYWluKCkrYTp0aGlzLmdldEJhc2VVcmwoKSthKTtyZXR1cm4gYX07CmZ1bmN0aW9uIG14UGFubmluZ01hbmFnZXIoYSl7dGhpcy50aHJlYWQ9bnVsbDt0aGlzLmFjdGl2ZT0hMTt0aGlzLmR5PXRoaXMuZHg9dGhpcy50MHk9dGhpcy50MHg9dGhpcy50ZHk9dGhpcy50ZHg9MDt0aGlzLnNjcm9sbGJhcnM9ITE7dGhpcy5zY3JvbGxUb3A9dGhpcy5zY3JvbGxMZWZ0PTA7dGhpcy5tb3VzZUxpc3RlbmVyPXttb3VzZURvd246ZnVuY3Rpb24oYSxiKXt9LG1vdXNlTW92ZTpmdW5jdGlvbihhLGIpe30sbW91c2VVcDpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3RoaXMuYWN0aXZlJiZ0aGlzLnN0b3AoKX0pfTthLmFkZE1vdXNlTGlzdGVuZXIodGhpcy5tb3VzZUxpc3RlbmVyKTt0aGlzLm1vdXNlVXBMaXN0ZW5lcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aXZlJiZ0aGlzLnN0b3AoKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoZG9jdW1lbnQsIm1vdXNldXAiLHRoaXMubW91c2VVcExpc3RlbmVyKTt2YXIgYj1teFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oKXt0aGlzLnNjcm9sbGJhcnM9bXhVdGlscy5oYXNTY3JvbGxiYXJzKGEuY29udGFpbmVyKTt0aGlzLnNjcm9sbExlZnQ9YS5jb250YWluZXIuc2Nyb2xsTGVmdDt0aGlzLnNjcm9sbFRvcD1hLmNvbnRhaW5lci5zY3JvbGxUb3A7cmV0dXJuIHdpbmRvdy5zZXRJbnRlcnZhbChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudGR4LT10aGlzLmR4O3RoaXMudGR5LT10aGlzLmR5O3RoaXMuc2Nyb2xsYmFycz8oYS5wYW5HcmFwaCgtYS5jb250YWluZXIuc2Nyb2xsTGVmdC1NYXRoLmNlaWwodGhpcy5keCksLWEuY29udGFpbmVyLnNjcm9sbFRvcC1NYXRoLmNlaWwodGhpcy5keSkpLGEucGFuRHg9dGhpcy5zY3JvbGxMZWZ0LWEuY29udGFpbmVyLnNjcm9sbExlZnQsYS5wYW5EeT10aGlzLnNjcm9sbFRvcC1hLmNvbnRhaW5lci5zY3JvbGxUb3AsYS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5QQU4pKSk6YS5wYW5HcmFwaCh0aGlzLmdldER4KCksCnRoaXMuZ2V0RHkoKSl9KSx0aGlzLmRlbGF5KX0pO3RoaXMuaXNBY3RpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gYWN0aXZlfTt0aGlzLmdldER4PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucm91bmQodGhpcy50ZHgpfTt0aGlzLmdldER5PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucm91bmQodGhpcy50ZHkpfTt0aGlzLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy50MHg9YS52aWV3LnRyYW5zbGF0ZS54O3RoaXMudDB5PWEudmlldy50cmFuc2xhdGUueTt0aGlzLmFjdGl2ZT0hMH07dGhpcy5wYW5Ubz1mdW5jdGlvbihjLGQsZSxmKXt0aGlzLmFjdGl2ZXx8dGhpcy5zdGFydCgpO3RoaXMuc2Nyb2xsTGVmdD1hLmNvbnRhaW5lci5zY3JvbGxMZWZ0O3RoaXMuc2Nyb2xsVG9wPWEuY29udGFpbmVyLnNjcm9sbFRvcDt2YXIgZz1hLmNvbnRhaW5lcjt0aGlzLmR4PWMrKG51bGwhPWU/ZTowKS1nLnNjcm9sbExlZnQtZy5jbGllbnRXaWR0aDt0aGlzLmR4PTA+dGhpcy5keCYmTWF0aC5hYnModGhpcy5keCk8CnRoaXMuYm9yZGVyP3RoaXMuYm9yZGVyK3RoaXMuZHg6dGhpcy5oYW5kbGVNb3VzZU91dD9NYXRoLm1heCh0aGlzLmR4LDApOjA7MD09dGhpcy5keCYmKHRoaXMuZHg9Yy1nLnNjcm9sbExlZnQsdGhpcy5keD0wPHRoaXMuZHgmJnRoaXMuZHg8dGhpcy5ib3JkZXI/dGhpcy5keC10aGlzLmJvcmRlcjp0aGlzLmhhbmRsZU1vdXNlT3V0P01hdGgubWluKDAsdGhpcy5keCk6MCk7dGhpcy5keT1kKyhudWxsIT1mP2Y6MCktZy5zY3JvbGxUb3AtZy5jbGllbnRIZWlnaHQ7dGhpcy5keT0wPnRoaXMuZHkmJk1hdGguYWJzKHRoaXMuZHkpPHRoaXMuYm9yZGVyP3RoaXMuYm9yZGVyK3RoaXMuZHk6dGhpcy5oYW5kbGVNb3VzZU91dD9NYXRoLm1heCh0aGlzLmR5LDApOjA7MD09dGhpcy5keSYmKHRoaXMuZHk9ZC1nLnNjcm9sbFRvcCx0aGlzLmR5PTA8dGhpcy5keSYmdGhpcy5keTx0aGlzLmJvcmRlcj90aGlzLmR5LXRoaXMuYm9yZGVyOnRoaXMuaGFuZGxlTW91c2VPdXQ/TWF0aC5taW4oMCx0aGlzLmR5KToKMCk7MCE9dGhpcy5keHx8MCE9dGhpcy5keT8odGhpcy5keCo9dGhpcy5kYW1wZXIsdGhpcy5keSo9dGhpcy5kYW1wZXIsbnVsbD09dGhpcy50aHJlYWQmJih0aGlzLnRocmVhZD1iKCkpKTpudWxsIT10aGlzLnRocmVhZCYmKHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMudGhyZWFkKSx0aGlzLnRocmVhZD1udWxsKX07dGhpcy5zdG9wPWZ1bmN0aW9uKCl7aWYodGhpcy5hY3RpdmUpaWYodGhpcy5hY3RpdmU9ITEsbnVsbCE9dGhpcy50aHJlYWQmJih3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRocmVhZCksdGhpcy50aHJlYWQ9bnVsbCksdGhpcy50ZHk9dGhpcy50ZHg9MCx0aGlzLnNjcm9sbGJhcnMpYS5wYW5EeD0wLGEucGFuRHk9MCxhLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlBBTikpO2Vsc2V7dmFyIGI9YS5wYW5EeCxkPWEucGFuRHk7aWYoMCE9Ynx8MCE9ZClhLnBhbkdyYXBoKDAsMCksYS52aWV3LnNldFRyYW5zbGF0ZSh0aGlzLnQweCtiL2Eudmlldy5zY2FsZSwKdGhpcy50MHkrZC9hLnZpZXcuc2NhbGUpfX07dGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7YS5yZW1vdmVNb3VzZUxpc3RlbmVyKHRoaXMubW91c2VMaXN0ZW5lcik7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwibW91c2V1cCIsdGhpcy5tb3VzZVVwTGlzdGVuZXIpfX1teFBhbm5pbmdNYW5hZ2VyLnByb3RvdHlwZS5kYW1wZXI9MS82O214UGFubmluZ01hbmFnZXIucHJvdG90eXBlLmRlbGF5PTEwO214UGFubmluZ01hbmFnZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlT3V0PSEwO214UGFubmluZ01hbmFnZXIucHJvdG90eXBlLmJvcmRlcj0wO2Z1bmN0aW9uIG14UG9wdXBNZW51KGEpe3RoaXMuZmFjdG9yeU1ldGhvZD1hO251bGwhPWEmJnRoaXMuaW5pdCgpfW14UG9wdXBNZW51LnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteFBvcHVwTWVudS5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhQb3B1cE1lbnU7Cm14UG9wdXBNZW51LnByb3RvdHlwZS5zdWJtZW51SW1hZ2U9bXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL3N1Ym1lbnUuZ2lmIjtteFBvcHVwTWVudS5wcm90b3R5cGUuekluZGV4PTEwMDA2O214UG9wdXBNZW51LnByb3RvdHlwZS5mYWN0b3J5TWV0aG9kPW51bGw7bXhQb3B1cE1lbnUucHJvdG90eXBlLnVzZUxlZnRCdXR0b25Gb3JQb3B1cD0hMTtteFBvcHVwTWVudS5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFBvcHVwTWVudS5wcm90b3R5cGUuaXRlbUNvdW50PTA7bXhQb3B1cE1lbnUucHJvdG90eXBlLmF1dG9FeHBhbmQ9ITE7bXhQb3B1cE1lbnUucHJvdG90eXBlLnNtYXJ0U2VwYXJhdG9ycz0hMTtteFBvcHVwTWVudS5wcm90b3R5cGUubGFiZWxzPSEwOwpteFBvcHVwTWVudS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3RoaXMudGFibGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTt0aGlzLnRhYmxlLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnUiO3RoaXMudGJvZHk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKTt0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRoaXMudGJvZHkpO3RoaXMuZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3RoaXMuZGl2LmNsYXNzTmFtZT0ibXhQb3B1cE1lbnUiO3RoaXMuZGl2LnN0eWxlLmRpc3BsYXk9ImlubGluZSI7dGhpcy5kaXYuc3R5bGUuekluZGV4PXRoaXMuekluZGV4O3RoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMudGFibGUpO214RXZlbnQuZGlzYWJsZUNvbnRleHRNZW51KHRoaXMuZGl2KX07bXhQb3B1cE1lbnUucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9OwpteFBvcHVwTWVudS5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhQb3B1cE1lbnUucHJvdG90eXBlLmlzUG9wdXBUcmlnZ2VyPWZ1bmN0aW9uKGEpe3JldHVybiBhLmlzUG9wdXBUcmlnZ2VyKCl8fHRoaXMudXNlTGVmdEJ1dHRvbkZvclBvcHVwJiZteEV2ZW50LmlzTGVmdE1vdXNlQnV0dG9uKGEuZ2V0RXZlbnQoKSl9OwpteFBvcHVwTWVudS5wcm90b3R5cGUuYWRkSXRlbT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2Q9ZHx8dGhpczt0aGlzLml0ZW1Db3VudCsrO2Qud2lsbEFkZFNlcGFyYXRvciYmKGQuY29udGFpbnNJdGVtcyYmdGhpcy5hZGRTZXBhcmF0b3IoZCwhMCksZC53aWxsQWRkU2VwYXJhdG9yPSExKTtkLmNvbnRhaW5zSXRlbXM9ITA7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTtsLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJdGVtIjt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO20uY2xhc3NOYW1lPSJteFBvcHVwTWVudUljb24iO251bGwhPWI/KGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIiksZS5zcmM9YixtLmFwcGVuZENoaWxkKGUpKTpudWxsIT1lJiYoYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxiLmNsYXNzTmFtZT1lLG0uYXBwZW5kQ2hpbGQoYikpO2wuYXBwZW5kQ2hpbGQobSk7dGhpcy5sYWJlbHMmJihtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIiksCm0uY2xhc3NOYW1lPSJteFBvcHVwTWVudUl0ZW0iKyhudWxsPT1mfHxmPyIiOiIgbXhEaXNhYmxlZCIpLG14VXRpbHMud3JpdGUobSxhKSxtLmFsaWduPSJsZWZ0IixsLmFwcGVuZENoaWxkKG0pLGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKSxhLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJdGVtIisobnVsbD09Znx8Zj8iIjoiIG14RGlzYWJsZWQiKSxhLnN0eWxlLnBhZGRpbmdSaWdodD0iNnB4IixhLnN0eWxlLnRleHRBbGlnbj0icmlnaHQiLGwuYXBwZW5kQ2hpbGQoYSksbnVsbD09ZC5kaXYmJnRoaXMuY3JlYXRlU3VibWVudShkKSk7ZC50Ym9keS5hcHBlbmRDaGlsZChsKTtpZigwIT1nJiYwIT1mKXt2YXIgbj1udWxsO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZXZlbnRSZWNlaXZlcj1sO2QuYWN0aXZlUm93IT1sJiZkLmFjdGl2ZVJvdyE9ZCYmKG51bGwhPWQuYWN0aXZlUm93JiZudWxsIT1kLmFjdGl2ZVJvdy5kaXYucGFyZW50Tm9kZSYmCnRoaXMuaGlkZVN1Ym1lbnUoZCksbnVsbCE9bC5kaXYmJih0aGlzLnNob3dTdWJtZW51KGQsbCksZC5hY3RpdmVSb3c9bCkpO251bGw9PWRvY3VtZW50LnNlbGVjdGlvbnx8IW14Q2xpZW50LklTX1FVSVJLUyYmOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwobj1kb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSk7bXhFdmVudC5jb25zdW1lKGEpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ZC5hY3RpdmVSb3chPWwmJmQuYWN0aXZlUm93IT1kJiYobnVsbCE9ZC5hY3RpdmVSb3cmJm51bGwhPWQuYWN0aXZlUm93LmRpdi5wYXJlbnROb2RlJiZ0aGlzLmhpZGVTdWJtZW51KGQpLHRoaXMuYXV0b0V4cGFuZCYmbnVsbCE9bC5kaXYmJih0aGlzLnNob3dTdWJtZW51KGQsbCksZC5hY3RpdmVSb3c9bCkpO2t8fChsLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJdGVtSG92ZXIiKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKHRoaXMuZXZlbnRSZWNlaXZlcj09Cmwpe2QuYWN0aXZlUm93IT1sJiZ0aGlzLmhpZGVNZW51KCk7aWYobnVsbCE9bil7dHJ5e24uc2VsZWN0KCl9Y2F0Y2gocSl7fW49bnVsbH1udWxsIT1jJiZjKGEpfXRoaXMuZXZlbnRSZWNlaXZlcj1udWxsO214RXZlbnQuY29uc3VtZShhKX0pKTtrfHxteEV2ZW50LmFkZExpc3RlbmVyKGwsIm1vdXNlb3V0IixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtsLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJdGVtIn0pKX1yZXR1cm4gbH07bXhQb3B1cE1lbnUucHJvdG90eXBlLmFkZENoZWNrbWFyaz1mdW5jdGlvbihhLGIpe3ZhciBjPWEuZmlyc3RDaGlsZC5uZXh0U2libGluZztjLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCciK2IrIicpIjtjLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCI7Yy5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249IjJweCA1MCUifTsKbXhQb3B1cE1lbnUucHJvdG90eXBlLmNyZWF0ZVN1Ym1lbnU9ZnVuY3Rpb24oYSl7YS50YWJsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0YWJsZSIpO2EudGFibGUuY2xhc3NOYW1lPSJteFBvcHVwTWVudSI7YS50Ym9keT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0Ym9keSIpO2EudGFibGUuYXBwZW5kQ2hpbGQoYS50Ym9keSk7YS5kaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7YS5kaXYuY2xhc3NOYW1lPSJteFBvcHVwTWVudSI7YS5kaXYuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjthLmRpdi5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiO2EuZGl2LnN0eWxlLnpJbmRleD10aGlzLnpJbmRleDthLmRpdi5hcHBlbmRDaGlsZChhLnRhYmxlKTt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtiLnNldEF0dHJpYnV0ZSgic3JjIix0aGlzLnN1Ym1lbnVJbWFnZSk7dGQ9YS5maXJzdENoaWxkLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nO3RkLmFwcGVuZENoaWxkKGIpfTsKbXhQb3B1cE1lbnUucHJvdG90eXBlLnNob3dTdWJtZW51PWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9Yi5kaXYpe2IuZGl2LnN0eWxlLmxlZnQ9YS5kaXYub2Zmc2V0TGVmdCtiLm9mZnNldExlZnQrYi5vZmZzZXRXaWR0aC0xKyJweCI7Yi5kaXYuc3R5bGUudG9wPWEuZGl2Lm9mZnNldFRvcCtiLm9mZnNldFRvcCsicHgiO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5kaXYpO3ZhciBjPXBhcnNlSW50KGIuZGl2Lm9mZnNldExlZnQpLGQ9cGFyc2VJbnQoYi5kaXYub2Zmc2V0V2lkdGgpLGU9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihkb2N1bWVudCksZj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7YytkPmUueCsoZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aHx8Zi5jbGllbnRXaWR0aCkmJihiLmRpdi5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsYS5kaXYub2Zmc2V0TGVmdC1kKyhteENsaWVudC5JU19JRT82Oi02KSkrInB4Iik7bXhVdGlscy5maXQoYi5kaXYpfX07Cm14UG9wdXBNZW51LnByb3RvdHlwZS5hZGRTZXBhcmF0b3I9ZnVuY3Rpb24oYSxiKXthPWF8fHRoaXM7aWYodGhpcy5zbWFydFNlcGFyYXRvcnMmJiFiKWEud2lsbEFkZFNlcGFyYXRvcj0hMDtlbHNlIGlmKG51bGwhPWEudGJvZHkpe2Eud2lsbEFkZFNlcGFyYXRvcj0hMTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpLGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtkLmNsYXNzTmFtZT0ibXhQb3B1cE1lbnVJY29uIjtkLnN0eWxlLnBhZGRpbmc9IjAgMCAwIDBweCI7Yy5hcHBlbmRDaGlsZChkKTtkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7ZC5zdHlsZS5wYWRkaW5nPSIwIDAgMCAwcHgiO2Quc2V0QXR0cmlidXRlKCJjb2xTcGFuIiwiMiIpO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImhyIik7ZS5zZXRBdHRyaWJ1dGUoInNpemUiLCIxIik7ZC5hcHBlbmRDaGlsZChlKTtjLmFwcGVuZENoaWxkKGQpO2EudGJvZHkuYXBwZW5kQ2hpbGQoYyl9fTsKbXhQb3B1cE1lbnUucHJvdG90eXBlLnBvcHVwPWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPXRoaXMuZGl2JiZudWxsIT10aGlzLnRib2R5JiZudWxsIT10aGlzLmZhY3RvcnlNZXRob2Qpe3RoaXMuZGl2LnN0eWxlLmxlZnQ9YSsicHgiO2Zvcih0aGlzLmRpdi5zdHlsZS50b3A9YisicHgiO251bGwhPXRoaXMudGJvZHkuZmlyc3RDaGlsZDspbXhFdmVudC5yZWxlYXNlKHRoaXMudGJvZHkuZmlyc3RDaGlsZCksdGhpcy50Ym9keS5yZW1vdmVDaGlsZCh0aGlzLnRib2R5LmZpcnN0Q2hpbGQpO3RoaXMuaXRlbUNvdW50PTA7dGhpcy5mYWN0b3J5TWV0aG9kKHRoaXMsYyxkKTswPHRoaXMuaXRlbUNvdW50JiYodGhpcy5zaG93TWVudSgpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0hPVykpKX19OwpteFBvcHVwTWVudS5wcm90b3R5cGUuaXNNZW51U2hvd2luZz1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmRpdiYmdGhpcy5kaXYucGFyZW50Tm9kZT09ZG9jdW1lbnQuYm9keX07bXhQb3B1cE1lbnUucHJvdG90eXBlLnNob3dNZW51PWZ1bmN0aW9uKCl7OTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYodGhpcy5kaXYuc3R5bGUuZmlsdGVyPSJub25lIik7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7bXhVdGlscy5maXQodGhpcy5kaXYpfTtteFBvcHVwTWVudS5wcm90b3R5cGUuaGlkZU1lbnU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmRpdiYmKG51bGwhPXRoaXMuZGl2LnBhcmVudE5vZGUmJnRoaXMuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaXYpLHRoaXMuaGlkZVN1Ym1lbnUodGhpcyksdGhpcy5jb250YWluc0l0ZW1zPSExLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuSElERSkpKX07Cm14UG9wdXBNZW51LnByb3RvdHlwZS5oaWRlU3VibWVudT1mdW5jdGlvbihhKXtudWxsIT1hLmFjdGl2ZVJvdyYmKHRoaXMuaGlkZVN1Ym1lbnUoYS5hY3RpdmVSb3cpLG51bGwhPWEuYWN0aXZlUm93LmRpdi5wYXJlbnROb2RlJiZhLmFjdGl2ZVJvdy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhLmFjdGl2ZVJvdy5kaXYpLGEuYWN0aXZlUm93PW51bGwpfTtteFBvcHVwTWVudS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe251bGwhPXRoaXMuZGl2JiYobXhFdmVudC5yZWxlYXNlKHRoaXMuZGl2KSxudWxsIT10aGlzLmRpdi5wYXJlbnROb2RlJiZ0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KSx0aGlzLmRpdj1udWxsKX07CmZ1bmN0aW9uIG14QXV0b1NhdmVNYW5hZ2VyKGEpe3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RoaXMuaXNFbmFibGVkKCkmJnRoaXMuZ3JhcGhNb2RlbENoYW5nZWQoYy5nZXRQcm9wZXJ0eSgiZWRpdCIpLmNoYW5nZXMpfSk7dGhpcy5zZXRHcmFwaChhKX1teEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14QXV0b1NhdmVNYW5hZ2VyO214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5ncmFwaD1udWxsO214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5hdXRvU2F2ZURlbGF5PTEwO214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5hdXRvU2F2ZVRocm90dGxlPTI7bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLmF1dG9TYXZlVGhyZXNob2xkPTU7bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLmlnbm9yZWRDaGFuZ2VzPTA7Cm14QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5sYXN0U25hcHNob3Q9MDtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuY2hhbmdlSGFuZGxlcj1udWxsO214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhBdXRvU2F2ZU1hbmFnZXIucHJvdG90eXBlLnNldEdyYXBoPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZ3JhcGgmJnRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZ3JhcGg9YTtudWxsIT10aGlzLmdyYXBoJiZ0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5jaGFuZ2VIYW5kbGVyKX07Cm14QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKCl7fTtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUuZ3JhcGhNb2RlbENoYW5nZWQ9ZnVuY3Rpb24oYSl7YT0oKG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5sYXN0U25hcHNob3QpLzFFMzthPnRoaXMuYXV0b1NhdmVEZWxheXx8dGhpcy5pZ25vcmVkQ2hhbmdlcz49dGhpcy5hdXRvU2F2ZVRocmVzaG9sZCYmYT50aGlzLmF1dG9TYXZlVGhyb3R0bGU/KHRoaXMuc2F2ZSgpLHRoaXMucmVzZXQoKSk6dGhpcy5pZ25vcmVkQ2hhbmdlcysrfTtteEF1dG9TYXZlTWFuYWdlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmxhc3RTbmFwc2hvdD0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLmlnbm9yZWRDaGFuZ2VzPTB9O214QXV0b1NhdmVNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5zZXRHcmFwaChudWxsKX07CmZ1bmN0aW9uIG14QW5pbWF0aW9uKGEpe3RoaXMuZGVsYXk9bnVsbCE9YT9hOjIwfW14QW5pbWF0aW9uLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteEFuaW1hdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhBbmltYXRpb247bXhBbmltYXRpb24ucHJvdG90eXBlLmRlbGF5PW51bGw7bXhBbmltYXRpb24ucHJvdG90eXBlLnRocmVhZD1udWxsO214QW5pbWF0aW9uLnByb3RvdHlwZS5pc1J1bm5pbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy50aHJlYWR9O214QW5pbWF0aW9uLnByb3RvdHlwZS5zdGFydEFuaW1hdGlvbj1mdW5jdGlvbigpe251bGw9PXRoaXMudGhyZWFkJiYodGhpcy50aHJlYWQ9d2luZG93LnNldEludGVydmFsKG14VXRpbHMuYmluZCh0aGlzLHRoaXMudXBkYXRlQW5pbWF0aW9uKSx0aGlzLmRlbGF5KSl9O214QW5pbWF0aW9uLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb249ZnVuY3Rpb24oKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVYRUNVVEUpKX07Cm14QW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy50aHJlYWQmJih3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRocmVhZCksdGhpcy50aHJlYWQ9bnVsbCx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkRPTkUpKSl9O2Z1bmN0aW9uIG14TW9ycGhpbmcoYSxiLGMsZCl7bXhBbmltYXRpb24uY2FsbCh0aGlzLGQpO3RoaXMuZ3JhcGg9YTt0aGlzLnN0ZXBzPW51bGwhPWI/Yjo2O3RoaXMuZWFzZT1udWxsIT1jP2M6MS41fW14TW9ycGhpbmcucHJvdG90eXBlPW5ldyBteEFuaW1hdGlvbjtteE1vcnBoaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teE1vcnBoaW5nO214TW9ycGhpbmcucHJvdG90eXBlLmdyYXBoPW51bGw7bXhNb3JwaGluZy5wcm90b3R5cGUuc3RlcHM9bnVsbDtteE1vcnBoaW5nLnByb3RvdHlwZS5zdGVwPTA7bXhNb3JwaGluZy5wcm90b3R5cGUuZWFzZT1udWxsOwpteE1vcnBoaW5nLnByb3RvdHlwZS5jZWxscz1udWxsO214TW9ycGhpbmcucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbj1mdW5jdGlvbigpe214QW5pbWF0aW9uLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPW5ldyBteENlbGxTdGF0ZVByZXZpZXcodGhpcy5ncmFwaCk7aWYobnVsbCE9dGhpcy5jZWxscylmb3IodmFyIGI9MDtiPHRoaXMuY2VsbHMubGVuZ3RoO2IrKyl0aGlzLmFuaW1hdGVDZWxsKHRoaXMuY2VsbHNbYl0sYSwhMSk7ZWxzZSB0aGlzLmFuaW1hdGVDZWxsKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRSb290KCksYSwhMCk7dGhpcy5zaG93KGEpOyhhLmlzRW1wdHkoKXx8dGhpcy5zdGVwKys+PXRoaXMuc3RlcHMpJiZ0aGlzLnN0b3BBbmltYXRpb24oKX07bXhNb3JwaGluZy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihhKXthLnNob3coKX07Cm14TW9ycGhpbmcucHJvdG90eXBlLmFuaW1hdGVDZWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZShhKSxlPW51bGw7aWYobnVsbCE9ZCYmKGU9dGhpcy5nZXREZWx0YShkKSx0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYSkmJigwIT1lLnh8fDAhPWUueSkpKXt2YXIgZj10aGlzLmdyYXBoLnZpZXcuZ2V0VHJhbnNsYXRlKCksZz10aGlzLmdyYXBoLnZpZXcuZ2V0U2NhbGUoKTtlLngrPWYueCpnO2UueSs9Zi55Kmc7Yi5tb3ZlU3RhdGUoZCwtZS54L3RoaXMuZWFzZSwtZS55L3RoaXMuZWFzZSl9aWYoYyYmIXRoaXMuc3RvcFJlY3Vyc2lvbihkLGUpKWZvcihkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGQ7ZSsrKXRoaXMuYW5pbWF0ZUNlbGwodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldENoaWxkQXQoYSxlKSxiLGMpfTsKbXhNb3JwaGluZy5wcm90b3R5cGUuc3RvcFJlY3Vyc2lvbj1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1iJiYoMCE9Yi54fHwwIT1iLnkpfTtteE1vcnBoaW5nLnByb3RvdHlwZS5nZXREZWx0YT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldE9yaWdpbkZvckNlbGwoYS5jZWxsKSxjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFRyYW5zbGF0ZSgpLGQ9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U2NhbGUoKTtyZXR1cm4gbmV3IG14UG9pbnQoKGIueC0oYS54L2QtYy54KSkqZCwoYi55LShhLnkvZC1jLnkpKSpkKX07Cm14TW9ycGhpbmcucHJvdG90eXBlLmdldE9yaWdpbkZvckNlbGw9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZihudWxsIT1hKXt2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGEpO2E9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSk7Yj10aGlzLmdldE9yaWdpbkZvckNlbGwoYyk7bnVsbCE9YSYmKGEucmVsYXRpdmU/KGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYyksbnVsbCE9YyYmKGIueCs9YS54KmMud2lkdGgsYi55Kz1hLnkqYy5oZWlnaHQpKTooYi54Kz1hLngsYi55Kz1hLnkpKX1udWxsPT1iJiYoYj10aGlzLmdyYXBoLnZpZXcuZ2V0VHJhbnNsYXRlKCksYj1uZXcgbXhQb2ludCgtYi54LC1iLnkpKTtyZXR1cm4gYn07ZnVuY3Rpb24gbXhJbWFnZUJ1bmRsZShhKXt0aGlzLmltYWdlcz1bXTt0aGlzLmFsdD1udWxsIT1hP2E6ITF9bXhJbWFnZUJ1bmRsZS5wcm90b3R5cGUuaW1hZ2VzPW51bGw7Cm14SW1hZ2VCdW5kbGUucHJvdG90eXBlLmFsdD1udWxsO214SW1hZ2VCdW5kbGUucHJvdG90eXBlLnB1dEltYWdlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmltYWdlc1thXT17dmFsdWU6YixmYWxsYmFjazpjfX07bXhJbWFnZUJ1bmRsZS5wcm90b3R5cGUuZ2V0SW1hZ2U9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtudWxsIT1hJiYoYT10aGlzLmltYWdlc1thXSxudWxsIT1hJiYoYj10aGlzLmFsdD9hLmZhbGxiYWNrOmEudmFsdWUpKTtyZXR1cm4gYn07ZnVuY3Rpb24gbXhJbWFnZUV4cG9ydCgpe31teEltYWdlRXhwb3J0LnByb3RvdHlwZS5pbmNsdWRlT3ZlcmxheXM9ITE7Cm14SW1hZ2VFeHBvcnQucHJvdG90eXBlLmRyYXdTdGF0ZT1mdW5jdGlvbihhLGIpe251bGwhPWEmJih0aGlzLnZpc2l0U3RhdGVzUmVjdXJzaXZlKGEsYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZHJhd0NlbGxTdGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSksdGhpcy5pbmNsdWRlT3ZlcmxheXMmJnRoaXMudmlzaXRTdGF0ZXNSZWN1cnNpdmUoYSxiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kcmF3T3ZlcmxheXMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSkpKX07Cm14SW1hZ2VFeHBvcnQucHJvdG90eXBlLnZpc2l0U3RhdGVzUmVjdXJzaXZlPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT1hKXtjKGEsYik7Zm9yKHZhciBkPWEudmlldy5ncmFwaCxlPWQubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmNlbGwpLGY9MDtmPGU7ZisrKXt2YXIgZz1kLnZpZXcuZ2V0U3RhdGUoZC5tb2RlbC5nZXRDaGlsZEF0KGEuY2VsbCxmKSk7dGhpcy52aXNpdFN0YXRlc1JlY3Vyc2l2ZShnLGIsYyl9fX07bXhJbWFnZUV4cG9ydC5wcm90b3R5cGUuZ2V0TGlua0ZvckNlbGxTdGF0ZT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsfTtteEltYWdlRXhwb3J0LnByb3RvdHlwZS5kcmF3Q2VsbFN0YXRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRMaW5rRm9yQ2VsbFN0YXRlKGEsYik7bnVsbCE9YyYmYi5zZXRMaW5rKGMpO3RoaXMuZHJhd1NoYXBlKGEsYik7dGhpcy5kcmF3VGV4dChhLGIpO251bGwhPWMmJmIuc2V0TGluayhudWxsKX07Cm14SW1hZ2VFeHBvcnQucHJvdG90eXBlLmRyYXdTaGFwZT1mdW5jdGlvbihhLGIpe2Euc2hhcGUgaW5zdGFuY2VvZiBteFNoYXBlJiZhLnNoYXBlLmNoZWNrQm91bmRzKCkmJihiLnNhdmUoKSxhLnNoYXBlLnBhaW50KGIpLGIucmVzdG9yZSgpKX07bXhJbWFnZUV4cG9ydC5wcm90b3R5cGUuZHJhd1RleHQ9ZnVuY3Rpb24oYSxiKXtudWxsIT1hLnRleHQmJmEudGV4dC5jaGVja0JvdW5kcygpJiYoYi5zYXZlKCksYS50ZXh0LnBhaW50KGIpLGIucmVzdG9yZSgpKX07bXhJbWFnZUV4cG9ydC5wcm90b3R5cGUuZHJhd092ZXJsYXlzPWZ1bmN0aW9uKGEsYil7bnVsbCE9YS5vdmVybGF5cyYmYS5vdmVybGF5cy52aXNpdChmdW5jdGlvbihhLGQpe2QgaW5zdGFuY2VvZiBteFNoYXBlJiZkLnBhaW50KGIpfSl9O2Z1bmN0aW9uIG14QWJzdHJhY3RDYW52YXMyRCgpe3RoaXMuY29udmVydGVyPXRoaXMuY3JlYXRlVXJsQ29udmVydGVyKCk7dGhpcy5yZXNldCgpfQpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnN0YXRlPW51bGw7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zdGF0ZXM9bnVsbDtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnBhdGg9bnVsbDtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZUh0bWw9ITA7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5sYXN0WD0wO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUubGFzdFk9MDtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLm1vdmVPcD0iTSI7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5saW5lT3A9IkwiO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucXVhZE9wPSJRIjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmN1cnZlT3A9IkMiO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuY2xvc2VPcD0iWiI7bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5wb2ludGVyRXZlbnRzPSExOwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVVybENvbnZlcnRlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhVcmxDb252ZXJ0ZXJ9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnN0YXRlPXRoaXMuY3JlYXRlU3RhdGUoKTt0aGlzLnN0YXRlcz1bXX07Cm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm57ZHg6MCxkeTowLHNjYWxlOjEsYWxwaGE6MSxmaWxsQWxwaGE6MSxzdHJva2VBbHBoYToxLGZpbGxDb2xvcjpudWxsLGdyYWRpZW50RmlsbEFscGhhOjEsZ3JhZGllbnRDb2xvcjpudWxsLGdyYWRpZW50QWxwaGE6MSxncmFkaWVudERpcmVjdGlvbjpudWxsLHN0cm9rZUNvbG9yOm51bGwsc3Ryb2tlV2lkdGg6MSxkYXNoZWQ6ITEsZGFzaFBhdHRlcm46IjMgMyIsZml4RGFzaDohMSxsaW5lQ2FwOiJmbGF0IixsaW5lSm9pbjoibWl0ZXIiLG1pdGVyTGltaXQ6MTAsZm9udENvbG9yOiIjMDAwMDAwIixmb250QmFja2dyb3VuZENvbG9yOm51bGwsZm9udEJvcmRlckNvbG9yOm51bGwsZm9udFNpemU6bXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRSxmb250RmFtaWx5Om14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWSxmb250U3R5bGU6MCxzaGFkb3c6ITEsc2hhZG93Q29sb3I6bXhDb25zdGFudHMuU0hBRE9XQ09MT1IsCnNoYWRvd0FscGhhOm14Q29uc3RhbnRzLlNIQURPV19PUEFDSVRZLHNoYWRvd0R4Om14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWCxzaGFkb3dEeTpteENvbnN0YW50cy5TSEFET1dfT0ZGU0VUX1kscm90YXRpb246MCxyb3RhdGlvbkN4OjAscm90YXRpb25DeTowfX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5mb3JtYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChhKSl9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmFkZE9wPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5wYXRoJiYodGhpcy5wYXRoLnB1c2goYXJndW1lbnRzWzBdKSwyPGFyZ3VtZW50cy5sZW5ndGgpKWZvcih2YXIgYT10aGlzLnN0YXRlLGI9MjtiPGFyZ3VtZW50cy5sZW5ndGg7Yis9Mil0aGlzLmxhc3RYPWFyZ3VtZW50c1tiLTFdLHRoaXMubGFzdFk9YXJndW1lbnRzW2JdLHRoaXMucGF0aC5wdXNoKHRoaXMuZm9ybWF0KCh0aGlzLmxhc3RYK2EuZHgpKmEuc2NhbGUpKSx0aGlzLnBhdGgucHVzaCh0aGlzLmZvcm1hdCgodGhpcy5sYXN0WSthLmR5KSphLnNjYWxlKSl9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucm90YXRlUG9pbnQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXtjKj1NYXRoLlBJLzE4MDtyZXR1cm4gbXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoYSxiKSxNYXRoLmNvcyhjKSxNYXRoLnNpbihjKSxuZXcgbXhQb2ludChkLGUpKX07Cm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbigpe3RoaXMuc3RhdGVzLnB1c2godGhpcy5zdGF0ZSk7dGhpcy5zdGF0ZT1teFV0aWxzLmNsb25lKHRoaXMuc3RhdGUpfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnJlc3RvcmU9ZnVuY3Rpb24oKXswPHRoaXMuc3RhdGVzLmxlbmd0aCYmKHRoaXMuc3RhdGU9dGhpcy5zdGF0ZXMucG9wKCkpfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldExpbms9ZnVuY3Rpb24oYSl7fTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuc2NhbGUqPWE7dGhpcy5zdGF0ZS5zdHJva2VXaWR0aCo9YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS50cmFuc2xhdGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLmR4Kz1hO3RoaXMuc3RhdGUuZHkrPWJ9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKGEsYixjLGQsZSl7fTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRBbHBoYT1mdW5jdGlvbihhKXt0aGlzLnN0YXRlLmFscGhhPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0RmlsbEFscGhhPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuZmlsbEFscGhhPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U3Ryb2tlQWxwaGE9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5zdHJva2VBbHBoYT1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZpbGxDb2xvcj1mdW5jdGlvbihhKXthPT1teENvbnN0YW50cy5OT05FJiYoYT1udWxsKTt0aGlzLnN0YXRlLmZpbGxDb2xvcj1hO3RoaXMuc3RhdGUuZ3JhZGllbnRDb2xvcj1udWxsfTsKbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRHcmFkaWVudD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCl7Yz10aGlzLnN0YXRlO2MuZmlsbENvbG9yPWE7Yy5ncmFkaWVudEZpbGxBbHBoYT1udWxsIT1rP2s6MTtjLmdyYWRpZW50Q29sb3I9YjtjLmdyYWRpZW50QWxwaGE9bnVsbCE9bD9sOjE7Yy5ncmFkaWVudERpcmVjdGlvbj1nfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFN0cm9rZUNvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO3RoaXMuc3RhdGUuc3Ryb2tlQ29sb3I9YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VXaWR0aD1mdW5jdGlvbihhKXt0aGlzLnN0YXRlLnN0cm9rZVdpZHRoPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0RGFzaGVkPWZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5kYXNoZWQ9YTt0aGlzLnN0YXRlLmZpeERhc2g9Yn07Cm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0RGFzaFBhdHRlcm49ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5kYXNoUGF0dGVybj1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldExpbmVDYXA9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5saW5lQ2FwPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0TGluZUpvaW49ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5saW5lSm9pbj1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldE1pdGVyTGltaXQ9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5taXRlckxpbWl0PWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udENvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO3RoaXMuc3RhdGUuZm9udENvbG9yPWF9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRCYWNrZ3JvdW5kQ29sb3I9ZnVuY3Rpb24oYSl7YT09bXhDb25zdGFudHMuTk9ORSYmKGE9bnVsbCk7dGhpcy5zdGF0ZS5mb250QmFja2dyb3VuZENvbG9yPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udEJvcmRlckNvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO3RoaXMuc3RhdGUuZm9udEJvcmRlckNvbG9yPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udFNpemU9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5mb250U2l6ZT1wYXJzZUZsb2F0KGEpfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRGYW1pbHk9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZS5mb250RmFtaWx5PWF9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRTdHlsZT1mdW5jdGlvbihhKXtudWxsPT1hJiYoYT0wKTt0aGlzLnN0YXRlLmZvbnRTdHlsZT1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvdz1mdW5jdGlvbihhKXt0aGlzLnN0YXRlLnNoYWRvdz1hfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvd0NvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO3RoaXMuc3RhdGUuc2hhZG93Q29sb3I9YX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3dBbHBoYT1mdW5jdGlvbihhKXt0aGlzLnN0YXRlLnNoYWRvd0FscGhhPWF9O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93T2Zmc2V0PWZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zaGFkb3dEeD1hO3RoaXMuc3RhdGUuc2hhZG93RHk9Yn07Cm14QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuYmVnaW49ZnVuY3Rpb24oKXt0aGlzLmxhc3RZPXRoaXMubGFzdFg9MDt0aGlzLnBhdGg9W119O214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUubW92ZVRvPWZ1bmN0aW9uKGEsYil7dGhpcy5hZGRPcCh0aGlzLm1vdmVPcCxhLGIpfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmxpbmVUbz1mdW5jdGlvbihhLGIpe3RoaXMuYWRkT3AodGhpcy5saW5lT3AsYSxiKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5xdWFkVG89ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5hZGRPcCh0aGlzLnF1YWRPcCxhLGIsYyxkKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5jdXJ2ZVRvPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLmFkZE9wKHRoaXMuY3VydmVPcCxhLGIsYyxkLGUsZil9OwpteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmFyY1RvPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2E9bXhVdGlscy5hcmNUb0N1cnZlcyh0aGlzLmxhc3RYLHRoaXMubGFzdFksYSxiLGMsZCxlLGYsZyk7aWYobnVsbCE9YSlmb3IoYj0wO2I8YS5sZW5ndGg7Yis9Nil0aGlzLmN1cnZlVG8oYVtiXSxhW2IrMV0sYVtiKzJdLGFbYiszXSxhW2IrNF0sYVtiKzVdKX07bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5hZGRPcCh0aGlzLmNsb3NlT3ApfTtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmVuZD1mdW5jdGlvbigpe307ZnVuY3Rpb24gbXhYbWxDYW52YXMyRChhKXtteEFic3RyYWN0Q2FudmFzMkQuY2FsbCh0aGlzKTt0aGlzLnJvb3Q9YTt0aGlzLndyaXRlRGVmYXVsdHMoKX1teFV0aWxzLmV4dGVuZChteFhtbENhbnZhczJELG14QWJzdHJhY3RDYW52YXMyRCk7Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnRleHRFbmFibGVkPSEwO214WG1sQ2FudmFzMkQucHJvdG90eXBlLmNvbXByZXNzZWQ9ITA7Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLndyaXRlRGVmYXVsdHM9ZnVuY3Rpb24oKXt2YXIgYTthPXRoaXMuY3JlYXRlRWxlbWVudCgiZm9udGZhbWlseSIpO2Euc2V0QXR0cmlidXRlKCJmYW1pbHkiLG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGEpO2E9dGhpcy5jcmVhdGVFbGVtZW50KCJmb250c2l6ZSIpO2Euc2V0QXR0cmlidXRlKCJzaXplIixteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYSk7YT10aGlzLmNyZWF0ZUVsZW1lbnQoInNoYWRvd2NvbG9yIik7YS5zZXRBdHRyaWJ1dGUoImNvbG9yIixteENvbnN0YW50cy5TSEFET1dDT0xPUik7dGhpcy5yb290LmFwcGVuZENoaWxkKGEpO2E9dGhpcy5jcmVhdGVFbGVtZW50KCJzaGFkb3dhbHBoYSIpO2Euc2V0QXR0cmlidXRlKCJhbHBoYSIsbXhDb25zdGFudHMuU0hBRE9XX09QQUNJVFkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChhKTsKYT10aGlzLmNyZWF0ZUVsZW1lbnQoInNoYWRvd29mZnNldCIpO2Euc2V0QXR0cmlidXRlKCJkeCIsbXhDb25zdGFudHMuU0hBRE9XX09GRlNFVF9YKTthLnNldEF0dHJpYnV0ZSgiZHkiLG14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGEpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5mb3JtYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHBhcnNlRmxvYXQocGFyc2VGbG9hdChhKS50b0ZpeGVkKDIpKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yb290Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChhKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbigpe3RoaXMuY29tcHJlc3NlZCYmbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zYXZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVFbGVtZW50KCJzYXZlIikpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUucmVzdG9yZT1mdW5jdGlvbigpe3RoaXMuY29tcHJlc3NlZCYmbXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5yZXN0b3JlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVFbGVtZW50KCJyZXN0b3JlIikpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoInNjYWxlIik7Yi5zZXRBdHRyaWJ1dGUoInNjYWxlIixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY3JlYXRlRWxlbWVudCgidHJhbnNsYXRlIik7Yy5zZXRBdHRyaWJ1dGUoImR4Iix0aGlzLmZvcm1hdChhKSk7Yy5zZXRBdHRyaWJ1dGUoImR5Iix0aGlzLmZvcm1hdChiKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGMpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5jcmVhdGVFbGVtZW50KCJyb3RhdGUiKTtpZigwIT1hfHxifHxjKWYuc2V0QXR0cmlidXRlKCJ0aGV0YSIsdGhpcy5mb3JtYXQoYSkpLGYuc2V0QXR0cmlidXRlKCJmbGlwSCIsYj8iMSI6IjAiKSxmLnNldEF0dHJpYnV0ZSgiZmxpcFYiLGM/IjEiOiIwIiksZi5zZXRBdHRyaWJ1dGUoImN4Iix0aGlzLmZvcm1hdChkKSksZi5zZXRBdHRyaWJ1dGUoImN5Iix0aGlzLmZvcm1hdChlKSksdGhpcy5yb290LmFwcGVuZENoaWxkKGYpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0QWxwaGE9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmFscGhhPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEFscGhhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImFscGhhIik7Yi5zZXRBdHRyaWJ1dGUoImFscGhhIix0aGlzLmZvcm1hdChhKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRGaWxsQWxwaGE9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmZpbGxBbHBoYT09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGaWxsQWxwaGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgiZmlsbGFscGhhIik7Yi5zZXRBdHRyaWJ1dGUoImFscGhhIix0aGlzLmZvcm1hdChhKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0U3Ryb2tlQWxwaGE9ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLnN0cm9rZUFscGhhPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFN0cm9rZUFscGhhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoInN0cm9rZWFscGhhIik7Yi5zZXRBdHRyaWJ1dGUoImFscGhhIix0aGlzLmZvcm1hdChhKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0RmlsbENvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5maWxsQ29sb3I9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0RmlsbENvbG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZpbGxjb2xvciIpO2Iuc2V0QXR0cmlidXRlKCJjb2xvciIsbnVsbCE9YT9hOm14Q29uc3RhbnRzLk5PTkUpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEdyYWRpZW50PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsKXtpZihudWxsIT1hJiZudWxsIT1iKXtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEdyYWRpZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgbT10aGlzLmNyZWF0ZUVsZW1lbnQoImdyYWRpZW50Iik7bS5zZXRBdHRyaWJ1dGUoImMxIixhKTttLnNldEF0dHJpYnV0ZSgiYzIiLGIpO20uc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChjKSk7bS5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGQpKTttLnNldEF0dHJpYnV0ZSgidyIsdGhpcy5mb3JtYXQoZSkpO20uc2V0QXR0cmlidXRlKCJoIix0aGlzLmZvcm1hdChmKSk7bnVsbCE9ZyYmbS5zZXRBdHRyaWJ1dGUoImRpcmVjdGlvbiIsZyk7bnVsbCE9ayYmbS5zZXRBdHRyaWJ1dGUoImFscGhhMSIsayk7bnVsbCE9bCYmbS5zZXRBdHRyaWJ1dGUoImFscGhhMiIsbCk7dGhpcy5yb290LmFwcGVuZENoaWxkKG0pfX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldFN0cm9rZUNvbG9yPWZ1bmN0aW9uKGEpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5zdHJva2VDb2xvcj09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VDb2xvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJzdHJva2Vjb2xvciIpO2Iuc2V0QXR0cmlidXRlKCJjb2xvciIsbnVsbCE9YT9hOm14Q29uc3RhbnRzLk5PTkUpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldFN0cm9rZVdpZHRoPWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5zdHJva2VXaWR0aD09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTdHJva2VXaWR0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJzdHJva2V3aWR0aCIpO2Iuc2V0QXR0cmlidXRlKCJ3aWR0aCIsdGhpcy5mb3JtYXQoYSkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldERhc2hlZD1mdW5jdGlvbihhLGIpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5kYXNoZWQ9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0RGFzaGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYz10aGlzLmNyZWF0ZUVsZW1lbnQoImRhc2hlZCIpO2Muc2V0QXR0cmlidXRlKCJkYXNoZWQiLGE/IjEiOiIwIik7bnVsbCE9YiYmYy5zZXRBdHRyaWJ1dGUoImZpeERhc2giLGI/IjEiOiIwIik7dGhpcy5yb290LmFwcGVuZENoaWxkKGMpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0RGFzaFBhdHRlcm49ZnVuY3Rpb24oYSl7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmRhc2hQYXR0ZXJuPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldERhc2hQYXR0ZXJuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImRhc2hwYXR0ZXJuIik7Yi5zZXRBdHRyaWJ1dGUoInBhdHRlcm4iLGEpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0TGluZUNhcD1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUubGluZUNhcD09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRMaW5lQ2FwLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImxpbmVjYXAiKTtiLnNldEF0dHJpYnV0ZSgiY2FwIixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRMaW5lSm9pbj1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUubGluZUpvaW49PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0TGluZUpvaW4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgibGluZWpvaW4iKTtiLnNldEF0dHJpYnV0ZSgiam9pbiIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRNaXRlckxpbWl0PWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5taXRlckxpbWl0PT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldE1pdGVyTGltaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgibWl0ZXJsaW1pdCIpO2Iuc2V0QXR0cmlidXRlKCJsaW1pdCIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udENvbG9yPWZ1bmN0aW9uKGEpe2lmKHRoaXMudGV4dEVuYWJsZWQpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5mb250Q29sb3I9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udENvbG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZvbnRjb2xvciIpO2Iuc2V0QXR0cmlidXRlKCJjb2xvciIsbnVsbCE9YT9hOm14Q29uc3RhbnRzLk5PTkUpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX19OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRGb250QmFja2dyb3VuZENvbG9yPWZ1bmN0aW9uKGEpe2lmKHRoaXMudGV4dEVuYWJsZWQpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5mb250QmFja2dyb3VuZENvbG9yPT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRCYWNrZ3JvdW5kQ29sb3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgiZm9udGJhY2tncm91bmRjb2xvciIpO2Iuc2V0QXR0cmlidXRlKCJjb2xvciIsbnVsbCE9YT9hOm14Q29uc3RhbnRzLk5PTkUpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX19OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRGb250Qm9yZGVyQ29sb3I9ZnVuY3Rpb24oYSl7aWYodGhpcy50ZXh0RW5hYmxlZCl7YT09bXhDb25zdGFudHMuTk9ORSYmKGE9bnVsbCk7aWYodGhpcy5jb21wcmVzc2VkKXtpZih0aGlzLnN0YXRlLmZvbnRCb3JkZXJDb2xvcj09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250Qm9yZGVyQ29sb3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgiZm9udGJvcmRlcmNvbG9yIik7Yi5zZXRBdHRyaWJ1dGUoImNvbG9yIixudWxsIT1hP2E6bXhDb25zdGFudHMuTk9ORSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldEZvbnRTaXplPWZ1bmN0aW9uKGEpe2lmKHRoaXMudGV4dEVuYWJsZWQpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5mb250U2l6ZT09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250U2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJmb250c2l6ZSIpO2Iuc2V0QXR0cmlidXRlKCJzaXplIixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9fTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udEZhbWlseT1mdW5jdGlvbihhKXtpZih0aGlzLnRleHRFbmFibGVkKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuZm9udEZhbWlseT09YSlyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRGb250RmFtaWx5LmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZvbnRmYW1pbHkiKTtiLnNldEF0dHJpYnV0ZSgiZmFtaWx5IixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9fTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udFN0eWxlPWZ1bmN0aW9uKGEpe2lmKHRoaXMudGV4dEVuYWJsZWQpe251bGw9PWEmJihhPTApO2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5mb250U3R5bGU9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0Rm9udFN0eWxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoImZvbnRzdHlsZSIpO2Iuc2V0QXR0cmlidXRlKCJzdHlsZSIsYSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGIpfX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvdz1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuc2hhZG93PT1hKXJldHVybjtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvdy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KCJzaGFkb3ciKTtiLnNldEF0dHJpYnV0ZSgiZW5hYmxlZCIsYT8iMSI6IjAiKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3dDb2xvcj1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2E9PW14Q29uc3RhbnRzLk5PTkUmJihhPW51bGwpO2lmKHRoaXMuc3RhdGUuc2hhZG93Q29sb3I9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93Q29sb3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgic2hhZG93Y29sb3IiKTtiLnNldEF0dHJpYnV0ZSgiY29sb3IiLG51bGwhPWE/YTpteENvbnN0YW50cy5OT05FKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYil9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3dBbHBoYT1mdW5jdGlvbihhKXtpZih0aGlzLmNvbXByZXNzZWQpe2lmKHRoaXMuc3RhdGUuc2hhZG93QWxwaGE9PWEpcmV0dXJuO214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUuc2V0U2hhZG93QWxwaGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgic2hhZG93YWxwaGEiKTtiLnNldEF0dHJpYnV0ZSgiYWxwaGEiLGEpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChiKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnNldFNoYWRvd09mZnNldD1mdW5jdGlvbihhLGIpe2lmKHRoaXMuY29tcHJlc3NlZCl7aWYodGhpcy5zdGF0ZS5zaGFkb3dEeD09YSYmdGhpcy5zdGF0ZS5zaGFkb3dEeT09YilyZXR1cm47bXhBYnN0cmFjdENhbnZhczJELnByb3RvdHlwZS5zZXRTaGFkb3dPZmZzZXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBjPXRoaXMuY3JlYXRlRWxlbWVudCgic2hhZG93b2Zmc2V0Iik7Yy5zZXRBdHRyaWJ1dGUoImR4IixhKTtjLnNldEF0dHJpYnV0ZSgiZHkiLGIpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChjKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLnJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5jcmVhdGVFbGVtZW50KCJyZWN0Iik7ZS5zZXRBdHRyaWJ1dGUoIngiLHRoaXMuZm9ybWF0KGEpKTtlLnNldEF0dHJpYnV0ZSgieSIsdGhpcy5mb3JtYXQoYikpO2Uuc2V0QXR0cmlidXRlKCJ3Iix0aGlzLmZvcm1hdChjKSk7ZS5zZXRBdHRyaWJ1dGUoImgiLHRoaXMuZm9ybWF0KGQpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoZSl9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5yb3VuZHJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMuY3JlYXRlRWxlbWVudCgicm91bmRyZWN0Iik7Zy5zZXRBdHRyaWJ1dGUoIngiLHRoaXMuZm9ybWF0KGEpKTtnLnNldEF0dHJpYnV0ZSgieSIsdGhpcy5mb3JtYXQoYikpO2cuc2V0QXR0cmlidXRlKCJ3Iix0aGlzLmZvcm1hdChjKSk7Zy5zZXRBdHRyaWJ1dGUoImgiLHRoaXMuZm9ybWF0KGQpKTtnLnNldEF0dHJpYnV0ZSgiZHgiLHRoaXMuZm9ybWF0KGUpKTtnLnNldEF0dHJpYnV0ZSgiZHkiLHRoaXMuZm9ybWF0KGYpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoZyl9OwpteFhtbENhbnZhczJELnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuY3JlYXRlRWxlbWVudCgiZWxsaXBzZSIpO2Uuc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7ZS5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTtlLnNldEF0dHJpYnV0ZSgidyIsdGhpcy5mb3JtYXQoYykpO2Uuc2V0QXR0cmlidXRlKCJoIix0aGlzLmZvcm1hdChkKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGUpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuaW1hZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtlPXRoaXMuY29udmVydGVyLmNvbnZlcnQoZSk7dmFyIGw9dGhpcy5jcmVhdGVFbGVtZW50KCJpbWFnZSIpO2wuc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7bC5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTtsLnNldEF0dHJpYnV0ZSgidyIsdGhpcy5mb3JtYXQoYykpO2wuc2V0QXR0cmlidXRlKCJoIix0aGlzLmZvcm1hdChkKSk7bC5zZXRBdHRyaWJ1dGUoInNyYyIsZSk7bC5zZXRBdHRyaWJ1dGUoImFzcGVjdCIsZj8iMSI6IjAiKTtsLnNldEF0dHJpYnV0ZSgiZmxpcEgiLGc/IjEiOiIwIik7bC5zZXRBdHRyaWJ1dGUoImZsaXBWIixrPyIxIjoiMCIpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChsKX07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLmJlZ2luPWZ1bmN0aW9uKCl7dGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudCgiYmVnaW4iKSk7dGhpcy5sYXN0WT10aGlzLmxhc3RYPTB9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLm1vdmVUbz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY3JlYXRlRWxlbWVudCgibW92ZSIpO2Muc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7Yy5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYyk7dGhpcy5sYXN0WD1hO3RoaXMubGFzdFk9Yn07Cm14WG1sQ2FudmFzMkQucHJvdG90eXBlLmxpbmVUbz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY3JlYXRlRWxlbWVudCgibGluZSIpO2Muc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7Yy5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYyk7dGhpcy5sYXN0WD1hO3RoaXMubGFzdFk9Yn07bXhYbWxDYW52YXMyRC5wcm90b3R5cGUucXVhZFRvPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuY3JlYXRlRWxlbWVudCgicXVhZCIpO2Uuc2V0QXR0cmlidXRlKCJ4MSIsdGhpcy5mb3JtYXQoYSkpO2Uuc2V0QXR0cmlidXRlKCJ5MSIsdGhpcy5mb3JtYXQoYikpO2Uuc2V0QXR0cmlidXRlKCJ4MiIsdGhpcy5mb3JtYXQoYykpO2Uuc2V0QXR0cmlidXRlKCJ5MiIsdGhpcy5mb3JtYXQoZCkpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChlKTt0aGlzLmxhc3RYPWM7dGhpcy5sYXN0WT1kfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUuY3VydmVUbz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9dGhpcy5jcmVhdGVFbGVtZW50KCJjdXJ2ZSIpO2cuc2V0QXR0cmlidXRlKCJ4MSIsdGhpcy5mb3JtYXQoYSkpO2cuc2V0QXR0cmlidXRlKCJ5MSIsdGhpcy5mb3JtYXQoYikpO2cuc2V0QXR0cmlidXRlKCJ4MiIsdGhpcy5mb3JtYXQoYykpO2cuc2V0QXR0cmlidXRlKCJ5MiIsdGhpcy5mb3JtYXQoZCkpO2cuc2V0QXR0cmlidXRlKCJ4MyIsdGhpcy5mb3JtYXQoZSkpO2cuc2V0QXR0cmlidXRlKCJ5MyIsdGhpcy5mb3JtYXQoZikpO3RoaXMucm9vdC5hcHBlbmRDaGlsZChnKTt0aGlzLmxhc3RYPWU7dGhpcy5sYXN0WT1mfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe3RoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUVsZW1lbnQoImNsb3NlIikpfTsKbXhYbWxDYW52YXMyRC5wcm90b3R5cGUudGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXtpZih0aGlzLnRleHRFbmFibGVkJiZudWxsIT1lKXtteFV0aWxzLmlzTm9kZShlKSYmKGU9bXhVdGlscy5nZXRPdXRlckh0bWwoZSkpO3ZhciByPXRoaXMuY3JlYXRlRWxlbWVudCgidGV4dCIpO3Iuc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdChhKSk7ci5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIpKTtyLnNldEF0dHJpYnV0ZSgidyIsdGhpcy5mb3JtYXQoYykpO3Iuc2V0QXR0cmlidXRlKCJoIix0aGlzLmZvcm1hdChkKSk7ci5zZXRBdHRyaWJ1dGUoInN0ciIsZSk7bnVsbCE9ZiYmci5zZXRBdHRyaWJ1dGUoImFsaWduIixmKTtudWxsIT1nJiZyLnNldEF0dHJpYnV0ZSgidmFsaWduIixnKTtyLnNldEF0dHJpYnV0ZSgid3JhcCIsaz8iMSI6IjAiKTtudWxsPT1sJiYobD0iIik7ci5zZXRBdHRyaWJ1dGUoImZvcm1hdCIsbCk7bnVsbCE9bSYmci5zZXRBdHRyaWJ1dGUoIm92ZXJmbG93IiwKbSk7bnVsbCE9biYmci5zZXRBdHRyaWJ1dGUoImNsaXAiLG4/IjEiOiIwIik7bnVsbCE9cCYmci5zZXRBdHRyaWJ1dGUoInJvdGF0aW9uIixwKTtudWxsIT1xJiZyLnNldEF0dHJpYnV0ZSgiZGlyIixxKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQocil9fTtteFhtbENhbnZhczJELnByb3RvdHlwZS5zdHJva2U9ZnVuY3Rpb24oKXt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVFbGVtZW50KCJzdHJva2UiKSl9O214WG1sQ2FudmFzMkQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oKXt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVFbGVtZW50KCJmaWxsIikpfTtteFhtbENhbnZhczJELnByb3RvdHlwZS5maWxsQW5kU3Ryb2tlPWZ1bmN0aW9uKCl7dGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRWxlbWVudCgiZmlsbHN0cm9rZSIpKX07CmZ1bmN0aW9uIG14U3ZnQ2FudmFzMkQoYSxiKXtteEFic3RyYWN0Q2FudmFzMkQuY2FsbCh0aGlzKTt0aGlzLnJvb3Q9YTt0aGlzLmdyYWRpZW50cz1bXTt0aGlzLmRlZnM9bnVsbDt0aGlzLnN0eWxlRW5hYmxlZD1udWxsIT1iP2I6ITE7dmFyIGM9bnVsbDtpZihhLm93bmVyRG9jdW1lbnQhPWRvY3VtZW50KWZvcihjPWE7bnVsbCE9YyYmInN2ZyIhPWMubm9kZU5hbWU7KWM9Yy5wYXJlbnROb2RlO251bGwhPWMmJigwPGMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRlZnMiKS5sZW5ndGgmJih0aGlzLmRlZnM9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGVmcyIpWzBdKSxudWxsPT10aGlzLmRlZnMmJih0aGlzLmRlZnM9dGhpcy5jcmVhdGVFbGVtZW50KCJkZWZzIiksbnVsbCE9Yy5maXJzdENoaWxkP2MuaW5zZXJ0QmVmb3JlKHRoaXMuZGVmcyxjLmZpcnN0Q2hpbGQpOmMuYXBwZW5kQ2hpbGQodGhpcy5kZWZzKSksdGhpcy5zdHlsZUVuYWJsZWQmJnRoaXMuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVN0eWxlKCkpKX0KbXhVdGlscy5leHRlbmQobXhTdmdDYW52YXMyRCxteEFic3RyYWN0Q2FudmFzMkQpOyhmdW5jdGlvbigpe214U3ZnQ2FudmFzMkQucHJvdG90eXBlLnVzZURvbVBhcnNlcj0hbXhDbGllbnQuSVNfSUUmJiJmdW5jdGlvbiI9PT10eXBlb2YgRE9NUGFyc2VyJiYiZnVuY3Rpb24iPT09dHlwZW9mIFhNTFNlcmlhbGl6ZXI7aWYobXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXNlRG9tUGFyc2VyKXRyeXt2YXIgYT0obmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKCJ0ZXN0IHRleHQiLCJ0ZXh0L2h0bWwiKTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS51c2VEb21QYXJzZXI9bnVsbCE9YX1jYXRjaChiKXtteFN2Z0NhbnZhczJELnByb3RvdHlwZS51c2VEb21QYXJzZXI9ITF9fSkoKTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5ub2RlPW51bGw7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUubWF0Y2hIdG1sQWxpZ25tZW50PSEwOwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS50ZXh0RW5hYmxlZD0hMDtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5mb0VuYWJsZWQ9ITA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZm9BbHRUZXh0PSJbT2JqZWN0XSI7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZm9PZmZzZXQ9MDtteFN2Z0NhbnZhczJELnByb3RvdHlwZS50ZXh0T2Zmc2V0PTA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuaW1hZ2VPZmZzZXQ9MDtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5zdHJva2VUb2xlcmFuY2U9MDtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5taW5TdHJva2VXaWR0aD0xO214U3ZnQ2FudmFzMkQucHJvdG90eXBlLnJlZkNvdW50PTA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUubGluZUhlaWdodENvcnJlY3Rpb249MTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5wb2ludGVyRXZlbnRzVmFsdWU9ImFsbCI7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZm9udE1ldHJpY3NQYWRkaW5nPTEwOwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jYWNoZU9mZnNldFNpemU9ITA7bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiBwYXJzZUZsb2F0KHBhcnNlRmxvYXQoYSkudG9GaXhlZCgyKSl9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmdldEJhc2VVcmw9ZnVuY3Rpb24oKXt2YXIgYT13aW5kb3cubG9jYXRpb24uaHJlZixiPWEubGFzdEluZGV4T2YoIiMiKTswPGImJihhPWEuc3Vic3RyaW5nKDAsYikpO3JldHVybiBhfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe214QWJzdHJhY3RDYW52YXMyRC5wcm90b3R5cGUucmVzZXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZ3JhZGllbnRzPVtdfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlU3R5bGU9ZnVuY3Rpb24oYSl7YT10aGlzLmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7YS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0L2NzcyIpO214VXRpbHMud3JpdGUoYSwic3Zne2ZvbnQtZmFtaWx5OiIrbXhDb25zdGFudHMuREVGQVVMVF9GT05URkFNSUxZKyI7Zm9udC1zaXplOiIrbXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRSsiO2ZpbGw6bm9uZTtzdHJva2UtbWl0ZXJsaW1pdDoxMH0iKTtyZXR1cm4gYX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLnJvb3Qub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMpcmV0dXJuIHRoaXMucm9vdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhifHxteENvbnN0YW50cy5OU19TVkcsYSk7dmFyIGM9dGhpcy5yb290Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChhKTtudWxsIT1iJiZjLnNldEF0dHJpYnV0ZSgieG1sbnMiLGIpO3JldHVybiBjfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5nZXRBbHRlcm5hdGVUZXh0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEpe3JldHVybiBudWxsIT1mP3RoaXMuZm9BbHRUZXh0Om51bGx9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVBbHRlcm5hdGVDb250ZW50PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEpe2E9dGhpcy5nZXRBbHRlcm5hdGVUZXh0KGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEpO2Q9dGhpcy5zdGF0ZTtyZXR1cm4gbnVsbCE9YSYmMDxkLmZvbnRTaXplPyhrPWs9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD8xOms9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT8wOi4zLGU9Zz09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/ImVuZCI6Zz09bXhDb25zdGFudHMuQUxJR05fTEVGVD8ic3RhcnQiOiJtaWRkbGUiLGc9dGhpcy5jcmVhdGVFbGVtZW50KCJ0ZXh0IiksZy5zZXRBdHRyaWJ1dGUoIngiLE1hdGgucm91bmQoYitkLmR4KSksZy5zZXRBdHRyaWJ1dGUoInkiLE1hdGgucm91bmQoYytkLmR5K2sqZC5mb250U2l6ZSkpLGcuc2V0QXR0cmlidXRlKCJmaWxsIixkLmZvbnRDb2xvcnx8ImJsYWNrIiksZy5zZXRBdHRyaWJ1dGUoImZvbnQtZmFtaWx5IiwKZC5mb250RmFtaWx5KSxnLnNldEF0dHJpYnV0ZSgiZm9udC1zaXplIixNYXRoLnJvdW5kKGQuZm9udFNpemUpKyJweCIpLCJzdGFydCIhPWUmJmcuc2V0QXR0cmlidXRlKCJ0ZXh0LWFuY2hvciIsZSksKGQuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRCYmZy5zZXRBdHRyaWJ1dGUoImZvbnQtd2VpZ2h0IiwiYm9sZCIpLChkLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDJiZnLnNldEF0dHJpYnV0ZSgiZm9udC1zdHlsZSIsIml0YWxpYyIpLGI9W10sKGQuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJmIucHVzaCgidW5kZXJsaW5lIiksKGQuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCk9PW14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCYmYi5wdXNoKCJsaW5lLXRocm91Z2giKSwKMDxiLmxlbmd0aCYmZy5zZXRBdHRyaWJ1dGUoInRleHQtZGVjb3JhdGlvbiIsYi5qb2luKCIgIikpLG14VXRpbHMud3JpdGUoZyxhKSxnKTpudWxsfTtteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVHcmFkaWVudElkPWZ1bmN0aW9uKGEsYixjLGQsZSl7IiMiPT1hLmNoYXJBdCgwKSYmKGE9YS5zdWJzdHJpbmcoMSkpOyIjIj09Yi5jaGFyQXQoMCkmJihiPWIuc3Vic3RyaW5nKDEpKTthPWEudG9Mb3dlckNhc2UoKSsiLSIrYztiPWIudG9Mb3dlckNhc2UoKSsiLSIrZDtjPW51bGw7bnVsbD09ZXx8ZT09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIP2M9InMiOmU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUP2M9ImUiOihkPWEsYT1iLGI9ZCxlPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/Yz0icyI6ZT09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QmJihjPSJlIikpO3JldHVybiJteC1ncmFkaWVudC0iK2ErIi0iK2IrIi0iK2N9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5nZXRTdmdHcmFkaWVudD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuY3JlYXRlR3JhZGllbnRJZChhLGIsYyxkLGUpLGc9dGhpcy5ncmFkaWVudHNbZl07aWYobnVsbD09Zyl7dmFyIGs9dGhpcy5yb290Lm93bmVyU1ZHRWxlbWVudCxsPTAsbT1mKyItIitsO2lmKG51bGwhPWspZm9yKGc9ay5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG0pO251bGwhPWcmJmcub3duZXJTVkdFbGVtZW50IT1rOyltPWYrIi0iK2wrKyxnPWsub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChtKTtlbHNlIG09ImlkIisgKyt0aGlzLnJlZkNvdW50O251bGw9PWcmJihnPXRoaXMuY3JlYXRlU3ZnR3JhZGllbnQoYSxiLGMsZCxlKSxnLnNldEF0dHJpYnV0ZSgiaWQiLG0pLG51bGwhPXRoaXMuZGVmcz90aGlzLmRlZnMuYXBwZW5kQ2hpbGQoZyk6ay5hcHBlbmRDaGlsZChnKSk7dGhpcy5ncmFkaWVudHNbZl09Z31yZXR1cm4gZy5nZXRBdHRyaWJ1dGUoImlkIil9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVTdmdHcmFkaWVudD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuY3JlYXRlRWxlbWVudCgibGluZWFyR3JhZGllbnQiKTtmLnNldEF0dHJpYnV0ZSgieDEiLCIwJSIpO2Yuc2V0QXR0cmlidXRlKCJ5MSIsIjAlIik7Zi5zZXRBdHRyaWJ1dGUoIngyIiwiMCUiKTtmLnNldEF0dHJpYnV0ZSgieTIiLCIwJSIpO251bGw9PWV8fGU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9mLnNldEF0dHJpYnV0ZSgieTIiLCIxMDAlIik6ZT09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q/Zi5zZXRBdHRyaWJ1dGUoIngyIiwiMTAwJSIpOmU9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9mLnNldEF0dHJpYnV0ZSgieTEiLCIxMDAlIik6ZT09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QmJmYuc2V0QXR0cmlidXRlKCJ4MSIsIjEwMCUiKTtjPTE+Yz8iO3N0b3Atb3BhY2l0eToiK2M6IiI7ZT10aGlzLmNyZWF0ZUVsZW1lbnQoInN0b3AiKTsKZS5zZXRBdHRyaWJ1dGUoIm9mZnNldCIsIjAlIik7ZS5zZXRBdHRyaWJ1dGUoInN0eWxlIiwic3RvcC1jb2xvcjoiK2ErYyk7Zi5hcHBlbmRDaGlsZChlKTtjPTE+ZD8iO3N0b3Atb3BhY2l0eToiK2Q6IiI7ZT10aGlzLmNyZWF0ZUVsZW1lbnQoInN0b3AiKTtlLnNldEF0dHJpYnV0ZSgib2Zmc2V0IiwiMTAwJSIpO2Uuc2V0QXR0cmlidXRlKCJzdHlsZSIsInN0b3AtY29sb3I6IitiK2MpO2YuYXBwZW5kQ2hpbGQoZSk7cmV0dXJuIGZ9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5hZGROb2RlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ub2RlLGQ9dGhpcy5zdGF0ZTtpZihudWxsIT1jKXtpZigicGF0aCI9PWMubm9kZU5hbWUpaWYobnVsbCE9dGhpcy5wYXRoJiYwPHRoaXMucGF0aC5sZW5ndGgpYy5zZXRBdHRyaWJ1dGUoImQiLHRoaXMucGF0aC5qb2luKCIgIikpO2Vsc2UgcmV0dXJuO2EmJm51bGwhPWQuZmlsbENvbG9yP3RoaXMudXBkYXRlRmlsbCgpOnRoaXMuc3R5bGVFbmFibGVkfHwoImVsbGlwc2UiPT1jLm5vZGVOYW1lJiZteENsaWVudC5JU19GRj9jLnNldEF0dHJpYnV0ZSgiZmlsbCIsInRyYW5zcGFyZW50Iik6Yy5zZXRBdHRyaWJ1dGUoImZpbGwiLCJub25lIiksYT0hMSk7YiYmbnVsbCE9ZC5zdHJva2VDb2xvcj90aGlzLnVwZGF0ZVN0cm9rZSgpOnRoaXMuc3R5bGVFbmFibGVkfHxjLnNldEF0dHJpYnV0ZSgic3Ryb2tlIiwibm9uZSIpO251bGwhPWQudHJhbnNmb3JtJiYwPGQudHJhbnNmb3JtLmxlbmd0aCYmCmMuc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLGQudHJhbnNmb3JtKTtkLnNoYWRvdyYmdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlU2hhZG93KGMpKTswPHRoaXMuc3Ryb2tlVG9sZXJhbmNlJiYhYSYmdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlVG9sZXJhbmNlKGMpKTt0aGlzLnBvaW50ZXJFdmVudHM/Yy5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIix0aGlzLnBvaW50ZXJFdmVudHNWYWx1ZSk6dGhpcy5wb2ludGVyRXZlbnRzfHxudWxsIT10aGlzLm9yaWdpbmFsUm9vdHx8Yy5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwibm9uZSIpOygicmVjdCIhPWMubm9kZU5hbWUmJiJwYXRoIiE9Yy5ub2RlTmFtZSYmImVsbGlwc2UiIT1jLm5vZGVOYW1lfHwibm9uZSIhPWMuZ2V0QXR0cmlidXRlKCJmaWxsIikmJiJ0cmFuc3BhcmVudCIhPWMuZ2V0QXR0cmlidXRlKCJmaWxsIil8fCJub25lIiE9Yy5nZXRBdHRyaWJ1dGUoInN0cm9rZSIpfHwibm9uZSIhPQpjLmdldEF0dHJpYnV0ZSgicG9pbnRlci1ldmVudHMiKSkmJnRoaXMucm9vdC5hcHBlbmRDaGlsZChjKTt0aGlzLm5vZGU9bnVsbH19OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS51cGRhdGVGaWxsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGF0ZTsoMT5hLmFscGhhfHwxPmEuZmlsbEFscGhhKSYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgiZmlsbC1vcGFjaXR5IixhLmFscGhhKmEuZmlsbEFscGhhKTtpZihudWxsIT1hLmZpbGxDb2xvcilpZihudWxsIT1hLmdyYWRpZW50Q29sb3IpaWYoYT10aGlzLmdldFN2Z0dyYWRpZW50KFN0cmluZyhhLmZpbGxDb2xvciksU3RyaW5nKGEuZ3JhZGllbnRDb2xvciksYS5ncmFkaWVudEZpbGxBbHBoYSxhLmdyYWRpZW50QWxwaGEsYS5ncmFkaWVudERpcmVjdGlvbiksbXhDbGllbnQuSVNfQ0hST01FQVBQfHxteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfRURHRXx8dGhpcy5yb290Lm93bmVyRG9jdW1lbnQhPWRvY3VtZW50KXRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoImZpbGwiLCJ1cmwoIyIrYSsiKSIpO2Vsc2V7dmFyIGI9dGhpcy5nZXRCYXNlVXJsKCkucmVwbGFjZSgvKFtcKFwpXSkvZywKIlxcJDEiKTt0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJmaWxsIiwidXJsKCIrYisiIyIrYSsiKSIpfWVsc2UgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgiZmlsbCIsU3RyaW5nKGEuZmlsbENvbG9yKS50b0xvd2VyQ2FzZSgpKX07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZ2V0Q3VycmVudFN0cm9rZVdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMubWluU3Ryb2tlV2lkdGgsTWF0aC5tYXgoLjAxLHRoaXMuZm9ybWF0KHRoaXMuc3RhdGUuc3Ryb2tlV2lkdGgqdGhpcy5zdGF0ZS5zY2FsZSkpKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLnVwZGF0ZVN0cm9rZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc3RhdGU7dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlIixTdHJpbmcoYS5zdHJva2VDb2xvcikudG9Mb3dlckNhc2UoKSk7KDE+YS5hbHBoYXx8MT5hLnN0cm9rZUFscGhhKSYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlLW9wYWNpdHkiLGEuYWxwaGEqYS5zdHJva2VBbHBoYSk7dmFyIGI9dGhpcy5nZXRDdXJyZW50U3Ryb2tlV2lkdGgoKTsxIT1iJiZ0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJzdHJva2Utd2lkdGgiLGIpOyJwYXRoIj09dGhpcy5ub2RlLm5vZGVOYW1lJiZ0aGlzLnVwZGF0ZVN0cm9rZUF0dHJpYnV0ZXMoKTthLmRhc2hlZCYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlLWRhc2hhcnJheSIsdGhpcy5jcmVhdGVEYXNoUGF0dGVybigoYS5maXhEYXNoPzE6YS5zdHJva2VXaWR0aCkqYS5zY2FsZSkpfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXBkYXRlU3Ryb2tlQXR0cmlidXRlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc3RhdGU7bnVsbCE9YS5saW5lSm9pbiYmIm1pdGVyIiE9YS5saW5lSm9pbiYmdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlLWxpbmVqb2luIixhLmxpbmVKb2luKTtpZihudWxsIT1hLmxpbmVDYXApe3ZhciBiPWEubGluZUNhcDsiZmxhdCI9PWImJihiPSJidXR0Iik7ImJ1dHQiIT1iJiZ0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJzdHJva2UtbGluZWNhcCIsYil9bnVsbD09YS5taXRlckxpbWl0fHx0aGlzLnN0eWxlRW5hYmxlZCYmMTA9PWEubWl0ZXJMaW1pdHx8dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgic3Ryb2tlLW1pdGVybGltaXQiLGEubWl0ZXJMaW1pdCl9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVEYXNoUGF0dGVybj1mdW5jdGlvbihhKXt2YXIgYj1bXTtpZigic3RyaW5nIj09PXR5cGVvZiB0aGlzLnN0YXRlLmRhc2hQYXR0ZXJuKXt2YXIgYz10aGlzLnN0YXRlLmRhc2hQYXR0ZXJuLnNwbGl0KCIgIik7aWYoMDxjLmxlbmd0aClmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyliW2RdPU51bWJlcihjW2RdKSphfXJldHVybiBiLmpvaW4oIiAiKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVRvbGVyYW5jZT1mdW5jdGlvbihhKXthPWEuY2xvbmVOb2RlKCEwKTt2YXIgYj1wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJzdHJva2Utd2lkdGgiKXx8MSkrdGhpcy5zdHJva2VUb2xlcmFuY2U7YS5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwic3Ryb2tlIik7YS5zZXRBdHRyaWJ1dGUoInZpc2liaWxpdHkiLCJoaWRkZW4iKTthLnJlbW92ZUF0dHJpYnV0ZSgic3Ryb2tlLWRhc2hhcnJheSIpO2Euc2V0QXR0cmlidXRlKCJzdHJva2Utd2lkdGgiLGIpO2Euc2V0QXR0cmlidXRlKCJmaWxsIiwibm9uZSIpO2Euc2V0QXR0cmlidXRlKCJzdHJva2UiLG14Q2xpZW50LklTX09UPyJub25lIjoid2hpdGUiKTtyZXR1cm4gYX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVNoYWRvdz1mdW5jdGlvbihhKXthPWEuY2xvbmVOb2RlKCEwKTt2YXIgYj10aGlzLnN0YXRlOyJub25lIj09YS5nZXRBdHRyaWJ1dGUoImZpbGwiKXx8bXhDbGllbnQuSVNfRkYmJiJ0cmFuc3BhcmVudCI9PWEuZ2V0QXR0cmlidXRlKCJmaWxsIil8fGEuc2V0QXR0cmlidXRlKCJmaWxsIixiLnNoYWRvd0NvbG9yKTsibm9uZSIhPWEuZ2V0QXR0cmlidXRlKCJzdHJva2UiKSYmYS5zZXRBdHRyaWJ1dGUoInN0cm9rZSIsYi5zaGFkb3dDb2xvcik7YS5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsInRyYW5zbGF0ZSgiK3RoaXMuZm9ybWF0KGIuc2hhZG93RHgqYi5zY2FsZSkrIiwiK3RoaXMuZm9ybWF0KGIuc2hhZG93RHkqYi5zY2FsZSkrIikiKyhiLnRyYW5zZm9ybXx8IiIpKTthLnNldEF0dHJpYnV0ZSgib3BhY2l0eSIsYi5zaGFkb3dBbHBoYSk7cmV0dXJuIGF9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5zZXRMaW5rPWZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpdGhpcy5yb290PXRoaXMub3JpZ2luYWxSb290O2Vsc2V7dGhpcy5vcmlnaW5hbFJvb3Q9dGhpcy5yb290O3ZhciBiPXRoaXMuY3JlYXRlRWxlbWVudCgiYSIpO251bGw9PWIuc2V0QXR0cmlidXRlTlN8fHRoaXMucm9vdC5vd25lckRvY3VtZW50IT1kb2N1bWVudCYmbnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP2Iuc2V0QXR0cmlidXRlKCJ4bGluazpocmVmIixhKTpiLnNldEF0dHJpYnV0ZU5TKG14Q29uc3RhbnRzLk5TX1hMSU5LLCJ4bGluazpocmVmIixhKTt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYik7dGhpcy5yb290PWJ9fTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoMCE9YXx8Ynx8Yyl7dmFyIGY9dGhpcy5zdGF0ZTtkKz1mLmR4O2UrPWYuZHk7ZCo9Zi5zY2FsZTtlKj1mLnNjYWxlO2YudHJhbnNmb3JtPWYudHJhbnNmb3JtfHwiIjtpZihiJiZjKWErPTE4MDtlbHNlIGlmKGIhPWMpe3ZhciBnPWI/ZDowLGs9Yj8tMToxLGw9Yz9lOjAsbT1jPy0xOjE7Zi50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoIit0aGlzLmZvcm1hdChnKSsiLCIrdGhpcy5mb3JtYXQobCkrIilzY2FsZSgiK3RoaXMuZm9ybWF0KGspKyIsIit0aGlzLmZvcm1hdChtKSsiKXRyYW5zbGF0ZSgiK3RoaXMuZm9ybWF0KC1nKSsiLCIrdGhpcy5mb3JtYXQoLWwpKyIpIn1pZihiPyFjOmMpYSo9LTE7MCE9YSYmKGYudHJhbnNmb3JtKz0icm90YXRlKCIrdGhpcy5mb3JtYXQoYSkrIiwiK3RoaXMuZm9ybWF0KGQpKyIsIit0aGlzLmZvcm1hdChlKSsiKSIpO2Yucm90YXRpb24rPWE7Zi5yb3RhdGlvbkN4PQpkO2Yucm90YXRpb25DeT1lfX07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuYmVnaW49ZnVuY3Rpb24oKXtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmJlZ2luLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLm5vZGU9dGhpcy5jcmVhdGVFbGVtZW50KCJwYXRoIil9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLnJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5zdGF0ZSxmPXRoaXMuY3JlYXRlRWxlbWVudCgicmVjdCIpO2Yuc2V0QXR0cmlidXRlKCJ4Iix0aGlzLmZvcm1hdCgoYStlLmR4KSplLnNjYWxlKSk7Zi5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KChiK2UuZHkpKmUuc2NhbGUpKTtmLnNldEF0dHJpYnV0ZSgid2lkdGgiLHRoaXMuZm9ybWF0KGMqZS5zY2FsZSkpO2Yuc2V0QXR0cmlidXRlKCJoZWlnaHQiLHRoaXMuZm9ybWF0KGQqZS5zY2FsZSkpO3RoaXMubm9kZT1mfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUucm91bmRyZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLnJlY3QoYSxiLGMsZCk7MDxlJiZ0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJyeCIsdGhpcy5mb3JtYXQoZSp0aGlzLnN0YXRlLnNjYWxlKSk7MDxmJiZ0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJyeSIsdGhpcy5mb3JtYXQoZip0aGlzLnN0YXRlLnNjYWxlKSl9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5zdGF0ZSxmPXRoaXMuY3JlYXRlRWxlbWVudCgiZWxsaXBzZSIpO2Yuc2V0QXR0cmlidXRlKCJjeCIsdGhpcy5mb3JtYXQoKGErYy8yK2UuZHgpKmUuc2NhbGUpKTtmLnNldEF0dHJpYnV0ZSgiY3kiLHRoaXMuZm9ybWF0KChiK2QvMitlLmR5KSplLnNjYWxlKSk7Zi5zZXRBdHRyaWJ1dGUoInJ4IixjLzIqZS5zY2FsZSk7Zi5zZXRBdHRyaWJ1dGUoInJ5IixkLzIqZS5zY2FsZSk7dGhpcy5ub2RlPWZ9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5pbWFnZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2U9dGhpcy5jb252ZXJ0ZXIuY29udmVydChlKTtmPW51bGwhPWY/ZjohMDtnPW51bGwhPWc/ZzohMTtrPW51bGwhPWs/azohMTt2YXIgbD10aGlzLnN0YXRlO2ErPWwuZHg7Yis9bC5keTt2YXIgbT10aGlzLmNyZWF0ZUVsZW1lbnQoImltYWdlIik7bS5zZXRBdHRyaWJ1dGUoIngiLHRoaXMuZm9ybWF0KGEqbC5zY2FsZSkrdGhpcy5pbWFnZU9mZnNldCk7bS5zZXRBdHRyaWJ1dGUoInkiLHRoaXMuZm9ybWF0KGIqbC5zY2FsZSkrdGhpcy5pbWFnZU9mZnNldCk7bS5zZXRBdHRyaWJ1dGUoIndpZHRoIix0aGlzLmZvcm1hdChjKmwuc2NhbGUpKTttLnNldEF0dHJpYnV0ZSgiaGVpZ2h0Iix0aGlzLmZvcm1hdChkKmwuc2NhbGUpKTtudWxsPT1tLnNldEF0dHJpYnV0ZU5TP20uc2V0QXR0cmlidXRlKCJ4bGluazpocmVmIixlKTptLnNldEF0dHJpYnV0ZU5TKG14Q29uc3RhbnRzLk5TX1hMSU5LLAoieGxpbms6aHJlZiIsZSk7Znx8bS5zZXRBdHRyaWJ1dGUoInByZXNlcnZlQXNwZWN0UmF0aW8iLCJub25lIik7KDE+bC5hbHBoYXx8MT5sLmZpbGxBbHBoYSkmJm0uc2V0QXR0cmlidXRlKCJvcGFjaXR5IixsLmFscGhhKmwuZmlsbEFscGhhKTtlPXRoaXMuc3RhdGUudHJhbnNmb3JtfHwiIjtpZihnfHxrKXt2YXIgbj1mPTEscD0wLHE9MDtnJiYoZj0tMSxwPS1jLTIqYSk7ayYmKG49LTEscT0tZC0yKmIpO2UrPSJzY2FsZSgiK2YrIiwiK24rIil0cmFuc2xhdGUoIitwKmwuc2NhbGUrIiwiK3EqbC5zY2FsZSsiKSJ9MDxlLmxlbmd0aCYmbS5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsZSk7dGhpcy5wb2ludGVyRXZlbnRzfHxtLnNldEF0dHJpYnV0ZSgicG9pbnRlci1ldmVudHMiLCJub25lIik7dGhpcy5yb290LmFwcGVuZENoaWxkKG0pfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY29udmVydEh0bWw9ZnVuY3Rpb24oYSl7aWYodGhpcy51c2VEb21QYXJzZXIpe3ZhciBiPShuZXcgRE9NUGFyc2VyKS5wYXJzZUZyb21TdHJpbmcoYSwidGV4dC9odG1sIik7bnVsbCE9YiYmKGE9KG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhiLmJvZHkpLCI8Ym9keSI9PWEuc3Vic3RyaW5nKDAsNSkmJihhPWEuc3Vic3RyaW5nKGEuaW5kZXhPZigiPiIsNSkrMSkpLCI8L2JvZHk+Ij09YS5zdWJzdHJpbmcoYS5sZW5ndGgtNyxhLmxlbmd0aCkmJihhPWEuc3Vic3RyaW5nKDAsYS5sZW5ndGgtNykpKX1lbHNle2lmKG51bGwhPWRvY3VtZW50LmltcGxlbWVudGF0aW9uJiZudWxsIT1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudCl7dmFyIGI9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiLCJodG1sIixudWxsKSxjPWIuY3JlYXRlRWxlbWVudCgiYm9keSIpOwpiLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChjKTt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLmlubmVySFRNTD1hO2ZvcihhPWQuZmlyc3RDaGlsZDtudWxsIT1hOylkPWEubmV4dFNpYmxpbmcsYy5hcHBlbmRDaGlsZChiLmFkb3B0Tm9kZShhKSksYT1kO3JldHVybiBjLmlubmVySFRNTH1iPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRleHRhcmVhIik7Yi5pbm5lckhUTUw9YS5yZXBsYWNlKC8mYW1wOy9nLCImYW1wO2FtcDsiKS5yZXBsYWNlKC8mIzYwOy9nLCImYW1wO2x0OyIpLnJlcGxhY2UoLyYjNjI7L2csIiZhbXA7Z3Q7IikucmVwbGFjZSgvJmx0Oy9nLCImYW1wO2x0OyIpLnJlcGxhY2UoLyZndDsvZywiJmFtcDtndDsiKS5yZXBsYWNlKC88L2csIiZsdDsiKS5yZXBsYWNlKC8+L2csIiZndDsiKTthPWIudmFsdWUucmVwbGFjZSgvJi9nLCImYW1wOyIpLnJlcGxhY2UoLyZhbXA7bHQ7L2csIiZsdDsiKS5yZXBsYWNlKC8mYW1wO2d0Oy9nLCImZ3Q7IikucmVwbGFjZSgvJmFtcDthbXA7L2csCiImYW1wOyIpLnJlcGxhY2UoLzxicj4vZywiPGJyIC8+IikucmVwbGFjZSgvPGhyPi9nLCI8aHIgLz4iKS5yZXBsYWNlKC8oPGltZ1tePl0rKT4vZ20sIiQxIC8+Iil9cmV0dXJuIGF9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS5jcmVhdGVEaXY9ZnVuY3Rpb24oYSl7bXhVdGlscy5pc05vZGUoYSl8fChhPSI8ZGl2PjxkaXY+Iit0aGlzLmNvbnZlcnRIdG1sKGEpKyI8L2Rpdj48L2Rpdj4iKTtpZihteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMXx8IWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUylyZXR1cm4gbXhVdGlscy5pc05vZGUoYSkmJihhPSI8ZGl2PjxkaXY+IitteFV0aWxzLmdldFhtbChhKSsiPC9kaXY+PC9kaXY+IiksbXhVdGlscy5wYXJzZVhtbCgnPGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+JythKyI8L2Rpdj4iKS5kb2N1bWVudEVsZW1lbnQ7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwiZGl2Iik7aWYobXhVdGlscy5pc05vZGUoYSkpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQ9Yy5jbG9uZU5vZGUoITEpO3RoaXMucm9vdC5vd25lckRvY3VtZW50IT0KZG9jdW1lbnQ/Yy5hcHBlbmRDaGlsZChhLmNsb25lTm9kZSghMCkpOmMuYXBwZW5kQ2hpbGQoYSk7ZC5hcHBlbmRDaGlsZChjKTtiLmFwcGVuZENoaWxkKGQpfWVsc2UgYi5pbm5lckhUTUw9YTtyZXR1cm4gYn07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXBkYXRlVGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4pe251bGwhPW4mJm51bGwhPW4uZmlyc3RDaGlsZCYmbnVsbCE9bi5maXJzdENoaWxkLmZpcnN0Q2hpbGQmJnRoaXMudXBkYXRlVGV4dE5vZGVzKGEsYixjLGQsZSxmLGcsayxsLG0sbi5maXJzdENoaWxkKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmFkZEZvcmVpZ25PYmplY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSxuLHAscSxyLHQpe3E9dGhpcy5jcmVhdGVFbGVtZW50KCJnIik7dmFyIHU9dGhpcy5jcmVhdGVFbGVtZW50KCJmb3JlaWduT2JqZWN0Iik7dS5zZXRBdHRyaWJ1dGUoInN0eWxlIiwib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Iik7dS5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwibm9uZSIpO3Iub3duZXJEb2N1bWVudCE9ZG9jdW1lbnQmJihyPW14VXRpbHMuaW1wb3J0Tm9kZUltcGxlbWVudGF0aW9uKHUub3duZXJEb2N1bWVudCxyLCEwKSk7dS5hcHBlbmRDaGlsZChyKTtxLmFwcGVuZENoaWxkKHUpO3RoaXMudXBkYXRlVGV4dE5vZGVzKGEsYixjLGQsZixnLGssbSxuLHAscSk7dGhpcy5yb290Lm93bmVyRG9jdW1lbnQhPWRvY3VtZW50JiYoYT10aGlzLmNyZWF0ZUFsdGVybmF0ZUNvbnRlbnQodSxhLGIsYyxkLGUsZixnLGssbCwKbSxuLHApLG51bGwhPWEmJih1LnNldEF0dHJpYnV0ZSgicmVxdWlyZWRGZWF0dXJlcyIsImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSIpLGI9dGhpcy5jcmVhdGVFbGVtZW50KCJzd2l0Y2giKSxiLmFwcGVuZENoaWxkKHUpLGIuYXBwZW5kQ2hpbGQoYSkscS5hcHBlbmRDaGlsZChiKSkpO3QuYXBwZW5kQ2hpbGQocSl9OwpteFN2Z0NhbnZhczJELnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZXM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGwsbSxuKXt2YXIgcD10aGlzLnN0YXRlLnNjYWxlO214U3ZnQ2FudmFzMkQuY3JlYXRlQ3NzKGMrMixkLGUsZixnLGssbCxudWxsIT10aGlzLnN0YXRlLmZvbnRCYWNrZ3JvdW5kQ29sb3I/dGhpcy5zdGF0ZS5mb250QmFja2dyb3VuZENvbG9yOm51bGwsbnVsbCE9dGhpcy5zdGF0ZS5mb250Qm9yZGVyQ29sb3I/dGhpcy5zdGF0ZS5mb250Qm9yZGVyQ29sb3I6bnVsbCwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSAiKyhmPT1teENvbnN0YW50cy5BTElHTl9UT1A/ImZsZXgtc3RhcnQiOmY9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT8iZmxleC1lbmQiOiJjZW50ZXIiKSsiOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSAiKyhlPT1teENvbnN0YW50cy5BTElHTl9MRUZUPyJmbGV4LXN0YXJ0IjplPT1teENvbnN0YW50cy5BTElHTl9SSUdIVD8iZmxleC1lbmQiOgoiY2VudGVyIikrIjsgIix0aGlzLmdldFRleHRDc3MoKSxwLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMsZCxlLGYsZyl7YSs9dGhpcy5zdGF0ZS5keDtiKz10aGlzLnN0YXRlLmR5O3ZhciBrPW4uZmlyc3RDaGlsZCxsPWsuZmlyc3RDaGlsZCxxPWwuZmlyc3RDaGlsZCxyPSh0aGlzLnJvdGF0ZUh0bWw/dGhpcy5zdGF0ZS5yb3RhdGlvbjowKSsobnVsbCE9bT9tOjApLHQ9KDAhPXRoaXMuZm9PZmZzZXQ/InRyYW5zbGF0ZSgiK3RoaXMuZm9PZmZzZXQrIiAiK3RoaXMuZm9PZmZzZXQrIikiOiIiKSsoMSE9cD8ic2NhbGUoIitwKyIpIjoiIik7cS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgic3R5bGUiLGcpO3Euc2V0QXR0cmlidXRlKCJzdHlsZSIsZik7ay5zZXRBdHRyaWJ1dGUoIndpZHRoIixNYXRoLmNlaWwoMS9NYXRoLm1pbigxLHApKjEwMCkrIiUiKTtrLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixNYXRoLmNlaWwoMS9NYXRoLm1pbigxLHApKjEwMCkrIiUiKTtkPU1hdGgucm91bmQoYisKZCk7MD5kP2suc2V0QXR0cmlidXRlKCJ5IixkKTooay5yZW1vdmVBdHRyaWJ1dGUoInkiKSxlKz0icGFkZGluZy10b3A6ICIrZCsicHg7ICIpO2wuc2V0QXR0cmlidXRlKCJzdHlsZSIsZSsibWFyZ2luLWxlZnQ6ICIrTWF0aC5yb3VuZChhK2MpKyJweDsiKTt0Kz0wIT1yPyJyb3RhdGUoIityKyIgIithKyIgIitiKyIpIjoiIjsiIiE9dD9uLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIix0KTpuLnJlbW92ZUF0dHJpYnV0ZSgidHJhbnNmb3JtIik7MSE9dGhpcy5zdGF0ZS5hbHBoYT9uLnNldEF0dHJpYnV0ZSgib3BhY2l0eSIsdGhpcy5zdGF0ZS5hbHBoYSk6bi5yZW1vdmVBdHRyaWJ1dGUoIm9wYWNpdHkiKX0pKX07Cm14U3ZnQ2FudmFzMkQuY3JlYXRlQ3NzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEpe3A9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMDsgdGV4dC1hbGlnbjogIisoYz09bXhDb25zdGFudHMuQUxJR05fTEVGVD8ibGVmdCI6Yz09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/InJpZ2h0IjoiY2VudGVyIikrIjsgIjt2YXIgcj1teFV0aWxzLmdldEFsaWdubWVudEFzUG9pbnQoYyxkKTtjPSJvdmVyZmxvdzogaGlkZGVuOyAiO2Q9IndpZHRoOiAxcHg7ICI7dmFyIHQ9ImhlaWdodDogMXB4OyAiLHU9ci54KmEscj1yLnkqYjtnPyhkPSJ3aWR0aDogIitNYXRoLnJvdW5kKGEpKyJweDsgIixwKz0ibWF4LWhlaWdodDogIitNYXRoLnJvdW5kKGIpKyJweDsgIixyPTApOiJmaWxsIj09Zj8oZD0id2lkdGg6ICIrTWF0aC5yb3VuZChhKSsicHg7ICIsdD0iaGVpZ2h0OiAiK01hdGgucm91bmQoYikrInB4OyAiLG4rPSJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAiLApwKz1kK3QpOiJ3aWR0aCI9PWY/KGQ9IndpZHRoOiAiK01hdGgucm91bmQoYSkrInB4OyAiLG4rPSJ3aWR0aDogMTAwJTsgIixwKz1kLHI9MCwwPGImJihwKz0ibWF4LWhlaWdodDogIitNYXRoLnJvdW5kKGIpKyJweDsgIikpOihjPSIiLHI9MCk7Yj0iIjtudWxsIT1rJiYoYis9ImJhY2tncm91bmQtY29sb3I6ICIraysiOyAiKTtudWxsIT1sJiYoYis9ImJvcmRlcjogMXB4IHNvbGlkICIrbCsiOyAiKTsiIj09Y3x8Zz9uKz1iOnArPWI7ZSYmMDxhPyhuKz0id2hpdGUtc3BhY2U6IG5vcm1hbDsgd29yZC13cmFwOiAiK214Q29uc3RhbnRzLldPUkRfV1JBUCsiOyAiLGQ9IndpZHRoOiAiK01hdGgucm91bmQoYSkrInB4OyAiLCIiIT1jJiYiZmlsbCIhPWYmJihyPTApKToobis9IndoaXRlLXNwYWNlOiBub3dyYXA7ICIsIiI9PWMmJih1PTApKTtxKHUscixtK2QrdCxwK2MsbixjKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmdldFRleHRDc3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnN0YXRlLGI9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAiK2EuZm9udFNpemUrInB4OyBmb250LWZhbWlseTogIithLmZvbnRGYW1pbHkrIjsgY29sb3I6ICIrYS5mb250Q29sb3IrIjsgbGluZS1oZWlnaHQ6ICIrKG14Q29uc3RhbnRzLkFCU09MVVRFX0xJTkVfSEVJR0hUP2EuZm9udFNpemUqbXhDb25zdGFudHMuTElORV9IRUlHSFQrInB4IjpteENvbnN0YW50cy5MSU5FX0hFSUdIVCp0aGlzLmxpbmVIZWlnaHRDb3JyZWN0aW9uKSsiOyBwb2ludGVyLWV2ZW50czogIisodGhpcy5wb2ludGVyRXZlbnRzP3RoaXMucG9pbnRlckV2ZW50c1ZhbHVlOiJub25lIikrIjsgIjsoYS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xEJiYoYis9ImZvbnQtd2VpZ2h0OiBib2xkOyAiKTsoYS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT0KbXhDb25zdGFudHMuRk9OVF9JVEFMSUMmJihiKz0iZm9udC1zdHlsZTogaXRhbGljOyAiKTt2YXIgYz1bXTsoYS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmYy5wdXNoKCJ1bmRlcmxpbmUiKTsoYS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIKT09bXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIJiZjLnB1c2goImxpbmUtdGhyb3VnaCIpOzA8Yy5sZW5ndGgmJihiKz0idGV4dC1kZWNvcmF0aW9uOiAiK2Muam9pbigiICIpKyI7ICIpO3JldHVybiBifTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUudGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxKXtpZih0aGlzLnRleHRFbmFibGVkJiZudWxsIT1lKWlmKHA9bnVsbCE9cD9wOjAsdGhpcy5mb0VuYWJsZWQmJiJodG1sIj09bCl7dmFyIHI9dGhpcy5jcmVhdGVEaXYoZSk7bnVsbCE9ciYmKG51bGwhPXEmJnIuc2V0QXR0cmlidXRlKCJkaXIiLHEpLHRoaXMuYWRkRm9yZWlnbk9iamVjdChhLGIsYyxkLGUsZixnLGssbCxtLG4scCxxLHIsdGhpcy5yb290KSl9ZWxzZSB0aGlzLnBsYWluVGV4dChhK3RoaXMuc3RhdGUuZHgsYit0aGlzLnN0YXRlLmR5LGMsZCxlLGYsZyxrLG0sbixwLHEpfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlQ2xpcD1mdW5jdGlvbihhLGIsYyxkKXthPU1hdGgucm91bmQoYSk7Yj1NYXRoLnJvdW5kKGIpO2M9TWF0aC5yb3VuZChjKTtkPU1hdGgucm91bmQoZCk7Zm9yKHZhciBlPSJteC1jbGlwLSIrYSsiLSIrYisiLSIrYysiLSIrZCxmPTAsZz1lKyItIitmO251bGwhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGcpOylnPWUrIi0iKyArK2Y7Y2xpcD10aGlzLmNyZWF0ZUVsZW1lbnQoImNsaXBQYXRoIik7Y2xpcC5zZXRBdHRyaWJ1dGUoImlkIixnKTtlPXRoaXMuY3JlYXRlRWxlbWVudCgicmVjdCIpO2Uuc2V0QXR0cmlidXRlKCJ4IixhKTtlLnNldEF0dHJpYnV0ZSgieSIsYik7ZS5zZXRBdHRyaWJ1dGUoIndpZHRoIixjKTtlLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixkKTtjbGlwLmFwcGVuZENoaWxkKGUpO3JldHVybiBjbGlwfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUucGxhaW5UZXh0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwKXtuPW51bGwhPW4/bjowO2s9dGhpcy5zdGF0ZTt2YXIgcT1rLmZvbnRTaXplLHI9dGhpcy5jcmVhdGVFbGVtZW50KCJnIiksdD1rLnRyYW5zZm9ybXx8IiI7dGhpcy51cGRhdGVGb250KHIpOzAhPW4mJih0Kz0icm90YXRlKCIrbisiLCIrdGhpcy5mb3JtYXQoYSprLnNjYWxlKSsiLCIrdGhpcy5mb3JtYXQoYiprLnNjYWxlKSsiKSIpO251bGwhPXAmJnIuc2V0QXR0cmlidXRlKCJkaXJlY3Rpb24iLHApO20mJjA8YyYmMDxkJiYocD1hLG49YixmPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/cC09Yy8yOmY9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYocC09YyksImZpbGwiIT1sJiYoZz09bXhDb25zdGFudHMuQUxJR05fTUlERExFP24tPWQvMjpnPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00mJihuLT1kKSksbj10aGlzLmNyZWF0ZUNsaXAocCprLnNjYWxlLTIsCm4qay5zY2FsZS0yLGMqay5zY2FsZSs0LGQqay5zY2FsZSs0KSxudWxsIT10aGlzLmRlZnM/dGhpcy5kZWZzLmFwcGVuZENoaWxkKG4pOnRoaXMucm9vdC5hcHBlbmRDaGlsZChuKSxteENsaWVudC5JU19DSFJPTUVBUFB8fG14Q2xpZW50LklTX0lFfHxteENsaWVudC5JU19JRTExfHxteENsaWVudC5JU19FREdFfHx0aGlzLnJvb3Qub3duZXJEb2N1bWVudCE9ZG9jdW1lbnQ/ci5zZXRBdHRyaWJ1dGUoImNsaXAtcGF0aCIsInVybCgjIituLmdldEF0dHJpYnV0ZSgiaWQiKSsiKSIpOihwPXRoaXMuZ2V0QmFzZVVybCgpLnJlcGxhY2UoLyhbXChcKV0pL2csIlxcJDEiKSxyLnNldEF0dHJpYnV0ZSgiY2xpcC1wYXRoIiwidXJsKCIrcCsiIyIrbi5nZXRBdHRyaWJ1dGUoImlkIikrIikiKSkpO249Zj09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/ImVuZCI6Zj09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSPyJtaWRkbGUiOiJzdGFydCI7InN0YXJ0IiE9biYmci5zZXRBdHRyaWJ1dGUoInRleHQtYW5jaG9yIiwKbik7dGhpcy5zdHlsZUVuYWJsZWQmJnE9PW14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNJWkV8fHIuc2V0QXR0cmlidXRlKCJmb250LXNpemUiLHEqay5zY2FsZSsicHgiKTswPHQubGVuZ3RoJiZyLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIix0KTsxPmsuYWxwaGEmJnIuc2V0QXR0cmlidXRlKCJvcGFjaXR5IixrLmFscGhhKTt0PWUuc3BsaXQoIlxuIik7cD1NYXRoLnJvdW5kKHEqbXhDb25zdGFudHMuTElORV9IRUlHSFQpO3ZhciB1PXErKHQubGVuZ3RoLTEpKnA7bj1iK3EtMTtnPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/ImZpbGwiPT1sP24tPWQvMjoobT0odGhpcy5tYXRjaEh0bWxBbGlnbm1lbnQmJm0mJjA8ZD9NYXRoLm1pbih1LGQpOnUpLzIsbi09bSk6Zz09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NJiYoImZpbGwiPT1sP24tPWQ6KG09dGhpcy5tYXRjaEh0bWxBbGlnbm1lbnQmJm0mJjA8ZD9NYXRoLm1pbih1LGQpOnUsbi09bSsxKSk7Zm9yKG09MDttPHQubGVuZ3RoO20rKykwPAp0W21dLmxlbmd0aCYmMDxteFV0aWxzLnRyaW0odFttXSkubGVuZ3RoJiYocT10aGlzLmNyZWF0ZUVsZW1lbnQoInRleHQiKSxxLnNldEF0dHJpYnV0ZSgieCIsdGhpcy5mb3JtYXQoYSprLnNjYWxlKSt0aGlzLnRleHRPZmZzZXQpLHEuc2V0QXR0cmlidXRlKCJ5Iix0aGlzLmZvcm1hdChuKmsuc2NhbGUpK3RoaXMudGV4dE9mZnNldCksbXhVdGlscy53cml0ZShxLHRbbV0pLHIuYXBwZW5kQ2hpbGQocSkpLG4rPXA7dGhpcy5yb290LmFwcGVuZENoaWxkKHIpO3RoaXMuYWRkVGV4dEJhY2tncm91bmQocixlLGEsYixjLCJmaWxsIj09bD9kOnUsZixnLGwpfTsKbXhTdmdDYW52YXMyRC5wcm90b3R5cGUudXBkYXRlRm9udD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnN0YXRlO2Euc2V0QXR0cmlidXRlKCJmaWxsIixiLmZvbnRDb2xvcik7dGhpcy5zdHlsZUVuYWJsZWQmJmIuZm9udEZhbWlseT09bXhDb25zdGFudHMuREVGQVVMVF9GT05URkFNSUxZfHxhLnNldEF0dHJpYnV0ZSgiZm9udC1mYW1pbHkiLGIuZm9udEZhbWlseSk7KGIuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRCYmYS5zZXRBdHRyaWJ1dGUoImZvbnQtd2VpZ2h0IiwiYm9sZCIpOyhiLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDJiZhLnNldEF0dHJpYnV0ZSgiZm9udC1zdHlsZSIsIml0YWxpYyIpO3ZhciBjPVtdOyhiLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1VOREVSTElORSk9PW14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FJiZjLnB1c2goInVuZGVybGluZSIpOwooYi5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIKT09bXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIJiZjLnB1c2goImxpbmUtdGhyb3VnaCIpOzA8Yy5sZW5ndGgmJmEuc2V0QXR0cmlidXRlKCJ0ZXh0LWRlY29yYXRpb24iLGMuam9pbigiICIpKX07Cm14U3ZnQ2FudmFzMkQucHJvdG90eXBlLmFkZFRleHRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsKXt2YXIgbT10aGlzLnN0YXRlO2lmKG51bGwhPW0uZm9udEJhY2tncm91bmRDb2xvcnx8bnVsbCE9bS5mb250Qm9yZGVyQ29sb3Ipe3ZhciBuPW51bGw7aWYoImZpbGwiPT1sfHwid2lkdGgiPT1sKWc9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj9jLT1lLzI6Zz09bXhDb25zdGFudHMuQUxJR05fUklHSFQmJihjLT1lKSxrPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/ZC09Zi8yOms9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTSYmKGQtPWYpLG49bmV3IG14UmVjdGFuZ2xlKChjKzEpKm0uc2NhbGUsZCptLnNjYWxlLChlLTIpKm0uc2NhbGUsKGYrMikqbS5zY2FsZSk7ZWxzZSBpZihudWxsIT1hLmdldEJCb3gmJnRoaXMucm9vdC5vd25lckRvY3VtZW50PT1kb2N1bWVudCl0cnl7dmFyIG49YS5nZXRCQm94KCkscD1teENsaWVudC5JU19JRSYmbXhDbGllbnQuSVNfU1ZHLApuPW5ldyBteFJlY3RhbmdsZShuLngsbi55KyhwPzA6MSksbi53aWR0aCxuLmhlaWdodCsocD8xOjApKX1jYXRjaChxKXt9ZWxzZSBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLG4uc3R5bGUubGluZUhlaWdodD1teENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD9tLmZvbnRTaXplKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQsbi5zdHlsZS5mb250U2l6ZT1tLmZvbnRTaXplKyJweCIsbi5zdHlsZS5mb250RmFtaWx5PW0uZm9udEZhbWlseSxuLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCIsbi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLG4uc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIixuLnN0eWxlLmRpc3BsYXk9bXhDbGllbnQuSVNfUVVJUktTPyJpbmxpbmUiOiJpbmxpbmUtYmxvY2siLG4uc3R5bGUuem9vbT0iMSIsKG0uZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRCYmCihuLnN0eWxlLmZvbnRXZWlnaHQ9ImJvbGQiKSwobS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyYmKG4uc3R5bGUuZm9udFN0eWxlPSJpdGFsaWMiKSxiPW14VXRpbHMuaHRtbEVudGl0aWVzKGIsITEpLG4uaW5uZXJIVE1MPWIucmVwbGFjZSgvXG4vZywiPGJyLz4iKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG4pLGU9bi5vZmZzZXRXaWR0aCxmPW4ub2Zmc2V0SGVpZ2h0LG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSxnPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/Yy09ZS8yOmc9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoYy09ZSksaz09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2QtPWYvMjprPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00mJihkLT1mKSxuPW5ldyBteFJlY3RhbmdsZSgoYysxKSptLnNjYWxlLChkKzIpKm0uc2NhbGUsZSptLnNjYWxlLChmKzEpKm0uc2NhbGUpO251bGwhPW4mJihiPQp0aGlzLmNyZWF0ZUVsZW1lbnQoInJlY3QiKSxiLnNldEF0dHJpYnV0ZSgiZmlsbCIsbS5mb250QmFja2dyb3VuZENvbG9yfHwibm9uZSIpLGIuc2V0QXR0cmlidXRlKCJzdHJva2UiLG0uZm9udEJvcmRlckNvbG9yfHwibm9uZSIpLGIuc2V0QXR0cmlidXRlKCJ4IixNYXRoLmZsb29yKG4ueC0xKSksYi5zZXRBdHRyaWJ1dGUoInkiLE1hdGguZmxvb3Iobi55LTEpKSxiLnNldEF0dHJpYnV0ZSgid2lkdGgiLE1hdGguY2VpbChuLndpZHRoKzIpKSxiLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixNYXRoLmNlaWwobi5oZWlnaHQpKSxtPW51bGwhPW0uZm9udEJvcmRlckNvbG9yP01hdGgubWF4KDEsdGhpcy5mb3JtYXQobS5zY2FsZSkpOjAsYi5zZXRBdHRyaWJ1dGUoInN0cm9rZS13aWR0aCIsbSksdGhpcy5yb290Lm93bmVyRG9jdW1lbnQ9PWRvY3VtZW50JiYxPT1teFV0aWxzLm1vZChtLDIpJiZiLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwidHJhbnNsYXRlKDAuNSwgMC41KSIpLGEuaW5zZXJ0QmVmb3JlKGIsCmEuZmlyc3RDaGlsZCkpfX07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuc3Ryb2tlPWZ1bmN0aW9uKCl7dGhpcy5hZGROb2RlKCExLCEwKX07bXhTdmdDYW52YXMyRC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbigpe3RoaXMuYWRkTm9kZSghMCwhMSl9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZpbGxBbmRTdHJva2U9ZnVuY3Rpb24oKXt0aGlzLmFkZE5vZGUoITAsITApfTt2YXIgbXhWbWxDYW52YXMyRD1mdW5jdGlvbihhKXtteEFic3RyYWN0Q2FudmFzMkQuY2FsbCh0aGlzKTt0aGlzLnJvb3Q9YX07bXhVdGlscy5leHRlbmQobXhWbWxDYW52YXMyRCxteEFic3RyYWN0Q2FudmFzMkQpO214Vm1sQ2FudmFzMkQucHJvdG90eXBlLm5vZGU9bnVsbDtteFZtbENhbnZhczJELnByb3RvdHlwZS50ZXh0RW5hYmxlZD0hMDtteFZtbENhbnZhczJELnByb3RvdHlwZS5tb3ZlT3A9Im0iO214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmxpbmVPcD0ibCI7Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmN1cnZlT3A9ImMiO214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNsb3NlT3A9IngiO214Vm1sQ2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZWRIdG1sQmFja2dyb3VuZD0iIjtteFZtbENhbnZhczJELnByb3RvdHlwZS52bWxTY2FsZT0xO214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYSl9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVZtbEVsZW1lbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudChteENsaWVudC5WTUxfUFJFRklYKyI6IithKX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmFkZE5vZGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLm5vZGUsZD10aGlzLnN0YXRlO2lmKG51bGwhPWMpe2lmKCJzaGFwZSI9PWMubm9kZU5hbWUpaWYobnVsbCE9dGhpcy5wYXRoJiYwPHRoaXMucGF0aC5sZW5ndGgpYy5wYXRoPXRoaXMucGF0aC5qb2luKCIgIikrIiBlIixjLnN0eWxlLndpZHRoPXRoaXMucm9vdC5zdHlsZS53aWR0aCxjLnN0eWxlLmhlaWdodD10aGlzLnJvb3Quc3R5bGUuaGVpZ2h0LGMuY29vcmRzaXplPXBhcnNlSW50KGMuc3R5bGUud2lkdGgpKyIgIitwYXJzZUludChjLnN0eWxlLmhlaWdodCk7ZWxzZSByZXR1cm47Yy5zdHJva2V3ZWlnaHQ9dGhpcy5mb3JtYXQoTWF0aC5tYXgoMSxkLnN0cm9rZVdpZHRoKmQuc2NhbGUvdGhpcy52bWxTY2FsZSkpKyJweCI7ZC5zaGFkb3cmJnRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVNoYWRvdyhjLGEmJm51bGwhPWQuZmlsbENvbG9yLGImJm51bGwhPWQuc3Ryb2tlQ29sb3IpKTsKYiYmbnVsbCE9ZC5zdHJva2VDb2xvcj8oYy5zdHJva2VkPSJ0cnVlIixjLnN0cm9rZWNvbG9yPWQuc3Ryb2tlQ29sb3IpOmMuc3Ryb2tlZD0iZmFsc2UiO2MuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVTdHJva2UoKSk7YSYmbnVsbCE9ZC5maWxsQ29sb3I/Yy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUZpbGwoKSk6IXRoaXMucG9pbnRlckV2ZW50c3x8InNoYXBlIj09Yy5ub2RlTmFtZSYmdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGgtMV0hPXRoaXMuY2xvc2VPcD9jLmZpbGxlZD0iZmFsc2UiOmMuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVUcmFuc3BhcmVudEZpbGwoKSk7dGhpcy5yb290LmFwcGVuZENoaWxkKGMpfX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcGFyZW50RmlsbD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgiZmlsbCIpO2Euc3JjPW14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi90cmFuc3BhcmVudC5naWYiO2EudHlwZT0idGlsZSI7cmV0dXJuIGF9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVGaWxsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGF0ZSxiPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgiZmlsbCIpO2IuY29sb3I9YS5maWxsQ29sb3I7aWYobnVsbCE9YS5ncmFkaWVudENvbG9yKXtiLnR5cGU9ImdyYWRpZW50IjtiLm1ldGhvZD0ibm9uZSI7Yi5jb2xvcjI9YS5ncmFkaWVudENvbG9yO3ZhciBjPTE4MC1hLnJvdGF0aW9uLGM9YS5ncmFkaWVudERpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/Yy0oOTArKCJ4Ij09dGhpcy5yb290LnN0eWxlLmZsaXA/MTgwOjApKTphLmdyYWRpZW50RGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVD9jKyg5MCsoIngiPT10aGlzLnJvb3Quc3R5bGUuZmxpcD8xODA6MCkpOmEuZ3JhZGllbnREaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9jLSgxODArKCJ5Ij09dGhpcy5yb290LnN0eWxlLmZsaXA/LTE4MDowKSk6YysoInkiPT0KdGhpcy5yb290LnN0eWxlLmZsaXA/LTE4MDowKTtpZigieCI9PXRoaXMucm9vdC5zdHlsZS5mbGlwfHwieSI9PXRoaXMucm9vdC5zdHlsZS5mbGlwKWMqPS0xO2IuYW5nbGU9bXhVdGlscy5tb2QoYywzNjApO2Iub3BhY2l0eT1hLmFscGhhKmEuZ3JhZGllbnRGaWxsQWxwaGEqMTAwKyIlIjtiLnNldEF0dHJpYnV0ZShteENsaWVudC5PRkZJQ0VfUFJFRklYKyI6b3BhY2l0eTIiLGEuYWxwaGEqYS5ncmFkaWVudEFscGhhKjEwMCsiJSIpfWVsc2UgaWYoMT5hLmFscGhhfHwxPmEuZmlsbEFscGhhKWIub3BhY2l0eT1hLmFscGhhKmEuZmlsbEFscGhhKjEwMCsiJSI7cmV0dXJuIGJ9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVTdHJva2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnN0YXRlLGI9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJzdHJva2UiKTtiLmVuZGNhcD1hLmxpbmVDYXB8fCJmbGF0IjtiLmpvaW5zdHlsZT1hLmxpbmVKb2lufHwibWl0ZXIiO2IubWl0ZXJsaW1pdD1hLm1pdGVyTGltaXR8fCIxMCI7aWYoMT5hLmFscGhhfHwxPmEuc3Ryb2tlQWxwaGEpYi5vcGFjaXR5PWEuYWxwaGEqYS5zdHJva2VBbHBoYSoxMDArIiUiO2EuZGFzaGVkJiYoYi5kYXNoc3R5bGU9dGhpcy5nZXRWbWxEYXNoU3R5bGUoKSk7cmV0dXJuIGJ9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmdldFZtbERhc2hTdHlsZT1mdW5jdGlvbigpe3ZhciBhPSJkYXNoIjtpZigic3RyaW5nIj09PXR5cGVvZiB0aGlzLnN0YXRlLmRhc2hQYXR0ZXJuKXt2YXIgYj10aGlzLnN0YXRlLmRhc2hQYXR0ZXJuLnNwbGl0KCIgIik7MDxiLmxlbmd0aCYmMT09YlswXSYmKGE9IjAgMiIpfXJldHVybiBhfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlU2hhZG93PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnN0YXRlLGU9TWF0aC5QSS8xODAqLWQucm90YXRpb24sZj1NYXRoLmNvcyhlKSxlPU1hdGguc2luKGUpLGc9ZC5zaGFkb3dEeCpkLnNjYWxlLGs9ZC5zaGFkb3dEeSpkLnNjYWxlOyJ4Ij09dGhpcy5yb290LnN0eWxlLmZsaXA/Zyo9LTE6InkiPT10aGlzLnJvb3Quc3R5bGUuZmxpcCYmKGsqPS0xKTt2YXIgbD1hLmNsb25lTm9kZSghMCk7bC5zdHlsZS5tYXJnaW5MZWZ0PU1hdGgucm91bmQoZypmLWsqZSkrInB4IjtsLnN0eWxlLm1hcmdpblRvcD1NYXRoLnJvdW5kKGcqZStrKmYpKyJweCI7OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYobC5zdHJva2V3ZWlnaHQ9YS5zdHJva2V3ZWlnaHQsInNoYXBlIj09YS5ub2RlTmFtZSYmKGwucGF0aD10aGlzLnBhdGguam9pbigiICIpKyIgZSIsbC5zdHlsZS53aWR0aD10aGlzLnJvb3Quc3R5bGUud2lkdGgsbC5zdHlsZS5oZWlnaHQ9CnRoaXMucm9vdC5zdHlsZS5oZWlnaHQsbC5jb29yZHNpemU9cGFyc2VJbnQoYS5zdHlsZS53aWR0aCkrIiAiK3BhcnNlSW50KGEuc3R5bGUuaGVpZ2h0KSkpO2M/KGwuc3Ryb2tlY29sb3I9ZC5zaGFkb3dDb2xvcixsLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlU2hhZG93U3Ryb2tlKCkpKTpsLnN0cm9rZWQ9ImZhbHNlIjtiP2wuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVTaGFkb3dGaWxsKCkpOmwuZmlsbGVkPSJmYWxzZSI7cmV0dXJuIGx9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd0ZpbGw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoImZpbGwiKTthLmNvbG9yPXRoaXMuc3RhdGUuc2hhZG93Q29sb3I7YS5vcGFjaXR5PXRoaXMuc3RhdGUuYWxwaGEqdGhpcy5zdGF0ZS5zaGFkb3dBbHBoYSoxMDArIiUiO3JldHVybiBhfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuY3JlYXRlU2hhZG93U3Ryb2tlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jcmVhdGVTdHJva2UoKTthLm9wYWNpdHk9dGhpcy5zdGF0ZS5hbHBoYSp0aGlzLnN0YXRlLnNoYWRvd0FscGhhKjEwMCsiJSI7cmV0dXJuIGF9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe2ImJmM/YSs9MTgwOmI/dGhpcy5yb290LnN0eWxlLmZsaXA9IngiOmMmJih0aGlzLnJvb3Quc3R5bGUuZmxpcD0ieSIpO2lmKGI/IWM6YylhKj0tMTt0aGlzLnJvb3Quc3R5bGUucm90YXRpb249YTt0aGlzLnN0YXRlLnJvdGF0aW9uKz1hO3RoaXMuc3RhdGUucm90YXRpb25DeD1kO3RoaXMuc3RhdGUucm90YXRpb25DeT1lfTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUuYmVnaW49ZnVuY3Rpb24oKXtteEFic3RyYWN0Q2FudmFzMkQucHJvdG90eXBlLmJlZ2luLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLm5vZGU9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJzaGFwZSIpO3RoaXMubm9kZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUifTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUucXVhZFRvPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuc3RhdGUsZj0odGhpcy5sYXN0WCtlLmR4KSplLnNjYWxlLGc9KHRoaXMubGFzdFkrZS5keSkqZS5zY2FsZTthPShhK2UuZHgpKmUuc2NhbGU7Yj0oYitlLmR5KSplLnNjYWxlO2M9KGMrZS5keCkqZS5zY2FsZTtkPShkK2UuZHkpKmUuc2NhbGU7dmFyIGc9ZysyLzMqKGItZyksaz1jKzIvMyooYS1jKTtiPWQrMi8zKihiLWQpO3RoaXMucGF0aC5wdXNoKCJjICIrdGhpcy5mb3JtYXQoZisyLzMqKGEtZikpKyIgIit0aGlzLmZvcm1hdChnKSsiICIrdGhpcy5mb3JtYXQoaykrIiAiK3RoaXMuZm9ybWF0KGIpKyIgIit0aGlzLmZvcm1hdChjKSsiICIrdGhpcy5mb3JtYXQoZCkpO3RoaXMubGFzdFg9Yy9lLnNjYWxlLWUuZHg7dGhpcy5sYXN0WT1kL2Uuc2NhbGUtZS5keX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLmNyZWF0ZVJlY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLnN0YXRlO2E9dGhpcy5jcmVhdGVWbWxFbGVtZW50KGEpO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjthLnN0eWxlLmxlZnQ9dGhpcy5mb3JtYXQoKGIrZi5keCkqZi5zY2FsZSkrInB4IjthLnN0eWxlLnRvcD10aGlzLmZvcm1hdCgoYytmLmR5KSpmLnNjYWxlKSsicHgiO2Euc3R5bGUud2lkdGg9dGhpcy5mb3JtYXQoZCpmLnNjYWxlKSsicHgiO2Euc3R5bGUuaGVpZ2h0PXRoaXMuZm9ybWF0KGUqZi5zY2FsZSkrInB4IjtyZXR1cm4gYX07bXhWbWxDYW52YXMyRC5wcm90b3R5cGUucmVjdD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLm5vZGU9dGhpcy5jcmVhdGVSZWN0KCJyZWN0IixhLGIsYyxkKX07Cm14Vm1sQ2FudmFzMkQucHJvdG90eXBlLnJvdW5kcmVjdD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5ub2RlPXRoaXMuY3JlYXRlUmVjdCgicm91bmRyZWN0IixhLGIsYyxkKTt0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJhcmNzaXplIixNYXRoLm1heCgxMDAqZS9jLDEwMCpmL2QpKyIlIil9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5ub2RlPXRoaXMuY3JlYXRlUmVjdCgib3ZhbCIsYSxiLGMsZCl9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5pbWFnZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2Y/KGE9dGhpcy5jcmVhdGVSZWN0KCJyZWN0IixhLGIsYyxkKSxhLnN0cm9rZWQ9ImZhbHNlIixiPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgiZmlsbCIpLGIuYXNwZWN0PWY/ImF0bW9zdCI6Imlnbm9yZSIsYi5yb3RhdGU9InRydWUiLGIudHlwZT0iZnJhbWUiLGIuc3JjPWUsYS5hcHBlbmRDaGlsZChiKSk6KGE9dGhpcy5jcmVhdGVSZWN0KCJpbWFnZSIsYSxiLGMsZCksYS5zcmM9ZSk7ZyYmaz9hLnN0eWxlLnJvdGF0aW9uPSIxODAiOmc/YS5zdHlsZS5mbGlwPSJ4IjprJiYoYS5zdHlsZS5mbGlwPSJ5Iik7aWYoMT50aGlzLnN0YXRlLmFscGhhfHwxPnRoaXMuc3RhdGUuZmlsbEFscGhhKWEuc3R5bGUuZmlsdGVyKz0iYWxwaGEob3BhY2l0eT0iK3RoaXMuc3RhdGUuYWxwaGEqdGhpcy5zdGF0ZS5maWxsQWxwaGEqMTAwKyIpIjt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYSl9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS5jcmVhdGVEaXY9ZnVuY3Rpb24oYSxiLGMsZCl7Yz10aGlzLmNyZWF0ZUVsZW1lbnQoImRpdiIpO3ZhciBlPXRoaXMuc3RhdGUsZj0iIjtudWxsIT1lLmZvbnRCYWNrZ3JvdW5kQ29sb3ImJihmKz0iYmFja2dyb3VuZC1jb2xvcjoiK214VXRpbHMuaHRtbEVudGl0aWVzKGUuZm9udEJhY2tncm91bmRDb2xvcikrIjsiKTtudWxsIT1lLmZvbnRCb3JkZXJDb2xvciYmKGYrPSJib3JkZXI6MXB4IHNvbGlkICIrbXhVdGlscy5odG1sRW50aXRpZXMoZS5mb250Qm9yZGVyQ29sb3IpKyI7Iik7bXhVdGlscy5pc05vZGUoYSk/Yy5hcHBlbmRDaGlsZChhKToiZmlsbCIhPWQmJiJ3aWR0aCIhPWQ/KGQ9dGhpcy5jcmVhdGVFbGVtZW50KCJkaXYiKSxkLnN0eWxlLmNzc1RleHQ9ZixkLnN0eWxlLmRpc3BsYXk9bXhDbGllbnQuSVNfUVVJUktTPyJpbmxpbmUiOiJpbmxpbmUtYmxvY2siLGQuc3R5bGUuem9vbT0iMSIsZC5zdHlsZS50ZXh0RGVjb3JhdGlvbj0KImluaGVyaXQiLGQuaW5uZXJIVE1MPWEsYy5hcHBlbmRDaGlsZChkKSk6KGMuc3R5bGUuY3NzVGV4dD1mLGMuaW5uZXJIVE1MPWEpO2E9Yy5zdHlsZTthLmZvbnRTaXplPWUuZm9udFNpemUvdGhpcy52bWxTY2FsZSsicHgiO2EuZm9udEZhbWlseT1lLmZvbnRGYW1pbHk7YS5jb2xvcj1lLmZvbnRDb2xvcjthLnZlcnRpY2FsQWxpZ249InRvcCI7YS50ZXh0QWxpZ249Ynx8ImxlZnQiO2EubGluZUhlaWdodD1teENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD9lLmZvbnRTaXplKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUL3RoaXMudm1sU2NhbGUrInB4IjpteENvbnN0YW50cy5MSU5FX0hFSUdIVDsoZS5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xEJiYoYS5mb250V2VpZ2h0PSJib2xkIik7KGUuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUMmJihhLmZvbnRTdHlsZT0iaXRhbGljIik7CihlLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1VOREVSTElORSk9PW14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FJiYoYS50ZXh0RGVjb3JhdGlvbj0idW5kZXJsaW5lIik7cmV0dXJuIGN9OwpteFZtbENhbnZhczJELnByb3RvdHlwZS50ZXh0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEpe2lmKHRoaXMudGV4dEVuYWJsZWQmJm51bGwhPWUpe3ZhciByPXRoaXMuc3RhdGU7aWYoImh0bWwiPT1sKXtudWxsIT1yLnJvdGF0aW9uJiYoYj10aGlzLnJvdGF0ZVBvaW50KGEsYixyLnJvdGF0aW9uLHIucm90YXRpb25DeCxyLnJvdGF0aW9uQ3kpLGE9Yi54LGI9Yi55KTs4IT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VNPyhhKj1yLnNjYWxlLGIqPXIuc2NhbGUpOihhKz1yLmR4LGIrPXIuZHksImZpbGwiIT1tJiZnPT1teENvbnN0YW50cy5BTElHTl9UT1AmJi0tYik7bD04IT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VNP3RoaXMuY3JlYXRlRWxlbWVudCgiZGl2Iik6dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJncm91cCIpO2wuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtsLnN0eWxlLmRpc3BsYXk9ImlubGluZSI7bC5zdHlsZS5sZWZ0PQp0aGlzLmZvcm1hdChhKSsicHgiO2wuc3R5bGUudG9wPXRoaXMuZm9ybWF0KGIpKyJweCI7bC5zdHlsZS56b29tPXIuc2NhbGU7dmFyIHQ9dGhpcy5jcmVhdGVFbGVtZW50KCJkaXYiKTt0LnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7dC5zdHlsZS5kaXNwbGF5PSJpbmxpbmUiO3ZhciB1PW14VXRpbHMuZ2V0QWxpZ25tZW50QXNQb2ludChmLGcpLHg9dS54LHU9dS55O2U9dGhpcy5jcmVhdGVEaXYoZSxmLGcsbSk7Zj10aGlzLmNyZWF0ZUVsZW1lbnQoImRpdiIpO251bGwhPXEmJmUuc2V0QXR0cmlidXRlKCJkaXIiLHEpO2lmKGsmJjA8Yyl7aWYobnx8KGUuc3R5bGUud2lkdGg9TWF0aC5yb3VuZChjKSsicHgiKSxlLnN0eWxlLndvcmRXcmFwPW14Q29uc3RhbnRzLldPUkRfV1JBUCxlLnN0eWxlLndoaXRlU3BhY2U9Im5vcm1hbCIsImJyZWFrLXdvcmQiPT1lLnN0eWxlLndvcmRXcmFwKXt2YXIgeT1lO251bGwhPXkuZmlyc3RDaGlsZCYmIkRJViI9PXkuZmlyc3RDaGlsZC5ub2RlTmFtZSYmCih5LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9IjEwMCUiKX19ZWxzZSBlLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7cD1yLnJvdGF0aW9uKyhwfHwwKTt0aGlzLnJvdGF0ZUh0bWwmJjAhPXA/KGYuc3R5bGUuZGlzcGxheT0iaW5saW5lIixmLnN0eWxlLnpvb209IjEiLGYuYXBwZW5kQ2hpbGQoZSksOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTXx8IkRJViI9PXRoaXMucm9vdC5ub2RlTmFtZT9sLmFwcGVuZENoaWxkKGYpOih0LmFwcGVuZENoaWxkKGYpLGwuYXBwZW5kQ2hpbGQodCkpKTo4IT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VNPyhlLnN0eWxlLmRpc3BsYXk9ImlubGluZSIsbC5hcHBlbmRDaGlsZChlKSk6KHQuYXBwZW5kQ2hpbGQoZSksbC5hcHBlbmRDaGlsZCh0KSk7IkRJViIhPXRoaXMucm9vdC5ub2RlTmFtZT8ocT10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoInJlY3QiKSxxLnN0cm9rZWQ9ImZhbHNlIixxLmZpbGxlZD0iZmFsc2UiLApxLmFwcGVuZENoaWxkKGwpLHRoaXMucm9vdC5hcHBlbmRDaGlsZChxKSk6dGhpcy5yb290LmFwcGVuZENoaWxkKGwpO24/KGUuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIsZS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKGMpKyJweCIsbXhDbGllbnQuSVNfUVVJUktTfHwoZS5zdHlsZS5tYXhIZWlnaHQ9TWF0aC5yb3VuZChkKSsicHgiKSk6ImZpbGwiPT1tPyhlLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iLGUuc3R5bGUud2lkdGg9TWF0aC5tYXgoMCxjKSsxKyJweCIsZS5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxkKSsxKyJweCIpOiJ3aWR0aCI9PW0mJihlLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iLGUuc3R5bGUud2lkdGg9TWF0aC5tYXgoMCxjKSsxKyJweCIsZS5zdHlsZS5tYXhIZWlnaHQ9TWF0aC5tYXgoMCxkKSsxKyJweCIpO2lmKHRoaXMucm90YXRlSHRtbCYmMCE9cCl7eT1NYXRoLlBJLzE4MCpwO3A9cGFyc2VGbG9hdChwYXJzZUZsb2F0KE1hdGguY29zKHkpKS50b0ZpeGVkKDgpKTsKcT1wYXJzZUZsb2F0KHBhcnNlRmxvYXQoTWF0aC5zaW4oLXkpKS50b0ZpeGVkKDgpKTt5JT0yKk1hdGguUEk7MD55JiYoeSs9MipNYXRoLlBJKTt5JT1NYXRoLlBJO3k+TWF0aC5QSS8yJiYoeT1NYXRoLlBJLXkpO2c9TWF0aC5jb3MoeSk7dmFyIEI9TWF0aC5zaW4oeSk7OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTXx8KGUuc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIixmLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayIsdC5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siKTtlLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiI7ZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSk7dD1lO251bGwhPXQuZmlyc3RDaGlsZCYmIkRJViI9PXQuZmlyc3RDaGlsZC5ub2RlTmFtZSYmKHQ9dC5maXJzdENoaWxkKTt5PXQub2Zmc2V0V2lkdGgrMzt0PXQub2Zmc2V0SGVpZ2h0O24/KGM9TWF0aC5taW4oYyx5KSx0PQpNYXRoLm1pbih0LGQpKTpjPXk7ayYmKGUuc3R5bGUud2lkdGg9YysicHgiKTtteENsaWVudC5JU19RVUlSS1MmJihufHwid2lkdGgiPT1tKSYmdD5kJiYodD1kLGUuc3R5bGUuaGVpZ2h0PXQrInB4Iik7ZD10O249KGQtZCpnK2MqLUIpLzItcSpjKih4Ky41KStwKmQqKHUrLjUpO2s9KGMtYypnK2QqLUIpLzIrcCpjKih4Ky41KStxKmQqKHUrLjUpOyJncm91cCI9PWwubm9kZU5hbWUmJiJESVYiPT10aGlzLnJvb3Qubm9kZU5hbWU/KG09dGhpcy5jcmVhdGVFbGVtZW50KCJkaXYiKSxtLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayIsbS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLG0uc3R5bGUubGVmdD10aGlzLmZvcm1hdChhKyhrLWMvMikqci5zY2FsZSkrInB4IixtLnN0eWxlLnRvcD10aGlzLmZvcm1hdChiKyhuLWQvMikqci5zY2FsZSkrInB4IixsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobSksbS5hcHBlbmRDaGlsZChsKSk6KHI9OCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwKbXhDbGllbnQuSVNfRU0/ci5zY2FsZToxLGwuc3R5bGUubGVmdD10aGlzLmZvcm1hdChhKyhrLWMvMikqcikrInB4IixsLnN0eWxlLnRvcD10aGlzLmZvcm1hdChiKyhuLWQvMikqcikrInB4Iik7Zi5zdHlsZS5maWx0ZXI9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPSIrcCsiLCBNMTI9IitxKyIsIE0yMT0iKy1xKyIsIE0yMj0iK3ArIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpIjtmLnN0eWxlLmJhY2tncm91bmRDb2xvcj10aGlzLnJvdGF0ZWRIdG1sQmFja2dyb3VuZDsxPnRoaXMuc3RhdGUuYWxwaGEmJihmLnN0eWxlLmZpbHRlcis9ImFscGhhKG9wYWNpdHk9IisxMDAqdGhpcy5zdGF0ZS5hbHBoYSsiKSIpO2YuYXBwZW5kQ2hpbGQoZSk7ZS5zdHlsZS5wb3NpdGlvbj0iIjtlLnN0eWxlLnZpc2liaWxpdHk9IiJ9ZWxzZSA4IT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VNPyhlLnN0eWxlLnZlcnRpY2FsQWxpZ249CiJ0b3AiLDE+dGhpcy5zdGF0ZS5hbHBoYSYmKGwuc3R5bGUuZmlsdGVyPSJhbHBoYShvcGFjaXR5PSIrMTAwKnRoaXMuc3RhdGUuYWxwaGErIikiKSxyPWUucGFyZW50Tm9kZSxlLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKSxjPWUub2Zmc2V0V2lkdGgsdD1lLm9mZnNldEhlaWdodCxteENsaWVudC5JU19RVUlSS1MmJm4mJnQ+ZCYmKHQ9ZCxlLnN0eWxlLmhlaWdodD10KyJweCIpLGQ9dCxlLnN0eWxlLnZpc2liaWxpdHk9IiIsci5hcHBlbmRDaGlsZChlKSxsLnN0eWxlLmxlZnQ9dGhpcy5mb3JtYXQoYStjKngqdGhpcy5zdGF0ZS5zY2FsZSkrInB4IixsLnN0eWxlLnRvcD10aGlzLmZvcm1hdChiK2QqdSp0aGlzLnN0YXRlLnNjYWxlKSsicHgiKTooMT50aGlzLnN0YXRlLmFscGhhJiYoZS5zdHlsZS5maWx0ZXI9ImFscGhhKG9wYWNpdHk9IisxMDAqdGhpcy5zdGF0ZS5hbHBoYSsiKSIpLHQuc3R5bGUubGVmdD0xMDAqeCsiJSIsdC5zdHlsZS50b3A9CjEwMCp1KyIlIil9ZWxzZSB0aGlzLnBsYWluVGV4dChhLGIsYyxkLG14VXRpbHMuaHRtbEVudGl0aWVzKGUsITEpLGYsZyxrLGwsbSxuLHAscSl9fTsKbXhWbWxDYW52YXMyRC5wcm90b3R5cGUucGxhaW5UZXh0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0sbixwLHEpe2s9dGhpcy5zdGF0ZTthPShhK2suZHgpKmsuc2NhbGU7Yj0oYitrLmR5KSprLnNjYWxlO2M9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJzaGFwZSIpO2Muc3R5bGUud2lkdGg9IjFweCI7Yy5zdHlsZS5oZWlnaHQ9IjFweCI7Yy5zdHJva2VkPSJmYWxzZSI7ZD10aGlzLmNyZWF0ZVZtbEVsZW1lbnQoImZpbGwiKTtkLmNvbG9yPWsuZm9udENvbG9yO2Qub3BhY2l0eT0xMDAqay5hbHBoYSsiJSI7Yy5hcHBlbmRDaGlsZChkKTtkPXRoaXMuY3JlYXRlVm1sRWxlbWVudCgicGF0aCIpO2QudGV4dHBhdGhvaz0idHJ1ZSI7ZC52PSJtICIrdGhpcy5mb3JtYXQoMCkrIiAiK3RoaXMuZm9ybWF0KDApKyIgbCAiK3RoaXMuZm9ybWF0KDEpKyIgIit0aGlzLmZvcm1hdCgwKTtjLmFwcGVuZENoaWxkKGQpO2Q9dGhpcy5jcmVhdGVWbWxFbGVtZW50KCJ0ZXh0cGF0aCIpO2Quc3R5bGUuY3NzVGV4dD0KInYtdGV4dC1hbGlnbjoiK2Y7ZC5zdHlsZS5hbGlnbj1mO2Quc3R5bGUuZm9udEZhbWlseT1rLmZvbnRGYW1pbHk7ZC5zdHJpbmc9ZTtkLm9uPSJ0cnVlIjtmPWsuZm9udFNpemUqay5zY2FsZS90aGlzLnZtbFNjYWxlO2Quc3R5bGUuZm9udFNpemU9ZisicHgiOyhrLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQmJihkLnN0eWxlLmZvbnRXZWlnaHQ9ImJvbGQiKTsoay5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQyYmKGQuc3R5bGUuZm9udFN0eWxlPSJpdGFsaWMiKTsoay5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmKGQuc3R5bGUudGV4dERlY29yYXRpb249InVuZGVybGluZSIpO2U9ZS5zcGxpdCgiXG4iKTtrPWYrKGUubGVuZ3RoLTEpKmYqbXhDb25zdGFudHMuTElORV9IRUlHSFQ7Zj1lPTA7Cmc9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT9mPS1rLzI6ZyE9bXhDb25zdGFudHMuQUxJR05fTUlERExFJiYoZj1rLzIpO251bGwhPXAmJihjLnN0eWxlLnJvdGF0aW9uPXAsZz1NYXRoLlBJLzE4MCpwLGU9TWF0aC5zaW4oZykqZixmKj1NYXRoLmNvcyhnKSk7Yy5hcHBlbmRDaGlsZChkKTtjLnN0eWxlLmxlZnQ9dGhpcy5mb3JtYXQoYS1lKSsicHgiO2Muc3R5bGUudG9wPXRoaXMuZm9ybWF0KGIrZikrInB4Ijt0aGlzLnJvb3QuYXBwZW5kQ2hpbGQoYyl9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLnN0cm9rZT1mdW5jdGlvbigpe3RoaXMuYWRkTm9kZSghMSwhMCl9O214Vm1sQ2FudmFzMkQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oKXt0aGlzLmFkZE5vZGUoITAsITEpfTtteFZtbENhbnZhczJELnByb3RvdHlwZS5maWxsQW5kU3Ryb2tlPWZ1bmN0aW9uKCl7dGhpcy5hZGROb2RlKCEwLCEwKX07CmZ1bmN0aW9uIG14R3VpZGUoYSxiKXt0aGlzLmdyYXBoPWE7dGhpcy5zZXRTdGF0ZXMoYil9bXhHdWlkZS5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEd1aWRlLnByb3RvdHlwZS5zdGF0ZXM9bnVsbDtteEd1aWRlLnByb3RvdHlwZS5ob3Jpem9udGFsPSEwO214R3VpZGUucHJvdG90eXBlLnZlcnRpY2FsPSEwO214R3VpZGUucHJvdG90eXBlLmd1aWRlWD1udWxsO214R3VpZGUucHJvdG90eXBlLmd1aWRlWT1udWxsO214R3VpZGUucHJvdG90eXBlLnJvdW5kZWQ9ITE7bXhHdWlkZS5wcm90b3R5cGUudG9sZXJhbmNlPTI7bXhHdWlkZS5wcm90b3R5cGUuc2V0U3RhdGVzPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdGVzPWF9O214R3VpZGUucHJvdG90eXBlLmlzRW5hYmxlZEZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiEwfTsKbXhHdWlkZS5wcm90b3R5cGUuZ2V0R3VpZGVUb2xlcmFuY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJnRoaXMuZ3JhcGguZ3JpZEVuYWJsZWQ/dGhpcy5ncmFwaC5ncmlkU2l6ZS8yOnRoaXMudG9sZXJhbmNlfTtteEd1aWRlLnByb3RvdHlwZS5jcmVhdGVHdWlkZVNoYXBlPWZ1bmN0aW9uKGEpe2E9bmV3IG14UG9seWxpbmUoW10sbXhDb25zdGFudHMuR1VJREVfQ09MT1IsbXhDb25zdGFudHMuR1VJREVfU1RST0tFV0lEVEgpO2EuaXNEYXNoZWQ9ITA7cmV0dXJuIGF9O214R3VpZGUucHJvdG90eXBlLmlzU3RhdGVJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiExfTsKbXhHdWlkZS5wcm90b3R5cGUubW92ZT1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT10aGlzLnN0YXRlcyYmKHRoaXMuaG9yaXpvbnRhbHx8dGhpcy52ZXJ0aWNhbCkmJm51bGwhPWEmJm51bGwhPWIpe2Q9ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPSExO2UmJk1hdGguYWJzKGMteik8dD8oYi55PWMtYS5nZXRDZW50ZXJZKCksdD1NYXRoLmFicyhjLXopLGY9ITApOmV8fChNYXRoLmFicyhjLUIpPHQ/KGIueT1jLWEueSx0PU1hdGguYWJzKGMtQiksZj0hMCk6TWF0aC5hYnMoYy1BKTx0JiYoYi55PWMtYS55LWEuaGVpZ2h0LHQ9TWF0aC5hYnMoYy1BKSxmPSEwKSk7ZiYmKHA9ZCxxPWMsbnVsbD09dGhpcy5ndWlkZVkmJih0aGlzLmd1aWRlWT10aGlzLmNyZWF0ZUd1aWRlU2hhcGUoITEpLHRoaXMuZ3VpZGVZLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX1ZNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRyx0aGlzLmd1aWRlWS5wb2ludGVyRXZlbnRzPQohMSx0aGlzLmd1aWRlWS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpKSk7bj1ufHxmfTt2YXIgZT1mdW5jdGlvbihjLGQsZSl7dmFyIGY9ITE7ZSYmTWF0aC5hYnMoYy15KTxyPyhiLng9Yy1hLmdldENlbnRlclgoKSxyPU1hdGguYWJzKGMteSksZj0hMCk6ZXx8KE1hdGguYWJzKGMtdSk8cj8oYi54PWMtYS54LHI9TWF0aC5hYnMoYy11KSxmPSEwKTpNYXRoLmFicyhjLXgpPHImJihiLng9Yy1hLngtYS53aWR0aCxyPU1hdGguYWJzKGMteCksZj0hMCkpO2YmJihsPWQsbT1jLG51bGw9PXRoaXMuZ3VpZGVYJiYodGhpcy5ndWlkZVg9dGhpcy5jcmVhdGVHdWlkZVNoYXBlKCEwKSx0aGlzLmd1aWRlWC5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsdGhpcy5ndWlkZVgucG9pbnRlckV2ZW50cz0hMSx0aGlzLmd1aWRlWC5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpKSk7Cms9a3x8Zn0sZj10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxmPXRoaXMuZ2V0R3VpZGVUb2xlcmFuY2UoYykqZixnPWEuY2xvbmUoKTtnLngrPWIueDtnLnkrPWIueTtmb3IodmFyIGs9ITEsbD1udWxsLG09bnVsbCxuPSExLHA9bnVsbCxxPW51bGwscj1mLHQ9Zix1PWcueCx4PWcueCtnLndpZHRoLHk9Zy5nZXRDZW50ZXJYKCksQj1nLnksQT1nLnkrZy5oZWlnaHQsej1nLmdldENlbnRlclkoKSxmPTA7Zjx0aGlzLnN0YXRlcy5sZW5ndGg7ZisrKWc9dGhpcy5zdGF0ZXNbZl0sbnVsbD09Z3x8dGhpcy5pc1N0YXRlSWdub3JlZChnKXx8KHRoaXMuaG9yaXpvbnRhbCYmKGUuY2FsbCh0aGlzLGcuZ2V0Q2VudGVyWCgpLGcsITApLGUuY2FsbCh0aGlzLGcueCxnLCExKSxlLmNhbGwodGhpcyxnLngrZy53aWR0aCxnLCExKSxudWxsPT1nLmNlbGwmJmUuY2FsbCh0aGlzLGcuZ2V0Q2VudGVyWCgpLGcsITEpKSx0aGlzLnZlcnRpY2FsJiYoZC5jYWxsKHRoaXMsZy5nZXRDZW50ZXJZKCksZywKITApLGQuY2FsbCh0aGlzLGcueSxnLCExKSxkLmNhbGwodGhpcyxnLnkrZy5oZWlnaHQsZywhMSksbnVsbD09Zy5jZWxsJiZkLmNhbGwodGhpcyxnLmdldENlbnRlclkoKSxnLCExKSkpO3RoaXMuZ3JhcGguc25hcERlbHRhKGIsYSwhYyxrLG4pO2I9dGhpcy5nZXREZWx0YShhLGwsYi54LHAsYi55KTtjPXRoaXMuZ3JhcGguY29udGFpbmVyO2t8fG51bGw9PXRoaXMuZ3VpZGVYP251bGwhPXRoaXMuZ3VpZGVYJiYoZT1kPW51bGwsbnVsbCE9bCYmbnVsbCE9YSYmKGQ9TWF0aC5taW4oYS55K2IueS10aGlzLmdyYXBoLnBhbkR5LGwueSksZT1NYXRoLm1heChhLnkrYS5oZWlnaHQrYi55LXRoaXMuZ3JhcGgucGFuRHksbC55K2wuaGVpZ2h0KSksdGhpcy5ndWlkZVgucG9pbnRzPW51bGwhPWQmJm51bGwhPWU/W25ldyBteFBvaW50KG0sZCksbmV3IG14UG9pbnQobSxlKV06W25ldyBteFBvaW50KG0sLXRoaXMuZ3JhcGgucGFuRHkpLG5ldyBteFBvaW50KG0sYy5zY3JvbGxIZWlnaHQtMy10aGlzLmdyYXBoLnBhbkR5KV0sCnRoaXMuZ3VpZGVYLnN0cm9rZT10aGlzLmdldEd1aWRlQ29sb3IobCwhMCksdGhpcy5ndWlkZVgubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIix0aGlzLmd1aWRlWC5yZWRyYXcoKSk6dGhpcy5ndWlkZVgubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iO258fG51bGw9PXRoaXMuZ3VpZGVZP251bGwhPXRoaXMuZ3VpZGVZJiYoZT1kPW51bGwsbnVsbCE9cCYmbnVsbCE9YSYmKGQ9TWF0aC5taW4oYS54K2IueC10aGlzLmdyYXBoLnBhbkR4LHAueCksZT1NYXRoLm1heChhLngrYS53aWR0aCtiLngtdGhpcy5ncmFwaC5wYW5EeCxwLngrcC53aWR0aCkpLHRoaXMuZ3VpZGVZLnBvaW50cz1udWxsIT1kJiZudWxsIT1lP1tuZXcgbXhQb2ludChkLHEpLG5ldyBteFBvaW50KGUscSldOltuZXcgbXhQb2ludCgtdGhpcy5ncmFwaC5wYW5EeCxxKSxuZXcgbXhQb2ludChjLnNjcm9sbFdpZHRoLTMtdGhpcy5ncmFwaC5wYW5EeCxxKV0sdGhpcy5ndWlkZVkuc3Ryb2tlPXRoaXMuZ2V0R3VpZGVDb2xvcihwLAohMSksdGhpcy5ndWlkZVkubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIix0aGlzLmd1aWRlWS5yZWRyYXcoKSk6dGhpcy5ndWlkZVkubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4ifXJldHVybiBifTtteEd1aWRlLnByb3RvdHlwZS5nZXREZWx0YT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuZ3JhcGgudmlldy5zY2FsZTtpZih0aGlzLnJvdW5kZWR8fG51bGwhPWImJm51bGw9PWIuY2VsbCljPU1hdGgucm91bmQoKGEueCtjKS9mKSpmLWEueDtpZih0aGlzLnJvdW5kZWR8fG51bGwhPWQmJm51bGw9PWQuY2VsbCllPU1hdGgucm91bmQoKGEueStlKS9mKSpmLWEueTtyZXR1cm4gbmV3IG14UG9pbnQoYyxlKX07bXhHdWlkZS5wcm90b3R5cGUuZ2V0R3VpZGVDb2xvcj1mdW5jdGlvbihhLGIpe3JldHVybiBteENvbnN0YW50cy5HVUlERV9DT0xPUn07bXhHdWlkZS5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3RoaXMuc2V0VmlzaWJsZSghMSl9OwpteEd1aWRlLnByb3RvdHlwZS5zZXRWaXNpYmxlPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZ3VpZGVYJiYodGhpcy5ndWlkZVgubm9kZS5zdHlsZS52aXNpYmlsaXR5PWE/InZpc2libGUiOiJoaWRkZW4iKTtudWxsIT10aGlzLmd1aWRlWSYmKHRoaXMuZ3VpZGVZLm5vZGUuc3R5bGUudmlzaWJpbGl0eT1hPyJ2aXNpYmxlIjoiaGlkZGVuIil9O214R3VpZGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmd1aWRlWCYmKHRoaXMuZ3VpZGVYLmRlc3Ryb3koKSx0aGlzLmd1aWRlWD1udWxsKTtudWxsIT10aGlzLmd1aWRlWSYmKHRoaXMuZ3VpZGVZLmRlc3Ryb3koKSx0aGlzLmd1aWRlWT1udWxsKX07ZnVuY3Rpb24gbXhTaGFwZShhKXt0aGlzLnN0ZW5jaWw9YTt0aGlzLmluaXRTdHlsZXMoKX1teFNoYXBlLnByb3RvdHlwZS5kaWFsZWN0PW51bGw7bXhTaGFwZS5wcm90b3R5cGUuc2NhbGU9MTtteFNoYXBlLnByb3RvdHlwZS5hbnRpQWxpYXM9ITA7Cm14U2hhcGUucHJvdG90eXBlLm1pblN2Z1N0cm9rZVdpZHRoPTE7bXhTaGFwZS5wcm90b3R5cGUuYm91bmRzPW51bGw7bXhTaGFwZS5wcm90b3R5cGUucG9pbnRzPW51bGw7bXhTaGFwZS5wcm90b3R5cGUubm9kZT1udWxsO214U2hhcGUucHJvdG90eXBlLnN0YXRlPW51bGw7bXhTaGFwZS5wcm90b3R5cGUuc3R5bGU9bnVsbDtteFNoYXBlLnByb3RvdHlwZS5ib3VuZGluZ0JveD1udWxsO214U2hhcGUucHJvdG90eXBlLnN0ZW5jaWw9bnVsbDtteFNoYXBlLnByb3RvdHlwZS5zdmdTdHJva2VUb2xlcmFuY2U9ODtteFNoYXBlLnByb3RvdHlwZS5wb2ludGVyRXZlbnRzPSEwO214U2hhcGUucHJvdG90eXBlLnN2Z1BvaW50ZXJFdmVudHM9ImFsbCI7bXhTaGFwZS5wcm90b3R5cGUuc2hhcGVQb2ludGVyRXZlbnRzPSExO214U2hhcGUucHJvdG90eXBlLnN0ZW5jaWxQb2ludGVyRXZlbnRzPSExO214U2hhcGUucHJvdG90eXBlLnZtbFNjYWxlPTE7Cm14U2hhcGUucHJvdG90eXBlLm91dGxpbmU9ITE7bXhTaGFwZS5wcm90b3R5cGUudmlzaWJsZT0hMDtteFNoYXBlLnByb3RvdHlwZS51c2VTdmdCb3VuZGluZ0JveD0hMTtteFNoYXBlLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe251bGw9PXRoaXMubm9kZSYmKHRoaXMubm9kZT10aGlzLmNyZWF0ZShhKSxudWxsIT1hJiZhLmFwcGVuZENoaWxkKHRoaXMubm9kZSkpfTtteFNoYXBlLnByb3RvdHlwZS5pbml0U3R5bGVzPWZ1bmN0aW9uKGEpe3RoaXMuc3Ryb2tld2lkdGg9MTt0aGlzLnJvdGF0aW9uPTA7dGhpcy5zdHJva2VPcGFjaXR5PXRoaXMuZmlsbE9wYWNpdHk9dGhpcy5vcGFjaXR5PTEwMDt0aGlzLmZsaXBWPXRoaXMuZmxpcEg9ITF9O214U2hhcGUucHJvdG90eXBlLmlzUGFyc2VWbWw9ZnVuY3Rpb24oKXtyZXR1cm4hMH07bXhTaGFwZS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiExfTsKbXhTaGFwZS5wcm90b3R5cGUuZ2V0U3ZnU2NyZWVuT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE9PW14VXRpbHMubW9kKE1hdGgubWF4KDEsTWF0aC5yb3VuZCgodGhpcy5zdGVuY2lsJiYiaW5oZXJpdCIhPXRoaXMuc3RlbmNpbC5zdHJva2V3aWR0aD9OdW1iZXIodGhpcy5zdGVuY2lsLnN0cm9rZXdpZHRoKTp0aGlzLnN0cm9rZXdpZHRoKSp0aGlzLnNjYWxlKSksMik/LjU6MH07bXhTaGFwZS5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLm93bmVyU1ZHRWxlbWVudD90aGlzLmNyZWF0ZVN2ZyhhKTo4PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fCFteENsaWVudC5JU19WTUx8fHRoaXMuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9WTUwmJnRoaXMuaXNIdG1sQWxsb3dlZCgpP3RoaXMuY3JlYXRlSHRtbChhKTp0aGlzLmNyZWF0ZVZtbChhKX07Cm14U2hhcGUucHJvdG90eXBlLmNyZWF0ZVN2Zz1mdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJnIil9O214U2hhcGUucHJvdG90eXBlLmNyZWF0ZVZtbD1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOmdyb3VwIik7YS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3JldHVybiBhfTtteFNoYXBlLnByb3RvdHlwZS5jcmVhdGVIdG1sPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7YS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3JldHVybiBhfTtteFNoYXBlLnByb3RvdHlwZS5yZWNvbmZpZ3VyZT1mdW5jdGlvbigpe3RoaXMucmVkcmF3KCl9OwpteFNoYXBlLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZUJvdW5kc0Zyb21Qb2ludHMoKTt0aGlzLnZpc2libGUmJnRoaXMuY2hlY2tCb3VuZHMoKT8odGhpcy5ub2RlLnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiLHRoaXMuY2xlYXIoKSwiRElWIiE9dGhpcy5ub2RlLm5vZGVOYW1lfHwhdGhpcy5pc0h0bWxBbGxvd2VkKCkmJm14Q2xpZW50LklTX1ZNTD90aGlzLnJlZHJhd1NoYXBlKCk6dGhpcy5yZWRyYXdIdG1sU2hhcGUoKSx0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KCkpOih0aGlzLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIix0aGlzLmJvdW5kaW5nQm94PW51bGwpfTsKbXhTaGFwZS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLm5vZGUub3duZXJTVkdFbGVtZW50KWZvcig7bnVsbCE9dGhpcy5ub2RlLmxhc3RDaGlsZDspdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpO2Vsc2UgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlOyIrKG51bGwhPXRoaXMuY3Vyc29yPyJjdXJzb3I6Iit0aGlzLmN1cnNvcisiOyI6IiIpLHRoaXMubm9kZS5pbm5lckhUTUw9IiJ9OwpteFNoYXBlLnByb3RvdHlwZS51cGRhdGVCb3VuZHNGcm9tUG9pbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wb2ludHM7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCYmbnVsbCE9YVswXSl7dGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE51bWJlcihhWzBdLngpLE51bWJlcihhWzBdLnkpLDEsMSk7Zm9yKHZhciBiPTE7Yjx0aGlzLnBvaW50cy5sZW5ndGg7YisrKW51bGwhPWFbYl0mJnRoaXMuYm91bmRzLmFkZChuZXcgbXhSZWN0YW5nbGUoTnVtYmVyKGFbYl0ueCksTnVtYmVyKGFbYl0ueSksMSwxKSl9fTsKbXhTaGFwZS5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCksYz1hO2IhPW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCYmYiE9bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIJiZudWxsIT10aGlzLnN0YXRlJiZudWxsIT10aGlzLnN0YXRlLnRleHQmJnRoaXMuc3RhdGUudGV4dC5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSYmKGM9Yy5jbG9uZSgpLGI9Yy53aWR0aCxjLndpZHRoPWMuaGVpZ2h0LGMuaGVpZ2h0PWIpO2M9dGhpcy5nZXRMYWJlbE1hcmdpbnMoYyk7aWYobnVsbCE9Yyl7dmFyIGQ9IjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUEgsITEpLGU9IjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsCiExKTtudWxsIT10aGlzLnN0YXRlJiZudWxsIT10aGlzLnN0YXRlLnRleHQmJnRoaXMuc3RhdGUudGV4dC5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSYmKGI9Yy54LGMueD1jLmhlaWdodCxjLmhlaWdodD1jLndpZHRoLGMud2lkdGg9Yy55LGMueT1iLGI9ZCxkPWUsZT1iKTtyZXR1cm4gbXhVdGlscy5nZXREaXJlY3RlZEJvdW5kcyhhLGMsdGhpcy5zdHlsZSxkLGUpfXJldHVybiBhfTtteFNoYXBlLnByb3RvdHlwZS5nZXRMYWJlbE1hcmdpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9OwpteFNoYXBlLnByb3RvdHlwZS5jaGVja0JvdW5kcz1mdW5jdGlvbigpe3JldHVybiFpc05hTih0aGlzLnNjYWxlKSYmaXNGaW5pdGUodGhpcy5zY2FsZSkmJjA8dGhpcy5zY2FsZSYmbnVsbCE9dGhpcy5ib3VuZHMmJiFpc05hTih0aGlzLmJvdW5kcy54KSYmIWlzTmFOKHRoaXMuYm91bmRzLnkpJiYhaXNOYU4odGhpcy5ib3VuZHMud2lkdGgpJiYhaXNOYU4odGhpcy5ib3VuZHMuaGVpZ2h0KSYmMDx0aGlzLmJvdW5kcy53aWR0aCYmMDx0aGlzLmJvdW5kcy5oZWlnaHR9O214U2hhcGUucHJvdG90eXBlLmNyZWF0ZVZtbEdyb3VwPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChteENsaWVudC5WTUxfUFJFRklYKyI6Z3JvdXAiKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zdHlsZS53aWR0aD10aGlzLm5vZGUuc3R5bGUud2lkdGg7YS5zdHlsZS5oZWlnaHQ9dGhpcy5ub2RlLnN0eWxlLmhlaWdodDtyZXR1cm4gYX07Cm14U2hhcGUucHJvdG90eXBlLnJlZHJhd1NoYXBlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jcmVhdGVDYW52YXMoKTtudWxsIT1hJiYoYS5wb2ludGVyRXZlbnRzPXRoaXMucG9pbnRlckV2ZW50cyx0aGlzLnBhaW50KGEpLHRoaXMubm9kZSE9YS5yb290JiZ0aGlzLm5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKCJiZWZvcmVlbmQiLGEucm9vdC5vdXRlckhUTUwpLCJESVYiPT10aGlzLm5vZGUubm9kZU5hbWUmJjg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmKHRoaXMubm9kZS5zdHlsZS5maWx0ZXI9IiIsbXhVdGlscy5hZGRUcmFuc3BhcmVudEJhY2tncm91bmRGaWx0ZXIodGhpcy5ub2RlKSksdGhpcy5kZXN0cm95Q2FudmFzKGEpKX07Cm14U2hhcGUucHJvdG90eXBlLmNyZWF0ZUNhbnZhcz1mdW5jdGlvbigpe3ZhciBhPW51bGw7bnVsbCE9dGhpcy5ub2RlLm93bmVyU1ZHRWxlbWVudD9hPXRoaXMuY3JlYXRlU3ZnQ2FudmFzKCk6bXhDbGllbnQuSVNfVk1MJiYodGhpcy51cGRhdGVWbWxDb250YWluZXIoKSxhPXRoaXMuY3JlYXRlVm1sQ2FudmFzKCkpO251bGwhPWEmJnRoaXMub3V0bGluZSYmKGEuc2V0U3Ryb2tlV2lkdGgodGhpcy5zdHJva2V3aWR0aCksYS5zZXRTdHJva2VDb2xvcih0aGlzLnN0cm9rZSksbnVsbCE9dGhpcy5pc0Rhc2hlZCYmYS5zZXREYXNoZWQodGhpcy5pc0Rhc2hlZCksYS5zZXRTdHJva2VXaWR0aD1mdW5jdGlvbigpe30sYS5zZXRTdHJva2VDb2xvcj1mdW5jdGlvbigpe30sYS5zZXRGaWxsQ29sb3I9ZnVuY3Rpb24oKXt9LGEuc2V0R3JhZGllbnQ9ZnVuY3Rpb24oKXt9LGEuc2V0RGFzaGVkPWZ1bmN0aW9uKCl7fSxhLnRleHQ9ZnVuY3Rpb24oKXt9KTtyZXR1cm4gYX07Cm14U2hhcGUucHJvdG90eXBlLmNyZWF0ZVN2Z0NhbnZhcz1mdW5jdGlvbigpe3ZhciBhPW5ldyBteFN2Z0NhbnZhczJEKHRoaXMubm9kZSwhMSk7YS5zdHJva2VUb2xlcmFuY2U9dGhpcy5wb2ludGVyRXZlbnRzP3RoaXMuc3ZnU3Ryb2tlVG9sZXJhbmNlOjA7YS5wb2ludGVyRXZlbnRzVmFsdWU9dGhpcy5zdmdQb2ludGVyRXZlbnRzO3ZhciBiPXRoaXMuZ2V0U3ZnU2NyZWVuT2Zmc2V0KCk7MCE9Yj90aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoIitiKyIsIitiKyIpIik6dGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgidHJhbnNmb3JtIik7YS5taW5TdHJva2VXaWR0aD10aGlzLm1pblN2Z1N0cm9rZVdpZHRoO3RoaXMuYW50aUFsaWFzfHwoYS5mb3JtYXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChhKSl9KTtyZXR1cm4gYX07Cm14U2hhcGUucHJvdG90eXBlLmNyZWF0ZVZtbENhbnZhcz1mdW5jdGlvbigpe3ZhciBhPTg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSYmdGhpcy5pc1BhcnNlVm1sKCk/dGhpcy5jcmVhdGVWbWxHcm91cCgpOnRoaXMubm9kZSxiPW5ldyBteFZtbENhbnZhczJEKGEsITEpOyIiIT1hLnRhZ1VybiYmKGEuY29vcmRzaXplPU1hdGgubWF4KDEsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aCkpKnRoaXMudm1sU2NhbGUrIiwiK01hdGgubWF4KDEsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy5oZWlnaHQpKSp0aGlzLnZtbFNjYWxlLGIuc2NhbGUodGhpcy52bWxTY2FsZSksYi52bWxTY2FsZT10aGlzLnZtbFNjYWxlKTthPXRoaXMuc2NhbGU7Yi50cmFuc2xhdGUoLU1hdGgucm91bmQodGhpcy5ib3VuZHMueC9hKSwtTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55L2EpKTtyZXR1cm4gYn07Cm14U2hhcGUucHJvdG90eXBlLnVwZGF0ZVZtbENvbnRhaW5lcj1mdW5jdGlvbigpe3RoaXMubm9kZS5zdHlsZS5sZWZ0PU1hdGgucm91bmQodGhpcy5ib3VuZHMueCkrInB4Ijt0aGlzLm5vZGUuc3R5bGUudG9wPU1hdGgucm91bmQodGhpcy5ib3VuZHMueSkrInB4Ijt2YXIgYT1NYXRoLm1heCgxLE1hdGgucm91bmQodGhpcy5ib3VuZHMuaGVpZ2h0KSk7dGhpcy5ub2RlLnN0eWxlLndpZHRoPU1hdGgubWF4KDEsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aCkpKyJweCI7dGhpcy5ub2RlLnN0eWxlLmhlaWdodD1hKyJweCI7dGhpcy5ub2RlLnN0eWxlLm92ZXJmbG93PSJ2aXNpYmxlIn07bXhTaGFwZS5wcm90b3R5cGUucmVkcmF3SHRtbFNoYXBlPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVIdG1sQm91bmRzKHRoaXMubm9kZSk7dGhpcy51cGRhdGVIdG1sRmlsdGVycyh0aGlzLm5vZGUpO3RoaXMudXBkYXRlSHRtbENvbG9ycyh0aGlzLm5vZGUpfTsKbXhTaGFwZS5wcm90b3R5cGUudXBkYXRlSHRtbEZpbHRlcnM9ZnVuY3Rpb24oYSl7dmFyIGI9IiI7MTAwPnRoaXMub3BhY2l0eSYmKGIrPSJhbHBoYShvcGFjaXR5PSIrdGhpcy5vcGFjaXR5KyIpIik7dGhpcy5pc1NoYWRvdyYmKGIrPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZHJvcFNoYWRvdyAoT2ZmWD0nIitNYXRoLnJvdW5kKG14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWCp0aGlzLnNjYWxlKSsiJywgT2ZmWT0nIitNYXRoLnJvdW5kKG14Q29uc3RhbnRzLlNIQURPV19PRkZTRVRfWSp0aGlzLnNjYWxlKSsiJywgQ29sb3I9JyIrbXhDb25zdGFudHMuVk1MX1NIQURPV0NPTE9SKyInKSIpO2lmKG51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FJiZ0aGlzLmdyYWRpZW50JiZ0aGlzLmdyYWRpZW50IT1teENvbnN0YW50cy5OT05FKXt2YXIgYz10aGlzLmZpbGwsZD10aGlzLmdyYWRpZW50LGU9IjAiLGY9e2Vhc3Q6MCxzb3V0aDoxLAp3ZXN0OjIsbm9ydGg6M30sZz1udWxsIT10aGlzLmRpcmVjdGlvbj9mW3RoaXMuZGlyZWN0aW9uXTowO251bGwhPXRoaXMuZ3JhZGllbnREaXJlY3Rpb24mJihnPW14VXRpbHMubW9kKGcrZlt0aGlzLmdyYWRpZW50RGlyZWN0aW9uXS0xLDQpKTsxPT1nPyhlPSIxIixmPWMsYz1kLGQ9Zik6Mj09Zz8oZj1jLGM9ZCxkPWYpOjM9PWcmJihlPSIxIik7Yis9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yU3RyPSciK2MrIicsIGVuZENvbG9yU3RyPSciK2QrIicsIGdyYWRpZW50VHlwZT0nIitlKyInKSJ9YS5zdHlsZS5maWx0ZXI9Yn07Cm14U2hhcGUucHJvdG90eXBlLnVwZGF0ZUh0bWxDb2xvcnM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zdHJva2U7bnVsbCE9YiYmYiE9bXhDb25zdGFudHMuTk9ORT8oYS5zdHlsZS5ib3JkZXJDb2xvcj1iLHRoaXMuaXNEYXNoZWQ/YS5zdHlsZS5ib3JkZXJTdHlsZT0iZGFzaGVkIjowPHRoaXMuc3Ryb2tld2lkdGgmJihhLnN0eWxlLmJvcmRlclN0eWxlPSJzb2xpZCIpLGEuc3R5bGUuYm9yZGVyV2lkdGg9TWF0aC5tYXgoMSxNYXRoLmNlaWwodGhpcy5zdHJva2V3aWR0aCp0aGlzLnNjYWxlKSkrInB4Iik6YS5zdHlsZS5ib3JkZXJXaWR0aD0iMHB4IjtiPXRoaXMub3V0bGluZT9udWxsOnRoaXMuZmlsbDtudWxsIT1iJiZiIT1teENvbnN0YW50cy5OT05FPyhhLnN0eWxlLmJhY2tncm91bmRDb2xvcj1iLGEuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJub25lIik6dGhpcy5wb2ludGVyRXZlbnRzP2Euc3R5bGUuYmFja2dyb3VuZENvbG9yPSJ0cmFuc3BhcmVudCI6OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPwpteFV0aWxzLmFkZFRyYW5zcGFyZW50QmFja2dyb3VuZEZpbHRlcihhKTp0aGlzLnNldFRyYW5zcGFyZW50QmFja2dyb3VuZEltYWdlKGEpfTsKbXhTaGFwZS5wcm90b3R5cGUudXBkYXRlSHRtbEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj05PD1kb2N1bWVudC5kb2N1bWVudE1vZGU/MDpNYXRoLmNlaWwodGhpcy5zdHJva2V3aWR0aCp0aGlzLnNjYWxlKTthLnN0eWxlLmJvcmRlcldpZHRoPU1hdGgubWF4KDEsYikrInB4IjthLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO2Euc3R5bGUubGVmdD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngtYi8yKSsicHgiO2Euc3R5bGUudG9wPU1hdGgucm91bmQodGhpcy5ib3VuZHMueS1iLzIpKyJweCI7IkNTUzFDb21wYXQiPT1kb2N1bWVudC5jb21wYXRNb2RlJiYoYj0tYik7YS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsdGhpcy5ib3VuZHMud2lkdGgrYikpKyJweCI7YS5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCgwLHRoaXMuYm91bmRzLmhlaWdodCtiKSkrInB4In07Cm14U2hhcGUucHJvdG90eXBlLmRlc3Ryb3lDYW52YXM9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIG14U3ZnQ2FudmFzMkQpe2Zvcih2YXIgYiBpbiBhLmdyYWRpZW50cyl7dmFyIGM9YS5ncmFkaWVudHNbYl07bnVsbCE9YyYmKGMubXhSZWZDb3VudD0oYy5teFJlZkNvdW50fHwwKSsxKX10aGlzLnJlbGVhc2VTdmdHcmFkaWVudHModGhpcy5vbGRHcmFkaWVudHMpO3RoaXMub2xkR3JhZGllbnRzPWEuZ3JhZGllbnRzfX07Cm14U2hhcGUucHJvdG90eXBlLnBhaW50PWZ1bmN0aW9uKGEpe3ZhciBiPSExO2lmKG51bGwhPWEmJnRoaXMub3V0bGluZSl7dmFyIGM9YS5zdHJva2U7YS5zdHJva2U9ZnVuY3Rpb24oKXtiPSEwO2MuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgZD1hLmZpbGxBbmRTdHJva2U7YS5maWxsQW5kU3Ryb2tlPWZ1bmN0aW9uKCl7Yj0hMDtkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIGU9dGhpcy5zY2FsZSxmPXRoaXMuYm91bmRzLngvZSxnPXRoaXMuYm91bmRzLnkvZSxrPXRoaXMuYm91bmRzLndpZHRoL2UsbD10aGlzLmJvdW5kcy5oZWlnaHQvZTtpZih0aGlzLmlzUGFpbnRCb3VuZHNJbnZlcnRlZCgpKXZhciBtPShrLWwpLzIsZj1mK20sZz1nLW0sbT1rLGs9bCxsPW07dGhpcy51cGRhdGVUcmFuc2Zvcm0oYSxmLGcsayxsKTt0aGlzLmNvbmZpZ3VyZUNhbnZhcyhhLGYsZyxrLGwpO209bnVsbDtpZihudWxsPT10aGlzLnN0ZW5jaWwmJm51bGw9PXRoaXMucG9pbnRzJiZ0aGlzLnNoYXBlUG9pbnRlckV2ZW50c3x8Cm51bGwhPXRoaXMuc3RlbmNpbCYmdGhpcy5zdGVuY2lsUG9pbnRlckV2ZW50cyl7dmFyIG49dGhpcy5jcmVhdGVCb3VuZGluZ0JveCgpO3RoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/KG09dGhpcy5jcmVhdGVUcmFuc3BhcmVudFN2Z1JlY3RhbmdsZShuLngsbi55LG4ud2lkdGgsbi5oZWlnaHQpLHRoaXMubm9kZS5hcHBlbmRDaGlsZChtKSk6KG49YS5jcmVhdGVSZWN0KCJyZWN0IixuLngvZSxuLnkvZSxuLndpZHRoL2Usbi5oZWlnaHQvZSksbi5hcHBlbmRDaGlsZChhLmNyZWF0ZVRyYW5zcGFyZW50RmlsbCgpKSxuLnN0cm9rZWQ9ImZhbHNlIixhLnJvb3QuYXBwZW5kQ2hpbGQobikpfWlmKG51bGwhPXRoaXMuc3RlbmNpbCl0aGlzLnN0ZW5jaWwuZHJhd1NoYXBlKGEsdGhpcyxmLGcsayxsKTtlbHNlIGlmKGEuc2V0U3Ryb2tlV2lkdGgodGhpcy5zdHJva2V3aWR0aCksbnVsbCE9dGhpcy5wb2ludHMpe2Zvcih2YXIgbj1bXSxwPTA7cDx0aGlzLnBvaW50cy5sZW5ndGg7cCsrKW51bGwhPQp0aGlzLnBvaW50c1twXSYmbi5wdXNoKG5ldyBteFBvaW50KHRoaXMucG9pbnRzW3BdLngvZSx0aGlzLnBvaW50c1twXS55L2UpKTt0aGlzLnBhaW50RWRnZVNoYXBlKGEsbil9ZWxzZSB0aGlzLnBhaW50VmVydGV4U2hhcGUoYSxmLGcsayxsKTtudWxsIT1tJiZudWxsIT1hLnN0YXRlJiZudWxsIT1hLnN0YXRlLnRyYW5zZm9ybSYmbS5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsYS5zdGF0ZS50cmFuc2Zvcm0pO251bGwhPWEmJnRoaXMub3V0bGluZSYmIWImJihhLnJlY3QoZixnLGssbCksYS5zdHJva2UoKSl9OwpteFNoYXBlLnByb3RvdHlwZS5jb25maWd1cmVDYW52YXM9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1udWxsO251bGwhPXRoaXMuc3R5bGUmJihmPXRoaXMuc3R5bGUuZGFzaFBhdHRlcm4pO2Euc2V0QWxwaGEodGhpcy5vcGFjaXR5LzEwMCk7YS5zZXRGaWxsQWxwaGEodGhpcy5maWxsT3BhY2l0eS8xMDApO2Euc2V0U3Ryb2tlQWxwaGEodGhpcy5zdHJva2VPcGFjaXR5LzEwMCk7bnVsbCE9dGhpcy5pc1NoYWRvdyYmYS5zZXRTaGFkb3codGhpcy5pc1NoYWRvdyk7bnVsbCE9dGhpcy5pc0Rhc2hlZCYmYS5zZXREYXNoZWQodGhpcy5pc0Rhc2hlZCxudWxsIT10aGlzLnN0eWxlPzE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSVhfREFTSCwhMSk6ITEpO251bGwhPWYmJmEuc2V0RGFzaFBhdHRlcm4oZik7bnVsbCE9dGhpcy5maWxsJiZ0aGlzLmZpbGwhPW14Q29uc3RhbnRzLk5PTkUmJnRoaXMuZ3JhZGllbnQmJnRoaXMuZ3JhZGllbnQhPW14Q29uc3RhbnRzLk5PTkU/CihiPXRoaXMuZ2V0R3JhZGllbnRCb3VuZHMoYSxiLGMsZCxlKSxhLnNldEdyYWRpZW50KHRoaXMuZmlsbCx0aGlzLmdyYWRpZW50LGIueCxiLnksYi53aWR0aCxiLmhlaWdodCx0aGlzLmdyYWRpZW50RGlyZWN0aW9uKSk6YS5zZXRGaWxsQ29sb3IodGhpcy5maWxsKTthLnNldFN0cm9rZUNvbG9yKHRoaXMuc3Ryb2tlKX07bXhTaGFwZS5wcm90b3R5cGUuZ2V0R3JhZGllbnRCb3VuZHM9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGIsYyxkLGUpfTtteFNoYXBlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm09ZnVuY3Rpb24oYSxiLGMsZCxlKXthLnNjYWxlKHRoaXMuc2NhbGUpO2Eucm90YXRlKHRoaXMuZ2V0U2hhcGVSb3RhdGlvbigpLHRoaXMuZmxpcEgsdGhpcy5mbGlwVixiK2QvMixjK2UvMil9OwpteFNoYXBlLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5wYWludEJhY2tncm91bmQoYSxiLGMsZCxlKTt0aGlzLm91dGxpbmUmJm51bGwhPXRoaXMuc3R5bGUmJjAhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9CQUNLR1JPVU5EX09VVExJTkUsMCl8fChhLnNldFNoYWRvdyghMSksdGhpcy5wYWludEZvcmVncm91bmQoYSxiLGMsZCxlKSl9O214U2hhcGUucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsYyxkLGUpe307bXhTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixjLGQsZSl7fTtteFNoYXBlLnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZT1mdW5jdGlvbihhLGIpe307Cm14U2hhcGUucHJvdG90eXBlLmdldEFyY1NpemU9ZnVuY3Rpb24oYSxiKXt2YXIgYzsiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BQlNPTFVURV9BUkNTSVpFLDApP2M9TWF0aC5taW4oYS8yLE1hdGgubWluKGIvMixteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzIpKTooYz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwxMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUikvMTAwLGM9TWF0aC5taW4oYSpjLGIqYykpO3JldHVybiBjfTsKbXhTaGFwZS5wcm90b3R5cGUucGFpbnRHbGFzc0VmZmVjdD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9TWF0aC5jZWlsKHRoaXMuc3Ryb2tld2lkdGgvMik7YS5zZXRHcmFkaWVudCgiI2ZmZmZmZiIsIiNmZmZmZmYiLGIsYyxkLC42KmUsInNvdXRoIiwuOSwuMSk7YS5iZWdpbigpO2YrPTIqZzt0aGlzLmlzUm91bmRlZD8oYS5tb3ZlVG8oYi1nK2YsYy1nKSxhLnF1YWRUbyhiLWcsYy1nLGItZyxjLWcrZiksYS5saW5lVG8oYi1nLGMrLjQqZSksYS5xdWFkVG8oYisuNSpkLGMrLjcqZSxiK2QrZyxjKy40KmUpLGEubGluZVRvKGIrZCtnLGMtZytmKSxhLnF1YWRUbyhiK2QrZyxjLWcsYitkK2ctZixjLWcpKTooYS5tb3ZlVG8oYi1nLGMtZyksYS5saW5lVG8oYi1nLGMrLjQqZSksYS5xdWFkVG8oYisuNSpkLGMrLjcqZSxiK2QrZyxjKy40KmUpLGEubGluZVRvKGIrZCtnLGMtZykpO2EuY2xvc2UoKTthLmZpbGwoKX07Cm14U2hhcGUucHJvdG90eXBlLmFkZFBvaW50cz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtpZihudWxsIT1iJiYwPGIubGVuZ3RoKXtnPW51bGwhPWc/ZzohMDt2YXIgaz1iW2IubGVuZ3RoLTFdO2lmKGUmJmMpe2I9Yi5zbGljZSgpO3ZhciBsPWJbMF0sbD1uZXcgbXhQb2ludChrLngrKGwueC1rLngpLzIsay55KyhsLnktay55KS8yKTtiLnNwbGljZSgwLDAsbCl9dmFyIG09YlswXSxsPTE7Zm9yKGc/YS5tb3ZlVG8obS54LG0ueSk6YS5saW5lVG8obS54LG0ueSk7bDwoZT9iLmxlbmd0aDpiLmxlbmd0aC0xKTspe2c9YltteFV0aWxzLm1vZChsLGIubGVuZ3RoKV07dmFyIG49bS54LWcueCxtPW0ueS1nLnk7aWYoYyYmKDAhPW58fDAhPW0pJiYobnVsbD09Znx8MD5teFV0aWxzLmluZGV4T2YoZixsLTEpKSl7dmFyIHA9TWF0aC5zcXJ0KG4qbittKm0pO2EubGluZVRvKGcueCtuKk1hdGgubWluKGQscC8yKS9wLGcueSttKk1hdGgubWluKGQscC8yKS9wKTtmb3IobT1iW214VXRpbHMubW9kKGwrCjEsYi5sZW5ndGgpXTtsPGIubGVuZ3RoLTImJjA9PU1hdGgucm91bmQobS54LWcueCkmJjA9PU1hdGgucm91bmQobS55LWcueSk7KW09YltteFV0aWxzLm1vZChsKzIsYi5sZW5ndGgpXSxsKys7bj1tLngtZy54O209bS55LWcueTtwPU1hdGgubWF4KDEsTWF0aC5zcXJ0KG4qbittKm0pKTtuPWcueCtuKk1hdGgubWluKGQscC8yKS9wO209Zy55K20qTWF0aC5taW4oZCxwLzIpL3A7YS5xdWFkVG8oZy54LGcueSxuLG0pO2c9bmV3IG14UG9pbnQobixtKX1lbHNlIGEubGluZVRvKGcueCxnLnkpO209ZztsKyt9ZT9hLmNsb3NlKCk6YS5saW5lVG8oay54LGsueSl9fTsKbXhTaGFwZS5wcm90b3R5cGUucmVzZXRTdHlsZXM9ZnVuY3Rpb24oKXt0aGlzLmluaXRTdHlsZXMoKTt0aGlzLnNwYWNpbmc9MDtkZWxldGUgdGhpcy5maWxsO2RlbGV0ZSB0aGlzLmdyYWRpZW50O2RlbGV0ZSB0aGlzLmdyYWRpZW50RGlyZWN0aW9uO2RlbGV0ZSB0aGlzLnN0cm9rZTtkZWxldGUgdGhpcy5zdGFydFNpemU7ZGVsZXRlIHRoaXMuZW5kU2l6ZTtkZWxldGUgdGhpcy5zdGFydEFycm93O2RlbGV0ZSB0aGlzLmVuZEFycm93O2RlbGV0ZSB0aGlzLmRpcmVjdGlvbjtkZWxldGUgdGhpcy5pc1NoYWRvdztkZWxldGUgdGhpcy5pc0Rhc2hlZDtkZWxldGUgdGhpcy5pc1JvdW5kZWQ7ZGVsZXRlIHRoaXMuZ2xhc3N9OwpteFNoYXBlLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXt0aGlzLnN0YXRlPWE7dGhpcy5zdHlsZT1hLnN0eWxlO2lmKG51bGwhPXRoaXMuc3R5bGUpe3RoaXMuZmlsbD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLHRoaXMuZmlsbCk7dGhpcy5ncmFkaWVudD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUix0aGlzLmdyYWRpZW50KTt0aGlzLmdyYWRpZW50RGlyZWN0aW9uPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVF9ESVJFQ1RJT04sdGhpcy5ncmFkaWVudERpcmVjdGlvbik7dGhpcy5vcGFjaXR5PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9PUEFDSVRZLHRoaXMub3BhY2l0eSk7dGhpcy5maWxsT3BhY2l0eT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRklMTF9PUEFDSVRZLAp0aGlzLmZpbGxPcGFjaXR5KTt0aGlzLnN0cm9rZU9wYWNpdHk9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRV9PUEFDSVRZLHRoaXMuc3Ryb2tlT3BhY2l0eSk7dGhpcy5zdHJva2U9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SLHRoaXMuc3Ryb2tlKTt0aGlzLnN0cm9rZXdpZHRoPW14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFV0lEVEgsdGhpcy5zdHJva2V3aWR0aCk7dGhpcy5zcGFjaW5nPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HLHRoaXMuc3BhY2luZyk7dGhpcy5zdGFydFNpemU9bXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsdGhpcy5zdGFydFNpemUpO3RoaXMuZW5kU2l6ZT1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFLHRoaXMuZW5kU2l6ZSk7dGhpcy5zdGFydEFycm93PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVEFSUk9XLHRoaXMuc3RhcnRBcnJvdyk7dGhpcy5lbmRBcnJvdz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1csdGhpcy5lbmRBcnJvdyk7dGhpcy5yb3RhdGlvbj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sdGhpcy5yb3RhdGlvbik7dGhpcy5kaXJlY3Rpb249bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTix0aGlzLmRpcmVjdGlvbik7dGhpcy5mbGlwSD0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUEgsMCk7dGhpcy5mbGlwVj0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRkxJUFYsCjApO251bGwhPXRoaXMuc3RlbmNpbCYmKHRoaXMuZmxpcEg9MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzdGVuY2lsRmxpcEgiLDApfHx0aGlzLmZsaXBILHRoaXMuZmxpcFY9MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzdGVuY2lsRmxpcFYiLDApfHx0aGlzLmZsaXBWKTtpZih0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKWE9dGhpcy5mbGlwSCx0aGlzLmZsaXBIPXRoaXMuZmxpcFYsdGhpcy5mbGlwVj1hO3RoaXMuaXNTaGFkb3c9MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NIQURPVyx0aGlzLmlzU2hhZG93KTt0aGlzLmlzRGFzaGVkPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsdGhpcy5pc0Rhc2hlZCk7dGhpcy5pc1JvdW5kZWQ9MT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9ST1VOREVELHRoaXMuaXNSb3VuZGVkKTt0aGlzLmdsYXNzPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9HTEFTUyx0aGlzLmdsYXNzKTt0aGlzLmZpbGw9PW14Q29uc3RhbnRzLk5PTkUmJih0aGlzLmZpbGw9bnVsbCk7dGhpcy5ncmFkaWVudD09bXhDb25zdGFudHMuTk9ORSYmKHRoaXMuZ3JhZGllbnQ9bnVsbCk7dGhpcy5zdHJva2U9PW14Q29uc3RhbnRzLk5PTkUmJih0aGlzLnN0cm9rZT1udWxsKX19O214U2hhcGUucHJvdG90eXBlLnNldEN1cnNvcj1mdW5jdGlvbihhKXtudWxsPT1hJiYoYT0iIik7dGhpcy5jdXJzb3I9YTtudWxsIT10aGlzLm5vZGUmJih0aGlzLm5vZGUuc3R5bGUuY3Vyc29yPWEpfTtteFNoYXBlLnByb3RvdHlwZS5nZXRDdXJzb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJzb3J9O214U2hhcGUucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITF9OwpteFNoYXBlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ0JveD1mdW5jdGlvbigpe2lmKHRoaXMudXNlU3ZnQm91bmRpbmdCb3gmJm51bGwhPXRoaXMubm9kZSYmbnVsbCE9dGhpcy5ub2RlLm93bmVyU1ZHRWxlbWVudCl0cnl7dmFyIGE9dGhpcy5ub2RlLmdldEJCb3goKTtpZigwPGEud2lkdGgmJjA8YS5oZWlnaHQpe3RoaXMuYm91bmRpbmdCb3g9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksYS53aWR0aCxhLmhlaWdodCk7dGhpcy5ib3VuZGluZ0JveC5ncm93KHRoaXMuc3Ryb2tld2lkdGgqdGhpcy5zY2FsZS8yKTtyZXR1cm59fWNhdGNoKGMpe31pZihudWxsIT10aGlzLmJvdW5kcyl7YT10aGlzLmNyZWF0ZUJvdW5kaW5nQm94KCk7aWYobnVsbCE9YSl7dGhpcy5hdWdtZW50Qm91bmRpbmdCb3goYSk7dmFyIGI9dGhpcy5nZXRTaGFwZVJvdGF0aW9uKCk7MCE9YiYmKGE9bXhVdGlscy5nZXRCb3VuZGluZ0JveChhLGIpKX10aGlzLmJvdW5kaW5nQm94PWF9fTsKbXhTaGFwZS5wcm90b3R5cGUuY3JlYXRlQm91bmRpbmdCb3g9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmJvdW5kcy5jbG9uZSgpOyhudWxsIT10aGlzLnN0ZW5jaWwmJih0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKXx8dGhpcy5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSkmJmEucm90YXRlOTAoKTtyZXR1cm4gYX07bXhTaGFwZS5wcm90b3R5cGUuYXVnbWVudEJvdW5kaW5nQm94PWZ1bmN0aW9uKGEpe3RoaXMuaXNTaGFkb3cmJihhLndpZHRoKz1NYXRoLmNlaWwobXhDb25zdGFudHMuU0hBRE9XX09GRlNFVF9YKnRoaXMuc2NhbGUpLGEuaGVpZ2h0Kz1NYXRoLmNlaWwobXhDb25zdGFudHMuU0hBRE9XX09GRlNFVF9ZKnRoaXMuc2NhbGUpKTthLmdyb3codGhpcy5zdHJva2V3aWR0aCp0aGlzLnNjYWxlLzIpfTsKbXhTaGFwZS5wcm90b3R5cGUuaXNQYWludEJvdW5kc0ludmVydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXRoaXMuc3RlbmNpbCYmKHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgpfTtteFNoYXBlLnByb3RvdHlwZS5nZXRSb3RhdGlvbj1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLnJvdGF0aW9uP3RoaXMucm90YXRpb246MH07bXhTaGFwZS5wcm90b3R5cGUuZ2V0VGV4dFJvdGF0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRSb3RhdGlvbigpOzEhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLDEpJiYoYSs9bXhUZXh0LnByb3RvdHlwZS52ZXJ0aWNhbFRleHRSb3RhdGlvbik7cmV0dXJuIGF9OwpteFNoYXBlLnByb3RvdHlwZS5nZXRTaGFwZVJvdGF0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRSb3RhdGlvbigpO251bGwhPXRoaXMuZGlyZWN0aW9uJiYodGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9hKz0yNzA6dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2ErPTE4MDp0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIJiYoYSs9OTApKTtyZXR1cm4gYX07Cm14U2hhcGUucHJvdG90eXBlLmNyZWF0ZVRyYW5zcGFyZW50U3ZnUmVjdGFuZ2xlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsInJlY3QiKTtlLnNldEF0dHJpYnV0ZSgieCIsYSk7ZS5zZXRBdHRyaWJ1dGUoInkiLGIpO2Uuc2V0QXR0cmlidXRlKCJ3aWR0aCIsYyk7ZS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsZCk7ZS5zZXRBdHRyaWJ1dGUoImZpbGwiLCJub25lIik7ZS5zZXRBdHRyaWJ1dGUoInN0cm9rZSIsIm5vbmUiKTtlLnNldEF0dHJpYnV0ZSgicG9pbnRlci1ldmVudHMiLCJhbGwiKTtyZXR1cm4gZX07bXhTaGFwZS5wcm90b3R5cGUuc2V0VHJhbnNwYXJlbnRCYWNrZ3JvdW5kSW1hZ2U9ZnVuY3Rpb24oYSl7YS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgnIitteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvdHJhbnNwYXJlbnQuZ2lmJykifTsKbXhTaGFwZS5wcm90b3R5cGUucmVsZWFzZVN2Z0dyYWRpZW50cz1mdW5jdGlvbihhKXtpZihudWxsIT1hKWZvcih2YXIgYiBpbiBhKXt2YXIgYz1hW2JdO251bGwhPWMmJihjLm14UmVmQ291bnQ9KGMubXhSZWZDb3VudHx8MCktMSwwPT1jLm14UmVmQ291bnQmJm51bGwhPWMucGFyZW50Tm9kZSYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpKX19O214U2hhcGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLm5vZGUmJihteEV2ZW50LnJlbGVhc2UodGhpcy5ub2RlKSxudWxsIT10aGlzLm5vZGUucGFyZW50Tm9kZSYmdGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKSx0aGlzLm5vZGU9bnVsbCk7dGhpcy5yZWxlYXNlU3ZnR3JhZGllbnRzKHRoaXMub2xkR3JhZGllbnRzKTt0aGlzLm9sZEdyYWRpZW50cz1udWxsfTsKZnVuY3Rpb24gbXhTdGVuY2lsKGEpe3RoaXMuZGVzYz1hO3RoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMucGFyc2VDb25zdHJhaW50cygpfW14VXRpbHMuZXh0ZW5kKG14U3RlbmNpbCxteFNoYXBlKTtteFN0ZW5jaWwuZGVmYXVsdExvY2FsaXplZD0hMTtteFN0ZW5jaWwuYWxsb3dFdmFsPSExO214U3RlbmNpbC5wcm90b3R5cGUuZGVzYz1udWxsO214U3RlbmNpbC5wcm90b3R5cGUuY29uc3RyYWludHM9bnVsbDtteFN0ZW5jaWwucHJvdG90eXBlLmFzcGVjdD1udWxsO214U3RlbmNpbC5wcm90b3R5cGUudzA9bnVsbDtteFN0ZW5jaWwucHJvdG90eXBlLmgwPW51bGw7bXhTdGVuY2lsLnByb3RvdHlwZS5iZ05vZGU9bnVsbDtteFN0ZW5jaWwucHJvdG90eXBlLmZnTm9kZT1udWxsO214U3RlbmNpbC5wcm90b3R5cGUuc3Ryb2tld2lkdGg9bnVsbDsKbXhTdGVuY2lsLnByb3RvdHlwZS5wYXJzZURlc2NyaXB0aW9uPWZ1bmN0aW9uKCl7dGhpcy5mZ05vZGU9dGhpcy5kZXNjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJmb3JlZ3JvdW5kIilbMF07dGhpcy5iZ05vZGU9dGhpcy5kZXNjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJiYWNrZ3JvdW5kIilbMF07dGhpcy53MD1OdW1iZXIodGhpcy5kZXNjLmdldEF0dHJpYnV0ZSgidyIpfHwxMDApO3RoaXMuaDA9TnVtYmVyKHRoaXMuZGVzYy5nZXRBdHRyaWJ1dGUoImgiKXx8MTAwKTt2YXIgYT10aGlzLmRlc2MuZ2V0QXR0cmlidXRlKCJhc3BlY3QiKTt0aGlzLmFzcGVjdD1udWxsIT1hP2E6InZhcmlhYmxlIjthPXRoaXMuZGVzYy5nZXRBdHRyaWJ1dGUoInN0cm9rZXdpZHRoIik7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1hP2E6IjEifTsKbXhTdGVuY2lsLnByb3RvdHlwZS5wYXJzZUNvbnN0cmFpbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kZXNjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJjb25uZWN0aW9ucyIpWzBdO2lmKG51bGwhPWEmJihhPW14VXRpbHMuZ2V0Q2hpbGROb2RlcyhhKSxudWxsIT1hJiYwPGEubGVuZ3RoKSl7dGhpcy5jb25zdHJhaW50cz1bXTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLmNvbnN0cmFpbnRzLnB1c2godGhpcy5wYXJzZUNvbnN0cmFpbnQoYVtiXSkpfX07bXhTdGVuY2lsLnByb3RvdHlwZS5wYXJzZUNvbnN0cmFpbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9TnVtYmVyKGEuZ2V0QXR0cmlidXRlKCJ4IikpLGM9TnVtYmVyKGEuZ2V0QXR0cmlidXRlKCJ5IikpLGQ9IjEiPT1hLmdldEF0dHJpYnV0ZSgicGVyaW1ldGVyIik7YT1hLmdldEF0dHJpYnV0ZSgibmFtZSIpO3JldHVybiBuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludChiLGMpLGQsYSl9OwpteFN0ZW5jaWwucHJvdG90eXBlLmV2YWx1YXRlVGV4dEF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyl7Yj10aGlzLmV2YWx1YXRlQXR0cmlidXRlKGEsYixjKTthPWEuZ2V0QXR0cmlidXRlKCJsb2NhbGl6ZWQiKTtpZihteFN0ZW5jaWwuZGVmYXVsdExvY2FsaXplZCYmbnVsbD09YXx8IjEiPT1hKWI9bXhSZXNvdXJjZXMuZ2V0KGIpO3JldHVybiBifTtteFN0ZW5jaWwucHJvdG90eXBlLmV2YWx1YXRlQXR0cmlidXRlPWZ1bmN0aW9uKGEsYixjKXtiPWEuZ2V0QXR0cmlidXRlKGIpO251bGw9PWImJihhPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYSksbnVsbCE9YSYmbXhTdGVuY2lsLmFsbG93RXZhbCYmKGE9bXhVdGlscy5ldmFsKGEpLCJmdW5jdGlvbiI9PXR5cGVvZiBhJiYoYj1hKGMpKSkpO3JldHVybiBifTsKbXhTdGVuY2lsLnByb3RvdHlwZS5kcmF3U2hhcGU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPWEuc3RhdGVzLnNsaWNlKCksaz1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRElSRUNUSU9OLG51bGwpLGs9dGhpcy5jb21wdXRlQXNwZWN0KGIuc3R5bGUsYyxkLGUsZixrKSxsPU1hdGgubWluKGsud2lkdGgsay5oZWlnaHQpLGw9ImluaGVyaXQiPT10aGlzLnN0cm9rZXdpZHRoP051bWJlcihteFV0aWxzLmdldE51bWJlcihiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUUk9LRVdJRFRILDEpKTpOdW1iZXIodGhpcy5zdHJva2V3aWR0aCkqbDthLnNldFN0cm9rZVdpZHRoKGwpO251bGwhPWIuc3R5bGUmJiIxIj09bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPSU5URVJfRVZFTlRTLCIwIikmJihhLnNldFN0cm9rZUNvbG9yKG14Q29uc3RhbnRzLk5PTkUpLGEucmVjdChjLGQsZSxmKSxhLnN0cm9rZSgpLGEuc2V0U3Ryb2tlQ29sb3IoYi5zdHJva2UpKTsKdGhpcy5kcmF3Q2hpbGRyZW4oYSxiLGMsZCxlLGYsdGhpcy5iZ05vZGUsaywhMSwhMCk7dGhpcy5kcmF3Q2hpbGRyZW4oYSxiLGMsZCxlLGYsdGhpcy5mZ05vZGUsaywhMCwhYi5vdXRsaW5lfHxudWxsPT1iLnN0eWxlfHwwPT1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQkFDS0dST1VORF9PVVRMSU5FLDApKTthLnN0YXRlcy5sZW5ndGghPWcubGVuZ3RoJiYoYS5zdGF0ZXM9Zyl9O214U3RlbmNpbC5wcm90b3R5cGUuZHJhd0NoaWxkcmVuPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0pe2lmKG51bGwhPWcmJjA8ZSYmMDxmKWZvcihjPWcuZmlyc3RDaGlsZDtudWxsIT1jOyljLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UJiZ0aGlzLmRyYXdOb2RlKGEsYixjLGssbCxtKSxjPWMubmV4dFNpYmxpbmd9OwpteFN0ZW5jaWwucHJvdG90eXBlLmNvbXB1dGVBc3BlY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2E9YjtiPWQvdGhpcy53MDt2YXIgZz1lL3RoaXMuaDA7aWYoZj1mPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCl7Zz1kL3RoaXMuaDA7Yj1lL3RoaXMudzA7dmFyIGs9KGQtZSkvMjthKz1rO2MtPWt9ImZpeGVkIj09dGhpcy5hc3BlY3QmJihiPWc9TWF0aC5taW4oYixnKSxmPyhhKz0oZS10aGlzLncwKmIpLzIsYys9KGQtdGhpcy5oMCpnKS8yKTooYSs9KGQtdGhpcy53MCpiKS8yLGMrPShlLXRoaXMuaDAqZykvMikpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYSxjLGIsZyl9OwpteFN0ZW5jaWwucHJvdG90eXBlLmRyYXdOb2RlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1jLm5vZGVOYW1lLGs9ZC54LGw9ZC55LG09ZC53aWR0aCxuPWQuaGVpZ2h0LHA9TWF0aC5taW4obSxuKTtpZigic2F2ZSI9PWcpYS5zYXZlKCk7ZWxzZSBpZigicmVzdG9yZSI9PWcpYS5yZXN0b3JlKCk7ZWxzZSBpZihmKXtpZigicGF0aCI9PWcpe2EuYmVnaW4oKTtwPSEwO2lmKCIxIj09Yy5nZXRBdHRyaWJ1dGUoInJvdW5kZWQiKSl7Zm9yKHZhciBwPSExLHE9TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJhcmNTaXplIikpLHI9MCx0PVtdLHU9Yy5maXJzdENoaWxkO251bGwhPXU7KXtpZih1Lm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXt2YXIgeD11Lm5vZGVOYW1lO2lmKCJtb3ZlIj09eHx8ImxpbmUiPT14KSJtb3ZlIiE9eCYmMCE9dC5sZW5ndGh8fHQucHVzaChbXSksdFt0Lmxlbmd0aC0xXS5wdXNoKG5ldyBteFBvaW50KGsrTnVtYmVyKHUuZ2V0QXR0cmlidXRlKCJ4IikpKgptLGwrTnVtYmVyKHUuZ2V0QXR0cmlidXRlKCJ5IikpKm4pKSxyKys7ZWxzZXtwPSEwO2JyZWFrfX11PXUubmV4dFNpYmxpbmd9aWYoIXAmJjA8cilmb3IobT0wO208dC5sZW5ndGg7bSsrKW49ITEsbD10W21dWzBdLGs9dFttXVt0W21dLmxlbmd0aC0xXSxsLng9PWsueCYmbC55PT1rLnkmJih0W21dLnBvcCgpLG49ITApLHRoaXMuYWRkUG9pbnRzKGEsdFttXSwhMCxxLG4pO2Vsc2UgcD0hMH1pZihwKWZvcih1PWMuZmlyc3RDaGlsZDtudWxsIT11Oyl1Lm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UJiZ0aGlzLmRyYXdOb2RlKGEsYix1LGQsZSxmKSx1PXUubmV4dFNpYmxpbmd9ZWxzZSBpZigiY2xvc2UiPT1nKWEuY2xvc2UoKTtlbHNlIGlmKCJtb3ZlIj09ZylhLm1vdmVUbyhrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieCIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5IikpKm4pO2Vsc2UgaWYoImxpbmUiPT1nKWEubGluZVRvKGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKgptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5IikpKm4pO2Vsc2UgaWYoInF1YWQiPT1nKWEucXVhZFRvKGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4MSIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5MSIpKSpuLGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4MiIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5MiIpKSpuKTtlbHNlIGlmKCJjdXJ2ZSI9PWcpYS5jdXJ2ZVRvKGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4MSIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5MSIpKSpuLGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4MiIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5MiIpKSpuLGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4MyIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5MyIpKSpuKTtlbHNlIGlmKCJhcmMiPT1nKWEuYXJjVG8oTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJyeCIpKSptLE51bWJlcihjLmdldEF0dHJpYnV0ZSgicnkiKSkqCm4sTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4LWF4aXMtcm90YXRpb24iKSksTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJsYXJnZS1hcmMtZmxhZyIpKSxOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInN3ZWVwLWZsYWciKSksaytOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuKTtlbHNlIGlmKCJyZWN0Ij09ZylhLnJlY3QoaytOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuLE51bWJlcihjLmdldEF0dHJpYnV0ZSgidyIpKSptLE51bWJlcihjLmdldEF0dHJpYnV0ZSgiaCIpKSpuKTtlbHNlIGlmKCJyb3VuZHJlY3QiPT1nKWI9TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJhcmNzaXplIikpLDA9PWImJihiPTEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKSxkPU51bWJlcihjLmdldEF0dHJpYnV0ZSgidyIpKSptLGY9TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJoIikpKgpuLGI9TnVtYmVyKGIpLzEwMCxiPU1hdGgubWluKGQqYixmKmIpLGEucm91bmRyZWN0KGsrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ4IikpKm0sbCtOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInkiKSkqbixkLGYsYixiKTtlbHNlIGlmKCJlbGxpcHNlIj09ZylhLmVsbGlwc2UoaytOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuLE51bWJlcihjLmdldEF0dHJpYnV0ZSgidyIpKSptLE51bWJlcihjLmdldEF0dHJpYnV0ZSgiaCIpKSpuKTtlbHNlIGlmKCJpbWFnZSI9PWcpYi5vdXRsaW5lfHwoYj10aGlzLmV2YWx1YXRlQXR0cmlidXRlKGMsInNyYyIsYiksYS5pbWFnZShrK051bWJlcihjLmdldEF0dHJpYnV0ZSgieCIpKSptLGwrTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ5IikpKm4sTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJ3IikpKm0sTnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJoIikpKm4sYiwhMSwiMSI9PWMuZ2V0QXR0cmlidXRlKCJmbGlwSCIpLAoiMSI9PWMuZ2V0QXR0cmlidXRlKCJmbGlwViIpKSk7ZWxzZSBpZigidGV4dCI9PWcpYi5vdXRsaW5lfHwoZD10aGlzLmV2YWx1YXRlVGV4dEF0dHJpYnV0ZShjLCJzdHIiLGIpLGY9IjEiPT1jLmdldEF0dHJpYnV0ZSgidmVydGljYWwiKT8tOTA6MCwiMCI9PWMuZ2V0QXR0cmlidXRlKCJhbGlnbi1zaGFwZSIpJiYocD1iLnJvdGF0aW9uLHE9MT09bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILDApLGI9MT09bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLDApLGY9cSYmYj9mLXA6cXx8Yj9mK3A6Zi1wKSxmLT1jLmdldEF0dHJpYnV0ZSgicm90YXRpb24iKSxhLnRleHQoaytOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsK051bWJlcihjLmdldEF0dHJpYnV0ZSgieSIpKSpuLDAsMCxkLGMuZ2V0QXR0cmlidXRlKCJhbGlnbiIpfHwibGVmdCIsYy5nZXRBdHRyaWJ1dGUoInZhbGlnbiIpfHwidG9wIiwKITEsIiIsbnVsbCwhMSxmKSk7ZWxzZSBpZigiaW5jbHVkZS1zaGFwZSI9PWcpcD1teFN0ZW5jaWxSZWdpc3RyeS5nZXRTdGVuY2lsKGMuZ2V0QXR0cmlidXRlKCJuYW1lIikpLG51bGwhPXAmJihrKz1OdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIngiKSkqbSxsKz1OdW1iZXIoYy5nZXRBdHRyaWJ1dGUoInkiKSkqbixkPU51bWJlcihjLmdldEF0dHJpYnV0ZSgidyIpKSptLGY9TnVtYmVyKGMuZ2V0QXR0cmlidXRlKCJoIikpKm4scC5kcmF3U2hhcGUoYSxiLGssbCxkLGYpKTtlbHNlIGlmKCJmaWxsc3Ryb2tlIj09ZylhLmZpbGxBbmRTdHJva2UoKTtlbHNlIGlmKCJmaWxsIj09ZylhLmZpbGwoKTtlbHNlIGlmKCJzdHJva2UiPT1nKWEuc3Ryb2tlKCk7ZWxzZSBpZigic3Ryb2tld2lkdGgiPT1nKW09IjEiPT1jLmdldEF0dHJpYnV0ZSgiZml4ZWQiKT8xOnAsYS5zZXRTdHJva2VXaWR0aChOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoIndpZHRoIikpKm0pO2Vsc2UgaWYoImRhc2hlZCI9PWcpYS5zZXREYXNoZWQoIjEiPT0KYy5nZXRBdHRyaWJ1dGUoImRhc2hlZCIpKTtlbHNlIGlmKCJkYXNocGF0dGVybiI9PWcpe2lmKGM9Yy5nZXRBdHRyaWJ1dGUoInBhdHRlcm4iKSxudWxsIT1jKXtjPWMuc3BsaXQoIiAiKTtuPVtdO2ZvcihtPTA7bTxjLmxlbmd0aDttKyspMDxjW21dLmxlbmd0aCYmbi5wdXNoKE51bWJlcihjW21dKSpwKTtjPW4uam9pbigiICIpO2Euc2V0RGFzaFBhdHRlcm4oYyl9fWVsc2Uic3Ryb2tlY29sb3IiPT1nP2Euc2V0U3Ryb2tlQ29sb3IoYy5nZXRBdHRyaWJ1dGUoImNvbG9yIikpOiJsaW5lY2FwIj09Zz9hLnNldExpbmVDYXAoYy5nZXRBdHRyaWJ1dGUoImNhcCIpKToibGluZWpvaW4iPT1nP2Euc2V0TGluZUpvaW4oYy5nZXRBdHRyaWJ1dGUoImpvaW4iKSk6Im1pdGVybGltaXQiPT1nP2Euc2V0TWl0ZXJMaW1pdChOdW1iZXIoYy5nZXRBdHRyaWJ1dGUoImxpbWl0IikpKToiZmlsbGNvbG9yIj09Zz9hLnNldEZpbGxDb2xvcihjLmdldEF0dHJpYnV0ZSgiY29sb3IiKSk6ImFscGhhIj09Cmc/YS5zZXRBbHBoYShjLmdldEF0dHJpYnV0ZSgiYWxwaGEiKSk6ImZpbGxhbHBoYSI9PWc/YS5zZXRBbHBoYShjLmdldEF0dHJpYnV0ZSgiYWxwaGEiKSk6InN0cm9rZWFscGhhIj09Zz9hLnNldEFscGhhKGMuZ2V0QXR0cmlidXRlKCJhbHBoYSIpKToiZm9udGNvbG9yIj09Zz9hLnNldEZvbnRDb2xvcihjLmdldEF0dHJpYnV0ZSgiY29sb3IiKSk6ImZvbnRzdHlsZSI9PWc/YS5zZXRGb250U3R5bGUoYy5nZXRBdHRyaWJ1dGUoInN0eWxlIikpOiJmb250ZmFtaWx5Ij09Zz9hLnNldEZvbnRGYW1pbHkoYy5nZXRBdHRyaWJ1dGUoImZhbWlseSIpKToiZm9udHNpemUiPT1nJiZhLnNldEZvbnRTaXplKE51bWJlcihjLmdldEF0dHJpYnV0ZSgic2l6ZSIpKSpwKTshZXx8ImZpbGxzdHJva2UiIT1nJiYiZmlsbCIhPWcmJiJzdHJva2UiIT1nfHxhLnNldFNoYWRvdyghMSl9fTsKdmFyIG14U3RlbmNpbFJlZ2lzdHJ5PXtzdGVuY2lsczp7fSxhZGRTdGVuY2lsOmZ1bmN0aW9uKGEsYil7bXhTdGVuY2lsUmVnaXN0cnkuc3RlbmNpbHNbYV09Yn0sZ2V0U3RlbmNpbDpmdW5jdGlvbihhKXtyZXR1cm4gbXhTdGVuY2lsUmVnaXN0cnkuc3RlbmNpbHNbYV19fSxteE1hcmtlcj17bWFya2VyczpbXSxhZGRNYXJrZXI6ZnVuY3Rpb24oYSxiKXtteE1hcmtlci5tYXJrZXJzW2FdPWJ9LGNyZWF0ZU1hcmtlcjpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtKXt2YXIgbj1teE1hcmtlci5tYXJrZXJzW2NdO3JldHVybiBudWxsIT1uP24oYSxiLGMsZCxlLGYsZyxrLGwsbSk6bnVsbH19OwooZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2E9bnVsbCE9YT9hOjI7cmV0dXJuIGZ1bmN0aW9uKGIsYyxkLGssbCxtLG4scCxxLHIpe2M9bCpxKjEuMTE4O3A9bSpxKjEuMTE4O2wqPW4rcTttKj1uK3E7dmFyIGU9ay5jbG9uZSgpO2UueC09YztlLnktPXA7bj1kIT1teENvbnN0YW50cy5BUlJPV19DTEFTU0lDJiZkIT1teENvbnN0YW50cy5BUlJPV19DTEFTU0lDX1RISU4/MTouNzU7ay54Kz0tbCpuLWM7ay55Kz0tbSpuLXA7cmV0dXJuIGZ1bmN0aW9uKCl7Yi5iZWdpbigpO2IubW92ZVRvKGUueCxlLnkpO2IubGluZVRvKGUueC1sLW0vYSxlLnktbStsL2EpO2QhPW14Q29uc3RhbnRzLkFSUk9XX0NMQVNTSUMmJmQhPW14Q29uc3RhbnRzLkFSUk9XX0NMQVNTSUNfVEhJTnx8Yi5saW5lVG8oZS54LTMqbC80LGUueS0zKm0vNCk7Yi5saW5lVG8oZS54K20vYS1sLGUueS1tLWwvYSk7Yi5jbG9zZSgpO3I/Yi5maWxsQW5kU3Ryb2tlKCk6Yi5zdHJva2UoKX19fWZ1bmN0aW9uIGIoYSl7YT0KbnVsbCE9YT9hOjI7cmV0dXJuIGZ1bmN0aW9uKGIsYyxkLGssbCxtLG4scCxxLHIpe2M9bCpxKjEuMTE4O2Q9bSpxKjEuMTE4O2wqPW4rcTttKj1uK3E7dmFyIGU9ay5jbG9uZSgpO2UueC09YztlLnktPWQ7ay54Kz0yKi1jO2sueSs9MiotZDtyZXR1cm4gZnVuY3Rpb24oKXtiLmJlZ2luKCk7Yi5tb3ZlVG8oZS54LWwtbS9hLGUueS1tK2wvYSk7Yi5saW5lVG8oZS54LGUueSk7Yi5saW5lVG8oZS54K20vYS1sLGUueS1tLWwvYSk7Yi5zdHJva2UoKX19fWZ1bmN0aW9uIGMoYSxiLGMsZyxrLGwsbSxuLHAscSl7bj1jPT1teENvbnN0YW50cy5BUlJPV19ESUFNT05EPy43MDcxOi45ODYyO2I9aypwKm47bio9bCpwO2sqPW0rcDtsKj1tK3A7dmFyIGQ9Zy5jbG9uZSgpO2QueC09YjtkLnktPW47Zy54Kz0tay1iO2cueSs9LWwtbjt2YXIgZT1jPT1teENvbnN0YW50cy5BUlJPV19ESUFNT05EPzI6My40O3JldHVybiBmdW5jdGlvbigpe2EuYmVnaW4oKTthLm1vdmVUbyhkLngsZC55KTthLmxpbmVUbyhkLngtCmsvMi1sL2UsZC55K2svZS1sLzIpO2EubGluZVRvKGQueC1rLGQueS1sKTthLmxpbmVUbyhkLngtay8yK2wvZSxkLnktbC8yLWsvZSk7YS5jbG9zZSgpO3E/YS5maWxsQW5kU3Ryb2tlKCk6YS5zdHJva2UoKX19bXhNYXJrZXIuYWRkTWFya2VyKCJjbGFzc2ljIixhKDIpKTtteE1hcmtlci5hZGRNYXJrZXIoImNsYXNzaWNUaGluIixhKDMpKTtteE1hcmtlci5hZGRNYXJrZXIoImJsb2NrIixhKDIpKTtteE1hcmtlci5hZGRNYXJrZXIoImJsb2NrVGhpbiIsYSgzKSk7bXhNYXJrZXIuYWRkTWFya2VyKCJvcGVuIixiKDIpKTtteE1hcmtlci5hZGRNYXJrZXIoIm9wZW5UaGluIixiKDMpKTtteE1hcmtlci5hZGRNYXJrZXIoIm92YWwiLGZ1bmN0aW9uKGEsYixjLGcsayxsLG0sbixwLHEpe3ZhciBkPW0vMixlPWcuY2xvbmUoKTtnLngtPWsqZDtnLnktPWwqZDtyZXR1cm4gZnVuY3Rpb24oKXthLmVsbGlwc2UoZS54LWQsZS55LWQsbSxtKTtxP2EuZmlsbEFuZFN0cm9rZSgpOmEuc3Ryb2tlKCl9fSk7Cm14TWFya2VyLmFkZE1hcmtlcigiZGlhbW9uZCIsYyk7bXhNYXJrZXIuYWRkTWFya2VyKCJkaWFtb25kVGhpbiIsYyl9KSgpO2Z1bmN0aW9uIG14QWN0b3IoYSxiLGMsZCl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxfW14VXRpbHMuZXh0ZW5kKG14QWN0b3IsbXhTaGFwZSk7bXhBY3Rvci5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsYyxkLGUpe2EudHJhbnNsYXRlKGIsYyk7YS5iZWdpbigpO3RoaXMucmVkcmF3UGF0aChhLGIsYyxkLGUpO2EuZmlsbEFuZFN0cm9rZSgpfTsKbXhBY3Rvci5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsYyxkLGUpe2I9ZC8zO2EubW92ZVRvKDAsZSk7YS5jdXJ2ZVRvKDAsMyplLzUsMCwyKmUvNSxkLzIsMiplLzUpO2EuY3VydmVUbyhkLzItYiwyKmUvNSxkLzItYiwwLGQvMiwwKTthLmN1cnZlVG8oZC8yK2IsMCxkLzIrYiwyKmUvNSxkLzIsMiplLzUpO2EuY3VydmVUbyhkLDIqZS81LGQsMyplLzUsZCxlKTthLmNsb3NlKCl9O2Z1bmN0aW9uIG14Q2xvdWQoYSxiLGMsZCl7bXhBY3Rvci5jYWxsKHRoaXMpO3RoaXMuYm91bmRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxfW14VXRpbHMuZXh0ZW5kKG14Q2xvdWQsbXhBY3Rvcik7Cm14Q2xvdWQucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGMsZCxlKXthLm1vdmVUbyguMjUqZCwuMjUqZSk7YS5jdXJ2ZVRvKC4wNSpkLC4yNSplLDAsLjUqZSwuMTYqZCwuNTUqZSk7YS5jdXJ2ZVRvKDAsLjY2KmUsLjE4KmQsLjkqZSwuMzEqZCwuOCplKTthLmN1cnZlVG8oLjQqZCxlLC43KmQsZSwuOCpkLC44KmUpO2EuY3VydmVUbyhkLC44KmUsZCwuNiplLC44NzUqZCwuNSplKTthLmN1cnZlVG8oZCwuMyplLC44KmQsLjEqZSwuNjI1KmQsLjIqZSk7YS5jdXJ2ZVRvKC41KmQsLjA1KmUsLjMqZCwuMDUqZSwuMjUqZCwuMjUqZSk7YS5jbG9zZSgpfTtmdW5jdGlvbiBteFJlY3RhbmdsZVNoYXBlKGEsYixjLGQpe214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLmJvdW5kcz1hO3RoaXMuZmlsbD1iO3RoaXMuc3Ryb2tlPWM7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1kP2Q6MX1teFV0aWxzLmV4dGVuZChteFJlY3RhbmdsZVNoYXBlLG14U2hhcGUpOwpteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7dmFyIGE9ITA7bnVsbCE9dGhpcy5zdHlsZSYmKGE9IjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUE9JTlRFUl9FVkVOVFMsIjEiKSk7cmV0dXJuIXRoaXMuaXNSb3VuZGVkJiYhdGhpcy5nbGFzcyYmMD09dGhpcy5yb3RhdGlvbiYmKGF8fG51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FKX07Cm14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPSEwO251bGwhPXRoaXMuc3R5bGUmJihmPSIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPSU5URVJfRVZFTlRTLCIxIikpO2lmKGZ8fG51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FfHxudWxsIT10aGlzLnN0cm9rZSYmdGhpcy5zdHJva2UhPW14Q29uc3RhbnRzLk5PTkUpZnx8bnVsbCE9dGhpcy5maWxsJiZ0aGlzLmZpbGwhPW14Q29uc3RhbnRzLk5PTkV8fChhLnBvaW50ZXJFdmVudHM9ITEpLHRoaXMuaXNSb3VuZGVkPygiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BQlNPTFVURV9BUkNTSVpFLDApP2Y9TWF0aC5taW4oZC8yLE1hdGgubWluKGUvMixteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwKbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yKSk6KGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsMTAwKm14Q29uc3RhbnRzLlJFQ1RBTkdMRV9ST1VORElOR19GQUNUT1IpLzEwMCxmPU1hdGgubWluKGQqZixlKmYpKSxhLnJvdW5kcmVjdChiLGMsZCxlLGYsZikpOmEucmVjdChiLGMsZCxlKSxhLmZpbGxBbmRTdHJva2UoKX07bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4hMH07bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy5nbGFzcyYmIXRoaXMub3V0bGluZSYmbnVsbCE9dGhpcy5maWxsJiZ0aGlzLmZpbGwhPW14Q29uc3RhbnRzLk5PTkUmJnRoaXMucGFpbnRHbGFzc0VmZmVjdChhLGIsYyxkLGUsdGhpcy5nZXRBcmNTaXplKGQrdGhpcy5zdHJva2V3aWR0aCxlK3RoaXMuc3Ryb2tld2lkdGgpKX07CmZ1bmN0aW9uIG14RWxsaXBzZShhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjF9bXhVdGlscy5leHRlbmQobXhFbGxpcHNlLG14U2hhcGUpO214RWxsaXBzZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsYyxkLGUpe2EuZWxsaXBzZShiLGMsZCxlKTthLmZpbGxBbmRTdHJva2UoKX07ZnVuY3Rpb24gbXhEb3VibGVFbGxpcHNlKGEsYixjLGQpe214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLmJvdW5kcz1hO3RoaXMuZmlsbD1iO3RoaXMuc3Ryb2tlPWM7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1kP2Q6MX1teFV0aWxzLmV4dGVuZChteERvdWJsZUVsbGlwc2UsbXhTaGFwZSk7bXhEb3VibGVFbGxpcHNlLnByb3RvdHlwZS52bWxTY2FsZT0xMDsKbXhEb3VibGVFbGxpcHNlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXthLmVsbGlwc2UoYixjLGQsZSk7YS5maWxsQW5kU3Ryb2tlKCl9O214RG91YmxlRWxsaXBzZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoIXRoaXMub3V0bGluZSl7dmFyIGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX01BUkdJTixNYXRoLm1pbigzK3RoaXMuc3Ryb2tld2lkdGgsTWF0aC5taW4oZC81LGUvNSkpKTtkLT0yKmY7ZS09MipmOzA8ZCYmMDxlJiZhLmVsbGlwc2UoYitmLGMrZixkLGUpO2Euc3Ryb2tlKCl9fTsKbXhEb3VibGVFbGxpcHNlLnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOLE1hdGgubWluKDMrdGhpcy5zdHJva2V3aWR0aCxNYXRoLm1pbihhLndpZHRoLzUvdGhpcy5zY2FsZSxhLmhlaWdodC81L3RoaXMuc2NhbGUpKSkqdGhpcy5zY2FsZTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGEueCtiLGEueStiLGEud2lkdGgtMipiLGEuaGVpZ2h0LTIqYil9O2Z1bmN0aW9uIG14UmhvbWJ1cyhhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjF9bXhVdGlscy5leHRlbmQobXhSaG9tYnVzLG14U2hhcGUpO214UmhvbWJ1cy5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Cm14UmhvbWJ1cy5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWQvMixnPWUvMixrPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjthLmJlZ2luKCk7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoYitmLGMpLG5ldyBteFBvaW50KGIrZCxjK2cpLG5ldyBteFBvaW50KGIrZixjK2UpLG5ldyBteFBvaW50KGIsYytnKV0sdGhpcy5pc1JvdW5kZWQsaywhMCk7YS5maWxsQW5kU3Ryb2tlKCl9O2Z1bmN0aW9uIG14UG9seWxpbmUoYSxiLGMpe214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLnBvaW50cz1hO3RoaXMuc3Ryb2tlPWI7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1jP2M6MX1teFV0aWxzLmV4dGVuZChteFBvbHlsaW5lLG14U2hhcGUpO214UG9seWxpbmUucHJvdG90eXBlLmdldFJvdGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIDB9OwpteFBvbHlsaW5lLnByb3RvdHlwZS5nZXRTaGFwZVJvdGF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIDB9O214UG9seWxpbmUucHJvdG90eXBlLmlzUGFpbnRCb3VuZHNJbnZlcnRlZD1mdW5jdGlvbigpe3JldHVybiExfTtteFBvbHlsaW5lLnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEucG9pbnRlckV2ZW50c1ZhbHVlO2EucG9pbnRlckV2ZW50c1ZhbHVlPSJzdHJva2UiO251bGw9PXRoaXMuc3R5bGV8fDEhPXRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXT90aGlzLnBhaW50TGluZShhLGIsdGhpcy5pc1JvdW5kZWQpOnRoaXMucGFpbnRDdXJ2ZWRMaW5lKGEsYik7YS5wb2ludGVyRXZlbnRzVmFsdWU9Y307Cm14UG9seWxpbmUucHJvdG90eXBlLnBhaW50TGluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO2EuYmVnaW4oKTt0aGlzLmFkZFBvaW50cyhhLGIsYyxkLCExKTthLnN0cm9rZSgpfTtteFBvbHlsaW5lLnByb3RvdHlwZS5wYWludEN1cnZlZExpbmU9ZnVuY3Rpb24oYSxiKXthLmJlZ2luKCk7dmFyIGM9YlswXSxkPWIubGVuZ3RoO2EubW92ZVRvKGMueCxjLnkpO2ZvcihjPTE7YzxkLTI7YysrKXt2YXIgZT1iW2NdLGY9YltjKzFdO2EucXVhZFRvKGUueCxlLnksKGUueCtmLngpLzIsKGUueStmLnkpLzIpfWU9YltkLTJdO2Y9YltkLTFdO2EucXVhZFRvKGUueCxlLnksZi54LGYueSk7YS5zdHJva2UoKX07CmZ1bmN0aW9uIG14QXJyb3coYSxiLGMsZCxlLGYsZyl7bXhTaGFwZS5jYWxsKHRoaXMpO3RoaXMucG9pbnRzPWE7dGhpcy5maWxsPWI7dGhpcy5zdHJva2U9Yzt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWQ/ZDoxO3RoaXMuYXJyb3dXaWR0aD1udWxsIT1lP2U6bXhDb25zdGFudHMuQVJST1dfV0lEVEg7dGhpcy5zcGFjaW5nPW51bGwhPWY/ZjpteENvbnN0YW50cy5BUlJPV19TUEFDSU5HO3RoaXMuZW5kU2l6ZT1udWxsIT1nP2c6bXhDb25zdGFudHMuQVJST1dfU0laRX1teFV0aWxzLmV4dGVuZChteEFycm93LG14U2hhcGUpO214QXJyb3cucHJvdG90eXBlLmF1Z21lbnRCb3VuZGluZ0JveD1mdW5jdGlvbihhKXtteFNoYXBlLnByb3RvdHlwZS5hdWdtZW50Qm91bmRpbmdCb3guYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuZ3JvdygoTWF0aC5tYXgodGhpcy5hcnJvd1dpZHRoLHRoaXMuZW5kU2l6ZSkvMit0aGlzLnN0cm9rZXdpZHRoKSp0aGlzLnNjYWxlKX07Cm14QXJyb3cucHJvdG90eXBlLnBhaW50RWRnZVNoYXBlPWZ1bmN0aW9uKGEsYil7dmFyIGM9bXhDb25zdGFudHMuQVJST1dfU1BBQ0lORyxkPW14Q29uc3RhbnRzLkFSUk9XX1dJRFRILGU9YlswXSxmPWJbYi5sZW5ndGgtMV0sZz1mLngtZS54LGs9Zi55LWUueSxsPU1hdGguc3FydChnKmcrayprKSxtPWwtMipjLW14Q29uc3RhbnRzLkFSUk9XX1NJWkUsZz1nL2wsaz1rL2wsbD1kKmsvMyxkPS1kKmcvMyxuPWUueC1sLzIrYypnLGU9ZS55LWQvMitjKmsscD1uK2wscT1lK2Qscj1wK20qZyxtPXErbSprLHQ9citsLHU9bStkLHg9dC0zKmwseT11LTMqZDthLmJlZ2luKCk7YS5tb3ZlVG8obixlKTthLmxpbmVUbyhwLHEpO2EubGluZVRvKHIsbSk7YS5saW5lVG8odCx1KTthLmxpbmVUbyhmLngtYypnLGYueS1jKmspO2EubGluZVRvKHgseSk7YS5saW5lVG8oeCtsLHkrZCk7YS5jbG9zZSgpO2EuZmlsbEFuZFN0cm9rZSgpfTsKZnVuY3Rpb24gbXhBcnJvd0Nvbm5lY3RvcihhLGIsYyxkLGUsZixnKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5wb2ludHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjE7dGhpcy5hcnJvd1dpZHRoPW51bGwhPWU/ZTpteENvbnN0YW50cy5BUlJPV19XSURUSDt0aGlzLmFycm93U3BhY2luZz1udWxsIT1mP2Y6bXhDb25zdGFudHMuQVJST1dfU1BBQ0lORzt0aGlzLnN0YXJ0U2l6ZT1teENvbnN0YW50cy5BUlJPV19TSVpFLzU7dGhpcy5lbmRTaXplPW14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNX1teFV0aWxzLmV4dGVuZChteEFycm93Q29ubmVjdG9yLG14U2hhcGUpO214QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLnVzZVN2Z0JvdW5kaW5nQm94PSEwOwpteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5yZXNldFN0eWxlcz1mdW5jdGlvbigpe214U2hhcGUucHJvdG90eXBlLnJlc2V0U3R5bGVzLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmFycm93U3BhY2luZz1teENvbnN0YW50cy5BUlJPV19TUEFDSU5HfTtteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhKXtteFNoYXBlLnByb3RvdHlwZS5hcHBseS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5zdHlsZSYmKHRoaXMuc3RhcnRTaXplPTMqbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuQVJST1dfU0laRS81KSx0aGlzLmVuZFNpemU9MypteFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0VORFNJWkUsbXhDb25zdGFudHMuQVJST1dfU0laRS81KSl9OwpteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5hdWdtZW50Qm91bmRpbmdCb3g9ZnVuY3Rpb24oYSl7bXhTaGFwZS5wcm90b3R5cGUuYXVnbWVudEJvdW5kaW5nQm94LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYj10aGlzLmdldEVkZ2VXaWR0aCgpO3RoaXMuaXNNYXJrZXJTdGFydCgpJiYoYj1NYXRoLm1heChiLHRoaXMuZ2V0U3RhcnRBcnJvd1dpZHRoKCkpKTt0aGlzLmlzTWFya2VyRW5kKCkmJihiPU1hdGgubWF4KGIsdGhpcy5nZXRFbmRBcnJvd1dpZHRoKCkpKTthLmdyb3coKGIvMit0aGlzLnN0cm9rZXdpZHRoKSp0aGlzLnNjYWxlKX07Cm14QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLnBhaW50RWRnZVNoYXBlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5zdHJva2V3aWR0aDt0aGlzLm91dGxpbmUmJihjPU1hdGgubWF4KDEsbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VXSURUSCx0aGlzLnN0cm9rZXdpZHRoKSkpO2Zvcih2YXIgZD10aGlzLmdldFN0YXJ0QXJyb3dXaWR0aCgpK2MsZT10aGlzLmdldEVuZEFycm93V2lkdGgoKStjLGY9dGhpcy5vdXRsaW5lP3RoaXMuZ2V0RWRnZVdpZHRoKCkrYzp0aGlzLmdldEVkZ2VXaWR0aCgpLGc9dGhpcy5pc09wZW5FbmRlZCgpLGs9dGhpcy5pc01hcmtlclN0YXJ0KCksbD10aGlzLmlzTWFya2VyRW5kKCksbT1nPzA6dGhpcy5hcnJvd1NwYWNpbmcrYy8yLG49dGhpcy5zdGFydFNpemUrYyxjPXRoaXMuZW5kU2l6ZStjLHA9dGhpcy5pc0Fycm93Um91bmRlZCgpLHE9YltiLmxlbmd0aC0xXSxyPTE7cjxiLmxlbmd0aC0xJiZiW3JdLng9PQpiWzBdLngmJmJbcl0ueT09YlswXS55OylyKys7dmFyIHQ9YltyXS54LWJbMF0ueCxyPWJbcl0ueS1iWzBdLnksdT1NYXRoLnNxcnQodCp0K3Iqcik7aWYoMCE9dSl7dmFyIHg9dC91LHksQj14LEE9ci91LHosQz1BLHU9ZipBLHY9LWYqeCxEPVtdO3A/YS5zZXRMaW5lSm9pbigicm91bmQiKToyPGIubGVuZ3RoJiZhLnNldE1pdGVyTGltaXQoMS40Mik7YS5iZWdpbigpO3Q9eDtyPUE7aWYoayYmIWcpdGhpcy5wYWludE1hcmtlcihhLGJbMF0ueCxiWzBdLnkseCxBLG4sZCxmLG0sITApO2Vsc2V7eT1iWzBdLngrdS8yK20qeDt6PWJbMF0ueSt2LzIrbSpBO3ZhciBHPWJbMF0ueC11LzIrbSp4LEo9YlswXS55LXYvMittKkE7Zz8oYS5tb3ZlVG8oeSx6KSxELnB1c2goZnVuY3Rpb24oKXthLmxpbmVUbyhHLEopfSkpOihhLm1vdmVUbyhHLEopLGEubGluZVRvKHkseikpfWZvcih2YXIgRT16PXk9MCx1PTA7dTxiLmxlbmd0aC0yO3UrKylpZih2PW14VXRpbHMucmVsYXRpdmVDY3coYlt1XS54LApiW3VdLnksYlt1KzFdLngsYlt1KzFdLnksYlt1KzJdLngsYlt1KzJdLnkpLHk9Ylt1KzJdLngtYlt1KzFdLngsej1iW3UrMl0ueS1iW3UrMV0ueSxFPU1hdGguc3FydCh5Knkreip6KSwwIT1FKXtCPXkvRTtDPXovRTtFPU1hdGgubWF4KE1hdGguc3FydCgoeCpCK0EqQysxKS8yKSwuMDQpO3k9eCtCO3o9QStDO3ZhciBIPU1hdGguc3FydCh5Knkreip6KTtpZigwIT1IKXt5Lz1IO3ovPUg7dmFyIEg9TWF0aC5tYXgoRSxNYXRoLm1pbih0aGlzLnN0cm9rZXdpZHRoLzIwMCsuMDQsLjM1KSksRT0wIT12JiZwP01hdGgubWF4KC4xLEgpOk1hdGgubWF4KEUsLjA2KSxJPWJbdSsxXS54K3oqZi8yL0UsRj1iW3UrMV0ueS15KmYvMi9FO3o9Ylt1KzFdLngteipmLzIvRTt5PWJbdSsxXS55K3kqZi8yL0U7MCE9diYmcD8tMT09dj8odj16K0MqZixFPXktQipmLGEubGluZVRvKHorQSpmLHkteCpmKSxhLnF1YWRUbyhJLEYsdixFKSxmdW5jdGlvbihiLGMpe0QucHVzaChmdW5jdGlvbigpe2EubGluZVRvKGIsCmMpfSl9KHoseSkpOihhLmxpbmVUbyhJLEYpLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9SS1BKmYsZT1GK3gqZixnPUktQypmLGs9RitCKmY7RC5wdXNoKGZ1bmN0aW9uKCl7YS5xdWFkVG8oYixjLGQsZSl9KTtELnB1c2goZnVuY3Rpb24oKXthLmxpbmVUbyhnLGspfSl9KHoseSkpOihhLmxpbmVUbyhJLEYpLGZ1bmN0aW9uKGIsYyl7RC5wdXNoKGZ1bmN0aW9uKCl7YS5saW5lVG8oYixjKX0pfSh6LHkpKTt4PUI7QT1DfX11PWYqQzt2PS1mKkI7aWYobCYmIWcpdGhpcy5wYWludE1hcmtlcihhLHEueCxxLnksLXgsLUEsYyxlLGYsbSwhMSk7ZWxzZXthLmxpbmVUbyhxLngtbSpCK3UvMixxLnktbSpDK3YvMik7dmFyIEs9cS54LW0qQi11LzIsTD1xLnktbSpDLXYvMjtnPyhhLm1vdmVUbyhLLEwpLEQuc3BsaWNlKDAsMCxmdW5jdGlvbigpe2EubW92ZVRvKEssTCl9KSk6YS5saW5lVG8oSyxMKX1mb3IodT1ELmxlbmd0aC0xOzA8PXU7dS0tKURbdV0oKTtnPyhhLmVuZCgpLGEuc3Ryb2tlKCkpOgooYS5jbG9zZSgpLGEuZmlsbEFuZFN0cm9rZSgpKTthLnNldFNoYWRvdyghMSk7YS5zZXRNaXRlckxpbWl0KDQpO3AmJmEuc2V0TGluZUpvaW4oImZsYXQiKTsyPGIubGVuZ3RoJiYoYS5zZXRNaXRlckxpbWl0KDQpLGsmJiFnJiYoYS5iZWdpbigpLHRoaXMucGFpbnRNYXJrZXIoYSxiWzBdLngsYlswXS55LHQscixuLGQsZixtLCEwKSxhLnN0cm9rZSgpLGEuZW5kKCkpLGwmJiFnJiYoYS5iZWdpbigpLHRoaXMucGFpbnRNYXJrZXIoYSxxLngscS55LC14LC1BLGMsZSxmLG0sITApLGEuc3Ryb2tlKCksYS5lbmQoKSkpfX07Cm14QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLnBhaW50TWFya2VyPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsLG0pe2c9ay9nO3ZhciBuPWsqZS8yO2s9LWsqZC8yO3ZhciBwPShsK2YpKmQ7Zj0obCtmKSplO20/YS5tb3ZlVG8oYi1uK3AsYy1rK2YpOmEubGluZVRvKGItbitwLGMtaytmKTthLmxpbmVUbyhiLW4vZytwLGMtay9nK2YpO2EubGluZVRvKGIrbCpkLGMrbCplKTthLmxpbmVUbyhiK24vZytwLGMray9nK2YpO2EubGluZVRvKGIrbitwLGMraytmKX07bXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuaXNBcnJvd1JvdW5kZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JvdW5kZWR9O214QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLmdldFN0YXJ0QXJyb3dXaWR0aD1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5BUlJPV19XSURUSH07bXhBcnJvd0Nvbm5lY3Rvci5wcm90b3R5cGUuZ2V0RW5kQXJyb3dXaWR0aD1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5BUlJPV19XSURUSH07Cm14QXJyb3dDb25uZWN0b3IucHJvdG90eXBlLmdldEVkZ2VXaWR0aD1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5BUlJPV19XSURUSC8zfTtteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5pc09wZW5FbmRlZD1mdW5jdGlvbigpe3JldHVybiExfTtteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5pc01hcmtlclN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVEFSUk9XLG14Q29uc3RhbnRzLk5PTkUpIT1teENvbnN0YW50cy5OT05FfTtteEFycm93Q29ubmVjdG9yLnByb3RvdHlwZS5pc01hcmtlckVuZD1mdW5jdGlvbigpe3JldHVybiBteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1csbXhDb25zdGFudHMuTk9ORSkhPW14Q29uc3RhbnRzLk5PTkV9OwpmdW5jdGlvbiBteFRleHQoYSxiLGMsZCxlLGYsZyxrLGwsbSxuLHAscSxyLHQsdSx4LHksQixBLHope214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLnZhbHVlPWE7dGhpcy5ib3VuZHM9Yjt0aGlzLmNvbG9yPW51bGwhPWU/ZToiYmxhY2siO3RoaXMuYWxpZ249bnVsbCE9Yz9jOm14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUjt0aGlzLnZhbGlnbj1udWxsIT1kP2Q6bXhDb25zdGFudHMuQUxJR05fTUlERExFO3RoaXMuZmFtaWx5PW51bGwhPWY/ZjpteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFk7dGhpcy5zaXplPW51bGwhPWc/ZzpteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFO3RoaXMuZm9udFN0eWxlPW51bGwhPWs/azpteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTVFlMRTt0aGlzLnNwYWNpbmc9cGFyc2VJbnQobHx8Mik7dGhpcy5zcGFjaW5nVG9wPXRoaXMuc3BhY2luZytwYXJzZUludChtfHwwKTt0aGlzLnNwYWNpbmdSaWdodD10aGlzLnNwYWNpbmcrcGFyc2VJbnQobnx8MCk7CnRoaXMuc3BhY2luZ0JvdHRvbT10aGlzLnNwYWNpbmcrcGFyc2VJbnQocHx8MCk7dGhpcy5zcGFjaW5nTGVmdD10aGlzLnNwYWNpbmcrcGFyc2VJbnQocXx8MCk7dGhpcy5ob3Jpem9udGFsPW51bGwhPXI/cjohMDt0aGlzLmJhY2tncm91bmQ9dDt0aGlzLmJvcmRlcj11O3RoaXMud3JhcD1udWxsIT14P3g6ITE7dGhpcy5jbGlwcGVkPW51bGwhPXk/eTohMTt0aGlzLm92ZXJmbG93PW51bGwhPUI/QjoidmlzaWJsZSI7dGhpcy5sYWJlbFBhZGRpbmc9bnVsbCE9QT9BOjA7dGhpcy50ZXh0RGlyZWN0aW9uPXo7dGhpcy5yb3RhdGlvbj0wO3RoaXMudXBkYXRlTWFyZ2luKCl9bXhVdGlscy5leHRlbmQobXhUZXh0LG14U2hhcGUpO214VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdUb3A9MDtteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nQm90dG9tPTA7bXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0xlZnQ9MDtteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nUmlnaHQ9MDsKbXhUZXh0LnByb3RvdHlwZS5yZXBsYWNlTGluZWZlZWRzPSEwO214VGV4dC5wcm90b3R5cGUudmVydGljYWxUZXh0Um90YXRpb249LTkwO214VGV4dC5wcm90b3R5cGUuaWdub3JlQ2xpcHBlZFN0cmluZ1NpemU9ITA7bXhUZXh0LnByb3RvdHlwZS5pZ25vcmVTdHJpbmdTaXplPSExO214VGV4dC5wcm90b3R5cGUudGV4dFdpZHRoUGFkZGluZz04IT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VNPzM6NDtteFRleHQucHJvdG90eXBlLmxhc3RWYWx1ZT1udWxsO214VGV4dC5wcm90b3R5cGUuY2FjaGVFbmFibGVkPSEwO214VGV4dC5wcm90b3R5cGUuaXNQYXJzZVZtbD1mdW5jdGlvbigpe3JldHVybiExfTtteFRleHQucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19FTX07bXhUZXh0LnByb3RvdHlwZS5nZXRTdmdTY3JlZW5PZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH07Cm14VGV4dC5wcm90b3R5cGUuY2hlY2tCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4haXNOYU4odGhpcy5zY2FsZSkmJmlzRmluaXRlKHRoaXMuc2NhbGUpJiYwPHRoaXMuc2NhbGUmJm51bGwhPXRoaXMuYm91bmRzJiYhaXNOYU4odGhpcy5ib3VuZHMueCkmJiFpc05hTih0aGlzLmJvdW5kcy55KSYmIWlzTmFOKHRoaXMuYm91bmRzLndpZHRoKSYmIWlzTmFOKHRoaXMuYm91bmRzLmhlaWdodCl9OwpteFRleHQucHJvdG90eXBlLnBhaW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5zY2FsZSxkPXRoaXMuYm91bmRzLngvYyxlPXRoaXMuYm91bmRzLnkvYyxmPXRoaXMuYm91bmRzLndpZHRoL2MsYz10aGlzLmJvdW5kcy5oZWlnaHQvYzt0aGlzLnVwZGF0ZVRyYW5zZm9ybShhLGQsZSxmLGMpO3RoaXMuY29uZmlndXJlQ2FudmFzKGEsZCxlLGYsYyk7aWYoYilhLnVwZGF0ZVRleHQoZCxlLGYsYyx0aGlzLmFsaWduLHRoaXMudmFsaWduLHRoaXMud3JhcCx0aGlzLm92ZXJmbG93LHRoaXMuY2xpcHBlZCx0aGlzLmdldFRleHRSb3RhdGlvbigpLHRoaXMubm9kZSk7ZWxzZXt2YXIgZz1teFV0aWxzLmlzTm9kZSh0aGlzLnZhbHVlKXx8dGhpcy5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwsaz1nfHxhIGluc3RhbmNlb2YgbXhWbWxDYW52YXMyRD8iaHRtbCI6IiIsbD10aGlzLnZhbHVlO2d8fCJodG1sIiE9a3x8KGw9bXhVdGlscy5odG1sRW50aXRpZXMobCwhMSkpOwoiaHRtbCIhPWt8fG14VXRpbHMuaXNOb2RlKHRoaXMudmFsdWUpfHwobD1teFV0aWxzLnJlcGxhY2VUcmFpbGluZ05ld2xpbmVzKGwsIjxkaXY+PGJyPjwvZGl2PiIpKTt2YXIgbD0hbXhVdGlscy5pc05vZGUodGhpcy52YWx1ZSkmJnRoaXMucmVwbGFjZUxpbmVmZWVkcyYmImh0bWwiPT1rP2wucmVwbGFjZSgvXG4vZywiPGJyLz4iKTpsLG09dGhpcy50ZXh0RGlyZWN0aW9uO20hPW14Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX0FVVE98fGd8fChtPXRoaXMuZ2V0QXV0b0RpcmVjdGlvbigpKTttIT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9MVFImJm0hPW14Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX1JUTCYmKG09bnVsbCk7YS50ZXh0KGQsZSxmLGMsbCx0aGlzLmFsaWduLHRoaXMudmFsaWduLHRoaXMud3JhcCxrLHRoaXMub3ZlcmZsb3csdGhpcy5jbGlwcGVkLHRoaXMuZ2V0VGV4dFJvdGF0aW9uKCksbSl9fTsKbXhUZXh0LnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXtpZih0aGlzLnZpc2libGUmJnRoaXMuY2hlY2tCb3VuZHMoKSYmdGhpcy5jYWNoZUVuYWJsZWQmJnRoaXMubGFzdFZhbHVlPT10aGlzLnZhbHVlJiYobXhVdGlscy5pc05vZGUodGhpcy52YWx1ZSl8fHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MKSlpZigiRElWIiE9dGhpcy5ub2RlLm5vZGVOYW1lfHwhdGhpcy5pc0h0bWxBbGxvd2VkKCkmJm14Q2xpZW50LklTX1ZNTCl7dmFyIGE9dGhpcy5jcmVhdGVDYW52YXMoKTtudWxsIT1hJiZudWxsIT1hLnVwZGF0ZVRleHQ/KGEucG9pbnRlckV2ZW50cz10aGlzLnBvaW50ZXJFdmVudHMsdGhpcy5wYWludChhLCEwKSx0aGlzLmRlc3Ryb3lDYW52YXMoYSksdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpKTpteFNoYXBlLnByb3RvdHlwZS5yZWRyYXcuYXBwbHkodGhpcyxhcmd1bWVudHMpfWVsc2UgbXhDbGllbnQuSVNfU1ZHP3RoaXMucmVkcmF3SHRtbFNoYXBlV2l0aENzczMoKToKKHRoaXMudXBkYXRlU2l6ZSh0aGlzLm5vZGUsbnVsbD09dGhpcy5zdGF0ZXx8bnVsbD09dGhpcy5zdGF0ZS52aWV3LnRleHREaXYpLG14Q2xpZW50LklTX0lFJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw4Pj1kb2N1bWVudC5kb2N1bWVudE1vZGUpP3RoaXMudXBkYXRlSHRtbEZpbHRlcigpOnRoaXMudXBkYXRlSHRtbFRyYW5zZm9ybSgpKSx0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KCk7ZWxzZSBteFNoYXBlLnByb3RvdHlwZS5yZWRyYXcuYXBwbHkodGhpcyxhcmd1bWVudHMpLG14VXRpbHMuaXNOb2RlKHRoaXMudmFsdWUpfHx0aGlzLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTD90aGlzLmxhc3RWYWx1ZT10aGlzLnZhbHVlOnRoaXMubGFzdFZhbHVlPW51bGx9OwpteFRleHQucHJvdG90eXBlLnJlc2V0U3R5bGVzPWZ1bmN0aW9uKCl7bXhTaGFwZS5wcm90b3R5cGUucmVzZXRTdHlsZXMuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuY29sb3I9ImJsYWNrIjt0aGlzLmFsaWduPW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUjt0aGlzLnZhbGlnbj1teENvbnN0YW50cy5BTElHTl9NSURETEU7dGhpcy5mYW1pbHk9bXhDb25zdGFudHMuREVGQVVMVF9GT05URkFNSUxZO3RoaXMuc2l6ZT1teENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFO3RoaXMuZm9udFN0eWxlPW14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVFNUWUxFO3RoaXMuc3BhY2luZ0xlZnQ9dGhpcy5zcGFjaW5nQm90dG9tPXRoaXMuc3BhY2luZ1JpZ2h0PXRoaXMuc3BhY2luZ1RvcD10aGlzLnNwYWNpbmc9Mjt0aGlzLmhvcml6b250YWw9ITA7ZGVsZXRlIHRoaXMuYmFja2dyb3VuZDtkZWxldGUgdGhpcy5ib3JkZXI7dGhpcy50ZXh0RGlyZWN0aW9uPW14Q29uc3RhbnRzLkRFRkFVTFRfVEVYVF9ESVJFQ1RJT047CmRlbGV0ZSB0aGlzLm1hcmdpbn07Cm14VGV4dC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zcGFjaW5nO214U2hhcGUucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT10aGlzLnN0eWxlJiYodGhpcy5mb250U3R5bGU9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSx0aGlzLmZvbnRTdHlsZSksdGhpcy5mYW1pbHk9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRGQU1JTFksdGhpcy5mYW1pbHkpLHRoaXMuc2l6ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkUsdGhpcy5zaXplKSx0aGlzLmNvbG9yPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1IsdGhpcy5jb2xvciksdGhpcy5hbGlnbj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUxJR04sCnRoaXMuYWxpZ24pLHRoaXMudmFsaWduPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTix0aGlzLnZhbGlnbiksdGhpcy5zcGFjaW5nPXBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HLHRoaXMuc3BhY2luZykpLHRoaXMuc3BhY2luZ1RvcD1wYXJzZUludChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19UT1AsdGhpcy5zcGFjaW5nVG9wLWIpKSt0aGlzLnNwYWNpbmcsdGhpcy5zcGFjaW5nUmlnaHQ9cGFyc2VJbnQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfUklHSFQsdGhpcy5zcGFjaW5nUmlnaHQtYikpK3RoaXMuc3BhY2luZyx0aGlzLnNwYWNpbmdCb3R0b209cGFyc2VJbnQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfQk9UVE9NLAp0aGlzLnNwYWNpbmdCb3R0b20tYikpK3RoaXMuc3BhY2luZyx0aGlzLnNwYWNpbmdMZWZ0PXBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0xFRlQsdGhpcy5zcGFjaW5nTGVmdC1iKSkrdGhpcy5zcGFjaW5nLHRoaXMuaG9yaXpvbnRhbD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCx0aGlzLmhvcml6b250YWwpLHRoaXMuYmFja2dyb3VuZD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfQkFDS0dST1VORENPTE9SLHRoaXMuYmFja2dyb3VuZCksdGhpcy5ib3JkZXI9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JPUkRFUkNPTE9SLHRoaXMuYm9yZGVyKSx0aGlzLnRleHREaXJlY3Rpb249bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1RFWFRfRElSRUNUSU9OLApteENvbnN0YW50cy5ERUZBVUxUX1RFWFRfRElSRUNUSU9OKSx0aGlzLm9wYWNpdHk9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1RFWFRfT1BBQ0lUWSwxMDApLHRoaXMudXBkYXRlTWFyZ2luKCkpO3RoaXMuZmxpcEg9dGhpcy5mbGlwVj1udWxsfTtteFRleHQucHJvdG90eXBlLmdldEF1dG9EaXJlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYT0vW0EtWmEtelx1MDVkMC1cdTA2NWZcdTA2NmEtXHUwNmVmXHUwNmZhLVx1MDdmZlx1ZmIxZC1cdWZkZmZcdWZlNzAtXHVmZWZjXS8uZXhlYyh0aGlzLnZhbHVlKTtyZXR1cm4gbnVsbCE9YSYmMDxhLmxlbmd0aCYmInoiPGFbMF0/bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fUlRMOm14Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX0xUUn07Cm14VGV4dC5wcm90b3R5cGUuZ2V0Q29udGVudE5vZGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm5vZGU7bnVsbCE9YSYmKGE9bnVsbD09YS5vd25lclNWR0VsZW1lbnQ/dGhpcy5ub2RlLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZDphLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCk7cmV0dXJuIGF9OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nQm94PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ub2RlO3RoaXMuYm91bmRpbmdCb3g9dGhpcy5ib3VuZHMuY2xvbmUoKTt2YXIgYj10aGlzLmdldFRleHRSb3RhdGlvbigpLGM9bnVsbCE9dGhpcy5zdHlsZT9teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKTpudWxsLGQ9bnVsbCE9dGhpcy5zdHlsZT9teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKTpudWxsO2lmKCEodGhpcy5pZ25vcmVTdHJpbmdTaXplfHxudWxsPT1hfHwiZmlsbCI9PXRoaXMub3ZlcmZsb3d8fHRoaXMuY2xpcHBlZCYmdGhpcy5pZ25vcmVDbGlwcGVkU3RyaW5nU2l6ZSYmYz09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJiZkPT1teENvbnN0YW50cy5BTElHTl9NSURETEUpKXtkPQpjPW51bGw7aWYobnVsbCE9YS5vd25lclNWR0VsZW1lbnQpaWYobnVsbCE9YS5maXJzdENoaWxkJiZudWxsIT1hLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCYmImZvcmVpZ25PYmplY3QiPT1hLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC5ub2RlTmFtZSlhPWEuZmlyc3RDaGlsZC5maXJzdENoaWxkLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCxkPWEub2Zmc2V0SGVpZ2h0KnRoaXMuc2NhbGUsYz0id2lkdGgiPT10aGlzLm92ZXJmbG93P3RoaXMuYm91bmRpbmdCb3gud2lkdGg6YS5vZmZzZXRXaWR0aCp0aGlzLnNjYWxlO2Vsc2UgdHJ5e3ZhciBlPWEuZ2V0QkJveCgpOyJzdHJpbmciPT10eXBlb2YgdGhpcy52YWx1ZSYmMD09bXhVdGlscy50cmltKHRoaXMudmFsdWUpP3RoaXMuYm91bmRpbmdCb3g9bnVsbDp0aGlzLmJvdW5kaW5nQm94PTA9PWUud2lkdGgmJjA9PWUuaGVpZ2h0P251bGw6bmV3IG14UmVjdGFuZ2xlKGUueCxlLnksZS53aWR0aCxlLmhlaWdodCk7cmV0dXJufWNhdGNoKGYpe31lbHNle2M9Cm51bGwhPXRoaXMuc3RhdGU/dGhpcy5zdGF0ZS52aWV3LnRleHREaXY6bnVsbDtpZihudWxsPT10aGlzLm9mZnNldFdpZHRofHxudWxsPT10aGlzLm9mZnNldEhlaWdodCludWxsIT1jJiYodGhpcy51cGRhdGVGb250KGMpLHRoaXMudXBkYXRlU2l6ZShjLCExKSx0aGlzLnVwZGF0ZUlubmVySHRtbChjKSxhPWMpLGU9YSw4IT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VNP251bGwhPWUuZmlyc3RDaGlsZCYmIkRJViI9PWUuZmlyc3RDaGlsZC5ub2RlTmFtZSYmKGU9ZS5maXJzdENoaWxkKTooZD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLndpZHRoL3RoaXMuc2NhbGUpLHRoaXMud3JhcCYmMDxkPyhhLnN0eWxlLndvcmRXcmFwPW14Q29uc3RhbnRzLldPUkRfV1JBUCxhLnN0eWxlLndoaXRlU3BhY2U9Im5vcm1hbCIsImJyZWFrLXdvcmQiIT1hLnN0eWxlLndvcmRXcmFwJiYoYT1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKSwwPGEubGVuZ3RoJiYoZT1hW2EubGVuZ3RoLQoxXSksYz1lLm9mZnNldFdpZHRoKzIsYT10aGlzLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLHRoaXMuY2xpcHBlZCYmKGM9TWF0aC5taW4oZCxjKSksMTxhLmxlbmd0aCYmKGFbYS5sZW5ndGgtMl0uc3R5bGUud2lkdGg9YysicHgiKSkpOmEuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIiksdGhpcy5vZmZzZXRXaWR0aD1lLm9mZnNldFdpZHRoK3RoaXMudGV4dFdpZHRoUGFkZGluZyx0aGlzLm9mZnNldEhlaWdodD1lLm9mZnNldEhlaWdodDtjPXRoaXMub2Zmc2V0V2lkdGgqdGhpcy5zY2FsZTtkPXRoaXMub2Zmc2V0SGVpZ2h0KnRoaXMuc2NhbGV9bnVsbCE9YyYmbnVsbCE9ZCYmKHRoaXMuYm91bmRpbmdCb3g9bmV3IG14UmVjdGFuZ2xlKHRoaXMuYm91bmRzLngsdGhpcy5ib3VuZHMueSxjLGQpKX1udWxsIT10aGlzLmJvdW5kaW5nQm94JiYoMCE9Yj8oYj1teFV0aWxzLmdldEJvdW5kaW5nQm94KG5ldyBteFJlY3RhbmdsZSh0aGlzLm1hcmdpbi54KnRoaXMuYm91bmRpbmdCb3gud2lkdGgsCnRoaXMubWFyZ2luLnkqdGhpcy5ib3VuZGluZ0JveC5oZWlnaHQsdGhpcy5ib3VuZGluZ0JveC53aWR0aCx0aGlzLmJvdW5kaW5nQm94LmhlaWdodCksYixuZXcgbXhQb2ludCgwLDApKSx0aGlzLnVucm90YXRlZEJvdW5kaW5nQm94PW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUodGhpcy5ib3VuZGluZ0JveCksdGhpcy51bnJvdGF0ZWRCb3VuZGluZ0JveC54Kz10aGlzLm1hcmdpbi54KnRoaXMudW5yb3RhdGVkQm91bmRpbmdCb3gud2lkdGgsdGhpcy51bnJvdGF0ZWRCb3VuZGluZ0JveC55Kz10aGlzLm1hcmdpbi55KnRoaXMudW5yb3RhdGVkQm91bmRpbmdCb3guaGVpZ2h0LHRoaXMuYm91bmRpbmdCb3gueCs9Yi54LHRoaXMuYm91bmRpbmdCb3gueSs9Yi55LHRoaXMuYm91bmRpbmdCb3gud2lkdGg9Yi53aWR0aCx0aGlzLmJvdW5kaW5nQm94LmhlaWdodD1iLmhlaWdodCk6KHRoaXMuYm91bmRpbmdCb3gueCs9dGhpcy5tYXJnaW4ueCp0aGlzLmJvdW5kaW5nQm94LndpZHRoLHRoaXMuYm91bmRpbmdCb3gueSs9CnRoaXMubWFyZ2luLnkqdGhpcy5ib3VuZGluZ0JveC5oZWlnaHQsdGhpcy51bnJvdGF0ZWRCb3VuZGluZ0JveD1udWxsKSl9O214VGV4dC5wcm90b3R5cGUuZ2V0U2hhcGVSb3RhdGlvbj1mdW5jdGlvbigpe3JldHVybiAwfTtteFRleHQucHJvdG90eXBlLmdldFRleHRSb3RhdGlvbj1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLnN0YXRlJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlP3RoaXMuc3RhdGUuc2hhcGUuZ2V0VGV4dFJvdGF0aW9uKCk6MH07bXhUZXh0LnByb3RvdHlwZS5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5ob3Jpem9udGFsJiZudWxsIT10aGlzLnN0YXRlJiZ0aGlzLnN0YXRlLnZpZXcuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgodGhpcy5zdGF0ZS5jZWxsKX07Cm14VGV4dC5wcm90b3R5cGUuY29uZmlndXJlQ2FudmFzPWZ1bmN0aW9uKGEsYixjLGQsZSl7bXhTaGFwZS5wcm90b3R5cGUuY29uZmlndXJlQ2FudmFzLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnNldEZvbnRDb2xvcih0aGlzLmNvbG9yKTthLnNldEZvbnRCYWNrZ3JvdW5kQ29sb3IodGhpcy5iYWNrZ3JvdW5kKTthLnNldEZvbnRCb3JkZXJDb2xvcih0aGlzLmJvcmRlcik7YS5zZXRGb250RmFtaWx5KHRoaXMuZmFtaWx5KTthLnNldEZvbnRTaXplKHRoaXMuc2l6ZSk7YS5zZXRGb250U3R5bGUodGhpcy5mb250U3R5bGUpfTsKbXhUZXh0LnByb3RvdHlwZS51cGRhdGVWbWxDb250YWluZXI9ZnVuY3Rpb24oKXt0aGlzLm5vZGUuc3R5bGUubGVmdD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngpKyJweCI7dGhpcy5ub2RlLnN0eWxlLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkpKyJweCI7dGhpcy5ub2RlLnN0eWxlLndpZHRoPSIxcHgiO3RoaXMubm9kZS5zdHlsZS5oZWlnaHQ9IjFweCI7dGhpcy5ub2RlLnN0eWxlLm92ZXJmbG93PSJ2aXNpYmxlIn07bXhUZXh0LnByb3RvdHlwZS5nZXRIdG1sVmFsdWU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnZhbHVlO3RoaXMuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MJiYoYT1teFV0aWxzLmh0bWxFbnRpdGllcyhhLCExKSk7YT1teFV0aWxzLnJlcGxhY2VUcmFpbGluZ05ld2xpbmVzKGEsIjxkaXY+PGJyPjwvZGl2PiIpO3JldHVybiB0aGlzLnJlcGxhY2VMaW5lZmVlZHM/YS5yZXBsYWNlKC9cbi9nLCI8YnIvPiIpOmF9OwpteFRleHQucHJvdG90eXBlLmdldFRleHRDc3M9ZnVuY3Rpb24oKXt2YXIgYT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6ICIrdGhpcy5zaXplKyJweDsgZm9udC1mYW1pbHk6ICIrdGhpcy5mYW1pbHkrIjsgY29sb3I6ICIrdGhpcy5jb2xvcisiOyBsaW5lLWhlaWdodDogIisobXhDb25zdGFudHMuQUJTT0xVVEVfTElORV9IRUlHSFQ/dGhpcy5zaXplKm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQpKyI7IHBvaW50ZXItZXZlbnRzOiAiKyh0aGlzLnBvaW50ZXJFdmVudHM/ImFsbCI6Im5vbmUiKSsiOyAiOyh0aGlzLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQmJihhKz0iZm9udC13ZWlnaHQ6IGJvbGQ7ICIpOyh0aGlzLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDJiYoYSs9ImZvbnQtc3R5bGU6IGl0YWxpYzsgIik7CnZhciBiPVtdOyh0aGlzLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1VOREVSTElORSk9PW14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FJiZiLnB1c2goInVuZGVybGluZSIpOyh0aGlzLmZvbnRTdHlsZSZteENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gpPT1teENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gmJmIucHVzaCgibGluZS10aHJvdWdoIik7MDxiLmxlbmd0aCYmKGErPSJ0ZXh0LWRlY29yYXRpb246ICIrYi5qb2luKCIgIikrIjsgIik7cmV0dXJuIGF9OwpteFRleHQucHJvdG90eXBlLnJlZHJhd0h0bWxTaGFwZT1mdW5jdGlvbigpe2lmKG14Q2xpZW50LklTX1NWRyl0aGlzLnJlZHJhd0h0bWxTaGFwZVdpdGhDc3MzKCk7ZWxzZXt2YXIgYT10aGlzLm5vZGUuc3R5bGU7YS53aGl0ZVNwYWNlPSJub3JtYWwiO2Eub3ZlcmZsb3c9IiI7YS53aWR0aD0iIjthLmhlaWdodD0iIjt0aGlzLnVwZGF0ZVZhbHVlKCk7dGhpcy51cGRhdGVGb250KHRoaXMubm9kZSk7dGhpcy51cGRhdGVTaXplKHRoaXMubm9kZSxudWxsPT10aGlzLnN0YXRlfHxudWxsPT10aGlzLnN0YXRlLnZpZXcudGV4dERpdik7dGhpcy5vZmZzZXRIZWlnaHQ9dGhpcy5vZmZzZXRXaWR0aD1udWxsO214Q2xpZW50LklTX0lFJiYobnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw4Pj1kb2N1bWVudC5kb2N1bWVudE1vZGUpP3RoaXMudXBkYXRlSHRtbEZpbHRlcigpOnRoaXMudXBkYXRlSHRtbFRyYW5zZm9ybSgpfX07Cm14VGV4dC5wcm90b3R5cGUucmVkcmF3SHRtbFNoYXBlV2l0aENzczM9ZnVuY3Rpb24oKXt2YXIgYT1NYXRoLm1heCgwLE1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgvdGhpcy5zY2FsZSkpLGI9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLmhlaWdodC90aGlzLnNjYWxlKSksYz0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAiK01hdGgucm91bmQodGhpcy5ib3VuZHMueCkrInB4OyB0b3A6ICIrTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55KSsicHg7IHBvaW50ZXItZXZlbnRzOiBub25lOyAiLGQ9dGhpcy5nZXRUZXh0Q3NzKCk7bXhTdmdDYW52YXMyRC5jcmVhdGVDc3MoYSsyLGIsdGhpcy5hbGlnbix0aGlzLnZhbGlnbix0aGlzLndyYXAsdGhpcy5vdmVyZmxvdyx0aGlzLmNsaXBwZWQsbnVsbCE9dGhpcy5iYWNrZ3JvdW5kP214VXRpbHMuaHRtbEVudGl0aWVzKHRoaXMuYmFja2dyb3VuZCk6bnVsbCxudWxsIT10aGlzLmJvcmRlcj9teFV0aWxzLmh0bWxFbnRpdGllcyh0aGlzLmJvcmRlcik6Cm51bGwsYyxkLHRoaXMuc2NhbGUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiLGMsZCxsLG0pe2E9dGhpcy5nZXRUZXh0Um90YXRpb24oKTthPSgxIT10aGlzLnNjYWxlPyJzY2FsZSgiK3RoaXMuc2NhbGUrIikgIjoiIikrKDAhPWE/InJvdGF0ZSgiK2ErImRlZykgIjoiIikrKDAhPXRoaXMubWFyZ2luLnh8fDAhPXRoaXMubWFyZ2luLnk/InRyYW5zbGF0ZSgiKzEwMCp0aGlzLm1hcmdpbi54KyIlLCIrMTAwKnRoaXMubWFyZ2luLnkrIiUpIjoiIik7IiIhPWEmJihhPSJ0cmFuc2Zvcm0tb3JpZ2luOiAwIDA7IHRyYW5zZm9ybTogIithKyI7ICIpOyIiPT1tPyhjKz1kLGQ9ImRpc3BsYXk6aW5saW5lLWJsb2NrOyBtaW4td2lkdGg6IDEwMCU7ICIrYSk6ZCs9YTsxMDA+dGhpcy5vcGFjaXR5JiYobCs9Im9wYWNpdHk6ICIrdGhpcy5vcGFjaXR5LzEwMCsiOyAiKTt0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJzdHlsZSIsYyk7Yz1teFV0aWxzLmlzTm9kZSh0aGlzLnZhbHVlKT90aGlzLnZhbHVlLm91dGVySFRNTDoKdGhpcy5nZXRIdG1sVmFsdWUoKTtudWxsPT10aGlzLm5vZGUuZmlyc3RDaGlsZCYmKHRoaXMubm9kZS5pbm5lckhUTUw9IjxkaXY+PGRpdj4iK2MrIjwvZGl2PjwvZGl2PiIpO3RoaXMubm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCJzdHlsZSIsbCk7dGhpcy5ub2RlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCJzdHlsZSIsZCl9KSl9OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZUh0bWxUcmFuc2Zvcm09ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFRleHRSb3RhdGlvbigpLGI9dGhpcy5ub2RlLnN0eWxlLGM9dGhpcy5tYXJnaW4ueCxkPXRoaXMubWFyZ2luLnk7MCE9YT8obXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGIsInRyYW5zZm9ybU9yaWdpbiIsMTAwKi1jKyIlICIrMTAwKi1kKyIlIiksbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGIsInRyYW5zZm9ybSIsInRyYW5zbGF0ZSgiKzEwMCpjKyIlLCIrMTAwKmQrIiUpIHNjYWxlKCIrdGhpcy5zY2FsZSsiKSByb3RhdGUoIithKyJkZWcpIikpOihteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoYiwidHJhbnNmb3JtT3JpZ2luIiwiMCUgMCUiKSxteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoYiwidHJhbnNmb3JtIiwic2NhbGUoIit0aGlzLnNjYWxlKyIpIHRyYW5zbGF0ZSgiKzEwMCpjKyIlLCIrMTAwKmQrIiUpIikpO2IubGVmdD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngtCk1hdGguY2VpbChjKigiZmlsbCIhPXRoaXMub3ZlcmZsb3cmJiJ3aWR0aCIhPXRoaXMub3ZlcmZsb3c/MzoxKSkpKyJweCI7Yi50b3A9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55LWQqKCJmaWxsIiE9dGhpcy5vdmVyZmxvdz8zOjEpKSsicHgiO2Iub3BhY2l0eT0xMDA+dGhpcy5vcGFjaXR5P3RoaXMub3BhY2l0eS8xMDA6IiJ9OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZUlubmVySHRtbD1mdW5jdGlvbihhKXtpZihteFV0aWxzLmlzTm9kZSh0aGlzLnZhbHVlKSlhLmlubmVySFRNTD10aGlzLnZhbHVlLm91dGVySFRNTDtlbHNle3ZhciBiPXRoaXMudmFsdWU7dGhpcy5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwmJihiPW14VXRpbHMuaHRtbEVudGl0aWVzKGIsITEpKTtiPW14VXRpbHMucmVwbGFjZVRyYWlsaW5nTmV3bGluZXMoYiwiPGRpdj4mbmJzcDs8L2Rpdj4iKTtiPXRoaXMucmVwbGFjZUxpbmVmZWVkcz9iLnJlcGxhY2UoL1xuL2csIjxici8+Iik6YjthLmlubmVySFRNTD0nPGRpdiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7X2Rpc3BsYXk6aW5saW5lOyI+JytiKyI8L2Rpdj4ifX07Cm14VGV4dC5wcm90b3R5cGUudXBkYXRlSHRtbEZpbHRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMubm9kZS5zdHlsZSxiPXRoaXMubWFyZ2luLngsYz10aGlzLm1hcmdpbi55LGQ9dGhpcy5zY2FsZTtteFV0aWxzLnNldE9wYWNpdHkodGhpcy5ub2RlLHRoaXMub3BhY2l0eSk7dmFyIGUsZj0wLGc9bnVsbCE9dGhpcy5zdGF0ZT90aGlzLnN0YXRlLnZpZXcudGV4dERpdjpudWxsLGs9dGhpcy5ub2RlO2lmKG51bGwhPWcpe2cuc3R5bGUub3ZlcmZsb3c9IiI7Zy5zdHlsZS5oZWlnaHQ9IiI7Zy5zdHlsZS53aWR0aD0iIjt0aGlzLnVwZGF0ZUZvbnQoZyk7dGhpcy51cGRhdGVTaXplKGcsITEpO3RoaXMudXBkYXRlSW5uZXJIdG1sKGcpO3ZhciBsPU1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgvdGhpcy5zY2FsZSk7dGhpcy53cmFwJiYwPGw/KGcuc3R5bGUud2hpdGVTcGFjZT0ibm9ybWFsIixnLnN0eWxlLndvcmRXcmFwPW14Q29uc3RhbnRzLldPUkRfV1JBUCxlPWwsdGhpcy5jbGlwcGVkJiYKKGU9TWF0aC5taW4oZSx0aGlzLmJvdW5kcy53aWR0aCkpLGcuc3R5bGUud2lkdGg9ZSsicHgiKTpnLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7az1nO251bGwhPWsuZmlyc3RDaGlsZCYmIkRJViI9PWsuZmlyc3RDaGlsZC5ub2RlTmFtZSYmKGs9ay5maXJzdENoaWxkLHRoaXMud3JhcCYmImJyZWFrLXdvcmQiPT1nLnN0eWxlLndvcmRXcmFwJiYoay5zdHlsZS53aWR0aD0iMTAwJSIpKTshdGhpcy5jbGlwcGVkJiZ0aGlzLndyYXAmJjA8bCYmKGU9ay5vZmZzZXRXaWR0aCt0aGlzLnRleHRXaWR0aFBhZGRpbmcsZy5zdHlsZS53aWR0aD1lKyJweCIpO2Y9ay5vZmZzZXRIZWlnaHQrMjtteENsaWVudC5JU19RVUlSS1MmJm51bGwhPXRoaXMuYm9yZGVyJiZ0aGlzLmJvcmRlciE9bXhDb25zdGFudHMuTk9ORSYmKGYrPTMpfWVsc2UgbnVsbCE9ay5maXJzdENoaWxkJiYiRElWIj09ay5maXJzdENoaWxkLm5vZGVOYW1lJiYoaz1rLmZpcnN0Q2hpbGQsZj1rLm9mZnNldEhlaWdodCk7ZT1rLm9mZnNldFdpZHRoKwp0aGlzLnRleHRXaWR0aFBhZGRpbmc7dGhpcy5jbGlwcGVkJiYoZj1NYXRoLm1pbihmLHRoaXMuYm91bmRzLmhlaWdodCkpO2w9dGhpcy5ib3VuZHMud2lkdGgvZDtnPXRoaXMuYm91bmRzLmhlaWdodC9kOyJmaWxsIj09dGhpcy5vdmVyZmxvdz8oZj1nLGU9bCk6IndpZHRoIj09dGhpcy5vdmVyZmxvdyYmKGY9ay5zY3JvbGxIZWlnaHQsZT1sKTt0aGlzLm9mZnNldFdpZHRoPWU7dGhpcy5vZmZzZXRIZWlnaHQ9ZjtteENsaWVudC5JU19RVUlSS1MmJih0aGlzLmNsaXBwZWR8fCJ3aWR0aCI9PXRoaXMub3ZlcmZsb3cmJjA8Zyk/KGc9TWF0aC5taW4oZyxmKSxhLmhlaWdodD1NYXRoLnJvdW5kKGcpKyJweCIpOmc9ZjsiZmlsbCIhPXRoaXMub3ZlcmZsb3cmJiJ3aWR0aCIhPXRoaXMub3ZlcmZsb3cmJih0aGlzLmNsaXBwZWQmJihlPU1hdGgubWluKGwsZSkpLGw9ZSxteENsaWVudC5JU19RVUlSS1MmJnRoaXMuY2xpcHBlZHx8dGhpcy53cmFwKSYmKGEud2lkdGg9TWF0aC5yb3VuZChsKSsKInB4Iik7dmFyIGc9ZypkLGw9bCpkLG09dGhpcy5nZXRUZXh0Um90YXRpb24oKSooTWF0aC5QSS8xODApO2U9cGFyc2VGbG9hdChwYXJzZUZsb2F0KE1hdGguY29zKG0pKS50b0ZpeGVkKDgpKTtmPXBhcnNlRmxvYXQocGFyc2VGbG9hdChNYXRoLnNpbigtbSkpLnRvRml4ZWQoOCkpO20lPTIqTWF0aC5QSTswPm0mJihtKz0yKk1hdGguUEkpO20lPU1hdGguUEk7bT5NYXRoLlBJLzImJihtPU1hdGguUEktbSk7dmFyIGs9TWF0aC5jb3MobSksbj1NYXRoLnNpbigtbSksYj1sKi0oYisuNSkscD1nKi0oYysuNSk7MCE9bSYmKGM9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPSIrZSsiLCBNMTI9IitmKyIsIE0yMT0iKy1mKyIsIE0yMj0iK2UrIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpIixhLmZpbHRlcj1udWxsIT1hLmZpbHRlciYmMDxhLmZpbHRlci5sZW5ndGg/YS5maWx0ZXIrKCIgIitjKTpjKTtjPTA7ImZpbGwiIT10aGlzLm92ZXJmbG93JiYKbXhDbGllbnQuSVNfUVVJUktTJiYoYz10aGlzLnZhbGlnbj09bXhDb25zdGFudHMuQUxJR05fVE9QP2MtMTp0aGlzLnZhbGlnbj09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NP2MrMjpjKzEpO2Euem9vbT1kO2EubGVmdD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngrKChsLWwqaytnKm4pLzItZSpiLWYqcCktbC8yKSsicHgiO2EudG9wPU1hdGgucm91bmQodGhpcy5ib3VuZHMueSsoKGctZyprK2wqbikvMitmKmItZSpwKS1nLzIrYykrInB4In07Cm14VGV4dC5wcm90b3R5cGUudXBkYXRlVmFsdWU9ZnVuY3Rpb24oKXtpZihteFV0aWxzLmlzTm9kZSh0aGlzLnZhbHVlKSl0aGlzLm5vZGUuaW5uZXJIVE1MPSIiLHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLnZhbHVlKTtlbHNle3ZhciBhPXRoaXMudmFsdWU7dGhpcy5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwmJihhPW14VXRpbHMuaHRtbEVudGl0aWVzKGEsITEpKTt2YXIgYT1teFV0aWxzLnJlcGxhY2VUcmFpbGluZ05ld2xpbmVzKGEsIjxkaXY+PGJyPjwvZGl2PiIpLGE9dGhpcy5yZXBsYWNlTGluZWZlZWRzP2EucmVwbGFjZSgvXG4vZywiPGJyLz4iKTphLGI9bnVsbCE9dGhpcy5iYWNrZ3JvdW5kJiZ0aGlzLmJhY2tncm91bmQhPW14Q29uc3RhbnRzLk5PTkU/dGhpcy5iYWNrZ3JvdW5kOm51bGwsYz1udWxsIT10aGlzLmJvcmRlciYmdGhpcy5ib3JkZXIhPW14Q29uc3RhbnRzLk5PTkU/dGhpcy5ib3JkZXI6bnVsbDtpZigiZmlsbCI9PXRoaXMub3ZlcmZsb3d8fAoid2lkdGgiPT10aGlzLm92ZXJmbG93KW51bGwhPWImJih0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yPWIpLG51bGwhPWMmJih0aGlzLm5vZGUuc3R5bGUuYm9yZGVyPSIxcHggc29saWQgIitjKTtlbHNle3ZhciBkPSIiO251bGwhPWImJihkKz0iYmFja2dyb3VuZC1jb2xvcjoiK214VXRpbHMuaHRtbEVudGl0aWVzKGIpKyI7Iik7bnVsbCE9YyYmKGQrPSJib3JkZXI6MXB4IHNvbGlkICIrbXhVdGlscy5odG1sRW50aXRpZXMoYykrIjsiKTthPSc8ZGl2IHN0eWxlPSJ6b29tOjE7JytkKyJkaXNwbGF5OmlubGluZS1ibG9jaztfZGlzcGxheTppbmxpbmU7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7cGFkZGluZy1ib3R0b206MXB4O3BhZGRpbmctcmlnaHQ6MXB4O2xpbmUtaGVpZ2h0OiIrKG14Q29uc3RhbnRzLkFCU09MVVRFX0xJTkVfSEVJR0hUP3RoaXMuc2l6ZSpteENvbnN0YW50cy5MSU5FX0hFSUdIVCsicHgiOm14Q29uc3RhbnRzLkxJTkVfSEVJR0hUKSsnIj4nK2ErIjwvZGl2PiJ9dGhpcy5ub2RlLmlubmVySFRNTD0KYTthPXRoaXMubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2Iik7MDxhLmxlbmd0aCYmKGI9dGhpcy50ZXh0RGlyZWN0aW9uLGI9PW14Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX0FVVE8mJnRoaXMuZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MJiYoYj10aGlzLmdldEF1dG9EaXJlY3Rpb24oKSksYj09bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fTFRSfHxiPT1teENvbnN0YW50cy5URVhUX0RJUkVDVElPTl9SVEw/YVthLmxlbmd0aC0xXS5zZXRBdHRyaWJ1dGUoImRpciIsYik6YVthLmxlbmd0aC0xXS5yZW1vdmVBdHRyaWJ1dGUoImRpciIpKX19OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZUZvbnQ9ZnVuY3Rpb24oYSl7YT1hLnN0eWxlO2EubGluZUhlaWdodD1teENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD90aGlzLnNpemUqbXhDb25zdGFudHMuTElORV9IRUlHSFQrInB4IjpteENvbnN0YW50cy5MSU5FX0hFSUdIVDthLmZvbnRTaXplPXRoaXMuc2l6ZSsicHgiO2EuZm9udEZhbWlseT10aGlzLmZhbWlseTthLnZlcnRpY2FsQWxpZ249InRvcCI7YS5jb2xvcj10aGlzLmNvbG9yO2EuZm9udFdlaWdodD0odGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9CT0xEKT09bXhDb25zdGFudHMuRk9OVF9CT0xEPyJib2xkIjoiIjthLmZvbnRTdHlsZT0odGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9JVEFMSUMpPT1teENvbnN0YW50cy5GT05UX0lUQUxJQz8iaXRhbGljIjoiIjt2YXIgYj1bXTsodGhpcy5mb250U3R5bGUmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmCmIucHVzaCgidW5kZXJsaW5lIik7KHRoaXMuZm9udFN0eWxlJm14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCk9PW14Q29uc3RhbnRzLkZPTlRfU1RSSUtFVEhST1VHSCYmYi5wdXNoKCJsaW5lLXRocm91Z2giKTthLnRleHREZWNvcmF0aW9uPWIuam9pbigiICIpO2EudGV4dEFsaWduPXRoaXMuYWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj8iY2VudGVyIjp0aGlzLmFsaWduPT1teENvbnN0YW50cy5BTElHTl9SSUdIVD8icmlnaHQiOiJsZWZ0In07Cm14VGV4dC5wcm90b3R5cGUudXBkYXRlU2l6ZT1mdW5jdGlvbihhLGIpe3ZhciBjPU1hdGgubWF4KDAsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aC90aGlzLnNjYWxlKSksZD1NYXRoLm1heCgwLE1hdGgucm91bmQodGhpcy5ib3VuZHMuaGVpZ2h0L3RoaXMuc2NhbGUpKSxlPWEuc3R5bGU7dGhpcy5jbGlwcGVkPyhlLm92ZXJmbG93PSJoaWRkZW4iLG14Q2xpZW50LklTX1FVSVJLUz9lLndpZHRoPWMrInB4IjooZS5tYXhIZWlnaHQ9ZCsicHgiLGUubWF4V2lkdGg9YysicHgiKSk6ImZpbGwiPT10aGlzLm92ZXJmbG93PyhlLndpZHRoPWMrMSsicHgiLGUuaGVpZ2h0PWQrMSsicHgiLGUub3ZlcmZsb3c9ImhpZGRlbiIpOiJ3aWR0aCI9PXRoaXMub3ZlcmZsb3cmJihlLndpZHRoPWMrMSsicHgiLGUubWF4SGVpZ2h0PWQrMSsicHgiLGUub3ZlcmZsb3c9ImhpZGRlbiIpO2lmKHRoaXMud3JhcCYmMDxjKXtpZihlLndvcmRXcmFwPW14Q29uc3RhbnRzLldPUkRfV1JBUCxlLndoaXRlU3BhY2U9CiJub3JtYWwiLGUud2lkdGg9YysicHgiLGImJiJmaWxsIiE9dGhpcy5vdmVyZmxvdyYmIndpZHRoIiE9dGhpcy5vdmVyZmxvdyl7ZD1hO251bGwhPWQuZmlyc3RDaGlsZCYmIkRJViI9PWQuZmlyc3RDaGlsZC5ub2RlTmFtZSYmKGQ9ZC5maXJzdENoaWxkLCJicmVhay13b3JkIj09YS5zdHlsZS53b3JkV3JhcCYmKGQuc3R5bGUud2lkdGg9IjEwMCUiKSk7dmFyIGY9ZC5vZmZzZXRXaWR0aDtpZigwPT1mKXt2YXIgZz1hLnBhcmVudE5vZGU7YS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7Zj1kLm9mZnNldFdpZHRoO2Euc3R5bGUudmlzaWJpbGl0eT0iIjtnLmFwcGVuZENoaWxkKGEpfWYrPTM7dGhpcy5jbGlwcGVkJiYoZj1NYXRoLm1pbihmLGMpKTtlLndpZHRoPWYrInB4In19ZWxzZSBlLndoaXRlU3BhY2U9Im5vd3JhcCJ9OwpteFRleHQucHJvdG90eXBlLnVwZGF0ZU1hcmdpbj1mdW5jdGlvbigpe3RoaXMubWFyZ2luPW14VXRpbHMuZ2V0QWxpZ25tZW50QXNQb2ludCh0aGlzLmFsaWduLHRoaXMudmFsaWduKX07Cm14VGV4dC5wcm90b3R5cGUuZ2V0U3BhY2luZz1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQb2ludCh0aGlzLmFsaWduPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/KHRoaXMuc3BhY2luZ0xlZnQtdGhpcy5zcGFjaW5nUmlnaHQpLzI6dGhpcy5hbGlnbj09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/LXRoaXMuc3BhY2luZ1JpZ2h0LXRoaXMuYmFzZVNwYWNpbmdSaWdodDp0aGlzLnNwYWNpbmdMZWZ0K3RoaXMuYmFzZVNwYWNpbmdMZWZ0LHRoaXMudmFsaWduPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/KHRoaXMuc3BhY2luZ1RvcC10aGlzLnNwYWNpbmdCb3R0b20pLzI6dGhpcy52YWxpZ249PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT8tdGhpcy5zcGFjaW5nQm90dG9tLXRoaXMuYmFzZVNwYWNpbmdCb3R0b206dGhpcy5zcGFjaW5nVG9wK3RoaXMuYmFzZVNwYWNpbmdUb3ApfTtmdW5jdGlvbiBteFRyaWFuZ2xlKCl7bXhBY3Rvci5jYWxsKHRoaXMpfQpteFV0aWxzLmV4dGVuZChteFRyaWFuZ2xlLG14QWN0b3IpO214VHJpYW5nbGUucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O214VHJpYW5nbGUucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGMsZCxlKXtiPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludCgwLDApLG5ldyBteFBvaW50KGQsLjUqZSksbmV3IG14UG9pbnQoMCxlKV0sdGhpcy5pc1JvdW5kZWQsYiwhMCl9O2Z1bmN0aW9uIG14SGV4YWdvbigpe214QWN0b3IuY2FsbCh0aGlzKX1teFV0aWxzLmV4dGVuZChteEhleGFnb24sbXhBY3Rvcik7Cm14SGV4YWdvbi5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsYyxkLGUpe2I9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KC4yNSpkLDApLG5ldyBteFBvaW50KC43NSpkLDApLG5ldyBteFBvaW50KGQsLjUqZSksbmV3IG14UG9pbnQoLjc1KmQsZSksbmV3IG14UG9pbnQoLjI1KmQsZSksbmV3IG14UG9pbnQoMCwuNSplKV0sdGhpcy5pc1JvdW5kZWQsYiwhMCl9O2Z1bmN0aW9uIG14TGluZShhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLnN0cm9rZT1iO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9Yz9jOjE7dGhpcy52ZXJ0aWNhbD1udWxsIT1kP2Q6dGhpcy52ZXJ0aWNhbH1teFV0aWxzLmV4dGVuZChteExpbmUsbXhTaGFwZSk7bXhMaW5lLnByb3RvdHlwZS52ZXJ0aWNhbD0hMTsKbXhMaW5lLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7YS5iZWdpbigpO2lmKHRoaXMudmVydGljYWwpe3ZhciBmPWIrZC8yO2EubW92ZVRvKGYsYyk7YS5saW5lVG8oZixjK2UpfWVsc2UgZj1jK2UvMixhLm1vdmVUbyhiLGYpLGEubGluZVRvKGIrZCxmKTthLnN0cm9rZSgpfTtmdW5jdGlvbiBteEltYWdlU2hhcGUoYSxiLGMsZCxlKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmltYWdlPWI7dGhpcy5maWxsPWM7dGhpcy5zdHJva2U9ZDt0aGlzLnN0cm9rZXdpZHRoPW51bGwhPWU/ZToxO3RoaXMuc2hhZG93PSExfW14VXRpbHMuZXh0ZW5kKG14SW1hZ2VTaGFwZSxteFJlY3RhbmdsZVNoYXBlKTtteEltYWdlU2hhcGUucHJvdG90eXBlLnByZXNlcnZlSW1hZ2VBc3BlY3Q9ITA7bXhJbWFnZVNoYXBlLnByb3RvdHlwZS5nZXRTdmdTY3JlZW5PZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH07Cm14SW1hZ2VTaGFwZS5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7bXhTaGFwZS5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZ3JhZGllbnQ9dGhpcy5zdHJva2U9dGhpcy5maWxsPW51bGw7bnVsbCE9dGhpcy5zdHlsZSYmKHRoaXMucHJlc2VydmVJbWFnZUFzcGVjdD0xPT1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0FTUEVDVCwxKSx0aGlzLmZsaXBIPXRoaXMuZmxpcEh8fDE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiaW1hZ2VGbGlwSCIsMCksdGhpcy5mbGlwVj10aGlzLmZsaXBWfHwxPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImltYWdlRmxpcFYiLDApKX07bXhJbWFnZVNoYXBlLnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMucHJlc2VydmVJbWFnZUFzcGVjdH07Cm14SW1hZ2VTaGFwZS5wcm90b3R5cGUuY3JlYXRlSHRtbD1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtyZXR1cm4gYX07bXhJbWFnZVNoYXBlLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiExfTsKbXhJbWFnZVNoYXBlLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYobnVsbCE9dGhpcy5pbWFnZSl7dmFyIGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0JBQ0tHUk9VTkQsbnVsbCksZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfQk9SREVSLG51bGwpO251bGwhPWYmJihhLnNldEZpbGxDb2xvcihmKSxhLnNldFN0cm9rZUNvbG9yKGcpLGEucmVjdChiLGMsZCxlKSxhLmZpbGxBbmRTdHJva2UoKSk7YS5pbWFnZShiLGMsZCxlLHRoaXMuaW1hZ2UsdGhpcy5wcmVzZXJ2ZUltYWdlQXNwZWN0LCExLCExKTtnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9CT1JERVIsbnVsbCk7bnVsbCE9ZyYmKGEuc2V0U2hhZG93KCExKSxhLnNldFN0cm9rZUNvbG9yKGcpLGEucmVjdChiLGMsZCxlKSxhLnN0cm9rZSgpKX1lbHNlIG14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZC5hcHBseSh0aGlzLAphcmd1bWVudHMpfTsKbXhJbWFnZVNoYXBlLnByb3RvdHlwZS5yZWRyYXdIdG1sU2hhcGU9ZnVuY3Rpb24oKXt0aGlzLm5vZGUuc3R5bGUubGVmdD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLngpKyJweCI7dGhpcy5ub2RlLnN0eWxlLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkpKyJweCI7dGhpcy5ub2RlLnN0eWxlLndpZHRoPU1hdGgubWF4KDAsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aCkpKyJweCI7dGhpcy5ub2RlLnN0eWxlLmhlaWdodD1NYXRoLm1heCgwLE1hdGgucm91bmQodGhpcy5ib3VuZHMuaGVpZ2h0KSkrInB4Ijt0aGlzLm5vZGUuaW5uZXJIVE1MPSIiO2lmKG51bGwhPXRoaXMuaW1hZ2Upe3ZhciBhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9CQUNLR1JPVU5ELCIiKSxiPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9JTUFHRV9CT1JERVIsIiIpO3RoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9YTsKdGhpcy5ub2RlLnN0eWxlLmJvcmRlckNvbG9yPWI7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG14Q2xpZW50LklTX0lFNnx8KG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OD49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSYmMCE9dGhpcy5yb3RhdGlvbj9teENsaWVudC5WTUxfUFJFRklYKyI6aW1hZ2UiOiJpbWciKTthLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjthLnNyYz10aGlzLmltYWdlO2I9MTAwPnRoaXMub3BhY2l0eT8iYWxwaGEob3BhY2l0eT0iK3RoaXMub3BhY2l0eSsiKSI6IiI7dGhpcy5ub2RlLnN0eWxlLmZpbHRlcj1iO3RoaXMuZmxpcEgmJnRoaXMuZmxpcFY/Yis9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIpIjp0aGlzLmZsaXBIP2IrPSJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShtaXJyb3I9MSkiOnRoaXMuZmxpcFYmJgooYis9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIsIG1pcnJvcj0xKSIpO2Euc3R5bGUuZmlsdGVyIT1iJiYoYS5zdHlsZS5maWx0ZXI9Yik7ImltYWdlIj09YS5ub2RlTmFtZT9hLnN0eWxlLnJvdGF0aW9uPXRoaXMucm90YXRpb246MCE9dGhpcy5yb3RhdGlvbj9teFV0aWxzLnNldFByZWZpeGVkU3R5bGUoYS5zdHlsZSwidHJhbnNmb3JtIiwicm90YXRlKCIrdGhpcy5yb3RhdGlvbisiZGVnKSIpOm14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShhLnN0eWxlLCJ0cmFuc2Zvcm0iLCIiKTthLnN0eWxlLndpZHRoPXRoaXMubm9kZS5zdHlsZS53aWR0aDthLnN0eWxlLmhlaWdodD10aGlzLm5vZGUuc3R5bGUuaGVpZ2h0O3RoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9IiI7dGhpcy5ub2RlLmFwcGVuZENoaWxkKGEpfWVsc2UgdGhpcy5zZXRUcmFuc3BhcmVudEJhY2tncm91bmRJbWFnZSh0aGlzLm5vZGUpfTsKZnVuY3Rpb24gbXhMYWJlbChhLGIsYyxkKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyxhLGIsYyxkKX1teFV0aWxzLmV4dGVuZChteExhYmVsLG14UmVjdGFuZ2xlU2hhcGUpO214TGFiZWwucHJvdG90eXBlLmltYWdlU2l6ZT1teENvbnN0YW50cy5ERUZBVUxUX0lNQUdFU0laRTtteExhYmVsLnByb3RvdHlwZS5zcGFjaW5nPTI7bXhMYWJlbC5wcm90b3R5cGUuaW5kaWNhdG9yU2l6ZT0xMDtteExhYmVsLnByb3RvdHlwZS5pbmRpY2F0b3JTcGFjaW5nPTI7bXhMYWJlbC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhKXtteFNoYXBlLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT10aGlzLmluZGljYXRvclNoYXBlJiYodGhpcy5pbmRpY2F0b3I9bmV3IHRoaXMuaW5kaWNhdG9yU2hhcGUsdGhpcy5pbmRpY2F0b3IuZGlhbGVjdD10aGlzLmRpYWxlY3QsdGhpcy5pbmRpY2F0b3IuaW5pdCh0aGlzLm5vZGUpKX07Cm14TGFiZWwucHJvdG90eXBlLnJlZHJhdz1mdW5jdGlvbigpe251bGwhPXRoaXMuaW5kaWNhdG9yJiYodGhpcy5pbmRpY2F0b3IuZmlsbD10aGlzLmluZGljYXRvckNvbG9yLHRoaXMuaW5kaWNhdG9yLnN0cm9rZT10aGlzLmluZGljYXRvclN0cm9rZUNvbG9yLHRoaXMuaW5kaWNhdG9yLmdyYWRpZW50PXRoaXMuaW5kaWNhdG9yR3JhZGllbnRDb2xvcix0aGlzLmluZGljYXRvci5kaXJlY3Rpb249dGhpcy5pbmRpY2F0b3JEaXJlY3Rpb24sdGhpcy5pbmRpY2F0b3IucmVkcmF3KCkpO214U2hhcGUucHJvdG90eXBlLnJlZHJhdy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214TGFiZWwucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZC5hcHBseSh0aGlzLGFyZ3VtZW50cykmJm51bGw9PXRoaXMuaW5kaWNhdG9yQ29sb3ImJm51bGw9PXRoaXMuaW5kaWNhdG9yU2hhcGV9OwpteExhYmVsLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLnBhaW50SW1hZ2UoYSxiLGMsZCxlKTt0aGlzLnBhaW50SW5kaWNhdG9yKGEsYixjLGQsZSk7bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhMYWJlbC5wcm90b3R5cGUucGFpbnRJbWFnZT1mdW5jdGlvbihhLGIsYyxkLGUpe251bGwhPXRoaXMuaW1hZ2UmJihiPXRoaXMuZ2V0SW1hZ2VCb3VuZHMoYixjLGQsZSksYS5pbWFnZShiLngsYi55LGIud2lkdGgsYi5oZWlnaHQsdGhpcy5pbWFnZSwhMSwhMSwhMSkpfTsKbXhMYWJlbC5wcm90b3R5cGUuZ2V0SW1hZ2VCb3VuZHM9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX0xFRlQpLGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX1ZFUlRJQ0FMX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSksZz1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lNQUdFX1dJRFRILG14Q29uc3RhbnRzLkRFRkFVTFRfSU1BR0VTSVpFKSxrPW14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfSEVJR0hULG14Q29uc3RhbnRzLkRFRkFVTFRfSU1BR0VTSVpFKSxsPW14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lORyx0aGlzLnNwYWNpbmcpKzU7YT1lPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/CmErKGMtZykvMjplPT1teENvbnN0YW50cy5BTElHTl9SSUdIVD9hKyhjLWctbCk6YStsO2I9Zj09bXhDb25zdGFudHMuQUxJR05fVE9QP2IrbDpmPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/YisoZC1rLWwpOmIrKGQtaykvMjtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGEsYixnLGspfTtteExhYmVsLnByb3RvdHlwZS5wYWludEluZGljYXRvcj1mdW5jdGlvbihhLGIsYyxkLGUpe251bGwhPXRoaXMuaW5kaWNhdG9yPyh0aGlzLmluZGljYXRvci5ib3VuZHM9dGhpcy5nZXRJbmRpY2F0b3JCb3VuZHMoYixjLGQsZSksdGhpcy5pbmRpY2F0b3IucGFpbnQoYSkpOm51bGwhPXRoaXMuaW5kaWNhdG9ySW1hZ2UmJihiPXRoaXMuZ2V0SW5kaWNhdG9yQm91bmRzKGIsYyxkLGUpLGEuaW1hZ2UoYi54LGIueSxiLndpZHRoLGIuaGVpZ2h0LHRoaXMuaW5kaWNhdG9ySW1hZ2UsITEsITEsITEpKX07Cm14TGFiZWwucHJvdG90eXBlLmdldEluZGljYXRvckJvdW5kcz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTEVGVCksZj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfVkVSVElDQUxfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSxnPW14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfSU5ESUNBVE9SX1dJRFRILHRoaXMuaW5kaWNhdG9yU2l6ZSksaz1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0lORElDQVRPUl9IRUlHSFQsdGhpcy5pbmRpY2F0b3JTaXplKSxsPXRoaXMuc3BhY2luZys1O2E9ZT09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/YSsoYy1nLWwpOmU9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj9hKyhjLWcpLwoyOmErbDtiPWY9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT9iKyhkLWstbCk6Zj09bXhDb25zdGFudHMuQUxJR05fVE9QP2IrbDpiKyhkLWspLzI7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLGIsZyxrKX07Cm14TGFiZWwucHJvdG90eXBlLnJlZHJhd0h0bWxTaGFwZT1mdW5jdGlvbigpe2ZvcihteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5yZWRyYXdIdG1sU2hhcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCk7KXRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtpZihudWxsIT10aGlzLmltYWdlKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTthLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7YS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTt2YXIgYj10aGlzLmdldEltYWdlQm91bmRzKHRoaXMuYm91bmRzLngsdGhpcy5ib3VuZHMueSx0aGlzLmJvdW5kcy53aWR0aCx0aGlzLmJvdW5kcy5oZWlnaHQpO2IueC09dGhpcy5ib3VuZHMueDtiLnktPXRoaXMuYm91bmRzLnk7YS5zdHlsZS5sZWZ0PU1hdGgucm91bmQoYi54KSsicHgiO2Euc3R5bGUudG9wPU1hdGgucm91bmQoYi55KSsicHgiO2Euc3R5bGUud2lkdGg9Ck1hdGgucm91bmQoYi53aWR0aCkrInB4IjthLnN0eWxlLmhlaWdodD1NYXRoLnJvdW5kKGIuaGVpZ2h0KSsicHgiO2Euc3JjPXRoaXMuaW1hZ2U7dGhpcy5ub2RlLmFwcGVuZENoaWxkKGEpfX07ZnVuY3Rpb24gbXhDeWxpbmRlcihhLGIsYyxkKXtteFNoYXBlLmNhbGwodGhpcyk7dGhpcy5ib3VuZHM9YTt0aGlzLmZpbGw9Yjt0aGlzLnN0cm9rZT1jO3RoaXMuc3Ryb2tld2lkdGg9bnVsbCE9ZD9kOjF9bXhVdGlscy5leHRlbmQobXhDeWxpbmRlcixteFNoYXBlKTtteEN5bGluZGVyLnByb3RvdHlwZS5tYXhIZWlnaHQ9NDA7bXhDeWxpbmRlci5wcm90b3R5cGUuc3ZnU3Ryb2tlVG9sZXJhbmNlPTA7Cm14Q3lsaW5kZXIucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXthLnRyYW5zbGF0ZShiLGMpO2EuYmVnaW4oKTt0aGlzLnJlZHJhd1BhdGgoYSxiLGMsZCxlLCExKTthLmZpbGxBbmRTdHJva2UoKTt0aGlzLm91dGxpbmUmJm51bGwhPXRoaXMuc3R5bGUmJjAhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9CQUNLR1JPVU5EX09VVExJTkUsMCl8fChhLnNldFNoYWRvdyghMSksYS5iZWdpbigpLHRoaXMucmVkcmF3UGF0aChhLGIsYyxkLGUsITApLGEuc3Ryb2tlKCkpfTtteEN5bGluZGVyLnByb3RvdHlwZS5nZXRDeWxpbmRlclNpemU9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LE1hdGgucm91bmQoZC81KSl9OwpteEN5bGluZGVyLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtiPXRoaXMuZ2V0Q3lsaW5kZXJTaXplKGIsYyxkLGUpO2lmKGYmJm51bGwhPXRoaXMuZmlsbHx8IWYmJm51bGw9PXRoaXMuZmlsbClhLm1vdmVUbygwLGIpLGEuY3VydmVUbygwLDIqYixkLDIqYixkLGIpLGZ8fChhLnN0cm9rZSgpLGEuYmVnaW4oKSk7Znx8KGEubW92ZVRvKDAsYiksYS5jdXJ2ZVRvKDAsLWIvMyxkLC1iLzMsZCxiKSxhLmxpbmVUbyhkLGUtYiksYS5jdXJ2ZVRvKGQsZStiLzMsMCxlK2IvMywwLGUtYiksYS5jbG9zZSgpKX07ZnVuY3Rpb24gbXhDb25uZWN0b3IoYSxiLGMpe214UG9seWxpbmUuY2FsbCh0aGlzLGEsYixjKX1teFV0aWxzLmV4dGVuZChteENvbm5lY3RvcixteFBvbHlsaW5lKTsKbXhDb25uZWN0b3IucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nQm94PWZ1bmN0aW9uKCl7dGhpcy51c2VTdmdCb3VuZGluZ0JveD1udWxsIT10aGlzLnN0eWxlJiYxPT10aGlzLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0NVUlZFRF07bXhTaGFwZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdCb3guYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteENvbm5lY3Rvci5wcm90b3R5cGUucGFpbnRFZGdlU2hhcGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNyZWF0ZU1hcmtlcihhLGIsITApLGQ9dGhpcy5jcmVhdGVNYXJrZXIoYSxiLCExKTtteFBvbHlsaW5lLnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5zZXRGaWxsQ29sb3IodGhpcy5zdHJva2UpO2Euc2V0U2hhZG93KCExKTthLnNldERhc2hlZCghMSk7bnVsbCE9YyYmYygpO251bGwhPWQmJmQoKX07Cm14Q29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVNYXJrZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwsZT1iLmxlbmd0aCxmPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxjP214Q29uc3RhbnRzLlNUWUxFX1NUQVJUQVJST1c6bXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1cpLGc9Yz9iWzFdOmJbZS0yXSxrPWM/YlswXTpiW2UtMV07aWYobnVsbCE9ZiYmbnVsbCE9ZyYmbnVsbCE9ayl7Zm9yKGQ9MTtkPGUtMSYmMD09TWF0aC5yb3VuZChnLngtay54KSYmMD09TWF0aC5yb3VuZChnLnktay55KTspZz1jP2JbMStkXTpiW2UtMi1kXSxkKys7Yj1rLngtZy54O2U9ay55LWcueTtkPU1hdGgubWF4KDEsTWF0aC5zcXJ0KGIqYitlKmUpKTtnPWIvZDtiPWUvZDtlPW14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsYz9teENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkU6bXhDb25zdGFudHMuU1RZTEVfRU5EU0laRSxteENvbnN0YW50cy5ERUZBVUxUX01BUktFUlNJWkUpO2Q9bXhNYXJrZXIuY3JlYXRlTWFya2VyKGEsCnRoaXMsZixrLGcsYixlLGMsdGhpcy5zdHJva2V3aWR0aCwwIT10aGlzLnN0eWxlW2M/bXhDb25zdGFudHMuU1RZTEVfU1RBUlRGSUxMOm14Q29uc3RhbnRzLlNUWUxFX0VOREZJTExdKX1yZXR1cm4gZH07Cm14Q29ubmVjdG9yLnByb3RvdHlwZS5hdWdtZW50Qm91bmRpbmdCb3g9ZnVuY3Rpb24oYSl7bXhTaGFwZS5wcm90b3R5cGUuYXVnbWVudEJvdW5kaW5nQm94LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYj0wO214VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVEFSUk9XLG14Q29uc3RhbnRzLk5PTkUpIT1teENvbnN0YW50cy5OT05FJiYoYj1teFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5ERUZBVUxUX01BUktFUlNJWkUpKzEpO214VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FTkRBUlJPVyxteENvbnN0YW50cy5OT05FKSE9bXhDb25zdGFudHMuTk9ORSYmKGI9TWF0aC5tYXgoYixteFV0aWxzLmdldE51bWJlcih0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0VORFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9NQVJLRVJTSVpFKSkrCjEpO2EuZ3JvdyhiKnRoaXMuc2NhbGUpfTtmdW5jdGlvbiBteFN3aW1sYW5lKGEsYixjLGQpe214U2hhcGUuY2FsbCh0aGlzKTt0aGlzLmJvdW5kcz1hO3RoaXMuZmlsbD1iO3RoaXMuc3Ryb2tlPWM7dGhpcy5zdHJva2V3aWR0aD1udWxsIT1kP2Q6MX1teFV0aWxzLmV4dGVuZChteFN3aW1sYW5lLG14U2hhcGUpO214U3dpbWxhbmUucHJvdG90eXBlLmltYWdlU2l6ZT0xNjtteFN3aW1sYW5lLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiEwfTtteFN3aW1sYW5lLnByb3RvdHlwZS5nZXRUaXRsZVNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgoMCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfU1RBUlRTSVpFKSl9OwpteFN3aW1sYW5lLnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldFRpdGxlU2l6ZSgpO2E9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksYS53aWR0aCxhLmhlaWdodCk7dmFyIGM9dGhpcy5pc0hvcml6b250YWwoKSxkPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GTElQSCwwKSxlPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GTElQViwwKSxmPXRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgsYz1jPT0hZixkPSFjJiZkIT0odGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSxlPWMmJmUhPSh0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfHwKdGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKTtpZihmKXtiPU1hdGgubWluKGEud2lkdGgsYip0aGlzLnNjYWxlKTtpZihkfHxlKWEueCs9YS53aWR0aC1iO2Eud2lkdGg9Yn1lbHNle2I9TWF0aC5taW4oYS5oZWlnaHQsYip0aGlzLnNjYWxlKTtpZihkfHxlKWEueSs9YS5oZWlnaHQtYjthLmhlaWdodD1ifXJldHVybiBhfTtteFN3aW1sYW5lLnByb3RvdHlwZS5nZXRHcmFkaWVudEJvdW5kcz1mdW5jdGlvbihhLGIsYyxkLGUpe2E9dGhpcy5nZXRUaXRsZVNpemUoKTtpZih0aGlzLmlzSG9yaXpvbnRhbCgpKXJldHVybiBhPU1hdGgubWluKGEsZSksbmV3IG14UmVjdGFuZ2xlKGIsYyxkLGEpO2E9TWF0aC5taW4oYSxkKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGIsYyxhLGUpfTsKbXhTd2ltbGFuZS5wcm90b3R5cGUuZ2V0QXJjU2l6ZT1mdW5jdGlvbihhLGIsYyl7aWYoIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUJTT0xVVEVfQVJDU0laRSwwKSlyZXR1cm4gTWF0aC5taW4oYS8yLE1hdGgubWluKGIvMixteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzIpKTthPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLDEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKS8xMDA7cmV0dXJuIGMqYSozfTtteFN3aW1sYW5lLnByb3RvdHlwZS5pc0hvcml6b250YWw9ZnVuY3Rpb24oKXtyZXR1cm4gMT09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsMSl9OwpteFN3aW1sYW5lLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5nZXRUaXRsZVNpemUoKSxnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TV0lNTEFORV9GSUxMQ09MT1IsbXhDb25zdGFudHMuTk9ORSksaz0xPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1dJTUxBTkVfTElORSwxKSxsPTAsZj10aGlzLmlzSG9yaXpvbnRhbCgpP01hdGgubWluKGYsZSk6TWF0aC5taW4oZixkKTthLnRyYW5zbGF0ZShiLGMpO3RoaXMuaXNSb3VuZGVkPyhsPXRoaXMuZ2V0QXJjU2l6ZShkLGUsZiksbD1NYXRoLm1pbigodGhpcy5pc0hvcml6b250YWwoKT9lOmQpLWYsTWF0aC5taW4oZixsKSksdGhpcy5wYWludFJvdW5kZWRTd2ltbGFuZShhLGIsYyxkLGUsZixsLGcsaykpOnRoaXMucGFpbnRTd2ltbGFuZShhLGIsYyxkLGUsZixnLGspO2c9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9TRVBBUkFUT1JDT0xPUixteENvbnN0YW50cy5OT05FKTt0aGlzLnBhaW50U2VwYXJhdG9yKGEsYixjLGQsZSxmLGcpO251bGwhPXRoaXMuaW1hZ2UmJihlPXRoaXMuZ2V0SW1hZ2VCb3VuZHMoYixjLGQsZSksYS5pbWFnZShlLngtYixlLnktYyxlLndpZHRoLGUuaGVpZ2h0LHRoaXMuaW1hZ2UsITEsITEsITEpKTt0aGlzLmdsYXNzJiYoYS5zZXRTaGFkb3coITEpLHRoaXMucGFpbnRHbGFzc0VmZmVjdChhLDAsMCxkLGYsbCkpfTsKbXhTd2ltbGFuZS5wcm90b3R5cGUucGFpbnRTd2ltbGFuZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2EuYmVnaW4oKTt2YXIgbD0hMDtudWxsIT10aGlzLnN0eWxlJiYobD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT0lOVEVSX0VWRU5UUywiMSIpKTtsfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORXx8KGEucG9pbnRlckV2ZW50cz0hMSk7dGhpcy5pc0hvcml6b250YWwoKT8oYS5tb3ZlVG8oMCxmKSxhLmxpbmVUbygwLDApLGEubGluZVRvKGQsMCksYS5saW5lVG8oZCxmKSxhLmZpbGxBbmRTdHJva2UoKSxmPGUmJihnIT1teENvbnN0YW50cy5OT05FJiZsfHwoYS5wb2ludGVyRXZlbnRzPSExKSxnIT1teENvbnN0YW50cy5OT05FJiZhLnNldEZpbGxDb2xvcihnKSxhLmJlZ2luKCksYS5tb3ZlVG8oMCxmKSxhLmxpbmVUbygwLGUpLGEubGluZVRvKGQsZSksYS5saW5lVG8oZCxmKSxnPT1teENvbnN0YW50cy5OT05FPwphLnN0cm9rZSgpOmEuZmlsbEFuZFN0cm9rZSgpKSk6KGEubW92ZVRvKGYsMCksYS5saW5lVG8oMCwwKSxhLmxpbmVUbygwLGUpLGEubGluZVRvKGYsZSksYS5maWxsQW5kU3Ryb2tlKCksZjxkJiYoZyE9bXhDb25zdGFudHMuTk9ORSYmbHx8KGEucG9pbnRlckV2ZW50cz0hMSksZyE9bXhDb25zdGFudHMuTk9ORSYmYS5zZXRGaWxsQ29sb3IoZyksYS5iZWdpbigpLGEubW92ZVRvKGYsMCksYS5saW5lVG8oZCwwKSxhLmxpbmVUbyhkLGUpLGEubGluZVRvKGYsZSksZz09bXhDb25zdGFudHMuTk9ORT9hLnN0cm9rZSgpOmEuZmlsbEFuZFN0cm9rZSgpKSk7ayYmdGhpcy5wYWludERpdmlkZXIoYSxiLGMsZCxlLGYsZz09bXhDb25zdGFudHMuTk9ORSl9OwpteFN3aW1sYW5lLnByb3RvdHlwZS5wYWludFJvdW5kZWRTd2ltbGFuZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCl7YS5iZWdpbigpO3ZhciBtPSEwO251bGwhPXRoaXMuc3R5bGUmJihtPSIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1BPSU5URVJfRVZFTlRTLCIxIikpO218fG51bGwhPXRoaXMuZmlsbCYmdGhpcy5maWxsIT1teENvbnN0YW50cy5OT05FfHwoYS5wb2ludGVyRXZlbnRzPSExKTt0aGlzLmlzSG9yaXpvbnRhbCgpPyhhLm1vdmVUbyhkLGYpLGEubGluZVRvKGQsZyksYS5xdWFkVG8oZCwwLGQtTWF0aC5taW4oZC8yLGcpLDApLGEubGluZVRvKE1hdGgubWluKGQvMixnKSwwKSxhLnF1YWRUbygwLDAsMCxnKSxhLmxpbmVUbygwLGYpLGEuZmlsbEFuZFN0cm9rZSgpLGY8ZSYmKGshPW14Q29uc3RhbnRzLk5PTkUmJm18fChhLnBvaW50ZXJFdmVudHM9ITEpLGshPW14Q29uc3RhbnRzLk5PTkUmJmEuc2V0RmlsbENvbG9yKGspLAphLmJlZ2luKCksYS5tb3ZlVG8oMCxmKSxhLmxpbmVUbygwLGUtZyksYS5xdWFkVG8oMCxlLE1hdGgubWluKGQvMixnKSxlKSxhLmxpbmVUbyhkLU1hdGgubWluKGQvMixnKSxlKSxhLnF1YWRUbyhkLGUsZCxlLWcpLGEubGluZVRvKGQsZiksaz09bXhDb25zdGFudHMuTk9ORT9hLnN0cm9rZSgpOmEuZmlsbEFuZFN0cm9rZSgpKSk6KGEubW92ZVRvKGYsMCksYS5saW5lVG8oZywwKSxhLnF1YWRUbygwLDAsMCxNYXRoLm1pbihlLzIsZykpLGEubGluZVRvKDAsZS1NYXRoLm1pbihlLzIsZykpLGEucXVhZFRvKDAsZSxnLGUpLGEubGluZVRvKGYsZSksYS5maWxsQW5kU3Ryb2tlKCksZjxkJiYoayE9bXhDb25zdGFudHMuTk9ORSYmbXx8KGEucG9pbnRlckV2ZW50cz0hMSksayE9bXhDb25zdGFudHMuTk9ORSYmYS5zZXRGaWxsQ29sb3IoayksYS5iZWdpbigpLGEubW92ZVRvKGYsZSksYS5saW5lVG8oZC1nLGUpLGEucXVhZFRvKGQsZSxkLGUtTWF0aC5taW4oZS8yLGcpKSxhLmxpbmVUbyhkLApNYXRoLm1pbihlLzIsZykpLGEucXVhZFRvKGQsMCxkLWcsMCksYS5saW5lVG8oZiwwKSxrPT1teENvbnN0YW50cy5OT05FP2Euc3Ryb2tlKCk6YS5maWxsQW5kU3Ryb2tlKCkpKTtsJiZ0aGlzLnBhaW50RGl2aWRlcihhLGIsYyxkLGUsZixrPT1teENvbnN0YW50cy5OT05FKX07bXhTd2ltbGFuZS5wcm90b3R5cGUucGFpbnREaXZpZGVyPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2d8fGEuc2V0U2hhZG93KCExKTthLmJlZ2luKCk7dGhpcy5pc0hvcml6b250YWwoKT8oYS5tb3ZlVG8oMCxmKSxhLmxpbmVUbyhkLGYpKTooYS5tb3ZlVG8oZiwwKSxhLmxpbmVUbyhmLGUpKTthLnN0cm9rZSgpfTsKbXhTd2ltbGFuZS5wcm90b3R5cGUucGFpbnRTZXBhcmF0b3I9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7ZyE9bXhDb25zdGFudHMuTk9ORSYmKGEuc2V0U3Ryb2tlQ29sb3IoZyksYS5zZXREYXNoZWQoITApLGEuYmVnaW4oKSx0aGlzLmlzSG9yaXpvbnRhbCgpPyhhLm1vdmVUbyhkLGYpLGEubGluZVRvKGQsZSkpOihhLm1vdmVUbyhmLDApLGEubGluZVRvKGQsMCkpLGEuc3Ryb2tlKCksYS5zZXREYXNoZWQoITEpKX07bXhTd2ltbGFuZS5wcm90b3R5cGUuZ2V0SW1hZ2VCb3VuZHM9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKCk/bmV3IG14UmVjdGFuZ2xlKGErYy10aGlzLmltYWdlU2l6ZSxiLHRoaXMuaW1hZ2VTaXplLHRoaXMuaW1hZ2VTaXplKTpuZXcgbXhSZWN0YW5nbGUoYSxiLHRoaXMuaW1hZ2VTaXplLHRoaXMuaW1hZ2VTaXplKX07ZnVuY3Rpb24gbXhHcmFwaExheW91dChhKXt0aGlzLmdyYXBoPWF9Cm14R3JhcGhMYXlvdXQucHJvdG90eXBlLmdyYXBoPW51bGw7bXhHcmFwaExheW91dC5wcm90b3R5cGUudXNlQm91bmRpbmdCb3g9ITA7bXhHcmFwaExheW91dC5wcm90b3R5cGUucGFyZW50PW51bGw7bXhHcmFwaExheW91dC5wcm90b3R5cGUubW92ZUNlbGw9ZnVuY3Rpb24oYSxiLGMpe307bXhHcmFwaExheW91dC5wcm90b3R5cGUucmVzaXplQ2VsbD1mdW5jdGlvbihhLGIpe307bXhHcmFwaExheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt9O214R3JhcGhMYXlvdXQucHJvdG90eXBlLmdldEdyYXBoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGh9O214R3JhcGhMYXlvdXQucHJvdG90eXBlLmdldENvbnN0cmFpbnQ9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuZ3JhcGguZ2V0Q3VycmVudENlbGxTdHlsZShiKVthXX07Cm14R3JhcGhMYXlvdXQudHJhdmVyc2U9ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihudWxsIT1jJiZudWxsIT1hJiYoYj1udWxsIT1iP2I6ITAsZT1lfHxuZXcgbXhEaWN0aW9uYXJ5LCFlLmdldChhKSYmKGUucHV0KGEsITApLGQ9YyhhLGQpLG51bGw9PWR8fGQpKSYmKGQ9dGhpcy5ncmFwaC5tb2RlbC5nZXRFZGdlQ291bnQoYSksMDxkKSlmb3IodmFyIGY9MDtmPGQ7ZisrKXt2YXIgZz10aGlzLmdyYXBoLm1vZGVsLmdldEVkZ2VBdChhLGYpLGs9dGhpcy5ncmFwaC5tb2RlbC5nZXRUZXJtaW5hbChnLCEwKT09YTtpZighYnx8aylrPXRoaXMuZ3JhcGgudmlldy5nZXRWaXNpYmxlVGVybWluYWwoZywhayksdGhpcy50cmF2ZXJzZShrLGIsYyxnLGUpfX07Cm14R3JhcGhMYXlvdXQucHJvdG90eXBlLmlzQW5jZXN0b3I9ZnVuY3Rpb24oYSxiLGMpe2lmKCFjKXJldHVybiB0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChiKT09YTtpZihiPT1hKXJldHVybiExO2Zvcig7bnVsbCE9YiYmYiE9YTspYj10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChiKTtyZXR1cm4gYj09YX07bXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNWZXJ0ZXhNb3ZhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUoYSl9O214R3JhcGhMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpfHwhdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGEpfTsKbXhHcmFwaExheW91dC5wcm90b3R5cGUuaXNFZGdlSWdub3JlZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCk7cmV0dXJuIWIuaXNFZGdlKGEpfHwhdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGEpfHxudWxsPT1iLmdldFRlcm1pbmFsKGEsITApfHxudWxsPT1iLmdldFRlcm1pbmFsKGEsITEpfTtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRFZGdlU3R5bGVFbmFibGVkPWZ1bmN0aW9uKGEsYil7dGhpcy5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX05PRURHRVNUWUxFLGI/IjAiOiIxIixbYV0pfTtteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRPcnRob2dvbmFsRWRnZT1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9PUlRIT0dPTkFMLGI/IjEiOiIwIixbYV0pfTsKbXhHcmFwaExheW91dC5wcm90b3R5cGUuZ2V0UGFyZW50T2Zmc2V0PWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBteFBvaW50O2lmKG51bGwhPWEmJmEhPXRoaXMucGFyZW50KXt2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCk7aWYoYy5pc0FuY2VzdG9yKHRoaXMucGFyZW50LGEpKWZvcih2YXIgZD1jLmdldEdlb21ldHJ5KGEpO2EhPXRoaXMucGFyZW50OyliLngrPWQueCxiLnkrPWQueSxhPWMuZ2V0UGFyZW50KGEpLGQ9Yy5nZXRHZW9tZXRyeShhKX1yZXR1cm4gYn07Cm14R3JhcGhMYXlvdXQucHJvdG90eXBlLnNldEVkZ2VQb2ludHM9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXt2YXIgYz10aGlzLmdyYXBoLm1vZGVsLGQ9Yy5nZXRHZW9tZXRyeShhKTtudWxsPT1kPyhkPW5ldyBteEdlb21ldHJ5LGQuc2V0UmVsYXRpdmUoITApKTpkPWQuY2xvbmUoKTtpZihudWxsIT10aGlzLnBhcmVudCYmbnVsbCE9Yilmb3IodmFyIGU9Yy5nZXRQYXJlbnQoYSksZT10aGlzLmdldFBhcmVudE9mZnNldChlKSxmPTA7ZjxiLmxlbmd0aDtmKyspYltmXS54LT1lLngsYltmXS55LT1lLnk7ZC5wb2ludHM9YjtjLnNldEdlb21ldHJ5KGEsZCl9fTsKbXhHcmFwaExheW91dC5wcm90b3R5cGUuc2V0VmVydGV4TG9jYXRpb249ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0R2VvbWV0cnkoYSksZj1udWxsO2lmKG51bGwhPWUpe2Y9bmV3IG14UmVjdGFuZ2xlKGIsYyxlLndpZHRoLGUuaGVpZ2h0KTtpZih0aGlzLnVzZUJvdW5kaW5nQm94KXt2YXIgZz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZShhKTtpZihudWxsIT1nJiZudWxsIT1nLnRleHQmJm51bGwhPWcudGV4dC5ib3VuZGluZ0JveCl7dmFyIGs9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsbD1nLnRleHQuYm91bmRpbmdCb3g7Zy50ZXh0LmJvdW5kaW5nQm94Lng8Zy54JiYoYis9KGcueC1sLngpL2ssZi53aWR0aD1sLndpZHRoKTtnLnRleHQuYm91bmRpbmdCb3gueTxnLnkmJihjKz0oZy55LWwueSkvayxmLmhlaWdodD1sLmhlaWdodCl9fW51bGwhPXRoaXMucGFyZW50JiYoZz1kLmdldFBhcmVudChhKSxudWxsIT1nJiZnIT0KdGhpcy5wYXJlbnQmJihnPXRoaXMuZ2V0UGFyZW50T2Zmc2V0KGcpLGItPWcueCxjLT1nLnkpKTtpZihlLnghPWJ8fGUueSE9YyllPWUuY2xvbmUoKSxlLng9YixlLnk9YyxkLnNldEdlb21ldHJ5KGEsZSl9cmV0dXJuIGZ9OwpteEdyYXBoTGF5b3V0LnByb3RvdHlwZS5nZXRWZXJ0ZXhCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KGEpO2lmKHRoaXMudXNlQm91bmRpbmdCb3gpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGEpO2lmKG51bGwhPWMmJm51bGwhPWMudGV4dCYmbnVsbCE9Yy50ZXh0LmJvdW5kaW5nQm94KXZhciBkPXRoaXMuZ3JhcGguZ2V0VmlldygpLnNjYWxlLGU9Yy50ZXh0LmJvdW5kaW5nQm94LGY9TWF0aC5tYXgoYy54LWUueCwwKS9kLGc9TWF0aC5tYXgoYy55LWUueSwwKS9kLGI9bmV3IG14UmVjdGFuZ2xlKGIueC1mLGIueS1nLGIud2lkdGgrZitNYXRoLm1heChlLngrZS53aWR0aC0oYy54K2Mud2lkdGgpLDApL2QsYi5oZWlnaHQrZytNYXRoLm1heChlLnkrZS5oZWlnaHQtKGMueStjLmhlaWdodCksMCkvZCl9bnVsbCE9dGhpcy5wYXJlbnQmJihhPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYSksCmI9Yi5jbG9uZSgpLG51bGwhPWEmJmEhPXRoaXMucGFyZW50JiYoYT10aGlzLmdldFBhcmVudE9mZnNldChhKSxiLngrPWEueCxiLnkrPWEueSkpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYi54LGIueSxiLndpZHRoLGIuaGVpZ2h0KX07bXhHcmFwaExheW91dC5wcm90b3R5cGUuYXJyYW5nZUdyb3Vwcz1mdW5jdGlvbihhLGIsYyxkLGUsZil7cmV0dXJuIHRoaXMuZ3JhcGgudXBkYXRlR3JvdXBCb3VuZHMoYSxiLCEwLGMsZCxlLGYpfTtmdW5jdGlvbiBXZWlnaHRlZENlbGxTb3J0ZXIoYSxiKXt0aGlzLmNlbGw9YTt0aGlzLndlaWdodGVkVmFsdWU9Yn1XZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLndlaWdodGVkVmFsdWU9MDtXZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLm51ZGdlPSExO1dlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUudmlzaXRlZD0hMTtXZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLnJhbmtJbmRleD1udWxsOwpXZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLmNlbGw9bnVsbDtXZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9Yj9iLndlaWdodGVkVmFsdWU+YS53ZWlnaHRlZFZhbHVlPy0xOmIud2VpZ2h0ZWRWYWx1ZTxhLndlaWdodGVkVmFsdWU/MTpiLm51ZGdlPy0xOjE6MH07ZnVuY3Rpb24gbXhTdGFja0xheW91dChhLGIsYyxkLGUsZil7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSk7dGhpcy5ob3Jpem9udGFsPW51bGwhPWI/YjohMDt0aGlzLnNwYWNpbmc9bnVsbCE9Yz9jOjA7dGhpcy54MD1udWxsIT1kP2Q6MDt0aGlzLnkwPW51bGwhPWU/ZTowO3RoaXMuYm9yZGVyPW51bGwhPWY/ZjowfW14U3RhY2tMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0O214U3RhY2tMYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14U3RhY2tMYXlvdXQ7Cm14U3RhY2tMYXlvdXQucHJvdG90eXBlLmhvcml6b250YWw9bnVsbDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5zcGFjaW5nPW51bGw7bXhTdGFja0xheW91dC5wcm90b3R5cGUueDA9bnVsbDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS55MD1udWxsO214U3RhY2tMYXlvdXQucHJvdG90eXBlLmJvcmRlcj0wO214U3RhY2tMYXlvdXQucHJvdG90eXBlLm1hcmdpblRvcD0wO214U3RhY2tMYXlvdXQucHJvdG90eXBlLm1hcmdpbkxlZnQ9MDtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5tYXJnaW5SaWdodD0wO214U3RhY2tMYXlvdXQucHJvdG90eXBlLm1hcmdpbkJvdHRvbT0wO214U3RhY2tMYXlvdXQucHJvdG90eXBlLmtlZXBGaXJzdExvY2F0aW9uPSExO214U3RhY2tMYXlvdXQucHJvdG90eXBlLmZpbGw9ITE7bXhTdGFja0xheW91dC5wcm90b3R5cGUucmVzaXplUGFyZW50PSExO214U3RhY2tMYXlvdXQucHJvdG90eXBlLnJlc2l6ZVBhcmVudE1heD0hMTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUucmVzaXplTGFzdD0hMTtteFN0YWNrTGF5b3V0LnByb3RvdHlwZS53cmFwPW51bGw7bXhTdGFja0xheW91dC5wcm90b3R5cGUuYm9yZGVyQ29sbGFwc2U9ITA7bXhTdGFja0xheW91dC5wcm90b3R5cGUuYWxsb3dHYXBzPSExO214U3RhY2tMYXlvdXQucHJvdG90eXBlLmdyaWRTaXplPTA7bXhTdGFja0xheW91dC5wcm90b3R5cGUuaXNIb3Jpem9udGFsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaG9yaXpvbnRhbH07Cm14U3RhY2tMYXlvdXQucHJvdG90eXBlLm1vdmVDZWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1kLmdldFBhcmVudChhKSxmPXRoaXMuaXNIb3Jpem9udGFsKCk7aWYobnVsbCE9YSYmbnVsbCE9ZSl7dmFyIGc9MCxrPWQuZ2V0Q2hpbGRDb3VudChlKTtjPWY/YjpjO2I9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUoZSk7bnVsbCE9YiYmKGMtPWY/Yi54OmIueSk7Yy89dGhpcy5ncmFwaC52aWV3LnNjYWxlO2ZvcihiPTA7YjxrO2IrKyl7dmFyIGw9ZC5nZXRDaGlsZEF0KGUsYik7aWYobCE9YSYmKGw9ZC5nZXRHZW9tZXRyeShsKSxudWxsIT1sKSl7bD1mP2wueCtsLndpZHRoLzI6bC55K2wuaGVpZ2h0LzI7aWYoZzw9YyYmbD5jKWJyZWFrO2c9bH19Zj1lLmdldEluZGV4KGEpO2Y9TWF0aC5tYXgoMCxiLShiPmY/MTowKSk7ZC5hZGQoZSxhLGYpfX07Cm14U3RhY2tMYXlvdXQucHJvdG90eXBlLmdldFBhcmVudFNpemU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9Yi5nZXRHZW9tZXRyeShhKTtudWxsIT10aGlzLmdyYXBoLmNvbnRhaW5lciYmKG51bGw9PWMmJmIuaXNMYXllcihhKXx8YT09dGhpcy5ncmFwaC5nZXRWaWV3KCkuY3VycmVudFJvb3QpJiYoYz1uZXcgbXhSZWN0YW5nbGUoMCwwLHRoaXMuZ3JhcGguY29udGFpbmVyLm9mZnNldFdpZHRoLTEsdGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0SGVpZ2h0LTEpKTtyZXR1cm4gY307Cm14U3RhY2tMYXlvdXQucHJvdG90eXBlLmdldExheW91dENlbGxzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCksYz1iLmdldENoaWxkQ291bnQoYSksZD1bXSxlPTA7ZTxjO2UrKyl7dmFyIGY9Yi5nZXRDaGlsZEF0KGEsZSk7IXRoaXMuaXNWZXJ0ZXhJZ25vcmVkKGYpJiZ0aGlzLmlzVmVydGV4TW92YWJsZShmKSYmZC5wdXNoKGYpfXRoaXMuYWxsb3dHYXBzJiZkLnNvcnQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKSxkPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGIpO3JldHVybiBjLnk9PWQueT8wOmMueT5kLnk+MD8xOi0xfSkpO3JldHVybiBkfTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUuc25hcD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmdyaWRTaXplJiYwPHRoaXMuZ3JpZFNpemUmJihhPU1hdGgubWF4KGEsdGhpcy5ncmlkU2l6ZSksMTxhL3RoaXMuZ3JpZFNpemUpKXt2YXIgYj1hJXRoaXMuZ3JpZFNpemU7YSs9Yj50aGlzLmdyaWRTaXplLzI/dGhpcy5ncmlkU2l6ZS1iOi1ifXJldHVybiBhfTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj10aGlzLmdldFBhcmVudFNpemUoYSksYz10aGlzLmlzSG9yaXpvbnRhbCgpLGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGU9bnVsbDtudWxsIT1iJiYoZT1jP2IuaGVpZ2h0LXRoaXMubWFyZ2luVG9wLXRoaXMubWFyZ2luQm90dG9tOmIud2lkdGgtdGhpcy5tYXJnaW5MZWZ0LXRoaXMubWFyZ2luUmlnaHQpO3ZhciBlPWUtMip0aGlzLmJvcmRlcixmPXRoaXMueDArdGhpcy5ib3JkZXIrdGhpcy5tYXJnaW5MZWZ0LGc9dGhpcy55MCt0aGlzLmJvcmRlcit0aGlzLm1hcmdpblRvcDtpZih0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYSkpe3ZhciBrPXRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGEpLGw9bXhVdGlscy5nZXROdW1iZXIoayxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9TVEFSVFNJWkUpLGs9MT09bXhVdGlscy5nZXRWYWx1ZShrLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsCiEwKTtudWxsIT1iJiYobD1rP01hdGgubWluKGwsYi5oZWlnaHQpOk1hdGgubWluKGwsYi53aWR0aCkpO2M9PWsmJihlLT1sKTtrP2crPWw6Zis9bH1kLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgbD0wLGs9bnVsbCxtPTAsbj1udWxsLHA9dGhpcy5nZXRMYXlvdXRDZWxscyhhKSxxPTA7cTxwLmxlbmd0aDtxKyspe3ZhciByPXBbcV0sdD1kLmdldEdlb21ldHJ5KHIpO2lmKG51bGwhPXQpe3Q9dC5jbG9uZSgpO251bGwhPXRoaXMud3JhcCYmbnVsbCE9ayYmKGMmJmsueCtrLndpZHRoK3Qud2lkdGgrMip0aGlzLnNwYWNpbmc+dGhpcy53cmFwfHwhYyYmay55K2suaGVpZ2h0K3QuaGVpZ2h0KzIqdGhpcy5zcGFjaW5nPnRoaXMud3JhcCkmJihrPW51bGwsYz9nKz1sK3RoaXMuc3BhY2luZzpmKz1sK3RoaXMuc3BhY2luZyxsPTApO3ZhciBsPU1hdGgubWF4KGwsYz90LmhlaWdodDp0LndpZHRoKSx1PTA7aWYoIXRoaXMuYm9yZGVyQ29sbGFwc2UpdmFyIHg9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUociksCnU9bXhVdGlscy5nZXROdW1iZXIoeCxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VXSURUSCwxKTtpZihudWxsIT1rKXt2YXIgeT1tK3RoaXMuc3BhY2luZytNYXRoLmZsb29yKHUvMik7Yz90Lng9dGhpcy5zbmFwKCh0aGlzLmFsbG93R2Fwcz9NYXRoLm1heCh5LHQueCk6eSktdGhpcy5tYXJnaW5MZWZ0KSt0aGlzLm1hcmdpbkxlZnQ6dC55PXRoaXMuc25hcCgodGhpcy5hbGxvd0dhcHM/TWF0aC5tYXgoeSx0LnkpOnkpLXRoaXMubWFyZ2luVG9wKSt0aGlzLm1hcmdpblRvcH1lbHNlIHRoaXMua2VlcEZpcnN0TG9jYXRpb258fChjP3QueD10aGlzLmFsbG93R2FwcyYmdC54PmY/TWF0aC5tYXgodGhpcy5zbmFwKHQueC10aGlzLm1hcmdpbkxlZnQpK3RoaXMubWFyZ2luTGVmdCxmKTpmOnQueT10aGlzLmFsbG93R2FwcyYmdC55Pmc/TWF0aC5tYXgodGhpcy5zbmFwKHQueS10aGlzLm1hcmdpblRvcCkrdGhpcy5tYXJnaW5Ub3AsZyk6Zyk7Yz90Lnk9Zzp0Lng9Zjt0aGlzLmZpbGwmJm51bGwhPQplJiYoYz90LmhlaWdodD1lOnQud2lkdGg9ZSk7Yz90LndpZHRoPXRoaXMuc25hcCh0LndpZHRoKTp0LmhlaWdodD10aGlzLnNuYXAodC5oZWlnaHQpO3RoaXMuc2V0Q2hpbGRHZW9tZXRyeShyLHQpO249cjtrPXQ7bT1jP2sueCtrLndpZHRoK01hdGguZmxvb3IodS8yKTprLnkray5oZWlnaHQrTWF0aC5mbG9vcih1LzIpfX10aGlzLnJlc2l6ZVBhcmVudCYmbnVsbCE9YiYmbnVsbCE9ayYmIXRoaXMuZ3JhcGguaXNDZWxsQ29sbGFwc2VkKGEpP3RoaXMudXBkYXRlUGFyZW50R2VvbWV0cnkoYSxiLGspOnRoaXMucmVzaXplTGFzdCYmbnVsbCE9YiYmbnVsbCE9ayYmbnVsbCE9biYmKGM/ay53aWR0aD1iLndpZHRoLWsueC10aGlzLnNwYWNpbmctdGhpcy5tYXJnaW5SaWdodC10aGlzLm1hcmdpbkxlZnQ6ay5oZWlnaHQ9Yi5oZWlnaHQtay55LXRoaXMuc3BhY2luZy10aGlzLm1hcmdpbkJvdHRvbSx0aGlzLnNldENoaWxkR2VvbWV0cnkobixrKSl9ZmluYWxseXtkLmVuZFVwZGF0ZSgpfX19OwpteFN0YWNrTGF5b3V0LnByb3RvdHlwZS5zZXRDaGlsZEdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSk7bnVsbCE9YyYmYi54PT1jLngmJmIueT09Yy55JiZiLndpZHRoPT1jLndpZHRoJiZiLmhlaWdodD09Yy5oZWlnaHR8fHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5zZXRHZW9tZXRyeShhLGIpfTsKbXhTdGFja0xheW91dC5wcm90b3R5cGUudXBkYXRlUGFyZW50R2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuaXNIb3Jpem9udGFsKCksZT10aGlzLmdyYXBoLmdldE1vZGVsKCksZj1iLmNsb25lKCk7ZD8oYz1jLngrYy53aWR0aCt0aGlzLm1hcmdpblJpZ2h0K3RoaXMuYm9yZGVyLGYud2lkdGg9dGhpcy5yZXNpemVQYXJlbnRNYXg/TWF0aC5tYXgoZi53aWR0aCxjKTpjKTooYz1jLnkrYy5oZWlnaHQrdGhpcy5tYXJnaW5Cb3R0b20rdGhpcy5ib3JkZXIsZi5oZWlnaHQ9dGhpcy5yZXNpemVQYXJlbnRNYXg/TWF0aC5tYXgoZi5oZWlnaHQsYyk6Yyk7Yi54PT1mLngmJmIueT09Zi55JiZiLndpZHRoPT1mLndpZHRoJiZiLmhlaWdodD09Zi5oZWlnaHR8fGUuc2V0R2VvbWV0cnkoYSxmKX07CmZ1bmN0aW9uIG14UGFydGl0aW9uTGF5b3V0KGEsYixjLGQpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpO3RoaXMuaG9yaXpvbnRhbD1udWxsIT1iP2I6ITA7dGhpcy5zcGFjaW5nPWN8fDA7dGhpcy5ib3JkZXI9ZHx8MH1teFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGU9bmV3IG14R3JhcGhMYXlvdXQ7bXhQYXJ0aXRpb25MYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14UGFydGl0aW9uTGF5b3V0O214UGFydGl0aW9uTGF5b3V0LnByb3RvdHlwZS5ob3Jpem9udGFsPW51bGw7bXhQYXJ0aXRpb25MYXlvdXQucHJvdG90eXBlLnNwYWNpbmc9bnVsbDtteFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGUuYm9yZGVyPW51bGw7bXhQYXJ0aXRpb25MYXlvdXQucHJvdG90eXBlLnJlc2l6ZVZlcnRpY2VzPSEwO214UGFydGl0aW9uTGF5b3V0LnByb3RvdHlwZS5pc0hvcml6b250YWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3Jpem9udGFsfTsKbXhQYXJ0aXRpb25MYXlvdXQucHJvdG90eXBlLm1vdmVDZWxsPWZ1bmN0aW9uKGEsYixjKXtjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTt2YXIgZD1jLmdldFBhcmVudChhKTtpZihudWxsIT1hJiZudWxsIT1kKXt2YXIgZSxmPTAsZz1jLmdldENoaWxkQ291bnQoZCk7Zm9yKGU9MDtlPGc7ZSsrKXt2YXIgaz1jLmdldENoaWxkQXQoZCxlKSxrPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGspO2lmKG51bGwhPWspe2s9ay54K2sud2lkdGgvMjtpZihmPGImJms+YilicmVhaztmPWt9fWI9ZC5nZXRJbmRleChhKTtiPU1hdGgubWF4KDAsZS0oZT5iPzE6MCkpO2MuYWRkKGQsYSxiKX19OwpteFBhcnRpdGlvbkxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmlzSG9yaXpvbnRhbCgpLGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9Yy5nZXRHZW9tZXRyeShhKTtudWxsIT10aGlzLmdyYXBoLmNvbnRhaW5lciYmKG51bGw9PWQmJmMuaXNMYXllcihhKXx8YT09dGhpcy5ncmFwaC5nZXRWaWV3KCkuY3VycmVudFJvb3QpJiYoZD1uZXcgbXhSZWN0YW5nbGUoMCwwLHRoaXMuZ3JhcGguY29udGFpbmVyLm9mZnNldFdpZHRoLTEsdGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0SGVpZ2h0LTEpKTtpZihudWxsIT1kKXtmb3IodmFyIGU9W10sZj1jLmdldENoaWxkQ291bnQoYSksZz0wO2c8ZjtnKyspe3ZhciBrPWMuZ2V0Q2hpbGRBdChhLGcpOyF0aGlzLmlzVmVydGV4SWdub3JlZChrKSYmdGhpcy5pc1ZlcnRleE1vdmFibGUoaykmJmUucHVzaChrKX1mPWUubGVuZ3RoO2lmKDA8Zil7dmFyIGw9dGhpcy5ib3JkZXIsbT10aGlzLmJvcmRlcixuPWI/CmQuaGVpZ2h0OmQud2lkdGgsbj1uLTIqdGhpcy5ib3JkZXI7YT10aGlzLmdyYXBoLmlzU3dpbWxhbmUoYSk/dGhpcy5ncmFwaC5nZXRTdGFydFNpemUoYSk6bmV3IG14UmVjdGFuZ2xlO24tPWI/YS5oZWlnaHQ6YS53aWR0aDtsKz1hLndpZHRoO20rPWEuaGVpZ2h0O2E9dGhpcy5ib3JkZXIrKGYtMSkqdGhpcy5zcGFjaW5nO2Q9Yj8oZC53aWR0aC1sLWEpL2Y6KGQuaGVpZ2h0LW0tYSkvZjtpZigwPGQpe2MuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKGc9MDtnPGY7ZysrKXt2YXIgaz1lW2ddLHA9Yy5nZXRHZW9tZXRyeShrKTtudWxsIT1wJiYocD1wLmNsb25lKCkscC54PWwscC55PW0sYj8odGhpcy5yZXNpemVWZXJ0aWNlcyYmKHAud2lkdGg9ZCxwLmhlaWdodD1uKSxsKz1kK3RoaXMuc3BhY2luZyk6KHRoaXMucmVzaXplVmVydGljZXMmJihwLmhlaWdodD1kLHAud2lkdGg9biksbSs9ZCt0aGlzLnNwYWNpbmcpLGMuc2V0R2VvbWV0cnkoayxwKSl9fWZpbmFsbHl7Yy5lbmRVcGRhdGUoKX19fX19OwpmdW5jdGlvbiBteENvbXBhY3RUcmVlTGF5b3V0KGEsYixjKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKTt0aGlzLmhvcml6b250YWw9bnVsbCE9Yj9iOiEwO3RoaXMuaW52ZXJ0PW51bGwhPWM/YzohMX1teENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teENvbXBhY3RUcmVlTGF5b3V0O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmhvcml6b250YWw9bnVsbDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5pbnZlcnQ9bnVsbDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5yZXNpemVQYXJlbnQ9ITA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubWFpbnRhaW5QYXJlbnRMb2NhdGlvbj0hMTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5ncm91cFBhZGRpbmc9MTA7Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmdyb3VwUGFkZGluZ1RvcD0wO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmdyb3VwUGFkZGluZ1JpZ2h0PTA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZ3JvdXBQYWRkaW5nQm90dG9tPTA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZ3JvdXBQYWRkaW5nTGVmdD0wO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnBhcmVudHNDaGFuZ2VkPW51bGw7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubW92ZVRyZWU9ITE7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUudmlzaXRlZD1udWxsO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmxldmVsRGlzdGFuY2U9MTA7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubm9kZURpc3RhbmNlPTIwO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnJlc2V0RWRnZXM9ITA7Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnByZWZIb3pFZGdlU2VwPTU7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUucHJlZlZlcnRFZGdlT2ZmPTQ7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubWluRWRnZUpldHR5PTg7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuY2hhbm5lbEJ1ZmZlcj00O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmVkZ2VSb3V0aW5nPSEwO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnNvcnRFZGdlcz0hMTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5hbGlnblJhbmtzPSExO214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLm1heFJhbmtIZWlnaHQ9bnVsbDtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5yb290PW51bGw7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubm9kZT1udWxsOwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5pc1ZlcnRleElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14R3JhcGhMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDA9PXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbnMoYSkubGVuZ3RofTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5pc0hvcml6b250YWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3Jpem9udGFsfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhLGIpe3RoaXMucGFyZW50PWE7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2lmKG51bGw9PWIpaWYoMDx0aGlzLmdyYXBoLmdldEVkZ2VzKGEsYy5nZXRQYXJlbnQoYSksdGhpcy5pbnZlcnQsIXRoaXMuaW52ZXJ0LCExKS5sZW5ndGgpdGhpcy5yb290PWE7ZWxzZXt2YXIgZD10aGlzLmdyYXBoLmZpbmRUcmVlUm9vdHMoYSwhMCx0aGlzLmludmVydCk7aWYoMDxkLmxlbmd0aClmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKylpZighdGhpcy5pc1ZlcnRleElnbm9yZWQoZFtlXSkmJjA8dGhpcy5ncmFwaC5nZXRFZGdlcyhkW2VdLG51bGwsdGhpcy5pbnZlcnQsIXRoaXMuaW52ZXJ0LCExKS5sZW5ndGgpe3RoaXMucm9vdD1kW2VdO2JyZWFrfX1lbHNlIHRoaXMucm9vdD1iO2lmKG51bGwhPXRoaXMucm9vdCl7dGhpcy5wYXJlbnRzQ2hhbmdlZD10aGlzLnJlc2l6ZVBhcmVudD97fTpudWxsO3RoaXMucGFyZW50WT0KdGhpcy5wYXJlbnRYPW51bGw7aWYoYSE9dGhpcy5yb290JiZudWxsIT1jLmlzVmVydGV4KGEpJiZ0aGlzLm1haW50YWluUGFyZW50TG9jYXRpb24pe3ZhciBmPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO251bGwhPWYmJih0aGlzLnBhcmVudFg9Zi54LHRoaXMucGFyZW50WT1mLnkpfWMuYmVnaW5VcGRhdGUoKTt0cnl7aWYodGhpcy52aXNpdGVkPXt9LHRoaXMubm9kZT10aGlzLmRmcyh0aGlzLnJvb3QsYSksdGhpcy5hbGlnblJhbmtzJiYodGhpcy5tYXhSYW5rSGVpZ2h0PVtdLHRoaXMuZmluZFJhbmtIZWlnaHRzKHRoaXMubm9kZSwwKSx0aGlzLnNldENlbGxIZWlnaHRzKHRoaXMubm9kZSwwKSksbnVsbCE9dGhpcy5ub2RlKXt0aGlzLmxheW91dCh0aGlzLm5vZGUpO3ZhciBnPXRoaXMuZ3JhcGguZ3JpZFNpemUsZD1nO2lmKCF0aGlzLm1vdmVUcmVlKXt2YXIgaz10aGlzLmdldFZlcnRleEJvdW5kcyh0aGlzLnJvb3QpO251bGwhPWsmJihnPWsueCxkPWsueSl9az1udWxsOwprPXRoaXMuaXNIb3Jpem9udGFsKCk/dGhpcy5ob3Jpem9udGFsTGF5b3V0KHRoaXMubm9kZSxnLGQpOnRoaXMudmVydGljYWxMYXlvdXQodGhpcy5ub2RlLG51bGwsZyxkKTtpZihudWxsIT1rKXt2YXIgbD1lPTA7MD5rLngmJihlPU1hdGguYWJzKGctay54KSk7MD5rLnkmJihsPU1hdGguYWJzKGQtay55KSk7MD09ZSYmMD09bHx8dGhpcy5tb3ZlTm9kZSh0aGlzLm5vZGUsZSxsKTt0aGlzLnJlc2l6ZVBhcmVudCYmdGhpcy5hZGp1c3RQYXJlbnRzKCk7dGhpcy5lZGdlUm91dGluZyYmdGhpcy5sb2NhbEVkZ2VQcm9jZXNzaW5nKHRoaXMubm9kZSl9bnVsbCE9dGhpcy5wYXJlbnRYJiZudWxsIT10aGlzLnBhcmVudFkmJihmPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpLG51bGwhPWYmJihmPWYuY2xvbmUoKSxmLng9dGhpcy5wYXJlbnRYLGYueT10aGlzLnBhcmVudFksYy5zZXRHZW9tZXRyeShhLGYpKSl9fWZpbmFsbHl7Yy5lbmRVcGRhdGUoKX19fTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubW92ZU5vZGU9ZnVuY3Rpb24oYSxiLGMpe2EueCs9YjthLnkrPWM7dGhpcy5hcHBseShhKTtmb3IoYT1hLmNoaWxkO251bGwhPWE7KXRoaXMubW92ZU5vZGUoYSxiLGMpLGE9YS5uZXh0fTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuc29ydE91dGdvaW5nRWRnZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgbXhEaWN0aW9uYXJ5O2Iuc29ydChmdW5jdGlvbihiLGUpe3ZhciBkPWIuZ2V0VGVybWluYWwoYi5nZXRUZXJtaW5hbCghMSk9PWEpLGc9Yy5nZXQoZCk7bnVsbD09ZyYmKGc9bXhDZWxsUGF0aC5jcmVhdGUoZCkuc3BsaXQobXhDZWxsUGF0aC5QQVRIX1NFUEFSQVRPUiksYy5wdXQoZCxnKSk7dmFyIGQ9ZS5nZXRUZXJtaW5hbChlLmdldFRlcm1pbmFsKCExKT09YSksaz1jLmdldChkKTtudWxsPT1rJiYoaz1teENlbGxQYXRoLmNyZWF0ZShkKS5zcGxpdChteENlbGxQYXRoLlBBVEhfU0VQQVJBVE9SKSxjLnB1dChkLGspKTtyZXR1cm4gbXhDZWxsUGF0aC5jb21wYXJlKGcsayl9KX07Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmZpbmRSYW5rSGVpZ2h0cz1mdW5jdGlvbihhLGIpe2lmKG51bGw9PXRoaXMubWF4UmFua0hlaWdodFtiXXx8dGhpcy5tYXhSYW5rSGVpZ2h0W2JdPGEuaGVpZ2h0KXRoaXMubWF4UmFua0hlaWdodFtiXT1hLmhlaWdodDtmb3IodmFyIGM9YS5jaGlsZDtudWxsIT1jOyl0aGlzLmZpbmRSYW5rSGVpZ2h0cyhjLGIrMSksYz1jLm5leHR9O214Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLnNldENlbGxIZWlnaHRzPWZ1bmN0aW9uKGEsYil7bnVsbCE9dGhpcy5tYXhSYW5rSGVpZ2h0W2JdJiZ0aGlzLm1heFJhbmtIZWlnaHRbYl0+YS5oZWlnaHQmJihhLmhlaWdodD10aGlzLm1heFJhbmtIZWlnaHRbYl0pO2Zvcih2YXIgYz1hLmNoaWxkO251bGwhPWM7KXRoaXMuc2V0Q2VsbEhlaWdodHMoYyxiKzEpLGM9Yy5uZXh0fTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZGZzPWZ1bmN0aW9uKGEsYil7dmFyIGM9bXhDZWxsUGF0aC5jcmVhdGUoYSksZD1udWxsO2lmKG51bGwhPWEmJm51bGw9PXRoaXMudmlzaXRlZFtjXSYmIXRoaXMuaXNWZXJ0ZXhJZ25vcmVkKGEpKXt0aGlzLnZpc2l0ZWRbY109YTt2YXIgZD10aGlzLmNyZWF0ZU5vZGUoYSksYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1udWxsLGY9dGhpcy5ncmFwaC5nZXRFZGdlcyhhLGIsdGhpcy5pbnZlcnQsIXRoaXMuaW52ZXJ0LCExLCEwKSxnPXRoaXMuZ3JhcGguZ2V0VmlldygpO3RoaXMuc29ydEVkZ2VzJiZ0aGlzLnNvcnRPdXRnb2luZ0VkZ2VzKGEsZik7Zm9yKHZhciBrPTA7azxmLmxlbmd0aDtrKyspe3ZhciBsPWZba107aWYoIXRoaXMuaXNFZGdlSWdub3JlZChsKSl7dGhpcy5yZXNldEVkZ2VzJiZ0aGlzLnNldEVkZ2VQb2ludHMobCxudWxsKTt0aGlzLmVkZ2VSb3V0aW5nJiYodGhpcy5zZXRFZGdlU3R5bGVFbmFibGVkKGwsITEpLAp0aGlzLnNldEVkZ2VQb2ludHMobCxudWxsKSk7dmFyIG09Zy5nZXRTdGF0ZShsKSxsPW51bGwhPW0/bS5nZXRWaXNpYmxlVGVybWluYWwodGhpcy5pbnZlcnQpOmcuZ2V0VmlzaWJsZVRlcm1pbmFsKGwsdGhpcy5pbnZlcnQpLG09dGhpcy5kZnMobCxiKTtudWxsIT1tJiZudWxsIT1jLmdldEdlb21ldHJ5KGwpJiYobnVsbD09ZT9kLmNoaWxkPW06ZS5uZXh0PW0sZT1tKX19fXJldHVybiBkfTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5sYXlvdXQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7Zm9yKHZhciBiPWEuY2hpbGQ7bnVsbCE9YjspdGhpcy5sYXlvdXQoYiksYj1iLm5leHQ7bnVsbCE9YS5jaGlsZD90aGlzLmF0dGFjaFBhcmVudChhLHRoaXMuam9pbihhKSk6dGhpcy5sYXlvdXRMZWFmKGEpfX07Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmhvcml6b250YWxMYXlvdXQ9ZnVuY3Rpb24oYSxiLGMsZCl7YS54Kz1iK2Eub2Zmc2V0WDthLnkrPWMrYS5vZmZzZXRZO2Q9dGhpcy5hcHBseShhLGQpO2I9YS5jaGlsZDtpZihudWxsIT1iKXtkPXRoaXMuaG9yaXpvbnRhbExheW91dChiLGEueCxhLnksZCk7Yz1hLnkrYi5vZmZzZXRZO2Zvcih2YXIgZT1iLm5leHQ7bnVsbCE9ZTspZD10aGlzLmhvcml6b250YWxMYXlvdXQoZSxhLngrYi5vZmZzZXRYLGMsZCksYys9ZS5vZmZzZXRZLGU9ZS5uZXh0fXJldHVybiBkfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUudmVydGljYWxMYXlvdXQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXthLngrPWMrYS5vZmZzZXRZO2EueSs9ZCthLm9mZnNldFg7ZT10aGlzLmFwcGx5KGEsZSk7Yj1hLmNoaWxkO2lmKG51bGwhPWIpZm9yKGU9dGhpcy52ZXJ0aWNhbExheW91dChiLGEsYS54LGEueSxlKSxjPWEueCtiLm9mZnNldFksZD1iLm5leHQ7bnVsbCE9ZDspZT10aGlzLnZlcnRpY2FsTGF5b3V0KGQsYSxjLGEueStiLm9mZnNldFgsZSksYys9ZC5vZmZzZXRZLGQ9ZC5uZXh0O3JldHVybiBlfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuYXR0YWNoUGFyZW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ub2RlRGlzdGFuY2UrdGhpcy5sZXZlbERpc3RhbmNlLGQ9KGItYS53aWR0aCkvMi10aGlzLm5vZGVEaXN0YW5jZSxlPWQrYS53aWR0aCsyKnRoaXMubm9kZURpc3RhbmNlLWI7YS5jaGlsZC5vZmZzZXRYPWMrYS5oZWlnaHQ7YS5jaGlsZC5vZmZzZXRZPWU7YS5jb250b3VyLnVwcGVySGVhZD10aGlzLmNyZWF0ZUxpbmUoYS5oZWlnaHQsMCx0aGlzLmNyZWF0ZUxpbmUoYyxlLGEuY29udG91ci51cHBlckhlYWQpKTthLmNvbnRvdXIubG93ZXJIZWFkPXRoaXMuY3JlYXRlTGluZShhLmhlaWdodCwwLHRoaXMuY3JlYXRlTGluZShjLGQsYS5jb250b3VyLmxvd2VySGVhZCkpfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubGF5b3V0TGVhZj1mdW5jdGlvbihhKXt2YXIgYj0yKnRoaXMubm9kZURpc3RhbmNlO2EuY29udG91ci51cHBlclRhaWw9dGhpcy5jcmVhdGVMaW5lKGEuaGVpZ2h0K2IsMCk7YS5jb250b3VyLnVwcGVySGVhZD1hLmNvbnRvdXIudXBwZXJUYWlsO2EuY29udG91ci5sb3dlclRhaWw9dGhpcy5jcmVhdGVMaW5lKDAsLWEud2lkdGgtYik7YS5jb250b3VyLmxvd2VySGVhZD10aGlzLmNyZWF0ZUxpbmUoYS5oZWlnaHQrYiwwLGEuY29udG91ci5sb3dlclRhaWwpfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuam9pbj1mdW5jdGlvbihhKXt2YXIgYj0yKnRoaXMubm9kZURpc3RhbmNlLGM9YS5jaGlsZDthLmNvbnRvdXI9Yy5jb250b3VyO2Zvcih2YXIgZD1jLndpZHRoK2IsZT1kLGM9Yy5uZXh0O251bGwhPWM7KXt2YXIgZj10aGlzLm1lcmdlKGEuY29udG91cixjLmNvbnRvdXIpO2Mub2Zmc2V0WT1mK2Q7Yy5vZmZzZXRYPTA7ZD1jLndpZHRoK2I7ZSs9ZitkO2M9Yy5uZXh0fXJldHVybiBlfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUubWVyZ2U9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MCxkPTAsZT0wLGY9YS5sb3dlckhlYWQsZz1iLnVwcGVySGVhZDtudWxsIT1nJiZudWxsIT1mOyl7dmFyIGs9dGhpcy5vZmZzZXQoYyxkLGcuZHgsZy5keSxmLmR4LGYuZHkpLGQ9ZCtrLGU9ZStrO2MrZy5keDw9Zi5keD8oYys9Zy5keCxkKz1nLmR5LGc9Zy5uZXh0KTooYy09Zi5keCxkLT1mLmR5LGY9Zi5uZXh0KX1udWxsIT1nPyhjPXRoaXMuYnJpZGdlKGEudXBwZXJUYWlsLDAsMCxnLGMsZCksYS51cHBlclRhaWw9bnVsbCE9Yy5uZXh0P2IudXBwZXJUYWlsOmMsYS5sb3dlclRhaWw9Yi5sb3dlclRhaWwpOihjPXRoaXMuYnJpZGdlKGIubG93ZXJUYWlsLGMsZCxmLDAsMCksbnVsbD09Yy5uZXh0JiYoYS5sb3dlclRhaWw9YykpO2EubG93ZXJIZWFkPWIubG93ZXJIZWFkO3JldHVybiBlfTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZihlPD1hfHwwPj1hK2MpcmV0dXJuIDA7YT0wPGUqZC1jKmY/MD5hP2EqZC9jLWI6MDxhP2EqZi9lLWI6LWI6ZTxhK2M/Zi0oYisoZS1hKSpkL2MpOmU+YStjPyhjK2EpKmYvZS0oYitkKTpmLShiK2QpO3JldHVybiAwPGE/YTowfTtteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5icmlkZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2I9ZStkLmR4LWI7MD09ZC5keD9lPWQuZHk6KGU9YipkLmR5LGUvPWQuZHgpO2I9dGhpcy5jcmVhdGVMaW5lKGIsZSxkLm5leHQpO2EubmV4dD10aGlzLmNyZWF0ZUxpbmUoMCxmK2QuZHktZS1jLGIpO3JldHVybiBifTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuY3JlYXRlTm9kZT1mdW5jdGlvbihhKXt2YXIgYj17fTtiLmNlbGw9YTtiLng9MDtiLnk9MDtiLndpZHRoPTA7Yi5oZWlnaHQ9MDthPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGEpO251bGwhPWEmJih0aGlzLmlzSG9yaXpvbnRhbCgpPyhiLndpZHRoPWEuaGVpZ2h0LGIuaGVpZ2h0PWEud2lkdGgpOihiLndpZHRoPWEud2lkdGgsYi5oZWlnaHQ9YS5oZWlnaHQpKTtiLm9mZnNldFg9MDtiLm9mZnNldFk9MDtiLmNvbnRvdXI9e307cmV0dXJuIGJ9OwpteENvbXBhY3RUcmVlTGF5b3V0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPWEuY2VsbCxlPWMuZ2V0R2VvbWV0cnkoZCk7bnVsbCE9ZCYmbnVsbCE9ZSYmKHRoaXMuaXNWZXJ0ZXhNb3ZhYmxlKGQpJiYoZT10aGlzLnNldFZlcnRleExvY2F0aW9uKGQsYS54LGEueSksdGhpcy5yZXNpemVQYXJlbnQmJihjPWMuZ2V0UGFyZW50KGQpLGQ9bXhDZWxsUGF0aC5jcmVhdGUoYyksbnVsbD09dGhpcy5wYXJlbnRzQ2hhbmdlZFtkXSYmKHRoaXMucGFyZW50c0NoYW5nZWRbZF09YykpKSxiPW51bGw9PWI/bmV3IG14UmVjdGFuZ2xlKGUueCxlLnksZS53aWR0aCxlLmhlaWdodCk6bmV3IG14UmVjdGFuZ2xlKE1hdGgubWluKGIueCxlLngpLE1hdGgubWluKGIueSxlLnkpLE1hdGgubWF4KGIueCtiLndpZHRoLGUueCtlLndpZHRoKSxNYXRoLm1heChiLnkrYi5oZWlnaHQsZS55K2UuaGVpZ2h0KSkpO3JldHVybiBifTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuY3JlYXRlTGluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9e307ZC5keD1hO2QuZHk9YjtkLm5leHQ9YztyZXR1cm4gZH07bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuYWRqdXN0UGFyZW50cz1mdW5jdGlvbigpe3ZhciBhPVtdLGI7Zm9yKGIgaW4gdGhpcy5wYXJlbnRzQ2hhbmdlZClhLnB1c2godGhpcy5wYXJlbnRzQ2hhbmdlZFtiXSk7dGhpcy5hcnJhbmdlR3JvdXBzKG14VXRpbHMuc29ydENlbGxzKGEsITApLHRoaXMuZ3JvdXBQYWRkaW5nLHRoaXMuZ3JvdXBQYWRkaW5nVG9wLHRoaXMuZ3JvdXBQYWRkaW5nUmlnaHQsdGhpcy5ncm91cFBhZGRpbmdCb3R0b20sdGhpcy5ncm91cFBhZGRpbmdMZWZ0KX07Cm14Q29tcGFjdFRyZWVMYXlvdXQucHJvdG90eXBlLmxvY2FsRWRnZVByb2Nlc3Npbmc9ZnVuY3Rpb24oYSl7dGhpcy5wcm9jZXNzTm9kZU91dGdvaW5nKGEpO2ZvcihhPWEuY2hpbGQ7bnVsbCE9YTspdGhpcy5sb2NhbEVkZ2VQcm9jZXNzaW5nKGEpLGE9YS5uZXh0fTsKbXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUucHJvY2Vzc05vZGVPdXRnb2luZz1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS5jaGlsZCxjPWEuY2VsbCxkPTAsZT1bXTtudWxsIT1iOyl7ZCsrO3ZhciBmPWIueDt0aGlzLmhvcml6b250YWwmJihmPWIueSk7ZS5wdXNoKG5ldyBXZWlnaHRlZENlbGxTb3J0ZXIoYixmKSk7Yj1iLm5leHR9ZS5zb3J0KFdlaWdodGVkQ2VsbFNvcnRlci5wcm90b3R5cGUuY29tcGFyZSk7dmFyIGY9YS53aWR0aCxnPShkKzEpKnRoaXMucHJlZkhvekVkZ2VTZXA7Zj5nKzIqdGhpcy5wcmVmSG96RWRnZVNlcCYmKGYtPTIqdGhpcy5wcmVmSG96RWRnZVNlcCk7YT1mL2Q7Yj1hLzI7Zj5nKzIqdGhpcy5wcmVmSG96RWRnZVNlcCYmKGIrPXRoaXMucHJlZkhvekVkZ2VTZXApO2Zvcih2YXIgZj10aGlzLm1pbkVkZ2VKZXR0eS10aGlzLnByZWZWZXJ0RWRnZU9mZixnPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGMpLGs9MDtrPGUubGVuZ3RoO2srKyl7Zm9yKHZhciBsPQplW2tdLmNlbGwuY2VsbCxtPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGwpLGw9dGhpcy5ncmFwaC5nZXRFZGdlc0JldHdlZW4oYyxsLCExKSxuPVtdLHAscSxyPTA7cjxsLmxlbmd0aDtyKyspdGhpcy5ob3Jpem9udGFsPyhwPWcueCtnLndpZHRoLHE9Zy55K2Isbi5wdXNoKG5ldyBteFBvaW50KHAscSkpLHA9Zy54K2cud2lkdGgrZixuLnB1c2gobmV3IG14UG9pbnQocCxxKSkscT1tLnkrbS5oZWlnaHQvMik6KHA9Zy54K2IscT1nLnkrZy5oZWlnaHQsbi5wdXNoKG5ldyBteFBvaW50KHAscSkpLHE9Zy55K2cuaGVpZ2h0K2Ysbi5wdXNoKG5ldyBteFBvaW50KHAscSkpLHA9bS54K20ud2lkdGgvMiksbi5wdXNoKG5ldyBteFBvaW50KHAscSkpLHRoaXMuc2V0RWRnZVBvaW50cyhsW3JdLG4pO2s8ZC8yP2YrPXRoaXMucHJlZlZlcnRFZGdlT2ZmOms+ZC8yJiYoZi09dGhpcy5wcmVmVmVydEVkZ2VPZmYpO2IrPWF9fTsKZnVuY3Rpb24gbXhSYWRpYWxUcmVlTGF5b3V0KGEpe214Q29tcGFjdFRyZWVMYXlvdXQuY2FsbCh0aGlzLGEsITEpfW14VXRpbHMuZXh0ZW5kKG14UmFkaWFsVHJlZUxheW91dCxteENvbXBhY3RUcmVlTGF5b3V0KTtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLmFuZ2xlT2Zmc2V0PS41O214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUucm9vdHg9MDtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLnJvb3R5PTA7bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5sZXZlbERpc3RhbmNlPTEyMDtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLm5vZGVEaXN0YW5jZT0xMDtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLmF1dG9SYWRpdXM9ITE7bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5zb3J0RWRnZXM9ITE7bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5yb3dNaW5YPVtdO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUucm93TWF4WD1bXTsKbXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5yb3dNaW5DZW5YPVtdO214UmFkaWFsVHJlZUxheW91dC5wcm90b3R5cGUucm93TWF4Q2VuWD1bXTtteFJhZGlhbFRyZWVMYXlvdXQucHJvdG90eXBlLnJvd1JhZGk9W107bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5yb3c9W107bXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5pc1ZlcnRleElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14R3JhcGhMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDA9PXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbnMoYSkubGVuZ3RofTsKbXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5wYXJlbnQ9YTt0aGlzLmVkZ2VSb3V0aW5nPXRoaXMudXNlQm91bmRpbmdCb3g9ITE7bXhDb21wYWN0VHJlZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGM9bnVsbCxkPXRoaXMuZ2V0VmVydGV4Qm91bmRzKHRoaXMucm9vdCk7dGhpcy5jZW50ZXJYPWQueCtkLndpZHRoLzI7dGhpcy5jZW50ZXJZPWQueStkLmhlaWdodC8yO2Zvcih2YXIgZSBpbiB0aGlzLnZpc2l0ZWQpe3ZhciBmPXRoaXMuZ2V0VmVydGV4Qm91bmRzKHRoaXMudmlzaXRlZFtlXSksYz1udWxsIT1jP2M6Zi5jbG9uZSgpO2MuYWRkKGYpfXRoaXMuY2FsY1Jvd0RpbXMoW3RoaXMubm9kZV0sMCk7Zm9yKHZhciBnPTAsaz0wLGM9MDtjPHRoaXMucm93Lmxlbmd0aDtjKyspZT0odGhpcy5yb3dNYXhYW2NdLXRoaXMuY2VudGVyWC10aGlzLm5vZGVEaXN0YW5jZSkvdGhpcy5yb3dSYWRpW2NdLApnPU1hdGgubWF4KGcsKHRoaXMuY2VudGVyWC10aGlzLnJvd01pblhbY10tdGhpcy5ub2RlRGlzdGFuY2UpL3RoaXMucm93UmFkaVtjXSksaz1NYXRoLm1heChrLGUpO2ZvcihjPTA7Yzx0aGlzLnJvdy5sZW5ndGg7YysrKXt2YXIgbD10aGlzLmNlbnRlclgtdGhpcy5ub2RlRGlzdGFuY2UtZyp0aGlzLnJvd1JhZGlbY10sbT10aGlzLmNlbnRlclgrdGhpcy5ub2RlRGlzdGFuY2Urayp0aGlzLnJvd1JhZGlbY10tbDtmb3IoZT0wO2U8dGhpcy5yb3dbY10ubGVuZ3RoO2UrKylmPXRoaXMucm93W2NdLGQ9ZltlXSxmPXRoaXMuZ2V0VmVydGV4Qm91bmRzKGQuY2VsbCksZC50aGV0YT0oZi54K2Yud2lkdGgvMi1sKS9tKk1hdGguUEkqMn1mb3IoYz10aGlzLnJvdy5sZW5ndGgtMjswPD1jO2MtLSlmb3IoZj10aGlzLnJvd1tjXSxlPTA7ZTxmLmxlbmd0aDtlKyspe2Q9ZltlXTtnPWQuY2hpbGQ7Zm9yKGw9az0wO251bGwhPWc7KWwrPWcudGhldGEsaysrLGc9Zy5uZXh0OzA8ayYmKGc9bC9rLGc+CmQudGhldGEmJmU8Zi5sZW5ndGgtMT9kLnRoZXRhPU1hdGgubWluKGcsZltlKzFdLnRoZXRhLU1hdGguUEkvMTApOmc8ZC50aGV0YSYmMDxlJiYoZC50aGV0YT1NYXRoLm1heChnLGZbZS0xXS50aGV0YStNYXRoLlBJLzEwKSkpfWZvcihjPTA7Yzx0aGlzLnJvdy5sZW5ndGg7YysrKWZvcihlPTA7ZTx0aGlzLnJvd1tjXS5sZW5ndGg7ZSsrKWY9dGhpcy5yb3dbY10sZD1mW2VdLGY9dGhpcy5nZXRWZXJ0ZXhCb3VuZHMoZC5jZWxsKSx0aGlzLnNldFZlcnRleExvY2F0aW9uKGQuY2VsbCx0aGlzLmNlbnRlclgtZi53aWR0aC8yK3RoaXMucm93UmFkaVtjXSpNYXRoLmNvcyhkLnRoZXRhKSx0aGlzLmNlbnRlclktZi5oZWlnaHQvMit0aGlzLnJvd1JhZGlbY10qTWF0aC5zaW4oZC50aGV0YSkpfTsKbXhSYWRpYWxUcmVlTGF5b3V0LnByb3RvdHlwZS5jYWxjUm93RGltcz1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJjAhPWEubGVuZ3RoKXt0aGlzLnJvd01pblhbYl09dGhpcy5jZW50ZXJYO3RoaXMucm93TWF4WFtiXT10aGlzLmNlbnRlclg7dGhpcy5yb3dNaW5DZW5YW2JdPXRoaXMuY2VudGVyWDt0aGlzLnJvd01heENlblhbYl09dGhpcy5jZW50ZXJYO3RoaXMucm93W2JdPVtdO2Zvcih2YXIgYz0hMSxkPTA7ZDxhLmxlbmd0aDtkKyspZm9yKHZhciBlPW51bGwhPWFbZF0/YVtkXS5jaGlsZDpudWxsO251bGwhPWU7KXt2YXIgZj10aGlzLmdldFZlcnRleEJvdW5kcyhlLmNlbGwpO3RoaXMucm93TWluWFtiXT1NYXRoLm1pbihmLngsdGhpcy5yb3dNaW5YW2JdKTt0aGlzLnJvd01heFhbYl09TWF0aC5tYXgoZi54K2Yud2lkdGgsdGhpcy5yb3dNYXhYW2JdKTt0aGlzLnJvd01pbkNlblhbYl09TWF0aC5taW4oZi54K2Yud2lkdGgvMix0aGlzLnJvd01pbkNlblhbYl0pO3RoaXMucm93TWF4Q2VuWFtiXT0KTWF0aC5tYXgoZi54K2Yud2lkdGgvMix0aGlzLnJvd01heENlblhbYl0pO3RoaXMucm93UmFkaVtiXT1mLnktdGhpcy5nZXRWZXJ0ZXhCb3VuZHModGhpcy5yb290KS55O251bGwhPWUuY2hpbGQmJihjPSEwKTt0aGlzLnJvd1tiXS5wdXNoKGUpO2U9ZS5uZXh0fWMmJnRoaXMuY2FsY1Jvd0RpbXModGhpcy5yb3dbYl0sYisxKX19O2Z1bmN0aW9uIG14RmFzdE9yZ2FuaWNMYXlvdXQoYSl7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSl9bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGU9bmV3IG14R3JhcGhMYXlvdXQ7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhGYXN0T3JnYW5pY0xheW91dDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS51c2VJbnB1dE9yaWdpbj0hMDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5yZXNldEVkZ2VzPSEwO214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLmRpc2FibGVFZGdlU3R5bGU9ITA7Cm14RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLmZvcmNlQ29uc3RhbnQ9NTA7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuZm9yY2VDb25zdGFudFNxdWFyZWQ9MDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5taW5EaXN0YW5jZUxpbWl0PTI7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUubWF4RGlzdGFuY2VMaW1pdD01MDA7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUubWluRGlzdGFuY2VMaW1pdFNxdWFyZWQ9NDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5pbml0aWFsVGVtcD0yMDA7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUudGVtcGVyYXR1cmU9MDtteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5tYXhJdGVyYXRpb25zPTA7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuaXRlcmF0aW9uPTA7bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuYWxsb3dlZFRvUnVuPSEwOwpteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5pc1ZlcnRleElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14R3JhcGhMYXlvdXQucHJvdG90eXBlLmlzVmVydGV4SWdub3JlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDA9PXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbnMoYSkubGVuZ3RofTsKbXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCk7dGhpcy52ZXJ0ZXhBcnJheT1bXTtmb3IodmFyIGM9dGhpcy5ncmFwaC5nZXRDaGlsZFZlcnRpY2VzKGEpLGQ9MDtkPGMubGVuZ3RoO2QrKyl0aGlzLmlzVmVydGV4SWdub3JlZChjW2RdKXx8dGhpcy52ZXJ0ZXhBcnJheS5wdXNoKGNbZF0pO3ZhciBlPXRoaXMudXNlSW5wdXRPcmlnaW4/dGhpcy5ncmFwaC5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeSh0aGlzLnZlcnRleEFycmF5KTpudWxsLGY9dGhpcy52ZXJ0ZXhBcnJheS5sZW5ndGg7dGhpcy5pbmRpY2VzPVtdO3RoaXMuZGlzcFg9W107dGhpcy5kaXNwWT1bXTt0aGlzLmNlbGxMb2NhdGlvbj1bXTt0aGlzLmlzTW92ZWFibGU9W107dGhpcy5uZWlnaGJvdXJzPVtdO3RoaXMucmFkaXVzPVtdO3RoaXMucmFkaXVzU3F1YXJlZD1bXTsuMDAxPnRoaXMuZm9yY2VDb25zdGFudCYmKHRoaXMuZm9yY2VDb25zdGFudD0KLjAwMSk7dGhpcy5mb3JjZUNvbnN0YW50U3F1YXJlZD10aGlzLmZvcmNlQ29uc3RhbnQqdGhpcy5mb3JjZUNvbnN0YW50O2ZvcihkPTA7ZDx0aGlzLnZlcnRleEFycmF5Lmxlbmd0aDtkKyspe3ZhciBnPXRoaXMudmVydGV4QXJyYXlbZF07dGhpcy5jZWxsTG9jYXRpb25bZF09W107dmFyIGs9bXhPYmplY3RJZGVudGl0eS5nZXQoZyk7dGhpcy5pbmRpY2VzW2tdPWQ7dmFyIGw9dGhpcy5nZXRWZXJ0ZXhCb3VuZHMoZyksbT1sLndpZHRoLG49bC5oZWlnaHQscD1sLngscT1sLnk7dGhpcy5jZWxsTG9jYXRpb25bZF1bMF09cCttLzI7dGhpcy5jZWxsTG9jYXRpb25bZF1bMV09cStuLzI7dGhpcy5yYWRpdXNbZF09TWF0aC5taW4obSxuKTt0aGlzLnJhZGl1c1NxdWFyZWRbZF09dGhpcy5yYWRpdXNbZF0qdGhpcy5yYWRpdXNbZF19Yi5iZWdpblVwZGF0ZSgpO3RyeXtmb3IoZD0wO2Q8ZjtkKyspe3RoaXMuZGlzcFhbZF09MDt0aGlzLmRpc3BZW2RdPTA7dGhpcy5pc01vdmVhYmxlW2RdPXRoaXMuaXNWZXJ0ZXhNb3ZhYmxlKHRoaXMudmVydGV4QXJyYXlbZF0pOwp2YXIgcj10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25zKHRoaXMudmVydGV4QXJyYXlbZF0sYSksYz10aGlzLmdyYXBoLmdldE9wcG9zaXRlcyhyLHRoaXMudmVydGV4QXJyYXlbZF0pO3RoaXMubmVpZ2hib3Vyc1tkXT1bXTtmb3IobT0wO208Yy5sZW5ndGg7bSsrKXt0aGlzLnJlc2V0RWRnZXMmJnRoaXMuZ3JhcGgucmVzZXRFZGdlKHJbbV0pO3RoaXMuZGlzYWJsZUVkZ2VTdHlsZSYmdGhpcy5zZXRFZGdlU3R5bGVFbmFibGVkKHJbbV0sITEpO3ZhciBrPW14T2JqZWN0SWRlbnRpdHkuZ2V0KGNbbV0pLHQ9dGhpcy5pbmRpY2VzW2tdO3RoaXMubmVpZ2hib3Vyc1tkXVttXT1udWxsIT10P3Q6ZH19dGhpcy50ZW1wZXJhdHVyZT10aGlzLmluaXRpYWxUZW1wOzA9PXRoaXMubWF4SXRlcmF0aW9ucyYmKHRoaXMubWF4SXRlcmF0aW9ucz0yMCpNYXRoLnNxcnQoZikpO2Zvcih0aGlzLml0ZXJhdGlvbj0wO3RoaXMuaXRlcmF0aW9uPHRoaXMubWF4SXRlcmF0aW9uczt0aGlzLml0ZXJhdGlvbisrKXtpZighdGhpcy5hbGxvd2VkVG9SdW4pcmV0dXJuOwp0aGlzLmNhbGNSZXB1bHNpb24oKTt0aGlzLmNhbGNBdHRyYWN0aW9uKCk7dGhpcy5jYWxjUG9zaXRpb25zKCk7dGhpcy5yZWR1Y2VUZW1wZXJhdHVyZSgpfWE9Yz1udWxsO2ZvcihkPTA7ZDx0aGlzLnZlcnRleEFycmF5Lmxlbmd0aDtkKyspZz10aGlzLnZlcnRleEFycmF5W2RdLHRoaXMuaXNWZXJ0ZXhNb3ZhYmxlKGcpJiYobD10aGlzLmdldFZlcnRleEJvdW5kcyhnKSxudWxsIT1sJiYodGhpcy5jZWxsTG9jYXRpb25bZF1bMF0tPWwud2lkdGgvMix0aGlzLmNlbGxMb2NhdGlvbltkXVsxXS09bC5oZWlnaHQvMixwPXRoaXMuZ3JhcGguc25hcChNYXRoLnJvdW5kKHRoaXMuY2VsbExvY2F0aW9uW2RdWzBdKSkscT10aGlzLmdyYXBoLnNuYXAoTWF0aC5yb3VuZCh0aGlzLmNlbGxMb2NhdGlvbltkXVsxXSkpLHRoaXMuc2V0VmVydGV4TG9jYXRpb24oZyxwLHEpLGM9bnVsbD09Yz9wOk1hdGgubWluKGMscCksYT1udWxsPT1hP3E6TWF0aC5taW4oYSxxKSkpO2Q9LShjfHwwKSsxO2c9LShhfHwKMCkrMTtudWxsIT1lJiYoZCs9ZS54LGcrPWUueSk7dGhpcy5ncmFwaC5tb3ZlQ2VsbHModGhpcy52ZXJ0ZXhBcnJheSxkLGcpfWZpbmFsbHl7Yi5lbmRVcGRhdGUoKX19O214RmFzdE9yZ2FuaWNMYXlvdXQucHJvdG90eXBlLmNhbGNQb3NpdGlvbnM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMudmVydGV4QXJyYXkubGVuZ3RoO2ErKylpZih0aGlzLmlzTW92ZWFibGVbYV0pe3ZhciBiPU1hdGguc3FydCh0aGlzLmRpc3BYW2FdKnRoaXMuZGlzcFhbYV0rdGhpcy5kaXNwWVthXSp0aGlzLmRpc3BZW2FdKTsuMDAxPmImJihiPS4wMDEpO3ZhciBjPXRoaXMuZGlzcFhbYV0vYipNYXRoLm1pbihiLHRoaXMudGVtcGVyYXR1cmUpLGI9dGhpcy5kaXNwWVthXS9iKk1hdGgubWluKGIsdGhpcy50ZW1wZXJhdHVyZSk7dGhpcy5kaXNwWFthXT0wO3RoaXMuZGlzcFlbYV09MDt0aGlzLmNlbGxMb2NhdGlvblthXVswXSs9Yzt0aGlzLmNlbGxMb2NhdGlvblthXVsxXSs9Yn19OwpteEZhc3RPcmdhbmljTGF5b3V0LnByb3RvdHlwZS5jYWxjQXR0cmFjdGlvbj1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy52ZXJ0ZXhBcnJheS5sZW5ndGg7YSsrKWZvcih2YXIgYj0wO2I8dGhpcy5uZWlnaGJvdXJzW2FdLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMubmVpZ2hib3Vyc1thXVtiXTtpZihhIT1jJiZ0aGlzLmlzTW92ZWFibGVbYV0mJnRoaXMuaXNNb3ZlYWJsZVtjXSl7dmFyIGQ9dGhpcy5jZWxsTG9jYXRpb25bYV1bMF0tdGhpcy5jZWxsTG9jYXRpb25bY11bMF0sZT10aGlzLmNlbGxMb2NhdGlvblthXVsxXS10aGlzLmNlbGxMb2NhdGlvbltjXVsxXSxmPWQqZCtlKmUtdGhpcy5yYWRpdXNTcXVhcmVkW2FdLXRoaXMucmFkaXVzU3F1YXJlZFtjXTtmPHRoaXMubWluRGlzdGFuY2VMaW1pdFNxdWFyZWQmJihmPXRoaXMubWluRGlzdGFuY2VMaW1pdFNxdWFyZWQpO3ZhciBnPU1hdGguc3FydChmKSxmPWYvdGhpcy5mb3JjZUNvbnN0YW50LGQ9ZC9nKmYsZT1lL2cqZjsKdGhpcy5kaXNwWFthXS09ZDt0aGlzLmRpc3BZW2FdLT1lO3RoaXMuZGlzcFhbY10rPWQ7dGhpcy5kaXNwWVtjXSs9ZX19fTsKbXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvbj1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLnZlcnRleEFycmF5Lmxlbmd0aCxiPTA7YjxhO2IrKylmb3IodmFyIGM9YjtjPGE7YysrKXtpZighdGhpcy5hbGxvd2VkVG9SdW4pcmV0dXJuO2lmKGMhPWImJnRoaXMuaXNNb3ZlYWJsZVtiXSYmdGhpcy5pc01vdmVhYmxlW2NdKXt2YXIgZD10aGlzLmNlbGxMb2NhdGlvbltiXVswXS10aGlzLmNlbGxMb2NhdGlvbltjXVswXSxlPXRoaXMuY2VsbExvY2F0aW9uW2JdWzFdLXRoaXMuY2VsbExvY2F0aW9uW2NdWzFdOzA9PWQmJihkPS4wMStNYXRoLnJhbmRvbSgpKTswPT1lJiYoZT0uMDErTWF0aC5yYW5kb20oKSk7dmFyIGY9TWF0aC5zcXJ0KGQqZCtlKmUpLGc9Zi10aGlzLnJhZGl1c1tiXS10aGlzLnJhZGl1c1tjXTtnPnRoaXMubWF4RGlzdGFuY2VMaW1pdHx8KGc8dGhpcy5taW5EaXN0YW5jZUxpbWl0JiYoZz10aGlzLm1pbkRpc3RhbmNlTGltaXQpLGc9dGhpcy5mb3JjZUNvbnN0YW50U3F1YXJlZC8KZyxkPWQvZipnLGU9ZS9mKmcsdGhpcy5kaXNwWFtiXSs9ZCx0aGlzLmRpc3BZW2JdKz1lLHRoaXMuZGlzcFhbY10tPWQsdGhpcy5kaXNwWVtjXS09ZSl9fX07bXhGYXN0T3JnYW5pY0xheW91dC5wcm90b3R5cGUucmVkdWNlVGVtcGVyYXR1cmU9ZnVuY3Rpb24oKXt0aGlzLnRlbXBlcmF0dXJlPXRoaXMuaW5pdGlhbFRlbXAqKDEtdGhpcy5pdGVyYXRpb24vdGhpcy5tYXhJdGVyYXRpb25zKX07ZnVuY3Rpb24gbXhDaXJjbGVMYXlvdXQoYSxiKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKTt0aGlzLnJhZGl1cz1udWxsIT1iP2I6MTAwfW14Q2lyY2xlTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDtteENpcmNsZUxheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhDaXJjbGVMYXlvdXQ7bXhDaXJjbGVMYXlvdXQucHJvdG90eXBlLnJhZGl1cz1udWxsO214Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS5tb3ZlQ2lyY2xlPSExOwpteENpcmNsZUxheW91dC5wcm90b3R5cGUueDA9MDtteENpcmNsZUxheW91dC5wcm90b3R5cGUueTA9MDtteENpcmNsZUxheW91dC5wcm90b3R5cGUucmVzZXRFZGdlcz0hMDtteENpcmNsZUxheW91dC5wcm90b3R5cGUuZGlzYWJsZUVkZ2VTdHlsZT0hMDsKbXhDaXJjbGVMYXlvdXQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2IuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBjPTAsZD1udWxsLGU9bnVsbCxmPVtdLGc9Yi5nZXRDaGlsZENvdW50KGEpLGs9MDtrPGc7aysrKXt2YXIgbD1iLmdldENoaWxkQXQoYSxrKTtpZih0aGlzLmlzVmVydGV4SWdub3JlZChsKSl0aGlzLmlzRWRnZUlnbm9yZWQobCl8fCh0aGlzLnJlc2V0RWRnZXMmJnRoaXMuZ3JhcGgucmVzZXRFZGdlKGwpLHRoaXMuZGlzYWJsZUVkZ2VTdHlsZSYmdGhpcy5zZXRFZGdlU3R5bGVFbmFibGVkKGwsITEpKTtlbHNle2YucHVzaChsKTt2YXIgbT10aGlzLmdldFZlcnRleEJvdW5kcyhsKSxkPW51bGw9PWQ/bS55Ok1hdGgubWluKGQsbS55KSxlPW51bGw9PWU/bS54Ok1hdGgubWluKGUsbS54KSxjPU1hdGgubWF4KGMsTWF0aC5tYXgobS53aWR0aCxtLmhlaWdodCkpfX12YXIgbj10aGlzLmdldFJhZGl1cyhmLmxlbmd0aCwKYyk7dGhpcy5tb3ZlQ2lyY2xlJiYoZT10aGlzLngwLGQ9dGhpcy55MCk7dGhpcy5jaXJjbGUoZixuLGUsZCl9ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX07bXhDaXJjbGVMYXlvdXQucHJvdG90eXBlLmdldFJhZGl1cz1mdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLm1heChhKmIvTWF0aC5QSSx0aGlzLnJhZGl1cyl9O214Q2lyY2xlTGF5b3V0LnByb3RvdHlwZS5jaXJjbGU9ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlPWEubGVuZ3RoLGY9MipNYXRoLlBJL2UsZz0wO2c8ZTtnKyspdGhpcy5pc1ZlcnRleE1vdmFibGUoYVtnXSkmJnRoaXMuc2V0VmVydGV4TG9jYXRpb24oYVtnXSxNYXRoLnJvdW5kKGMrYitiKk1hdGguc2luKGcqZikpLE1hdGgucm91bmQoZCtiK2IqTWF0aC5jb3MoZypmKSkpfTtmdW5jdGlvbiBteFBhcmFsbGVsRWRnZUxheW91dChhKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKX1teFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGU9bmV3IG14R3JhcGhMYXlvdXQ7Cm14UGFyYWxsZWxFZGdlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teFBhcmFsbGVsRWRnZUxheW91dDtteFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGUuc3BhY2luZz0yMDtteFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXthPXRoaXMuZmluZFBhcmFsbGVscyhhKTt0aGlzLmdyYXBoLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYiBpbiBhKXt2YXIgYz1hW2JdOzE8Yy5sZW5ndGgmJnRoaXMubGF5b3V0KGMpfX1maW5hbGx5e3RoaXMuZ3JhcGgubW9kZWwuZW5kVXBkYXRlKCl9fTsKbXhQYXJhbGxlbEVkZ2VMYXlvdXQucHJvdG90eXBlLmZpbmRQYXJhbGxlbHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxjPVtdLGQ9Yi5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGQ7ZSsrKXt2YXIgZj1iLmdldENoaWxkQXQoYSxlKTtpZighdGhpcy5pc0VkZ2VJZ25vcmVkKGYpKXt2YXIgZz10aGlzLmdldEVkZ2VJZChmKTtudWxsIT1nJiYobnVsbD09Y1tnXSYmKGNbZ109W10pLGNbZ10ucHVzaChmKSl9fXJldHVybiBjfTtteFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGUuZ2V0RWRnZUlkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0VmlldygpLGM9Yi5nZXRWaXNpYmxlVGVybWluYWwoYSwhMCk7YT1iLmdldFZpc2libGVUZXJtaW5hbChhLCExKTtyZXR1cm4gbnVsbCE9YyYmbnVsbCE9YT8oYz1teE9iamVjdElkZW50aXR5LmdldChjKSxhPW14T2JqZWN0SWRlbnRpdHkuZ2V0KGEpLGM+YT9hKyItIitjOmMrIi0iK2EpOm51bGx9OwpteFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGUubGF5b3V0PWZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0sYz10aGlzLmdyYXBoLmdldFZpZXcoKSxkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0R2VvbWV0cnkoYy5nZXRWaXNpYmxlVGVybWluYWwoYiwhMCkpLGQ9ZC5nZXRHZW9tZXRyeShjLmdldFZpc2libGVUZXJtaW5hbChiLCExKSk7aWYoZT09ZClmb3IodmFyIGI9ZS54K2Uud2lkdGgrdGhpcy5zcGFjaW5nLGM9ZS55K2UuaGVpZ2h0LzIsZj0wO2Y8YS5sZW5ndGg7ZisrKXRoaXMucm91dGUoYVtmXSxiLGMpLGIrPXRoaXMuc3BhY2luZztlbHNlIGlmKG51bGwhPWUmJm51bGwhPWQpe3ZhciBiPWUueCtlLndpZHRoLzIsYz1lLnkrZS5oZWlnaHQvMixmPWQueCtkLndpZHRoLzItYixnPWQueStkLmhlaWdodC8yLWMsZD1NYXRoLnNxcnQoZipmK2cqZyk7aWYoMDxkKWZvcihlPWcqdGhpcy5zcGFjaW5nL2QsZD1mKnRoaXMuc3BhY2luZy9kLGI9YitmLzIrZSooYS5sZW5ndGgtCjEpLzIsYz1jK2cvMi1kKihhLmxlbmd0aC0xKS8yLGY9MDtmPGEubGVuZ3RoO2YrKyl0aGlzLnJvdXRlKGFbZl0sYixjKSxiLT1lLGMrPWR9fTtteFBhcmFsbGVsRWRnZUxheW91dC5wcm90b3R5cGUucm91dGU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuZ3JhcGguaXNDZWxsTW92YWJsZShhKSYmdGhpcy5zZXRFZGdlUG9pbnRzKGEsW25ldyBteFBvaW50KGIsYyldKX07ZnVuY3Rpb24gbXhDb21wb3NpdGVMYXlvdXQoYSxiLGMpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpO3RoaXMubGF5b3V0cz1iO3RoaXMubWFzdGVyPWN9bXhDb21wb3NpdGVMYXlvdXQucHJvdG90eXBlPW5ldyBteEdyYXBoTGF5b3V0O214Q29tcG9zaXRlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teENvbXBvc2l0ZUxheW91dDtteENvbXBvc2l0ZUxheW91dC5wcm90b3R5cGUubGF5b3V0cz1udWxsO214Q29tcG9zaXRlTGF5b3V0LnByb3RvdHlwZS5tYXN0ZXI9bnVsbDsKbXhDb21wb3NpdGVMYXlvdXQucHJvdG90eXBlLm1vdmVDZWxsPWZ1bmN0aW9uKGEsYixjKXtudWxsIT10aGlzLm1hc3Rlcj90aGlzLm1hc3Rlci5tb3ZlQ2VsbC5hcHBseSh0aGlzLm1hc3Rlcixhcmd1bWVudHMpOnRoaXMubGF5b3V0c1swXS5tb3ZlQ2VsbC5hcHBseSh0aGlzLmxheW91dHNbMF0sYXJndW1lbnRzKX07bXhDb21wb3NpdGVMYXlvdXQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2IuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBjPTA7Yzx0aGlzLmxheW91dHMubGVuZ3RoO2MrKyl0aGlzLmxheW91dHNbY10uZXhlY3V0ZS5hcHBseSh0aGlzLmxheW91dHNbY10sYXJndW1lbnRzKX1maW5hbGx5e2IuZW5kVXBkYXRlKCl9fTtmdW5jdGlvbiBteEVkZ2VMYWJlbExheW91dChhLGIpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpfW14RWRnZUxhYmVsTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDsKbXhFZGdlTGFiZWxMYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14RWRnZUxhYmVsTGF5b3V0O214RWRnZUxhYmVsTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmdyYXBoLnZpZXcsYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZD1bXSxlPVtdLGY9Yy5nZXRDaGlsZENvdW50KGEpLGc9MDtnPGY7ZysrKXt2YXIgaz1jLmdldENoaWxkQXQoYSxnKSxsPWIuZ2V0U3RhdGUoayk7bnVsbCE9bCYmKHRoaXMuaXNWZXJ0ZXhJZ25vcmVkKGspP3RoaXMuaXNFZGdlSWdub3JlZChrKXx8ZC5wdXNoKGwpOmUucHVzaChsKSl9dGhpcy5wbGFjZUxhYmVscyhlLGQpfTsKbXhFZGdlTGFiZWxMYXlvdXQucHJvdG90eXBlLnBsYWNlTGFiZWxzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2MuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF07aWYobnVsbCE9ZSYmbnVsbCE9ZS50ZXh0JiZudWxsIT1lLnRleHQuYm91bmRpbmdCb3gpZm9yKHZhciBmPTA7ZjxhLmxlbmd0aDtmKyspe3ZhciBnPWFbZl07bnVsbCE9ZyYmdGhpcy5hdm9pZChlLGcpfX19ZmluYWxseXtjLmVuZFVwZGF0ZSgpfX07Cm14RWRnZUxhYmVsTGF5b3V0LnByb3RvdHlwZS5hdm9pZD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPWEudGV4dC5ib3VuZGluZ0JveDtpZihteFV0aWxzLmludGVyc2VjdHMoZCxiKSl7dmFyIGU9LWQueS1kLmhlaWdodCtiLnksZj0tZC55K2IueStiLmhlaWdodCxlPU1hdGguYWJzKGUpPE1hdGguYWJzKGYpP2U6ZixmPS1kLngtZC53aWR0aCtiLngsZD0tZC54K2IueCtiLndpZHRoLGQ9TWF0aC5hYnMoZik8TWF0aC5hYnMoZCk/ZjpkO01hdGguYWJzKGQpPE1hdGguYWJzKGUpP2U9MDpkPTA7Zj1jLmdldEdlb21ldHJ5KGEuY2VsbCk7bnVsbCE9ZiYmKGY9Zi5jbG9uZSgpLG51bGwhPWYub2Zmc2V0PyhmLm9mZnNldC54Kz1kLGYub2Zmc2V0LnkrPWUpOmYub2Zmc2V0PW5ldyBteFBvaW50KGQsZSksYy5zZXRHZW9tZXRyeShhLmNlbGwsZikpfX07CmZ1bmN0aW9uIG14R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwoKXt0aGlzLng9W107dGhpcy55PVtdO3RoaXMudGVtcD1bXX1teEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5tYXhSYW5rPS0xO214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLm1pblJhbms9LTE7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUueD1udWxsO214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLnk9bnVsbDtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS53aWR0aD0wO214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLmhlaWdodD0wO214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLm5leHRMYXllckNvbm5lY3RlZENlbGxzPW51bGw7bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzPW51bGw7Cm14R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLnRlbXA9bnVsbDtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuZ2V0UHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5pc0VkZ2U9ZnVuY3Rpb24oKXtyZXR1cm4hMX07bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuaXNWZXJ0ZXg9ZnVuY3Rpb24oKXtyZXR1cm4hMX07bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07Cm14R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbH07bXhHcmFwaEFic3RyYWN0SGllcmFyY2h5Q2VsbC5wcm90b3R5cGUuc2V0WD1mdW5jdGlvbihhLGIpe3RoaXMuaXNWZXJ0ZXgoKT90aGlzLnhbMF09Yjp0aGlzLmlzRWRnZSgpJiYodGhpcy54W2EtdGhpcy5taW5SYW5rLTFdPWIpfTtteEdyYXBoQWJzdHJhY3RIaWVyYXJjaHlDZWxsLnByb3RvdHlwZS5nZXRYPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzVmVydGV4KCk/dGhpcy54WzBdOnRoaXMuaXNFZGdlKCk/dGhpcy54W2EtdGhpcy5taW5SYW5rLTFdOjB9O214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwucHJvdG90eXBlLnNldFk9ZnVuY3Rpb24oYSxiKXt0aGlzLmlzVmVydGV4KCk/dGhpcy55WzBdPWI6dGhpcy5pc0VkZ2UoKSYmKHRoaXMueVthLXRoaXMubWluUmFuay0xXT1iKX07CmZ1bmN0aW9uIG14R3JhcGhIaWVyYXJjaHlOb2RlKGEpe214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuY2VsbD1hO3RoaXMuaWQ9bXhPYmplY3RJZGVudGl0eS5nZXQoYSk7dGhpcy5jb25uZWN0c0FzVGFyZ2V0PVtdO3RoaXMuY29ubmVjdHNBc1NvdXJjZT1bXX1teEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGU9bmV3IG14R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGw7bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14R3JhcGhIaWVyYXJjaHlOb2RlO214R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5jZWxsPW51bGw7bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmlkPW51bGw7bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmNvbm5lY3RzQXNUYXJnZXQ9bnVsbDtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuY29ubmVjdHNBc1NvdXJjZT1udWxsOwpteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuaGFzaENvZGU9ITE7bXhHcmFwaEhpZXJhcmNoeU5vZGUucHJvdG90eXBlLmdldFJhbmtWYWx1ZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tYXhSYW5rfTtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuZ2V0TmV4dExheWVyQ29ubmVjdGVkQ2VsbHM9ZnVuY3Rpb24oYSl7aWYobnVsbD09dGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxscyl7dGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxscz1bXTt0aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzWzBdPVtdO2Zvcih2YXIgYj0wO2I8dGhpcy5jb25uZWN0c0FzVGFyZ2V0Lmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuY29ubmVjdHNBc1RhcmdldFtiXTstMT09Yy5tYXhSYW5rfHxjLm1heFJhbms9PWErMT90aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzWzBdLnB1c2goYy5zb3VyY2UpOnRoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHNbMF0ucHVzaChjKX19cmV0dXJuIHRoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHNbMF19OwpteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuZ2V0UHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzPWZ1bmN0aW9uKGEpe2lmKG51bGw9PXRoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzKXt0aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscz1bXTt0aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxsc1swXT1bXTtmb3IodmFyIGI9MDtiPHRoaXMuY29ubmVjdHNBc1NvdXJjZS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmNvbm5lY3RzQXNTb3VyY2VbYl07LTE9PWMubWluUmFua3x8Yy5taW5SYW5rPT1hLTE/dGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbMF0ucHVzaChjLnRhcmdldCk6dGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbMF0ucHVzaChjKX19cmV0dXJuIHRoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzWzBdfTtteEdyYXBoSGllcmFyY2h5Tm9kZS5wcm90b3R5cGUuaXNWZXJ0ZXg9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Cm14R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRlbXBbMF19O214R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlPWZ1bmN0aW9uKGEsYil7dGhpcy50ZW1wWzBdPWJ9O214R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5pc0FuY2VzdG9yPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJm51bGwhPXRoaXMuaGFzaENvZGUmJm51bGwhPWEuaGFzaENvZGUmJnRoaXMuaGFzaENvZGUubGVuZ3RoPGEuaGFzaENvZGUubGVuZ3RoKXtpZih0aGlzLmhhc2hDb2RlPT1hLmhhc2hDb2RlKXJldHVybiEwO2lmKG51bGw9PXRoaXMuaGFzaENvZGV8fG51bGw9PXRoaXMuaGFzaENvZGUpcmV0dXJuITE7Zm9yKHZhciBiPTA7Yjx0aGlzLmhhc2hDb2RlLmxlbmd0aDtiKyspaWYodGhpcy5oYXNoQ29kZVtiXSE9YS5oYXNoQ29kZVtiXSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX07Cm14R3JhcGhIaWVyYXJjaHlOb2RlLnByb3RvdHlwZS5nZXRDb3JlQ2VsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGx9O2Z1bmN0aW9uIG14R3JhcGhIaWVyYXJjaHlFZGdlKGEpe214R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZWRnZXM9YTt0aGlzLmlkcz1bXTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLmlkcy5wdXNoKG14T2JqZWN0SWRlbnRpdHkuZ2V0KGFbYl0pKX1teEdyYXBoSGllcmFyY2h5RWRnZS5wcm90b3R5cGU9bmV3IG14R3JhcGhBYnN0cmFjdEhpZXJhcmNoeUNlbGw7bXhHcmFwaEhpZXJhcmNoeUVkZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14R3JhcGhIaWVyYXJjaHlFZGdlO214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5lZGdlcz1udWxsO214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5pZHM9bnVsbDtteEdyYXBoSGllcmFyY2h5RWRnZS5wcm90b3R5cGUuc291cmNlPW51bGw7Cm14R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS50YXJnZXQ9bnVsbDtteEdyYXBoSGllcmFyY2h5RWRnZS5wcm90b3R5cGUuaXNSZXZlcnNlZD0hMTtteEdyYXBoSGllcmFyY2h5RWRnZS5wcm90b3R5cGUuaW52ZXJ0PWZ1bmN0aW9uKGEpe2E9dGhpcy5zb3VyY2U7dGhpcy5zb3VyY2U9dGhpcy50YXJnZXQ7dGhpcy50YXJnZXQ9YTt0aGlzLmlzUmV2ZXJzZWQ9IXRoaXMuaXNSZXZlcnNlZH07Cm14R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscz1mdW5jdGlvbihhKXtpZihudWxsPT10aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzKXt0aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzPVtdO2Zvcih2YXIgYj0wO2I8dGhpcy50ZW1wLmxlbmd0aDtiKyspdGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxsc1tiXT1bXSxiPT10aGlzLnRlbXAubGVuZ3RoLTE/dGhpcy5uZXh0TGF5ZXJDb25uZWN0ZWRDZWxsc1tiXS5wdXNoKHRoaXMuc291cmNlKTp0aGlzLm5leHRMYXllckNvbm5lY3RlZENlbGxzW2JdLnB1c2godGhpcyl9cmV0dXJuIHRoaXMubmV4dExheWVyQ29ubmVjdGVkQ2VsbHNbYS10aGlzLm1pblJhbmstMV19OwpteEdyYXBoSGllcmFyY2h5RWRnZS5wcm90b3R5cGUuZ2V0UHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzPWZ1bmN0aW9uKGEpe2lmKG51bGw9PXRoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzKXt0aGlzLnByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscz1bXTtmb3IodmFyIGI9MDtiPHRoaXMudGVtcC5sZW5ndGg7YisrKXRoaXMucHJldmlvdXNMYXllckNvbm5lY3RlZENlbGxzW2JdPVtdLDA9PWI/dGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbYl0ucHVzaCh0aGlzLnRhcmdldCk6dGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbYl0ucHVzaCh0aGlzKX1yZXR1cm4gdGhpcy5wcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHNbYS10aGlzLm1pblJhbmstMV19O214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5pc0VkZ2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Cm14R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRlbXBbYS10aGlzLm1pblJhbmstMV19O214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlPWZ1bmN0aW9uKGEsYil7dGhpcy50ZW1wW2EtdGhpcy5taW5SYW5rLTFdPWJ9O214R3JhcGhIaWVyYXJjaHlFZGdlLnByb3RvdHlwZS5nZXRDb3JlQ2VsbD1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmVkZ2VzJiYwPHRoaXMuZWRnZXMubGVuZ3RoP3RoaXMuZWRnZXNbMF06bnVsbH07CmZ1bmN0aW9uIG14R3JhcGhIaWVyYXJjaHlNb2RlbChhLGIsYyxkLGUpe2EuZ2V0R3JhcGgoKTt0aGlzLnRpZ2h0ZW5Ub1NvdXJjZT1lO3RoaXMucm9vdHM9Yzt0aGlzLnBhcmVudD1kO3RoaXMudmVydGV4TWFwcGVyPW5ldyBteERpY3Rpb25hcnk7dGhpcy5lZGdlTWFwcGVyPW5ldyBteERpY3Rpb25hcnk7dGhpcy5tYXhSYW5rPTA7Yz1bXTtudWxsPT1iJiYoYj10aGlzLmdyYXBoLmdldENoaWxkVmVydGljZXMoZCkpO3RoaXMubWF4UmFuaz10aGlzLlNPVVJDRVNDQU5TVEFSVFJBTks7dGhpcy5jcmVhdGVJbnRlcm5hbENlbGxzKGEsYixjKTtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKXtlPWNbZF0uY29ubmVjdHNBc1NvdXJjZTtmb3IodmFyIGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGc9ZVtmXSxrPWcuZWRnZXM7aWYobnVsbCE9ayYmMDxrLmxlbmd0aCl7dmFyIGs9a1swXSxsPWEuZ2V0VmlzaWJsZVRlcm1pbmFsKGssITEpLGw9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KGwpO2NbZF09PQpsJiYobD1hLmdldFZpc2libGVUZXJtaW5hbChrLCEwKSxsPXRoaXMudmVydGV4TWFwcGVyLmdldChsKSk7bnVsbCE9bCYmY1tkXSE9bCYmKGcudGFyZ2V0PWwsMD09bC5jb25uZWN0c0FzVGFyZ2V0Lmxlbmd0aCYmKGwuY29ubmVjdHNBc1RhcmdldD1bXSksMD5teFV0aWxzLmluZGV4T2YobC5jb25uZWN0c0FzVGFyZ2V0LGcpJiZsLmNvbm5lY3RzQXNUYXJnZXQucHVzaChnKSl9fWNbZF0udGVtcFswXT0xfX1teEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLm1heFJhbms9bnVsbDtteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLnZlcnRleE1hcHBlcj1udWxsO214R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUuZWRnZU1hcHBlcj1udWxsO214R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUucmFua3M9bnVsbDtteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLnJvb3RzPW51bGw7bXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5wYXJlbnQ9bnVsbDsKbXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5kZnNDb3VudD0wO214R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUuU09VUkNFU0NBTlNUQVJUUkFOSz0xRTg7bXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS50aWdodGVuVG9Tb3VyY2U9ITE7Cm14R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUuY3JlYXRlSW50ZXJuYWxDZWxscz1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEuZ2V0R3JhcGgoKSxlPTA7ZTxiLmxlbmd0aDtlKyspe2NbZV09bmV3IG14R3JhcGhIaWVyYXJjaHlOb2RlKGJbZV0pO3RoaXMudmVydGV4TWFwcGVyLnB1dChiW2VdLGNbZV0pO3ZhciBmPWEuZ2V0RWRnZXMoYltlXSk7Y1tlXS5jb25uZWN0c0FzU291cmNlPVtdO2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaz1hLmdldFZpc2libGVUZXJtaW5hbChmW2ddLCExKTtpZihrIT1iW2VdJiZhLmdyYXBoLm1vZGVsLmlzVmVydGV4KGspJiYhYS5pc1ZlcnRleElnbm9yZWQoaykpe3ZhciBsPWEuZ2V0RWRnZXNCZXR3ZWVuKGJbZV0saywhMSksaz1hLmdldEVkZ2VzQmV0d2VlbihiW2VdLGssITApO2lmKG51bGwhPWwmJjA8bC5sZW5ndGgmJm51bGw9PXRoaXMuZWRnZU1hcHBlci5nZXQobFswXSkmJjIqay5sZW5ndGg+PWwubGVuZ3RoKXtmb3IodmFyIGs9Cm5ldyBteEdyYXBoSGllcmFyY2h5RWRnZShsKSxtPTA7bTxsLmxlbmd0aDttKyspe3ZhciBuPWxbbV07dGhpcy5lZGdlTWFwcGVyLnB1dChuLGspO2QucmVzZXRFZGdlKG4pO2EuZGlzYWJsZUVkZ2VTdHlsZSYmKGEuc2V0RWRnZVN0eWxlRW5hYmxlZChuLCExKSxhLnNldE9ydGhvZ29uYWxFZGdlKG4sITApKX1rLnNvdXJjZT1jW2VdOzA+bXhVdGlscy5pbmRleE9mKGNbZV0uY29ubmVjdHNBc1NvdXJjZSxrKSYmY1tlXS5jb25uZWN0c0FzU291cmNlLnB1c2goayl9fX1jW2VdLnRlbXBbMF09MH19OwpteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLmluaXRpYWxSYW5rPWZ1bmN0aW9uKCl7dmFyIGE9W107aWYobnVsbCE9dGhpcy5yb290cylmb3IodmFyIGI9MDtiPHRoaXMucm9vdHMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KHRoaXMucm9vdHNbYl0pO251bGwhPWMmJmEucHVzaChjKX1mb3IodmFyIGQ9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0VmFsdWVzKCksYj0wO2I8ZC5sZW5ndGg7YisrKWRbYl0udGVtcFswXT0tMTtmb3IodmFyIGU9YS5zbGljZSgpOzA8YS5sZW5ndGg7KXt2YXIgYz1hWzBdLGYsZztmPWMuY29ubmVjdHNBc1RhcmdldDtnPWMuY29ubmVjdHNBc1NvdXJjZTtmb3IodmFyIGs9ITAsbD10aGlzLlNPVVJDRVNDQU5TVEFSVFJBTkssYj0wO2I8Zi5sZW5ndGg7YisrKXt2YXIgbT1mW2JdO2lmKDUyNzA2MjA9PW0udGVtcFswXSltPW0uc291cmNlLGw9TWF0aC5taW4obCxtLnRlbXBbMF0tMSk7ZWxzZXtrPSExO2JyZWFrfX1pZihrKXtjLnRlbXBbMF09Cmw7dGhpcy5tYXhSYW5rPU1hdGgubWluKHRoaXMubWF4UmFuayxsKTtpZihudWxsIT1nKWZvcihiPTA7YjxnLmxlbmd0aDtiKyspbT1nW2JdLG0udGVtcFswXT01MjcwNjIwLG09bS50YXJnZXQsLTE9PW0udGVtcFswXSYmKGEucHVzaChtKSxtLnRlbXBbMF09LTIpO2Euc2hpZnQoKX1lbHNlIGlmKGI9YS5zaGlmdCgpLGEucHVzaChjKSxiPT1jJiYxPT1hLmxlbmd0aClicmVha31mb3IoYj0wO2I8ZC5sZW5ndGg7YisrKWRbYl0udGVtcFswXS09dGhpcy5tYXhSYW5rO2ZvcihiPTA7YjxlLmxlbmd0aDtiKyspZm9yKGM9ZVtiXSxhPTAsZj1jLmNvbm5lY3RzQXNTb3VyY2UsZD0wO2Q8Zi5sZW5ndGg7ZCsrKW09ZltkXSxtPW0udGFyZ2V0LGMudGVtcFswXT1NYXRoLm1heChhLG0udGVtcFswXSsxKSxhPWMudGVtcFswXTt0aGlzLm1heFJhbms9dGhpcy5TT1VSQ0VTQ0FOU1RBUlRSQU5LLXRoaXMubWF4UmFua307Cm14R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUuZml4UmFua3M9ZnVuY3Rpb24oKXt2YXIgYT1bXTt0aGlzLnJhbmtzPVtdO2Zvcih2YXIgYj0wO2I8dGhpcy5tYXhSYW5rKzE7YisrKWFbYl09W10sdGhpcy5yYW5rc1tiXT1hW2JdO3ZhciBjPW51bGw7aWYobnVsbCE9dGhpcy5yb290cylmb3IodmFyIGQ9dGhpcy5yb290cyxjPVtdLGI9MDtiPGQubGVuZ3RoO2IrKyl7dmFyIGU9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KGRbYl0pO2NbYl09ZX10aGlzLnZpc2l0KGZ1bmN0aW9uKGIsYyxkLGUsbSl7MD09bSYmMD5jLm1heFJhbmsmJjA+Yy5taW5SYW5rJiYoYVtjLnRlbXBbMF1dLnB1c2goYyksYy5tYXhSYW5rPWMudGVtcFswXSxjLm1pblJhbms9Yy50ZW1wWzBdLGMudGVtcFswXT1hW2MubWF4UmFua10ubGVuZ3RoLTEpO2lmKG51bGwhPWImJm51bGwhPWQmJjE8Yi5tYXhSYW5rLWMubWF4UmFuaylmb3IoZC5tYXhSYW5rPWIubWF4UmFuayxkLm1pblJhbms9Yy5tYXhSYW5rLGQudGVtcD0KW10sZC54PVtdLGQueT1bXSxiPWQubWluUmFuaysxO2I8ZC5tYXhSYW5rO2IrKylhW2JdLnB1c2goZCksZC5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGIsYVtiXS5sZW5ndGgtMSl9LGMsITEsbnVsbCl9O214R3JhcGhIaWVyYXJjaHlNb2RlbC5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9Yil7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspe3ZhciBmPWJbZV07bnVsbCE9ZiYmKG51bGw9PWQmJihkPXt9KSxjPyhmLmhhc2hDb2RlPVtdLGYuaGFzaENvZGVbMF09dGhpcy5kZnNDb3VudCxmLmhhc2hDb2RlWzFdPWUsdGhpcy5leHRlbmRlZERmcyhudWxsLGYsbnVsbCxhLGQsZi5oYXNoQ29kZSxlLDApKTp0aGlzLmRmcyhudWxsLGYsbnVsbCxhLGQsMCkpfXRoaXMuZGZzQ291bnQrK319OwpteEdyYXBoSGllcmFyY2h5TW9kZWwucHJvdG90eXBlLmRmcz1mdW5jdGlvbihhLGIsYyxkLGUsZil7aWYobnVsbCE9Yil7dmFyIGc9Yi5pZDtpZihudWxsPT1lW2ddKWZvcihlW2ddPWIsZChhLGIsYyxmLDApLGE9Yi5jb25uZWN0c0FzU291cmNlLnNsaWNlKCksYz0wO2M8YS5sZW5ndGg7YysrKWc9YVtjXSx0aGlzLmRmcyhiLGcudGFyZ2V0LGcsZCxlLGYrMSk7ZWxzZSBkKGEsYixjLGYsMSl9fTsKbXhHcmFwaEhpZXJhcmNoeU1vZGVsLnByb3RvdHlwZS5leHRlbmRlZERmcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2lmKG51bGwhPWIpaWYobnVsbD09YXx8bnVsbCE9Yi5oYXNoQ29kZSYmYi5oYXNoQ29kZVswXT09YS5oYXNoQ29kZVswXXx8KGY9YS5oYXNoQ29kZS5sZW5ndGgrMSxiLmhhc2hDb2RlPWEuaGFzaENvZGUuc2xpY2UoKSxiLmhhc2hDb2RlW2YtMV09ZyksZz1iLmlkLG51bGw9PWVbZ10pZm9yKGVbZ109YixkKGEsYixjLGssMCksYT1iLmNvbm5lY3RzQXNTb3VyY2Uuc2xpY2UoKSxjPTA7YzxhLmxlbmd0aDtjKyspZz1hW2NdLHRoaXMuZXh0ZW5kZWREZnMoYixnLnRhcmdldCxnLGQsZSxiLmhhc2hDb2RlLGMsaysxKTtlbHNlIGQoYSxiLGMsaywxKX07CmZ1bmN0aW9uIG14U3dpbWxhbmVNb2RlbChhLGIsYyxkLGUpe2EuZ2V0R3JhcGgoKTt0aGlzLnRpZ2h0ZW5Ub1NvdXJjZT1lO3RoaXMucm9vdHM9Yzt0aGlzLnBhcmVudD1kO3RoaXMudmVydGV4TWFwcGVyPW5ldyBteERpY3Rpb25hcnk7dGhpcy5lZGdlTWFwcGVyPW5ldyBteERpY3Rpb25hcnk7dGhpcy5tYXhSYW5rPTA7Yz1bXTtudWxsPT1iJiYoYj10aGlzLmdyYXBoLmdldENoaWxkVmVydGljZXMoZCkpO3RoaXMubWF4UmFuaz10aGlzLlNPVVJDRVNDQU5TVEFSVFJBTks7dGhpcy5jcmVhdGVJbnRlcm5hbENlbGxzKGEsYixjKTtmb3IoZD0wO2Q8Yi5sZW5ndGg7ZCsrKXtlPWNbZF0uY29ubmVjdHNBc1NvdXJjZTtmb3IodmFyIGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGc9ZVtmXSxrPWcuZWRnZXM7aWYobnVsbCE9ayYmMDxrLmxlbmd0aCl7dmFyIGs9a1swXSxsPWEuZ2V0VmlzaWJsZVRlcm1pbmFsKGssITEpLGw9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KGwpO2NbZF09PWwmJihsPQphLmdldFZpc2libGVUZXJtaW5hbChrLCEwKSxsPXRoaXMudmVydGV4TWFwcGVyLmdldChsKSk7bnVsbCE9bCYmY1tkXSE9bCYmKGcudGFyZ2V0PWwsMD09bC5jb25uZWN0c0FzVGFyZ2V0Lmxlbmd0aCYmKGwuY29ubmVjdHNBc1RhcmdldD1bXSksMD5teFV0aWxzLmluZGV4T2YobC5jb25uZWN0c0FzVGFyZ2V0LGcpJiZsLmNvbm5lY3RzQXNUYXJnZXQucHVzaChnKSl9fWNbZF0udGVtcFswXT0xfX1teFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLm1heFJhbms9bnVsbDtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLnZlcnRleE1hcHBlcj1udWxsO214U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuZWRnZU1hcHBlcj1udWxsO214U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUucmFua3M9bnVsbDtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLnJvb3RzPW51bGw7bXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5wYXJlbnQ9bnVsbDtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLmRmc0NvdW50PTA7Cm14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuU09VUkNFU0NBTlNUQVJUUkFOSz0xRTg7bXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS50aWdodGVuVG9Tb3VyY2U9ITE7bXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5yYW5rc1Blckdyb3VwPW51bGw7Cm14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuY3JlYXRlSW50ZXJuYWxDZWxscz1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEuZ2V0R3JhcGgoKSxlPWEuc3dpbWxhbmVzLGY9MDtmPGIubGVuZ3RoO2YrKyl7Y1tmXT1uZXcgbXhHcmFwaEhpZXJhcmNoeU5vZGUoYltmXSk7dGhpcy52ZXJ0ZXhNYXBwZXIucHV0KGJbZl0sY1tmXSk7Y1tmXS5zd2ltbGFuZUluZGV4PS0xO2Zvcih2YXIgZz0wO2c8ZS5sZW5ndGg7ZysrKWlmKGQubW9kZWwuZ2V0UGFyZW50KGJbZl0pPT1lW2ddKXtjW2ZdLnN3aW1sYW5lSW5kZXg9ZzticmVha31nPWEuZ2V0RWRnZXMoYltmXSk7Y1tmXS5jb25uZWN0c0FzU291cmNlPVtdO2Zvcih2YXIgaz0wO2s8Zy5sZW5ndGg7aysrKXt2YXIgbD1hLmdldFZpc2libGVUZXJtaW5hbChnW2tdLCExKTtpZihsIT1iW2ZdJiZhLmdyYXBoLm1vZGVsLmlzVmVydGV4KGwpJiYhYS5pc1ZlcnRleElnbm9yZWQobCkpe3ZhciBtPWEuZ2V0RWRnZXNCZXR3ZWVuKGJbZl0sbCwhMSksCmw9YS5nZXRFZGdlc0JldHdlZW4oYltmXSxsLCEwKTtpZihudWxsIT1tJiYwPG0ubGVuZ3RoJiZudWxsPT10aGlzLmVkZ2VNYXBwZXIuZ2V0KG1bMF0pJiYyKmwubGVuZ3RoPj1tLmxlbmd0aCl7Zm9yKHZhciBsPW5ldyBteEdyYXBoSGllcmFyY2h5RWRnZShtKSxuPTA7bjxtLmxlbmd0aDtuKyspe3ZhciBwPW1bbl07dGhpcy5lZGdlTWFwcGVyLnB1dChwLGwpO2QucmVzZXRFZGdlKHApO2EuZGlzYWJsZUVkZ2VTdHlsZSYmKGEuc2V0RWRnZVN0eWxlRW5hYmxlZChwLCExKSxhLnNldE9ydGhvZ29uYWxFZGdlKHAsITApKX1sLnNvdXJjZT1jW2ZdOzA+bXhVdGlscy5pbmRleE9mKGNbZl0uY29ubmVjdHNBc1NvdXJjZSxsKSYmY1tmXS5jb25uZWN0c0FzU291cmNlLnB1c2gobCl9fX1jW2ZdLnRlbXBbMF09MH19OwpteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLmluaXRpYWxSYW5rPWZ1bmN0aW9uKCl7dGhpcy5yYW5rc1Blckdyb3VwPVtdO3ZhciBhPVtdLGI9e307aWYobnVsbCE9dGhpcy5yb290cylmb3IodmFyIGM9MDtjPHRoaXMucm9vdHMubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy52ZXJ0ZXhNYXBwZXIuZ2V0KHRoaXMucm9vdHNbY10pO3RoaXMubWF4Q2hhaW5EZnMobnVsbCxkLG51bGwsYiwwKTtudWxsIT1kJiZhLnB1c2goZCl9ZD1bXTtiPVtdO2ZvcihjPXRoaXMucmFua3NQZXJHcm91cC5sZW5ndGgtMTswPD1jO2MtLSlkW2NdPWM9PXRoaXMucmFua3NQZXJHcm91cC5sZW5ndGgtMT8wOmJbYysxXSsxLGJbY109ZFtjXSt0aGlzLnJhbmtzUGVyR3JvdXBbY107dGhpcy5tYXhSYW5rPWJbMF07ZD10aGlzLnZlcnRleE1hcHBlci5nZXRWYWx1ZXMoKTtmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKWRbY10udGVtcFswXT0tMTtmb3IoYS5zbGljZSgpOzA8YS5sZW5ndGg7KXt2YXIgZD1hWzBdLGUsZjsKZT1kLmNvbm5lY3RzQXNUYXJnZXQ7Zj1kLmNvbm5lY3RzQXNTb3VyY2U7Zm9yKHZhciBnPSEwLGs9YlswXSxjPTA7YzxlLmxlbmd0aDtjKyspe3ZhciBsPWVbY107aWYoNTI3MDYyMD09bC50ZW1wWzBdKWw9bC5zb3VyY2Usaz1NYXRoLm1pbihrLGwudGVtcFswXS0xKTtlbHNle2c9ITE7YnJlYWt9fWlmKGcpe2s+YltkLnN3aW1sYW5lSW5kZXhdJiYoaz1iW2Quc3dpbWxhbmVJbmRleF0pO2QudGVtcFswXT1rO2lmKG51bGwhPWYpZm9yKGM9MDtjPGYubGVuZ3RoO2MrKylsPWZbY10sbC50ZW1wWzBdPTUyNzA2MjAsbD1sLnRhcmdldCwtMT09bC50ZW1wWzBdJiYoYS5wdXNoKGwpLGwudGVtcFswXT0tMik7YS5zaGlmdCgpfWVsc2UgaWYoYz1hLnNoaWZ0KCksYS5wdXNoKGQpLGM9PWQmJjE9PWEubGVuZ3RoKWJyZWFrfX07Cm14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUubWF4Q2hhaW5EZnM9ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZihudWxsIT1iJiYoYT1teENlbGxQYXRoLmNyZWF0ZShiLmNlbGwpLG51bGw9PWRbYV0pKXtkW2FdPWI7YT1iLnN3aW1sYW5lSW5kZXg7aWYobnVsbD09dGhpcy5yYW5rc1Blckdyb3VwW2FdfHx0aGlzLnJhbmtzUGVyR3JvdXBbYV08ZSl0aGlzLnJhbmtzUGVyR3JvdXBbYV09ZTthPWIuY29ubmVjdHNBc1NvdXJjZS5zbGljZSgpO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBmPWFbY10sZz1mLnRhcmdldDtiLnN3aW1sYW5lSW5kZXg8Zy5zd2ltbGFuZUluZGV4P3RoaXMubWF4Q2hhaW5EZnMoYixnLGYsbXhVdGlscy5jbG9uZShkLG51bGwsITApLDApOmIuc3dpbWxhbmVJbmRleD09Zy5zd2ltbGFuZUluZGV4JiZ0aGlzLm1heENoYWluRGZzKGIsZyxmLG14VXRpbHMuY2xvbmUoZCxudWxsLCEwKSxlKzEpfX19OwpteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLmZpeFJhbmtzPWZ1bmN0aW9uKCl7dmFyIGE9W107dGhpcy5yYW5rcz1bXTtmb3IodmFyIGI9MDtiPHRoaXMubWF4UmFuaysxO2IrKylhW2JdPVtdLHRoaXMucmFua3NbYl09YVtiXTt2YXIgYz1udWxsO2lmKG51bGwhPXRoaXMucm9vdHMpZm9yKHZhciBkPXRoaXMucm9vdHMsYz1bXSxiPTA7YjxkLmxlbmd0aDtiKyspe3ZhciBlPXRoaXMudmVydGV4TWFwcGVyLmdldChkW2JdKTtjW2JdPWV9dGhpcy52aXNpdChmdW5jdGlvbihiLGMsZCxlLG0pezA9PW0mJjA+Yy5tYXhSYW5rJiYwPmMubWluUmFuayYmKGFbYy50ZW1wWzBdXS5wdXNoKGMpLGMubWF4UmFuaz1jLnRlbXBbMF0sYy5taW5SYW5rPWMudGVtcFswXSxjLnRlbXBbMF09YVtjLm1heFJhbmtdLmxlbmd0aC0xKTtpZihudWxsIT1iJiZudWxsIT1kJiYxPGIubWF4UmFuay1jLm1heFJhbmspZm9yKGQubWF4UmFuaz1iLm1heFJhbmssZC5taW5SYW5rPWMubWF4UmFuayxkLnRlbXA9W10sCmQueD1bXSxkLnk9W10sYj1kLm1pblJhbmsrMTtiPGQubWF4UmFuaztiKyspYVtiXS5wdXNoKGQpLGQuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShiLGFbYl0ubGVuZ3RoLTEpfSxjLCExLG51bGwpfTtteFN3aW1sYW5lTW9kZWwucHJvdG90eXBlLnZpc2l0PWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPWIpe2Zvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgZj1iW2VdO251bGwhPWYmJihudWxsPT1kJiYoZD17fSksYz8oZi5oYXNoQ29kZT1bXSxmLmhhc2hDb2RlWzBdPXRoaXMuZGZzQ291bnQsZi5oYXNoQ29kZVsxXT1lLHRoaXMuZXh0ZW5kZWREZnMobnVsbCxmLG51bGwsYSxkLGYuaGFzaENvZGUsZSwwKSk6dGhpcy5kZnMobnVsbCxmLG51bGwsYSxkLDApKX10aGlzLmRmc0NvdW50Kyt9fTsKbXhTd2ltbGFuZU1vZGVsLnByb3RvdHlwZS5kZnM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKG51bGwhPWIpe3ZhciBnPWIuaWQ7aWYobnVsbD09ZVtnXSlmb3IoZVtnXT1iLGQoYSxiLGMsZiwwKSxhPWIuY29ubmVjdHNBc1NvdXJjZS5zbGljZSgpLGM9MDtjPGEubGVuZ3RoO2MrKylnPWFbY10sdGhpcy5kZnMoYixnLnRhcmdldCxnLGQsZSxmKzEpO2Vsc2UgZChhLGIsYyxmLDEpfX07Cm14U3dpbWxhbmVNb2RlbC5wcm90b3R5cGUuZXh0ZW5kZWREZnM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrKXtpZihudWxsIT1iKWlmKG51bGw9PWF8fG51bGwhPWIuaGFzaENvZGUmJmIuaGFzaENvZGVbMF09PWEuaGFzaENvZGVbMF18fChmPWEuaGFzaENvZGUubGVuZ3RoKzEsYi5oYXNoQ29kZT1hLmhhc2hDb2RlLnNsaWNlKCksYi5oYXNoQ29kZVtmLTFdPWcpLGc9Yi5pZCxudWxsPT1lW2ddKXtlW2ddPWI7ZChhLGIsYyxrLDApO2E9Yi5jb25uZWN0c0FzU291cmNlLnNsaWNlKCk7Yz1iLmNvbm5lY3RzQXNUYXJnZXQuc2xpY2UoKTtmb3IoZz0wO2c8YS5sZW5ndGg7ZysrKXtmPWFbZ107dmFyIGw9Zi50YXJnZXQ7Yi5zd2ltbGFuZUluZGV4PD1sLnN3aW1sYW5lSW5kZXgmJnRoaXMuZXh0ZW5kZWREZnMoYixsLGYsZCxlLGIuaGFzaENvZGUsZyxrKzEpfWZvcihnPTA7ZzxjLmxlbmd0aDtnKyspZj1jW2ddLGw9Zi5zb3VyY2UsYi5zd2ltbGFuZUluZGV4PGwuc3dpbWxhbmVJbmRleCYmCnRoaXMuZXh0ZW5kZWREZnMoYixsLGYsZCxlLGIuaGFzaENvZGUsZyxrKzEpfWVsc2UgZChhLGIsYyxrLDEpfTtmdW5jdGlvbiBteEhpZXJhcmNoaWNhbExheW91dFN0YWdlKCl7fW14SGllcmFyY2hpY2FsTGF5b3V0U3RhZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7fTtmdW5jdGlvbiBteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uKGEpe3RoaXMubGF5b3V0PWF9bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGU9bmV3IG14SGllcmFyY2hpY2FsTGF5b3V0U3RhZ2U7bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbjtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5sYXlvdXQ9bnVsbDtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5tYXhJdGVyYXRpb25zPTI0OwpteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5uZXN0ZWRCZXN0UmFua3M9bnVsbDtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5jdXJyZW50QmVzdENyb3NzaW5ncz0wO214TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLml0ZXJhdGlvbnNXaXRob3V0SW1wcm92ZW1lbnQ9MDtteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5tYXhOb0ltcHJvdmVtZW50SXRlcmF0aW9ucz0yOwpteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2E9dGhpcy5sYXlvdXQuZ2V0TW9kZWwoKTt0aGlzLm5lc3RlZEJlc3RSYW5rcz1bXTtmb3IodmFyIGI9MDtiPGEucmFua3MubGVuZ3RoO2IrKyl0aGlzLm5lc3RlZEJlc3RSYW5rc1tiXT1hLnJhbmtzW2JdLnNsaWNlKCk7Zm9yKHZhciBjPTAsZD10aGlzLmNhbGN1bGF0ZUNyb3NzaW5ncyhhKSxiPTA7Yjx0aGlzLm1heEl0ZXJhdGlvbnMmJmM8dGhpcy5tYXhOb0ltcHJvdmVtZW50SXRlcmF0aW9ucztiKyspe3RoaXMud2VpZ2h0ZWRNZWRpYW4oYixhKTt0aGlzLnRyYW5zcG9zZShiLGEpO3ZhciBlPXRoaXMuY2FsY3VsYXRlQ3Jvc3NpbmdzKGEpO2lmKGU8ZClmb3IoZD1lLGU9Yz0wO2U8dGhpcy5uZXN0ZWRCZXN0UmFua3MubGVuZ3RoO2UrKylmb3IodmFyIGY9YS5yYW5rc1tlXSxnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBrPWZbZ107dGhpcy5uZXN0ZWRCZXN0UmFua3NbZV1bay5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGUpXT0Ka31lbHNlIGZvcihjKyssZT0wO2U8dGhpcy5uZXN0ZWRCZXN0UmFua3MubGVuZ3RoO2UrKylmb3IoZj1hLnJhbmtzW2VdLGc9MDtnPGYubGVuZ3RoO2crKylrPWZbZ10say5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGUsZyk7aWYoMD09ZClicmVha31jPVtdO2Q9W107Zm9yKGI9MDtiPGEubWF4UmFuaysxO2IrKylkW2JdPVtdLGNbYl09ZFtiXTtmb3IoYj0wO2I8dGhpcy5uZXN0ZWRCZXN0UmFua3MubGVuZ3RoO2IrKylmb3IoZT0wO2U8dGhpcy5uZXN0ZWRCZXN0UmFua3NbYl0ubGVuZ3RoO2UrKylkW2JdLnB1c2godGhpcy5uZXN0ZWRCZXN0UmFua3NbYl1bZV0pO2EucmFua3M9Y307bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlQ3Jvc3NpbmdzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLnJhbmtzLmxlbmd0aCxjPTAsZD0xO2Q8YjtkKyspYys9dGhpcy5jYWxjdWxhdGVSYW5rQ3Jvc3NpbmcoZCxhKTtyZXR1cm4gY307Cm14TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLmNhbGN1bGF0ZVJhbmtDcm9zc2luZz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9Yi5yYW5rc1thXSxlPWIucmFua3NbYS0xXSxmPVtdLGc9MDtnPGQubGVuZ3RoO2crKyl7Zm9yKHZhciBrPWRbZ10sbD1rLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSksaz1rLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhhKSxtPVtdLG49MDtuPGsubGVuZ3RoO24rKyl7dmFyIHA9a1tuXS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEtMSk7bS5wdXNoKHApfW0uc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9KTtmW2xdPW19ZD1bXTtmb3IoZz0wO2c8Zi5sZW5ndGg7ZysrKWQ9ZC5jb25jYXQoZltnXSk7Zm9yKGY9MTtmPGUubGVuZ3RoOylmPDw9MTtsPTIqZi0xOy0tZjtlPVtdO2ZvcihnPTA7ZzxsOysrZyllW2ddPTA7Zm9yKGc9MDtnPGQubGVuZ3RoO2crKylmb3IobD1kW2ddK2YsKytlW2xdOzA8Cmw7KWwlMiYmKGMrPWVbbCsxXSksbD1sLTE+PjEsKytlW2xdO3JldHVybiBjfTsKbXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPSEwLGQ9MDtjJiYxMD5kKys7KWZvcih2YXIgZT0xPT1hJTImJjE9PWQlMixjPSExLGY9MDtmPGIucmFua3MubGVuZ3RoO2YrKyl7Zm9yKHZhciBnPWIucmFua3NbZl0saz1bXSxsPTA7bDxnLmxlbmd0aDtsKyspe3ZhciBtPWdbbF0sbj1tLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZik7MD5uJiYobj1sKTtrW25dPW19Zm9yKHZhciBwPW51bGwscT1udWxsLHIsdCx1PW51bGwseD1udWxsLHksQj1udWxsLGw9MDtsPGcubGVuZ3RoLTE7bCsrKXtpZigwPT1sKXt5PWtbbF07bT15LmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzKGYpO249eS5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMoZik7cj1bXTt0PVtdO2Zvcih2YXIgQT0wO0E8bS5sZW5ndGg7QSsrKXJbQV09bVtBXS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGYrMSk7Zm9yKEE9CjA7QTxuLmxlbmd0aDtBKyspdFtBXT1uW0FdLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZi0xKX1lbHNlIG09cCxuPXEscj11LHQ9eCx5PUI7Qj1rW2wrMV07cD1CLmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzKGYpO3E9Qi5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMoZik7dT1bXTt4PVtdO2ZvcihBPTA7QTxwLmxlbmd0aDtBKyspdVtBXT1wW0FdLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZisxKTtmb3IoQT0wO0E8cS5sZW5ndGg7QSsrKXhbQV09cVtBXS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGYtMSk7Zm9yKHZhciB6PTAsQz0wLEE9MDtBPHIubGVuZ3RoO0ErKylmb3IodmFyIHY9MDt2PHUubGVuZ3RoO3YrKylyW0FdPnVbdl0mJnorKyxyW0FdPHVbdl0mJkMrKztmb3IoQT0wO0E8dC5sZW5ndGg7QSsrKWZvcih2PTA7djx4Lmxlbmd0aDt2KyspdFtBXT54W3ZdJiZ6KyssdFtBXTx4W3ZdJiZDKys7aWYoQzx6fHxDPT16JiZlKXA9eS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGYpLAp5LnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZixCLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZikpLEIuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShmLHApLHA9bSxxPW4sdT1yLHg9dCxCPXksZXx8KGM9ITApfX19O214TWVkaWFuSHlicmlkQ3Jvc3NpbmdSZWR1Y3Rpb24ucHJvdG90eXBlLndlaWdodGVkTWVkaWFuPWZ1bmN0aW9uKGEsYil7dmFyIGM9MD09YSUyO2lmKGMpZm9yKHZhciBkPWIubWF4UmFuay0xOzA8PWQ7ZC0tKXRoaXMubWVkaWFuUmFuayhkLGMpO2Vsc2UgZm9yKGQ9MTtkPGIubWF4UmFuaztkKyspdGhpcy5tZWRpYW5SYW5rKGQsYyl9OwpteE1lZGlhbkh5YnJpZENyb3NzaW5nUmVkdWN0aW9uLnByb3RvdHlwZS5tZWRpYW5SYW5rPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMubmVzdGVkQmVzdFJhbmtzW2FdLmxlbmd0aCxkPVtdLGU9W10sZj0wO2Y8YztmKyspe3ZhciBnPXRoaXMubmVzdGVkQmVzdFJhbmtzW2FdW2ZdLGs9bmV3IE1lZGlhbkNlbGxTb3J0ZXI7ay5jZWxsPWc7dmFyIGw7bD1iP2cuZ2V0TmV4dExheWVyQ29ubmVjdGVkQ2VsbHMoYSk6Zy5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMoYSk7dmFyIG07bT1iP2ErMTphLTE7bnVsbCE9bCYmMCE9bC5sZW5ndGg/KGsubWVkaWFuVmFsdWU9dGhpcy5tZWRpYW5WYWx1ZShsLG0pLGQucHVzaChrKSk6ZVtnLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSldPSEwfWQuc29ydChNZWRpYW5DZWxsU29ydGVyLnByb3RvdHlwZS5jb21wYXJlKTtmb3IoZj0wO2Y8YztmKyspbnVsbD09ZVtmXSYmKGc9ZC5zaGlmdCgpLmNlbGwsZy5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEsCmYpKX07bXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbi5wcm90b3R5cGUubWVkaWFuVmFsdWU9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD0wLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGY9YVtlXTtjW2QrK109Zi5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGIpfWMuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9KTtpZigxPT1kJTIpcmV0dXJuIGNbTWF0aC5mbG9vcihkLzIpXTtpZigyPT1kKXJldHVybihjWzBdK2NbMV0pLzI7ZT1kLzI7Zj1jW2UtMV0tY1swXTtkPWNbZC0xXS1jW2VdO3JldHVybihjW2UtMV0qZCtjW2VdKmYpLyhmK2QpfTtmdW5jdGlvbiBNZWRpYW5DZWxsU29ydGVyKCl7fU1lZGlhbkNlbGxTb3J0ZXIucHJvdG90eXBlLm1lZGlhblZhbHVlPTA7TWVkaWFuQ2VsbFNvcnRlci5wcm90b3R5cGUuY2VsbD0hMTsKTWVkaWFuQ2VsbFNvcnRlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hJiZudWxsIT1iP2IubWVkaWFuVmFsdWU+YS5tZWRpYW5WYWx1ZT8tMTpiLm1lZGlhblZhbHVlPGEubWVkaWFuVmFsdWU/MTowOjB9O2Z1bmN0aW9uIG14TWluaW11bUN5Y2xlUmVtb3ZlcihhKXt0aGlzLmxheW91dD1hfW14TWluaW11bUN5Y2xlUmVtb3Zlci5wcm90b3R5cGU9bmV3IG14SGllcmFyY2hpY2FsTGF5b3V0U3RhZ2U7bXhNaW5pbXVtQ3ljbGVSZW1vdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teE1pbmltdW1DeWNsZVJlbW92ZXI7bXhNaW5pbXVtQ3ljbGVSZW1vdmVyLnByb3RvdHlwZS5sYXlvdXQ9bnVsbDsKbXhNaW5pbXVtQ3ljbGVSZW1vdmVyLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2E9dGhpcy5sYXlvdXQuZ2V0TW9kZWwoKTtmb3IodmFyIGI9e30sYz1hLnZlcnRleE1hcHBlci5nZXRWYWx1ZXMoKSxkPXt9LGU9MDtlPGMubGVuZ3RoO2UrKylkW2NbZV0uaWRdPWNbZV07Yz1udWxsO2lmKG51bGwhPWEucm9vdHMpZm9yKHZhciBmPWEucm9vdHMsYz1bXSxlPTA7ZTxmLmxlbmd0aDtlKyspY1tlXT1hLnZlcnRleE1hcHBlci5nZXQoZltlXSk7YS52aXNpdChmdW5jdGlvbihhLGMsZSxmLG4pe2MuaXNBbmNlc3RvcihhKSYmKGUuaW52ZXJ0KCksbXhVdGlscy5yZW1vdmUoZSxhLmNvbm5lY3RzQXNTb3VyY2UpLGEuY29ubmVjdHNBc1RhcmdldC5wdXNoKGUpLG14VXRpbHMucmVtb3ZlKGUsYy5jb25uZWN0c0FzVGFyZ2V0KSxjLmNvbm5lY3RzQXNTb3VyY2UucHVzaChlKSk7YltjLmlkXT1jO2RlbGV0ZSBkW2MuaWRdfSxjLCEwLG51bGwpO2U9bXhVdGlscy5jbG9uZShiLG51bGwsCiEwKTthLnZpc2l0KGZ1bmN0aW9uKGEsYyxlLGYsbil7Yy5pc0FuY2VzdG9yKGEpJiYoZS5pbnZlcnQoKSxteFV0aWxzLnJlbW92ZShlLGEuY29ubmVjdHNBc1NvdXJjZSksYy5jb25uZWN0c0FzU291cmNlLnB1c2goZSksYS5jb25uZWN0c0FzVGFyZ2V0LnB1c2goZSksbXhVdGlscy5yZW1vdmUoZSxjLmNvbm5lY3RzQXNUYXJnZXQpKTtiW2MuaWRdPWM7ZGVsZXRlIGRbYy5pZF19LGQsITAsZSl9O2Z1bmN0aW9uIG14Q29vcmRpbmF0ZUFzc2lnbm1lbnQoYSxiLGMsZCxlLGYpe3RoaXMubGF5b3V0PWE7dGhpcy5pbnRyYUNlbGxTcGFjaW5nPWI7dGhpcy5pbnRlclJhbmtDZWxsU3BhY2luZz1jO3RoaXMub3JpZW50YXRpb249ZDt0aGlzLmluaXRpYWxYPWU7dGhpcy5wYXJhbGxlbEVkZ2VTcGFjaW5nPWZ9bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGU9bmV3IG14SGllcmFyY2hpY2FsTGF5b3V0U3RhZ2U7Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14Q29vcmRpbmF0ZUFzc2lnbm1lbnQ7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUubGF5b3V0PW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuaW50cmFDZWxsU3BhY2luZz0zMDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5pbnRlclJhbmtDZWxsU3BhY2luZz0xMDA7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUucGFyYWxsZWxFZGdlU3BhY2luZz0xMDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5tYXhJdGVyYXRpb25zPTg7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUucHJlZkhvekVkZ2VTZXA9NTtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5wcmVmVmVydEVkZ2VPZmY9MjtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5taW5FZGdlSmV0dHk9MTI7Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmNoYW5uZWxCdWZmZXI9NDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5qZXR0eVBvc2l0aW9ucz1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm9yaWVudGF0aW9uPW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5pbml0aWFsWD1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmxpbWl0WD1udWxsO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmN1cnJlbnRYRGVsdGE9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS53aWRlc3RSYW5rPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUucmFua1RvcFk9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5yYW5rQm90dG9tWT1udWxsOwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS53aWRlc3RSYW5rVmFsdWU9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5yYW5rV2lkdGhzPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUucmFua1k9bnVsbDtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5maW5lVHVuaW5nPSEwO214Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm5leHRMYXllckNvbm5lY3RlZENhY2hlPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUucHJldmlvdXNMYXllckNvbm5lY3RlZENhY2hlPW51bGw7bXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuZ3JvdXBQYWRkaW5nPTEwOwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5wcmludFN0YXR1cz1mdW5jdGlvbigpe3ZhciBhPXRoaXMubGF5b3V0LmdldE1vZGVsKCk7bXhMb2cuc2hvdygpO214TG9nLndyaXRlbG4oIj09PT09PUNvb3JkIGFzc2lnbm1lbnQgZGVidWc9PT09PT09Iik7Zm9yKHZhciBiPTA7YjxhLnJhbmtzLmxlbmd0aDtiKyspe214TG9nLndyaXRlKCJSYW5rICIsYiwiIDogIik7Zm9yKHZhciBjPWEucmFua3NbYl0sZD0wO2Q8Yy5sZW5ndGg7ZCsrKW14TG9nLndyaXRlKGNbZF0uZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShiKSwiICAiKTtteExvZy53cml0ZWxuKCl9bXhMb2cud3JpdGVsbigiPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Iil9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe3RoaXMuamV0dHlQb3NpdGlvbnM9e307YT10aGlzLmxheW91dC5nZXRNb2RlbCgpO3RoaXMuY3VycmVudFhEZWx0YT0wO3RoaXMuaW5pdGlhbENvb3Jkcyh0aGlzLmxheW91dC5nZXRHcmFwaCgpLGEpO3RoaXMuZmluZVR1bmluZyYmdGhpcy5taW5Ob2RlKGEpO3ZhciBiPTFFODtpZih0aGlzLmZpbmVUdW5pbmcpZm9yKHZhciBjPTA7Yzx0aGlzLm1heEl0ZXJhdGlvbnM7YysrKXswIT1jJiYodGhpcy5tZWRpYW5Qb3MoYyxhKSx0aGlzLm1pbk5vZGUoYSkpO2lmKHRoaXMuY3VycmVudFhEZWx0YTxiKXtmb3IodmFyIGQ9MDtkPGEucmFua3MubGVuZ3RoO2QrKylmb3IodmFyIGU9YS5yYW5rc1tkXSxmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl07Zy5zZXRYKGQsZy5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGQpKX1iPXRoaXMuY3VycmVudFhEZWx0YX1lbHNlIGZvcihkPTA7ZDxhLnJhbmtzLmxlbmd0aDtkKyspZm9yKGU9CmEucmFua3NbZF0sZj0wO2Y8ZS5sZW5ndGg7ZisrKWc9ZVtmXSxnLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoZCxnLmdldFgoZCkpO3RoaXMubWluUGF0aCh0aGlzLmxheW91dC5nZXRHcmFwaCgpLGEpO3RoaXMuY3VycmVudFhEZWx0YT0wfXRoaXMuc2V0Q2VsbExvY2F0aW9ucyh0aGlzLmxheW91dC5nZXRHcmFwaCgpLGEpfTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUubWluTm9kZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz1uZXcgbXhEaWN0aW9uYXJ5LGQ9W10sZT0wO2U8PWEubWF4UmFuaztlKyspe2RbZV09YS5yYW5rc1tlXTtmb3IodmFyIGY9MDtmPGRbZV0ubGVuZ3RoO2YrKyl7dmFyIGc9ZFtlXVtmXSxrPW5ldyBXZWlnaHRlZENlbGxTb3J0ZXIoZyxlKTtrLnJhbmtJbmRleD1mO2sudmlzaXRlZD0hMDtiLnB1c2goayk7Yy5wdXQoZyxrKX19YT0xMCpiLmxlbmd0aDtmb3IoZj0wOzA8Yi5sZW5ndGgmJmY8PWE7KXt2YXIgZz1iLnNoaWZ0KCksZT1nLmNlbGwsbD1nLndlaWdodGVkVmFsdWUsbT1wYXJzZUludChnLnJhbmtJbmRleCksaz1lLmdldE5leHRMYXllckNvbm5lY3RlZENlbGxzKGwpLG49ZS5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMobCkscD1rLmxlbmd0aCxxPW4ubGVuZ3RoLHI9dGhpcy5tZWRpYW5YVmFsdWUoayxsKzEpLHQ9dGhpcy5tZWRpYW5YVmFsdWUobiwKbC0xKSx1PXArcSx4PWUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsKSx5PXg7MDx1JiYoeT0ocipwK3QqcSkvdSk7cD0hMTt5PHgtMT8wPT1tPyhlLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUobCx5KSxwPSEwKToobT1kW2xdW20tMV0seD1tLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUobCkseD14K20ud2lkdGgvMit0aGlzLmludHJhQ2VsbFNwYWNpbmcrZS53aWR0aC8yLHg8eT8oZS5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGwseSkscD0hMCk6eDxlLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUobCktMSYmKGUuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsLHgpLHA9ITApKTp5PngrMSYmKG09PWRbbF0ubGVuZ3RoLTE/KGUuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsLHkpLHA9ITApOihtPWRbbF1bbSsxXSx4PW0uZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsKSx4PXgtbS53aWR0aC8yLXRoaXMuaW50cmFDZWxsU3BhY2luZy1lLndpZHRoLzIseD55PyhlLnNldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUobCwKeSkscD0hMCk6eD5lLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUobCkrMSYmKGUuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsLHgpLHA9ITApKSk7aWYocCl7Zm9yKGU9MDtlPGsubGVuZ3RoO2UrKylsPWtbZV0sbD1jLmdldChsKSxudWxsIT1sJiYwPT1sLnZpc2l0ZWQmJihsLnZpc2l0ZWQ9ITAsYi5wdXNoKGwpKTtmb3IoZT0wO2U8bi5sZW5ndGg7ZSsrKWw9bltlXSxsPWMuZ2V0KGwpLG51bGwhPWwmJjA9PWwudmlzaXRlZCYmKGwudmlzaXRlZD0hMCxiLnB1c2gobCkpfWcudmlzaXRlZD0hMTtmKyt9fTtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5tZWRpYW5Qb3M9ZnVuY3Rpb24oYSxiKXtpZigwPT1hJTIpZm9yKHZhciBjPWIubWF4UmFuazswPGM7Yy0tKXRoaXMucmFua01lZGlhblBvc2l0aW9uKGMtMSxiLGMpO2Vsc2UgZm9yKGM9MDtjPGIubWF4UmFuay0xO2MrKyl0aGlzLnJhbmtNZWRpYW5Qb3NpdGlvbihjKzEsYixjKX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLnJhbmtNZWRpYW5Qb3NpdGlvbj1mdW5jdGlvbihhLGIsYyl7Yj1iLnJhbmtzW2FdO2Zvcih2YXIgZD1bXSxlPXt9LGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGc9YltmXTtkW2ZdPW5ldyBXZWlnaHRlZENlbGxTb3J0ZXI7ZFtmXS5jZWxsPWc7ZFtmXS5yYW5rSW5kZXg9ZjtlW2cuaWRdPWRbZl07dmFyIGs7az1jPGE/Zy5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMoYSk6Zy5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscyhhKTtkW2ZdLndlaWdodGVkVmFsdWU9dGhpcy5jYWxjdWxhdGVkV2VpZ2h0ZWRWYWx1ZShnLGspfWQuc29ydChXZWlnaHRlZENlbGxTb3J0ZXIucHJvdG90eXBlLmNvbXBhcmUpO2ZvcihmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciBsLGc9ZFtmXS5jZWxsO2w9MDtrPWM8YT9nLmdldFByZXZpb3VzTGF5ZXJDb25uZWN0ZWRDZWxscyhhKS5zbGljZSgpOmcuZ2V0TmV4dExheWVyQ29ubmVjdGVkQ2VsbHMoYSkuc2xpY2UoKTsKbnVsbCE9ayYmKGw9ay5sZW5ndGgsbD0wPGw/dGhpcy5tZWRpYW5YVmFsdWUoayxjKTpnLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYSkpO3ZhciBtPTA7az0tMUU4O2Zvcih2YXIgbj1kW2ZdLnJhbmtJbmRleC0xOzA8PW47KXt2YXIgcD1lW2Jbbl0uaWRdO2lmKG51bGwhPXApe3ZhciBxPXAuY2VsbDtwLnZpc2l0ZWQ/KGs9cS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEpK3Eud2lkdGgvMit0aGlzLmludHJhQ2VsbFNwYWNpbmcrbStnLndpZHRoLzIsbj0tMSk6KG0rPXEud2lkdGgrdGhpcy5pbnRyYUNlbGxTcGFjaW5nLG4tLSl9fW09MDtxPTFFODtmb3Iobj1kW2ZdLnJhbmtJbmRleCsxO248ZC5sZW5ndGg7KWlmKHA9ZVtiW25dLmlkXSxudWxsIT1wKXt2YXIgcj1wLmNlbGw7cC52aXNpdGVkPyhxPXIuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShhKS1yLndpZHRoLzItdGhpcy5pbnRyYUNlbGxTcGFjaW5nLW0tZy53aWR0aC8yLG49ZC5sZW5ndGgpOihtKz1yLndpZHRoKwp0aGlzLmludHJhQ2VsbFNwYWNpbmcsbisrKX1sPj1rJiZsPD1xP2cuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShhLGwpOmw8az8oZy5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEsayksdGhpcy5jdXJyZW50WERlbHRhKz1rLWwpOmw+cSYmKGcuc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShhLHEpLHRoaXMuY3VycmVudFhEZWx0YSs9bC1xKTtkW2ZdLnZpc2l0ZWQ9ITB9fTtteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5jYWxjdWxhdGVkV2VpZ2h0ZWRWYWx1ZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTthLmlzVmVydGV4KCkmJmUuaXNWZXJ0ZXgoKT9jKys6Yz1hLmlzRWRnZSgpJiZlLmlzRWRnZSgpP2MrODpjKzJ9cmV0dXJuIGN9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5tZWRpYW5YVmFsdWU9ZnVuY3Rpb24oYSxiKXtpZigwPT1hLmxlbmd0aClyZXR1cm4gMDtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCsrKWNbZF09YVtkXS5nZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGIpO2Muc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9KTtpZigxPT1hLmxlbmd0aCUyKXJldHVybiBjW01hdGguZmxvb3IoYS5sZW5ndGgvMildO2Q9YS5sZW5ndGgvMjtyZXR1cm4oY1tkLTFdK2NbZF0pLzJ9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5pbml0aWFsQ29vcmRzPWZ1bmN0aW9uKGEsYil7dGhpcy5jYWxjdWxhdGVXaWRlc3RSYW5rKGEsYik7Zm9yKHZhciBjPXRoaXMud2lkZXN0UmFuazswPD1jO2MtLSljPGIubWF4UmFuayYmdGhpcy5yYW5rQ29vcmRpbmF0ZXMoYyxhLGIpO2ZvcihjPXRoaXMud2lkZXN0UmFuaysxO2M8PWIubWF4UmFuaztjKyspMDxjJiZ0aGlzLnJhbmtDb29yZGluYXRlcyhjLGEsYil9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5yYW5rQ29vcmRpbmF0ZXM9ZnVuY3Rpb24oYSxiLGMpe2I9Yy5yYW5rc1thXTtjPXRoaXMuaW5pdGlhbFgrKHRoaXMud2lkZXN0UmFua1ZhbHVlLXRoaXMucmFua1dpZHRoc1thXSkvMjtmb3IodmFyIGQ9ITEsZT0wO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgZj1iW2VdO2lmKGYuaXNWZXJ0ZXgoKSl7dmFyIGc9dGhpcy5sYXlvdXQuZ2V0VmVydGV4Qm91bmRzKGYuY2VsbCk7bnVsbCE9Zz90aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD8oZi53aWR0aD1nLndpZHRoLGYuaGVpZ2h0PWcuaGVpZ2h0KTooZi53aWR0aD1nLmhlaWdodCxmLmhlaWdodD1nLndpZHRoKTpkPSEwfWVsc2UgZi5pc0VkZ2UoKSYmKGc9MSxudWxsIT1mLmVkZ2VzP2c9Zi5lZGdlcy5sZW5ndGg6bXhMb2cud2FybigiZWRnZS5lZGdlcyBpcyBudWxsIiksCmYud2lkdGg9KGctMSkqdGhpcy5wYXJhbGxlbEVkZ2VTcGFjaW5nKTtjKz1mLndpZHRoLzI7Zi5zZXRYKGEsYyk7Zi5zZXRHZW5lcmFsUHVycG9zZVZhcmlhYmxlKGEsYyk7Yys9Zi53aWR0aC8yO2MrPXRoaXMuaW50cmFDZWxsU3BhY2luZ30xPT1kJiZteExvZy53YXJuKCJBdCBsZWFzdCBvbmUgY2VsbCBoYXMgbm8gYm91bmRzIil9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5jYWxjdWxhdGVXaWRlc3RSYW5rPWZ1bmN0aW9uKGEsYil7dmFyIGM9LXRoaXMuaW50ZXJSYW5rQ2VsbFNwYWNpbmcsZD0wO3RoaXMucmFua1dpZHRocz1bXTt0aGlzLnJhbmtZPVtdO2Zvcih2YXIgZT1iLm1heFJhbms7MDw9ZTtlLS0pe2Zvcih2YXIgZj0wLGc9Yi5yYW5rc1tlXSxrPXRoaXMuaW5pdGlhbFgsbD0hMSxtPTA7bTxnLmxlbmd0aDttKyspe3ZhciBuPWdbbV07aWYobi5pc1ZlcnRleCgpKXt2YXIgcD10aGlzLmxheW91dC5nZXRWZXJ0ZXhCb3VuZHMobi5jZWxsKTtudWxsIT1wP3RoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhuLndpZHRoPXAud2lkdGgsbi5oZWlnaHQ9cC5oZWlnaHQpOihuLndpZHRoPXAuaGVpZ2h0LG4uaGVpZ2h0PXAud2lkdGgpOmw9ITA7Zj1NYXRoLm1heChmLG4uaGVpZ2h0KX1lbHNlIG4uaXNFZGdlKCkmJgoocD0xLG51bGwhPW4uZWRnZXM/cD1uLmVkZ2VzLmxlbmd0aDpteExvZy53YXJuKCJlZGdlLmVkZ2VzIGlzIG51bGwiKSxuLndpZHRoPShwLTEpKnRoaXMucGFyYWxsZWxFZGdlU3BhY2luZyk7ays9bi53aWR0aC8yO24uc2V0WChlLGspO24uc2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShlLGspO2srPW4ud2lkdGgvMjtrKz10aGlzLmludHJhQ2VsbFNwYWNpbmc7az50aGlzLndpZGVzdFJhbmtWYWx1ZSYmKHRoaXMud2lkZXN0UmFua1ZhbHVlPWssdGhpcy53aWRlc3RSYW5rPWUpO3RoaXMucmFua1dpZHRoc1tlXT1rfTE9PWwmJm14TG9nLndhcm4oIkF0IGxlYXN0IG9uZSBjZWxsIGhhcyBubyBib3VuZHMiKTt0aGlzLnJhbmtZW2VdPWM7az1mLzIrZC8yK3RoaXMuaW50ZXJSYW5rQ2VsbFNwYWNpbmc7ZD1mO2M9dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9jK2s6Yy0Kaztmb3IobT0wO208Zy5sZW5ndGg7bSsrKWdbbV0uc2V0WShlLGMpfX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLm1pblBhdGg9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5lZGdlTWFwcGVyLmdldFZhbHVlcygpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZighKDE+ZS5tYXhSYW5rLWUubWluUmFuay0xKSl7Zm9yKHZhciBmPWUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShlLm1pblJhbmsrMSksZz0hMCxrPTAsbD1lLm1pblJhbmsrMjtsPGUubWF4UmFuaztsKyspe3ZhciBtPWUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShsKTtmIT1tPyhnPSExLGY9bSk6aysrfWlmKCFnKXtmb3IodmFyIGc9Zj0wLG09W10sbj1bXSxwPWUuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShlLm1pblJhbmsrMSksbD1lLm1pblJhbmsrMTtsPGUubWF4UmFuay0xO2wrKyl7dmFyIHE9ZS5nZXRYKGwrMSk7cD09cT8obVtsLWUubWluUmFuay0xXT1wLGYrKyk6dGhpcy5yZXBvc2l0aW9uVmFsaWQoYixlLGwrMSxwKT8obVtsLWUubWluUmFuay0KMV09cCxmKyspOnA9bVtsLWUubWluUmFuay0xXT1xfXA9ZS5nZXRYKGwpO2ZvcihsPWUubWF4UmFuay0xO2w+ZS5taW5SYW5rKzE7bC0tKXE9ZS5nZXRYKGwtMSkscD09cT8obltsLWUubWluUmFuay0yXT1wLGcrKyk6dGhpcy5yZXBvc2l0aW9uVmFsaWQoYixlLGwtMSxwKT8obltsLWUubWluUmFuay0yXT1wLGcrKyk6KG5bbC1lLm1pblJhbmstMl09ZS5nZXRYKGwtMSkscD1xKTtpZihnPmt8fGY+aylpZihnPj1mKWZvcihsPWUubWF4UmFuay0yO2w+ZS5taW5SYW5rO2wtLSllLnNldFgobCxuW2wtZS5taW5SYW5rLTFdKTtlbHNlIGlmKGY+Zylmb3IobD1lLm1pblJhbmsrMjtsPGUubWF4UmFuaztsKyspZS5zZXRYKGwsbVtsLWUubWluUmFuay0yXSl9fX19OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5yZXBvc2l0aW9uVmFsaWQ9ZnVuY3Rpb24oYSxiLGMsZCl7YT1hLnJhbmtzW2NdO2Zvcih2YXIgZT0tMSxmPTA7ZjxhLmxlbmd0aDtmKyspaWYoYj09YVtmXSl7ZT1mO2JyZWFrfWlmKDA+ZSlyZXR1cm4hMTtmPWIuZ2V0R2VuZXJhbFB1cnBvc2VWYXJpYWJsZShjKTtpZihkPGYpe2lmKDA9PWUpcmV0dXJuITA7YT1hW2UtMV07Yz1hLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYyk7Yz1jK2Eud2lkdGgvMit0aGlzLmludHJhQ2VsbFNwYWNpbmcrYi53aWR0aC8yO2lmKCEoYzw9ZCkpcmV0dXJuITF9ZWxzZSBpZihkPmYpe2lmKGU9PWEubGVuZ3RoLTEpcmV0dXJuITA7YT1hW2UrMV07Yz1hLmdldEdlbmVyYWxQdXJwb3NlVmFyaWFibGUoYyk7Yz1jLWEud2lkdGgvMi10aGlzLmludHJhQ2VsbFNwYWNpbmctYi53aWR0aC8yO2lmKCEoYz49ZCkpcmV0dXJuITF9cmV0dXJuITB9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5zZXRDZWxsTG9jYXRpb25zPWZ1bmN0aW9uKGEsYil7dGhpcy5yYW5rVG9wWT1bXTt0aGlzLnJhbmtCb3R0b21ZPVtdO2Zvcih2YXIgYz0wO2M8Yi5yYW5rcy5sZW5ndGg7YysrKXRoaXMucmFua1RvcFlbY109TnVtYmVyLk1BWF9WQUxVRSx0aGlzLnJhbmtCb3R0b21ZW2NdPS1OdW1iZXIuTUFYX1ZBTFVFO2Zvcih2YXIgZD1iLnZlcnRleE1hcHBlci5nZXRWYWx1ZXMoKSxjPTA7YzxkLmxlbmd0aDtjKyspdGhpcy5zZXRWZXJ0ZXhMb2NhdGlvbihkW2NdKTt0aGlzLmxheW91dC5lZGdlU3R5bGUhPW14SGllcmFyY2hpY2FsRWRnZVN0eWxlLk9SVEhPR09OQUwmJnRoaXMubGF5b3V0LmVkZ2VTdHlsZSE9bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuUE9MWUxJTkUmJnRoaXMubGF5b3V0LmVkZ2VTdHlsZSE9bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuQ1VSVkV8fHRoaXMubG9jYWxFZGdlUHJvY2Vzc2luZyhiKTtkPWIuZWRnZU1hcHBlci5nZXRWYWx1ZXMoKTsKZm9yKGM9MDtjPGQubGVuZ3RoO2MrKyl0aGlzLnNldEVkZ2VQb3NpdGlvbihkW2NdKX07Cm14Q29vcmRpbmF0ZUFzc2lnbm1lbnQucHJvdG90eXBlLmxvY2FsRWRnZVByb2Nlc3Npbmc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLnJhbmtzLmxlbmd0aDtiKyspZm9yKHZhciBjPWEucmFua3NbYl0sZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2lmKGUuaXNWZXJ0ZXgoKSlmb3IodmFyIGY9ZS5nZXRQcmV2aW91c0xheWVyQ29ubmVjdGVkQ2VsbHMoYiksZz1iLTEsaz0wOzI+aztrKyspe2lmKC0xPGcmJmc8YS5yYW5rcy5sZW5ndGgmJm51bGwhPWYmJjA8Zi5sZW5ndGgpe2Zvcih2YXIgbD1bXSxtPTA7bTxmLmxlbmd0aDttKyspe3ZhciBuPW5ldyBXZWlnaHRlZENlbGxTb3J0ZXIoZlttXSxmW21dLmdldFgoZykpO2wucHVzaChuKX1sLnNvcnQoV2VpZ2h0ZWRDZWxsU29ydGVyLnByb3RvdHlwZS5jb21wYXJlKTtmb3IodmFyIG49ZS54WzBdLWUud2lkdGgvMixwPW4rZS53aWR0aCxxPWY9MCxnPVtdLG09MDttPGwubGVuZ3RoO20rKyl7dmFyIHI9bFttXS5jZWxsLAp0O2lmKHIuaXNWZXJ0ZXgoKSl7dD0wPT1rP2UuY29ubmVjdHNBc1NvdXJjZTplLmNvbm5lY3RzQXNUYXJnZXQ7Zm9yKHZhciB1PTA7dTx0Lmxlbmd0aDt1KyspaWYodFt1XS5zb3VyY2U9PXJ8fHRbdV0udGFyZ2V0PT1yKWYrPXRbdV0uZWRnZXMubGVuZ3RoLHErKyxnLnB1c2godFt1XSl9ZWxzZSBmKz1yLmVkZ2VzLmxlbmd0aCxxKyssZy5wdXNoKHIpfWUud2lkdGg+KGYrMSkqdGhpcy5wcmVmSG96RWRnZVNlcCsyKnRoaXMucHJlZkhvekVkZ2VTZXAmJihuKz10aGlzLnByZWZIb3pFZGdlU2VwLHAtPXRoaXMucHJlZkhvekVkZ2VTZXApO2w9KHAtbikvZjtuKz1sLzI7cD10aGlzLm1pbkVkZ2VKZXR0eS10aGlzLnByZWZWZXJ0RWRnZU9mZjtmb3IobT0wO208Zy5sZW5ndGg7bSsrKWZvcihxPWdbbV0uZWRnZXMubGVuZ3RoLHI9dGhpcy5qZXR0eVBvc2l0aW9uc1tnW21dLmlkc1swXV0sbnVsbD09ciYmKHI9W10sdGhpcy5qZXR0eVBvc2l0aW9uc1tnW21dLmlkc1swXV09ciksbTxmLzI/CnArPXRoaXMucHJlZlZlcnRFZGdlT2ZmOm0+Zi8yJiYocC09dGhpcy5wcmVmVmVydEVkZ2VPZmYpLHQ9MDt0PHE7dCsrKXJbNCp0KzIqa109bixuKz1sLHJbNCp0KzIqaysxXT1wfWY9ZS5nZXROZXh0TGF5ZXJDb25uZWN0ZWRDZWxscyhiKTtnPWIrMX19fTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuc2V0RWRnZVBvc2l0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPTA7aWYoMTAxMjA3IT1hLnRlbXBbMF0pe3ZhciBjPWEubWF4UmFuayxkPWEubWluUmFuaztjPT1kJiYoYz1hLnNvdXJjZS5tYXhSYW5rLGQ9YS50YXJnZXQubWluUmFuayk7Zm9yKHZhciBlPTAsZj10aGlzLmpldHR5UG9zaXRpb25zW2EuaWRzWzBdXSxnPWEuaXNSZXZlcnNlZD9hLnRhcmdldC5jZWxsOmEuc291cmNlLmNlbGwsaz10aGlzLmxheW91dC5ncmFwaCxsPXRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUfHx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgsbT0wO208YS5lZGdlcy5sZW5ndGg7bSsrKXt2YXIgbj1hLmVkZ2VzW21dLHA9dGhpcy5sYXlvdXQuZ2V0VmlzaWJsZVRlcm1pbmFsKG4sITApLHE9W10scj1hLmlzUmV2ZXJzZWQ7cCE9ZyYmKHI9IXIpO2lmKG51bGwhPWYpe3ZhciB0PXI/CjI6MCx1PXI/bD90aGlzLnJhbmtCb3R0b21ZW2RdOnRoaXMucmFua1RvcFlbZF06bD90aGlzLnJhbmtUb3BZW2NdOnRoaXMucmFua0JvdHRvbVlbY10seD1mWzQqZSsxK3RdO3IhPWwmJih4PS14KTt2YXIgdT11K3gsdD1mWzQqZSt0XSx5PWsubW9kZWwuZ2V0VGVybWluYWwobiwhMCk7dGhpcy5sYXlvdXQuaXNQb3J0KHkpJiZrLm1vZGVsLmdldFBhcmVudCh5KT09cCYmKHQ9ay52aWV3LmdldFN0YXRlKHkpLHQ9bnVsbCE9dD90Lng6cC5nZW9tZXRyeS54K2Euc291cmNlLndpZHRoKnkuZ2VvbWV0cnkueCk7dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KHEucHVzaChuZXcgbXhQb2ludCh0LHUpKSx0aGlzLmxheW91dC5lZGdlU3R5bGU9PW14SGllcmFyY2hpY2FsRWRnZVN0eWxlLkNVUlZFJiZxLnB1c2gobmV3IG14UG9pbnQodCx1K3gpKSk6KHEucHVzaChuZXcgbXhQb2ludCh1LAp0KSksdGhpcy5sYXlvdXQuZWRnZVN0eWxlPT1teEhpZXJhcmNoaWNhbEVkZ2VTdHlsZS5DVVJWRSYmcS5wdXNoKG5ldyBteFBvaW50KHUreCx0KSkpfXQ9YS54Lmxlbmd0aC0xO3U9eD0tMTtwPWEubWF4UmFuay0xO2ZvcihyJiYodD0wLHg9YS54Lmxlbmd0aCx1PTEscD1hLm1pblJhbmsrMSk7YS5tYXhSYW5rIT1hLm1pblJhbmsmJnQhPXg7dCs9dSl7dmFyIHk9YS54W3RdK2IsQj0odGhpcy5yYW5rVG9wWVtwXSt0aGlzLnJhbmtCb3R0b21ZW3ArMV0pLzIsQT0odGhpcy5yYW5rVG9wWVtwLTFdK3RoaXMucmFua0JvdHRvbVlbcF0pLzI7aWYocil2YXIgej1CLEI9QSxBPXo7dGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KHEucHVzaChuZXcgbXhQb2ludCh5LEIpKSxxLnB1c2gobmV3IG14UG9pbnQoeSxBKSkpOihxLnB1c2gobmV3IG14UG9pbnQoQix5KSkscS5wdXNoKG5ldyBteFBvaW50KEEsCnkpKSk7dGhpcy5saW1pdFg9TWF0aC5tYXgodGhpcy5saW1pdFgseSk7cCs9dX1udWxsIT1mJiYodD1yPzI6MCx1PXI/bD90aGlzLnJhbmtUb3BZW2NdOnRoaXMucmFua0JvdHRvbVlbY106bD90aGlzLnJhbmtCb3R0b21ZW2RdOnRoaXMucmFua1RvcFlbZF0seD1mWzQqZSszLXRdLHIhPWwmJih4PS14KSx1LT14LHQ9Zls0KmUrMi10XSxyPWsubW9kZWwuZ2V0VGVybWluYWwobiwhMSkscD10aGlzLmxheW91dC5nZXRWaXNpYmxlVGVybWluYWwobiwhMSksdGhpcy5sYXlvdXQuaXNQb3J0KHIpJiZrLm1vZGVsLmdldFBhcmVudChyKT09cCYmKHQ9ay52aWV3LmdldFN0YXRlKHIpLHQ9bnVsbCE9dD90Lng6cC5nZW9tZXRyeS54K2EudGFyZ2V0LndpZHRoKnIuZ2VvbWV0cnkueCksdGhpcy5vcmllbnRhdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHx0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KHRoaXMubGF5b3V0LmVkZ2VTdHlsZT09bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuQ1VSVkUmJgpxLnB1c2gobmV3IG14UG9pbnQodCx1LXgpKSxxLnB1c2gobmV3IG14UG9pbnQodCx1KSkpOih0aGlzLmxheW91dC5lZGdlU3R5bGU9PW14SGllcmFyY2hpY2FsRWRnZVN0eWxlLkNVUlZFJiZxLnB1c2gobmV3IG14UG9pbnQodS14LHQpKSxxLnB1c2gobmV3IG14UG9pbnQodSx0KSkpKTthLmlzUmV2ZXJzZWQmJnRoaXMucHJvY2Vzc1JldmVyc2VkRWRnZShhLG4pO3RoaXMubGF5b3V0LnNldEVkZ2VQb2ludHMobixxKTtiPTA9PWI/dGhpcy5wYXJhbGxlbEVkZ2VTcGFjaW5nOjA8Yj8tYjotYit0aGlzLnBhcmFsbGVsRWRnZVNwYWNpbmc7ZSsrfWEudGVtcFswXT0xMDEyMDd9fTsKbXhDb29yZGluYXRlQXNzaWdubWVudC5wcm90b3R5cGUuc2V0VmVydGV4TG9jYXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9YS5jZWxsLGM9YS54WzBdLWEud2lkdGgvMixkPWEueVswXS1hLmhlaWdodC8yO3RoaXMucmFua1RvcFlbYS5taW5SYW5rXT1NYXRoLm1pbih0aGlzLnJhbmtUb3BZW2EubWluUmFua10sZCk7dGhpcy5yYW5rQm90dG9tWVthLm1pblJhbmtdPU1hdGgubWF4KHRoaXMucmFua0JvdHRvbVlbYS5taW5SYW5rXSxkK2EuaGVpZ2h0KTt0aGlzLm9yaWVudGF0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fHRoaXMub3JpZW50YXRpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD90aGlzLmxheW91dC5zZXRWZXJ0ZXhMb2NhdGlvbihiLGMsZCk6dGhpcy5sYXlvdXQuc2V0VmVydGV4TG9jYXRpb24oYixkLGMpO3RoaXMubGltaXRYPU1hdGgubWF4KHRoaXMubGltaXRYLGMrYS53aWR0aCl9OwpteENvb3JkaW5hdGVBc3NpZ25tZW50LnByb3RvdHlwZS5wcm9jZXNzUmV2ZXJzZWRFZGdlPWZ1bmN0aW9uKGEsYil7fTtmdW5jdGlvbiBteFN3aW1sYW5lT3JkZXJpbmcoYSl7dGhpcy5sYXlvdXQ9YX1teFN3aW1sYW5lT3JkZXJpbmcucHJvdG90eXBlPW5ldyBteEhpZXJhcmNoaWNhbExheW91dFN0YWdlO214U3dpbWxhbmVPcmRlcmluZy5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhTd2ltbGFuZU9yZGVyaW5nO214U3dpbWxhbmVPcmRlcmluZy5wcm90b3R5cGUubGF5b3V0PW51bGw7Cm14U3dpbWxhbmVPcmRlcmluZy5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXthPXRoaXMubGF5b3V0LmdldE1vZGVsKCk7dmFyIGI9bXhVdGlscy5jbG9uZShhLnZlcnRleE1hcHBlcixudWxsLCEwKSxjPW51bGw7aWYobnVsbCE9YS5yb290cylmb3IodmFyIGQ9YS5yb290cyxjPVtdLGU9MDtlPGQubGVuZ3RoO2UrKyljW2VdPWEudmVydGV4TWFwcGVyLmdldChkW2VdKTthLnZpc2l0KGZ1bmN0aW9uKGEsYyxkLGUsbSl7ZT1udWxsIT1hJiZhLnN3aW1sYW5lSW5kZXg9PWMuc3dpbWxhbmVJbmRleCYmYy5pc0FuY2VzdG9yKGEpO209bnVsbCE9YSYmbnVsbCE9ZCYmYS5zd2ltbGFuZUluZGV4PGMuc3dpbWxhbmVJbmRleCYmZC5zb3VyY2U9PWM7ZT8oZC5pbnZlcnQoKSxteFV0aWxzLnJlbW92ZShkLGEuY29ubmVjdHNBc1NvdXJjZSksYy5jb25uZWN0c0FzU291cmNlLnB1c2goZCksYS5jb25uZWN0c0FzVGFyZ2V0LnB1c2goZCksbXhVdGlscy5yZW1vdmUoZCxjLmNvbm5lY3RzQXNUYXJnZXQpKToKbSYmKGQuaW52ZXJ0KCksbXhVdGlscy5yZW1vdmUoZCxhLmNvbm5lY3RzQXNUYXJnZXQpLGMuY29ubmVjdHNBc1RhcmdldC5wdXNoKGQpLGEuY29ubmVjdHNBc1NvdXJjZS5wdXNoKGQpLG14VXRpbHMucmVtb3ZlKGQsYy5jb25uZWN0c0FzU291cmNlKSk7YT1teENlbGxQYXRoLmNyZWF0ZShjLmNlbGwpO2RlbGV0ZSBiW2FdfSxjLCEwLG51bGwpfTtmdW5jdGlvbiBteEhpZXJhcmNoaWNhbExheW91dChhLGIsYyl7bXhHcmFwaExheW91dC5jYWxsKHRoaXMsYSk7dGhpcy5vcmllbnRhdGlvbj1udWxsIT1iP2I6bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIO3RoaXMuZGV0ZXJtaW5pc3RpYz1udWxsIT1jP2M6ITB9dmFyIG14SGllcmFyY2hpY2FsRWRnZVN0eWxlPXtPUlRIT0dPTkFMOjEsUE9MWUxJTkU6MixTVFJBSUdIVDozLENVUlZFOjR9O214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14SGllcmFyY2hpY2FsTGF5b3V0O214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5yb290cz1udWxsO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5yZXNpemVQYXJlbnQ9ITE7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLm1haW50YWluUGFyZW50TG9jYXRpb249ITE7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLm1vdmVQYXJlbnQ9ITE7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnBhcmVudEJvcmRlcj0wO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5pbnRyYUNlbGxTcGFjaW5nPTMwO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5pbnRlclJhbmtDZWxsU3BhY2luZz0xMDA7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmludGVySGllcmFyY2h5U3BhY2luZz02MDsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnBhcmFsbGVsRWRnZVNwYWNpbmc9MTA7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLm9yaWVudGF0aW9uPW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSDtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZmluZVR1bmluZz0hMDtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUudGlnaHRlblRvU291cmNlPSEwO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5kaXNhYmxlRWRnZVN0eWxlPSEwO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS50cmF2ZXJzZUFuY2VzdG9ycz0hMDtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUubW9kZWw9bnVsbDtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZWRnZXNDYWNoZT1udWxsO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlU291cmNlVGVybUNhY2hlPW51bGw7Cm14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlc1RhcmdldFRlcm1DYWNoZT1udWxsO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlU3R5bGU9bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuUE9MWUxJTkU7bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmdldE1vZGVsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWx9OwpteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhLGIpe3RoaXMucGFyZW50PWE7dmFyIGM9dGhpcy5ncmFwaC5tb2RlbDt0aGlzLmVkZ2VzQ2FjaGU9bmV3IG14RGljdGlvbmFyeTt0aGlzLmVkZ2VTb3VyY2VUZXJtQ2FjaGU9bmV3IG14RGljdGlvbmFyeTt0aGlzLmVkZ2VzVGFyZ2V0VGVybUNhY2hlPW5ldyBteERpY3Rpb25hcnk7bnVsbD09Ynx8YiBpbnN0YW5jZW9mIEFycmF5fHwoYj1bYl0pO2lmKG51bGwhPWJ8fG51bGwhPWEpe3RoaXMucGFyZW50WT10aGlzLnBhcmVudFg9bnVsbDtpZihhIT10aGlzLnJvb3QmJm51bGwhPWMuaXNWZXJ0ZXgoYSkmJnRoaXMubWFpbnRhaW5QYXJlbnRMb2NhdGlvbil7dmFyIGQ9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSk7bnVsbCE9ZCYmKHRoaXMucGFyZW50WD1kLngsdGhpcy5wYXJlbnRZPWQueSl9aWYobnVsbCE9Yil7Zm9yKHZhciBlPVtdLGY9MDtmPGIubGVuZ3RoO2YrKykobnVsbCE9YT9jLmlzQW5jZXN0b3IoYSwKYltmXSk6MSkmJmMuaXNWZXJ0ZXgoYltmXSkmJmUucHVzaChiW2ZdKTt0aGlzLnJvb3RzPWV9Yy5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLnJ1bihhKSx0aGlzLnJlc2l6ZVBhcmVudCYmIXRoaXMuZ3JhcGguaXNDZWxsQ29sbGFwc2VkKGEpJiZ0aGlzLmdyYXBoLnVwZGF0ZUdyb3VwQm91bmRzKFthXSx0aGlzLnBhcmVudEJvcmRlcix0aGlzLm1vdmVQYXJlbnQpLG51bGwhPXRoaXMucGFyZW50WCYmbnVsbCE9dGhpcy5wYXJlbnRZJiYoZD10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKSxudWxsIT1kJiYoZD1kLmNsb25lKCksZC54PXRoaXMucGFyZW50WCxkLnk9dGhpcy5wYXJlbnRZLGMuc2V0R2VvbWV0cnkoYSxkKSkpfWZpbmFsbHl7Yy5lbmRVcGRhdGUoKX19fTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmZpbmRSb290cz1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2lmKG51bGwhPWEmJm51bGwhPWIpe3ZhciBkPXRoaXMuZ3JhcGgubW9kZWwsZT1udWxsLGY9LTFFNSxnO2ZvcihnIGluIGIpe3ZhciBrPWJbZ107aWYoZC5pc1ZlcnRleChrKSYmdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGspKXtmb3IodmFyIGw9dGhpcy5nZXRFZGdlcyhrKSxtPTAsbj0wLHA9MDtwPGwubGVuZ3RoO3ArKyl0aGlzLmdldFZpc2libGVUZXJtaW5hbChsW3BdLCEwKT09az9tKys6bisrOzA9PW4mJjA8bSYmYy5wdXNoKGspO2w9bS1uO2w+ZiYmKGY9bCxlPWspfX0wPT1jLmxlbmd0aCYmbnVsbCE9ZSYmYy5wdXNoKGUpfXJldHVybiBjfTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmdldEVkZ2VzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWRnZXNDYWNoZS5nZXQoYSk7aWYobnVsbCE9YilyZXR1cm4gYjtmb3IodmFyIGM9dGhpcy5ncmFwaC5tb2RlbCxiPVtdLGQ9dGhpcy5ncmFwaC5pc0NlbGxDb2xsYXBzZWQoYSksZT1jLmdldENoaWxkQ291bnQoYSksZj0wO2Y8ZTtmKyspe3ZhciBnPWMuZ2V0Q2hpbGRBdChhLGYpO2lmKHRoaXMuaXNQb3J0KGcpKWI9Yi5jb25jYXQoYy5nZXRFZGdlcyhnLCEwLCEwKSk7ZWxzZSBpZihkfHwhdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGcpKWI9Yi5jb25jYXQoYy5nZXRFZGdlcyhnLCEwLCEwKSl9Yj1iLmNvbmNhdChjLmdldEVkZ2VzKGEsITAsITApKTtjPVtdO2ZvcihmPTA7ZjxiLmxlbmd0aDtmKyspZD10aGlzLmdldFZpc2libGVUZXJtaW5hbChiW2ZdLCEwKSxlPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGJbZl0sITEpLChkPT1lfHxkIT1lJiYoZT09YSYmKG51bGw9PQp0aGlzLnBhcmVudHx8dGhpcy5pc0FuY2VzdG9yKHRoaXMucGFyZW50LGQsdGhpcy50cmF2ZXJzZUFuY2VzdG9ycykpfHxkPT1hJiYobnVsbD09dGhpcy5wYXJlbnR8fHRoaXMuaXNBbmNlc3Rvcih0aGlzLnBhcmVudCxlLHRoaXMudHJhdmVyc2VBbmNlc3RvcnMpKSkpJiZjLnB1c2goYltmXSk7dGhpcy5lZGdlc0NhY2hlLnB1dChhLGMpO3JldHVybiBjfTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmdldFZpc2libGVUZXJtaW5hbD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZWRnZXNUYXJnZXRUZXJtQ2FjaGU7YiYmKGM9dGhpcy5lZGdlU291cmNlVGVybUNhY2hlKTt2YXIgZD1jLmdldChhKTtpZihudWxsIT1kKXJldHVybiBkO3ZhciBkPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKSxlPW51bGwhPWQ/ZC5nZXRWaXNpYmxlVGVybWluYWwoYik6dGhpcy5ncmFwaC52aWV3LmdldFZpc2libGVUZXJtaW5hbChhLGIpO251bGw9PWUmJihlPW51bGwhPWQ/ZC5nZXRWaXNpYmxlVGVybWluYWwoYik6dGhpcy5ncmFwaC52aWV3LmdldFZpc2libGVUZXJtaW5hbChhLGIpKTtudWxsIT1lJiYodGhpcy5pc1BvcnQoZSkmJihlPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGUpKSxjLnB1dChhLGUpKTtyZXR1cm4gZX07Cm14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oYSl7dmFyIGI9W10sYz1bXTtpZihudWxsPT10aGlzLnJvb3RzJiZudWxsIT1hKXt2YXIgZD17fTt0aGlzLmZpbHRlckRlc2NlbmRhbnRzKGEsZCk7dGhpcy5yb290cz1bXTt2YXIgZT0hMCxmO2ZvcihmIGluIGQpaWYobnVsbCE9ZFtmXSl7ZT0hMTticmVha31mb3IoOyFlOyl7Zm9yKHZhciBnPXRoaXMuZmluZFJvb3RzKGEsZCksZT0wO2U8Zy5sZW5ndGg7ZSsrKXt2YXIgaz17fTtiLnB1c2goayk7dGhpcy50cmF2ZXJzZShnW2VdLCEwLG51bGwsYyxrLGIsZCl9Zm9yKGU9MDtlPGcubGVuZ3RoO2UrKyl0aGlzLnJvb3RzLnB1c2goZ1tlXSk7ZT0hMDtmb3IoZiBpbiBkKWlmKG51bGwhPWRbZl0pe2U9ITE7YnJlYWt9fX1lbHNlIGZvcihlPTA7ZTx0aGlzLnJvb3RzLmxlbmd0aDtlKyspaz17fSxiLnB1c2goayksdGhpcy50cmF2ZXJzZSh0aGlzLnJvb3RzW2VdLCEwLG51bGwsYyxrLGIsbnVsbCk7Zm9yKGU9Yz0KMDtlPGIubGVuZ3RoO2UrKyl7az1iW2VdO2Q9W107Zm9yKGYgaW4gaylkLnB1c2goa1tmXSk7dGhpcy5tb2RlbD1uZXcgbXhHcmFwaEhpZXJhcmNoeU1vZGVsKHRoaXMsZCx0aGlzLnJvb3RzLGEsdGhpcy50aWdodGVuVG9Tb3VyY2UpO3RoaXMuY3ljbGVTdGFnZShhKTt0aGlzLmxheWVyaW5nU3RhZ2UoKTt0aGlzLmNyb3NzaW5nU3RhZ2UoYSk7Yz10aGlzLnBsYWNlbWVudFN0YWdlKGMsYSl9fTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmZpbHRlckRlc2NlbmRhbnRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5tb2RlbDtjLmlzVmVydGV4KGEpJiZhIT10aGlzLnBhcmVudCYmdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGEpJiYoYltteE9iamVjdElkZW50aXR5LmdldChhKV09YSk7aWYodGhpcy50cmF2ZXJzZUFuY2VzdG9yc3x8YT09dGhpcy5wYXJlbnQmJnRoaXMuZ3JhcGguaXNDZWxsVmlzaWJsZShhKSlmb3IodmFyIGQ9Yy5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGQ7ZSsrKXt2YXIgZj1jLmdldENoaWxkQXQoYSxlKTt0aGlzLmlzUG9ydChmKXx8dGhpcy5maWx0ZXJEZXNjZW5kYW50cyhmLGIpfX07bXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmlzUG9ydD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9YS5nZW9tZXRyeT9hLmdlb21ldHJ5LnJlbGF0aXZlOiExfTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLmdldEVkZ2VzQmV0d2Vlbj1mdW5jdGlvbihhLGIsYyl7Yz1udWxsIT1jP2M6ITE7Zm9yKHZhciBkPXRoaXMuZ2V0RWRnZXMoYSksZT1bXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGRbZl0sITApLGs9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwoZFtmXSwhMSk7KGc9PWEmJms9PWJ8fCFjJiZnPT1iJiZrPT1hKSYmZS5wdXNoKGRbZl0pfXJldHVybiBlfTsKbXhIaWVyYXJjaGljYWxMYXlvdXQucHJvdG90eXBlLnRyYXZlcnNlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2lmKG51bGwhPWEmJm51bGwhPWQpe3ZhciBrPW14T2JqZWN0SWRlbnRpdHkuZ2V0KGEpO2lmKG51bGw9PWRba10mJihudWxsPT1nfHxudWxsIT1nW2tdKSl7bnVsbD09ZVtrXSYmKGVba109YSk7bnVsbD09ZFtrXSYmKGRba109YSk7bnVsbCE9PWcmJmRlbGV0ZSBnW2tdO3ZhciBsPXRoaXMuZ2V0RWRnZXMoYSksaz1bXTtmb3IoYz0wO2M8bC5sZW5ndGg7YysrKWtbY109dGhpcy5nZXRWaXNpYmxlVGVybWluYWwobFtjXSwhMCk9PWE7Zm9yKGM9MDtjPGwubGVuZ3RoO2MrKylpZighYnx8a1tjXSl7YT10aGlzLmdldFZpc2libGVUZXJtaW5hbChsW2NdLCFrW2NdKTtmb3IodmFyIG09MSxuPTA7bjxsLmxlbmd0aDtuKyspaWYobiE9Yyl7dmFyIHA9a1tuXTt0aGlzLmdldFZpc2libGVUZXJtaW5hbChsW25dLCFwKT09YSYmKHA/bSsrOm0tLSl9MDw9bSYmKGU9dGhpcy50cmF2ZXJzZShhLApiLGxbY10sZCxlLGYsZykpfX1lbHNlIGlmKG51bGw9PWVba10pZm9yKGM9MDtjPGYubGVuZ3RoO2MrKylpZihiPWZbY10sbnVsbCE9YltrXSl7Zm9yKGwgaW4gYillW2xdPWJbbF07Zi5zcGxpY2UoYywxKTticmVha319cmV0dXJuIGV9O214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5jeWNsZVN0YWdlPWZ1bmN0aW9uKGEpeyhuZXcgbXhNaW5pbXVtQ3ljbGVSZW1vdmVyKHRoaXMpKS5leGVjdXRlKGEpfTtteEhpZXJhcmNoaWNhbExheW91dC5wcm90b3R5cGUubGF5ZXJpbmdTdGFnZT1mdW5jdGlvbigpe3RoaXMubW9kZWwuaW5pdGlhbFJhbmsoKTt0aGlzLm1vZGVsLmZpeFJhbmtzKCl9O214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5jcm9zc2luZ1N0YWdlPWZ1bmN0aW9uKGEpeyhuZXcgbXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbih0aGlzKSkuZXhlY3V0ZShhKX07Cm14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5wbGFjZW1lbnRTdGFnZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBteENvb3JkaW5hdGVBc3NpZ25tZW50KHRoaXMsdGhpcy5pbnRyYUNlbGxTcGFjaW5nLHRoaXMuaW50ZXJSYW5rQ2VsbFNwYWNpbmcsdGhpcy5vcmllbnRhdGlvbixhLHRoaXMucGFyYWxsZWxFZGdlU3BhY2luZyk7Yy5maW5lVHVuaW5nPXRoaXMuZmluZVR1bmluZztjLmV4ZWN1dGUoYik7cmV0dXJuIGMubGltaXRYK3RoaXMuaW50ZXJIaWVyYXJjaHlTcGFjaW5nfTtmdW5jdGlvbiBteFN3aW1sYW5lTGF5b3V0KGEsYixjKXtteEdyYXBoTGF5b3V0LmNhbGwodGhpcyxhKTt0aGlzLm9yaWVudGF0aW9uPW51bGwhPWI/YjpteENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg7dGhpcy5kZXRlcm1pbmlzdGljPW51bGwhPWM/YzohMH1teFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhHcmFwaExheW91dDsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhTd2ltbGFuZUxheW91dDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5yb290cz1udWxsO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnN3aW1sYW5lcz1udWxsO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmR1bW15VmVydGV4V2lkdGg9NTA7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUucmVzaXplUGFyZW50PSExO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLm1haW50YWluUGFyZW50TG9jYXRpb249ITE7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUubW92ZVBhcmVudD0hMTtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5wYXJlbnRCb3JkZXI9MzA7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuaW50cmFDZWxsU3BhY2luZz0zMDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5pbnRlclJhbmtDZWxsU3BhY2luZz0xMDA7Cm14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmludGVySGllcmFyY2h5U3BhY2luZz02MDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5wYXJhbGxlbEVkZ2VTcGFjaW5nPTEwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLm9yaWVudGF0aW9uPW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5maW5lVHVuaW5nPSEwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnRpZ2h0ZW5Ub1NvdXJjZT0hMDtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5kaXNhYmxlRWRnZVN0eWxlPSEwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnRyYXZlcnNlQW5jZXN0b3JzPSEwO214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLm1vZGVsPW51bGw7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZWRnZXNDYWNoZT1udWxsO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlU291cmNlVGVybUNhY2hlPW51bGw7Cm14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlc1RhcmdldFRlcm1DYWNoZT1udWxsO214SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5lZGdlU3R5bGU9bXhIaWVyYXJjaGljYWxFZGdlU3R5bGUuUE9MWUxJTkU7bXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZ2V0TW9kZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbH07Cm14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnBhcmVudD1hO3ZhciBjPXRoaXMuZ3JhcGgubW9kZWw7dGhpcy5lZGdlc0NhY2hlPW5ldyBteERpY3Rpb25hcnk7dGhpcy5lZGdlU291cmNlVGVybUNhY2hlPW5ldyBteERpY3Rpb25hcnk7dGhpcy5lZGdlc1RhcmdldFRlcm1DYWNoZT1uZXcgbXhEaWN0aW9uYXJ5O2lmKCEobnVsbD09Ynx8MT5iLmxlbmd0aCkpe251bGw9PWEmJihhPWMuZ2V0UGFyZW50KGJbMF0pKTt0aGlzLnBhcmVudFk9dGhpcy5wYXJlbnRYPW51bGw7aWYoYSE9dGhpcy5yb290JiZudWxsIT1jLmlzVmVydGV4KGEpJiZ0aGlzLm1haW50YWluUGFyZW50TG9jYXRpb24pe3ZhciBkPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO251bGwhPWQmJih0aGlzLnBhcmVudFg9ZC54LHRoaXMucGFyZW50WT1kLnkpfXRoaXMuc3dpbWxhbmVzPWI7Zm9yKHZhciBlPVtdLGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5ncmFwaC5nZXRDaGlsZENlbGxzKGJbZl0pOwppZihudWxsPT1nfHwwPT1nLmxlbmd0aClnPXRoaXMuZ3JhcGguaW5zZXJ0VmVydGV4KGJbZl0sbnVsbCxudWxsLDAsMCx0aGlzLmR1bW15VmVydGV4V2lkdGgsMCksZS5wdXNoKGcpfWMuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5ydW4oYSksdGhpcy5yZXNpemVQYXJlbnQmJiF0aGlzLmdyYXBoLmlzQ2VsbENvbGxhcHNlZChhKSYmdGhpcy5ncmFwaC51cGRhdGVHcm91cEJvdW5kcyhbYV0sdGhpcy5wYXJlbnRCb3JkZXIsdGhpcy5tb3ZlUGFyZW50KSxudWxsIT10aGlzLnBhcmVudFgmJm51bGwhPXRoaXMucGFyZW50WSYmKGQ9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSksbnVsbCE9ZCYmKGQ9ZC5jbG9uZSgpLGQueD10aGlzLnBhcmVudFgsZC55PXRoaXMucGFyZW50WSxjLnNldEdlb21ldHJ5KGEsZCkpKSx0aGlzLmdyYXBoLnJlbW92ZUNlbGxzKGUpfWZpbmFsbHl7Yy5lbmRVcGRhdGUoKX19fTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUudXBkYXRlR3JvdXBCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiPXRoaXMubW9kZWwsYztmb3IoYyBpbiBiLmVkZ2VNYXBwZXIpZm9yKHZhciBkPWIuZWRnZU1hcHBlcltjXSxlPTA7ZTxkLmVkZ2VzLmxlbmd0aDtlKyspYS5wdXNoKGQuZWRnZXNbZV0pO2E9dGhpcy5ncmFwaC5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShhLCEwKTtiPVtdO2ZvcihlPTA7ZTx0aGlzLnN3aW1sYW5lcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLnN3aW1sYW5lc1tlXTtjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGYpO2lmKG51bGwhPWMpe3ZhciBnPXRoaXMuZ3JhcGguZ2V0Q2hpbGRDZWxscyhmKSxkPXRoaXMuZ3JhcGguaXNTd2ltbGFuZShmKT90aGlzLmdyYXBoLmdldFN0YXJ0U2l6ZShmKTpuZXcgbXhSZWN0YW5nbGUsZj10aGlzLmdyYXBoLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KGcpO2JbZV09ZjtkPWYueStjLnktZC5oZWlnaHQtCnRoaXMucGFyZW50Qm9yZGVyO2M9Zi55K2MueStmLmhlaWdodDtudWxsPT1hP2E9bmV3IG14UmVjdGFuZ2xlKDAsZCwwLGMtZCk6KGEueT1NYXRoLm1pbihhLnksZCksYS5oZWlnaHQ9TWF0aC5tYXgoYS55K2EuaGVpZ2h0LGMpLWEueSl9fWZvcihlPTA7ZTx0aGlzLnN3aW1sYW5lcy5sZW5ndGg7ZSsrKWlmKGY9dGhpcy5zd2ltbGFuZXNbZV0sYz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShmKSxudWxsIT1jKXt2YXIgZz10aGlzLmdyYXBoLmdldENoaWxkQ2VsbHMoZiksZD10aGlzLmdyYXBoLmlzU3dpbWxhbmUoZik/dGhpcy5ncmFwaC5nZXRTdGFydFNpemUoZik6bmV3IG14UmVjdGFuZ2xlLGs9Yy5jbG9uZSgpLGw9ZC53aWR0aCsoMD09ZT90aGlzLnBhcmVudEJvcmRlcjp0aGlzLmludGVyUmFua0NlbGxTcGFjaW5nLzIpLG09YltlXS54LWwsbj1hLnktdGhpcy5wYXJlbnRCb3JkZXI7ay54Kz1tO2sueT1uO2sud2lkdGg9YltlXS53aWR0aCtsK3RoaXMuaW50ZXJSYW5rQ2VsbFNwYWNpbmcvCjI7ay5oZWlnaHQ9YS5oZWlnaHQrZC5oZWlnaHQrMip0aGlzLnBhcmVudEJvcmRlcjt0aGlzLmdyYXBoLm1vZGVsLnNldEdlb21ldHJ5KGYsayk7dGhpcy5ncmFwaC5tb3ZlQ2VsbHMoZywtbSxjLnktbil9fTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZmluZFJvb3RzPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYobnVsbCE9YSYmbnVsbCE9Yil7dmFyIGQ9dGhpcy5ncmFwaC5tb2RlbCxlPW51bGwsZj0tMUU1LGc7Zm9yKGcgaW4gYil7dmFyIGs9YltnXTtpZihudWxsIT1rJiZkLmlzVmVydGV4KGspJiZ0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoaykmJmQuaXNBbmNlc3RvcihhLGspKXtmb3IodmFyIGw9dGhpcy5nZXRFZGdlcyhrKSxtPTAsbj0wLHA9MDtwPGwubGVuZ3RoO3ArKyl7dmFyIHE9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwobFtwXSwhMCk7cT09az8ocT10aGlzLmdldFZpc2libGVUZXJtaW5hbChsW3BdLCExKSxkLmlzQW5jZXN0b3IoYSxxKSYmbSsrKTpkLmlzQW5jZXN0b3IoYSxxKSYmbisrfTA9PW4mJjA8bSYmYy5wdXNoKGspO2w9bS1uO2w+ZiYmKGY9bCxlPWspfX0wPT1jLmxlbmd0aCYmbnVsbCE9ZSYmYy5wdXNoKGUpfXJldHVybiBjfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZ2V0RWRnZXM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lZGdlc0NhY2hlLmdldChhKTtpZihudWxsIT1iKXJldHVybiBiO2Zvcih2YXIgYz10aGlzLmdyYXBoLm1vZGVsLGI9W10sZD10aGlzLmdyYXBoLmlzQ2VsbENvbGxhcHNlZChhKSxlPWMuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxlO2YrKyl7dmFyIGc9Yy5nZXRDaGlsZEF0KGEsZik7aWYodGhpcy5pc1BvcnQoZykpYj1iLmNvbmNhdChjLmdldEVkZ2VzKGcsITAsITApKTtlbHNlIGlmKGR8fCF0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoZykpYj1iLmNvbmNhdChjLmdldEVkZ2VzKGcsITAsITApKX1iPWIuY29uY2F0KGMuZ2V0RWRnZXMoYSwhMCwhMCkpO2M9W107Zm9yKGY9MDtmPGIubGVuZ3RoO2YrKylkPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGJbZl0sITApLGU9dGhpcy5nZXRWaXNpYmxlVGVybWluYWwoYltmXSwhMSksKGQ9PWV8fGQhPWUmJihlPT1hJiYobnVsbD09dGhpcy5wYXJlbnR8fAp0aGlzLmdyYXBoLmlzVmFsaWRBbmNlc3RvcihkLHRoaXMucGFyZW50LHRoaXMudHJhdmVyc2VBbmNlc3RvcnMpKXx8ZD09YSYmKG51bGw9PXRoaXMucGFyZW50fHx0aGlzLmdyYXBoLmlzVmFsaWRBbmNlc3RvcihlLHRoaXMucGFyZW50LHRoaXMudHJhdmVyc2VBbmNlc3RvcnMpKSkpJiZjLnB1c2goYltmXSk7dGhpcy5lZGdlc0NhY2hlLnB1dChhLGMpO3JldHVybiBjfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUuZ2V0VmlzaWJsZVRlcm1pbmFsPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5lZGdlc1RhcmdldFRlcm1DYWNoZTtiJiYoYz10aGlzLmVkZ2VTb3VyY2VUZXJtQ2FjaGUpO3ZhciBkPWMuZ2V0KGEpO2lmKG51bGwhPWQpcmV0dXJuIGQ7dmFyIGQ9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEpLGU9bnVsbCE9ZD9kLmdldFZpc2libGVUZXJtaW5hbChiKTp0aGlzLmdyYXBoLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsYik7bnVsbD09ZSYmKGU9bnVsbCE9ZD9kLmdldFZpc2libGVUZXJtaW5hbChiKTp0aGlzLmdyYXBoLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGEsYikpO251bGwhPWUmJih0aGlzLmlzUG9ydChlKSYmKGU9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoZSkpLGMucHV0KGEsZSkpO3JldHVybiBlfTsKbXhTd2ltbGFuZUxheW91dC5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9e307aWYobnVsbCE9dGhpcy5zd2ltbGFuZXMmJjA8dGhpcy5zd2ltbGFuZXMubGVuZ3RoJiZudWxsIT1hKXtmb3IodmFyIGQ9e30sZT0wO2U8dGhpcy5zd2ltbGFuZXMubGVuZ3RoO2UrKyl0aGlzLmZpbHRlckRlc2NlbmRhbnRzKHRoaXMuc3dpbWxhbmVzW2VdLGQpO3RoaXMucm9vdHM9W107dmFyIGU9ITAsZjtmb3IoZiBpbiBkKWlmKG51bGwhPWRbZl0pe2U9ITE7YnJlYWt9Zm9yKHZhciBnPTA7IWUmJmc8dGhpcy5zd2ltbGFuZXMubGVuZ3RoOyl7dmFyIGs9dGhpcy5maW5kUm9vdHModGhpcy5zd2ltbGFuZXNbZ10sZCk7aWYoMD09ay5sZW5ndGgpZysrO2Vsc2V7Zm9yKGU9MDtlPGsubGVuZ3RoO2UrKyl7dmFyIGw9e307Yi5wdXNoKGwpO3RoaXMudHJhdmVyc2Uoa1tlXSwhMCxudWxsLGMsbCxiLGQsZyl9Zm9yKGU9MDtlPGsubGVuZ3RoO2UrKyl0aGlzLnJvb3RzLnB1c2goa1tlXSk7CmU9ITA7Zm9yKGYgaW4gZClpZihudWxsIT1kW2ZdKXtlPSExO2JyZWFrfX19fWVsc2UgZm9yKGU9MDtlPHRoaXMucm9vdHMubGVuZ3RoO2UrKylsPXt9LGIucHVzaChsKSx0aGlzLnRyYXZlcnNlKHRoaXMucm9vdHNbZV0sITAsbnVsbCxjLGwsYixudWxsKTtiPVtdO2ZvcihmIGluIGMpYi5wdXNoKGNbZl0pO3RoaXMubW9kZWw9bmV3IG14U3dpbWxhbmVNb2RlbCh0aGlzLGIsdGhpcy5yb290cyxhLHRoaXMudGlnaHRlblRvU291cmNlKTt0aGlzLmN5Y2xlU3RhZ2UoYSk7dGhpcy5sYXllcmluZ1N0YWdlKCk7dGhpcy5jcm9zc2luZ1N0YWdlKGEpO3RoaXMucGxhY2VtZW50U3RhZ2UoMCxhKX07Cm14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmZpbHRlckRlc2NlbmRhbnRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5tb2RlbDtjLmlzVmVydGV4KGEpJiZhIT10aGlzLnBhcmVudCYmYy5nZXRQYXJlbnQoYSkhPXRoaXMucGFyZW50JiZ0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoYSkmJihiW214T2JqZWN0SWRlbnRpdHkuZ2V0KGEpXT1hKTtpZih0aGlzLnRyYXZlcnNlQW5jZXN0b3JzfHxhPT10aGlzLnBhcmVudCYmdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGEpKWZvcih2YXIgZD1jLmdldENoaWxkQ291bnQoYSksZT0wO2U8ZDtlKyspe3ZhciBmPWMuZ2V0Q2hpbGRBdChhLGUpO3RoaXMuaXNQb3J0KGYpfHx0aGlzLmZpbHRlckRlc2NlbmRhbnRzKGYsYil9fTtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5pc1BvcnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZ2VvbWV0cnkucmVsYXRpdmU/ITA6ITF9OwpteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5nZXRFZGdlc0JldHdlZW49ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOiExO2Zvcih2YXIgZD10aGlzLmdldEVkZ2VzKGEpLGU9W10sZj0wO2Y8ZC5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLmdldFZpc2libGVUZXJtaW5hbChkW2ZdLCEwKSxrPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKGRbZl0sITEpOyhnPT1hJiZrPT1ifHwhYyYmZz09YiYmaz09YSkmJmUucHVzaChkW2ZdKX1yZXR1cm4gZX07Cm14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnRyYXZlcnNlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayl7aWYobnVsbCE9YSYmbnVsbCE9ZCl7dmFyIGw9bXhPYmplY3RJZGVudGl0eS5nZXQoYSk7aWYobnVsbD09ZFtsXSYmKG51bGw9PWd8fG51bGwhPWdbbF0pKXtudWxsPT1lW2xdJiYoZVtsXT1hKTtudWxsPT1kW2xdJiYoZFtsXT1hKTtudWxsIT09ZyYmZGVsZXRlIGdbbF07dmFyIG09dGhpcy5nZXRFZGdlcyhhKSxsPXRoaXMuZ3JhcGgubW9kZWw7Zm9yKGM9MDtjPG0ubGVuZ3RoO2MrKyl7dmFyIG49dGhpcy5nZXRWaXNpYmxlVGVybWluYWwobVtjXSwhMCkscD1uPT1hO3AmJihuPXRoaXMuZ2V0VmlzaWJsZVRlcm1pbmFsKG1bY10sITEpKTt2YXIgcTtmb3IocT0wO3E8dGhpcy5zd2ltbGFuZXMubGVuZ3RoJiYhbC5pc0FuY2VzdG9yKHRoaXMuc3dpbWxhbmVzW3FdLG4pO3ErKyk7cT49dGhpcy5zd2ltbGFuZXMubGVuZ3RofHwhKHE+a3x8KCFifHxwKSYmcT09ayl8fChlPXRoaXMudHJhdmVyc2UobiwKYixtW2NdLGQsZSxmLGcscSkpfX1lbHNlIGlmKG51bGw9PWVbbF0pZm9yKGM9MDtjPGYubGVuZ3RoO2MrKylpZihhPWZbY10sbnVsbCE9YVtsXSl7Zm9yKG0gaW4gYSllW21dPWFbbV07Zi5zcGxpY2UoYywxKTticmVha319cmV0dXJuIGV9O214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmN5Y2xlU3RhZ2U9ZnVuY3Rpb24oYSl7KG5ldyBteFN3aW1sYW5lT3JkZXJpbmcodGhpcykpLmV4ZWN1dGUoYSl9O214U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLmxheWVyaW5nU3RhZ2U9ZnVuY3Rpb24oKXt0aGlzLm1vZGVsLmluaXRpYWxSYW5rKCk7dGhpcy5tb2RlbC5maXhSYW5rcygpfTtteFN3aW1sYW5lTGF5b3V0LnByb3RvdHlwZS5jcm9zc2luZ1N0YWdlPWZ1bmN0aW9uKGEpeyhuZXcgbXhNZWRpYW5IeWJyaWRDcm9zc2luZ1JlZHVjdGlvbih0aGlzKSkuZXhlY3V0ZShhKX07Cm14U3dpbWxhbmVMYXlvdXQucHJvdG90eXBlLnBsYWNlbWVudFN0YWdlPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14Q29vcmRpbmF0ZUFzc2lnbm1lbnQodGhpcyx0aGlzLmludHJhQ2VsbFNwYWNpbmcsdGhpcy5pbnRlclJhbmtDZWxsU3BhY2luZyx0aGlzLm9yaWVudGF0aW9uLGEsdGhpcy5wYXJhbGxlbEVkZ2VTcGFjaW5nKTtjLmZpbmVUdW5pbmc9dGhpcy5maW5lVHVuaW5nO2MuZXhlY3V0ZShiKTtyZXR1cm4gYy5saW1pdFgrdGhpcy5pbnRlckhpZXJhcmNoeVNwYWNpbmd9O2Z1bmN0aW9uIG14R3JhcGhNb2RlbChhKXt0aGlzLmN1cnJlbnRFZGl0PXRoaXMuY3JlYXRlVW5kb2FibGVFZGl0KCk7bnVsbCE9YT90aGlzLnNldFJvb3QoYSk6dGhpcy5jbGVhcigpfW14R3JhcGhNb2RlbC5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teEdyYXBoTW9kZWw7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5yb290PW51bGw7Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuY2VsbHM9bnVsbDtteEdyYXBoTW9kZWwucHJvdG90eXBlLm1haW50YWluRWRnZVBhcmVudD0hMDtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlnbm9yZVJlbGF0aXZlRWRnZVBhcmVudD0hMDtteEdyYXBoTW9kZWwucHJvdG90eXBlLmNyZWF0ZUlkcz0hMDtteEdyYXBoTW9kZWwucHJvdG90eXBlLnByZWZpeD0iIjtteEdyYXBoTW9kZWwucHJvdG90eXBlLnBvc3RmaXg9IiI7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5uZXh0SWQ9MDtteEdyYXBoTW9kZWwucHJvdG90eXBlLmN1cnJlbnRFZGl0PW51bGw7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS51cGRhdGVMZXZlbD0wO214R3JhcGhNb2RlbC5wcm90b3R5cGUuZW5kaW5nVXBkYXRlPSExO214R3JhcGhNb2RlbC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLnNldFJvb3QodGhpcy5jcmVhdGVSb290KCkpfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzQ3JlYXRlSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlSWRzfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRDcmVhdGVJZHM9ZnVuY3Rpb24oYSl7dGhpcy5jcmVhdGVJZHM9YX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jcmVhdGVSb290PWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbDthLmluc2VydChuZXcgbXhDZWxsKTtyZXR1cm4gYX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT10aGlzLmNlbGxzP3RoaXMuY2VsbHNbYV06bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5maWx0ZXJDZWxscz1mdW5jdGlvbihhLGIpe3ZhciBjPW51bGw7aWYobnVsbCE9YSlmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCsrKWIoYVtkXSkmJmMucHVzaChhW2RdKTtyZXR1cm4gY307bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXREZXNjZW5kYW50cz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5maWx0ZXJEZXNjZW5kYW50cyhudWxsLGEpfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5maWx0ZXJEZXNjZW5kYW50cz1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO2I9Ynx8dGhpcy5nZXRSb290KCk7KG51bGw9PWF8fGEoYikpJiZjLnB1c2goYik7Zm9yKHZhciBkPXRoaXMuZ2V0Q2hpbGRDb3VudChiKSxlPTA7ZTxkO2UrKyl2YXIgZj10aGlzLmdldENoaWxkQXQoYixlKSxjPWMuY29uY2F0KHRoaXMuZmlsdGVyRGVzY2VuZGFudHMoYSxmKSk7cmV0dXJuIGN9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Um9vdD1mdW5jdGlvbihhKXt2YXIgYj1hfHx0aGlzLnJvb3Q7aWYobnVsbCE9YSlmb3IoO251bGwhPWE7KWI9YSxhPXRoaXMuZ2V0UGFyZW50KGEpO3JldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnNldFJvb3Q9ZnVuY3Rpb24oYSl7dGhpcy5leGVjdXRlKG5ldyBteFJvb3RDaGFuZ2UodGhpcyxhKSk7cmV0dXJuIGF9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnJvb3RDaGFuZ2VkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucm9vdDt0aGlzLnJvb3Q9YTt0aGlzLm5leHRJZD0wO3RoaXMuY2VsbHM9bnVsbDt0aGlzLmNlbGxBZGRlZChhKTtyZXR1cm4gYn07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc1Jvb3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJnRoaXMucm9vdD09YX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc0xheWVyPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzUm9vdCh0aGlzLmdldFBhcmVudChhKSl9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuaXNBbmNlc3Rvcj1mdW5jdGlvbihhLGIpe2Zvcig7bnVsbCE9YiYmYiE9YTspYj10aGlzLmdldFBhcmVudChiKTtyZXR1cm4gYj09YX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0FuY2VzdG9yKHRoaXMucm9vdCxhKX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0UGFyZW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuZ2V0UGFyZW50KCk6bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSxiLGMpe2lmKGIhPWEmJm51bGwhPWEmJm51bGwhPWIpe251bGw9PWMmJihjPXRoaXMuZ2V0Q2hpbGRDb3VudChhKSk7dmFyIGQ9YSE9dGhpcy5nZXRQYXJlbnQoYik7dGhpcy5leGVjdXRlKG5ldyBteENoaWxkQ2hhbmdlKHRoaXMsYSxiLGMpKTt0aGlzLm1haW50YWluRWRnZVBhcmVudCYmZCYmdGhpcy51cGRhdGVFZGdlUGFyZW50cyhiKX1yZXR1cm4gYn07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuY2VsbEFkZGVkPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe251bGw9PWEuZ2V0SWQoKSYmdGhpcy5jcmVhdGVJZHMmJmEuc2V0SWQodGhpcy5jcmVhdGVJZChhKSk7aWYobnVsbCE9YS5nZXRJZCgpKXt2YXIgYj10aGlzLmdldENlbGwoYS5nZXRJZCgpKTtpZihiIT1hKXtmb3IoO251bGwhPWI7KWEuc2V0SWQodGhpcy5jcmVhdGVJZChhKSksYj10aGlzLmdldENlbGwoYS5nZXRJZCgpKTtudWxsPT10aGlzLmNlbGxzJiYodGhpcy5jZWxscz17fSk7dGhpcy5jZWxsc1thLmdldElkKCldPWF9fW14VXRpbHMuaXNOdW1lcmljKGEuZ2V0SWQoKSkmJih0aGlzLm5leHRJZD1NYXRoLm1heCh0aGlzLm5leHRJZCxhLmdldElkKCkpKTtmb3IodmFyIGI9dGhpcy5nZXRDaGlsZENvdW50KGEpLGM9MDtjPGI7YysrKXRoaXMuY2VsbEFkZGVkKHRoaXMuZ2V0Q2hpbGRBdChhLGMpKX19OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmNyZWF0ZUlkPWZ1bmN0aW9uKGEpe2E9dGhpcy5uZXh0SWQ7dGhpcy5uZXh0SWQrKztyZXR1cm4gdGhpcy5wcmVmaXgrYSt0aGlzLnBvc3RmaXh9O214R3JhcGhNb2RlbC5wcm90b3R5cGUudXBkYXRlRWRnZVBhcmVudHM9ZnVuY3Rpb24oYSxiKXtiPWJ8fHRoaXMuZ2V0Um9vdChhKTtmb3IodmFyIGM9dGhpcy5nZXRDaGlsZENvdW50KGEpLGQ9MDtkPGM7ZCsrKXt2YXIgZT10aGlzLmdldENoaWxkQXQoYSxkKTt0aGlzLnVwZGF0ZUVkZ2VQYXJlbnRzKGUsYil9ZT10aGlzLmdldEVkZ2VDb3VudChhKTtjPVtdO2ZvcihkPTA7ZDxlO2QrKyljLnB1c2godGhpcy5nZXRFZGdlQXQoYSxkKSk7Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyllPWNbZF0sdGhpcy5pc0FuY2VzdG9yKGIsZSkmJnRoaXMudXBkYXRlRWRnZVBhcmVudChlLGIpfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS51cGRhdGVFZGdlUGFyZW50PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuZ2V0VGVybWluYWwoYSwhMCksZD10aGlzLmdldFRlcm1pbmFsKGEsITEpO251bGwhPWMmJiF0aGlzLmlzRWRnZShjKSYmbnVsbCE9Yy5nZW9tZXRyeSYmYy5nZW9tZXRyeS5yZWxhdGl2ZTspYz10aGlzLmdldFBhcmVudChjKTtmb3IoO251bGwhPWQmJnRoaXMuaWdub3JlUmVsYXRpdmVFZGdlUGFyZW50JiYhdGhpcy5pc0VkZ2UoZCkmJm51bGwhPWQuZ2VvbWV0cnkmJmQuZ2VvbWV0cnkucmVsYXRpdmU7KWQ9dGhpcy5nZXRQYXJlbnQoZCk7aWYodGhpcy5pc0FuY2VzdG9yKGIsYykmJnRoaXMuaXNBbmNlc3RvcihiLGQpJiYoYz1jPT1kP3RoaXMuZ2V0UGFyZW50KGMpOnRoaXMuZ2V0TmVhcmVzdENvbW1vbkFuY2VzdG9yKGMsZCksbnVsbCE9YyYmKHRoaXMuZ2V0UGFyZW50KGMpIT10aGlzLnJvb3R8fHRoaXMuaXNBbmNlc3RvcihjLGEpKSYmdGhpcy5nZXRQYXJlbnQoYSkhPQpjKSl7ZD10aGlzLmdldEdlb21ldHJ5KGEpO2lmKG51bGwhPWQpe3ZhciBlPXRoaXMuZ2V0T3JpZ2luKHRoaXMuZ2V0UGFyZW50KGEpKSxmPXRoaXMuZ2V0T3JpZ2luKGMpLGc9Zi54LWUueCxlPWYueS1lLnksZD1kLmNsb25lKCk7ZC50cmFuc2xhdGUoLWcsLWUpO3RoaXMuc2V0R2VvbWV0cnkoYSxkKX10aGlzLmFkZChjLGEsdGhpcy5nZXRDaGlsZENvdW50KGMpKX19O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0T3JpZ2luPWZ1bmN0aW9uKGEpe3ZhciBiO251bGwhPWE/KGI9dGhpcy5nZXRPcmlnaW4odGhpcy5nZXRQYXJlbnQoYSkpLHRoaXMuaXNFZGdlKGEpfHwoYT10aGlzLmdldEdlb21ldHJ5KGEpLG51bGwhPWEmJihiLngrPWEueCxiLnkrPWEueSkpKTpiPW5ldyBteFBvaW50O3JldHVybiBifTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXROZWFyZXN0Q29tbW9uQW5jZXN0b3I9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiZudWxsIT1iKXt2YXIgYz1teENlbGxQYXRoLmNyZWF0ZShiKTtpZihudWxsIT1jJiYwPGMubGVuZ3RoKXt2YXIgZD1hLGU9bXhDZWxsUGF0aC5jcmVhdGUoZCk7aWYoYy5sZW5ndGg8ZS5sZW5ndGgpdmFyIGQ9YixmPWUsZT1jLGM9Zjtmb3IoO251bGwhPWQ7KXtmPXRoaXMuZ2V0UGFyZW50KGQpO2lmKDA9PWMuaW5kZXhPZihlK214Q2VsbFBhdGguUEFUSF9TRVBBUkFUT1IpJiZudWxsIT1mKXJldHVybiBkO2U9bXhDZWxsUGF0aC5nZXRQYXJlbnRQYXRoKGUpO2Q9Zn19fXJldHVybiBudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXthPT10aGlzLnJvb3Q/dGhpcy5zZXRSb290KG51bGwpOm51bGwhPXRoaXMuZ2V0UGFyZW50KGEpJiZ0aGlzLmV4ZWN1dGUobmV3IG14Q2hpbGRDaGFuZ2UodGhpcyxudWxsLGEpKTtyZXR1cm4gYX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuY2VsbFJlbW92ZWQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmbnVsbCE9dGhpcy5jZWxscyl7Zm9yKHZhciBiPXRoaXMuZ2V0Q2hpbGRDb3VudChhKS0xOzA8PWI7Yi0tKXRoaXMuY2VsbFJlbW92ZWQodGhpcy5nZXRDaGlsZEF0KGEsYikpO251bGwhPXRoaXMuY2VsbHMmJm51bGwhPWEuZ2V0SWQoKSYmZGVsZXRlIHRoaXMuY2VsbHNbYS5nZXRJZCgpXX19O214R3JhcGhNb2RlbC5wcm90b3R5cGUucGFyZW50Rm9yQ2VsbENoYW5nZWQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ2V0UGFyZW50KGEpO251bGwhPWI/Yj09ZCYmZC5nZXRJbmRleChhKT09Y3x8Yi5pbnNlcnQoYSxjKTpudWxsIT1kJiYoYz1kLmdldEluZGV4KGEpLGQucmVtb3ZlKGMpKTtiPXRoaXMuY29udGFpbnMoYik7Yz10aGlzLmNvbnRhaW5zKGQpO2ImJiFjP3RoaXMuY2VsbEFkZGVkKGEpOmMmJiFiJiZ0aGlzLmNlbGxSZW1vdmVkKGEpO3JldHVybiBkfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRDaGlsZENvdW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuZ2V0Q2hpbGRDb3VudCgpOjB9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Q2hpbGRBdD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hP2EuZ2V0Q2hpbGRBdChiKTpudWxsfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldENoaWxkcmVuPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuY2hpbGRyZW46bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRDaGlsZFZlcnRpY2VzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldENoaWxkQ2VsbHMoYSwhMCwhMSl9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0Q2hpbGRFZGdlcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRDaGlsZENlbGxzKGEsITEsITApfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRDaGlsZENlbGxzPWZ1bmN0aW9uKGEsYixjKXtiPW51bGwhPWI/YjohMTtjPW51bGwhPWM/YzohMTtmb3IodmFyIGQ9dGhpcy5nZXRDaGlsZENvdW50KGEpLGU9W10sZj0wO2Y8ZDtmKyspe3ZhciBnPXRoaXMuZ2V0Q2hpbGRBdChhLGYpOyghYyYmIWJ8fGMmJnRoaXMuaXNFZGdlKGcpfHxiJiZ0aGlzLmlzVmVydGV4KGcpKSYmZS5wdXNoKGcpfXJldHVybiBlfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldFRlcm1pbmFsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWE/YS5nZXRUZXJtaW5hbChiKTpudWxsfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRUZXJtaW5hbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YiE9dGhpcy5nZXRUZXJtaW5hbChhLGMpO3RoaXMuZXhlY3V0ZShuZXcgbXhUZXJtaW5hbENoYW5nZSh0aGlzLGEsYixjKSk7dGhpcy5tYWludGFpbkVkZ2VQYXJlbnQmJmQmJnRoaXMudXBkYXRlRWRnZVBhcmVudChhLHRoaXMuZ2V0Um9vdCgpKTtyZXR1cm4gYn07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRUZXJtaW5hbHM9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5zZXRUZXJtaW5hbChhLGIsITApLHRoaXMuc2V0VGVybWluYWwoYSxjLCExKX1maW5hbGx5e3RoaXMuZW5kVXBkYXRlKCl9fTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS50ZXJtaW5hbEZvckNlbGxDaGFuZ2VkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdldFRlcm1pbmFsKGEsYyk7bnVsbCE9Yj9iLmluc2VydEVkZ2UoYSxjKTpudWxsIT1kJiZkLnJlbW92ZUVkZ2UoYSxjKTtyZXR1cm4gZH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRFZGdlQ291bnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5nZXRFZGdlQ291bnQoKTowfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldEVkZ2VBdD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hP2EuZ2V0RWRnZUF0KGIpOm51bGx9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0RGlyZWN0ZWRFZGdlQ291bnQ9ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wLGU9dGhpcy5nZXRFZGdlQ291bnQoYSksZj0wO2Y8ZTtmKyspe3ZhciBnPXRoaXMuZ2V0RWRnZUF0KGEsZik7ZyE9YyYmdGhpcy5nZXRUZXJtaW5hbChnLGIpPT1hJiZkKyt9cmV0dXJuIGR9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldENvbm5lY3Rpb25zPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldEVkZ2VzKGEsITAsITAsITEpfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldEluY29taW5nRWRnZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoYSwhMCwhMSwhMSl9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0T3V0Z29pbmdFZGdlcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRFZGdlcyhhLCExLCEwLCExKX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0RWRnZXM9ZnVuY3Rpb24oYSxiLGMsZCl7Yj1udWxsIT1iP2I6ITA7Yz1udWxsIT1jP2M6ITA7ZD1udWxsIT1kP2Q6ITA7Zm9yKHZhciBlPXRoaXMuZ2V0RWRnZUNvdW50KGEpLGY9W10sZz0wO2c8ZTtnKyspe3ZhciBrPXRoaXMuZ2V0RWRnZUF0KGEsZyksbD10aGlzLmdldFRlcm1pbmFsKGssITApLG09dGhpcy5nZXRUZXJtaW5hbChrLCExKTsoZCYmbD09bXx8bCE9bSYmKGImJm09PWF8fGMmJmw9PWEpKSYmZi5wdXNoKGspfXJldHVybiBmfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRFZGdlc0JldHdlZW49ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9Yz9jOiExO3ZhciBkPXRoaXMuZ2V0RWRnZUNvdW50KGEpLGU9dGhpcy5nZXRFZGdlQ291bnQoYiksZj1hLGc9ZDtlPGQmJihnPWUsZj1iKTtkPVtdO2ZvcihlPTA7ZTxnO2UrKyl7dmFyIGs9dGhpcy5nZXRFZGdlQXQoZixlKSxsPXRoaXMuZ2V0VGVybWluYWwoaywhMCksbT10aGlzLmdldFRlcm1pbmFsKGssITEpLG49bT09YSYmbD09YjsobD09YSYmbT09Ynx8IWMmJm4pJiZkLnB1c2goayl9cmV0dXJuIGR9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldE9wcG9zaXRlcz1mdW5jdGlvbihhLGIsYyxkKXtjPW51bGwhPWM/YzohMDtkPW51bGwhPWQ/ZDohMDt2YXIgZT1bXTtpZihudWxsIT1hKWZvcih2YXIgZj0wO2Y8YS5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLmdldFRlcm1pbmFsKGFbZl0sITApLGs9dGhpcy5nZXRUZXJtaW5hbChhW2ZdLCExKTtnPT1iJiZudWxsIT1rJiZrIT1iJiZkP2UucHVzaChrKTprPT1iJiZudWxsIT1nJiZnIT1iJiZjJiZlLnB1c2goZyl9cmV0dXJuIGV9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmdldFRvcG1vc3RDZWxscz1mdW5jdGlvbihhKXtmb3IodmFyIGI9bmV3IG14RGljdGlvbmFyeSxjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKyliLnB1dChhW2RdLCEwKTtmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKXtmb3IodmFyIGU9YVtkXSxmPSEwLGc9dGhpcy5nZXRQYXJlbnQoZSk7bnVsbCE9Zzspe2lmKGIuZ2V0KGcpKXtmPSExO2JyZWFrfWc9dGhpcy5nZXRQYXJlbnQoZyl9ZiYmYy5wdXNoKGUpfXJldHVybiBjfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmlzVmVydGV4PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuaXNWZXJ0ZXgoKTohMX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc0VkZ2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5pc0VkZ2UoKTohMX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP2EuaXNDb25uZWN0YWJsZSgpOiExfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRWYWx1ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmdldFZhbHVlKCk6bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRWYWx1ZT1mdW5jdGlvbihhLGIpe3RoaXMuZXhlY3V0ZShuZXcgbXhWYWx1ZUNoYW5nZSh0aGlzLGEsYikpO3JldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnZhbHVlRm9yQ2VsbENoYW5nZWQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS52YWx1ZUNoYW5nZWQoYil9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0R2VvbWV0cnk9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5nZXRHZW9tZXRyeSgpOm51bGx9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuc2V0R2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXtiIT10aGlzLmdldEdlb21ldHJ5KGEpJiZ0aGlzLmV4ZWN1dGUobmV3IG14R2VvbWV0cnlDaGFuZ2UodGhpcyxhLGIpKTtyZXR1cm4gYn07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2VvbWV0cnlGb3JDZWxsQ2hhbmdlZD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0R2VvbWV0cnkoYSk7YS5zZXRHZW9tZXRyeShiKTtyZXR1cm4gY307bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5nZXRTdHlsZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hLmdldFN0eWxlKCk6bnVsbH07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRTdHlsZT1mdW5jdGlvbihhLGIpe2IhPXRoaXMuZ2V0U3R5bGUoYSkmJnRoaXMuZXhlY3V0ZShuZXcgbXhTdHlsZUNoYW5nZSh0aGlzLGEsYikpO3JldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLnN0eWxlRm9yQ2VsbENoYW5nZWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldFN0eWxlKGEpO2Euc2V0U3R5bGUoYik7cmV0dXJuIGN9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuaXNDb2xsYXBzZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5pc0NvbGxhcHNlZCgpOiExfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRDb2xsYXBzZWQ9ZnVuY3Rpb24oYSxiKXtiIT10aGlzLmlzQ29sbGFwc2VkKGEpJiZ0aGlzLmV4ZWN1dGUobmV3IG14Q29sbGFwc2VDaGFuZ2UodGhpcyxhLGIpKTtyZXR1cm4gYn07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5jb2xsYXBzZWRTdGF0ZUZvckNlbGxDaGFuZ2VkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5pc0NvbGxhcHNlZChhKTthLnNldENvbGxhcHNlZChiKTtyZXR1cm4gY307bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pc1Zpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/YS5pc1Zpc2libGUoKTohMX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5zZXRWaXNpYmxlPWZ1bmN0aW9uKGEsYil7YiE9dGhpcy5pc1Zpc2libGUoYSkmJnRoaXMuZXhlY3V0ZShuZXcgbXhWaXNpYmxlQ2hhbmdlKHRoaXMsYSxiKSk7cmV0dXJuIGJ9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLnZpc2libGVTdGF0ZUZvckNlbGxDaGFuZ2VkPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5pc1Zpc2libGUoYSk7YS5zZXRWaXNpYmxlKGIpO3JldHVybiBjfTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7YS5leGVjdXRlKCk7dGhpcy5iZWdpblVwZGF0ZSgpO3RoaXMuY3VycmVudEVkaXQuYWRkKGEpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRVhFQ1VURSwiY2hhbmdlIixhKSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5FWEVDVVRFRCwiY2hhbmdlIixhKSk7dGhpcy5lbmRVcGRhdGUoKX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5iZWdpblVwZGF0ZT1mdW5jdGlvbigpe3RoaXMudXBkYXRlTGV2ZWwrKzt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkJFR0lOX1VQREFURSkpOzE9PXRoaXMudXBkYXRlTGV2ZWwmJnRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU1RBUlRfRURJVCkpfTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5lbmRVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZUxldmVsLS07MD09dGhpcy51cGRhdGVMZXZlbCYmdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5FTkRfRURJVCkpO2lmKCF0aGlzLmVuZGluZ1VwZGF0ZSl7dGhpcy5lbmRpbmdVcGRhdGU9MD09dGhpcy51cGRhdGVMZXZlbDt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVORF9VUERBVEUsImVkaXQiLHRoaXMuY3VycmVudEVkaXQpKTt0cnl7aWYodGhpcy5lbmRpbmdVcGRhdGUmJiF0aGlzLmN1cnJlbnRFZGl0LmlzRW1wdHkoKSl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5CRUZPUkVfVU5ETywiZWRpdCIsdGhpcy5jdXJyZW50RWRpdCkpO3ZhciBhPXRoaXMuY3VycmVudEVkaXQ7dGhpcy5jdXJyZW50RWRpdD10aGlzLmNyZWF0ZVVuZG9hYmxlRWRpdCgpO2Eubm90aWZ5KCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5VTkRPLAoiZWRpdCIsYSkpfX1maW5hbGx5e3RoaXMuZW5kaW5nVXBkYXRlPSExfX19O214R3JhcGhNb2RlbC5wcm90b3R5cGUuY3JlYXRlVW5kb2FibGVFZGl0PWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBteFVuZG9hYmxlRWRpdCh0aGlzLG51bGwhPWE/YTohMCk7Yi5ub3RpZnk9ZnVuY3Rpb24oKXtiLnNvdXJjZS5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DSEFOR0UsImVkaXQiLGIsImNoYW5nZXMiLGIuY2hhbmdlcykpO2Iuc291cmNlLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk5PVElGWSwiZWRpdCIsYiwiY2hhbmdlcyIsYi5jaGFuZ2VzKSl9O3JldHVybiBifTsKbXhHcmFwaE1vZGVsLnByb3RvdHlwZS5tZXJnZUNoaWxkcmVuPWZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/YzohMDt0aGlzLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBkPXt9O3RoaXMubWVyZ2VDaGlsZHJlbkltcGwoYSxiLGMsZCk7Zm9yKHZhciBlIGluIGQpe3ZhciBmPWRbZV0sZz10aGlzLmdldFRlcm1pbmFsKGYsITApO251bGwhPWcmJihnPWRbbXhDZWxsUGF0aC5jcmVhdGUoZyldLHRoaXMuc2V0VGVybWluYWwoZixnLCEwKSk7Zz10aGlzLmdldFRlcm1pbmFsKGYsITEpO251bGwhPWcmJihnPWRbbXhDZWxsUGF0aC5jcmVhdGUoZyldLHRoaXMuc2V0VGVybWluYWwoZixnLCExKSl9fWZpbmFsbHl7dGhpcy5lbmRVcGRhdGUoKX19OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLm1lcmdlQ2hpbGRyZW5JbXBsPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPWEuZ2V0Q2hpbGRDb3VudCgpLGY9MDtmPGU7ZisrKXt2YXIgZz1hLmdldENoaWxkQXQoZik7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGcuZ2V0SWQpe3ZhciBrPWcuZ2V0SWQoKSxsPW51bGw9PWt8fHRoaXMuaXNFZGdlKGcpJiZjP251bGw6dGhpcy5nZXRDZWxsKGspO2lmKG51bGw9PWwpe3ZhciBtPWcuY2xvbmUoKTttLnNldElkKGspO20uc2V0VGVybWluYWwoZy5nZXRUZXJtaW5hbCghMCksITApO20uc2V0VGVybWluYWwoZy5nZXRUZXJtaW5hbCghMSksITEpO2w9Yi5pbnNlcnQobSk7dGhpcy5jZWxsQWRkZWQobCl9ZFtteENlbGxQYXRoLmNyZWF0ZShnKV09bDt0aGlzLm1lcmdlQ2hpbGRyZW5JbXBsKGcsbCxjLGQpfX19ZmluYWxseXt0aGlzLmVuZFVwZGF0ZSgpfX07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuZ2V0UGFyZW50cz1mdW5jdGlvbihhKXt2YXIgYj1bXTtpZihudWxsIT1hKWZvcih2YXIgYz1uZXcgbXhEaWN0aW9uYXJ5LGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5nZXRQYXJlbnQoYVtkXSk7bnVsbD09ZXx8Yy5nZXQoZSl8fChjLnB1dChlLCEwKSxiLnB1c2goZSkpfXJldHVybiBifTtteEdyYXBoTW9kZWwucHJvdG90eXBlLmNsb25lQ2VsbD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hP3RoaXMuY2xvbmVDZWxscyhbYV0sYilbMF06bnVsbH07Cm14R3JhcGhNb2RlbC5wcm90b3R5cGUuY2xvbmVDZWxscz1mdW5jdGlvbihhLGIsYyl7Yj1udWxsIT1iP2I6ITA7Yz1udWxsIT1jP2M6e307Zm9yKHZhciBkPVtdLGU9MDtlPGEubGVuZ3RoO2UrKyludWxsIT1hW2VdP2QucHVzaCh0aGlzLmNsb25lQ2VsbEltcGwoYVtlXSxjLGIpKTpkLnB1c2gobnVsbCk7Zm9yKGU9MDtlPGQubGVuZ3RoO2UrKyludWxsIT1kW2VdJiZ0aGlzLnJlc3RvcmVDbG9uZShkW2VdLGFbZV0sYyk7cmV0dXJuIGR9O214R3JhcGhNb2RlbC5wcm90b3R5cGUuY2xvbmVDZWxsSW1wbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bXhPYmplY3RJZGVudGl0eS5nZXQoYSksZT1iW2RdO2lmKG51bGw9PWUmJihlPXRoaXMuY2VsbENsb25lZChhKSxiW2RdPWUsYykpZm9yKGM9dGhpcy5nZXRDaGlsZENvdW50KGEpLGQ9MDtkPGM7ZCsrKXt2YXIgZj10aGlzLmNsb25lQ2VsbEltcGwodGhpcy5nZXRDaGlsZEF0KGEsZCksYiwhMCk7ZS5pbnNlcnQoZil9cmV0dXJuIGV9OwpteEdyYXBoTW9kZWwucHJvdG90eXBlLmNlbGxDbG9uZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2xvbmUoKX07bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5yZXN0b3JlQ2xvbmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ2V0VGVybWluYWwoYiwhMCk7bnVsbCE9ZCYmKGQ9Y1tteE9iamVjdElkZW50aXR5LmdldChkKV0sbnVsbCE9ZCYmZC5pbnNlcnRFZGdlKGEsITApKTtkPXRoaXMuZ2V0VGVybWluYWwoYiwhMSk7bnVsbCE9ZCYmKGQ9Y1tteE9iamVjdElkZW50aXR5LmdldChkKV0sbnVsbCE9ZCYmZC5pbnNlcnRFZGdlKGEsITEpKTtmb3IodmFyIGQ9dGhpcy5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGQ7ZSsrKXRoaXMucmVzdG9yZUNsb25lKHRoaXMuZ2V0Q2hpbGRBdChhLGUpLHRoaXMuZ2V0Q2hpbGRBdChiLGUpLGMpfTtmdW5jdGlvbiBteFJvb3RDaGFuZ2UoYSxiKXt0aGlzLm1vZGVsPWE7dGhpcy5wcmV2aW91cz10aGlzLnJvb3Q9Yn0KbXhSb290Q2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dGhpcy5yb290PXRoaXMucHJldmlvdXM7dGhpcy5wcmV2aW91cz10aGlzLm1vZGVsLnJvb3RDaGFuZ2VkKHRoaXMucHJldmlvdXMpfTtmdW5jdGlvbiBteENoaWxkQ2hhbmdlKGEsYixjLGQpe3RoaXMubW9kZWw9YTt0aGlzLnByZXZpb3VzPXRoaXMucGFyZW50PWI7dGhpcy5jaGlsZD1jO3RoaXMucHJldmlvdXNJbmRleD10aGlzLmluZGV4PWR9Cm14Q2hpbGRDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmNoaWxkKXt2YXIgYT10aGlzLm1vZGVsLmdldFBhcmVudCh0aGlzLmNoaWxkKSxiPW51bGwhPWE/YS5nZXRJbmRleCh0aGlzLmNoaWxkKTowO251bGw9PXRoaXMucHJldmlvdXMmJnRoaXMuY29ubmVjdCh0aGlzLmNoaWxkLCExKTthPXRoaXMubW9kZWwucGFyZW50Rm9yQ2VsbENoYW5nZWQodGhpcy5jaGlsZCx0aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXNJbmRleCk7bnVsbCE9dGhpcy5wcmV2aW91cyYmdGhpcy5jb25uZWN0KHRoaXMuY2hpbGQsITApO3RoaXMucGFyZW50PXRoaXMucHJldmlvdXM7dGhpcy5wcmV2aW91cz1hO3RoaXMuaW5kZXg9dGhpcy5wcmV2aW91c0luZGV4O3RoaXMucHJldmlvdXNJbmRleD1ifX07Cm14Q2hpbGRDaGFuZ2UucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDt2YXIgYz1hLmdldFRlcm1pbmFsKCEwKSxkPWEuZ2V0VGVybWluYWwoITEpO251bGwhPWMmJihiP3RoaXMubW9kZWwudGVybWluYWxGb3JDZWxsQ2hhbmdlZChhLGMsITApOnRoaXMubW9kZWwudGVybWluYWxGb3JDZWxsQ2hhbmdlZChhLG51bGwsITApKTtudWxsIT1kJiYoYj90aGlzLm1vZGVsLnRlcm1pbmFsRm9yQ2VsbENoYW5nZWQoYSxkLCExKTp0aGlzLm1vZGVsLnRlcm1pbmFsRm9yQ2VsbENoYW5nZWQoYSxudWxsLCExKSk7YS5zZXRUZXJtaW5hbChjLCEwKTthLnNldFRlcm1pbmFsKGQsITEpO2M9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpO2ZvcihkPTA7ZDxjO2QrKyl0aGlzLmNvbm5lY3QodGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsZCksYil9OwpmdW5jdGlvbiBteFRlcm1pbmFsQ2hhbmdlKGEsYixjLGQpe3RoaXMubW9kZWw9YTt0aGlzLmNlbGw9Yjt0aGlzLnByZXZpb3VzPXRoaXMudGVybWluYWw9Yzt0aGlzLnNvdXJjZT1kfW14VGVybWluYWxDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmNlbGwmJih0aGlzLnRlcm1pbmFsPXRoaXMucHJldmlvdXMsdGhpcy5wcmV2aW91cz10aGlzLm1vZGVsLnRlcm1pbmFsRm9yQ2VsbENoYW5nZWQodGhpcy5jZWxsLHRoaXMucHJldmlvdXMsdGhpcy5zb3VyY2UpKX07ZnVuY3Rpb24gbXhWYWx1ZUNoYW5nZShhLGIsYyl7dGhpcy5tb2RlbD1hO3RoaXMuY2VsbD1iO3RoaXMucHJldmlvdXM9dGhpcy52YWx1ZT1jfQpteFZhbHVlQ2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jZWxsJiYodGhpcy52YWx1ZT10aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXM9dGhpcy5tb2RlbC52YWx1ZUZvckNlbGxDaGFuZ2VkKHRoaXMuY2VsbCx0aGlzLnByZXZpb3VzKSl9O2Z1bmN0aW9uIG14U3R5bGVDaGFuZ2UoYSxiLGMpe3RoaXMubW9kZWw9YTt0aGlzLmNlbGw9Yjt0aGlzLnByZXZpb3VzPXRoaXMuc3R5bGU9Y31teFN0eWxlQ2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jZWxsJiYodGhpcy5zdHlsZT10aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXM9dGhpcy5tb2RlbC5zdHlsZUZvckNlbGxDaGFuZ2VkKHRoaXMuY2VsbCx0aGlzLnByZXZpb3VzKSl9O2Z1bmN0aW9uIG14R2VvbWV0cnlDaGFuZ2UoYSxiLGMpe3RoaXMubW9kZWw9YTt0aGlzLmNlbGw9Yjt0aGlzLnByZXZpb3VzPXRoaXMuZ2VvbWV0cnk9Y30KbXhHZW9tZXRyeUNoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe251bGwhPXRoaXMuY2VsbCYmKHRoaXMuZ2VvbWV0cnk9dGhpcy5wcmV2aW91cyx0aGlzLnByZXZpb3VzPXRoaXMubW9kZWwuZ2VvbWV0cnlGb3JDZWxsQ2hhbmdlZCh0aGlzLmNlbGwsdGhpcy5wcmV2aW91cykpfTtmdW5jdGlvbiBteENvbGxhcHNlQ2hhbmdlKGEsYixjKXt0aGlzLm1vZGVsPWE7dGhpcy5jZWxsPWI7dGhpcy5wcmV2aW91cz10aGlzLmNvbGxhcHNlZD1jfW14Q29sbGFwc2VDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmNlbGwmJih0aGlzLmNvbGxhcHNlZD10aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXM9dGhpcy5tb2RlbC5jb2xsYXBzZWRTdGF0ZUZvckNlbGxDaGFuZ2VkKHRoaXMuY2VsbCx0aGlzLnByZXZpb3VzKSl9OwpmdW5jdGlvbiBteFZpc2libGVDaGFuZ2UoYSxiLGMpe3RoaXMubW9kZWw9YTt0aGlzLmNlbGw9Yjt0aGlzLnByZXZpb3VzPXRoaXMudmlzaWJsZT1jfW14VmlzaWJsZUNoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe251bGwhPXRoaXMuY2VsbCYmKHRoaXMudmlzaWJsZT10aGlzLnByZXZpb3VzLHRoaXMucHJldmlvdXM9dGhpcy5tb2RlbC52aXNpYmxlU3RhdGVGb3JDZWxsQ2hhbmdlZCh0aGlzLmNlbGwsdGhpcy5wcmV2aW91cykpfTtmdW5jdGlvbiBteENlbGxBdHRyaWJ1dGVDaGFuZ2UoYSxiLGMpe3RoaXMuY2VsbD1hO3RoaXMuYXR0cmlidXRlPWI7dGhpcy5wcmV2aW91cz10aGlzLnZhbHVlPWN9Cm14Q2VsbEF0dHJpYnV0ZUNoYW5nZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuY2VsbCl7dmFyIGE9dGhpcy5jZWxsLmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZSk7bnVsbD09dGhpcy5wcmV2aW91cz90aGlzLmNlbGwudmFsdWUucmVtb3ZlQXR0cmlidXRlKHRoaXMuYXR0cmlidXRlKTp0aGlzLmNlbGwuc2V0QXR0cmlidXRlKHRoaXMuYXR0cmlidXRlLHRoaXMucHJldmlvdXMpO3RoaXMucHJldmlvdXM9YX19O2Z1bmN0aW9uIG14Q2VsbChhLGIsYyl7dGhpcy52YWx1ZT1hO3RoaXMuc2V0R2VvbWV0cnkoYik7dGhpcy5zZXRTdHlsZShjKTtpZihudWxsIT10aGlzLm9uSW5pdCl0aGlzLm9uSW5pdCgpfW14Q2VsbC5wcm90b3R5cGUuaWQ9bnVsbDtteENlbGwucHJvdG90eXBlLnZhbHVlPW51bGw7bXhDZWxsLnByb3RvdHlwZS5nZW9tZXRyeT1udWxsO214Q2VsbC5wcm90b3R5cGUuc3R5bGU9bnVsbDtteENlbGwucHJvdG90eXBlLnZlcnRleD0hMTsKbXhDZWxsLnByb3RvdHlwZS5lZGdlPSExO214Q2VsbC5wcm90b3R5cGUuY29ubmVjdGFibGU9ITA7bXhDZWxsLnByb3RvdHlwZS52aXNpYmxlPSEwO214Q2VsbC5wcm90b3R5cGUuY29sbGFwc2VkPSExO214Q2VsbC5wcm90b3R5cGUucGFyZW50PW51bGw7bXhDZWxsLnByb3RvdHlwZS5zb3VyY2U9bnVsbDtteENlbGwucHJvdG90eXBlLnRhcmdldD1udWxsO214Q2VsbC5wcm90b3R5cGUuY2hpbGRyZW49bnVsbDtteENlbGwucHJvdG90eXBlLmVkZ2VzPW51bGw7bXhDZWxsLnByb3RvdHlwZS5teFRyYW5zaWVudD0iaWQgdmFsdWUgcGFyZW50IHNvdXJjZSB0YXJnZXQgY2hpbGRyZW4gZWRnZXMiLnNwbGl0KCIgIik7bXhDZWxsLnByb3RvdHlwZS5nZXRJZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlkfTtteENlbGwucHJvdG90eXBlLnNldElkPWZ1bmN0aW9uKGEpe3RoaXMuaWQ9YX07bXhDZWxsLnByb3RvdHlwZS5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfTsKbXhDZWxsLnByb3RvdHlwZS5zZXRWYWx1ZT1mdW5jdGlvbihhKXt0aGlzLnZhbHVlPWF9O214Q2VsbC5wcm90b3R5cGUudmFsdWVDaGFuZ2VkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0VmFsdWUoKTt0aGlzLnNldFZhbHVlKGEpO3JldHVybiBifTtteENlbGwucHJvdG90eXBlLmdldEdlb21ldHJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnl9O214Q2VsbC5wcm90b3R5cGUuc2V0R2VvbWV0cnk9ZnVuY3Rpb24oYSl7dGhpcy5nZW9tZXRyeT1hfTtteENlbGwucHJvdG90eXBlLmdldFN0eWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3R5bGV9O214Q2VsbC5wcm90b3R5cGUuc2V0U3R5bGU9ZnVuY3Rpb24oYSl7dGhpcy5zdHlsZT1hfTtteENlbGwucHJvdG90eXBlLmlzVmVydGV4PWZ1bmN0aW9uKCl7cmV0dXJuIDAhPXRoaXMudmVydGV4fTtteENlbGwucHJvdG90eXBlLnNldFZlcnRleD1mdW5jdGlvbihhKXt0aGlzLnZlcnRleD1hfTsKbXhDZWxsLnByb3RvdHlwZS5pc0VkZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9dGhpcy5lZGdlfTtteENlbGwucHJvdG90eXBlLnNldEVkZ2U9ZnVuY3Rpb24oYSl7dGhpcy5lZGdlPWF9O214Q2VsbC5wcm90b3R5cGUuaXNDb25uZWN0YWJsZT1mdW5jdGlvbigpe3JldHVybiAwIT10aGlzLmNvbm5lY3RhYmxlfTtteENlbGwucHJvdG90eXBlLnNldENvbm5lY3RhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY29ubmVjdGFibGU9YX07bXhDZWxsLnByb3RvdHlwZS5pc1Zpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9dGhpcy52aXNpYmxlfTtteENlbGwucHJvdG90eXBlLnNldFZpc2libGU9ZnVuY3Rpb24oYSl7dGhpcy52aXNpYmxlPWF9O214Q2VsbC5wcm90b3R5cGUuaXNDb2xsYXBzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9dGhpcy5jb2xsYXBzZWR9O214Q2VsbC5wcm90b3R5cGUuc2V0Q29sbGFwc2VkPWZ1bmN0aW9uKGEpe3RoaXMuY29sbGFwc2VkPWF9OwpteENlbGwucHJvdG90eXBlLmdldFBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudH07bXhDZWxsLnByb3RvdHlwZS5zZXRQYXJlbnQ9ZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnQ9YX07bXhDZWxsLnByb3RvdHlwZS5nZXRUZXJtaW5hbD1mdW5jdGlvbihhKXtyZXR1cm4gYT90aGlzLnNvdXJjZTp0aGlzLnRhcmdldH07bXhDZWxsLnByb3RvdHlwZS5zZXRUZXJtaW5hbD1mdW5jdGlvbihhLGIpe2I/dGhpcy5zb3VyY2U9YTp0aGlzLnRhcmdldD1hO3JldHVybiBhfTtteENlbGwucHJvdG90eXBlLmdldENoaWxkQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5jaGlsZHJlbj8wOnRoaXMuY2hpbGRyZW4ubGVuZ3RofTtteENlbGwucHJvdG90eXBlLmdldEluZGV4PWZ1bmN0aW9uKGEpe3JldHVybiBteFV0aWxzLmluZGV4T2YodGhpcy5jaGlsZHJlbixhKX07Cm14Q2VsbC5wcm90b3R5cGUuZ2V0Q2hpbGRBdD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09dGhpcy5jaGlsZHJlbj9udWxsOnRoaXMuY2hpbGRyZW5bYV19O214Q2VsbC5wcm90b3R5cGUuaW5zZXJ0PWZ1bmN0aW9uKGEsYil7bnVsbCE9YSYmKG51bGw9PWImJihiPXRoaXMuZ2V0Q2hpbGRDb3VudCgpLGEuZ2V0UGFyZW50KCk9PXRoaXMmJmItLSksYS5yZW1vdmVGcm9tUGFyZW50KCksYS5zZXRQYXJlbnQodGhpcyksbnVsbD09dGhpcy5jaGlsZHJlbj8odGhpcy5jaGlsZHJlbj1bXSx0aGlzLmNoaWxkcmVuLnB1c2goYSkpOnRoaXMuY2hpbGRyZW4uc3BsaWNlKGIsMCxhKSk7cmV0dXJuIGF9O214Q2VsbC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9dGhpcy5jaGlsZHJlbiYmMDw9YSYmKGI9dGhpcy5nZXRDaGlsZEF0KGEpLG51bGwhPWImJih0aGlzLmNoaWxkcmVuLnNwbGljZShhLDEpLGIuc2V0UGFyZW50KG51bGwpKSk7cmV0dXJuIGJ9OwpteENlbGwucHJvdG90eXBlLnJlbW92ZUZyb21QYXJlbnQ9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnBhcmVudCl7dmFyIGE9dGhpcy5wYXJlbnQuZ2V0SW5kZXgodGhpcyk7dGhpcy5wYXJlbnQucmVtb3ZlKGEpfX07bXhDZWxsLnByb3RvdHlwZS5nZXRFZGdlQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5lZGdlcz8wOnRoaXMuZWRnZXMubGVuZ3RofTtteENlbGwucHJvdG90eXBlLmdldEVkZ2VJbmRleD1mdW5jdGlvbihhKXtyZXR1cm4gbXhVdGlscy5pbmRleE9mKHRoaXMuZWRnZXMsYSl9O214Q2VsbC5wcm90b3R5cGUuZ2V0RWRnZUF0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT10aGlzLmVkZ2VzP251bGw6dGhpcy5lZGdlc1thXX07Cm14Q2VsbC5wcm90b3R5cGUuaW5zZXJ0RWRnZT1mdW5jdGlvbihhLGIpe251bGwhPWEmJihhLnJlbW92ZUZyb21UZXJtaW5hbChiKSxhLnNldFRlcm1pbmFsKHRoaXMsYiksbnVsbD09dGhpcy5lZGdlc3x8YS5nZXRUZXJtaW5hbCghYikhPXRoaXN8fDA+bXhVdGlscy5pbmRleE9mKHRoaXMuZWRnZXMsYSkpJiYobnVsbD09dGhpcy5lZGdlcyYmKHRoaXMuZWRnZXM9W10pLHRoaXMuZWRnZXMucHVzaChhKSk7cmV0dXJuIGF9O214Q2VsbC5wcm90b3R5cGUucmVtb3ZlRWRnZT1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe2lmKGEuZ2V0VGVybWluYWwoIWIpIT10aGlzJiZudWxsIT10aGlzLmVkZ2VzKXt2YXIgYz10aGlzLmdldEVkZ2VJbmRleChhKTswPD1jJiZ0aGlzLmVkZ2VzLnNwbGljZShjLDEpfWEuc2V0VGVybWluYWwobnVsbCxiKX1yZXR1cm4gYX07Cm14Q2VsbC5wcm90b3R5cGUucmVtb3ZlRnJvbVRlcm1pbmFsPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0VGVybWluYWwoYSk7bnVsbCE9YiYmYi5yZW1vdmVFZGdlKHRoaXMsYSl9O214Q2VsbC5wcm90b3R5cGUuaGFzQXR0cmlidXRlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0VmFsdWUoKTtyZXR1cm4gbnVsbCE9YiYmYi5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmYi5oYXNBdHRyaWJ1dGU/Yi5oYXNBdHRyaWJ1dGUoYSk6bnVsbCE9Yi5nZXRBdHRyaWJ1dGUoYSl9O214Q2VsbC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRWYWx1ZSgpLGM9bnVsbCE9YyYmYy5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVD9jLmdldEF0dHJpYnV0ZShhKTpudWxsO3JldHVybiBudWxsIT1jP2M6Yn07Cm14Q2VsbC5wcm90b3R5cGUuc2V0QXR0cmlidXRlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRWYWx1ZSgpO251bGwhPWMmJmMubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQmJmMuc2V0QXR0cmlidXRlKGEsYil9O214Q2VsbC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1teFV0aWxzLmNsb25lKHRoaXMsdGhpcy5teFRyYW5zaWVudCk7YS5zZXRWYWx1ZSh0aGlzLmNsb25lVmFsdWUoKSk7cmV0dXJuIGF9O214Q2VsbC5wcm90b3R5cGUuY2xvbmVWYWx1ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0VmFsdWUoKTtudWxsIT1hJiYoImZ1bmN0aW9uIj09dHlwZW9mIGEuY2xvbmU/YT1hLmNsb25lKCk6aXNOYU4oYS5ub2RlVHlwZSl8fChhPWEuY2xvbmVOb2RlKCEwKSkpO3JldHVybiBhfTtmdW5jdGlvbiBteEdlb21ldHJ5KGEsYixjLGQpe214UmVjdGFuZ2xlLmNhbGwodGhpcyxhLGIsYyxkKX1teEdlb21ldHJ5LnByb3RvdHlwZT1uZXcgbXhSZWN0YW5nbGU7Cm14R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14R2VvbWV0cnk7bXhHZW9tZXRyeS5wcm90b3R5cGUuVFJBTlNMQVRFX0NPTlRST0xfUE9JTlRTPSEwO214R2VvbWV0cnkucHJvdG90eXBlLmFsdGVybmF0ZUJvdW5kcz1udWxsO214R2VvbWV0cnkucHJvdG90eXBlLnNvdXJjZVBvaW50PW51bGw7bXhHZW9tZXRyeS5wcm90b3R5cGUudGFyZ2V0UG9pbnQ9bnVsbDtteEdlb21ldHJ5LnByb3RvdHlwZS5wb2ludHM9bnVsbDtteEdlb21ldHJ5LnByb3RvdHlwZS5vZmZzZXQ9bnVsbDtteEdlb21ldHJ5LnByb3RvdHlwZS5yZWxhdGl2ZT0hMTsKbXhHZW9tZXRyeS5wcm90b3R5cGUuc3dhcD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuYWx0ZXJuYXRlQm91bmRzKXt2YXIgYT1uZXcgbXhSZWN0YW5nbGUodGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KTt0aGlzLng9dGhpcy5hbHRlcm5hdGVCb3VuZHMueDt0aGlzLnk9dGhpcy5hbHRlcm5hdGVCb3VuZHMueTt0aGlzLndpZHRoPXRoaXMuYWx0ZXJuYXRlQm91bmRzLndpZHRoO3RoaXMuaGVpZ2h0PXRoaXMuYWx0ZXJuYXRlQm91bmRzLmhlaWdodDt0aGlzLmFsdGVybmF0ZUJvdW5kcz1hfX07bXhHZW9tZXRyeS5wcm90b3R5cGUuZ2V0VGVybWluYWxQb2ludD1mdW5jdGlvbihhKXtyZXR1cm4gYT90aGlzLnNvdXJjZVBvaW50OnRoaXMudGFyZ2V0UG9pbnR9O214R2VvbWV0cnkucHJvdG90eXBlLnNldFRlcm1pbmFsUG9pbnQ9ZnVuY3Rpb24oYSxiKXtiP3RoaXMuc291cmNlUG9pbnQ9YTp0aGlzLnRhcmdldFBvaW50PWE7cmV0dXJuIGF9OwpteEdlb21ldHJ5LnByb3RvdHlwZS5yb3RhdGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1teFV0aWxzLnRvUmFkaWFucyhhKSxkPU1hdGguY29zKGMpLGM9TWF0aC5zaW4oYyk7aWYoIXRoaXMucmVsYXRpdmUpe3ZhciBlPW5ldyBteFBvaW50KHRoaXMuZ2V0Q2VudGVyWCgpLHRoaXMuZ2V0Q2VudGVyWSgpKSxlPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KGUsZCxjLGIpO3RoaXMueD1NYXRoLnJvdW5kKGUueC10aGlzLndpZHRoLzIpO3RoaXMueT1NYXRoLnJvdW5kKGUueS10aGlzLmhlaWdodC8yKX1udWxsIT10aGlzLnNvdXJjZVBvaW50JiYoZT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludCh0aGlzLnNvdXJjZVBvaW50LGQsYyxiKSx0aGlzLnNvdXJjZVBvaW50Lng9TWF0aC5yb3VuZChlLngpLHRoaXMuc291cmNlUG9pbnQueT1NYXRoLnJvdW5kKGUueSkpO251bGwhPXRoaXMudGFyZ2V0UG9pbnQmJihlPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KHRoaXMudGFyZ2V0UG9pbnQsZCxjLGIpLHRoaXMudGFyZ2V0UG9pbnQueD0KTWF0aC5yb3VuZChlLngpLHRoaXMudGFyZ2V0UG9pbnQueT1NYXRoLnJvdW5kKGUueSkpO2lmKG51bGwhPXRoaXMucG9pbnRzKWZvcih2YXIgZj0wO2Y8dGhpcy5wb2ludHMubGVuZ3RoO2YrKyludWxsIT10aGlzLnBvaW50c1tmXSYmKGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQodGhpcy5wb2ludHNbZl0sZCxjLGIpLHRoaXMucG9pbnRzW2ZdLng9TWF0aC5yb3VuZChlLngpLHRoaXMucG9pbnRzW2ZdLnk9TWF0aC5yb3VuZChlLnkpKX07Cm14R2VvbWV0cnkucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbihhLGIpe2E9cGFyc2VGbG9hdChhKTtiPXBhcnNlRmxvYXQoYik7dGhpcy5yZWxhdGl2ZXx8KHRoaXMueD1wYXJzZUZsb2F0KHRoaXMueCkrYSx0aGlzLnk9cGFyc2VGbG9hdCh0aGlzLnkpK2IpO251bGwhPXRoaXMuc291cmNlUG9pbnQmJih0aGlzLnNvdXJjZVBvaW50Lng9cGFyc2VGbG9hdCh0aGlzLnNvdXJjZVBvaW50LngpK2EsdGhpcy5zb3VyY2VQb2ludC55PXBhcnNlRmxvYXQodGhpcy5zb3VyY2VQb2ludC55KStiKTtudWxsIT10aGlzLnRhcmdldFBvaW50JiYodGhpcy50YXJnZXRQb2ludC54PXBhcnNlRmxvYXQodGhpcy50YXJnZXRQb2ludC54KSthLHRoaXMudGFyZ2V0UG9pbnQueT1wYXJzZUZsb2F0KHRoaXMudGFyZ2V0UG9pbnQueSkrYik7aWYodGhpcy5UUkFOU0xBVEVfQ09OVFJPTF9QT0lOVFMmJm51bGwhPXRoaXMucG9pbnRzKWZvcih2YXIgYz0wO2M8dGhpcy5wb2ludHMubGVuZ3RoO2MrKyludWxsIT0KdGhpcy5wb2ludHNbY10mJih0aGlzLnBvaW50c1tjXS54PXBhcnNlRmxvYXQodGhpcy5wb2ludHNbY10ueCkrYSx0aGlzLnBvaW50c1tjXS55PXBhcnNlRmxvYXQodGhpcy5wb2ludHNbY10ueSkrYil9OwpteEdlb21ldHJ5LnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihhLGIsYyl7YT1wYXJzZUZsb2F0KGEpO2I9cGFyc2VGbG9hdChiKTtudWxsIT10aGlzLnNvdXJjZVBvaW50JiYodGhpcy5zb3VyY2VQb2ludC54PXBhcnNlRmxvYXQodGhpcy5zb3VyY2VQb2ludC54KSphLHRoaXMuc291cmNlUG9pbnQueT1wYXJzZUZsb2F0KHRoaXMuc291cmNlUG9pbnQueSkqYik7bnVsbCE9dGhpcy50YXJnZXRQb2ludCYmKHRoaXMudGFyZ2V0UG9pbnQueD1wYXJzZUZsb2F0KHRoaXMudGFyZ2V0UG9pbnQueCkqYSx0aGlzLnRhcmdldFBvaW50Lnk9cGFyc2VGbG9hdCh0aGlzLnRhcmdldFBvaW50LnkpKmIpO2lmKG51bGwhPXRoaXMucG9pbnRzKWZvcih2YXIgZD0wO2Q8dGhpcy5wb2ludHMubGVuZ3RoO2QrKyludWxsIT10aGlzLnBvaW50c1tkXSYmKHRoaXMucG9pbnRzW2RdLng9cGFyc2VGbG9hdCh0aGlzLnBvaW50c1tkXS54KSphLHRoaXMucG9pbnRzW2RdLnk9cGFyc2VGbG9hdCh0aGlzLnBvaW50c1tkXS55KSoKYik7dGhpcy5yZWxhdGl2ZXx8KHRoaXMueD1wYXJzZUZsb2F0KHRoaXMueCkqYSx0aGlzLnk9cGFyc2VGbG9hdCh0aGlzLnkpKmIsYyYmKGI9YT1NYXRoLm1pbihhLGIpKSx0aGlzLndpZHRoPXBhcnNlRmxvYXQodGhpcy53aWR0aCkqYSx0aGlzLmhlaWdodD1wYXJzZUZsb2F0KHRoaXMuaGVpZ2h0KSpiKX07Cm14R2VvbWV0cnkucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtyZXR1cm4gbXhSZWN0YW5nbGUucHJvdG90eXBlLmVxdWFscy5hcHBseSh0aGlzLGFyZ3VtZW50cykmJnRoaXMucmVsYXRpdmU9PWEucmVsYXRpdmUmJihudWxsPT10aGlzLnNvdXJjZVBvaW50JiZudWxsPT1hLnNvdXJjZVBvaW50fHxudWxsIT10aGlzLnNvdXJjZVBvaW50JiZ0aGlzLnNvdXJjZVBvaW50LmVxdWFscyhhLnNvdXJjZVBvaW50KSkmJihudWxsPT10aGlzLnRhcmdldFBvaW50JiZudWxsPT1hLnRhcmdldFBvaW50fHxudWxsIT10aGlzLnRhcmdldFBvaW50JiZ0aGlzLnRhcmdldFBvaW50LmVxdWFscyhhLnRhcmdldFBvaW50KSkmJihudWxsPT10aGlzLnBvaW50cyYmbnVsbD09YS5wb2ludHN8fG51bGwhPXRoaXMucG9pbnRzJiZteFV0aWxzLmVxdWFsUG9pbnRzKHRoaXMucG9pbnRzLGEucG9pbnRzKSkmJihudWxsPT10aGlzLmFsdGVybmF0ZUJvdW5kcyYmbnVsbD09YS5hbHRlcm5hdGVCb3VuZHN8fApudWxsIT10aGlzLmFsdGVybmF0ZUJvdW5kcyYmdGhpcy5hbHRlcm5hdGVCb3VuZHMuZXF1YWxzKGEuYWx0ZXJuYXRlQm91bmRzKSkmJihudWxsPT10aGlzLm9mZnNldCYmbnVsbD09YS5vZmZzZXR8fG51bGwhPXRoaXMub2Zmc2V0JiZ0aGlzLm9mZnNldC5lcXVhbHMoYS5vZmZzZXQpKX07CnZhciBteENlbGxQYXRoPXtQQVRIX1NFUEFSQVRPUjoiLiIsY3JlYXRlOmZ1bmN0aW9uKGEpe3ZhciBiPSIiO2lmKG51bGwhPWEpZm9yKHZhciBjPWEuZ2V0UGFyZW50KCk7bnVsbCE9YzspYj1jLmdldEluZGV4KGEpK214Q2VsbFBhdGguUEFUSF9TRVBBUkFUT1IrYixhPWMsYz1hLmdldFBhcmVudCgpO2E9Yi5sZW5ndGg7MTxhJiYoYj1iLnN1YnN0cmluZygwLGEtMSkpO3JldHVybiBifSxnZXRQYXJlbnRQYXRoOmZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPWEubGFzdEluZGV4T2YobXhDZWxsUGF0aC5QQVRIX1NFUEFSQVRPUik7aWYoMDw9YilyZXR1cm4gYS5zdWJzdHJpbmcoMCxiKTtpZigwPGEubGVuZ3RoKXJldHVybiIifXJldHVybiBudWxsfSxyZXNvbHZlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YTtpZihudWxsIT1iKWZvcih2YXIgZD1iLnNwbGl0KG14Q2VsbFBhdGguUEFUSF9TRVBBUkFUT1IpLGU9MDtlPGQubGVuZ3RoO2UrKyljPWMuZ2V0Q2hpbGRBdChwYXJzZUludChkW2VdKSk7CnJldHVybiBjfSxjb21wYXJlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPU1hdGgubWluKGEubGVuZ3RoLGIubGVuZ3RoKSxkPTAsZT0wO2U8YztlKyspaWYoYVtlXSE9YltlXSl7MD09YVtlXS5sZW5ndGh8fDA9PWJbZV0ubGVuZ3RoP2Q9YVtlXT09YltlXT8wOmFbZV0+YltlXT8xOi0xOihjPXBhcnNlSW50KGFbZV0pLGU9cGFyc2VJbnQoYltlXSksZD1jPT1lPzA6Yz5lPzE6LTEpO2JyZWFrfTA9PWQmJihjPWEubGVuZ3RoLGU9Yi5sZW5ndGgsYyE9ZSYmKGQ9Yz5lPzE6LTEpKTtyZXR1cm4gZH19LG14UGVyaW1ldGVyPXtSZWN0YW5nbGVQZXJpbWV0ZXI6ZnVuY3Rpb24oYSxiLGMsZCl7Yj1hLmdldENlbnRlclgoKTt2YXIgZT1hLmdldENlbnRlclkoKSxmPU1hdGguYXRhbjIoYy55LWUsYy54LWIpLGc9bmV3IG14UG9pbnQoMCwwKSxrPU1hdGguUEksbD1NYXRoLlBJLzItZixtPU1hdGguYXRhbjIoYS5oZWlnaHQsYS53aWR0aCk7ZjwtayttfHxmPmstbT8oZy54PWEueCxnLnk9ZS1hLndpZHRoKgpNYXRoLnRhbihmKS8yKTpmPC1tPyhnLnk9YS55LGcueD1iLWEuaGVpZ2h0Kk1hdGgudGFuKGwpLzIpOmY8bT8oZy54PWEueCthLndpZHRoLGcueT1lK2Eud2lkdGgqTWF0aC50YW4oZikvMik6KGcueT1hLnkrYS5oZWlnaHQsZy54PWIrYS5oZWlnaHQqTWF0aC50YW4obCkvMik7ZCYmKGMueD49YS54JiZjLng8PWEueCthLndpZHRoP2cueD1jLng6Yy55Pj1hLnkmJmMueTw9YS55K2EuaGVpZ2h0JiYoZy55PWMueSksYy54PGEueD9nLng9YS54OmMueD5hLngrYS53aWR0aCYmKGcueD1hLngrYS53aWR0aCksYy55PGEueT9nLnk9YS55OmMueT5hLnkrYS5oZWlnaHQmJihnLnk9YS55K2EuaGVpZ2h0KSk7cmV0dXJuIGd9LEVsbGlwc2VQZXJpbWV0ZXI6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS54LGY9YS55LGc9YS53aWR0aC8yLGs9YS5oZWlnaHQvMixsPWUrZyxtPWYraztiPWMueDtjPWMueTt2YXIgbj1wYXJzZUludChiLWwpLHA9cGFyc2VJbnQoYy1tKTtpZigwPT1uJiYwIT1wKXJldHVybiBuZXcgbXhQb2ludChsLAptK2sqcC9NYXRoLmFicyhwKSk7aWYoMD09biYmMD09cClyZXR1cm4gbmV3IG14UG9pbnQoYixjKTtpZihkKXtpZihjPj1mJiZjPD1mK2EuaGVpZ2h0KXJldHVybiBhPWMtbSxhPU1hdGguc3FydChnKmcqKDEtYSphLyhrKmspKSl8fDAsYjw9ZSYmKGE9LWEpLG5ldyBteFBvaW50KGwrYSxjKTtpZihiPj1lJiZiPD1lK2Eud2lkdGgpcmV0dXJuIGE9Yi1sLGE9TWF0aC5zcXJ0KGsqayooMS1hKmEvKGcqZykpKXx8MCxjPD1mJiYoYT0tYSksbmV3IG14UG9pbnQoYixtK2EpfWU9cC9uO20tPWUqbDtmPWcqZyplKmUrayprO2E9LTIqbCpmO2s9TWF0aC5zcXJ0KGEqYS00KmYqKGcqZyplKmUqbCpsK2sqaypsKmwtZypnKmsqaykpO2c9KC1hK2spLygyKmYpO2w9KC1hLWspLygyKmYpO2s9ZSpnK207bT1lKmwrbTtNYXRoLnNxcnQoTWF0aC5wb3coZy1iLDIpK01hdGgucG93KGstYywyKSk8TWF0aC5zcXJ0KE1hdGgucG93KGwtYiwyKStNYXRoLnBvdyhtLWMsMikpPyhiPWcsYz1rKTooYj1sLGM9Cm0pO3JldHVybiBuZXcgbXhQb2ludChiLGMpfSxSaG9tYnVzUGVyaW1ldGVyOmZ1bmN0aW9uKGEsYixjLGQpe2I9YS54O3ZhciBlPWEueSxmPWEud2lkdGg7YT1hLmhlaWdodDt2YXIgZz1iK2YvMixrPWUrYS8yLGw9Yy54O2M9Yy55O2lmKGc9PWwpcmV0dXJuIGs+Yz9uZXcgbXhQb2ludChnLGUpOm5ldyBteFBvaW50KGcsZSthKTtpZihrPT1jKXJldHVybiBnPmw/bmV3IG14UG9pbnQoYixrKTpuZXcgbXhQb2ludChiK2Ysayk7dmFyIG09ZyxuPWs7ZCYmKGw+PWImJmw8PWIrZj9tPWw6Yz49ZSYmYzw9ZSthJiYobj1jKSk7cmV0dXJuIGw8Zz9jPGs/bXhVdGlscy5pbnRlcnNlY3Rpb24obCxjLG0sbixnLGUsYixrKTpteFV0aWxzLmludGVyc2VjdGlvbihsLGMsbSxuLGcsZSthLGIsayk6YzxrP214VXRpbHMuaW50ZXJzZWN0aW9uKGwsYyxtLG4sZyxlLGIrZixrKTpteFV0aWxzLmludGVyc2VjdGlvbihsLGMsbSxuLGcsZSthLGIrZixrKX0sVHJpYW5nbGVQZXJpbWV0ZXI6ZnVuY3Rpb24oYSwKYixjLGQpe2I9bnVsbCE9Yj9iLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTl06bnVsbDt2YXIgZT1iPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCxmPWEueCxnPWEueSxrPWEud2lkdGgsbD1hLmhlaWdodDthPWYray8yO3ZhciBtPWcrbC8yLG49bmV3IG14UG9pbnQoZixnKSxwPW5ldyBteFBvaW50KGYrayxtKSxxPW5ldyBteFBvaW50KGYsZytsKTtiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/KG49cSxwPW5ldyBteFBvaW50KGEsZykscT1uZXcgbXhQb2ludChmK2ssZytsKSk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhwPW5ldyBteFBvaW50KGEsZytsKSxxPW5ldyBteFBvaW50KGYrayxnKSk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QmJihuPW5ldyBteFBvaW50KGYrayxnKSxwPW5ldyBteFBvaW50KGYsbSkscT1uZXcgbXhQb2ludChmK2ssZytsKSk7dmFyIHI9Yy54LQphLHQ9Yy55LW0scj1lP01hdGguYXRhbjIocix0KTpNYXRoLmF0YW4yKHQsciksdD1lP01hdGguYXRhbjIoayxsKTpNYXRoLmF0YW4yKGwsayk7KGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/cj4tdCYmcjx0OnI8LU1hdGguUEkrdHx8cj5NYXRoLlBJLXQpP2M9ZCYmKGUmJmMueD49bi54JiZjLng8PXEueHx8IWUmJmMueT49bi55JiZjLnk8PXEueSk/ZT9uZXcgbXhQb2ludChjLngsbi55KTpuZXcgbXhQb2ludChuLngsYy55KTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/bmV3IG14UG9pbnQoZitrLzIrbCpNYXRoLnRhbihyKS8yLGcrbCk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIP25ldyBteFBvaW50KGYray8yLWwqTWF0aC50YW4ocikvMixnKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9uZXcgbXhQb2ludChmK2ssZytsLzIraypNYXRoLnRhbihyKS8yKTpuZXcgbXhQb2ludChmLGcrCmwvMi1rKk1hdGgudGFuKHIpLzIpOihkJiYoZD1uZXcgbXhQb2ludChhLG0pLGMueT49ZyYmYy55PD1nK2w/KGQueD1lP2E6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/ZitrOmYsZC55PWMueSk6Yy54Pj1mJiZjLng8PWYrayYmKGQueD1jLngsZC55PWU/Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIP2crbDpnOm0pLGE9ZC54LG09ZC55KSxjPWUmJmMueDw9ZitrLzJ8fCFlJiZjLnk8PWcrbC8yP214VXRpbHMuaW50ZXJzZWN0aW9uKGMueCxjLnksYSxtLG4ueCxuLnkscC54LHAueSk6bXhVdGlscy5pbnRlcnNlY3Rpb24oYy54LGMueSxhLG0scC54LHAueSxxLngscS55KSk7bnVsbD09YyYmKGM9bmV3IG14UG9pbnQoYSxtKSk7cmV0dXJuIGN9LEhleGFnb25QZXJpbWV0ZXI6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS54LGY9YS55LGc9YS53aWR0aCxrPWEuaGVpZ2h0LGw9YS5nZXRDZW50ZXJYKCk7YT1hLmdldENlbnRlclkoKTt2YXIgbT1jLngsbj1jLnkscD0tTWF0aC5hdGFuMihuLQphLG0tbCkscT1NYXRoLlBJLHI9TWF0aC5QSS8yO25ldyBteFBvaW50KGwsYSk7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpOm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUO3ZhciB0PWI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIO2I9bmV3IG14UG9pbnQ7dmFyIHU9bmV3IG14UG9pbnQ7aWYobTxlJiZuPGZ8fG08ZSYmbj5mK2t8fG0+ZStnJiZuPGZ8fG0+ZStnJiZuPmYraylkPSExO2lmKGQpe2lmKHQpe2lmKG09PWwpe2lmKG48PWYpcmV0dXJuIG5ldyBteFBvaW50KGwsZik7aWYobj49ZitrKXJldHVybiBuZXcgbXhQb2ludChsLGYrayl9ZWxzZSBpZihtPGUpe2lmKG49PWYray80KXJldHVybiBuZXcgbXhQb2ludChlLGYray80KTtpZihuPT1mKzMqay80KXJldHVybiBuZXcgbXhQb2ludChlLGYrMyoKay80KX1lbHNlIGlmKG0+ZStnKXtpZihuPT1mK2svNClyZXR1cm4gbmV3IG14UG9pbnQoZStnLGYray80KTtpZihuPT1mKzMqay80KXJldHVybiBuZXcgbXhQb2ludChlK2csZiszKmsvNCl9ZWxzZSBpZihtPT1lKXtpZihuPGEpcmV0dXJuIG5ldyBteFBvaW50KGUsZitrLzQpO2lmKG4+YSlyZXR1cm4gbmV3IG14UG9pbnQoZSxmKzMqay80KX1lbHNlIGlmKG09PWUrZyl7aWYobjxhKXJldHVybiBuZXcgbXhQb2ludChlK2csZitrLzQpO2lmKG4+YSlyZXR1cm4gbmV3IG14UG9pbnQoZStnLGYrMyprLzQpfWlmKG49PWYpcmV0dXJuIG5ldyBteFBvaW50KGwsZik7aWYobj09ZitrKXJldHVybiBuZXcgbXhQb2ludChsLGYrayk7bTxsP24+ZitrLzQmJm48ZiszKmsvND8oYj1uZXcgbXhQb2ludChlLGYpLHU9bmV3IG14UG9pbnQoZSxmK2spKTpuPGYray80PyhiPW5ldyBteFBvaW50KGUtTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZStnLGYtCk1hdGguZmxvb3IoLjI1KmspKSk6bj5mKzMqay80JiYoYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjUqZyksZitNYXRoLmZsb29yKC41KmspKSx1PW5ldyBteFBvaW50KGUrZyxmK01hdGguZmxvb3IoMS4yNSprKSkpOm0+bCYmKG4+ZitrLzQmJm48ZiszKmsvND8oYj1uZXcgbXhQb2ludChlK2csZiksdT1uZXcgbXhQb2ludChlK2csZitrKSk6bjxmK2svND8oYj1uZXcgbXhQb2ludChlLGYtTWF0aC5mbG9vciguMjUqaykpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuNSpnKSxmK01hdGguZmxvb3IoLjUqaykpKTpuPmYrMyprLzQmJihiPW5ldyBteFBvaW50KGUrTWF0aC5mbG9vcigxLjUqZyksZitNYXRoLmZsb29yKC41KmspKSx1PW5ldyBteFBvaW50KGUsZitNYXRoLmZsb29yKDEuMjUqaykpKSl9ZWxzZXtpZihuPT1hKXtpZihtPD1lKXJldHVybiBuZXcgbXhQb2ludChlLGYray8yKTtpZihtPj1lK2cpcmV0dXJuIG5ldyBteFBvaW50KGUrZyxmK2svMil9ZWxzZSBpZihuPApmKXtpZihtPT1lK2cvNClyZXR1cm4gbmV3IG14UG9pbnQoZStnLzQsZik7aWYobT09ZSszKmcvNClyZXR1cm4gbmV3IG14UG9pbnQoZSszKmcvNCxmKX1lbHNlIGlmKG4+ZitrKXtpZihtPT1lK2cvNClyZXR1cm4gbmV3IG14UG9pbnQoZStnLzQsZitrKTtpZihtPT1lKzMqZy80KXJldHVybiBuZXcgbXhQb2ludChlKzMqZy80LGYrayl9ZWxzZSBpZihuPT1mKXtpZihtPGwpcmV0dXJuIG5ldyBteFBvaW50KGUrZy80LGYpO2lmKG0+bClyZXR1cm4gbmV3IG14UG9pbnQoZSszKmcvNCxmKX1lbHNlIGlmKG49PWYrayl7aWYobTxsKXJldHVybiBuZXcgbXhQb2ludChlK2cvNCxmK2spO2lmKG4+YSlyZXR1cm4gbmV3IG14UG9pbnQoZSszKmcvNCxmK2spfWlmKG09PWUpcmV0dXJuIG5ldyBteFBvaW50KGUsYSk7aWYobT09ZStnKXJldHVybiBuZXcgbXhQb2ludChlK2csYSk7bjxhP20+ZStnLzQmJm08ZSszKmcvND8oYj1uZXcgbXhQb2ludChlLGYpLHU9bmV3IG14UG9pbnQoZStnLGYpKToKbTxlK2cvND8oYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjI1KmcpLGYrayksdT1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjUqZyksZi1NYXRoLmZsb29yKC41KmspKSk6bT5lKzMqZy80JiYoYj1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjUqZyksZi1NYXRoLmZsb29yKC41KmspKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vcigxLjI1KmcpLGYraykpOm4+YSYmKG0+ZStnLzQmJm08ZSszKmcvND8oYj1uZXcgbXhQb2ludChlLGYrayksdT1uZXcgbXhQb2ludChlK2csZitrKSk6bTxlK2cvND8oYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjI1KmcpLGYpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC41KmcpLGYrTWF0aC5mbG9vcigxLjUqaykpKTptPmUrMypnLzQmJihiPW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoMS41KmspKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vcigxLjI1KmcpLGYpKSl9ZD1sO3A9YTttPj1lJiZtPD0KZStnPyhkPW0scD1uPGE/ZitrOmYpOm4+PWYmJm48PWYrayYmKHA9bixkPW08bD9lK2c6ZSk7Yz1teFV0aWxzLmludGVyc2VjdGlvbihkLHAsYy54LGMueSxiLngsYi55LHUueCx1LnkpfWVsc2V7aWYodCl7bT1NYXRoLmF0YW4yKGsvNCxnLzIpO2lmKHA9PW0pcmV0dXJuIG5ldyBteFBvaW50KGUrZyxmK01hdGguZmxvb3IoLjI1KmspKTtpZihwPT1yKXJldHVybiBuZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjUqZyksZik7aWYocD09cS1tKXJldHVybiBuZXcgbXhQb2ludChlLGYrTWF0aC5mbG9vciguMjUqaykpO2lmKHA9PS1tKXJldHVybiBuZXcgbXhQb2ludChlK2csZitNYXRoLmZsb29yKC43NSprKSk7aWYocD09LXIpcmV0dXJuIG5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmK2spO2lmKHA9PS1xK20pcmV0dXJuIG5ldyBteFBvaW50KGUsZitNYXRoLmZsb29yKC43NSprKSk7cDxtJiZwPi1tPyhiPW5ldyBteFBvaW50KGUrZyxmKSx1PW5ldyBteFBvaW50KGUrZyxmKwprKSk6cD5tJiZwPHI/KGI9bmV3IG14UG9pbnQoZSxmLU1hdGguZmxvb3IoLjI1KmspKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vcigxLjUqZyksZitNYXRoLmZsb29yKC41KmspKSk6cD5yJiZwPHEtbT8oYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjUqZyksZitNYXRoLmZsb29yKC41KmspKSx1PW5ldyBteFBvaW50KGUrZyxmLU1hdGguZmxvb3IoLjI1KmspKSk6cD5xLW0mJnA8PXF8fHA8LXErbSYmcD49LXE/KGI9bmV3IG14UG9pbnQoZSxmKSx1PW5ldyBteFBvaW50KGUsZitrKSk6cDwtbSYmcD4tcj8oYj1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoMS41KmcpLGYrTWF0aC5mbG9vciguNSprKSksdT1uZXcgbXhQb2ludChlLGYrTWF0aC5mbG9vcigxLjI1KmspKSk6cDwtciYmcD4tcSttJiYoYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjUqZyksZitNYXRoLmZsb29yKC41KmspKSx1PW5ldyBteFBvaW50KGUrZyxmK01hdGguZmxvb3IoMS4yNSprKSkpfWVsc2V7bT0KTWF0aC5hdGFuMihrLzIsZy80KTtpZihwPT1tKXJldHVybiBuZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjc1KmcpLGYpO2lmKHA9PXEtbSlyZXR1cm4gbmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC4yNSpnKSxmKTtpZihwPT1xfHxwPT0tcSlyZXR1cm4gbmV3IG14UG9pbnQoZSxmK01hdGguZmxvb3IoLjUqaykpO2lmKDA9PXApcmV0dXJuIG5ldyBteFBvaW50KGUrZyxmK01hdGguZmxvb3IoLjUqaykpO2lmKHA9PS1tKXJldHVybiBuZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjc1KmcpLGYrayk7aWYocD09LXErbSlyZXR1cm4gbmV3IG14UG9pbnQoZStNYXRoLmZsb29yKC4yNSpnKSxmK2spOzA8cCYmcDxtPyhiPW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmLU1hdGguZmxvb3IoLjUqaykpLHU9bmV3IG14UG9pbnQoZStNYXRoLmZsb29yKDEuMjUqZyksZitrKSk6cD5tJiZwPHEtbT8oYj1uZXcgbXhQb2ludChlLGYpLHU9bmV3IG14UG9pbnQoZStnLGYpKTpwPnEtbSYmCnA8cT8oYj1uZXcgbXhQb2ludChlLU1hdGguZmxvb3IoLjI1KmcpLGYrayksdT1uZXcgbXhQb2ludChlK01hdGguZmxvb3IoLjUqZyksZi1NYXRoLmZsb29yKC41KmspKSk6MD5wJiZwPi1tPyhiPW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoMS41KmspKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vcigxLjI1KmcpLGYpKTpwPC1tJiZwPi1xK20/KGI9bmV3IG14UG9pbnQoZSxmK2spLHU9bmV3IG14UG9pbnQoZStnLGYraykpOnA8LXErbSYmcD4tcSYmKGI9bmV3IG14UG9pbnQoZS1NYXRoLmZsb29yKC4yNSpnKSxmKSx1PW5ldyBteFBvaW50KGUrTWF0aC5mbG9vciguNSpnKSxmK01hdGguZmxvb3IoMS41KmspKSl9Yz1teFV0aWxzLmludGVyc2VjdGlvbihsLGEsYy54LGMueSxiLngsYi55LHUueCx1LnkpfXJldHVybiBudWxsPT1jP25ldyBteFBvaW50KGwsYSk6Y319OwpmdW5jdGlvbiBteFByaW50UHJldmlldyhhLGIsYyxkLGUsZixnLGssbCl7dGhpcy5ncmFwaD1hO3RoaXMuc2NhbGU9bnVsbCE9Yj9iOjEvYS5wYWdlU2NhbGU7dGhpcy5ib3JkZXI9bnVsbCE9ZD9kOjA7dGhpcy5wYWdlRm9ybWF0PW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUobnVsbCE9Yz9jOmEucGFnZUZvcm1hdCk7dGhpcy50aXRsZT1udWxsIT1rP2s6IlByaW50ZXItZnJpZW5kbHkgdmVyc2lvbiI7dGhpcy54MD1udWxsIT1lP2U6MDt0aGlzLnkwPW51bGwhPWY/ZjowO3RoaXMuYm9yZGVyQ29sb3I9Zzt0aGlzLnBhZ2VTZWxlY3Rvcj1udWxsIT1sP2w6ITB9bXhQcmludFByZXZpZXcucHJvdG90eXBlLmdyYXBoPW51bGw7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnBhZ2VGb3JtYXQ9bnVsbDtteFByaW50UHJldmlldy5wcm90b3R5cGUuc2NhbGU9bnVsbDtteFByaW50UHJldmlldy5wcm90b3R5cGUuYm9yZGVyPTA7Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5tYXJnaW5Ub3A9MDtteFByaW50UHJldmlldy5wcm90b3R5cGUubWFyZ2luQm90dG9tPTA7bXhQcmludFByZXZpZXcucHJvdG90eXBlLngwPTA7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnkwPTA7bXhQcmludFByZXZpZXcucHJvdG90eXBlLmF1dG9PcmlnaW49ITA7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnByaW50T3ZlcmxheXM9ITE7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnByaW50Q29udHJvbHM9ITE7bXhQcmludFByZXZpZXcucHJvdG90eXBlLnByaW50QmFja2dyb3VuZEltYWdlPSExO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5iYWNrZ3JvdW5kQ29sb3I9IiNmZmZmZmYiO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5ib3JkZXJDb2xvcj1udWxsO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS50aXRsZT1udWxsO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5wYWdlU2VsZWN0b3I9bnVsbDsKbXhQcmludFByZXZpZXcucHJvdG90eXBlLnduZD1udWxsO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS50YXJnZXRXaW5kb3c9bnVsbDtteFByaW50UHJldmlldy5wcm90b3R5cGUucGFnZUNvdW50PTA7bXhQcmludFByZXZpZXcucHJvdG90eXBlLmNsaXBwaW5nPSEwO214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5nZXRXaW5kb3c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53bmR9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUuZ2V0RG9jdHlwZT1mdW5jdGlvbigpe3ZhciBhPSIiOzU9PWRvY3VtZW50LmRvY3VtZW50TW9kZT9hPSc8bWV0YSBodHRwLWVxdWl2PSJYLVVBLUNvbXBhdGlibGUiIGNvbnRlbnQ9IklFPTUiPic6OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP2E9JzxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9OCI+Jzo4PGRvY3VtZW50LmRvY3VtZW50TW9kZSYmKGE9J1x4M2MhLS1baWYgSUVdPjxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9ZWRnZSI+PCFbZW5kaWZdLS1ceDNlJyk7cmV0dXJuIGF9O214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5hcHBlbmRHcmFwaD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5ncmFwaD1hO3RoaXMuc2NhbGU9bnVsbCE9Yj9iOjEvYS5wYWdlU2NhbGU7dGhpcy54MD1jO3RoaXMueTA9ZDt0aGlzLm9wZW4obnVsbCxudWxsLGUsZil9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5pbml0aWFsaXplT3ZlcmxheSxmPW51bGw7dHJ5e3RoaXMucHJpbnRPdmVybGF5cyYmKHRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmluaXRpYWxpemVPdmVybGF5PWZ1bmN0aW9uKGEsYil7Yi5pbml0KGEudmlldy5nZXREcmF3UGFuZSgpKX0pO3RoaXMucHJpbnRDb250cm9scyYmKHRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmluaXRDb250cm9sPWZ1bmN0aW9uKGEsYixjLGQpe2IuZGlhbGVjdD1hLnZpZXcuZ3JhcGguZGlhbGVjdDtiLmluaXQoYS52aWV3LmdldERyYXdQYW5lKCkpfSk7dGhpcy53bmQ9bnVsbCE9Yj9iOnRoaXMud25kO3ZhciBnPSExO251bGw9PXRoaXMud25kJiYoZz0hMCx0aGlzLnduZD13aW5kb3cub3BlbigpKTt2YXIgaz10aGlzLnduZC5kb2N1bWVudDtpZihnKXt2YXIgbD10aGlzLmdldERvY3R5cGUoKTtudWxsIT1sJiYwPGwubGVuZ3RoJiYKay53cml0ZWxuKGwpO214Q2xpZW50LklTX1ZNTD9rLndyaXRlbG4oJzxodG1sIHhtbG5zOnY9InVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sIiB4bWxuczpvPSJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2UiPicpOigiQ1NTMUNvbXBhdCI9PT1kb2N1bWVudC5jb21wYXRNb2RlJiZrLndyaXRlbG4oIjwhRE9DVFlQRSBodG1sPiIpLGsud3JpdGVsbigiPGh0bWw+IikpO2sud3JpdGVsbigiPGhlYWQ+Iik7dGhpcy53cml0ZUhlYWQoayxhKTtrLndyaXRlbG4oIjwvaGVhZD4iKTtrLndyaXRlbG4oJzxib2R5IGNsYXNzPSJteFBhZ2UiPicpfXZhciBtPXRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKS5jbG9uZSgpLG49dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U2NhbGUoKSxwPW4vdGhpcy5zY2FsZSxxPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFRyYW5zbGF0ZSgpO3RoaXMuYXV0b09yaWdpbnx8KHRoaXMueDAtPXEueCp0aGlzLnNjYWxlLHRoaXMueTAtPQpxLnkqdGhpcy5zY2FsZSxtLndpZHRoKz1tLngsbS5oZWlnaHQrPW0ueSxtLng9MCx0aGlzLmJvcmRlcj1tLnk9MCk7dmFyIHI9dGhpcy5wYWdlRm9ybWF0LndpZHRoLTIqdGhpcy5ib3JkZXIsdD10aGlzLnBhZ2VGb3JtYXQuaGVpZ2h0LTIqdGhpcy5ib3JkZXI7dGhpcy5wYWdlRm9ybWF0LmhlaWdodCs9dGhpcy5tYXJnaW5Ub3ArdGhpcy5tYXJnaW5Cb3R0b207bS53aWR0aC89cDttLmhlaWdodC89cDt2YXIgdT1NYXRoLm1heCgxLE1hdGguY2VpbCgobS53aWR0aCt0aGlzLngwKS9yKSkseD1NYXRoLm1heCgxLE1hdGguY2VpbCgobS5oZWlnaHQrdGhpcy55MCkvdCkpO3RoaXMucGFnZUNvdW50PXUqeDt2YXIgeT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKHRoaXMucGFnZVNlbGVjdG9yJiYoMTx4fHwxPHUpKXt2YXIgYT10aGlzLmNyZWF0ZVBhZ2VTZWxlY3Rvcih4LHUpO2suYm9keS5hcHBlbmRDaGlsZChhKTtpZihteENsaWVudC5JU19JRSYmbnVsbD09ay5kb2N1bWVudE1vZGV8fAo1PT1rLmRvY3VtZW50TW9kZXx8OD09ay5kb2N1bWVudE1vZGV8fDc9PWsuZG9jdW1lbnRNb2RlKXthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7dmFyIGI9ZnVuY3Rpb24oKXthLnN0eWxlLnRvcD0oay5ib2R5LnNjcm9sbFRvcHx8ay5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSsxMCsicHgifTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMud25kLCJzY3JvbGwiLGZ1bmN0aW9uKGEpe2IoKX0pO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy53bmQsInJlc2l6ZSIsZnVuY3Rpb24oYSl7YigpfSl9fX0pLEI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXtudWxsIT10aGlzLmJvcmRlckNvbG9yJiYoYS5zdHlsZS5ib3JkZXJDb2xvcj10aGlzLmJvcmRlckNvbG9yLGEuc3R5bGUuYm9yZGVyU3R5bGU9InNvbGlkIixhLnN0eWxlLmJvcmRlcldpZHRoPSIxcHgiKTthLnN0eWxlLmJhY2tncm91bmQ9dGhpcy5iYWNrZ3JvdW5kQ29sb3I7aWYoY3x8YilhLnN0eWxlLnBhZ2VCcmVha0FmdGVyPQoiYWx3YXlzIjtpZihnJiYobXhDbGllbnQuSVNfSUV8fDExPD1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VER0UpKWsud3JpdGVsbihhLm91dGVySFRNTCksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2Vsc2UgaWYobXhDbGllbnQuSVNfSUV8fDExPD1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX0VER0Upe3ZhciBkPWsuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZC5pbm5lckhUTUw9YS5vdXRlckhUTUw7ZD1kLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKVswXTtrLmJvZHkuYXBwZW5kQ2hpbGQoZCk7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfWVsc2UgYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLGsuYm9keS5hcHBlbmRDaGlsZChhKTsoY3x8YikmJnRoaXMuYWRkUGFnZUJyZWFrKGspfSksQT10aGlzLmdldENvdmVyUGFnZXModGhpcy5wYWdlRm9ybWF0LndpZHRoLHRoaXMucGFnZUZvcm1hdC5oZWlnaHQpO2lmKG51bGwhPUEpZm9yKHZhciB6PQowO3o8QS5sZW5ndGg7eisrKUIoQVt6XSwhMCk7Zm9yKHZhciBDPXRoaXMuZ2V0QXBwZW5kaWNlcyh0aGlzLnBhZ2VGb3JtYXQud2lkdGgsdGhpcy5wYWdlRm9ybWF0LmhlaWdodCksej0wO3o8eDt6Kyspe3ZhciB2PXoqdC90aGlzLnNjYWxlLXRoaXMueTAvdGhpcy5zY2FsZSsobS55LXEueSpuKS9uO2ZvcihhPTA7YTx1O2ErKyl7aWYobnVsbD09dGhpcy53bmQpcmV0dXJuIG51bGw7dmFyIEQ9YSpyL3RoaXMuc2NhbGUtdGhpcy54MC90aGlzLnNjYWxlKyhtLngtcS54Km4pL24sRz16KnUrYSsxLEo9bmV3IG14UmVjdGFuZ2xlKEQsdixyLHQpLGY9dGhpcy5yZW5kZXJQYWdlKHRoaXMucGFnZUZvcm1hdC53aWR0aCx0aGlzLnBhZ2VGb3JtYXQuaGVpZ2h0LDAsMCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFkZEdyYXBoRnJhZ21lbnQoLUQsLXYsdGhpcy5zY2FsZSxHLGEsSik7dGhpcy5wcmludEJhY2tncm91bmRJbWFnZSYmdGhpcy5pbnNlcnRCYWNrZ3JvdW5kSW1hZ2UoYSwKLUQsLXYpfSksRyk7Zi5zZXRBdHRyaWJ1dGUoImlkIiwibXhQYWdlLSIrRyk7QihmLG51bGwhPUN8fHo8eC0xfHxhPHUtMSl9fWlmKG51bGwhPUMpZm9yKHo9MDt6PEMubGVuZ3RoO3orKylCKENbel0sejxDLmxlbmd0aC0xKTtnJiYhZCYmKHRoaXMuY2xvc2VEb2N1bWVudCgpLHkoKSk7dGhpcy53bmQuZm9jdXMoKX1jYXRjaChFKXtudWxsIT1mJiZudWxsIT1mLnBhcmVudE5vZGUmJmYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmKX1maW5hbGx5e3RoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmluaXRpYWxpemVPdmVybGF5PWV9cmV0dXJuIHRoaXMud25kfTtteFByaW50UHJldmlldy5wcm90b3R5cGUuYWRkUGFnZUJyZWFrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuY3JlYXRlRWxlbWVudCgiaHIiKTtiLmNsYXNzTmFtZT0ibXhQYWdlQnJlYWsiO2EuYm9keS5hcHBlbmRDaGlsZChiKX07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5jbG9zZURvY3VtZW50PWZ1bmN0aW9uKCl7dHJ5e2lmKG51bGwhPXRoaXMud25kJiZudWxsIT10aGlzLnduZC5kb2N1bWVudCl7dmFyIGE9dGhpcy53bmQuZG9jdW1lbnQ7dGhpcy53cml0ZVBvc3RmaXgoYSk7YS53cml0ZWxuKCI8L2JvZHk+Iik7YS53cml0ZWxuKCI8L2h0bWw+Iik7YS5jbG9zZSgpO214RXZlbnQucmVsZWFzZShhLmJvZHkpfX1jYXRjaChiKXt9fTsKbXhQcmludFByZXZpZXcucHJvdG90eXBlLndyaXRlSGVhZD1mdW5jdGlvbihhLGIpe251bGwhPXRoaXMudGl0bGUmJmEud3JpdGVsbigiPHRpdGxlPiIrdGhpcy50aXRsZSsiPC90aXRsZT4iKTtteENsaWVudC5JU19WTUwmJmEud3JpdGVsbignPHN0eWxlIHR5cGU9InRleHQvY3NzIj52XFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX1vXFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX08L3N0eWxlPicpO214Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLG14Q2xpZW50LmJhc2VQYXRoKyIvY3NzL2NvbW1vbi5jc3MiLGEpO2Eud3JpdGVsbignPHN0eWxlIHR5cGU9InRleHQvY3NzIj4nKTthLndyaXRlbG4oIkBtZWRpYSBwcmludCB7Iik7YS53cml0ZWxuKCIgICogeyAtd2Via2l0LXByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7IH0iKTthLndyaXRlbG4oIiAgdGFibGUubXhQYWdlU2VsZWN0b3IgeyBkaXNwbGF5OiBub25lOyB9Iik7YS53cml0ZWxuKCIgIGhyLm14UGFnZUJyZWFrIHsgZGlzcGxheTogbm9uZTsgfSIpOwphLndyaXRlbG4oIn0iKTthLndyaXRlbG4oIkBtZWRpYSBzY3JlZW4geyIpO2Eud3JpdGVsbigiICB0YWJsZS5teFBhZ2VTZWxlY3RvciB7IHBvc2l0aW9uOiBmaXhlZDsgcmlnaHQ6IDEwcHg7IHRvcDogMTBweDtmb250LWZhbWlseTogQXJpYWw7IGZvbnQtc2l6ZToxMHB0OyBib3JkZXI6IHNvbGlkIDFweCBkYXJrZ3JheTtiYWNrZ3JvdW5kOiB3aGl0ZTsgYm9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlOyB9Iik7YS53cml0ZWxuKCIgIHRhYmxlLm14UGFnZVNlbGVjdG9yIHRkIHsgYm9yZGVyOiBzb2xpZCAxcHggZ3JheTsgcGFkZGluZzo0cHg7IH0iKTthLndyaXRlbG4oIiAgYm9keS5teFBhZ2UgeyBiYWNrZ3JvdW5kOiBncmF5OyB9Iik7YS53cml0ZWxuKCJ9Iik7bnVsbCE9YiYmYS53cml0ZWxuKGIpO2Eud3JpdGVsbigiPC9zdHlsZT4iKX07bXhQcmludFByZXZpZXcucHJvdG90eXBlLndyaXRlUG9zdGZpeD1mdW5jdGlvbihhKXt9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUuY3JlYXRlUGFnZVNlbGVjdG9yPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy53bmQuZG9jdW1lbnQsZD1jLmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7ZC5jbGFzc05hbWU9Im14UGFnZVNlbGVjdG9yIjtkLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Zvcih2YXIgZT1jLmNyZWF0ZUVsZW1lbnQoInRib2R5IiksZj0wO2Y8YTtmKyspe2Zvcih2YXIgZz1jLmNyZWF0ZUVsZW1lbnQoInRyIiksaz0wO2s8YjtrKyspe3ZhciBsPWYqYitrKzEsbT1jLmNyZWF0ZUVsZW1lbnQoInRkIiksbj1jLmNyZWF0ZUVsZW1lbnQoImEiKTtuLnNldEF0dHJpYnV0ZSgiaHJlZiIsIiNteFBhZ2UtIitsKTshbXhDbGllbnQuSVNfTlN8fG14Q2xpZW50LklTX1NGfHxteENsaWVudC5JU19HQ3x8bi5zZXRBdHRyaWJ1dGUoIm9uY2xpY2siLCJ2YXIgcGFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteFBhZ2UtIitsKyInKTtwYWdlLnNjcm9sbEludG9WaWV3KHRydWUpO2V2ZW50LnByZXZlbnREZWZhdWx0KCk7Iik7Cm14VXRpbHMud3JpdGUobixsLGMpO20uYXBwZW5kQ2hpbGQobik7Zy5hcHBlbmRDaGlsZChtKX1lLmFwcGVuZENoaWxkKGcpfWQuYXBwZW5kQ2hpbGQoZSk7cmV0dXJuIGR9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUucmVuZGVyUGFnZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7Zj10aGlzLnduZC5kb2N1bWVudDt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxrPW51bGw7dHJ5e2lmKDAhPWN8fDAhPWQpe2cuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjtnLnN0eWxlLndpZHRoPWErInB4IjtnLnN0eWxlLmhlaWdodD1iKyJweCI7Zy5zdHlsZS5wYWdlQnJlYWtJbnNpZGU9ImF2b2lkIjt2YXIgbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtsLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7bC5zdHlsZS50b3A9dGhpcy5ib3JkZXIrInB4IjtsLnN0eWxlLmxlZnQ9dGhpcy5ib3JkZXIrInB4IjtsLnN0eWxlLndpZHRoPWEtMip0aGlzLmJvcmRlcisicHgiO2wuc3R5bGUuaGVpZ2h0PWItMip0aGlzLmJvcmRlcisicHgiO2wuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7dmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bS5zdHlsZS5wb3NpdGlvbj0KInJlbGF0aXZlIjttLnN0eWxlLm1hcmdpbkxlZnQ9YysicHgiO20uc3R5bGUubWFyZ2luVG9wPWQrInB4Ijs4PT1mLmRvY3VtZW50TW9kZSYmKGwuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixtLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIpOzEwPT1mLmRvY3VtZW50TW9kZSYmKG0uc3R5bGUud2lkdGg9IjEwMCUiLG0uc3R5bGUuaGVpZ2h0PSIxMDAlIik7bC5hcHBlbmRDaGlsZChtKTtnLmFwcGVuZENoaWxkKGwpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZyk7az1tfWVsc2UgZy5zdHlsZS53aWR0aD1hKyJweCIsZy5zdHlsZS5oZWlnaHQ9YisicHgiLGcuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIsZy5zdHlsZS5wYWdlQnJlYWtJbnNpZGU9ImF2b2lkIiw4PT1mLmRvY3VtZW50TW9kZSYmKGcuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIiksbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxsLnN0eWxlLndpZHRoPWEtMip0aGlzLmJvcmRlcisicHgiLGwuc3R5bGUuaGVpZ2h0PQpiLTIqdGhpcy5ib3JkZXIrInB4IixsLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iLCFteENsaWVudC5JU19JRXx8bnVsbCE9Zi5kb2N1bWVudE1vZGUmJjUhPWYuZG9jdW1lbnRNb2RlJiY4IT1mLmRvY3VtZW50TW9kZSYmNyE9Zi5kb2N1bWVudE1vZGU/KGwuc3R5bGUudG9wPXRoaXMuYm9yZGVyKyJweCIsbC5zdHlsZS5sZWZ0PXRoaXMuYm9yZGVyKyJweCIpOihsLnN0eWxlLm1hcmdpblRvcD10aGlzLmJvcmRlcisicHgiLGwuc3R5bGUubWFyZ2luTGVmdD10aGlzLmJvcmRlcisicHgiKSx0aGlzLmdyYXBoLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfVk1MJiYobC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSxnLmFwcGVuZENoaWxkKGwpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZyksaz1sfWNhdGNoKG4pe3Rocm93IGcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnKSxuO31lKGspO3JldHVybiBnfTsKbXhQcmludFByZXZpZXcucHJvdG90eXBlLmdldFJvb3Q9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLnZpZXcuY3VycmVudFJvb3Q7bnVsbD09YSYmKGE9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFJvb3QoKSk7cmV0dXJuIGF9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUuYWRkR3JhcGhGcmFnbWVudD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9dGhpcy5ncmFwaC5nZXRWaWV3KCk7ZD10aGlzLmdyYXBoLmNvbnRhaW5lcjt0aGlzLmdyYXBoLmNvbnRhaW5lcj1lO3ZhciBrPWcuZ2V0Q2FudmFzKCksbD1nLmdldEJhY2tncm91bmRQYW5lKCksbT1nLmdldERyYXdQYW5lKCksbj1nLmdldE92ZXJsYXlQYW5lKCkscD1jO2lmKHRoaXMuZ3JhcGguZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkcpe2lmKGcuY3JlYXRlU3ZnKCksIW14Q2xpZW50Lk5PX0ZPKXt2YXIgcT1nLmdldERyYXdQYW5lKCkucGFyZW50Tm9kZTtxLmdldEF0dHJpYnV0ZSgidHJhbnNmb3JtIik7cS5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybU9yaWdpbiIsIjAgMCIpO3Euc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLCJzY2FsZSgiK2MrIiwiK2MrIil0cmFuc2xhdGUoIithKyIsIitiKyIpIik7Yz0xO2I9YT0wfX1lbHNlIHRoaXMuZ3JhcGguZGlhbGVjdD09Cm14Q29uc3RhbnRzLkRJQUxFQ1RfVk1MP2cuY3JlYXRlVm1sKCk6Zy5jcmVhdGVIdG1sKCk7cT1nLmlzRXZlbnRzRW5hYmxlZCgpO2cuc2V0RXZlbnRzRW5hYmxlZCghMSk7dmFyIHI9dGhpcy5ncmFwaC5pc0VuYWJsZWQoKTt0aGlzLmdyYXBoLnNldEVuYWJsZWQoITEpO3ZhciB0PWcuZ2V0VHJhbnNsYXRlKCk7Zy50cmFuc2xhdGU9bmV3IG14UG9pbnQoYSxiKTt2YXIgdT10aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcseD1nLnN0YXRlczthPWcuc2NhbGU7aWYodGhpcy5jbGlwcGluZyl7dmFyIHk9bmV3IG14UmVjdGFuZ2xlKChmLngrdC54KSphLChmLnkrdC55KSphLGYud2lkdGgqYS9wLGYuaGVpZ2h0KmEvcCk7dGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIucmVkcmF3PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT1hKXt2YXIgZD14LmdldChhLmNlbGwpO2lmKG51bGwhPWQmJihkPWcuZ2V0Qm91bmRpbmdCb3goZCwhMSksbnVsbCE9ZCYmMDxkLndpZHRoJiYwPGQuaGVpZ2h0JiYKIW14VXRpbHMuaW50ZXJzZWN0cyh5LGQpKSlyZXR1cm59dS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWE9bnVsbDt0cnl7dmFyIEI9W3RoaXMuZ2V0Um9vdCgpXTthPW5ldyBteFRlbXBvcmFyeUNlbGxTdGF0ZXMoZyxjLEIsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRMaW5rRm9yQ2VsbFN0YXRlKGEpfSkpfWZpbmFsbHl7aWYobXhDbGllbnQuSVNfSUUpZy5vdmVybGF5UGFuZS5pbm5lckhUTUw9IiIsZy5jYW52YXMuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIsZy5jYW52YXMuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIixnLmNhbnZhcy5zdHlsZS50b3A9dGhpcy5tYXJnaW5Ub3ArInB4IixnLmNhbnZhcy5zdHlsZS53aWR0aD1mLndpZHRoKyJweCIsZy5jYW52YXMuc3R5bGUuaGVpZ2h0PWYuaGVpZ2h0KyJweCI7ZWxzZSBmb3IoYz1lLmZpcnN0Q2hpbGQ7bnVsbCE9YzspQj1jLm5leHRTaWJsaW5nLGI9Yy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLAoic3ZnIj09Yj8oYy5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIixjLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSIsYy5zdHlsZS50b3A9dGhpcy5tYXJnaW5Ub3ArInB4IixjLnNldEF0dHJpYnV0ZSgid2lkdGgiLGYud2lkdGgpLGMuc2V0QXR0cmlidXRlKCJoZWlnaHQiLGYuaGVpZ2h0KSxjLnN0eWxlLndpZHRoPSIiLGMuc3R5bGUuaGVpZ2h0PSIiKToiZGVmYXVsdCIhPWMuc3R5bGUuY3Vyc29yJiYiZGl2IiE9YiYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLGM9Qjt0aGlzLnByaW50QmFja2dyb3VuZEltYWdlJiYoZT1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdmciKSwwPGUubGVuZ3RoJiYoZVswXS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiKSk7Zy5vdmVybGF5UGFuZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcub3ZlcmxheVBhbmUpO3RoaXMuZ3JhcGguc2V0RW5hYmxlZChyKTt0aGlzLmdyYXBoLmNvbnRhaW5lcj1kO3RoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdz0KdTtnLmNhbnZhcz1rO2cuYmFja2dyb3VuZFBhbmU9bDtnLmRyYXdQYW5lPW07Zy5vdmVybGF5UGFuZT1uO2cudHJhbnNsYXRlPXQ7YS5kZXN0cm95KCk7Zy5zZXRFdmVudHNFbmFibGVkKHEpfX07bXhQcmludFByZXZpZXcucHJvdG90eXBlLmdldExpbmtGb3JDZWxsU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ3JhcGguZ2V0TGlua0ZvckNlbGwoYS5jZWxsKX07Cm14UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5pbnNlcnRCYWNrZ3JvdW5kSW1hZ2U9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguYmFja2dyb3VuZEltYWdlO2lmKG51bGwhPWQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO2Uuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtlLnN0eWxlLm1hcmdpbkxlZnQ9TWF0aC5yb3VuZChiKnRoaXMuc2NhbGUpKyJweCI7ZS5zdHlsZS5tYXJnaW5Ub3A9TWF0aC5yb3VuZChjKnRoaXMuc2NhbGUpKyJweCI7ZS5zZXRBdHRyaWJ1dGUoIndpZHRoIixNYXRoLnJvdW5kKHRoaXMuc2NhbGUqZC53aWR0aCkpO2Uuc2V0QXR0cmlidXRlKCJoZWlnaHQiLE1hdGgucm91bmQodGhpcy5zY2FsZSpkLmhlaWdodCkpO2Uuc3JjPWQuc3JjO2EuaW5zZXJ0QmVmb3JlKGUsYS5maXJzdENoaWxkKX19O214UHJpbnRQcmV2aWV3LnByb3RvdHlwZS5nZXRDb3ZlclBhZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9OwpteFByaW50UHJldmlldy5wcm90b3R5cGUuZ2V0QXBwZW5kaWNlcz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtteFByaW50UHJldmlldy5wcm90b3R5cGUucHJpbnQ9ZnVuY3Rpb24oYSl7YT10aGlzLm9wZW4oYSk7bnVsbCE9YSYmYS5wcmludCgpfTtteFByaW50UHJldmlldy5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnduZCYmKHRoaXMud25kLmNsb3NlKCksdGhpcy53bmQ9bnVsbCl9O2Z1bmN0aW9uIG14U3R5bGVzaGVldCgpe3RoaXMuc3R5bGVzPXt9O3RoaXMucHV0RGVmYXVsdFZlcnRleFN0eWxlKHRoaXMuY3JlYXRlRGVmYXVsdFZlcnRleFN0eWxlKCkpO3RoaXMucHV0RGVmYXVsdEVkZ2VTdHlsZSh0aGlzLmNyZWF0ZURlZmF1bHRFZGdlU3R5bGUoKSl9Cm14U3R5bGVzaGVldC5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdFZlcnRleFN0eWxlPWZ1bmN0aW9uKCl7dmFyIGE9e307YVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV09bXhDb25zdGFudHMuU0hBUEVfUkVDVEFOR0xFO2FbbXhDb25zdGFudHMuU1RZTEVfUEVSSU1FVEVSXT1teFBlcmltZXRlci5SZWN0YW5nbGVQZXJpbWV0ZXI7YVtteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTl09bXhDb25zdGFudHMuQUxJR05fTUlERExFO2FbbXhDb25zdGFudHMuU1RZTEVfQUxJR05dPW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUjthW214Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUl09IiNDM0Q5RkYiO2FbbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1JdPSIjNjQ4MkI5IjthW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUl09IiM3NzQ0MDAiO3JldHVybiBhfTsKbXhTdHlsZXNoZWV0LnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0RWRnZVN0eWxlPWZ1bmN0aW9uKCl7dmFyIGE9e307YVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV09bXhDb25zdGFudHMuU0hBUEVfQ09OTkVDVE9SO2FbbXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1ddPW14Q29uc3RhbnRzLkFSUk9XX0NMQVNTSUM7YVtteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTl09bXhDb25zdGFudHMuQUxJR05fTUlERExFO2FbbXhDb25zdGFudHMuU1RZTEVfQUxJR05dPW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUjthW214Q29uc3RhbnRzLlNUWUxFX1NUUk9LRUNPTE9SXT0iIzY0ODJCOSI7YVtteENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1JdPSIjNDQ2Mjk5IjtyZXR1cm4gYX07bXhTdHlsZXNoZWV0LnByb3RvdHlwZS5wdXREZWZhdWx0VmVydGV4U3R5bGU9ZnVuY3Rpb24oYSl7dGhpcy5wdXRDZWxsU3R5bGUoImRlZmF1bHRWZXJ0ZXgiLGEpfTsKbXhTdHlsZXNoZWV0LnByb3RvdHlwZS5wdXREZWZhdWx0RWRnZVN0eWxlPWZ1bmN0aW9uKGEpe3RoaXMucHV0Q2VsbFN0eWxlKCJkZWZhdWx0RWRnZSIsYSl9O214U3R5bGVzaGVldC5wcm90b3R5cGUuZ2V0RGVmYXVsdFZlcnRleFN0eWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3R5bGVzLmRlZmF1bHRWZXJ0ZXh9O214U3R5bGVzaGVldC5wcm90b3R5cGUuZ2V0RGVmYXVsdEVkZ2VTdHlsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0eWxlcy5kZWZhdWx0RWRnZX07bXhTdHlsZXNoZWV0LnByb3RvdHlwZS5wdXRDZWxsU3R5bGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnN0eWxlc1thXT1ifTsKbXhTdHlsZXNoZWV0LnByb3RvdHlwZS5nZXRDZWxsU3R5bGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpZm9yKHZhciBkPWEuc3BsaXQoIjsiKSxjPW51bGwhPWMmJiI7IiE9YS5jaGFyQXQoMCk/bXhVdGlscy5jbG9uZShjKTp7fSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV0sZz1mLmluZGV4T2YoIj0iKTtpZigwPD1nKXt2YXIgaz1mLnN1YnN0cmluZygwLGcpLGY9Zi5zdWJzdHJpbmcoZysxKTtmPT1teENvbnN0YW50cy5OT05FP2RlbGV0ZSBjW2tdOm14VXRpbHMuaXNOdW1lcmljKGYpP2Nba109cGFyc2VGbG9hdChmKTpjW2tdPWZ9ZWxzZSBpZihmPXRoaXMuc3R5bGVzW2ZdLG51bGwhPWYpZm9yKGsgaW4gZiljW2tdPWZba119cmV0dXJuIGN9OwpmdW5jdGlvbiBteENlbGxTdGF0ZShhLGIsYyl7dGhpcy52aWV3PWE7dGhpcy5jZWxsPWI7dGhpcy5zdHlsZT1udWxsIT1jP2M6e307dGhpcy5vcmlnaW49bmV3IG14UG9pbnQ7dGhpcy5hYnNvbHV0ZU9mZnNldD1uZXcgbXhQb2ludH1teENlbGxTdGF0ZS5wcm90b3R5cGU9bmV3IG14UmVjdGFuZ2xlO214Q2VsbFN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teENlbGxTdGF0ZTtteENlbGxTdGF0ZS5wcm90b3R5cGUudmlldz1udWxsO214Q2VsbFN0YXRlLnByb3RvdHlwZS5jZWxsPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLnN0eWxlPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLmludmFsaWRTdHlsZT0hMTtteENlbGxTdGF0ZS5wcm90b3R5cGUuaW52YWxpZD0hMDtteENlbGxTdGF0ZS5wcm90b3R5cGUub3JpZ2luPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLmFic29sdXRlUG9pbnRzPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLmFic29sdXRlT2Zmc2V0PW51bGw7Cm14Q2VsbFN0YXRlLnByb3RvdHlwZS52aXNpYmxlU291cmNlU3RhdGU9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUudmlzaWJsZVRhcmdldFN0YXRlPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLnRlcm1pbmFsRGlzdGFuY2U9MDtteENlbGxTdGF0ZS5wcm90b3R5cGUubGVuZ3RoPTA7bXhDZWxsU3RhdGUucHJvdG90eXBlLnNlZ21lbnRzPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLnNoYXBlPW51bGw7bXhDZWxsU3RhdGUucHJvdG90eXBlLnRleHQ9bnVsbDtteENlbGxTdGF0ZS5wcm90b3R5cGUudW5zY2FsZWRXaWR0aD1udWxsO214Q2VsbFN0YXRlLnByb3RvdHlwZS51bnNjYWxlZEhlaWdodD1udWxsOwpteENlbGxTdGF0ZS5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyQm91bmRzPWZ1bmN0aW9uKGEsYil7YT1hfHwwO2I9bnVsbCE9Yj9iOm5ldyBteFJlY3RhbmdsZSh0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO2lmKG51bGwhPXRoaXMuc2hhcGUmJm51bGwhPXRoaXMuc2hhcGUuc3RlbmNpbCYmImZpeGVkIj09dGhpcy5zaGFwZS5zdGVuY2lsLmFzcGVjdCl7dmFyIGM9dGhpcy5zaGFwZS5zdGVuY2lsLmNvbXB1dGVBc3BlY3QodGhpcy5zdHlsZSxiLngsYi55LGIud2lkdGgsYi5oZWlnaHQpO2IueD1jLng7Yi55PWMueTtiLndpZHRoPXRoaXMuc2hhcGUuc3RlbmNpbC53MCpjLndpZHRoO2IuaGVpZ2h0PXRoaXMuc2hhcGUuc3RlbmNpbC5oMCpjLmhlaWdodH0wIT1hJiZiLmdyb3coYSk7cmV0dXJuIGJ9OwpteENlbGxTdGF0ZS5wcm90b3R5cGUuc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYil7Yj8obnVsbD09dGhpcy5hYnNvbHV0ZVBvaW50cyYmKHRoaXMuYWJzb2x1dGVQb2ludHM9W10pLDA9PXRoaXMuYWJzb2x1dGVQb2ludHMubGVuZ3RoP3RoaXMuYWJzb2x1dGVQb2ludHMucHVzaChhKTp0aGlzLmFic29sdXRlUG9pbnRzWzBdPWEpOm51bGw9PXRoaXMuYWJzb2x1dGVQb2ludHM/KHRoaXMuYWJzb2x1dGVQb2ludHM9W10sdGhpcy5hYnNvbHV0ZVBvaW50cy5wdXNoKG51bGwpLHRoaXMuYWJzb2x1dGVQb2ludHMucHVzaChhKSk6MT09dGhpcy5hYnNvbHV0ZVBvaW50cy5sZW5ndGg/dGhpcy5hYnNvbHV0ZVBvaW50cy5wdXNoKGEpOnRoaXMuYWJzb2x1dGVQb2ludHNbdGhpcy5hYnNvbHV0ZVBvaW50cy5sZW5ndGgtMV09YX07Cm14Q2VsbFN0YXRlLnByb3RvdHlwZS5zZXRDdXJzb3I9ZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5zaGFwZSYmdGhpcy5zaGFwZS5zZXRDdXJzb3IoYSk7bnVsbCE9dGhpcy50ZXh0JiZ0aGlzLnRleHQuc2V0Q3Vyc29yKGEpfTtteENlbGxTdGF0ZS5wcm90b3R5cGUuZ2V0VmlzaWJsZVRlcm1pbmFsPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZShhKTtyZXR1cm4gbnVsbCE9YT9hLmNlbGw6bnVsbH07bXhDZWxsU3RhdGUucHJvdG90eXBlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlPWZ1bmN0aW9uKGEpe3JldHVybiBhP3RoaXMudmlzaWJsZVNvdXJjZVN0YXRlOnRoaXMudmlzaWJsZVRhcmdldFN0YXRlfTtteENlbGxTdGF0ZS5wcm90b3R5cGUuc2V0VmlzaWJsZVRlcm1pbmFsU3RhdGU9ZnVuY3Rpb24oYSxiKXtiP3RoaXMudmlzaWJsZVNvdXJjZVN0YXRlPWE6dGhpcy52aXNpYmxlVGFyZ2V0U3RhdGU9YX07Cm14Q2VsbFN0YXRlLnByb3RvdHlwZS5nZXRDZWxsQm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbEJvdW5kc307bXhDZWxsU3RhdGUucHJvdG90eXBlLmdldFBhaW50Qm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFpbnRCb3VuZHN9O214Q2VsbFN0YXRlLnByb3RvdHlwZS51cGRhdGVDYWNoZWRCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnZpZXcudHJhbnNsYXRlLGI9dGhpcy52aWV3LnNjYWxlO3RoaXMuY2VsbEJvdW5kcz1uZXcgbXhSZWN0YW5nbGUodGhpcy54L2ItYS54LHRoaXMueS9iLWEueSx0aGlzLndpZHRoL2IsdGhpcy5oZWlnaHQvYik7dGhpcy5wYWludEJvdW5kcz1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKHRoaXMuY2VsbEJvdW5kcyk7bnVsbCE9dGhpcy5zaGFwZSYmdGhpcy5zaGFwZS5pc1BhaW50Qm91bmRzSW52ZXJ0ZWQoKSYmdGhpcy5wYWludEJvdW5kcy5yb3RhdGU5MCgpfTsKbXhDZWxsU3RhdGUucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEpe3RoaXMudmlldz1hLnZpZXc7dGhpcy5jZWxsPWEuY2VsbDt0aGlzLnN0eWxlPWEuc3R5bGU7dGhpcy5hYnNvbHV0ZVBvaW50cz1hLmFic29sdXRlUG9pbnRzO3RoaXMub3JpZ2luPWEub3JpZ2luO3RoaXMuYWJzb2x1dGVPZmZzZXQ9YS5hYnNvbHV0ZU9mZnNldDt0aGlzLmJvdW5kaW5nQm94PWEuYm91bmRpbmdCb3g7dGhpcy50ZXJtaW5hbERpc3RhbmNlPWEudGVybWluYWxEaXN0YW5jZTt0aGlzLnNlZ21lbnRzPWEuc2VnbWVudHM7dGhpcy5sZW5ndGg9YS5sZW5ndGg7dGhpcy54PWEueDt0aGlzLnk9YS55O3RoaXMud2lkdGg9YS53aWR0aDt0aGlzLmhlaWdodD1hLmhlaWdodDt0aGlzLnVuc2NhbGVkV2lkdGg9YS51bnNjYWxlZFdpZHRoO3RoaXMudW5zY2FsZWRIZWlnaHQ9YS51bnNjYWxlZEhlaWdodH07Cm14Q2VsbFN0YXRlLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBteENlbGxTdGF0ZSh0aGlzLnZpZXcsdGhpcy5jZWxsLHRoaXMuc3R5bGUpO2lmKG51bGwhPXRoaXMuYWJzb2x1dGVQb2ludHMpe2EuYWJzb2x1dGVQb2ludHM9W107Zm9yKHZhciBiPTA7Yjx0aGlzLmFic29sdXRlUG9pbnRzLmxlbmd0aDtiKyspYS5hYnNvbHV0ZVBvaW50c1tiXT10aGlzLmFic29sdXRlUG9pbnRzW2JdLmNsb25lKCl9bnVsbCE9dGhpcy5vcmlnaW4mJihhLm9yaWdpbj10aGlzLm9yaWdpbi5jbG9uZSgpKTtudWxsIT10aGlzLmFic29sdXRlT2Zmc2V0JiYoYS5hYnNvbHV0ZU9mZnNldD10aGlzLmFic29sdXRlT2Zmc2V0LmNsb25lKCkpO251bGwhPXRoaXMuYm91bmRpbmdCb3gmJihhLmJvdW5kaW5nQm94PXRoaXMuYm91bmRpbmdCb3guY2xvbmUoKSk7YS50ZXJtaW5hbERpc3RhbmNlPXRoaXMudGVybWluYWxEaXN0YW5jZTthLnNlZ21lbnRzPXRoaXMuc2VnbWVudHM7YS5sZW5ndGg9CnRoaXMubGVuZ3RoO2EueD10aGlzLng7YS55PXRoaXMueTthLndpZHRoPXRoaXMud2lkdGg7YS5oZWlnaHQ9dGhpcy5oZWlnaHQ7YS51bnNjYWxlZFdpZHRoPXRoaXMudW5zY2FsZWRXaWR0aDthLnVuc2NhbGVkSGVpZ2h0PXRoaXMudW5zY2FsZWRIZWlnaHQ7cmV0dXJuIGF9O214Q2VsbFN0YXRlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5kZXN0cm95KHRoaXMpfTtmdW5jdGlvbiBteEdyYXBoU2VsZWN0aW9uTW9kZWwoYSl7dGhpcy5ncmFwaD1hO3RoaXMuY2VsbHM9W119bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14R3JhcGhTZWxlY3Rpb25Nb2RlbDtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmRvbmVSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJkb25lIjoiIjsKbXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS51cGRhdGluZ1NlbGVjdGlvblJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/InVwZGF0aW5nU2VsZWN0aW9uIjoiIjtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmdyYXBoPW51bGw7bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zaW5nbGVTZWxlY3Rpb249ITE7bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc1NpbmdsZVNlbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpbmdsZVNlbGVjdGlvbn07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zZXRTaW5nbGVTZWxlY3Rpb249ZnVuY3Rpb24oYSl7dGhpcy5zaW5nbGVTZWxlY3Rpb249YX07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc1NlbGVjdGVkPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hPzA8PW14VXRpbHMuaW5kZXhPZih0aGlzLmNlbGxzLGEpOiExfTsKbXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PXRoaXMuY2VsbHMubGVuZ3RofTtteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5jaGFuZ2VTZWxlY3Rpb24obnVsbCx0aGlzLmNlbGxzKX07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zZXRDZWxsPWZ1bmN0aW9uKGEpe251bGwhPWEmJnRoaXMuc2V0Q2VsbHMoW2FdKX07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zZXRDZWxscz1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt0aGlzLnNpbmdsZVNlbGVjdGlvbiYmKGE9W3RoaXMuZ2V0Rmlyc3RTZWxlY3RhYmxlQ2VsbChhKV0pO2Zvcih2YXIgYj1bXSxjPTA7YzxhLmxlbmd0aDtjKyspdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RhYmxlKGFbY10pJiZiLnB1c2goYVtjXSk7dGhpcy5jaGFuZ2VTZWxlY3Rpb24oYix0aGlzLmNlbGxzKX19OwpteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmdldEZpcnN0U2VsZWN0YWJsZUNlbGw9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSlmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKylpZih0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGFibGUoYVtiXSkpcmV0dXJuIGFbYl07cmV0dXJuIG51bGx9O214R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuYWRkQ2VsbD1mdW5jdGlvbihhKXtudWxsIT1hJiZ0aGlzLmFkZENlbGxzKFthXSl9OwpteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmFkZENlbGxzPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPW51bGw7dGhpcy5zaW5nbGVTZWxlY3Rpb24mJihiPXRoaXMuY2VsbHMsYT1bdGhpcy5nZXRGaXJzdFNlbGVjdGFibGVDZWxsKGEpXSk7Zm9yKHZhciBjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKykhdGhpcy5pc1NlbGVjdGVkKGFbZF0pJiZ0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGFibGUoYVtkXSkmJmMucHVzaChhW2RdKTt0aGlzLmNoYW5nZVNlbGVjdGlvbihjLGIpfX07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5yZW1vdmVDZWxsPWZ1bmN0aW9uKGEpe251bGwhPWEmJnRoaXMucmVtb3ZlQ2VsbHMoW2FdKX07Cm14R3JhcGhTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQ2VsbHM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyl0aGlzLmlzU2VsZWN0ZWQoYVtjXSkmJmIucHVzaChhW2NdKTt0aGlzLmNoYW5nZVNlbGVjdGlvbihudWxsLGIpfX07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5jaGFuZ2VTZWxlY3Rpb249ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiYwPGEubGVuZ3RoJiZudWxsIT1hWzBdfHxudWxsIT1iJiYwPGIubGVuZ3RoJiZudWxsIT1iWzBdKXt2YXIgYz1uZXcgbXhTZWxlY3Rpb25DaGFuZ2UodGhpcyxhLGIpO2MuZXhlY3V0ZSgpO3ZhciBkPW5ldyBteFVuZG9hYmxlRWRpdCh0aGlzLCExKTtkLmFkZChjKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlVORE8sImVkaXQiLGQpKX19OwpteEdyYXBoU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNlbGxBZGRlZD1mdW5jdGlvbihhKXtudWxsPT1hfHx0aGlzLmlzU2VsZWN0ZWQoYSl8fHRoaXMuY2VsbHMucHVzaChhKX07bXhHcmFwaFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5jZWxsUmVtb3ZlZD1mdW5jdGlvbihhKXtudWxsIT1hJiYoYT1teFV0aWxzLmluZGV4T2YodGhpcy5jZWxscyxhKSwwPD1hJiZ0aGlzLmNlbGxzLnNwbGljZShhLDEpKX07ZnVuY3Rpb24gbXhTZWxlY3Rpb25DaGFuZ2UoYSxiLGMpe3RoaXMuc2VsZWN0aW9uTW9kZWw9YTt0aGlzLmFkZGVkPW51bGwhPWI/Yi5zbGljZSgpOm51bGw7dGhpcy5yZW1vdmVkPW51bGwhPWM/Yy5zbGljZSgpOm51bGx9Cm14U2VsZWN0aW9uQ2hhbmdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dmFyIGE9bXhMb2cuZW50ZXIoIm14U2VsZWN0aW9uQ2hhbmdlLmV4ZWN1dGUiKTt3aW5kb3cuc3RhdHVzPW14UmVzb3VyY2VzLmdldCh0aGlzLnNlbGVjdGlvbk1vZGVsLnVwZGF0aW5nU2VsZWN0aW9uUmVzb3VyY2UpfHx0aGlzLnNlbGVjdGlvbk1vZGVsLnVwZGF0aW5nU2VsZWN0aW9uUmVzb3VyY2U7aWYobnVsbCE9dGhpcy5yZW1vdmVkKWZvcih2YXIgYj0wO2I8dGhpcy5yZW1vdmVkLmxlbmd0aDtiKyspdGhpcy5zZWxlY3Rpb25Nb2RlbC5jZWxsUmVtb3ZlZCh0aGlzLnJlbW92ZWRbYl0pO2lmKG51bGwhPXRoaXMuYWRkZWQpZm9yKGI9MDtiPHRoaXMuYWRkZWQubGVuZ3RoO2IrKyl0aGlzLnNlbGVjdGlvbk1vZGVsLmNlbGxBZGRlZCh0aGlzLmFkZGVkW2JdKTtiPXRoaXMuYWRkZWQ7dGhpcy5hZGRlZD10aGlzLnJlbW92ZWQ7dGhpcy5yZW1vdmVkPWI7d2luZG93LnN0YXR1cz1teFJlc291cmNlcy5nZXQodGhpcy5zZWxlY3Rpb25Nb2RlbC5kb25lUmVzb3VyY2UpfHwKdGhpcy5zZWxlY3Rpb25Nb2RlbC5kb25lUmVzb3VyY2U7bXhMb2cubGVhdmUoIm14U2VsZWN0aW9uQ2hhbmdlLmV4ZWN1dGUiLGEpO3RoaXMuc2VsZWN0aW9uTW9kZWwuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0hBTkdFLCJhZGRlZCIsdGhpcy5hZGRlZCwicmVtb3ZlZCIsdGhpcy5yZW1vdmVkKSl9OwpmdW5jdGlvbiBteENlbGxFZGl0b3IoYSl7dGhpcy5ncmFwaD1hO3RoaXMuem9vbUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmdyYXBoLmlzRWRpdGluZygpJiZ0aGlzLnJlc2l6ZSgpfSk7dGhpcy5ncmFwaC52aWV3LmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEUsdGhpcy56b29tSGFuZGxlcik7dGhpcy5ncmFwaC52aWV3LmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEVfQU5EX1RSQU5TTEFURSx0aGlzLnpvb21IYW5kbGVyKTt0aGlzLmNoYW5nZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5lZGl0aW5nQ2VsbCYmbnVsbD09dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5lZGl0aW5nQ2VsbCkmJnRoaXMuc3RvcEVkaXRpbmcoITApfSk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMuY2hhbmdlSGFuZGxlcil9Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteENlbGxFZGl0b3IucHJvdG90eXBlLnRleHRhcmVhPW51bGw7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5lZGl0aW5nQ2VsbD1udWxsO214Q2VsbEVkaXRvci5wcm90b3R5cGUudHJpZ2dlcj1udWxsO214Q2VsbEVkaXRvci5wcm90b3R5cGUubW9kaWZpZWQ9ITE7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5hdXRvU2l6ZT0hMDtteENlbGxFZGl0b3IucHJvdG90eXBlLnNlbGVjdFRleHQ9ITA7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5lbXB0eUxhYmVsVGV4dD1teENsaWVudC5JU19GRj8iPGJyPiI6IiI7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5lc2NhcGVDYW5jZWxzRWRpdGluZz0hMDtteENlbGxFZGl0b3IucHJvdG90eXBlLnRleHROb2RlPSIiO214Q2VsbEVkaXRvci5wcm90b3R5cGUuekluZGV4PTU7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5taW5SZXNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMjApOwpteENlbGxFZGl0b3IucHJvdG90eXBlLndvcmRXcmFwUGFkZGluZz1teENsaWVudC5JU19RVUlSS1M/MjpteENsaWVudC5JU19JRTExPzA6MTtteENlbGxFZGl0b3IucHJvdG90eXBlLmJsdXJFbmFibGVkPSExO214Q2VsbEVkaXRvci5wcm90b3R5cGUuaW5pdGlhbFZhbHVlPW51bGw7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5hbGlnbj1udWxsO214Q2VsbEVkaXRvci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3RoaXMudGV4dGFyZWE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7dGhpcy50ZXh0YXJlYS5jbGFzc05hbWU9Im14Q2VsbEVkaXRvciBteFBsYWluVGV4dEVkaXRvciI7dGhpcy50ZXh0YXJlYS5jb250ZW50RWRpdGFibGU9ITA7bXhDbGllbnQuSVNfR0MmJih0aGlzLnRleHRhcmVhLnN0eWxlLm1pbkhlaWdodD0iMWVtIik7dGhpcy50ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbj10aGlzLmlzTGVnYWN5RWRpdG9yKCk/ImFic29sdXRlIjoicmVsYXRpdmUiO3RoaXMuaW5zdGFsbExpc3RlbmVycyh0aGlzLnRleHRhcmVhKX07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuYXBwbHlWYWx1ZT1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGgubGFiZWxDaGFuZ2VkKGEuY2VsbCxiLHRoaXMudHJpZ2dlcil9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuc2V0QWxpZ249ZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy50ZXh0YXJlYSYmKHRoaXMudGV4dGFyZWEuc3R5bGUudGV4dEFsaWduPWEpO3RoaXMuYWxpZ249YTt0aGlzLnJlc2l6ZSgpfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsVmFsdWU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1teFV0aWxzLmh0bWxFbnRpdGllcyh0aGlzLmdyYXBoLmdldEVkaXRpbmdWYWx1ZShhLmNlbGwsYiksITEpO214Q2xpZW50LklTX1FVSVJLU3x8OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDEwPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fChjPW14VXRpbHMucmVwbGFjZVRyYWlsaW5nTmV3bGluZXMoYywiPGRpdj48YnI+PC9kaXY+IikpO3JldHVybiBjLnJlcGxhY2UoL1xuL2csIjxicj4iKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRDdXJyZW50VmFsdWU9ZnVuY3Rpb24oYSl7cmV0dXJuIG14VXRpbHMuZXh0cmFjdFRleHRXaXRoV2hpdGVzcGFjZSh0aGlzLnRleHRhcmVhLmNoaWxkTm9kZXMpfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pc0NhbmNlbEVkaXRpbmdLZXlFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lc2NhcGVDYW5jZWxzRWRpdGluZ3x8bXhFdmVudC5pc1NoaWZ0RG93bihhKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfHxteEV2ZW50LmlzTWV0YURvd24oYSl9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLmluc3RhbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oYSl7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJkcmFnc3RhcnQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguc3RvcEVkaXRpbmcoITEpO214RXZlbnQuY29uc3VtZShhKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImJsdXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuYmx1ckVuYWJsZWQmJnRoaXMuZm9jdXNMb3N0KGEpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoYSwia2V5ZG93biIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5pc0NvbnN1bWVkKGEpfHwodGhpcy5pc1N0b3BFZGl0aW5nRXZlbnQoYSk/KHRoaXMuZ3JhcGguc3RvcEVkaXRpbmcoITEpLG14RXZlbnQuY29uc3VtZShhKSk6Mjc9PWEua2V5Q29kZSYmKHRoaXMuZ3JhcGguc3RvcEVkaXRpbmcodGhpcy5pc0NhbmNlbEVkaXRpbmdLZXlFdmVudChhKSksbXhFdmVudC5jb25zdW1lKGEpKSl9KSk7CnZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe251bGwhPXRoaXMuZWRpdGluZ0NlbGwmJnRoaXMuY2xlYXJPbkNoYW5nZSYmYS5pbm5lckhUTUw9PXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKSYmKCFteENsaWVudC5JU19GRnx8OCE9Yi5rZXlDb2RlJiY0NiE9Yi5rZXlDb2RlKSYmKHRoaXMuY2xlYXJPbkNoYW5nZT0hMSxhLmlubmVySFRNTD0iIil9KTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImtleXByZXNzIixiKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsInBhc3RlIixiKTtiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZWRpdGluZ0NlbGwmJigwPT10aGlzLnRleHRhcmVhLmlubmVySFRNTC5sZW5ndGh8fCI8YnI+Ij09dGhpcy50ZXh0YXJlYS5pbm5lckhUTUw/KHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKSx0aGlzLmNsZWFyT25DaGFuZ2U9MDx0aGlzLnRleHRhcmVhLmlubmVySFRNTC5sZW5ndGgpOgp0aGlzLmNsZWFyT25DaGFuZ2U9ITEpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLG14Q2xpZW50LklTX0lFMTF8fG14Q2xpZW50LklTX0lFPyJrZXl1cCI6ImlucHV0IixiKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImN1dCIsYik7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJwYXN0ZSIsYik7dmFyIGI9bXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfSUU/ImtleWRvd24iOiJpbnB1dCIsYz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT10aGlzLmVkaXRpbmdDZWxsJiZ0aGlzLmF1dG9TaXplJiYhbXhFdmVudC5pc0NvbnN1bWVkKGEpJiYobnVsbCE9dGhpcy5yZXNpemVUaHJlYWQmJndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaHJlYWQpLHRoaXMucmVzaXplVGhyZWFkPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXNpemVUaHJlYWQ9bnVsbDt0aGlzLnJlc2l6ZSgpfSksMCkpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLApiLGMpO214RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJyZXNpemUiLGMpOzk8PWRvY3VtZW50LmRvY3VtZW50TW9kZT8obXhFdmVudC5hZGRMaXN0ZW5lcihhLCJET01Ob2RlUmVtb3ZlZCIsYyksbXhFdmVudC5hZGRMaXN0ZW5lcihhLCJET01Ob2RlSW5zZXJ0ZWQiLGMpKToobXhFdmVudC5hZGRMaXN0ZW5lcihhLCJjdXQiLGMpLG14RXZlbnQuYWRkTGlzdGVuZXIoYSwicGFzdGUiLGMpKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pc1N0b3BFZGl0aW5nRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIDExMz09YS5rZXlDb2RlfHx0aGlzLmdyYXBoLmlzRW50ZXJTdG9wc0NlbGxFZGl0aW5nKCkmJjEzPT1hLmtleUNvZGUmJiFteEV2ZW50LmlzQ29udHJvbERvd24oYSkmJiFteEV2ZW50LmlzU2hpZnREb3duKGEpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmlzRXZlbnRTb3VyY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuZ2V0U291cmNlKGEpPT10aGlzLnRleHRhcmVhfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZSh0aGlzLmVkaXRpbmdDZWxsKTtpZihudWxsPT1hKXRoaXMuc3RvcEVkaXRpbmcoITApO2Vsc2UgaWYobnVsbCE9dGhpcy50ZXh0YXJlYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpLGM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZD1udWxsO2lmKHRoaXMuYXV0b1NpemUmJiJmaWxsIiE9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10pe3ZhciBlPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9XSURUSCxudWxsKSxkPW51bGwhPWEudGV4dCYmbnVsbD09dGhpcy5hbGlnbj9hLnRleHQubWFyZ2luOm51bGw7bnVsbD09ZCYmKGQ9bXhVdGlscy5nZXRBbGlnbm1lbnRBc1BvaW50KHRoaXMuYWxpZ258fG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BTElHTiwKbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKSxteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSkpO2lmKGIpdGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKGEuYWJzb2x1dGVPZmZzZXQueCxhLmFic29sdXRlT2Zmc2V0LnksMCwwKSxudWxsIT1lJiYoZT0ocGFyc2VGbG9hdChlKSsyKSpjLHRoaXMuYm91bmRzLndpZHRoPWUsdGhpcy5ib3VuZHMueCs9ZC54KmUpO2Vsc2V7dmFyIGI9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShhKSxmPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpLGc9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSksYj1udWxsIT1hLnNoYXBlJiZmPT0KbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJiZnPT1teENvbnN0YW50cy5BTElHTl9NSURETEU/YS5zaGFwZS5nZXRMYWJlbEJvdW5kcyhiKTpiO251bGwhPWUmJihiLndpZHRoPXBhcnNlRmxvYXQoZSkqYyk7aWYoIWEudmlldy5ncmFwaC5jZWxsUmVuZGVyZXIubGVnYWN5U3BhY2luZ3x8IndpZHRoIiE9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10pdmFyIGY9cGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HXXx8MikqYyxrPShwYXJzZUludChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfVE9QXXx8MCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ1RvcCkqYytmLGw9KHBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19SSUdIVF18fDApK214VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdSaWdodCkqYytmLG09KHBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19CT1RUT01dfHwKMCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0JvdHRvbSkqYytmLG49KHBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19MRUZUXXx8MCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ0xlZnQpKmMrZixmPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpLGc9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSksYj1uZXcgbXhSZWN0YW5nbGUoYi54K24sYi55K2ssYi53aWR0aC0oZj09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJiZudWxsPT1lP24rbDowKSxiLmhlaWdodC0oZz09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2srbTowKSk7dGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKGIueCthLmFic29sdXRlT2Zmc2V0LngsYi55KwphLmFic29sdXRlT2Zmc2V0LnksYi53aWR0aCxiLmhlaWdodCl9dGhpcy5ncmFwaC5pc1dyYXBwaW5nKGEuY2VsbCkmJigyPD10aGlzLmJvdW5kcy53aWR0aHx8Mjw9dGhpcy5ib3VuZHMuaGVpZ2h0KSYmdGhpcy50ZXh0YXJlYS5pbm5lckhUTUwhPXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKT8odGhpcy50ZXh0YXJlYS5zdHlsZS53b3JkV3JhcD1teENvbnN0YW50cy5XT1JEX1dSQVAsdGhpcy50ZXh0YXJlYS5zdHlsZS53aGl0ZVNwYWNlPSJub3JtYWwiLGU9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aC9jKSt0aGlzLndvcmRXcmFwUGFkZGluZywicmVsYXRpdmUiIT10aGlzLnRleHRhcmVhLnN0eWxlLnBvc2l0aW9uPyh0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPWUrInB4Iix0aGlzLnRleHRhcmVhLnNjcm9sbFdpZHRoPmUmJih0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPXRoaXMudGV4dGFyZWEuc2Nyb2xsV2lkdGgrInB4IikpOnRoaXMudGV4dGFyZWEuc3R5bGUubWF4V2lkdGg9CmUrInB4Iik6KHRoaXMudGV4dGFyZWEuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIix0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPSIiKTs4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJih0aGlzLnRleHRhcmVhLnN0eWxlLnpvb209IjEiLHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0PSJhdXRvIik7YT10aGlzLnRleHRhcmVhLnNjcm9sbFdpZHRoO2U9dGhpcy50ZXh0YXJlYS5zY3JvbGxIZWlnaHQ7OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPyh0aGlzLnRleHRhcmVhLnN0eWxlLmxlZnQ9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHRoaXMuYm91bmRzLngtZC54Kih0aGlzLmJvdW5kcy53aWR0aC0oYSsxKSpjKSthKihjLTEpKjArMiooZC54Ky41KSkvYykpKyJweCIsdGhpcy50ZXh0YXJlYS5zdHlsZS50b3A9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHRoaXMuYm91bmRzLnktZC55Kih0aGlzLmJvdW5kcy5oZWlnaHQtKGUrLjUpKmMpK2UqKGMtMSkqMCsxKk1hdGguYWJzKGQueSsuNSkpLwpjKSkrInB4Iix0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPU1hdGgucm91bmQoYSpjKSsicHgiLHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0PU1hdGgucm91bmQoZSpjKSsicHgiKTpteENsaWVudC5JU19RVUlSS1M/KHRoaXMudGV4dGFyZWEuc3R5bGUubGVmdD1NYXRoLm1heCgwLE1hdGguY2VpbCh0aGlzLmJvdW5kcy54LWQueCoodGhpcy5ib3VuZHMud2lkdGgtKGErMSkqYykrYSooYy0xKSowKzIqKGQueCsuNSkpKSsicHgiLHRoaXMudGV4dGFyZWEuc3R5bGUudG9wPU1hdGgubWF4KDAsTWF0aC5jZWlsKHRoaXMuYm91bmRzLnktZC55Kih0aGlzLmJvdW5kcy5oZWlnaHQtKGUrLjUpKmMpK2UqKGMtMSkqMCsxKk1hdGguYWJzKGQueSsuNSkpKSsicHgiKToodGhpcy50ZXh0YXJlYS5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54LWQueCoodGhpcy5ib3VuZHMud2lkdGgtMikpKzEpKyJweCIsdGhpcy50ZXh0YXJlYS5zdHlsZS50b3A9TWF0aC5tYXgoMCwKTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55LWQueSoodGhpcy5ib3VuZHMuaGVpZ2h0LTQpKygtMT09ZC55PzM6MCkpKzEpKyJweCIpfWVsc2UgdGhpcy5ib3VuZHM9dGhpcy5nZXRFZGl0b3JCb3VuZHMoYSksdGhpcy50ZXh0YXJlYS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLndpZHRoL2MpKyJweCIsdGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy5oZWlnaHQvYykrInB4Iiw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14Q2xpZW50LklTX1FVSVJLUz8odGhpcy50ZXh0YXJlYS5zdHlsZS5sZWZ0PU1hdGgucm91bmQodGhpcy5ib3VuZHMueCkrInB4Iix0aGlzLnRleHRhcmVhLnN0eWxlLnRvcD1NYXRoLnJvdW5kKHRoaXMuYm91bmRzLnkpKyJweCIpOih0aGlzLnRleHRhcmVhLnN0eWxlLmxlZnQ9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKHRoaXMuYm91bmRzLngrMSkpKyJweCIsdGhpcy50ZXh0YXJlYS5zdHlsZS50b3A9TWF0aC5tYXgoMCwKTWF0aC5yb3VuZCh0aGlzLmJvdW5kcy55KzEpKSsicHgiKSx0aGlzLmdyYXBoLmlzV3JhcHBpbmcoYS5jZWxsKSYmKDI8PXRoaXMuYm91bmRzLndpZHRofHwyPD10aGlzLmJvdW5kcy5oZWlnaHQpJiZ0aGlzLnRleHRhcmVhLmlubmVySFRNTCE9dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpPyh0aGlzLnRleHRhcmVhLnN0eWxlLndvcmRXcmFwPW14Q29uc3RhbnRzLldPUkRfV1JBUCx0aGlzLnRleHRhcmVhLnN0eWxlLndoaXRlU3BhY2U9Im5vcm1hbCIsImZpbGwiIT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXSYmKHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy53aWR0aC9jKSt0aGlzLndvcmRXcmFwUGFkZGluZysicHgiKSk6KHRoaXMudGV4dGFyZWEuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIiwiZmlsbCIhPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfT1ZFUkZMT1ddJiYodGhpcy50ZXh0YXJlYS5zdHlsZS53aWR0aD0iIikpOwpteENsaWVudC5JU19WTUw/dGhpcy50ZXh0YXJlYS5zdHlsZS56b29tPWM6KG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLnRleHRhcmVhLnN0eWxlLCJ0cmFuc2Zvcm1PcmlnaW4iLCIwcHggMHB4IiksbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKHRoaXMudGV4dGFyZWEuc3R5bGUsInRyYW5zZm9ybSIsInNjYWxlKCIrYysiLCIrYysiKSIrKG51bGw9PWQ/IiI6IiB0cmFuc2xhdGUoIisxMDAqZC54KyIlLCIrMTAwKmQueSsiJSkiKSkpfX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5mb2N1c0xvc3Q9ZnVuY3Rpb24oKXt0aGlzLnN0b3BFZGl0aW5nKCF0aGlzLmdyYXBoLmlzSW52b2tlc1N0b3BDZWxsRWRpdGluZygpKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRCYWNrZ3JvdW5kQ29sb3I9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLmlzTGVnYWN5RWRpdG9yPWZ1bmN0aW9uKCl7aWYobXhDbGllbnQuSVNfVk1MKXJldHVybiEwO3ZhciBhPSExO2lmKG14Q2xpZW50LklTX1NWRyl7dmFyIGI9dGhpcy5ncmFwaC52aWV3LmdldERyYXdQYW5lKCkub3duZXJTVkdFbGVtZW50O251bGwhPWImJihiPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKGIpLG51bGwhPWImJihhPSJhYnNvbHV0ZSI9PWIucG9zaXRpb24pKX1yZXR1cm4hYX07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuc3RhcnRFZGl0aW5nPWZ1bmN0aW9uKGEsYil7dGhpcy5zdG9wRWRpdGluZyghMCk7dGhpcy5hbGlnbj1udWxsO251bGw9PXRoaXMudGV4dGFyZWEmJnRoaXMuaW5pdCgpO251bGwhPXRoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXImJnRoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXIuaGlkZVRvb2x0aXAoKTt2YXIgYz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZShhKTtpZihudWxsIT1jKXt0aGlzLmdyYXBoLmdldFZpZXcoKTt2YXIgZD1teFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9GT05UU0laRSksZT1teFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRk9OVEZBTUlMWSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFkpLGY9bXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUiwiYmxhY2siKSwKZz1teFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTEVGVCksaz0obXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwwKSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQsbD0obXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwwKSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDLG09W107KG14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsMCkmbXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUpPT1teENvbnN0YW50cy5GT05UX1VOREVSTElORSYmbS5wdXNoKCJ1bmRlcmxpbmUiKTsobXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwwKSZteENvbnN0YW50cy5GT05UX1NUUklLRVRIUk9VR0gpPT0KbXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIJiZtLnB1c2goImxpbmUtdGhyb3VnaCIpO3RoaXMudGV4dGFyZWEuc3R5bGUubGluZUhlaWdodD1teENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD9NYXRoLnJvdW5kKGQqbXhDb25zdGFudHMuTElORV9IRUlHSFQpKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQ7dGhpcy50ZXh0YXJlYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy5nZXRCYWNrZ3JvdW5kQ29sb3IoYyk7dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0RGVjb3JhdGlvbj1tLmpvaW4oIiAiKTt0aGlzLnRleHRhcmVhLnN0eWxlLmZvbnRXZWlnaHQ9az8iYm9sZCI6Im5vcm1hbCI7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250U3R5bGU9bD8iaXRhbGljIjoiIjt0aGlzLnRleHRhcmVhLnN0eWxlLmZvbnRTaXplPU1hdGgucm91bmQoZCkrInB4Ijt0aGlzLnRleHRhcmVhLnN0eWxlLnpJbmRleD10aGlzLnpJbmRleDt0aGlzLnRleHRhcmVhLnN0eWxlLmZvbnRGYW1pbHk9CmU7dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0QWxpZ249Zzt0aGlzLnRleHRhcmVhLnN0eWxlLm91dGxpbmU9Im5vbmUiO3RoaXMudGV4dGFyZWEuc3R5bGUuY29sb3I9ZjtkPXRoaXMudGV4dERpcmVjdGlvbj1teFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVEVYVF9ESVJFQ1RJT04sbXhDb25zdGFudHMuREVGQVVMVF9URVhUX0RJUkVDVElPTik7ZD09bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fQVVUTyYmKG51bGw9PWN8fG51bGw9PWMudGV4dHx8Yy50ZXh0LmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTHx8bXhVdGlscy5pc05vZGUoYy50ZXh0LnZhbHVlKXx8KGQ9Yy50ZXh0LmdldEF1dG9EaXJlY3Rpb24oKSkpO2Q9PW14Q29uc3RhbnRzLlRFWFRfRElSRUNUSU9OX0xUUnx8ZD09bXhDb25zdGFudHMuVEVYVF9ESVJFQ1RJT05fUlRMP3RoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCJkaXIiLGQpOnRoaXMudGV4dGFyZWEucmVtb3ZlQXR0cmlidXRlKCJkaXIiKTsKdGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9dGhpcy5nZXRJbml0aWFsVmFsdWUoYyxiKXx8IiI7dGhpcy5pbml0aWFsVmFsdWU9dGhpcy50ZXh0YXJlYS5pbm5lckhUTUw7MD09dGhpcy50ZXh0YXJlYS5pbm5lckhUTUwubGVuZ3RofHwiPGJyPiI9PXRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPyh0aGlzLnRleHRhcmVhLmlubmVySFRNTD10aGlzLmdldEVtcHR5TGFiZWxUZXh0KCksdGhpcy5jbGVhck9uQ2hhbmdlPSEwKTp0aGlzLmNsZWFyT25DaGFuZ2U9dGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9PXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKTt0aGlzLmdyYXBoLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRleHRhcmVhKTt0aGlzLmVkaXRpbmdDZWxsPWE7dGhpcy50cmlnZ2VyPWI7dGhpcy50ZXh0Tm9kZT1udWxsO251bGwhPWMudGV4dCYmdGhpcy5pc0hpZGVMYWJlbChjKSYmKHRoaXMudGV4dE5vZGU9Yy50ZXh0Lm5vZGUsdGhpcy50ZXh0Tm9kZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iKTsKdGhpcy5hdXRvU2l6ZSYmKHRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGMuY2VsbCl8fCJmaWxsIiE9Yy5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10pJiZ3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucmVzaXplKCl9KSwwKTt0aGlzLnJlc2l6ZSgpO3RyeXt0aGlzLnRleHRhcmVhLmZvY3VzKCksdGhpcy5pc1NlbGVjdFRleHQoKSYmMDx0aGlzLnRleHRhcmVhLmlubmVySFRNTC5sZW5ndGgmJih0aGlzLnRleHRhcmVhLmlubmVySFRNTCE9dGhpcy5nZXRFbXB0eUxhYmVsVGV4dCgpfHwhdGhpcy5jbGVhck9uQ2hhbmdlKSYmZG9jdW1lbnQuZXhlY0NvbW1hbmQoInNlbGVjdEFsbCIsITEsbnVsbCl9Y2F0Y2gobil7fX19O214Q2VsbEVkaXRvci5wcm90b3R5cGUuaXNTZWxlY3RUZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VsZWN0VGV4dH07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuY2xlYXJTZWxlY3Rpb249ZnVuY3Rpb24oKXt2YXIgYT1udWxsO3dpbmRvdy5nZXRTZWxlY3Rpb24/YT13aW5kb3cuZ2V0U2VsZWN0aW9uKCk6ZG9jdW1lbnQuc2VsZWN0aW9uJiYoYT1kb2N1bWVudC5zZWxlY3Rpb24pO251bGwhPWEmJihhLmVtcHR5P2EuZW1wdHkoKTphLnJlbW92ZUFsbFJhbmdlcyYmYS5yZW1vdmVBbGxSYW5nZXMoKSl9OwpteENlbGxFZGl0b3IucHJvdG90eXBlLnN0b3BFZGl0aW5nPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuZWRpdGluZ0NlbGwpe251bGwhPXRoaXMudGV4dE5vZGUmJih0aGlzLnRleHROb2RlLnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiLHRoaXMudGV4dE5vZGU9bnVsbCk7YT1hP251bGw6dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZWRpdGluZ0NlbGwpO3ZhciBiPXRoaXMuaW5pdGlhbFZhbHVlO3RoaXMuYm91bmRzPXRoaXMudHJpZ2dlcj10aGlzLmVkaXRpbmdDZWxsPXRoaXMuaW5pdGlhbFZhbHVlPW51bGw7dGhpcy50ZXh0YXJlYS5ibHVyKCk7dGhpcy5jbGVhclNlbGVjdGlvbigpO251bGwhPXRoaXMudGV4dGFyZWEucGFyZW50Tm9kZSYmdGhpcy50ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGV4dGFyZWEpO3RoaXMuY2xlYXJPbkNoYW5nZSYmdGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9PXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKSYmKHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPQoiIix0aGlzLmNsZWFyT25DaGFuZ2U9ITEpO2lmKG51bGwhPWEmJih0aGlzLnRleHRhcmVhLmlubmVySFRNTCE9Ynx8bnVsbCE9dGhpcy5hbGlnbikpe3RoaXMucHJlcGFyZVRleHRhcmVhKCk7Yj10aGlzLmdldEN1cnJlbnRWYWx1ZShhKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7bnVsbCE9YiYmdGhpcy5hcHBseVZhbHVlKGEsYiksbnVsbCE9dGhpcy5hbGlnbiYmdGhpcy5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLHRoaXMuYWxpZ24sW2EuY2VsbF0pfWZpbmFsbHl7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX1teEV2ZW50LnJlbGVhc2UodGhpcy50ZXh0YXJlYSk7dGhpcy5hbGlnbj10aGlzLnRleHRhcmVhPW51bGx9fTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5wcmVwYXJlVGV4dGFyZWE9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnRleHRhcmVhLmxhc3RDaGlsZCYmIkJSIj09dGhpcy50ZXh0YXJlYS5sYXN0Q2hpbGQubm9kZU5hbWUmJnRoaXMudGV4dGFyZWEucmVtb3ZlQ2hpbGQodGhpcy50ZXh0YXJlYS5sYXN0Q2hpbGQpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmlzSGlkZUxhYmVsPWZ1bmN0aW9uKGEpe3JldHVybiEwfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldE1pbmltdW1TaXplPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0VmlldygpLnNjYWxlO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLG51bGw9PWEudGV4dD8zMDphLnRleHQuc2l6ZSpiKzIwLCJsZWZ0Ij09dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0QWxpZ24/MTIwOjQwKX07Cm14Q2VsbEVkaXRvci5wcm90b3R5cGUuZ2V0RWRpdG9yQm91bmRzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSxjPXRoaXMuZ3JhcGguZ2V0VmlldygpLnNjYWxlLGQ9dGhpcy5nZXRNaW5pbXVtU2l6ZShhKSxlPWQud2lkdGgsZD1kLmhlaWdodDtpZighYiYmYS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5sZWdhY3lTcGFjaW5nJiYiZmlsbCI9PWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfT1ZFUkZMT1ddKWM9YS5zaGFwZS5nZXRMYWJlbEJvdW5kcyhteFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGEpKTtlbHNle3ZhciBmPXBhcnNlSW50KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR118fDApKmMsZz0ocGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX1RPUF18fDApK214VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdUb3ApKmMrZixrPShwYXJzZUludChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfUklHSFRdfHwKMCkrbXhUZXh0LnByb3RvdHlwZS5iYXNlU3BhY2luZ1JpZ2h0KSpjK2YsbD0ocGFyc2VJbnQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0JPVFRPTV18fDApK214VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdCb3R0b20pKmMrZixmPShwYXJzZUludChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfTEVGVF18fDApK214VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdMZWZ0KSpjK2YsYz1uZXcgbXhSZWN0YW5nbGUoYS54LGEueSxNYXRoLm1heChlLGEud2lkdGgtZi1rKSxNYXRoLm1heChkLGEuaGVpZ2h0LWctbCkpLGs9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1BPU0lUSU9OLG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiksbD1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSxjPW51bGwhPWEuc2hhcGUmJgprPT1teENvbnN0YW50cy5BTElHTl9DRU5URVImJmw9PW14Q29uc3RhbnRzLkFMSUdOX01JRERMRT9hLnNoYXBlLmdldExhYmVsQm91bmRzKGMpOmM7Yj8oYy54PWEuYWJzb2x1dGVPZmZzZXQueCxjLnk9YS5hYnNvbHV0ZU9mZnNldC55LG51bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0LmJvdW5kaW5nQm94JiYoMDxhLnRleHQuYm91bmRpbmdCb3gueCYmKGMueD1hLnRleHQuYm91bmRpbmdCb3gueCksMDxhLnRleHQuYm91bmRpbmdCb3gueSYmKGMueT1hLnRleHQuYm91bmRpbmdCb3gueSkpKTpudWxsIT1hLnRleHQmJm51bGwhPWEudGV4dC5ib3VuZGluZ0JveCYmKGMueD1NYXRoLm1pbihjLngsYS50ZXh0LmJvdW5kaW5nQm94LngpLGMueT1NYXRoLm1pbihjLnksYS50ZXh0LmJvdW5kaW5nQm94LnkpKTtjLngrPWY7Yy55Kz1nO251bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0LmJvdW5kaW5nQm94JiYoYj8oYy53aWR0aD1NYXRoLm1heChlLGEudGV4dC5ib3VuZGluZ0JveC53aWR0aCksCmMuaGVpZ2h0PU1hdGgubWF4KGQsYS50ZXh0LmJvdW5kaW5nQm94LmhlaWdodCkpOihjLndpZHRoPU1hdGgubWF4KGMud2lkdGgsYS50ZXh0LmJvdW5kaW5nQm94LndpZHRoKSxjLmhlaWdodD1NYXRoLm1heChjLmhlaWdodCxhLnRleHQuYm91bmRpbmdCb3guaGVpZ2h0KSkpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChhLmNlbGwpJiYoYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKSxiPT1teENvbnN0YW50cy5BTElHTl9MRUZUP2MueC09YS53aWR0aDpiPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKGMueCs9YS53aWR0aCksYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fTUlERExFKSxiPT1teENvbnN0YW50cy5BTElHTl9UT1A/Yy55LT1hLmhlaWdodDpiPT0KbXhDb25zdGFudHMuQUxJR05fQk9UVE9NJiYoYy55Kz1hLmhlaWdodCkpfXJldHVybiBuZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChjLngpLE1hdGgucm91bmQoYy55KSxNYXRoLnJvdW5kKGMud2lkdGgpLE1hdGgucm91bmQoYy5oZWlnaHQpKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRFbXB0eUxhYmVsVGV4dD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lbXB0eUxhYmVsVGV4dH07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRFZGl0aW5nQ2VsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVkaXRpbmdDZWxsfTsKbXhDZWxsRWRpdG9yLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy50ZXh0YXJlYSYmKG14RXZlbnQucmVsZWFzZSh0aGlzLnRleHRhcmVhKSxudWxsIT10aGlzLnRleHRhcmVhLnBhcmVudE5vZGUmJnRoaXMudGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnRleHRhcmVhKSx0aGlzLnRleHRhcmVhPW51bGwpO251bGwhPXRoaXMuY2hhbmdlSGFuZGxlciYmKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLmNoYW5nZUhhbmRsZXIpLHRoaXMuY2hhbmdlSGFuZGxlcj1udWxsKTt0aGlzLnpvb21IYW5kbGVyJiYodGhpcy5ncmFwaC52aWV3LnJlbW92ZUxpc3RlbmVyKHRoaXMuem9vbUhhbmRsZXIpLHRoaXMuem9vbUhhbmRsZXI9bnVsbCl9O2Z1bmN0aW9uIG14Q2VsbFJlbmRlcmVyKCl7fW14Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXM9e307Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5kZWZhdWx0RWRnZVNoYXBlPW14Q29ubmVjdG9yO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5kZWZhdWx0VmVydGV4U2hhcGU9bXhSZWN0YW5nbGVTaGFwZTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZGVmYXVsdFRleHRTaGFwZT1teFRleHQ7bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmxlZ2FjeUNvbnRyb2xQb3NpdGlvbj0hMDtteENlbGxSZW5kZXJlci5wcm90b3R5cGUubGVnYWN5U3BhY2luZz0hMDtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuYW50aUFsaWFzPSEwO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5taW5TdmdTdHJva2VXaWR0aD0xO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5mb3JjZUNvbnRyb2xDbGlja0hhbmRsZXI9ITE7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZT1mdW5jdGlvbihhLGIpe214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXNbYV09Yn07Cm14Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfUkVDVEFOR0xFLG14UmVjdGFuZ2xlU2hhcGUpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfRUxMSVBTRSxteEVsbGlwc2UpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfUkhPTUJVUyxteFJob21idXMpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfQ1lMSU5ERVIsbXhDeWxpbmRlcik7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9DT05ORUNUT1IsbXhDb25uZWN0b3IpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfQUNUT1IsbXhBY3Rvcik7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9UUklBTkdMRSxteFRyaWFuZ2xlKTsKbXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9IRVhBR09OLG14SGV4YWdvbik7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9DTE9VRCxteENsb3VkKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0xJTkUsbXhMaW5lKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0FSUk9XLG14QXJyb3cpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfQVJST1dfQ09OTkVDVE9SLG14QXJyb3dDb25uZWN0b3IpO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUobXhDb25zdGFudHMuU0hBUEVfRE9VQkxFX0VMTElQU0UsbXhEb3VibGVFbGxpcHNlKTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX1NXSU1MQU5FLG14U3dpbWxhbmUpOwpteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKG14Q29uc3RhbnRzLlNIQVBFX0lNQUdFLG14SW1hZ2VTaGFwZSk7bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZShteENvbnN0YW50cy5TSEFQRV9MQUJFTCxteExhYmVsKTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZVNoYXBlPWZ1bmN0aW9uKGEpe2Euc2hhcGUuZGlhbGVjdD1hLnZpZXcuZ3JhcGguZGlhbGVjdDt0aGlzLmNvbmZpZ3VyZVNoYXBlKGEpO2Euc2hhcGUuaW5pdChhLnZpZXcuZ2V0RHJhd1BhbmUoKSl9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO251bGwhPWEuc3R5bGUmJihiPW14U3RlbmNpbFJlZ2lzdHJ5LmdldFN0ZW5jaWwoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0pLGI9bnVsbCE9Yj9uZXcgbXhTaGFwZShiKTpuZXcgKHRoaXMuZ2V0U2hhcGVDb25zdHJ1Y3RvcihhKSkpO3JldHVybiBifTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUluZGljYXRvclNoYXBlPWZ1bmN0aW9uKGEpe2Euc2hhcGUuaW5kaWNhdG9yU2hhcGU9dGhpcy5nZXRTaGFwZShhLnZpZXcuZ3JhcGguZ2V0SW5kaWNhdG9yU2hhcGUoYSkpfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlc1thXTpudWxsfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hhcGVDb25zdHJ1Y3Rvcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldFNoYXBlKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdKTtudWxsPT1iJiYoYj1hLnZpZXcuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKT90aGlzLmRlZmF1bHRFZGdlU2hhcGU6dGhpcy5kZWZhdWx0VmVydGV4U2hhcGUpO3JldHVybiBifTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNvbmZpZ3VyZVNoYXBlPWZ1bmN0aW9uKGEpe2Euc2hhcGUuYXBwbHkoYSk7YS5zaGFwZS5pbWFnZT1hLnZpZXcuZ3JhcGguZ2V0SW1hZ2UoYSk7YS5zaGFwZS5pbmRpY2F0b3JDb2xvcj1hLnZpZXcuZ3JhcGguZ2V0SW5kaWNhdG9yQ29sb3IoYSk7YS5zaGFwZS5pbmRpY2F0b3JTdHJva2VDb2xvcj1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0lORElDQVRPUl9TVFJPS0VDT0xPUl07YS5zaGFwZS5pbmRpY2F0b3JHcmFkaWVudENvbG9yPWEudmlldy5ncmFwaC5nZXRJbmRpY2F0b3JHcmFkaWVudENvbG9yKGEpO2Euc2hhcGUuaW5kaWNhdG9yRGlyZWN0aW9uPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSU5ESUNBVE9SX0RJUkVDVElPTl07YS5zaGFwZS5pbmRpY2F0b3JJbWFnZT1hLnZpZXcuZ3JhcGguZ2V0SW5kaWNhdG9ySW1hZ2UoYSk7dGhpcy5wb3N0Q29uZmlndXJlU2hhcGUoYSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUucG9zdENvbmZpZ3VyZVNoYXBlPWZ1bmN0aW9uKGEpe251bGwhPWEuc2hhcGUmJih0aGlzLnJlc29sdmVDb2xvcihhLCJpbmRpY2F0b3JHcmFkaWVudENvbG9yIixteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SKSx0aGlzLnJlc29sdmVDb2xvcihhLCJpbmRpY2F0b3JDb2xvciIsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SKSx0aGlzLnJlc29sdmVDb2xvcihhLCJncmFkaWVudCIsbXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUiksdGhpcy5yZXNvbHZlQ29sb3IoYSwic3Ryb2tlIixteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUiksdGhpcy5yZXNvbHZlQ29sb3IoYSwiZmlsbCIsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SKSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY2hlY2tQbGFjZWhvbGRlclN0eWxlcz1mdW5jdGlvbihhKXtpZihudWxsIT1hLnN0eWxlKWZvcih2YXIgYj1bImluaGVyaXQiLCJzd2ltbGFuZSIsImluZGljYXRlZCJdLGM9W214Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUixteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUixteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUl0sZD0wO2Q8Yy5sZW5ndGg7ZCsrKWlmKDA8PW14VXRpbHMuaW5kZXhPZihiLGEuc3R5bGVbY1tkXV0pKXJldHVybiEwO3JldHVybiExfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLnJlc29sdmVDb2xvcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yz09bXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SP2EudGV4dDphLnNoYXBlO2lmKG51bGwhPWQpe3ZhciBlPWEudmlldy5ncmFwaCxmPWRbYl0sZz1udWxsOyJpbmhlcml0Ij09Zj9nPWUubW9kZWwuZ2V0UGFyZW50KGEuY2VsbCk6InN3aW1sYW5lIj09Zj8oZFtiXT1jPT1teENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUnx8Yz09bXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SPyIjMDAwMDAwIjoiI2ZmZmZmZiIsZz1udWxsIT1lLm1vZGVsLmdldFRlcm1pbmFsKGEuY2VsbCwhMSk/ZS5tb2RlbC5nZXRUZXJtaW5hbChhLmNlbGwsITEpOmEuY2VsbCxnPWUuZ2V0U3dpbWxhbmUoZyksYz1lLnN3aW1sYW5lSW5kaWNhdG9yQ29sb3JBdHRyaWJ1dGUpOiJpbmRpY2F0ZWQiPT1mJiZudWxsIT1hLnNoYXBlJiYoZFtiXT1hLnNoYXBlLmluZGljYXRvckNvbG9yKTtudWxsIT1nJiYoYT0KZS5nZXRWaWV3KCkuZ2V0U3RhdGUoZyksZFtiXT1udWxsLG51bGwhPWEmJihlPWM9PW14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUj9hLnRleHQ6YS5zaGFwZSxkW2JdPW51bGwhPWUmJiJpbmRpY2F0b3JDb2xvciIhPWI/ZVtiXTphLnN0eWxlW2NdKSl9fTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFiZWxWYWx1ZT1mdW5jdGlvbihhKXtyZXR1cm4gYS52aWV3LmdyYXBoLmdldExhYmVsKGEuY2VsbCl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTGFiZWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnZpZXcuZ3JhcGg7Yy5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpO2lmKDA8YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GT05UU0laRV18fG51bGw9PWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkVdKXt2YXIgZD1jLmlzSHRtbExhYmVsKGEuY2VsbCl8fG51bGwhPWImJm14VXRpbHMuaXNOb2RlKGIpO2EudGV4dD1uZXcgdGhpcy5kZWZhdWx0VGV4dFNoYXBlKGIsbmV3IG14UmVjdGFuZ2xlLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfQUxJR05dfHxteENvbnN0YW50cy5BTElHTl9DRU5URVIsYy5nZXRWZXJ0aWNhbEFsaWduKGEpLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SXSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRGQU1JTFldLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkVdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFXSwKYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HXSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfVE9QXSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfUklHSFRdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19CT1RUT01dLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19MRUZUXSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUxdLGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfQkFDS0dST1VORENPTE9SXSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JPUkRFUkNPTE9SXSxjLmlzV3JhcHBpbmcoYS5jZWxsKSYmYy5pc0h0bWxMYWJlbChhLmNlbGwpLGMuaXNMYWJlbENsaXBwZWQoYS5jZWxsKSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXSxhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1BBRERJTkddLG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9URVhUX0RJUkVDVElPTiwKbXhDb25zdGFudHMuREVGQVVMVF9URVhUX0RJUkVDVElPTikpO2EudGV4dC5vcGFjaXR5PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9URVhUX09QQUNJVFksMTAwKTthLnRleHQuZGlhbGVjdD1kP214Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTDphLnZpZXcuZ3JhcGguZGlhbGVjdDthLnRleHQuc3R5bGU9YS5zdHlsZTthLnRleHQuc3RhdGU9YTt0aGlzLmluaXRpYWxpemVMYWJlbChhLGEudGV4dCk7dmFyIGU9ITEsZj1mdW5jdGlvbihiKXt2YXIgZD1hO2lmKG14Q2xpZW50LklTX1RPVUNIfHxlKWQ9bXhFdmVudC5nZXRDbGllbnRYKGIpLGI9bXhFdmVudC5nZXRDbGllbnRZKGIpLGI9bXhVdGlscy5jb252ZXJ0UG9pbnQoYy5jb250YWluZXIsZCxiKSxkPWMudmlldy5nZXRTdGF0ZShjLmdldENlbGxBdChiLngsYi55KSk7cmV0dXJuIGR9O214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhhLnRleHQubm9kZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLmlzTGFiZWxFdmVudChhLApiKSYmKGMuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9ET1dOLG5ldyBteE1vdXNlRXZlbnQoYixhKSksZT1jLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHJiYiSU1HIj09bXhFdmVudC5nZXRTb3VyY2UoYikubm9kZU5hbWUpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pc0xhYmVsRXZlbnQoYSxiKSYmYy5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChiLGYoYikpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuaXNMYWJlbEV2ZW50KGEsYikmJihjLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsbmV3IG14TW91c2VFdmVudChiLGYoYikpKSxlPSExKX0pKTtjLm5hdGl2ZURibENsaWNrRW5hYmxlZCYmbXhFdmVudC5hZGRMaXN0ZW5lcihhLnRleHQubm9kZSwiZGJsY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuaXNMYWJlbEV2ZW50KGEsCmIpJiYoYy5kYmxDbGljayhiLGEuY2VsbCksbXhFdmVudC5jb25zdW1lKGIpKX0pKX19O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplTGFiZWw9ZnVuY3Rpb24oYSxiKXtteENsaWVudC5JU19TVkcmJm14Q2xpZW50Lk5PX0ZPJiZiLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP2IuaW5pdChhLnZpZXcuZ3JhcGguY29udGFpbmVyKTpiLmluaXQoYS52aWV3LmdldERyYXdQYW5lKCkpfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNlbGxPdmVybGF5cz1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGguZ2V0Q2VsbE92ZXJsYXlzKGEuY2VsbCksYz1udWxsO2lmKG51bGwhPWIpZm9yKHZhciBjPW5ldyBteERpY3Rpb25hcnksZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1udWxsIT1hLm92ZXJsYXlzP2Eub3ZlcmxheXMucmVtb3ZlKGJbZF0pOm51bGw7bnVsbD09ZSYmKGU9bmV3IG14SW1hZ2VTaGFwZShuZXcgbXhSZWN0YW5nbGUsYltkXS5pbWFnZS5zcmMpLGUuZGlhbGVjdD1hLnZpZXcuZ3JhcGguZGlhbGVjdCxlLnByZXNlcnZlSW1hZ2VBc3BlY3Q9ITEsZS5vdmVybGF5PWJbZF0sdGhpcy5pbml0aWFsaXplT3ZlcmxheShhLGUpLHRoaXMuaW5zdGFsbENlbGxPdmVybGF5TGlzdGVuZXJzKGEsYltkXSxlKSxudWxsIT1iW2RdLmN1cnNvciYmKGUubm9kZS5zdHlsZS5jdXJzb3I9YltkXS5jdXJzb3IpKTtjLnB1dChiW2RdLGUpfW51bGwhPWEub3ZlcmxheXMmJgphLm92ZXJsYXlzLnZpc2l0KGZ1bmN0aW9uKGEsYil7Yi5kZXN0cm95KCl9KTthLm92ZXJsYXlzPWN9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplT3ZlcmxheT1mdW5jdGlvbihhLGIpe2IuaW5pdChhLnZpZXcuZ2V0T3ZlcmxheVBhbmUoKSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5zdGFsbENlbGxPdmVybGF5TGlzdGVuZXJzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnZpZXcuZ3JhcGg7bXhFdmVudC5hZGRMaXN0ZW5lcihjLm5vZGUsImNsaWNrIixmdW5jdGlvbihjKXtkLmlzRWRpdGluZygpJiZkLnN0b3BFZGl0aW5nKCFkLmlzSW52b2tlc1N0b3BDZWxsRWRpdGluZygpKTtiLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNMSUNLLCJldmVudCIsYywiY2VsbCIsYS5jZWxsKSl9KTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYy5ub2RlLGZ1bmN0aW9uKGEpe214RXZlbnQuY29uc3VtZShhKX0sZnVuY3Rpb24oYil7ZC5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChiLGEpKX0pO214Q2xpZW50LklTX1RPVUNIJiZteEV2ZW50LmFkZExpc3RlbmVyKGMubm9kZSwidG91Y2hlbmQiLGZ1bmN0aW9uKGMpe2IuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0xJQ0ssCiJldmVudCIsYywiY2VsbCIsYS5jZWxsKSl9KX07bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbnRyb2w9ZnVuY3Rpb24oYSl7dmFyIGI9YS52aWV3LmdyYXBoLGM9Yi5nZXRGb2xkaW5nSW1hZ2UoYSk7aWYoYi5mb2xkaW5nRW5hYmxlZCYmbnVsbCE9Yyl7aWYobnVsbD09YS5jb250cm9sKXt2YXIgZD1uZXcgbXhSZWN0YW5nbGUoMCwwLGMud2lkdGgsYy5oZWlnaHQpO2EuY29udHJvbD1uZXcgbXhJbWFnZVNoYXBlKGQsYy5zcmMpO2EuY29udHJvbC5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExO2EuY29udHJvbC5kaWFsZWN0PWIuZGlhbGVjdDt0aGlzLmluaXRDb250cm9sKGEsYS5jb250cm9sLCEwLHRoaXMuY3JlYXRlQ29udHJvbENsaWNrSGFuZGxlcihhKSl9fWVsc2UgbnVsbCE9YS5jb250cm9sJiYoYS5jb250cm9sLmRlc3Ryb3koKSxhLmNvbnRyb2w9bnVsbCl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29udHJvbENsaWNrSGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGg7cmV0dXJuIG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpe2lmKHRoaXMuZm9yY2VDb250cm9sQ2xpY2tIYW5kbGVyfHxiLmlzRW5hYmxlZCgpKXt2YXIgZD0hYi5pc0NlbGxDb2xsYXBzZWQoYS5jZWxsKTtiLmZvbGRDZWxscyhkLCExLFthLmNlbGxdLG51bGwsYyk7bXhFdmVudC5jb25zdW1lKGMpfX0pfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmluaXRDb250cm9sPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEudmlldy5ncmFwaDtlLmlzSHRtbExhYmVsKGEuY2VsbCkmJm14Q2xpZW50Lk5PX0ZPJiZlLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHPyhiLmRpYWxlY3Q9bXhDb25zdGFudHMuRElBTEVDVF9QUkVGRVJIVE1MLGIuaW5pdChlLmNvbnRhaW5lciksYi5ub2RlLnN0eWxlLnpJbmRleD0xKTpiLmluaXQoYS52aWV3LmdldE92ZXJsYXlQYW5lKCkpO2I9Yi5pbm5lck5vZGV8fGIubm9kZTtudWxsPT1kfHxteENsaWVudC5JU19JT1N8fChlLmlzRW5hYmxlZCgpJiYoYi5zdHlsZS5jdXJzb3I9InBvaW50ZXIiKSxteEV2ZW50LmFkZExpc3RlbmVyKGIsImNsaWNrIixkKSk7aWYoYyl7dmFyIGY9bnVsbDtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYixmdW5jdGlvbihiKXtmPW5ldyBteFBvaW50KG14RXZlbnQuZ2V0Q2xpZW50WChiKSxteEV2ZW50LmdldENsaWVudFkoYikpOwplLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGIsYSkpO214RXZlbnQuY29uc3VtZShiKX0sZnVuY3Rpb24oYil7ZS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChiLGEpKX0sZnVuY3Rpb24oYil7ZS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoYixhKSk7bXhFdmVudC5jb25zdW1lKGIpfSk7bnVsbCE9ZCYmbXhDbGllbnQuSVNfSU9TJiZiLmFkZEV2ZW50TGlzdGVuZXIoInRvdWNoZW5kIixmdW5jdGlvbihhKXtpZihudWxsIT1mKXt2YXIgYj1lLnRvbGVyYW5jZTtNYXRoLmFicyhmLngtbXhFdmVudC5nZXRDbGllbnRYKGEpKTxiJiZNYXRoLmFicyhmLnktbXhFdmVudC5nZXRDbGllbnRZKGEpKTxiJiYoZC5jYWxsKGQsYSksbXhFdmVudC5jb25zdW1lKGEpKX19LCEwKX1yZXR1cm4gYn07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pc1NoYXBlRXZlbnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hMH07bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzTGFiZWxFdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiEwfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmluc3RhbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oYSl7dmFyIGI9YS52aWV3LmdyYXBoLGM9ZnVuY3Rpb24oYyl7dmFyIGQ9YTtpZihiLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHJiYiSU1HIj09bXhFdmVudC5nZXRTb3VyY2UoYykubm9kZU5hbWV8fG14Q2xpZW50LklTX1RPVUNIKWQ9bXhFdmVudC5nZXRDbGllbnRYKGMpLGM9bXhFdmVudC5nZXRDbGllbnRZKGMpLGM9bXhVdGlscy5jb252ZXJ0UG9pbnQoYi5jb250YWluZXIsZCxjKSxkPWIudmlldy5nZXRTdGF0ZShiLmdldENlbGxBdChjLngsYy55KSk7cmV0dXJuIGR9O214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhhLnNoYXBlLm5vZGUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7dGhpcy5pc1NoYXBlRXZlbnQoYSxjKSYmYi5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sbmV3IG14TW91c2VFdmVudChjLGEpKX0pLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihkKXt0aGlzLmlzU2hhcGVFdmVudChhLGQpJiZiLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGQsYyhkKSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZCl7dGhpcy5pc1NoYXBlRXZlbnQoYSxkKSYmYi5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoZCxjKGQpKSl9KSk7Yi5uYXRpdmVEYmxDbGlja0VuYWJsZWQmJm14RXZlbnQuYWRkTGlzdGVuZXIoYS5zaGFwZS5ub2RlLCJkYmxjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7dGhpcy5pc1NoYXBlRXZlbnQoYSxjKSYmKGIuZGJsQ2xpY2soYyxhLmNlbGwpLG14RXZlbnQuY29uc3VtZShjKSl9KSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3TGFiZWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnZpZXcuZ3JhcGgsZD10aGlzLmdldExhYmVsVmFsdWUoYSksZT1jLmlzV3JhcHBpbmcoYS5jZWxsKSxmPWMuaXNMYWJlbENsaXBwZWQoYS5jZWxsKSxnPWEudmlldy5ncmFwaC5pc0h0bWxMYWJlbChhLmNlbGwpfHxudWxsIT1kJiZteFV0aWxzLmlzTm9kZShkKT9teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUw6YS52aWV3LmdyYXBoLmRpYWxlY3Qsaz1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX09WRVJGTE9XXXx8InZpc2libGUiO251bGw9PWEudGV4dHx8YS50ZXh0LndyYXA9PWUmJmEudGV4dC5jbGlwcGVkPT1mJiZhLnRleHQub3ZlcmZsb3c9PWsmJmEudGV4dC5kaWFsZWN0PT1nfHwoYS50ZXh0LmRlc3Ryb3koKSxhLnRleHQ9bnVsbCk7bnVsbD09YS50ZXh0JiZudWxsIT1kJiYobXhVdGlscy5pc05vZGUoZCl8fDA8ZC5sZW5ndGgpP3RoaXMuY3JlYXRlTGFiZWwoYSwKZCk6bnVsbD09YS50ZXh0fHxudWxsIT1kJiYwIT1kLmxlbmd0aHx8KGEudGV4dC5kZXN0cm95KCksYS50ZXh0PW51bGwpO2lmKG51bGwhPWEudGV4dCl7YiYmKG51bGwhPWEudGV4dC5sYXN0VmFsdWUmJnRoaXMuaXNUZXh0U2hhcGVJbnZhbGlkKGEsYS50ZXh0KSYmKGEudGV4dC5sYXN0VmFsdWU9bnVsbCksYS50ZXh0LnJlc2V0U3R5bGVzKCksYS50ZXh0LmFwcGx5KGEpLGEudGV4dC52YWxpZ249Yy5nZXRWZXJ0aWNhbEFsaWduKGEpKTt2YXIgYz10aGlzLmdldExhYmVsQm91bmRzKGEpLGw9dGhpcy5nZXRUZXh0U2NhbGUoYSk7dGhpcy5yZXNvbHZlQ29sb3IoYSwiY29sb3IiLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUik7aWYoYnx8YS50ZXh0LnZhbHVlIT1kfHxhLnRleHQuaXNXcmFwcGluZyE9ZXx8YS50ZXh0Lm92ZXJmbG93IT1rfHxhLnRleHQuaXNDbGlwcGluZyE9Znx8YS50ZXh0LnNjYWxlIT1sfHxhLnRleHQuZGlhbGVjdCE9Z3x8bnVsbD09YS50ZXh0LmJvdW5kc3x8CiFhLnRleHQuYm91bmRzLmVxdWFscyhjKSlhLnRleHQuZGlhbGVjdD1nLGEudGV4dC52YWx1ZT1kLGEudGV4dC5ib3VuZHM9YyxhLnRleHQuc2NhbGU9bCxhLnRleHQud3JhcD1lLGEudGV4dC5jbGlwcGVkPWYsYS50ZXh0Lm92ZXJmbG93PWssZD1hLnRleHQubm9kZS5zdHlsZS52aXNpYmlsaXR5LHRoaXMucmVkcmF3TGFiZWxTaGFwZShhLnRleHQpLGEudGV4dC5ub2RlLnN0eWxlLnZpc2liaWxpdHk9ZH19OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaXNUZXh0U2hhcGVJbnZhbGlkPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhjLGUsZil7cmV0dXJuInNwYWNpbmdUb3AiPT1lfHwic3BhY2luZ1JpZ2h0Ij09ZXx8InNwYWNpbmdCb3R0b20iPT1lfHwic3BhY2luZ0xlZnQiPT1lP3BhcnNlRmxvYXQoYltjXSktcGFyc2VGbG9hdChiLnNwYWNpbmcpIT0oYS5zdHlsZVtlXXx8Zik6YltjXSE9KGEuc3R5bGVbZV18fGYpfXJldHVybiBjKCJmb250U3R5bGUiLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTVFlMRSl8fGMoImZhbWlseSIsbXhDb25zdGFudHMuU1RZTEVfRk9OVEZBTUlMWSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFkpfHxjKCJzaXplIixteENvbnN0YW50cy5TVFlMRV9GT05UU0laRSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFKXx8YygiY29sb3IiLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUiwiYmxhY2siKXx8CmMoImFsaWduIixteENvbnN0YW50cy5TVFlMRV9BTElHTiwiIil8fGMoInZhbGlnbiIsbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR04sIiIpfHxjKCJzcGFjaW5nIixteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HLDIpfHxjKCJzcGFjaW5nVG9wIixteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX1RPUCwwKXx8Yygic3BhY2luZ1JpZ2h0IixteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX1JJR0hULDApfHxjKCJzcGFjaW5nQm90dG9tIixteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HX0JPVFRPTSwwKXx8Yygic3BhY2luZ0xlZnQiLG14Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfTEVGVCwwKXx8YygiaG9yaXpvbnRhbCIsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwhMCl8fGMoImJhY2tncm91bmQiLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JBQ0tHUk9VTkRDT0xPUil8fGMoImJvcmRlciIsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfQk9SREVSQ09MT1IpfHxjKCJvcGFjaXR5IiwKbXhDb25zdGFudHMuU1RZTEVfVEVYVF9PUEFDSVRZLDEwMCl8fGMoInRleHREaXJlY3Rpb24iLG14Q29uc3RhbnRzLlNUWUxFX1RFWFRfRElSRUNUSU9OLG14Q29uc3RhbnRzLkRFRkFVTFRfVEVYVF9ESVJFQ1RJT04pfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3TGFiZWxTaGFwZT1mdW5jdGlvbihhKXthLnJlZHJhdygpfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGV4dFNjYWxlPWZ1bmN0aW9uKGEpe3JldHVybiBhLnZpZXcuc2NhbGV9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9YS52aWV3LmdyYXBoLGM9YS52aWV3LnNjYWxlLGQ9Yi5nZXRNb2RlbCgpLmlzRWRnZShhLmNlbGwpLGU9bmV3IG14UmVjdGFuZ2xlKGEuYWJzb2x1dGVPZmZzZXQueCxhLmFic29sdXRlT2Zmc2V0LnkpO2lmKGQpe3ZhciBmPWEudGV4dC5nZXRTcGFjaW5nKCk7ZS54Kz1mLngqYztlLnkrPWYueSpjO2I9Yi5nZXRDZWxsR2VvbWV0cnkoYS5jZWxsKTtudWxsIT1iJiYoZS53aWR0aD1NYXRoLm1heCgwLGIud2lkdGgqYyksZS5oZWlnaHQ9TWF0aC5tYXgoMCxiLmhlaWdodCpjKSl9ZWxzZSBhLnRleHQuaXNQYWludEJvdW5kc0ludmVydGVkKCkmJihiPWUueCxlLng9ZS55LGUueT1iKSxlLngrPWEueCxlLnkrPWEueSxlLndpZHRoPU1hdGgubWF4KDEsYS53aWR0aCksZS5oZWlnaHQ9TWF0aC5tYXgoMSxhLmhlaWdodCk7YS50ZXh0LmlzUGFpbnRCb3VuZHNJbnZlcnRlZCgpJiYoYj0oYS53aWR0aC0KYS5oZWlnaHQpLzIsZS54Kz1iLGUueS09YixiPWUud2lkdGgsZS53aWR0aD1lLmhlaWdodCxlLmhlaWdodD1iKTtudWxsIT1hLnNoYXBlJiYoYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKSxmPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9NSURETEUpLGI9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiYmZj09bXhDb25zdGFudHMuQUxJR05fTUlERExFJiYoZT1hLnNoYXBlLmdldExhYmVsQm91bmRzKGUpKSk7Yj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfV0lEVEgsbnVsbCk7bnVsbCE9YiYmKGUud2lkdGg9cGFyc2VGbG9hdChiKSpjKTtkfHx0aGlzLnJvdGF0ZUxhYmVsQm91bmRzKGEsZSk7cmV0dXJuIGV9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUucm90YXRlTGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSxiKXtiLnktPWEudGV4dC5tYXJnaW4ueSpiLmhlaWdodDtiLngtPWEudGV4dC5tYXJnaW4ueCpiLndpZHRoO2lmKCF0aGlzLmxlZ2FjeVNwYWNpbmd8fCJmaWxsIiE9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV10mJiJ3aWR0aCIhPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfT1ZFUkZMT1ddKXt2YXIgYz1hLnZpZXcuc2NhbGUsZD1hLnRleHQuZ2V0U3BhY2luZygpO2IueCs9ZC54KmM7Yi55Kz1kLnkqYzt2YXIgZD1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKSxlPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9NSURETEUpLGY9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9MQUJFTF9XSURUSCxudWxsKTtiLndpZHRoPU1hdGgubWF4KDAsYi53aWR0aC0oZD09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSJiZudWxsPT1mP2EudGV4dC5zcGFjaW5nTGVmdCpjK2EudGV4dC5zcGFjaW5nUmlnaHQqYzowKSk7Yi5oZWlnaHQ9TWF0aC5tYXgoMCxiLmhlaWdodC0oZT09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2EudGV4dC5zcGFjaW5nVG9wKmMrYS50ZXh0LnNwYWNpbmdCb3R0b20qYzowKSl9ZT1hLnRleHQuZ2V0VGV4dFJvdGF0aW9uKCk7MCE9ZSYmbnVsbCE9YSYmYS52aWV3LmdyYXBoLm1vZGVsLmlzVmVydGV4KGEuY2VsbCkmJihjPWEuZ2V0Q2VudGVyWCgpLGQ9YS5nZXRDZW50ZXJZKCksYi54IT1jfHxiLnkhPWQpJiYoZSo9TWF0aC5QSS8xODAsYz1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChiLngsYi55KSxNYXRoLmNvcyhlKSxNYXRoLnNpbihlKSxuZXcgbXhQb2ludChjLGQpKSxiLng9Yy54LGIueT0KYy55KX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXdDZWxsT3ZlcmxheXM9ZnVuY3Rpb24oYSxiKXt0aGlzLmNyZWF0ZUNlbGxPdmVybGF5cyhhKTtpZihudWxsIT1hLm92ZXJsYXlzKXt2YXIgYz1teFV0aWxzLm1vZChteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCksOTApLGQ9bXhVdGlscy50b1JhZGlhbnMoYyksZT1NYXRoLmNvcyhkKSxmPU1hdGguc2luKGQpO2Eub3ZlcmxheXMudmlzaXQoZnVuY3Rpb24oZCxrKXt2YXIgZz1rLm92ZXJsYXkuZ2V0Qm91bmRzKGEpO2lmKCFhLnZpZXcuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSYmbnVsbCE9YS5zaGFwZSYmMCE9Yyl7dmFyIG09Zy5nZXRDZW50ZXJYKCksbj1nLmdldENlbnRlclkoKSxuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KG0sbiksZSxmLG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEuZ2V0Q2VudGVyWSgpKSksbT1uLngsbj1uLnk7Zy54PQpNYXRoLnJvdW5kKG0tZy53aWR0aC8yKTtnLnk9TWF0aC5yb3VuZChuLWcuaGVpZ2h0LzIpfWlmKGJ8fG51bGw9PWsuYm91bmRzfHxrLnNjYWxlIT1hLnZpZXcuc2NhbGV8fCFrLmJvdW5kcy5lcXVhbHMoZykpay5ib3VuZHM9ZyxrLnNjYWxlPWEudmlldy5zY2FsZSxrLnJlZHJhdygpfSl9fTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLnJlZHJhd0NvbnRyb2w9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnZpZXcuZ3JhcGguZ2V0Rm9sZGluZ0ltYWdlKGEpO2lmKG51bGwhPWEuY29udHJvbCYmbnVsbCE9Yyl7dmFyIGM9dGhpcy5nZXRDb250cm9sQm91bmRzKGEsYy53aWR0aCxjLmhlaWdodCksZD10aGlzLmxlZ2FjeUNvbnRyb2xQb3NpdGlvbj9teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCk6YS5zaGFwZS5nZXRUZXh0Um90YXRpb24oKSxlPWEudmlldy5zY2FsZTtpZihifHxhLmNvbnRyb2wuc2NhbGUhPWV8fCFhLmNvbnRyb2wuYm91bmRzLmVxdWFscyhjKXx8YS5jb250cm9sLnJvdGF0aW9uIT1kKWEuY29udHJvbC5yb3RhdGlvbj1kLGEuY29udHJvbC5ib3VuZHM9YyxhLmNvbnRyb2wuc2NhbGU9ZSxhLmNvbnRyb2wucmVkcmF3KCl9fTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmdldENvbnRyb2xCb3VuZHM9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWEuY29udHJvbCl7dmFyIGQ9YS52aWV3LnNjYWxlLGU9YS5nZXRDZW50ZXJYKCksZj1hLmdldENlbnRlclkoKTtpZighYS52aWV3LmdyYXBoLmdldE1vZGVsKCkuaXNFZGdlKGEuY2VsbCkmJihlPWEueCtiKmQsZj1hLnkrYypkLG51bGwhPWEuc2hhcGUpKXt2YXIgZz1hLnNoYXBlLmdldFNoYXBlUm90YXRpb24oKTtpZih0aGlzLmxlZ2FjeUNvbnRyb2xQb3NpdGlvbilnPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTiwwKTtlbHNlIGlmKGEuc2hhcGUuaXNQYWludEJvdW5kc0ludmVydGVkKCkpdmFyIGs9KGEud2lkdGgtYS5oZWlnaHQpLzIsZT1lK2ssZj1mLWs7MCE9ZyYmKGs9bXhVdGlscy50b1JhZGlhbnMoZyksZz1NYXRoLmNvcyhrKSxrPU1hdGguc2luKGspLGY9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoZSwKZiksZyxrLG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEuZ2V0Q2VudGVyWSgpKSksZT1mLngsZj1mLnkpfXJldHVybiBhLnZpZXcuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSxuZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChlLWIvMipkKSxNYXRoLnJvdW5kKGYtYy8yKmQpLE1hdGgucm91bmQoYipkKSxNYXRoLnJvdW5kKGMqZCkpfXJldHVybiBudWxsfTsKbXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmluc2VydFN0YXRlQWZ0ZXI9ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD10aGlzLmdldFNoYXBlc0ZvclN0YXRlKGEpLGU9MDtlPGQubGVuZ3RoO2UrKylpZihudWxsIT1kW2VdJiZudWxsIT1kW2VdLm5vZGUpe3ZhciBmPWRbZV0ubm9kZS5wYXJlbnROb2RlIT1hLnZpZXcuZ2V0RHJhd1BhbmUoKSYmZFtlXS5ub2RlLnBhcmVudE5vZGUhPWEudmlldy5nZXRPdmVybGF5UGFuZSgpLGc9Zj9jOmI7aWYobnVsbCE9ZyYmZy5uZXh0U2libGluZyE9ZFtlXS5ub2RlKW51bGw9PWcubmV4dFNpYmxpbmc/Zy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRbZV0ubm9kZSk6Zy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkW2VdLm5vZGUsZy5uZXh0U2libGluZyk7ZWxzZSBpZihudWxsPT1nKWlmKGRbZV0ubm9kZS5wYXJlbnROb2RlPT1hLnZpZXcuZ3JhcGguY29udGFpbmVyKXtmb3IoZz1hLnZpZXcuY2FudmFzO251bGwhPWcmJmcucGFyZW50Tm9kZSE9CmEudmlldy5ncmFwaC5jb250YWluZXI7KWc9Zy5wYXJlbnROb2RlO251bGwhPWcmJm51bGwhPWcubmV4dFNpYmxpbmc/Zy5uZXh0U2libGluZyE9ZFtlXS5ub2RlJiZkW2VdLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZFtlXS5ub2RlLGcubmV4dFNpYmxpbmcpOmRbZV0ubm9kZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRbZV0ubm9kZSl9ZWxzZSBudWxsIT1kW2VdLm5vZGUucGFyZW50Tm9kZSYmbnVsbCE9ZFtlXS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCYmZFtlXS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCE9ZFtlXS5ub2RlJiZkW2VdLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZFtlXS5ub2RlLGRbZV0ubm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO2Y/Yz1kW2VdLm5vZGU6Yj1kW2VdLm5vZGV9cmV0dXJuW2IsY119OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2hhcGVzRm9yU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuW2Euc2hhcGUsYS50ZXh0LGEuY29udHJvbF19O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5yZWRyYXdTaGFwZShhLGIsYyk7bnVsbD09YS5zaGFwZXx8bnVsbCE9YyYmIWN8fCh0aGlzLnJlZHJhd0xhYmVsKGEsYiksdGhpcy5yZWRyYXdDZWxsT3ZlcmxheXMoYSxiKSx0aGlzLnJlZHJhd0NvbnRyb2woYSxiKSl9OwpteENlbGxSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3U2hhcGU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEudmlldy5ncmFwaC5tb2RlbCxlPSExO251bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3R5bGUmJm51bGwhPWEuc3R5bGUmJmEuc2hhcGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdIT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXSYmKGEuc2hhcGUuZGVzdHJveSgpLGEuc2hhcGU9bnVsbCk7bnVsbD09YS5zaGFwZSYmbnVsbCE9YS52aWV3LmdyYXBoLmNvbnRhaW5lciYmYS5jZWxsIT1hLnZpZXcuY3VycmVudFJvb3QmJihkLmlzVmVydGV4KGEuY2VsbCl8fGQuaXNFZGdlKGEuY2VsbCkpPyhhLnNoYXBlPXRoaXMuY3JlYXRlU2hhcGUoYSksbnVsbCE9YS5zaGFwZSYmKGEuc2hhcGUubWluU3ZnU3Ryb2tlV2lkdGg9dGhpcy5taW5TdmdTdHJva2VXaWR0aCxhLnNoYXBlLmFudGlBbGlhcz10aGlzLmFudGlBbGlhcyx0aGlzLmNyZWF0ZUluZGljYXRvclNoYXBlKGEpLAp0aGlzLmluaXRpYWxpemVTaGFwZShhKSx0aGlzLmNyZWF0ZUNlbGxPdmVybGF5cyhhKSx0aGlzLmluc3RhbGxMaXN0ZW5lcnMoYSksYS52aWV3LmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci51cGRhdGVIYW5kbGVyKGEpKSk6Ynx8bnVsbD09YS5zaGFwZXx8bXhVdGlscy5lcXVhbEVudHJpZXMoYS5zaGFwZS5zdHlsZSxhLnN0eWxlKSYmIXRoaXMuY2hlY2tQbGFjZWhvbGRlclN0eWxlcyhhKXx8KGEuc2hhcGUucmVzZXRTdHlsZXMoKSx0aGlzLmNvbmZpZ3VyZVNoYXBlKGEpLGEudmlldy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIudXBkYXRlSGFuZGxlcihhKSxiPSEwKTtudWxsIT1hLnNoYXBlJiZhLnNoYXBlLmluZGljYXRvclNoYXBlIT10aGlzLmdldFNoYXBlKGEudmlldy5ncmFwaC5nZXRJbmRpY2F0b3JTaGFwZShhKSkmJihudWxsIT1hLnNoYXBlLmluZGljYXRvciYmKGEuc2hhcGUuaW5kaWNhdG9yLmRlc3Ryb3koKSxhLnNoYXBlLmluZGljYXRvcj1udWxsKSx0aGlzLmNyZWF0ZUluZGljYXRvclNoYXBlKGEpLApudWxsIT1hLnNoYXBlLmluZGljYXRvclNoYXBlJiYoYS5zaGFwZS5pbmRpY2F0b3I9bmV3IGEuc2hhcGUuaW5kaWNhdG9yU2hhcGUsYS5zaGFwZS5pbmRpY2F0b3IuZGlhbGVjdD1hLnNoYXBlLmRpYWxlY3QsYS5zaGFwZS5pbmRpY2F0b3IuaW5pdChhLm5vZGUpLGI9ITApKTtudWxsIT1hLnNoYXBlJiYodGhpcy5jcmVhdGVDb250cm9sKGEpLGJ8fHRoaXMuaXNTaGFwZUludmFsaWQoYSxhLnNoYXBlKSkmJihudWxsIT1hLmFic29sdXRlUG9pbnRzPyhhLnNoYXBlLnBvaW50cz1hLmFic29sdXRlUG9pbnRzLnNsaWNlKCksYS5zaGFwZS5ib3VuZHM9bnVsbCk6KGEuc2hhcGUucG9pbnRzPW51bGwsYS5zaGFwZS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksYS53aWR0aCxhLmhlaWdodCkpLGEuc2hhcGUuc2NhbGU9YS52aWV3LnNjYWxlLG51bGw9PWN8fGM/dGhpcy5kb1JlZHJhd1NoYXBlKGEpOmEuc2hhcGUudXBkYXRlQm91bmRpbmdCb3goKSxlPSEwKTtyZXR1cm4gZX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5kb1JlZHJhd1NoYXBlPWZ1bmN0aW9uKGEpe2Euc2hhcGUucmVkcmF3KCl9O214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pc1NoYXBlSW52YWxpZD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1iLmJvdW5kc3x8Yi5zY2FsZSE9YS52aWV3LnNjYWxlfHxudWxsPT1hLmFic29sdXRlUG9pbnRzJiYhYi5ib3VuZHMuZXF1YWxzKGEpfHxudWxsIT1hLmFic29sdXRlUG9pbnRzJiYhbXhVdGlscy5lcXVhbFBvaW50cyhiLnBvaW50cyxhLmFic29sdXRlUG9pbnRzKX07Cm14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKGEpe251bGwhPWEuc2hhcGUmJihudWxsIT1hLnRleHQmJihhLnRleHQuZGVzdHJveSgpLGEudGV4dD1udWxsKSxudWxsIT1hLm92ZXJsYXlzJiYoYS5vdmVybGF5cy52aXNpdChmdW5jdGlvbihhLGMpe2MuZGVzdHJveSgpfSksYS5vdmVybGF5cz1udWxsKSxudWxsIT1hLmNvbnRyb2wmJihhLmNvbnRyb2wuZGVzdHJveSgpLGEuY29udHJvbD1udWxsKSxhLnNoYXBlLmRlc3Ryb3koKSxhLnNoYXBlPW51bGwpfTsKdmFyIG14RWRnZVN0eWxlPXtFbnRpdHlSZWxhdGlvbjpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEudmlldyxnPWYuZ3JhcGg7ZD1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU0VHTUVOVCxteENvbnN0YW50cy5FTlRJVFlfU0VHTUVOVCkqZi5zY2FsZTt2YXIgaz1hLmFic29sdXRlUG9pbnRzLGw9a1swXSxtPWtbay5sZW5ndGgtMV0saz0hMTtpZihudWxsIT1sKWI9bmV3IG14Q2VsbFN0YXRlLGIueD1sLngsYi55PWwueTtlbHNlIGlmKG51bGwhPWIpe3ZhciBuPW14VXRpbHMuZ2V0UG9ydENvbnN0cmFpbnRzKGIsYSwhMCxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT05FKTtuIT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT05FJiZuIT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUK214Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q/az1uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUOihsPWcuZ2V0Q2VsbEdlb21ldHJ5KGIuY2VsbCksCmwucmVsYXRpdmU/az0uNT49bC54Om51bGwhPWMmJihrPWMueCtjLndpZHRoPGIueCkpfWVsc2UgcmV0dXJuO2w9ITA7bnVsbCE9bT8oYz1uZXcgbXhDZWxsU3RhdGUsYy54PW0ueCxjLnk9bS55KTpudWxsIT1jJiYobj1teFV0aWxzLmdldFBvcnRDb25zdHJhaW50cyhjLGEsITEsbXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9ORSksbiE9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9ORSYmbiE9bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVCtteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUP2w9bj09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDooYT1nLmdldENlbGxHZW9tZXRyeShjLmNlbGwpLGEucmVsYXRpdmU/bD0uNT49YS54Om51bGwhPWImJihsPWIueCtiLndpZHRoPGMueCkpKTtudWxsIT1iJiZudWxsIT1jJiYoYT1rP2IueDpiLngrYi53aWR0aCxiPWYuZ2V0Um91dGluZ0NlbnRlclkoYiksZz1sP2MueDpjLngrYy53aWR0aCxjPWYuZ2V0Um91dGluZ0NlbnRlclkoYyksCmY9bmV3IG14UG9pbnQoYSsoaz8tZDpkKSxiKSxtPW5ldyBteFBvaW50KGcrKGw/LWQ6ZCksYyksaz09bD8oZD1rP01hdGgubWluKGEsZyktZDpNYXRoLm1heChhLGcpK2QsZS5wdXNoKG5ldyBteFBvaW50KGQsYikpLGUucHVzaChuZXcgbXhQb2ludChkLGMpKSk6KGYueDxtLng9PWs/KGQ9YisoYy1iKS8yLGUucHVzaChmKSxlLnB1c2gobmV3IG14UG9pbnQoZi54LGQpKSxlLnB1c2gobmV3IG14UG9pbnQobS54LGQpKSk6ZS5wdXNoKGYpLGUucHVzaChtKSkpfSxMb29wOmZ1bmN0aW9uKGEsYixjLGQsZSl7Yz1hLmFic29sdXRlUG9pbnRzO3ZhciBmPWNbYy5sZW5ndGgtMV07aWYobnVsbCE9Y1swXSYmbnVsbCE9Zil7aWYobnVsbCE9ZCYmMDxkLmxlbmd0aClmb3IoYj0wO2I8ZC5sZW5ndGg7YisrKWM9ZFtiXSxjPWEudmlldy50cmFuc2Zvcm1Db250cm9sUG9pbnQoYSxjKSxlLnB1c2gobmV3IG14UG9pbnQoYy54LGMueSkpfWVsc2UgaWYobnVsbCE9Yil7dmFyIGY9YS52aWV3LGc9Zi5ncmFwaDsKYz1udWxsIT1kJiYwPGQubGVuZ3RoP2RbMF06bnVsbDtudWxsIT1jJiYoYz1mLnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGMpLG14VXRpbHMuY29udGFpbnMoYixjLngsYy55KSYmKGM9bnVsbCkpO3ZhciBrPWQ9MCxsPTAsbT0wLGc9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NFR01FTlQsZy5ncmlkU2l6ZSkqZi5zY2FsZTthPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpO2E9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8YT09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhkPWYuZ2V0Um91dGluZ0NlbnRlclgoYiksaz1nKToobD1mLmdldFJvdXRpbmdDZW50ZXJZKGIpLG09Zyk7bnVsbD09Y3x8Yy54PGIueHx8Yy54PmIueCtiLndpZHRoP251bGwhPWM/KGQ9Yy54LG09TWF0aC5tYXgoTWF0aC5hYnMobC1jLnkpLG0pKTphPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/Cmw9Yi55LTIqazphPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/bD1iLnkrYi5oZWlnaHQrMiprOmQ9YT09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q/Yi54LTIqbTpiLngrYi53aWR0aCsyKm06bnVsbCE9YyYmKGQ9Zi5nZXRSb3V0aW5nQ2VudGVyWChiKSxrPU1hdGgubWF4KE1hdGguYWJzKGQtYy54KSxtKSxsPWMueSxtPTApO2UucHVzaChuZXcgbXhQb2ludChkLWssbC1tKSk7ZS5wdXNoKG5ldyBteFBvaW50KGQrayxsK20pKX19LEVsYm93Q29ubmVjdG9yOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9bnVsbCE9ZCYmMDxkLmxlbmd0aD9kWzBdOm51bGwsZz0hMSxrPSExO2lmKG51bGwhPWImJm51bGwhPWMpaWYobnVsbCE9Zil2YXIgbD1NYXRoLm1pbihiLngsYy54KSxtPU1hdGgubWF4KGIueCtiLndpZHRoLGMueCtjLndpZHRoKSxrPU1hdGgubWluKGIueSxjLnkpLG49TWF0aC5tYXgoYi55K2IuaGVpZ2h0LGMueStjLmhlaWdodCksZj1hLnZpZXcudHJhbnNmb3JtQ29udHJvbFBvaW50KGEsCmYpLGc9Zi55PGt8fGYueT5uLGs9Zi54PGx8fGYueD5tO2Vsc2UgbD1NYXRoLm1heChiLngsYy54KSxtPU1hdGgubWluKGIueCtiLndpZHRoLGMueCtjLndpZHRoKSwoZz1sPT1tKXx8KGs9TWF0aC5tYXgoYi55LGMueSksbj1NYXRoLm1pbihiLnkrYi5oZWlnaHQsYy55K2MuaGVpZ2h0KSxrPWs9PW4pO2t8fCFnJiZhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VMQk9XXSE9bXhDb25zdGFudHMuRUxCT1dfVkVSVElDQUw/bXhFZGdlU3R5bGUuU2lkZVRvU2lkZShhLGIsYyxkLGUpOm14RWRnZVN0eWxlLlRvcFRvQm90dG9tKGEsYixjLGQsZSl9LFNpZGVUb1NpZGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLnZpZXc7ZD1udWxsIT1kJiYwPGQubGVuZ3RoP2RbMF06bnVsbDt2YXIgZz1hLmFic29sdXRlUG9pbnRzLGs9Z1swXSxnPWdbZy5sZW5ndGgtMV07bnVsbCE9ZCYmKGQ9Zi50cmFuc2Zvcm1Db250cm9sUG9pbnQoYSxkKSk7bnVsbCE9ayYmKGI9bmV3IG14Q2VsbFN0YXRlLApiLng9ay54LGIueT1rLnkpO251bGwhPWcmJihjPW5ldyBteENlbGxTdGF0ZSxjLng9Zy54LGMueT1nLnkpO251bGwhPWImJm51bGwhPWMmJihhPU1hdGgubWF4KGIueCxjLngpLGs9TWF0aC5taW4oYi54K2Iud2lkdGgsYy54K2Mud2lkdGgpLGE9bnVsbCE9ZD9kLng6TWF0aC5yb3VuZChrKyhhLWspLzIpLGs9Zi5nZXRSb3V0aW5nQ2VudGVyWShiKSxmPWYuZ2V0Um91dGluZ0NlbnRlclkoYyksbnVsbCE9ZCYmKGQueT49Yi55JiZkLnk8PWIueStiLmhlaWdodCYmKGs9ZC55KSxkLnk+PWMueSYmZC55PD1jLnkrYy5oZWlnaHQmJihmPWQueSkpLG14VXRpbHMuY29udGFpbnMoYyxhLGspfHxteFV0aWxzLmNvbnRhaW5zKGIsYSxrKXx8ZS5wdXNoKG5ldyBteFBvaW50KGEsaykpLG14VXRpbHMuY29udGFpbnMoYyxhLGYpfHxteFV0aWxzLmNvbnRhaW5zKGIsYSxmKXx8ZS5wdXNoKG5ldyBteFBvaW50KGEsZikpLDE9PWUubGVuZ3RoJiYobnVsbCE9ZD9teFV0aWxzLmNvbnRhaW5zKGMsYSwKZC55KXx8bXhVdGlscy5jb250YWlucyhiLGEsZC55KXx8ZS5wdXNoKG5ldyBteFBvaW50KGEsZC55KSk6KGY9TWF0aC5tYXgoYi55LGMueSksZS5wdXNoKG5ldyBteFBvaW50KGEsZisoTWF0aC5taW4oYi55K2IuaGVpZ2h0LGMueStjLmhlaWdodCktZikvMikpKSkpfSxUb3BUb0JvdHRvbTpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEudmlldztkPW51bGwhPWQmJjA8ZC5sZW5ndGg/ZFswXTpudWxsO3ZhciBnPWEuYWJzb2x1dGVQb2ludHMsaz1nWzBdLGc9Z1tnLmxlbmd0aC0xXTtudWxsIT1kJiYoZD1mLnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGQpKTtudWxsIT1rJiYoYj1uZXcgbXhDZWxsU3RhdGUsYi54PWsueCxiLnk9ay55KTtudWxsIT1nJiYoYz1uZXcgbXhDZWxsU3RhdGUsYy54PWcueCxjLnk9Zy55KTtudWxsIT1iJiZudWxsIT1jJiYoaz1NYXRoLm1heChiLnksYy55KSxnPU1hdGgubWluKGIueStiLmhlaWdodCxjLnkrYy5oZWlnaHQpLGE9Zi5nZXRSb3V0aW5nQ2VudGVyWChiKSwKbnVsbCE9ZCYmZC54Pj1iLngmJmQueDw9Yi54K2Iud2lkdGgmJihhPWQueCksaz1udWxsIT1kP2QueTpNYXRoLnJvdW5kKGcrKGstZykvMiksbXhVdGlscy5jb250YWlucyhjLGEsayl8fG14VXRpbHMuY29udGFpbnMoYixhLGspfHxlLnB1c2gobmV3IG14UG9pbnQoYSxrKSksYT1udWxsIT1kJiZkLng+PWMueCYmZC54PD1jLngrYy53aWR0aD9kLng6Zi5nZXRSb3V0aW5nQ2VudGVyWChjKSxteFV0aWxzLmNvbnRhaW5zKGMsYSxrKXx8bXhVdGlscy5jb250YWlucyhiLGEsayl8fGUucHVzaChuZXcgbXhQb2ludChhLGspKSwxPT1lLmxlbmd0aCYmKG51bGwhPWQmJjE9PWUubGVuZ3RoP214VXRpbHMuY29udGFpbnMoYyxkLngsayl8fG14VXRpbHMuY29udGFpbnMoYixkLngsayl8fGUucHVzaChuZXcgbXhQb2ludChkLngsaykpOihmPU1hdGgubWF4KGIueCxjLngpLGUucHVzaChuZXcgbXhQb2ludChmKyhNYXRoLm1pbihiLngrYi53aWR0aCxjLngrYy53aWR0aCktZikvMixrKSkpKSl9LApTZWdtZW50Q29ubmVjdG9yOmZ1bmN0aW9uKGEsYixjLGQsZSl7ZnVuY3Rpb24gZihiKXtiLng9TWF0aC5yb3VuZChiLngqYS52aWV3LnNjYWxlKjEwKS8xMDtiLnk9TWF0aC5yb3VuZChiLnkqYS52aWV3LnNjYWxlKjEwKS8xMDtpZihudWxsPT1rfHwxPD1NYXRoLmFicyhrLngtYi54KXx8TWF0aC5hYnMoay55LWIueSk+PU1hdGgubWF4KDEsYS52aWV3LnNjYWxlKSllLnB1c2goYiksaz1iO3JldHVybiBrfXZhciBnPW14RWRnZVN0eWxlLnNjYWxlUG9pbnRBcnJheShhLmFic29sdXRlUG9pbnRzLGEudmlldy5zY2FsZSk7Yj1teEVkZ2VTdHlsZS5zY2FsZUNlbGxTdGF0ZShiLGEudmlldy5zY2FsZSk7Yz1teEVkZ2VTdHlsZS5zY2FsZUNlbGxTdGF0ZShjLGEudmlldy5zY2FsZSk7dmFyIGs9MDxlLmxlbmd0aD9lWzBdOm51bGwsbD0hMCxtPW51bGwsbj1nWzBdO251bGw9PW4mJm51bGwhPWI/bj1uZXcgbXhQb2ludChhLnZpZXcuZ2V0Um91dGluZ0NlbnRlclgoYiksYS52aWV3LmdldFJvdXRpbmdDZW50ZXJZKGIpKToKbnVsbCE9biYmKG49bi5jbG9uZSgpKTt2YXIgcD1nLmxlbmd0aC0xO2lmKG51bGwhPWQmJjA8ZC5sZW5ndGgpe2Zvcih2YXIgcT1bXSxyPTA7cjxkLmxlbmd0aDtyKyspe3ZhciB0PWEudmlldy50cmFuc2Zvcm1Db250cm9sUG9pbnQoYSxkW3JdLCEwKTtudWxsIT10JiZxLnB1c2godCl9aWYoMD09cS5sZW5ndGgpcmV0dXJuO251bGwhPW4mJm51bGwhPXFbMF0mJigxPk1hdGguYWJzKHFbMF0ueC1uLngpJiYocVswXS54PW4ueCksMT5NYXRoLmFicyhxWzBdLnktbi55KSYmKHFbMF0ueT1uLnkpKTt0PWdbcF07bnVsbCE9dCYmbnVsbCE9cVtxLmxlbmd0aC0xXSYmKDE+TWF0aC5hYnMocVtxLmxlbmd0aC0xXS54LXQueCkmJihxW3EubGVuZ3RoLTFdLng9dC54KSwxPk1hdGguYWJzKHFbcS5sZW5ndGgtMV0ueS10LnkpJiYocVtxLmxlbmd0aC0xXS55PXQueSkpO3ZhciBtPXFbMF0sdT1iO2Q9Z1swXTt2YXIgeD0hMSx5PSExLHg9bTtudWxsIT1kJiYodT1udWxsKTtmb3Iocj0wOzI+cjtyKyspe3ZhciBCPQpudWxsIT1kJiZkLng9PXgueCxBPW51bGwhPWQmJmQueT09eC55LHo9bnVsbCE9dSYmeC55Pj11LnkmJngueTw9dS55K3UuaGVpZ2h0LHU9bnVsbCE9dSYmeC54Pj11LngmJngueDw9dS54K3Uud2lkdGgseD1BfHxudWxsPT1kJiZ6LHk9Qnx8bnVsbD09ZCYmdTtpZigwIT1yfHwhKHgmJnl8fEImJkEpKXtpZihudWxsIT1kJiYhQSYmIUImJih6fHx1KSl7bD16PyExOiEwO2JyZWFrfWlmKHl8fHgpe2w9eDsxPT1yJiYobD0wPT1xLmxlbmd0aCUyP3g6eSk7YnJlYWt9fXU9YztkPWdbcF07bnVsbCE9ZCYmKHU9bnVsbCk7eD1xW3EubGVuZ3RoLTFdO0ImJkEmJihxPXEuc2xpY2UoMSkpfWwmJihudWxsIT1nWzBdJiZnWzBdLnkhPW0ueXx8bnVsbD09Z1swXSYmbnVsbCE9YiYmKG0ueTxiLnl8fG0ueT5iLnkrYi5oZWlnaHQpKT9mKG5ldyBteFBvaW50KG4ueCxtLnkpKTohbCYmKG51bGwhPWdbMF0mJmdbMF0ueCE9bS54fHxudWxsPT1nWzBdJiZudWxsIT1iJiYobS54PGIueHx8bS54PmIueCsKYi53aWR0aCkpJiZmKG5ldyBteFBvaW50KG0ueCxuLnkpKTtsP24ueT1tLnk6bi54PW0ueDtmb3Iocj0wO3I8cS5sZW5ndGg7cisrKWw9IWwsbT1xW3JdLGw/bi55PW0ueTpuLng9bS54LGYobi5jbG9uZSgpKX1lbHNlIG09bixsPSEwO249Z1twXTtudWxsPT1uJiZudWxsIT1jJiYobj1uZXcgbXhQb2ludChhLnZpZXcuZ2V0Um91dGluZ0NlbnRlclgoYyksYS52aWV3LmdldFJvdXRpbmdDZW50ZXJZKGMpKSk7bnVsbCE9biYmbnVsbCE9bSYmKGwmJihudWxsIT1nW3BdJiZnW3BdLnkhPW0ueXx8bnVsbD09Z1twXSYmbnVsbCE9YyYmKG0ueTxjLnl8fG0ueT5jLnkrYy5oZWlnaHQpKT9mKG5ldyBteFBvaW50KG4ueCxtLnkpKTohbCYmKG51bGwhPWdbcF0mJmdbcF0ueCE9bS54fHxudWxsPT1nW3BdJiZudWxsIT1jJiYobS54PGMueHx8bS54PmMueCtjLndpZHRoKSkmJmYobmV3IG14UG9pbnQobS54LG4ueSkpKTtpZihudWxsPT1nWzBdJiZudWxsIT1iKWZvcig7MTxlLmxlbmd0aCYmbnVsbCE9CmVbMV0mJm14VXRpbHMuY29udGFpbnMoYixlWzFdLngsZVsxXS55KTspZS5zcGxpY2UoMSwxKTtpZihudWxsPT1nW3BdJiZudWxsIT1jKWZvcig7MTxlLmxlbmd0aCYmbnVsbCE9ZVtlLmxlbmd0aC0xXSYmbXhVdGlscy5jb250YWlucyhjLGVbZS5sZW5ndGgtMV0ueCxlW2UubGVuZ3RoLTFdLnkpOyllLnNwbGljZShlLmxlbmd0aC0xLDEpO251bGwhPXQmJm51bGwhPWVbZS5sZW5ndGgtMV0mJjE+PU1hdGguYWJzKHQueC1lW2UubGVuZ3RoLTFdLngpJiYxPj1NYXRoLmFicyh0LnktZVtlLmxlbmd0aC0xXS55KSYmKGUuc3BsaWNlKGUubGVuZ3RoLTEsMSksbnVsbCE9ZVtlLmxlbmd0aC0xXSYmKDE+TWF0aC5hYnMoZVtlLmxlbmd0aC0xXS54LXQueCkmJihlW2UubGVuZ3RoLTFdLng9dC54KSwxPk1hdGguYWJzKGVbZS5sZW5ndGgtMV0ueS10LnkpJiYoZVtlLmxlbmd0aC0xXS55PXQueSkpKX0sb3J0aEJ1ZmZlcjoxMCxvcnRoUG9pbnRzRmFsbGJhY2s6ITAsZGlyVmVjdG9yczpbWy0xLAowXSxbMCwtMV0sWzEsMF0sWzAsMV0sWy0xLDBdLFswLC0xXSxbMSwwXV0sd2F5UG9pbnRzMTpbWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF1dLHJvdXRlUGF0dGVybnM6W1tbNTEzLDIzMDgsMjA4MSwyNTYyXSxbNTEzLDEwOTAsNTE0LDIxODQsMjExNCwyNTYxXSxbNTEzLDEwOTAsNTE0LDI1NjQsMjE4NCwyNTYyXSxbNTEzLDIzMDgsMjU2MSwxMDkwLDUxNCwyNTY4LDIzMDhdXSxbWzUxNCwxMDU3LDUxMywyMzA4LDIwODEsMjU2Ml0sWzUxNCwyMTg0LDIxMTQsMjU2MV0sWzUxNCwyMTg0LDI1NjIsMTA1Nyw1MTMsMjU2NCwyMTg0XSxbNTE0LDEwNTcsNTEzLDI1NjgsMjMwOCwyNTYxXV0sW1sxMDkwLDUxNCwxMDU3LDUxMywyMzA4LDIwODEsMjU2Ml0sWzIxMTQsMjU2MV0sWzEwOTAsMjU2MiwxMDU3LDUxMywyNTY0LDIxODRdLFsxMDkwLDUxNCwxMDU3LDUxMywyMzA4LDI1NjEsMjU2OF1dLFtbMjA4MSwKMjU2Ml0sWzEwNTcsNTEzLDEwOTAsNTE0LDIxODQsMjExNCwyNTYxXSxbMTA1Nyw1MTMsMTA5MCw1MTQsMjE4NCwyNTYyLDI1NjRdLFsxMDU3LDI1NjEsMTA5MCw1MTQsMjU2OCwyMzA4XV1dLGlubGluZVJvdXRlUGF0dGVybnM6W1tudWxsLFsyMTE0LDI1NjhdLG51bGwsbnVsbF0sW251bGwsWzUxNCwyMDgxLDIxMTQsMjU2OF0sbnVsbCxudWxsXSxbbnVsbCxbMjExNCwyNTYxXSxudWxsLG51bGxdLFtbMjA4MSwyNTYyXSxbMTA1NywyMTE0LDI1NjhdLFsyMTg0LDI1NjJdLG51bGxdXSx2ZXJ0ZXhTZXBlcmF0aW9uczpbXSxsaW1pdHM6W1swLDAsMCwwLDAsMCwwLDAsMF0sWzAsMCwwLDAsMCwwLDAsMCwwXV0sTEVGVF9NQVNLOjMyLFRPUF9NQVNLOjY0LFJJR0hUX01BU0s6MTI4LEJPVFRPTV9NQVNLOjI1NixMRUZUOjEsVE9QOjIsUklHSFQ6NCxCT1RUT006OCxTSURFX01BU0s6NDgwLENFTlRFUl9NQVNLOjUxMixTT1VSQ0VfTUFTSzoxMDI0LFRBUkdFVF9NQVNLOjIwNDgsVkVSVEVYX01BU0s6MzA3MiwKZ2V0SmV0dHlTaXplOmZ1bmN0aW9uKGEsYil7dmFyIGM9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLGI/bXhDb25zdGFudHMuU1RZTEVfU09VUkNFX0pFVFRZX1NJWkU6bXhDb25zdGFudHMuU1RZTEVfVEFSR0VUX0pFVFRZX1NJWkUsbXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0pFVFRZX1NJWkUsbXhFZGdlU3R5bGUub3J0aEJ1ZmZlcikpOyJhdXRvIj09YyYmKG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxiP214Q29uc3RhbnRzLlNUWUxFX1NUQVJUQVJST1c6bXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1csbXhDb25zdGFudHMuTk9ORSkhPW14Q29uc3RhbnRzLk5PTkU/KGM9bXhVdGlscy5nZXROdW1iZXIoYS5zdHlsZSxiP214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRTpteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFLG14Q29uc3RhbnRzLkRFRkFVTFRfTUFSS0VSU0laRSksYz1NYXRoLm1heCgyLE1hdGguY2VpbCgoYytteEVkZ2VTdHlsZS5vcnRoQnVmZmVyKS8KbXhFZGdlU3R5bGUub3J0aEJ1ZmZlcikpKm14RWRnZVN0eWxlLm9ydGhCdWZmZXIpOmM9MipteEVkZ2VTdHlsZS5vcnRoQnVmZmVyKTtyZXR1cm4gY30sc2NhbGVQb2ludEFycmF5OmZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYobnVsbCE9YSlmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihudWxsIT1hW2RdKXt2YXIgZT1uZXcgbXhQb2ludChNYXRoLnJvdW5kKGFbZF0ueC9iKjEwKS8xMCxNYXRoLnJvdW5kKGFbZF0ueS9iKjEwKS8xMCk7Y1tkXT1lfWVsc2UgY1tkXT1udWxsO2Vsc2UgYz1udWxsO3JldHVybiBjfSxzY2FsZUNlbGxTdGF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjO251bGwhPWE/KGM9YS5jbG9uZSgpLGMuc2V0UmVjdChNYXRoLnJvdW5kKGEueC9iKjEwKS8xMCxNYXRoLnJvdW5kKGEueS9iKjEwKS8xMCxNYXRoLnJvdW5kKGEud2lkdGgvYioxMCkvMTAsTWF0aC5yb3VuZChhLmhlaWdodC9iKjEwKS8xMCkpOmM9bnVsbDtyZXR1cm4gY30sT3J0aENvbm5lY3RvcjpmdW5jdGlvbihhLApiLGMsZCxlKXt2YXIgZj1hLnZpZXcuZ3JhcGgsZz1udWxsPT1sPyExOmYuZ2V0TW9kZWwoKS5pc0VkZ2UobC5jZWxsKSxrPW51bGw9PW0/ITE6Zi5nZXRNb2RlbCgpLmlzRWRnZShtLmNlbGwpLGY9bXhFZGdlU3R5bGUuc2NhbGVQb2ludEFycmF5KGEuYWJzb2x1dGVQb2ludHMsYS52aWV3LnNjYWxlKSxsPW14RWRnZVN0eWxlLnNjYWxlQ2VsbFN0YXRlKGIsYS52aWV3LnNjYWxlKSxtPW14RWRnZVN0eWxlLnNjYWxlQ2VsbFN0YXRlKGMsYS52aWV3LnNjYWxlKSxuPWZbMF0scD1mW2YubGVuZ3RoLTFdLHE9bnVsbCE9bD9sLng6bi54LHI9bnVsbCE9bD9sLnk6bi55LHQ9bnVsbCE9bD9sLndpZHRoOjAsdT1udWxsIT1sP2wuaGVpZ2h0OjAseD1udWxsIT1tP20ueDpwLngseT1udWxsIT1tP20ueTpwLnksQj1udWxsIT1tP20ud2lkdGg6MCxBPW51bGwhPW0/bS5oZWlnaHQ6MCxmPW14RWRnZVN0eWxlLmdldEpldHR5U2l6ZShhLCEwKSx6PW14RWRnZVN0eWxlLmdldEpldHR5U2l6ZShhLCExKTsKbnVsbCE9bCYmbT09bCYmKGY9ej1NYXRoLm1heChmLHopKTt2YXIgQz16K2Ysdj0hMTtpZihudWxsIT1uJiZudWxsIT1wKXZhciB2PXAueC1uLngsRD1wLnktbi55LHY9dip2K0QqRDxDKkM7aWYodnx8bXhFZGdlU3R5bGUub3J0aFBvaW50c0ZhbGxiYWNrJiZudWxsIT1kJiYwPGQubGVuZ3RofHxnfHxrKW14RWRnZVN0eWxlLlNlZ21lbnRDb25uZWN0b3IoYSxiLGMsZCxlKTtlbHNle2M9W214Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0FMTCxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19BTExdO251bGwhPWwmJihjWzBdPW14VXRpbHMuZ2V0UG9ydENvbnN0cmFpbnRzKGwsYSwhMCxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19BTEwpLGI9bXhVdGlscy5nZXRWYWx1ZShsLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApLDAhPWImJihiPW14VXRpbHMuZ2V0Qm91bmRpbmdCb3gobmV3IG14UmVjdGFuZ2xlKHEscix0LHUpLGIpLHE9Yi54LHI9Yi55LHQ9Yi53aWR0aCwKdT1iLmhlaWdodCkpO251bGwhPW0mJihjWzFdPW14VXRpbHMuZ2V0UG9ydENvbnN0cmFpbnRzKG0sYSwhMSxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19BTEwpLGI9bXhVdGlscy5nZXRWYWx1ZShtLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApLDAhPWImJihiPW14VXRpbHMuZ2V0Qm91bmRpbmdCb3gobmV3IG14UmVjdGFuZ2xlKHgseSxCLEEpLGIpLHg9Yi54LHk9Yi55LEI9Yi53aWR0aCxBPWIuaGVpZ2h0KSk7Yj1bMCwwXTtxPVtbcSxyLHQsdV0sW3gseSxCLEFdXTt6PVtmLHpdO2Zvcih2PTA7Mj52O3YrKylteEVkZ2VTdHlsZS5saW1pdHNbdl1bMV09cVt2XVswXS16W3ZdLG14RWRnZVN0eWxlLmxpbWl0c1t2XVsyXT1xW3ZdWzFdLXpbdl0sbXhFZGdlU3R5bGUubGltaXRzW3ZdWzRdPXFbdl1bMF0rcVt2XVsyXSt6W3ZdLG14RWRnZVN0eWxlLmxpbWl0c1t2XVs4XT1xW3ZdWzFdK3Fbdl1bM10relt2XTt6PXFbMF1bMV0rcVswXVszXS8yO3I9cVsxXVsxXStxWzFdWzNdLwoyO3Y9cVswXVswXStxWzBdWzJdLzItKHFbMV1bMF0rcVsxXVsyXS8yKTtEPXotcjt6PTA7MD52P3o9MD5EPzI6MTowPj1EJiYoej0zLDA9PXYmJih6PTIpKTtyPW51bGw7bnVsbCE9bCYmKHI9bik7bD1bWy41LC41XSxbLjUsLjVdXTtmb3Iodj0wOzI+djt2KyspbnVsbCE9ciYmKGxbdl1bMF09KHIueC1xW3ZdWzBdKS9xW3ZdWzJdLDE+PU1hdGguYWJzKHIueC1xW3ZdWzBdKT9iW3ZdPW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1Q6MT49TWF0aC5hYnMoci54LXFbdl1bMF0tcVt2XVsyXSkmJihiW3ZdPW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1QpLGxbdl1bMV09KHIueS1xW3ZdWzFdKS9xW3ZdWzNdLDE+PU1hdGguYWJzKHIueS1xW3ZdWzFdKT9iW3ZdPW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PUlRIOjE+PU1hdGguYWJzKHIueS1xW3ZdWzFdLXFbdl1bM10pJiYoYlt2XT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSCkpLHI9bnVsbCxudWxsIT0KbSYmKHI9cCk7dj1xWzBdWzFdLShxWzFdWzFdK3FbMV1bM10pO3A9cVswXVswXS0ocVsxXVswXStxWzFdWzJdKTtyPXFbMV1bMV0tKHFbMF1bMV0rcVswXVszXSk7dD1xWzFdWzBdLShxWzBdWzBdK3FbMF1bMl0pO214RWRnZVN0eWxlLnZlcnRleFNlcGVyYXRpb25zWzFdPU1hdGgubWF4KHAtQywwKTtteEVkZ2VTdHlsZS52ZXJ0ZXhTZXBlcmF0aW9uc1syXT1NYXRoLm1heCh2LUMsMCk7bXhFZGdlU3R5bGUudmVydGV4U2VwZXJhdGlvbnNbNF09TWF0aC5tYXgoci1DLDApO214RWRnZVN0eWxlLnZlcnRleFNlcGVyYXRpb25zWzNdPU1hdGgubWF4KHQtQywwKTtDPVtdO209W107bj1bXTttWzBdPXA+PXQ/bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVDpteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUO25bMF09dj49cj9teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19OT1JUSDpteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSDttWzFdPW14VXRpbHMucmV2ZXJzZVBvcnRDb25zdHJhaW50cyhtWzBdKTsKblsxXT1teFV0aWxzLnJldmVyc2VQb3J0Q29uc3RyYWludHMoblswXSk7cD1wPj10P3A6dDtyPXY+PXI/djpyO3Q9W1swLDBdLFswLDBdXTt1PSExO2Zvcih2PTA7Mj52O3YrKykwPT1iW3ZdJiYoMD09KG1bdl0mY1t2XSkmJihtW3ZdPW14VXRpbHMucmV2ZXJzZVBvcnRDb25zdHJhaW50cyhtW3ZdKSksMD09KG5bdl0mY1t2XSkmJihuW3ZdPW14VXRpbHMucmV2ZXJzZVBvcnRDb25zdHJhaW50cyhuW3ZdKSksdFt2XVswXT1uW3ZdLHRbdl1bMV09bVt2XSk7MDxyJiYwPHAmJigwPChtWzBdJmNbMF0pJiYwPChuWzFdJmNbMV0pPyh0WzBdWzBdPW1bMF0sdFswXVsxXT1uWzBdLHRbMV1bMF09blsxXSx0WzFdWzFdPW1bMV0sdT0hMCk6MDwoblswXSZjWzBdKSYmMDwobVsxXSZjWzFdKSYmKHRbMF1bMF09blswXSx0WzBdWzFdPW1bMF0sdFsxXVswXT1tWzFdLHRbMV1bMV09blsxXSx1PSEwKSk7MDxyJiYhdSYmKHRbMF1bMF09blswXSx0WzBdWzFdPW1bMF0sdFsxXVswXT1uWzFdLHRbMV1bMV09Cm1bMV0sdT0hMCk7MDxwJiYhdSYmKHRbMF1bMF09bVswXSx0WzBdWzFdPW5bMF0sdFsxXVswXT1tWzFdLHRbMV1bMV09blsxXSk7Zm9yKHY9MDsyPnY7disrKTA9PWJbdl0mJigwPT0odFt2XVswXSZjW3ZdKSYmKHRbdl1bMF09dFt2XVsxXSksQ1t2XT10W3ZdWzBdJmNbdl0sQ1t2XXw9KHRbdl1bMV0mY1t2XSk8PDgsQ1t2XXw9KHRbMS12XVt2XSZjW3ZdKTw8MTYsQ1t2XXw9KHRbMS12XVsxLXZdJmNbdl0pPDwyNCwwPT0oQ1t2XSYxNSkmJihDW3ZdPDw9OCksMD09KENbdl0mMzg0MCkmJihDW3ZdPUNbdl0mMTV8Q1t2XT4+OCksMD09KENbdl0mOTgzMDQwKSYmKENbdl09Q1t2XSY2NTUzNXwoQ1t2XSYyNTE2NTgyNDApPj44KSxiW3ZdPUNbdl0mMTUsY1t2XT09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVHx8Y1t2XT09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfTk9SVEh8fGNbdl09PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1R8fGNbdl09PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1NPVVRIKSYmCihiW3ZdPWNbdl0pO2M9YlswXT09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVD8zOmJbMF07Qz1iWzFdPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUPzM6YlsxXTtjLT16O0MtPXo7MT5jJiYoYys9NCk7MT5DJiYoQys9NCk7Yz1teEVkZ2VTdHlsZS5yb3V0ZVBhdHRlcm5zW2MtMV1bQy0xXTtteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzBdPXFbMF1bMF07bXhFZGdlU3R5bGUud2F5UG9pbnRzMVswXVsxXT1xWzBdWzFdO3N3aXRjaChiWzBdKXtjYXNlIG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX1dFU1Q6bXhFZGdlU3R5bGUud2F5UG9pbnRzMVswXVswXS09ZjtteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzFdKz1sWzBdWzFdKnFbMF1bM107YnJlYWs7Y2FzZSBteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19TT1VUSDpteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzBdKz1sWzBdWzBdKnFbMF1bMl07bXhFZGdlU3R5bGUud2F5UG9pbnRzMVswXVsxXSs9cVswXVszXSsKZjticmVhaztjYXNlIG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q6bXhFZGdlU3R5bGUud2F5UG9pbnRzMVswXVswXSs9cVswXVsyXStmO214RWRnZVN0eWxlLndheVBvaW50czFbMF1bMV0rPWxbMF1bMV0qcVswXVszXTticmVhaztjYXNlIG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX05PUlRIOm14RWRnZVN0eWxlLndheVBvaW50czFbMF1bMF0rPWxbMF1bMF0qcVswXVsyXSxteEVkZ2VTdHlsZS53YXlQb2ludHMxWzBdWzFdLT1mfWY9MDttPUM9MDwoYlswXSYobXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVHxteENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19XRVNUKSk/MDoxO2Zvcih2PTA7djxjLmxlbmd0aDt2Kyspbj1jW3ZdJjE1LHU9bj09bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfRUFTVD8zOm4sdSs9eiw0PHUmJih1LT00KSxwPW14RWRnZVN0eWxlLmRpclZlY3RvcnNbdS0xXSxuPTA8dSUyPzA6MSxuIT1DJiYoZisrLG14RWRnZVN0eWxlLndheVBvaW50czFbZl1bMF09Cm14RWRnZVN0eWxlLndheVBvaW50czFbZi0xXVswXSxteEVkZ2VTdHlsZS53YXlQb2ludHMxW2ZdWzFdPW14RWRnZVN0eWxlLndheVBvaW50czFbZi0xXVsxXSkseD0wPChjW3ZdJm14RWRnZVN0eWxlLlRBUkdFVF9NQVNLKSx5PTA8KGNbdl0mbXhFZGdlU3R5bGUuU09VUkNFX01BU0spLHI9KGNbdl0mbXhFZGdlU3R5bGUuU0lERV9NQVNLKT4+NSxyPDw9eiwxNTxyJiYocj4+PTQpLHQ9MDwoY1t2XSZteEVkZ2VTdHlsZS5DRU5URVJfTUFTSyksKHl8fHgpJiY5PnI/KHU9eT8wOjEscj10JiYwPT1uP3FbdV1bMF0rbFt1XVswXSpxW3VdWzJdOnQ/cVt1XVsxXStsW3VdWzFdKnFbdV1bM106bXhFZGdlU3R5bGUubGltaXRzW3VdW3JdLDA9PW4/KHI9KHItbXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmXVswXSkqcFswXSwwPHImJihteEVkZ2VTdHlsZS53YXlQb2ludHMxW2ZdWzBdKz1wWzBdKnIpKToocj0oci1teEVkZ2VTdHlsZS53YXlQb2ludHMxW2ZdWzFdKSpwWzFdLDA8ciYmKG14RWRnZVN0eWxlLndheVBvaW50czFbZl1bMV0rPQpwWzFdKnIpKSk6dCYmKG14RWRnZVN0eWxlLndheVBvaW50czFbZl1bMF0rPXBbMF0qTWF0aC5hYnMobXhFZGdlU3R5bGUudmVydGV4U2VwZXJhdGlvbnNbdV0vMiksbXhFZGdlU3R5bGUud2F5UG9pbnRzMVtmXVsxXSs9cFsxXSpNYXRoLmFicyhteEVkZ2VTdHlsZS52ZXJ0ZXhTZXBlcmF0aW9uc1t1XS8yKSksMDxmJiZteEVkZ2VTdHlsZS53YXlQb2ludHMxW2ZdW25dPT1teEVkZ2VTdHlsZS53YXlQb2ludHMxW2YtMV1bbl0/Zi0tOkM9bjtmb3Iodj0wO3Y8PWYmJih2IT1mfHwoKDA8KGJbMV0mKG14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1R8bXhDb25zdGFudHMuRElSRUNUSU9OX01BU0tfV0VTVCkpPzA6MSk9PW0/MDoxKT09KGYrMSklMik7disrKWUucHVzaChuZXcgbXhQb2ludChNYXRoLnJvdW5kKG14RWRnZVN0eWxlLndheVBvaW50czFbdl1bMF0qYS52aWV3LnNjYWxlKjEwKS8xMCxNYXRoLnJvdW5kKG14RWRnZVN0eWxlLndheVBvaW50czFbdl1bMV0qYS52aWV3LnNjYWxlKgoxMCkvMTApKTtmb3IoYT0xO2E8ZS5sZW5ndGg7KW51bGw9PWVbYS0xXXx8bnVsbD09ZVthXXx8ZVthLTFdLnghPWVbYV0ueHx8ZVthLTFdLnkhPWVbYV0ueT9hKys6ZS5zcGxpY2UoYSwxKX19LGdldFJvdXRlUGF0dGVybjpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1hWzBdPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTUFTS19FQVNUPzM6YVswXTthPWFbMV09PW14Q29uc3RhbnRzLkRJUkVDVElPTl9NQVNLX0VBU1Q/MzphWzFdO2UtPWI7YS09YjsxPmUmJihlKz00KTsxPmEmJihhKz00KTtiPXJvdXRlUGF0dGVybnNbZS0xXVthLTFdOzAhPWMmJjAhPWR8fG51bGw9PWlubGluZVJvdXRlUGF0dGVybnNbZS0xXVthLTFdfHwoYj1pbmxpbmVSb3V0ZVBhdHRlcm5zW2UtMV1bYS0xXSk7cmV0dXJuIGJ9fSxteFN0eWxlUmVnaXN0cnk9e3ZhbHVlczpbXSxwdXRWYWx1ZTpmdW5jdGlvbihhLGIpe214U3R5bGVSZWdpc3RyeS52YWx1ZXNbYV09Yn0sZ2V0VmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIG14U3R5bGVSZWdpc3RyeS52YWx1ZXNbYV19LApnZXROYW1lOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYiBpbiBteFN0eWxlUmVnaXN0cnkudmFsdWVzKWlmKG14U3R5bGVSZWdpc3RyeS52YWx1ZXNbYl09PWEpcmV0dXJuIGI7cmV0dXJuIG51bGx9fTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuRURHRVNUWUxFX0VMQk9XLG14RWRnZVN0eWxlLkVsYm93Q29ubmVjdG9yKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuRURHRVNUWUxFX0VOVElUWV9SRUxBVElPTixteEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbik7bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLkVER0VTVFlMRV9MT09QLG14RWRnZVN0eWxlLkxvb3ApO214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5FREdFU1RZTEVfU0lERVRPU0lERSxteEVkZ2VTdHlsZS5TaWRlVG9TaWRlKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuRURHRVNUWUxFX1RPUFRPQk9UVE9NLG14RWRnZVN0eWxlLlRvcFRvQm90dG9tKTsKbXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLkVER0VTVFlMRV9PUlRIT0dPTkFMLG14RWRnZVN0eWxlLk9ydGhDb25uZWN0b3IpO214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5FREdFU1RZTEVfU0VHTUVOVCxteEVkZ2VTdHlsZS5TZWdtZW50Q29ubmVjdG9yKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuUEVSSU1FVEVSX0VMTElQU0UsbXhQZXJpbWV0ZXIuRWxsaXBzZVBlcmltZXRlcik7bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLlBFUklNRVRFUl9SRUNUQU5HTEUsbXhQZXJpbWV0ZXIuUmVjdGFuZ2xlUGVyaW1ldGVyKTtteFN0eWxlUmVnaXN0cnkucHV0VmFsdWUobXhDb25zdGFudHMuUEVSSU1FVEVSX1JIT01CVVMsbXhQZXJpbWV0ZXIuUmhvbWJ1c1BlcmltZXRlcik7bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKG14Q29uc3RhbnRzLlBFUklNRVRFUl9UUklBTkdMRSxteFBlcmltZXRlci5UcmlhbmdsZVBlcmltZXRlcik7Cm14U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZShteENvbnN0YW50cy5QRVJJTUVURVJfSEVYQUdPTixteFBlcmltZXRlci5IZXhhZ29uUGVyaW1ldGVyKTtmdW5jdGlvbiBteEdyYXBoVmlldyhhKXt0aGlzLmdyYXBoPWE7dGhpcy50cmFuc2xhdGU9bmV3IG14UG9pbnQ7dGhpcy5ncmFwaEJvdW5kcz1uZXcgbXhSZWN0YW5nbGU7dGhpcy5zdGF0ZXM9bmV3IG14RGljdGlvbmFyeX1teEdyYXBoVmlldy5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhHcmFwaFZpZXcucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14R3JhcGhWaWV3O214R3JhcGhWaWV3LnByb3RvdHlwZS5FTVBUWV9QT0lOVD1uZXcgbXhQb2ludDtteEdyYXBoVmlldy5wcm90b3R5cGUuZG9uZVJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImRvbmUiOiIiOwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRpbmdEb2N1bWVudFJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/InVwZGF0aW5nRG9jdW1lbnQiOiIiO214R3JhcGhWaWV3LnByb3RvdHlwZS5hbGxvd0V2YWw9ITE7bXhHcmFwaFZpZXcucHJvdG90eXBlLmNhcHR1cmVEb2N1bWVudEdlc3R1cmU9ITA7bXhHcmFwaFZpZXcucHJvdG90eXBlLm9wdGltaXplVm1sUmVmbG93cz0hMDtteEdyYXBoVmlldy5wcm90b3R5cGUucmVuZGVyaW5nPSEwO214R3JhcGhWaWV3LnByb3RvdHlwZS5ncmFwaD1udWxsO214R3JhcGhWaWV3LnByb3RvdHlwZS5jdXJyZW50Um9vdD1udWxsO214R3JhcGhWaWV3LnByb3RvdHlwZS5ncmFwaEJvdW5kcz1udWxsO214R3JhcGhWaWV3LnByb3RvdHlwZS5zY2FsZT0xO214R3JhcGhWaWV3LnByb3RvdHlwZS50cmFuc2xhdGU9bnVsbDtteEdyYXBoVmlldy5wcm90b3R5cGUuc3RhdGVzPW51bGw7Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVTdHlsZT0hMTtteEdyYXBoVmlldy5wcm90b3R5cGUubGFzdE5vZGU9bnVsbDtteEdyYXBoVmlldy5wcm90b3R5cGUubGFzdEh0bWxOb2RlPW51bGw7bXhHcmFwaFZpZXcucHJvdG90eXBlLmxhc3RGb3JlZ3JvdW5kTm9kZT1udWxsO214R3JhcGhWaWV3LnByb3RvdHlwZS5sYXN0Rm9yZWdyb3VuZEh0bWxOb2RlPW51bGw7bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEdyYXBoQm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGhCb3VuZHN9O214R3JhcGhWaWV3LnByb3RvdHlwZS5zZXRHcmFwaEJvdW5kcz1mdW5jdGlvbihhKXt0aGlzLmdyYXBoQm91bmRzPWF9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0Qm91bmRzPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7aWYobnVsbCE9YSYmMDxhLmxlbmd0aClmb3IodmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGQ9MDtkPGEubGVuZ3RoO2QrKylpZihjLmlzVmVydGV4KGFbZF0pfHxjLmlzRWRnZShhW2RdKSl7dmFyIGU9dGhpcy5nZXRTdGF0ZShhW2RdKTtudWxsIT1lJiYobnVsbD09Yj9iPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZSk6Yi5hZGQoZSkpfXJldHVybiBifTtteEdyYXBoVmlldy5wcm90b3R5cGUuc2V0Q3VycmVudFJvb3Q9ZnVuY3Rpb24oYSl7aWYodGhpcy5jdXJyZW50Um9vdCE9YSl7dmFyIGI9bmV3IG14Q3VycmVudFJvb3RDaGFuZ2UodGhpcyxhKTtiLmV4ZWN1dGUoKTt2YXIgYz1uZXcgbXhVbmRvYWJsZUVkaXQodGhpcywhMCk7Yy5hZGQoYik7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5VTkRPLCJlZGl0IixjKSk7dGhpcy5ncmFwaC5zaXplRGlkQ2hhbmdlKCl9cmV0dXJuIGF9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuc2NhbGVBbmRUcmFuc2xhdGU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuc2NhbGUsZT1uZXcgbXhQb2ludCh0aGlzLnRyYW5zbGF0ZS54LHRoaXMudHJhbnNsYXRlLnkpO2lmKHRoaXMuc2NhbGUhPWF8fHRoaXMudHJhbnNsYXRlLnghPWJ8fHRoaXMudHJhbnNsYXRlLnkhPWMpdGhpcy5zY2FsZT1hLHRoaXMudHJhbnNsYXRlLng9Yix0aGlzLnRyYW5zbGF0ZS55PWMsdGhpcy5pc0V2ZW50c0VuYWJsZWQoKSYmdGhpcy52aWV3U3RhdGVDaGFuZ2VkKCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLCJzY2FsZSIsYSwicHJldmlvdXNTY2FsZSIsZCwidHJhbnNsYXRlIix0aGlzLnRyYW5zbGF0ZSwicHJldmlvdXNUcmFuc2xhdGUiLGUpKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2NhbGV9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuc2V0U2NhbGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zY2FsZTt0aGlzLnNjYWxlIT1hJiYodGhpcy5zY2FsZT1hLHRoaXMuaXNFdmVudHNFbmFibGVkKCkmJnRoaXMudmlld1N0YXRlQ2hhbmdlZCgpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNDQUxFLCJzY2FsZSIsYSwicHJldmlvdXNTY2FsZSIsYikpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0VHJhbnNsYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnNldFRyYW5zbGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBteFBvaW50KHRoaXMudHJhbnNsYXRlLngsdGhpcy50cmFuc2xhdGUueSk7aWYodGhpcy50cmFuc2xhdGUueCE9YXx8dGhpcy50cmFuc2xhdGUueSE9Yil0aGlzLnRyYW5zbGF0ZS54PWEsdGhpcy50cmFuc2xhdGUueT1iLHRoaXMuaXNFdmVudHNFbmFibGVkKCkmJnRoaXMudmlld1N0YXRlQ2hhbmdlZCgpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuVFJBTlNMQVRFLCJ0cmFuc2xhdGUiLHRoaXMudHJhbnNsYXRlLCJwcmV2aW91c1RyYW5zbGF0ZSIsYykpfTtteEdyYXBoVmlldy5wcm90b3R5cGUudmlld1N0YXRlQ2hhbmdlZD1mdW5jdGlvbigpe3RoaXMucmV2YWxpZGF0ZSgpO3RoaXMuZ3JhcGguc2l6ZURpZENoYW5nZSgpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmN1cnJlbnRSb290JiZ0aGlzLmNsZWFyKCk7dGhpcy5yZXZhbGlkYXRlKCl9O214R3JhcGhWaWV3LnByb3RvdHlwZS5yZXZhbGlkYXRlPWZ1bmN0aW9uKCl7dGhpcy5pbnZhbGlkYXRlKCk7dGhpcy52YWxpZGF0ZSgpfTtteEdyYXBoVmlldy5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTthPWF8fGQuZ2V0Um9vdCgpO2I9bnVsbCE9Yj9iOiExO2M9bnVsbCE9Yz9jOiEwO3RoaXMucmVtb3ZlU3RhdGUoYSk7aWYoYyYmKGJ8fGEhPXRoaXMuY3VycmVudFJvb3QpKXtjPWQuZ2V0Q2hpbGRDb3VudChhKTtmb3IodmFyIGU9MDtlPGM7ZSsrKXRoaXMuY2xlYXIoZC5nZXRDaGlsZEF0KGEsZSksYil9ZWxzZSB0aGlzLmludmFsaWRhdGUoYSl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuaW52YWxpZGF0ZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2E9YXx8ZC5nZXRSb290KCk7Yj1udWxsIT1iP2I6ITA7Yz1udWxsIT1jP2M6ITA7dmFyIGU9dGhpcy5nZXRTdGF0ZShhKTtudWxsIT1lJiYoZS5pbnZhbGlkPSEwKTtpZighYS5pbnZhbGlkYXRpbmcpe2EuaW52YWxpZGF0aW5nPSEwO2lmKGIpZm9yKHZhciBmPWQuZ2V0Q2hpbGRDb3VudChhKSxlPTA7ZTxmO2UrKyl7dmFyIGc9ZC5nZXRDaGlsZEF0KGEsZSk7dGhpcy5pbnZhbGlkYXRlKGcsYixjKX1pZihjKWZvcihmPWQuZ2V0RWRnZUNvdW50KGEpLGU9MDtlPGY7ZSsrKXRoaXMuaW52YWxpZGF0ZShkLmdldEVkZ2VBdChhLGUpLGIsYyk7ZGVsZXRlIGEuaW52YWxpZGF0aW5nfX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbihhKXt2YXIgYj1teExvZy5lbnRlcigibXhHcmFwaFZpZXcudmFsaWRhdGUiKTt3aW5kb3cuc3RhdHVzPW14UmVzb3VyY2VzLmdldCh0aGlzLnVwZGF0aW5nRG9jdW1lbnRSZXNvdXJjZSl8fHRoaXMudXBkYXRpbmdEb2N1bWVudFJlc291cmNlO3RoaXMucmVzZXRWYWxpZGF0aW9uU3RhdGUoKTt2YXIgYz1udWxsO3RoaXMub3B0aW1pemVWbWxSZWZsb3dzJiZudWxsIT10aGlzLmNhbnZhcyYmbnVsbD09dGhpcy50ZXh0RGl2JiYoOD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYhbXhDbGllbnQuSVNfRU18fG14Q2xpZW50LklTX1FVSVJLUykmJih0aGlzLnBsYWNlaG9sZGVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHRoaXMucGxhY2Vob2xkZXIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIix0aGlzLnBsYWNlaG9sZGVyLnN0eWxlLndpZHRoPXRoaXMuY2FudmFzLmNsaWVudFdpZHRoKyJweCIsdGhpcy5wbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQ9CnRoaXMuY2FudmFzLmNsaWVudEhlaWdodCsicHgiLHRoaXMuY2FudmFzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wbGFjZWhvbGRlciksYz10aGlzLmRyYXdQYW5lLnN0eWxlLmRpc3BsYXksdGhpcy5jYW52YXMuc3R5bGUuZGlzcGxheT0ibm9uZSIsdGhpcy50ZXh0RGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHRoaXMudGV4dERpdi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLHRoaXMudGV4dERpdi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLHRoaXMudGV4dERpdi5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLHRoaXMudGV4dERpdi5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIix0aGlzLnRleHREaXYuc3R5bGUuem9vbT0iMSIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRleHREaXYpKTthPXRoaXMuZ2V0Qm91bmRpbmdCb3godGhpcy52YWxpZGF0ZUNlbGxTdGF0ZSh0aGlzLnZhbGlkYXRlQ2VsbChhfHwKKG51bGwhPXRoaXMuY3VycmVudFJvb3Q/dGhpcy5jdXJyZW50Um9vdDp0aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpKSkpKTt0aGlzLnNldEdyYXBoQm91bmRzKG51bGwhPWE/YTp0aGlzLmdldEVtcHR5Qm91bmRzKCkpO3RoaXMudmFsaWRhdGVCYWNrZ3JvdW5kKCk7bnVsbCE9YyYmKHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXk9Yyx0aGlzLnRleHREaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnRleHREaXYpLG51bGwhPXRoaXMucGxhY2Vob2xkZXImJnRoaXMucGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBsYWNlaG9sZGVyKSx0aGlzLnRleHREaXY9bnVsbCk7dGhpcy5yZXNldFZhbGlkYXRpb25TdGF0ZSgpO3dpbmRvdy5zdGF0dXM9bXhSZXNvdXJjZXMuZ2V0KHRoaXMuZG9uZVJlc291cmNlKXx8dGhpcy5kb25lUmVzb3VyY2U7bXhMb2cubGVhdmUoIm14R3JhcGhWaWV3LnZhbGlkYXRlIixiKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRFbXB0eUJvdW5kcz1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUodGhpcy50cmFuc2xhdGUueCp0aGlzLnNjYWxlLHRoaXMudHJhbnNsYXRlLnkqdGhpcy5zY2FsZSl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3g9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDt2YXIgYz1udWxsO2lmKG51bGwhPWEmJihudWxsIT1hLnNoYXBlJiZudWxsIT1hLnNoYXBlLmJvdW5kaW5nQm94JiYoYz1hLnNoYXBlLmJvdW5kaW5nQm94LmNsb25lKCkpLG51bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0LmJvdW5kaW5nQm94JiYobnVsbCE9Yz9jLmFkZChhLnRleHQuYm91bmRpbmdCb3gpOmM9YS50ZXh0LmJvdW5kaW5nQm94LmNsb25lKCkpLGIpKWZvcih2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1kLmdldENoaWxkQ291bnQoYS5jZWxsKSxmPTA7ZjxlO2YrKyl7dmFyIGc9dGhpcy5nZXRCb3VuZGluZ0JveCh0aGlzLmdldFN0YXRlKGQuZ2V0Q2hpbGRBdChhLmNlbGwsZikpKTtudWxsIT1nJiYobnVsbD09Yz9jPWc6Yy5hZGQoZykpfXJldHVybiBjfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZUJhY2tncm91bmRQYWdlU2hhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZVNoYXBlKGEsIndoaXRlIiwiYmxhY2siKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZD1mdW5jdGlvbigpe3RoaXMudmFsaWRhdGVCYWNrZ3JvdW5kSW1hZ2UoKTt0aGlzLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2UoKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZUJhY2tncm91bmRJbWFnZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguZ2V0QmFja2dyb3VuZEltYWdlKCk7aWYobnVsbCE9YSl7aWYobnVsbD09dGhpcy5iYWNrZ3JvdW5kSW1hZ2V8fHRoaXMuYmFja2dyb3VuZEltYWdlLmltYWdlIT1hLnNyYyl7bnVsbCE9dGhpcy5iYWNrZ3JvdW5kSW1hZ2UmJnRoaXMuYmFja2dyb3VuZEltYWdlLmRlc3Ryb3koKTt2YXIgYj1uZXcgbXhSZWN0YW5nbGUoMCwwLDEsMSk7dGhpcy5iYWNrZ3JvdW5kSW1hZ2U9bmV3IG14SW1hZ2VTaGFwZShiLGEuc3JjKTt0aGlzLmJhY2tncm91bmRJbWFnZS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdDt0aGlzLmJhY2tncm91bmRJbWFnZS5pbml0KHRoaXMuYmFja2dyb3VuZFBhbmUpO3RoaXMuYmFja2dyb3VuZEltYWdlLnJlZHJhdygpOzghPWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfRU18fG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLmJhY2tncm91bmRJbWFnZS5ub2RlLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGEpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLG5ldyBteE1vdXNlRXZlbnQoYSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX1VQLG5ldyBteE1vdXNlRXZlbnQoYSkpfSkpfXRoaXMucmVkcmF3QmFja2dyb3VuZEltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlLGEpfWVsc2UgbnVsbCE9dGhpcy5iYWNrZ3JvdW5kSW1hZ2UmJih0aGlzLmJhY2tncm91bmRJbWFnZS5kZXN0cm95KCksdGhpcy5iYWNrZ3JvdW5kSW1hZ2U9bnVsbCl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZT1mdW5jdGlvbigpe2lmKHRoaXMuZ3JhcGgucGFnZVZpc2libGUpe3ZhciBhPXRoaXMuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHMoKTtudWxsPT10aGlzLmJhY2tncm91bmRQYWdlU2hhcGU/KHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZT10aGlzLmNyZWF0ZUJhY2tncm91bmRQYWdlU2hhcGUoYSksdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLnNjYWxlPXRoaXMuc2NhbGUsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmlzU2hhZG93PSEwLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuaW5pdCh0aGlzLmJhY2tncm91bmRQYW5lKSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUucmVkcmF3KCksdGhpcy5ncmFwaC5uYXRpdmVEYmxDbGlja0VuYWJsZWQmJm14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUsCiJkYmxjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5kYmxDbGljayhhKX0pKSxteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sbmV3IG14TW91c2VFdmVudChhKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT10aGlzLmdyYXBoLnRvb2x0aXBIYW5kbGVyJiZ0aGlzLmdyYXBoLnRvb2x0aXBIYW5kbGVyLmlzSGlkZU9uSG92ZXIoKSYmdGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlKCk7dGhpcy5ncmFwaC5pc01vdXNlRG93biYmIW14RXZlbnQuaXNDb25zdW1lZChhKSYmdGhpcy5ncmFwaC5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChhKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsCm5ldyBteE1vdXNlRXZlbnQoYSkpfSkpKToodGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLnNjYWxlPXRoaXMuc2NhbGUsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmJvdW5kcz1hLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5yZWRyYXcoKSl9ZWxzZSBudWxsIT10aGlzLmJhY2tncm91bmRQYWdlU2hhcGUmJih0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuZGVzdHJveSgpLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZT1udWxsKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEJhY2tncm91bmRQYWdlQm91bmRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5wYWdlRm9ybWF0LGI9dGhpcy5zY2FsZSp0aGlzLmdyYXBoLnBhZ2VTY2FsZTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKHRoaXMuc2NhbGUqdGhpcy50cmFuc2xhdGUueCx0aGlzLnNjYWxlKnRoaXMudHJhbnNsYXRlLnksYS53aWR0aCpiLGEuaGVpZ2h0KmIpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnJlZHJhd0JhY2tncm91bmRJbWFnZT1mdW5jdGlvbihhLGIpe2Euc2NhbGU9dGhpcy5zY2FsZTthLmJvdW5kcy54PXRoaXMuc2NhbGUqdGhpcy50cmFuc2xhdGUueDthLmJvdW5kcy55PXRoaXMuc2NhbGUqdGhpcy50cmFuc2xhdGUueTthLmJvdW5kcy53aWR0aD10aGlzLnNjYWxlKmIud2lkdGg7YS5ib3VuZHMuaGVpZ2h0PXRoaXMuc2NhbGUqYi5oZWlnaHQ7YS5yZWRyYXcoKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZUNlbGw9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKWlmKGI9KG51bGwhPWI/YjohMCkmJnRoaXMuZ3JhcGguaXNDZWxsVmlzaWJsZShhKSxudWxsPT10aGlzLmdldFN0YXRlKGEsYil8fGIpZm9yKHZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPWMuZ2V0Q2hpbGRDb3VudChhKSxlPTA7ZTxkO2UrKyl0aGlzLnZhbGlkYXRlQ2VsbChjLmdldENoaWxkQXQoYSxlKSxiJiYoIXRoaXMuaXNDZWxsQ29sbGFwc2VkKGEpfHxhPT10aGlzLmN1cnJlbnRSb290KSk7ZWxzZSB0aGlzLnJlbW92ZVN0YXRlKGEpO3JldHVybiBhfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQ2VsbFN0YXRlPWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6ITA7dmFyIGM9bnVsbDtpZihudWxsIT1hJiYoYz10aGlzLmdldFN0YXRlKGEpLG51bGwhPWMpKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCk7aWYoYy5pbnZhbGlkKXtjLmludmFsaWQ9ITE7aWYobnVsbD09Yy5zdHlsZXx8Yy5pbnZhbGlkU3R5bGUpYy5zdHlsZT10aGlzLmdyYXBoLmdldENlbGxTdHlsZShjLmNlbGwpLGMuaW52YWxpZFN0eWxlPSExO2EhPXRoaXMuY3VycmVudFJvb3QmJnRoaXMudmFsaWRhdGVDZWxsU3RhdGUoZC5nZXRQYXJlbnQoYSksITEpO2Muc2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUodGhpcy52YWxpZGF0ZUNlbGxTdGF0ZSh0aGlzLmdldFZpc2libGVUZXJtaW5hbChhLCEwKSwhMSksITApO2Muc2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUodGhpcy52YWxpZGF0ZUNlbGxTdGF0ZSh0aGlzLmdldFZpc2libGVUZXJtaW5hbChhLCExKSwhMSksCiExKTt0aGlzLnVwZGF0ZUNlbGxTdGF0ZShjKTthPT10aGlzLmN1cnJlbnRSb290fHxjLmludmFsaWR8fCh0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcoYywhMSx0aGlzLmlzUmVuZGVyaW5nKCkpLGMudXBkYXRlQ2FjaGVkQm91bmRzKCkpfWlmKGImJiFjLmludmFsaWQpe251bGwhPWMuc2hhcGUmJnRoaXMuc3RhdGVWYWxpZGF0ZWQoYyk7Zm9yKHZhciBlPWQuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxlO2YrKyl0aGlzLnZhbGlkYXRlQ2VsbFN0YXRlKGQuZ2V0Q2hpbGRBdChhLGYpKX19cmV0dXJuIGN9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlQ2VsbFN0YXRlPWZ1bmN0aW9uKGEpe2EuYWJzb2x1dGVPZmZzZXQueD0wO2EuYWJzb2x1dGVPZmZzZXQueT0wO2Eub3JpZ2luLng9MDthLm9yaWdpbi55PTA7YS5sZW5ndGg9MDtpZihhLmNlbGwhPXRoaXMuY3VycmVudFJvb3Qpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxjPXRoaXMuZ2V0U3RhdGUoYi5nZXRQYXJlbnQoYS5jZWxsKSk7bnVsbCE9YyYmYy5jZWxsIT10aGlzLmN1cnJlbnRSb290JiYoYS5vcmlnaW4ueCs9Yy5vcmlnaW4ueCxhLm9yaWdpbi55Kz1jLm9yaWdpbi55KTt2YXIgZD10aGlzLmdyYXBoLmdldENoaWxkT2Zmc2V0Rm9yQ2VsbChhLmNlbGwpO251bGwhPWQmJihhLm9yaWdpbi54Kz1kLngsYS5vcmlnaW4ueSs9ZC55KTt2YXIgZT10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhLmNlbGwpO251bGwhPWUmJihiLmlzRWRnZShhLmNlbGwpfHwoZD1udWxsIT1lLm9mZnNldD9lLm9mZnNldDp0aGlzLkVNUFRZX1BPSU5ULAplLnJlbGF0aXZlJiZudWxsIT1jP2IuaXNFZGdlKGMuY2VsbCk/KGQ9dGhpcy5nZXRQb2ludChjLGUpLG51bGwhPWQmJihhLm9yaWdpbi54Kz1kLngvdGhpcy5zY2FsZS1jLm9yaWdpbi54LXRoaXMudHJhbnNsYXRlLngsYS5vcmlnaW4ueSs9ZC55L3RoaXMuc2NhbGUtYy5vcmlnaW4ueS10aGlzLnRyYW5zbGF0ZS55KSk6KGEub3JpZ2luLngrPWUueCpjLnVuc2NhbGVkV2lkdGgrZC54LGEub3JpZ2luLnkrPWUueSpjLnVuc2NhbGVkSGVpZ2h0K2QueSk6KGEuYWJzb2x1dGVPZmZzZXQueD10aGlzLnNjYWxlKmQueCxhLmFic29sdXRlT2Zmc2V0Lnk9dGhpcy5zY2FsZSpkLnksYS5vcmlnaW4ueCs9ZS54LGEub3JpZ2luLnkrPWUueSkpLGEueD10aGlzLnNjYWxlKih0aGlzLnRyYW5zbGF0ZS54K2Eub3JpZ2luLngpLGEueT10aGlzLnNjYWxlKih0aGlzLnRyYW5zbGF0ZS55K2Eub3JpZ2luLnkpLGEud2lkdGg9dGhpcy5zY2FsZSplLndpZHRoLGEudW5zY2FsZWRXaWR0aD1lLndpZHRoLGEuaGVpZ2h0PQp0aGlzLnNjYWxlKmUuaGVpZ2h0LGEudW5zY2FsZWRIZWlnaHQ9ZS5oZWlnaHQsYi5pc1ZlcnRleChhLmNlbGwpJiZ0aGlzLnVwZGF0ZVZlcnRleFN0YXRlKGEsZSksYi5pc0VkZ2UoYS5jZWxsKSYmdGhpcy51cGRhdGVFZGdlU3RhdGUoYSxlKSl9YS51cGRhdGVDYWNoZWRCb3VuZHMoKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmlzQ2VsbENvbGxhcHNlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ncmFwaC5pc0NlbGxDb2xsYXBzZWQoYSl9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlVmVydGV4U3RhdGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZD10aGlzLmdldFN0YXRlKGMuZ2V0UGFyZW50KGEuY2VsbCkpO2lmKGIucmVsYXRpdmUmJm51bGwhPWQmJiFjLmlzRWRnZShkLmNlbGwpKXt2YXIgZT1teFV0aWxzLnRvUmFkaWFucyhkLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKTtpZigwIT1lKXt2YXIgYz1NYXRoLmNvcyhlKSxlPU1hdGguc2luKGUpLGY9bmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS5nZXRDZW50ZXJZKCkpLGQ9bmV3IG14UG9pbnQoZC5nZXRDZW50ZXJYKCksZC5nZXRDZW50ZXJZKCkpLGQ9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZixjLGUsZCk7YS54PWQueC1hLndpZHRoLzI7YS55PWQueS1hLmhlaWdodC8yfX10aGlzLnVwZGF0ZVZlcnRleExhYmVsT2Zmc2V0KGEpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUVkZ2VTdGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApLGQ9YS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSk7bnVsbCE9dGhpcy5ncmFwaC5tb2RlbC5nZXRUZXJtaW5hbChhLmNlbGwsITApJiZudWxsPT1jfHxudWxsPT1jJiZudWxsPT1iLmdldFRlcm1pbmFsUG9pbnQoITApfHxudWxsIT10aGlzLmdyYXBoLm1vZGVsLmdldFRlcm1pbmFsKGEuY2VsbCwhMSkmJm51bGw9PWR8fG51bGw9PWQmJm51bGw9PWIuZ2V0VGVybWluYWxQb2ludCghMSk/dGhpcy5jbGVhcihhLmNlbGwsITApOih0aGlzLnVwZGF0ZUZpeGVkVGVybWluYWxQb2ludHMoYSxjLGQpLHRoaXMudXBkYXRlUG9pbnRzKGEsYi5wb2ludHMsYyxkKSx0aGlzLnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludHMoYSxjLGQpLGM9YS5hYnNvbHV0ZVBvaW50cyxhLmNlbGwhPXRoaXMuY3VycmVudFJvb3QmJihudWxsPT1jfHwyPgpjLmxlbmd0aHx8bnVsbD09Y1swXXx8bnVsbD09Y1tjLmxlbmd0aC0xXSk/dGhpcy5jbGVhcihhLmNlbGwsITApOih0aGlzLnVwZGF0ZUVkZ2VCb3VuZHMoYSksdGhpcy51cGRhdGVFZGdlTGFiZWxPZmZzZXQoYSkpKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVWZXJ0ZXhMYWJlbE9mZnNldD1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfUE9TSVRJT04sbXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKTtpZihiPT1teENvbnN0YW50cy5BTElHTl9MRUZUKWI9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX1dJRFRILG51bGwpLGI9bnVsbCE9Yj9iKnRoaXMuc2NhbGU6YS53aWR0aCxhLmFic29sdXRlT2Zmc2V0LngtPWI7ZWxzZSBpZihiPT1teENvbnN0YW50cy5BTElHTl9SSUdIVClhLmFic29sdXRlT2Zmc2V0LngrPWEud2lkdGg7ZWxzZSBpZihiPT1teENvbnN0YW50cy5BTElHTl9DRU5URVImJihiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9MQUJFTF9XSURUSCxudWxsKSxudWxsIT1iKSl7dmFyIGM9bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLApteENvbnN0YW50cy5BTElHTl9DRU5URVIpLGQ9MDtjPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/ZD0uNTpjPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKGQ9MSk7MCE9ZCYmKGEuYWJzb2x1dGVPZmZzZXQueC09KGIqdGhpcy5zY2FsZS1hLndpZHRoKSpkKX1iPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9MQUJFTF9QT1NJVElPTixteENvbnN0YW50cy5BTElHTl9NSURETEUpO2I9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9hLmFic29sdXRlT2Zmc2V0LnktPWEuaGVpZ2h0OmI9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTSYmKGEuYWJzb2x1dGVPZmZzZXQueSs9YS5oZWlnaHQpfTtteEdyYXBoVmlldy5wcm90b3R5cGUucmVzZXRWYWxpZGF0aW9uU3RhdGU9ZnVuY3Rpb24oKXt0aGlzLmxhc3RGb3JlZ3JvdW5kSHRtbE5vZGU9dGhpcy5sYXN0Rm9yZWdyb3VuZE5vZGU9dGhpcy5sYXN0SHRtbE5vZGU9dGhpcy5sYXN0Tm9kZT1udWxsfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnN0YXRlVmFsaWRhdGVkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSYmdGhpcy5ncmFwaC5rZWVwRWRnZXNJbkZvcmVncm91bmR8fHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChhLmNlbGwpJiZ0aGlzLmdyYXBoLmtlZXBFZGdlc0luQmFja2dyb3VuZDthPXRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmluc2VydFN0YXRlQWZ0ZXIoYSxiP3RoaXMubGFzdEZvcmVncm91bmROb2RlfHx0aGlzLmxhc3ROb2RlOnRoaXMubGFzdE5vZGUsYj90aGlzLmxhc3RGb3JlZ3JvdW5kSHRtbE5vZGV8fHRoaXMubGFzdEh0bWxOb2RlOnRoaXMubGFzdEh0bWxOb2RlKTtiPyh0aGlzLmxhc3RGb3JlZ3JvdW5kSHRtbE5vZGU9YVsxXSx0aGlzLmxhc3RGb3JlZ3JvdW5kTm9kZT1hWzBdKToodGhpcy5sYXN0SHRtbE5vZGU9YVsxXSx0aGlzLmxhc3ROb2RlPWFbMF0pfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUZpeGVkVGVybWluYWxQb2ludHM9ZnVuY3Rpb24oYSxiLGMpe3RoaXMudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50KGEsYiwhMCx0aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsYiwhMCkpO3RoaXMudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50KGEsYywhMSx0aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsYywhMSkpfTtteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYixjLGQpe2Euc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KHRoaXMuZ2V0Rml4ZWRUZXJtaW5hbFBvaW50KGEsYixjLGQpLGMpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEZpeGVkVGVybWluYWxQb2ludD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1udWxsO251bGwhPWQmJihlPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KGIsZCwhMSkpO2lmKG51bGw9PWUmJm51bGw9PWIpe2I9dGhpcy5zY2FsZTtkPXRoaXMudHJhbnNsYXRlO3ZhciBmPWEub3JpZ2luLGU9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYS5jZWxsKS5nZXRUZXJtaW5hbFBvaW50KGMpO251bGwhPWUmJihlPW5ldyBteFBvaW50KGIqKGQueCtlLngrZi54KSxiKihkLnkrZS55K2YueSkpKX1yZXR1cm4gZX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVCb3VuZHNGcm9tU3RlbmNpbD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKG51bGwhPWEmJm51bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3RlbmNpbCYmImZpeGVkIj09YS5zaGFwZS5zdGVuY2lsLmFzcGVjdCl7dmFyIGI9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShhKSxjPWEuc2hhcGUuc3RlbmNpbC5jb21wdXRlQXNwZWN0KGEuc3R5bGUsYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0KTthLnNldFJlY3QoYy54LGMueSxhLnNoYXBlLnN0ZW5jaWwudzAqYy53aWR0aCxhLnNoYXBlLnN0ZW5jaWwuaDAqYy5oZWlnaHQpfXJldHVybiBifTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZVBvaW50cz1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1hKXt2YXIgZT1bXTtlLnB1c2goYS5hYnNvbHV0ZVBvaW50c1swXSk7dmFyIGY9dGhpcy5nZXRFZGdlU3R5bGUoYSxiLGMsZCk7aWYobnVsbCE9Zil7Yz10aGlzLmdldFRlcm1pbmFsUG9ydChhLGMsITApO2Q9dGhpcy5nZXRUZXJtaW5hbFBvcnQoYSxkLCExKTt2YXIgZz10aGlzLnVwZGF0ZUJvdW5kc0Zyb21TdGVuY2lsKGMpLGs9dGhpcy51cGRhdGVCb3VuZHNGcm9tU3RlbmNpbChkKTtmKGEsYyxkLGIsZSk7bnVsbCE9ZyYmYy5zZXRSZWN0KGcueCxnLnksZy53aWR0aCxnLmhlaWdodCk7bnVsbCE9ayYmZC5zZXRSZWN0KGsueCxrLnksay53aWR0aCxrLmhlaWdodCl9ZWxzZSBpZihudWxsIT1iKWZvcihmPTA7ZjxiLmxlbmd0aDtmKyspbnVsbCE9YltmXSYmKGM9bXhVdGlscy5jbG9uZShiW2ZdKSxlLnB1c2godGhpcy50cmFuc2Zvcm1Db250cm9sUG9pbnQoYSxjKSkpO2I9CmEuYWJzb2x1dGVQb2ludHM7ZS5wdXNoKGJbYi5sZW5ndGgtMV0pO2EuYWJzb2x1dGVQb2ludHM9ZX19O214R3JhcGhWaWV3LnByb3RvdHlwZS50cmFuc2Zvcm1Db250cm9sUG9pbnQ9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBudWxsIT1hJiZudWxsIT1iPyhhPWEub3JpZ2luLGM9Yz8xOnRoaXMuc2NhbGUsbmV3IG14UG9pbnQoYyooYi54K3RoaXMudHJhbnNsYXRlLngrYS54KSxjKihiLnkrdGhpcy50cmFuc2xhdGUueSthLnkpKSk6bnVsbH07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5pc0xvb3BTdHlsZUVuYWJsZWQ9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludChhLGMsITApLGY9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludChhLGQsITEpO3JldHVybiEobnVsbD09Ynx8Mj5iLmxlbmd0aCl8fG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9PUlRIT0dPTkFMX0xPT1AsITEpJiYobnVsbCE9ZSYmbnVsbCE9ZS5wb2ludHx8bnVsbCE9ZiYmbnVsbCE9Zi5wb2ludCk/ITE6bnVsbCE9YyYmYz09ZH07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRFZGdlU3R5bGU9ZnVuY3Rpb24oYSxiLGMsZCl7YT10aGlzLmlzTG9vcFN0eWxlRW5hYmxlZChhLGIsYyxkKT9teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTE9PUCx0aGlzLmdyYXBoLmRlZmF1bHRMb29wU3R5bGUpOm14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRSwhMSk/bnVsbDphLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VER0VdOyJzdHJpbmciPT10eXBlb2YgYSYmKGI9bXhTdHlsZVJlZ2lzdHJ5LmdldFZhbHVlKGEpLG51bGw9PWImJnRoaXMuaXNBbGxvd0V2YWwoKSYmKGI9bXhVdGlscy5ldmFsKGEpKSxhPWIpO3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBhP2E6bnVsbH07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnRzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLmFic29sdXRlUG9pbnRzLGU9ZFswXTtudWxsPT1kW2QubGVuZ3RoLTFdJiZudWxsIT1jJiZ0aGlzLnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludChhLGMsYiwhMSk7bnVsbD09ZSYmbnVsbCE9YiYmdGhpcy51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnQoYSxiLGMsITApfTtteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYixjLGQpe2Euc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KHRoaXMuZ2V0RmxvYXRpbmdUZXJtaW5hbFBvaW50KGEsYixjLGQpLGQpfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEZsb2F0aW5nVGVybWluYWxQb2ludD1mdW5jdGlvbihhLGIsYyxkKXtiPXRoaXMuZ2V0VGVybWluYWxQb3J0KGEsYixkKTt2YXIgZT10aGlzLmdldE5leHRQb2ludChhLGMsZCksZj10aGlzLmdyYXBoLmlzT3J0aG9nb25hbChhKTtjPW14VXRpbHMudG9SYWRpYW5zKE51bWJlcihiLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSk7dmFyIGc9bmV3IG14UG9pbnQoYi5nZXRDZW50ZXJYKCksYi5nZXRDZW50ZXJZKCkpO2lmKDAhPWMpdmFyIGs9TWF0aC5jb3MoLWMpLGw9TWF0aC5zaW4oLWMpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoZSxrLGwsZyk7az1wYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUEVSSU1FVEVSX1NQQUNJTkddfHwwKTtrKz1wYXJzZUZsb2F0KGEuc3R5bGVbZD9teENvbnN0YW50cy5TVFlMRV9TT1VSQ0VfUEVSSU1FVEVSX1NQQUNJTkc6bXhDb25zdGFudHMuU1RZTEVfVEFSR0VUX1BFUklNRVRFUl9TUEFDSU5HXXx8CjApO2E9dGhpcy5nZXRQZXJpbWV0ZXJQb2ludChiLGUsMD09YyYmZixrKTswIT1jJiYoaz1NYXRoLmNvcyhjKSxsPU1hdGguc2luKGMpLGE9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoYSxrLGwsZykpO3JldHVybiBhfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0VGVybWluYWxQb3J0PWZ1bmN0aW9uKGEsYixjKXthPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxjP214Q29uc3RhbnRzLlNUWUxFX1NPVVJDRV9QT1JUOm14Q29uc3RhbnRzLlNUWUxFX1RBUkdFVF9QT1JUKTtudWxsIT1hJiYoYT10aGlzLmdldFN0YXRlKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRDZWxsKGEpKSxudWxsIT1hJiYoYj1hKSk7cmV0dXJuIGJ9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyUG9pbnQ9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bnVsbDtpZihudWxsIT1hKXt2YXIgZj10aGlzLmdldFBlcmltZXRlckZ1bmN0aW9uKGEpO2lmKG51bGwhPWYmJm51bGwhPWImJihkPXRoaXMuZ2V0UGVyaW1ldGVyQm91bmRzKGEsZCksMDxkLndpZHRofHwwPGQuaGVpZ2h0KSl7dmFyIGU9bmV3IG14UG9pbnQoYi54LGIueSksZz1iPSExO3RoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYS5jZWxsKSYmKGI9MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILDApLGc9MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLDApLG51bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3RlbmNpbCYmKGI9MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJzdGVuY2lsRmxpcEgiLDApfHxiLGc9MT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJzdGVuY2lsRmxpcFYiLAowKXx8ZyksYiYmKGUueD0yKmQuZ2V0Q2VudGVyWCgpLWUueCksZyYmKGUueT0yKmQuZ2V0Q2VudGVyWSgpLWUueSkpO2U9ZihkLGEsZSxjKTtudWxsIT1lJiYoYiYmKGUueD0yKmQuZ2V0Q2VudGVyWCgpLWUueCksZyYmKGUueT0yKmQuZ2V0Q2VudGVyWSgpLWUueSkpfW51bGw9PWUmJihlPXRoaXMuZ2V0UG9pbnQoYSkpfXJldHVybiBlfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0Um91dGluZ0NlbnRlclg9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbCE9YS5zdHlsZT9wYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9VVElOR19DRU5URVJfWF0pfHwwOjA7cmV0dXJuIGEuZ2V0Q2VudGVyWCgpK2IqYS53aWR0aH07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRSb3V0aW5nQ2VudGVyWT1mdW5jdGlvbihhKXt2YXIgYj1udWxsIT1hLnN0eWxlP3BhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1VUSU5HX0NFTlRFUl9ZXSl8fDA6MDtyZXR1cm4gYS5nZXRDZW50ZXJZKCkrYiphLmhlaWdodH07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFBlcmltZXRlckJvdW5kcz1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOjA7bnVsbCE9YSYmKGIrPXBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9QRVJJTUVURVJfU1BBQ0lOR118fDApKTtyZXR1cm4gYS5nZXRQZXJpbWV0ZXJCb3VuZHMoYip0aGlzLnNjYWxlKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRQZXJpbWV0ZXJGdW5jdGlvbj1mdW5jdGlvbihhKXthPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUEVSSU1FVEVSXTtpZigic3RyaW5nIj09dHlwZW9mIGEpe3ZhciBiPW14U3R5bGVSZWdpc3RyeS5nZXRWYWx1ZShhKTtudWxsPT1iJiZ0aGlzLmlzQWxsb3dFdmFsKCkmJihiPW14VXRpbHMuZXZhbChhKSk7YT1ifXJldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBhP2E6bnVsbH07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldE5leHRQb2ludD1mdW5jdGlvbihhLGIsYyl7YT1hLmFic29sdXRlUG9pbnRzO3ZhciBkPW51bGw7bnVsbCE9YSYmMjw9YS5sZW5ndGgmJihkPWEubGVuZ3RoLGQ9YVtjP01hdGgubWluKDEsZC0xKTpNYXRoLm1heCgwLGQtMildKTtudWxsPT1kJiZudWxsIT1iJiYoZD1uZXcgbXhQb2ludChiLmdldENlbnRlclgoKSxiLmdldENlbnRlclkoKSkpO3JldHVybiBkfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFZpc2libGVUZXJtaW5hbD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZD1jLmdldFRlcm1pbmFsKGEsYiksZT1kO251bGwhPWQmJmQhPXRoaXMuY3VycmVudFJvb3Q7KXtpZighdGhpcy5ncmFwaC5pc0NlbGxWaXNpYmxlKGUpfHx0aGlzLmlzQ2VsbENvbGxhcHNlZChkKSllPWQ7ZD1jLmdldFBhcmVudChkKX1udWxsPT1lfHxjLmNvbnRhaW5zKGUpJiZjLmdldFBhcmVudChlKSE9Yy5nZXRSb290KCkmJmUhPXRoaXMuY3VycmVudFJvb3R8fChlPW51bGwpO3JldHVybiBlfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUVkZ2VCb3VuZHM9ZnVuY3Rpb24oYSl7dmFyIGI9YS5hYnNvbHV0ZVBvaW50cyxjPWJbMF0sZD1iW2IubGVuZ3RoLTFdO2lmKGMueCE9ZC54fHxjLnkhPWQueSl7dmFyIGU9ZC54LWMueCxmPWQueS1jLnk7YS50ZXJtaW5hbERpc3RhbmNlPU1hdGguc3FydChlKmUrZipmKX1lbHNlIGEudGVybWluYWxEaXN0YW5jZT0wO3ZhciBkPTAsZz1bXSxmPWM7aWYobnVsbCE9Zil7Zm9yKHZhciBjPWYueCxrPWYueSxsPWMsbT1rLG49MTtuPGIubGVuZ3RoO24rKyl7dmFyIHA9YltuXTtudWxsIT1wJiYoZT1mLngtcC54LGY9Zi55LXAueSxlPU1hdGguc3FydChlKmUrZipmKSxnLnB1c2goZSksZCs9ZSxmPXAsYz1NYXRoLm1pbihmLngsYyksaz1NYXRoLm1pbihmLnksayksbD1NYXRoLm1heChmLngsbCksbT1NYXRoLm1heChmLnksbSkpfWEubGVuZ3RoPWQ7YS5zZWdtZW50cz1nO2EueD1jO2EueT1rO2Eud2lkdGg9TWF0aC5tYXgoMSxsLWMpO2EuaGVpZ2h0PQpNYXRoLm1heCgxLG0tayl9fTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFBvaW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRDZW50ZXJYKCksZD1hLmdldENlbnRlclkoKTtpZihudWxsPT1hLnNlZ21lbnRzfHxudWxsIT1iJiYhYi5yZWxhdGl2ZSludWxsIT1iJiYobT1iLm9mZnNldCxudWxsIT1tJiYoYys9bS54LGQrPW0ueSkpO2Vsc2V7Zm9yKHZhciBlPWEuYWJzb2x1dGVQb2ludHMubGVuZ3RoLGY9TWF0aC5yb3VuZCgoKG51bGwhPWI/Yi54LzI6MCkrLjUpKmEubGVuZ3RoKSxnPWEuc2VnbWVudHNbMF0saz0wLGw9MTtmPj1NYXRoLnJvdW5kKGsrZykmJmw8ZS0xOylrKz1nLGc9YS5zZWdtZW50c1tsKytdO2U9MD09Zz8wOihmLWspL2c7Zj1hLmFic29sdXRlUG9pbnRzW2wtMV07bD1hLmFic29sdXRlUG9pbnRzW2xdO2lmKG51bGwhPWYmJm51bGwhPWwpe2s9Yz1kPTA7aWYobnVsbCE9Yil7dmFyIGQ9Yi55LG09Yi5vZmZzZXQ7bnVsbCE9bSYmKGM9bS54LGs9bS55KX1tPWwueC1mLng7bD1sLnktZi55O2M9CmYueCttKmUrKCgwPT1nPzA6bC9nKSpkK2MpKnRoaXMuc2NhbGU7ZD1mLnkrbCplLSgoMD09Zz8wOm0vZykqZC1rKSp0aGlzLnNjYWxlfX1yZXR1cm4gbmV3IG14UG9pbnQoYyxkKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRSZWxhdGl2ZVBvaW50PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0R2VvbWV0cnkoYS5jZWxsKTtpZihudWxsIT1kKXt2YXIgZT1hLmFic29sdXRlUG9pbnRzLmxlbmd0aDtpZihkLnJlbGF0aXZlJiYxPGUpe2Zvcih2YXIgZD1hLmxlbmd0aCxmPWEuc2VnbWVudHMsZz1hLmFic29sdXRlUG9pbnRzWzBdLGs9YS5hYnNvbHV0ZVBvaW50c1sxXSxsPW14VXRpbHMucHRTZWdEaXN0U3EoZy54LGcueSxrLngsay55LGIsYyksbT0wLG49MCxwPTAscT0yO3E8ZTtxKyspbis9ZltxLTJdLGs9YS5hYnNvbHV0ZVBvaW50c1txXSxnPW14VXRpbHMucHRTZWdEaXN0U3EoZy54LGcueSxrLngsay55LGIsYyksZzw9bCYmKGw9ZyxtPXEtMSxwPW4pLGc9aztlPWZbbV07Zz1hLmFic29sdXRlUG9pbnRzW21dO2s9YS5hYnNvbHV0ZVBvaW50c1ttKzFdO2w9ay54O2Y9ay55O2E9Zy54LWw7bT1nLnktZjtmPShhLShiLWwpKSoKYSsobS0oYy1mKSkqbTthPU1hdGguc3FydCgwPj1mPzA6ZipmLyhhKmErbSptKSk7YT5lJiYoYT1lKTtlPU1hdGguc3FydChteFV0aWxzLnB0U2VnRGlzdFNxKGcueCxnLnksay54LGsueSxiLGMpKTstMT09bXhVdGlscy5yZWxhdGl2ZUNjdyhnLngsZy55LGsueCxrLnksYixjKSYmKGU9LWUpO3JldHVybiBuZXcgbXhQb2ludCgoZC8yLXAtYSkvZCotMixlL3RoaXMuc2NhbGUpfX1yZXR1cm4gbmV3IG14UG9pbnR9OwpteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlRWRnZUxhYmVsT2Zmc2V0PWZ1bmN0aW9uKGEpe3ZhciBiPWEuYWJzb2x1dGVQb2ludHM7YS5hYnNvbHV0ZU9mZnNldC54PWEuZ2V0Q2VudGVyWCgpO2EuYWJzb2x1dGVPZmZzZXQueT1hLmdldENlbnRlclkoKTtpZihudWxsIT1iJiYwPGIubGVuZ3RoJiZudWxsIT1hLnNlZ21lbnRzKXt2YXIgYz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhLmNlbGwpO2lmKGMucmVsYXRpdmUpe3ZhciBkPXRoaXMuZ2V0UG9pbnQoYSxjKTtudWxsIT1kJiYoYS5hYnNvbHV0ZU9mZnNldD1kKX1lbHNle3ZhciBkPWJbMF0sZT1iW2IubGVuZ3RoLTFdO2lmKG51bGwhPWQmJm51bGwhPWUpe3ZhciBiPWUueC1kLngsZj1lLnktZC55LGc9ZT0wLGM9Yy5vZmZzZXQ7bnVsbCE9YyYmKGU9Yy54LGc9Yy55KTtjPWQueStmLzIrZyp0aGlzLnNjYWxlO2EuYWJzb2x1dGVPZmZzZXQueD1kLngrYi8yK2UqdGhpcy5zY2FsZTthLmFic29sdXRlT2Zmc2V0Lnk9Y319fX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhLGIpe2I9Ynx8ITE7dmFyIGM9bnVsbDtudWxsIT1hJiYoYz10aGlzLnN0YXRlcy5nZXQoYSksYiYmKG51bGw9PWN8fHRoaXMudXBkYXRlU3R5bGUpJiZ0aGlzLmdyYXBoLmlzQ2VsbFZpc2libGUoYSkmJihudWxsPT1jPyhjPXRoaXMuY3JlYXRlU3RhdGUoYSksdGhpcy5zdGF0ZXMucHV0KGEsYykpOmMuc3R5bGU9dGhpcy5ncmFwaC5nZXRDZWxsU3R5bGUoYSkpKTtyZXR1cm4gY307bXhHcmFwaFZpZXcucHJvdG90eXBlLmlzUmVuZGVyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVuZGVyaW5nfTtteEdyYXBoVmlldy5wcm90b3R5cGUuc2V0UmVuZGVyaW5nPWZ1bmN0aW9uKGEpe3RoaXMucmVuZGVyaW5nPWF9O214R3JhcGhWaWV3LnByb3RvdHlwZS5pc0FsbG93RXZhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFsbG93RXZhbH07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5zZXRBbGxvd0V2YWw9ZnVuY3Rpb24oYSl7dGhpcy5hbGxvd0V2YWw9YX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldFN0YXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlc307bXhHcmFwaFZpZXcucHJvdG90eXBlLnNldFN0YXRlcz1mdW5jdGlvbihhKXt0aGlzLnN0YXRlcz1hfTtteEdyYXBoVmlldy5wcm90b3R5cGUuZ2V0Q2VsbFN0YXRlcz1mdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiB0aGlzLnN0YXRlcztmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmdldFN0YXRlKGFbY10pO251bGwhPWQmJmIucHVzaChkKX1yZXR1cm4gYn07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5yZW1vdmVTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO251bGwhPWEmJihiPXRoaXMuc3RhdGVzLnJlbW92ZShhKSxudWxsIT1iJiYodGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIuZGVzdHJveShiKSxiLmludmFsaWQ9ITAsYi5kZXN0cm95KCkpKTtyZXR1cm4gYn07bXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZVN0YXRlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhDZWxsU3RhdGUodGhpcyxhLHRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGEpKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldENhbnZhcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbnZhc307bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEJhY2tncm91bmRQYW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmFja2dyb3VuZFBhbmV9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXREcmF3UGFuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRyYXdQYW5lfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmdldE92ZXJsYXlQYW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3ZlcmxheVBhbmV9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXREZWNvcmF0b3JQYW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVjb3JhdG9yUGFuZX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmlzQ29udGFpbmVyRXZlbnQ9ZnVuY3Rpb24oYSl7YT1teEV2ZW50LmdldFNvdXJjZShhKTtyZXR1cm4gYT09dGhpcy5ncmFwaC5jb250YWluZXJ8fGEucGFyZW50Tm9kZT09dGhpcy5iYWNrZ3JvdW5kUGFuZXx8bnVsbCE9YS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucGFyZW50Tm9kZT09dGhpcy5iYWNrZ3JvdW5kUGFuZXx8YT09dGhpcy5jYW52YXMucGFyZW50Tm9kZXx8YT09dGhpcy5jYW52YXN8fGE9PXRoaXMuYmFja2dyb3VuZFBhbmV8fGE9PXRoaXMuZHJhd1BhbmV8fGE9PXRoaXMub3ZlcmxheVBhbmV8fGE9PXRoaXMuZGVjb3JhdG9yUGFuZX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5pc1Njcm9sbEV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKTthPW5ldyBteFBvaW50KGEuY2xpZW50WC1iLngsYS5jbGllbnRZLWIueSk7dmFyIGI9dGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0V2lkdGgsYz10aGlzLmdyYXBoLmNvbnRhaW5lci5jbGllbnRXaWR0aDtpZihiPmMmJmEueD5jKzImJmEueDw9YilyZXR1cm4hMDtiPXRoaXMuZ3JhcGguY29udGFpbmVyLm9mZnNldEhlaWdodDtjPXRoaXMuZ3JhcGguY29udGFpbmVyLmNsaWVudEhlaWdodDtyZXR1cm4gYj5jJiZhLnk+YysyJiZhLnk8PWI/ITA6ITF9OwpteEdyYXBoVmlldy5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3RoaXMuaW5zdGFsbExpc3RlbmVycygpO3ZhciBhPXRoaXMuZ3JhcGg7YS5kaWFsZWN0PT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz90aGlzLmNyZWF0ZVN2ZygpOmEuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9WTUw/dGhpcy5jcmVhdGVWbWwoKTp0aGlzLmNyZWF0ZUh0bWwoKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5pbnN0YWxsTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaCxiPWEuY29udGFpbmVyO2lmKG51bGwhPWIpe214Q2xpZW50LklTX1RPVUNIJiYobXhFdmVudC5hZGRMaXN0ZW5lcihiLCJnZXN0dXJlc3RhcnQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuZmlyZUdlc3R1cmVFdmVudChiKTtteEV2ZW50LmNvbnN1bWUoYil9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihiLCJnZXN0dXJlY2hhbmdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmZpcmVHZXN0dXJlRXZlbnQoYik7bXhFdmVudC5jb25zdW1lKGIpfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoYiwiZ2VzdHVyZWVuZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7YS5maXJlR2VzdHVyZUV2ZW50KGIpO214RXZlbnQuY29uc3VtZShiKX0pKSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7IXRoaXMuaXNDb250YWluZXJFdmVudChiKXx8CihteENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfR0N8fG14Q2xpZW50LklTX09QfHxteENsaWVudC5JU19TRikmJnRoaXMuaXNTY3JvbGxFdmVudChiKXx8YS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sbmV3IG14TW91c2VFdmVudChiKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLmlzQ29udGFpbmVyRXZlbnQoYikmJmEuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLG5ldyBteE1vdXNlRXZlbnQoYikpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pc0NvbnRhaW5lckV2ZW50KGIpJiZhLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsbmV3IG14TW91c2VFdmVudChiKSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJkYmxjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pc0NvbnRhaW5lckV2ZW50KGIpJiZhLmRibENsaWNrKGIpfSkpOwp2YXIgYz1mdW5jdGlvbihjKXt2YXIgZD1udWxsO214Q2xpZW50LklTX1RPVUNIJiYoZD1teEV2ZW50LmdldENsaWVudFgoYyksYz1teEV2ZW50LmdldENsaWVudFkoYyksYz1teFV0aWxzLmNvbnZlcnRQb2ludChiLGQsYyksZD1hLnZpZXcuZ2V0U3RhdGUoYS5nZXRDZWxsQXQoYy54LGMueSkpKTtyZXR1cm4gZH07YS5hZGRNb3VzZUxpc3RlbmVyKHttb3VzZURvd246ZnVuY3Rpb24oYixjKXthLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKX0sbW91c2VNb3ZlOmZ1bmN0aW9uKCl7fSxtb3VzZVVwOmZ1bmN0aW9uKCl7fX0pO3RoaXMubW92ZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bnVsbCE9YS50b29sdGlwSGFuZGxlciYmYS50b29sdGlwSGFuZGxlci5pc0hpZGVPbkhvdmVyKCkmJmEudG9vbHRpcEhhbmRsZXIuaGlkZSgpO3RoaXMuY2FwdHVyZURvY3VtZW50R2VzdHVyZSYmYS5pc01vdXNlRG93biYmbnVsbCE9YS5jb250YWluZXImJiF0aGlzLmlzQ29udGFpbmVyRXZlbnQoYikmJgoibm9uZSIhPWEuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkmJiJoaWRkZW4iIT1hLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5JiYhbXhFdmVudC5pc0NvbnN1bWVkKGIpJiZhLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGIsYyhiKSkpfSk7dGhpcy5lbmRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuY2FwdHVyZURvY3VtZW50R2VzdHVyZSYmYS5pc01vdXNlRG93biYmbnVsbCE9YS5jb250YWluZXImJiF0aGlzLmlzQ29udGFpbmVyRXZlbnQoYikmJiJub25lIiE9YS5jb250YWluZXIuc3R5bGUuZGlzcGxheSYmImhpZGRlbiIhPWEuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkmJmEuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGIpKX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLHRoaXMubW92ZUhhbmRsZXIsdGhpcy5lbmRIYW5kbGVyKX19OwpteEdyYXBoVmlldy5wcm90b3R5cGUuY3JlYXRlSHRtbD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguY29udGFpbmVyO251bGwhPWEmJih0aGlzLmNhbnZhcz10aGlzLmNyZWF0ZUh0bWxQYW5lKCIxMDAlIiwiMTAwJSIpLHRoaXMuY2FudmFzLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iLHRoaXMuYmFja2dyb3VuZFBhbmU9dGhpcy5jcmVhdGVIdG1sUGFuZSgiMXB4IiwiMXB4IiksdGhpcy5kcmF3UGFuZT10aGlzLmNyZWF0ZUh0bWxQYW5lKCIxcHgiLCIxcHgiKSx0aGlzLm92ZXJsYXlQYW5lPXRoaXMuY3JlYXRlSHRtbFBhbmUoIjFweCIsIjFweCIpLHRoaXMuZGVjb3JhdG9yUGFuZT10aGlzLmNyZWF0ZUh0bWxQYW5lKCIxcHgiLCIxcHgiKSx0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRQYW5lKSx0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmRyYXdQYW5lKSx0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlQYW5lKSx0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmRlY29yYXRvclBhbmUpLAphLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKSx0aGlzLnVwZGF0ZUNvbnRhaW5lclN0eWxlKGEpLG14Q2xpZW50LklTX1FVSVJLUyYmKGE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YT10aGlzLmdldEdyYXBoQm91bmRzKCk7dGhpcy51cGRhdGVIdG1sQ2FudmFzU2l6ZShhLngrYS53aWR0aCt0aGlzLmdyYXBoLmJvcmRlcixhLnkrYS5oZWlnaHQrdGhpcy5ncmFwaC5ib3JkZXIpfSksbXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsYSkpKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVIdG1sQ2FudmFzU2l6ZT1mdW5jdGlvbihhLGIpe2lmKG51bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyKXt2YXIgYz10aGlzLmdyYXBoLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7dGhpcy5jYW52YXMuc3R5bGUud2lkdGg9dGhpcy5ncmFwaC5jb250YWluZXIub2Zmc2V0V2lkdGg8YT9hKyJweCI6IjEwMCUiO3RoaXMuY2FudmFzLnN0eWxlLmhlaWdodD1jPGI/YisicHgiOiIxMDAlIn19O214R3JhcGhWaWV3LnByb3RvdHlwZS5jcmVhdGVIdG1sUGFuZT1mdW5jdGlvbihhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIkRJViIpO251bGwhPWEmJm51bGwhPWI/KGMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixjLnN0eWxlLmxlZnQ9IjBweCIsYy5zdHlsZS50b3A9IjBweCIsYy5zdHlsZS53aWR0aD1hLGMuc3R5bGUuaGVpZ2h0PWIpOmMuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjtyZXR1cm4gY307Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5jcmVhdGVWbWw9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmNvbnRhaW5lcjtpZihudWxsIT1hKXt2YXIgYj1hLm9mZnNldFdpZHRoLGM9YS5vZmZzZXRIZWlnaHQ7dGhpcy5jYW52YXM9dGhpcy5jcmVhdGVWbWxQYW5lKGIsYyk7dGhpcy5jYW52YXMuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7dGhpcy5iYWNrZ3JvdW5kUGFuZT10aGlzLmNyZWF0ZVZtbFBhbmUoYixjKTt0aGlzLmRyYXdQYW5lPXRoaXMuY3JlYXRlVm1sUGFuZShiLGMpO3RoaXMub3ZlcmxheVBhbmU9dGhpcy5jcmVhdGVWbWxQYW5lKGIsYyk7dGhpcy5kZWNvcmF0b3JQYW5lPXRoaXMuY3JlYXRlVm1sUGFuZShiLGMpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZFBhbmUpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuZHJhd1BhbmUpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheVBhbmUpO3RoaXMuY2FudmFzLmFwcGVuZENoaWxkKHRoaXMuZGVjb3JhdG9yUGFuZSk7CmEuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpfX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZVZtbFBhbmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KG14Q2xpZW50LlZNTF9QUkVGSVgrIjpncm91cCIpO2Muc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtjLnN0eWxlLmxlZnQ9IjBweCI7Yy5zdHlsZS50b3A9IjBweCI7Yy5zdHlsZS53aWR0aD1hKyJweCI7Yy5zdHlsZS5oZWlnaHQ9YisicHgiO2Muc2V0QXR0cmlidXRlKCJjb29yZHNpemUiLGErIiwiK2IpO2Muc2V0QXR0cmlidXRlKCJjb29yZG9yaWdpbiIsIjAsMCIpO3JldHVybiBjfTsKbXhHcmFwaFZpZXcucHJvdG90eXBlLmNyZWF0ZVN2Zz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguY29udGFpbmVyO3RoaXMuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImciKTt0aGlzLmJhY2tncm91bmRQYW5lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImciKTt0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRQYW5lKTt0aGlzLmRyYXdQYW5lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImciKTt0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmRyYXdQYW5lKTt0aGlzLm92ZXJsYXlQYW5lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsImciKTt0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlQYW5lKTt0aGlzLmRlY29yYXRvclBhbmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywKImciKTt0aGlzLmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmRlY29yYXRvclBhbmUpO3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsInN2ZyIpO2Iuc3R5bGUubGVmdD0iMHB4IjtiLnN0eWxlLnRvcD0iMHB4IjtiLnN0eWxlLndpZHRoPSIxMDAlIjtiLnN0eWxlLmhlaWdodD0iMTAwJSI7Yi5zdHlsZS5kaXNwbGF5PSJibG9jayI7Yi5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7aWYobXhDbGllbnQuSVNfSUV8fG14Q2xpZW50LklTX0lFMTEpYi5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtudWxsIT1hJiYoYS5hcHBlbmRDaGlsZChiKSx0aGlzLnVwZGF0ZUNvbnRhaW5lclN0eWxlKGEpKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTdHlsZT1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShhKTtudWxsIT1iJiYic3RhdGljIj09Yi5wb3NpdGlvbiYmKGEuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIik7bXhDbGllbnQuSVNfUE9JTlRFUiYmKGEuc3R5bGUudG91Y2hBY3Rpb249Im5vbmUiKX07Cm14R3JhcGhWaWV3LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9bnVsbCE9dGhpcy5jYW52YXM/dGhpcy5jYW52YXMub3duZXJTVkdFbGVtZW50Om51bGw7bnVsbD09YSYmKGE9dGhpcy5jYW52YXMpO251bGwhPWEmJm51bGwhPWEucGFyZW50Tm9kZSYmKHRoaXMuY2xlYXIodGhpcy5jdXJyZW50Um9vdCwhMCksbXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsdGhpcy5tb3ZlSGFuZGxlcix0aGlzLmVuZEhhbmRsZXIpLG14RXZlbnQucmVsZWFzZSh0aGlzLmdyYXBoLmNvbnRhaW5lciksYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLHRoaXMuZGVjb3JhdG9yUGFuZT10aGlzLm92ZXJsYXlQYW5lPXRoaXMuZHJhd1BhbmU9dGhpcy5iYWNrZ3JvdW5kUGFuZT10aGlzLmNhbnZhcz10aGlzLmVuZEhhbmRsZXI9dGhpcy5tb3ZlSGFuZGxlcj1udWxsKX07CmZ1bmN0aW9uIG14Q3VycmVudFJvb3RDaGFuZ2UoYSxiKXt0aGlzLnZpZXc9YTt0aGlzLnByZXZpb3VzPXRoaXMucm9vdD1iO3RoaXMuaXNVcD1udWxsPT1iO2lmKCF0aGlzLmlzVXApZm9yKHZhciBjPXRoaXMudmlldy5jdXJyZW50Um9vdCxkPXRoaXMudmlldy5ncmFwaC5nZXRNb2RlbCgpO251bGwhPWM7KXtpZihjPT1iKXt0aGlzLmlzVXA9ITA7YnJlYWt9Yz1kLmdldFBhcmVudChjKX19Cm14Q3VycmVudFJvb3RDaGFuZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnZpZXcuY3VycmVudFJvb3Q7dGhpcy52aWV3LmN1cnJlbnRSb290PXRoaXMucHJldmlvdXM7dGhpcy5wcmV2aW91cz1hO2E9dGhpcy52aWV3LmdyYXBoLmdldFRyYW5zbGF0ZUZvclJvb3QodGhpcy52aWV3LmN1cnJlbnRSb290KTtudWxsIT1hJiYodGhpcy52aWV3LnRyYW5zbGF0ZT1uZXcgbXhQb2ludCgtYS54LC1hLnkpKTt0aGlzLmlzVXA/KHRoaXMudmlldy5jbGVhcih0aGlzLnZpZXcuY3VycmVudFJvb3QsITApLHRoaXMudmlldy52YWxpZGF0ZSgpKTp0aGlzLnZpZXcucmVmcmVzaCgpO3RoaXMudmlldy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QodGhpcy5pc1VwP214RXZlbnQuVVA6bXhFdmVudC5ET1dOLCJyb290Iix0aGlzLnZpZXcuY3VycmVudFJvb3QsInByZXZpb3VzIix0aGlzLnByZXZpb3VzKSk7dGhpcy5pc1VwPSF0aGlzLmlzVXB9OwpmdW5jdGlvbiBteEdyYXBoKGEsYixjLGQpe3RoaXMubW91c2VMaXN0ZW5lcnM9bnVsbDt0aGlzLnJlbmRlckhpbnQ9Yzt0aGlzLmRpYWxlY3Q9bXhDbGllbnQuSVNfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHOmM9PW14Q29uc3RhbnRzLlJFTkRFUklOR19ISU5UX0VYQUNUJiZteENsaWVudC5JU19WTUw/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6Yz09bXhDb25zdGFudHMuUkVOREVSSU5HX0hJTlRfRkFTVEVTVD9teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUw6Yz09bXhDb25zdGFudHMuUkVOREVSSU5HX0hJTlRfRkFTVEVSP214Q29uc3RhbnRzLkRJQUxFQ1RfUFJFRkVSSFRNTDpteENvbnN0YW50cy5ESUFMRUNUX01JWEVESFRNTDt0aGlzLm1vZGVsPW51bGwhPWI/YjpuZXcgbXhHcmFwaE1vZGVsO3RoaXMubXVsdGlwbGljaXRpZXM9W107dGhpcy5pbWFnZUJ1bmRsZXM9W107dGhpcy5jZWxsUmVuZGVyZXI9dGhpcy5jcmVhdGVDZWxsUmVuZGVyZXIoKTt0aGlzLnNldFNlbGVjdGlvbk1vZGVsKHRoaXMuY3JlYXRlU2VsZWN0aW9uTW9kZWwoKSk7CnRoaXMuc2V0U3R5bGVzaGVldChudWxsIT1kP2Q6dGhpcy5jcmVhdGVTdHlsZXNoZWV0KCkpO3RoaXMudmlldz10aGlzLmNyZWF0ZUdyYXBoVmlldygpO3RoaXMuZ3JhcGhNb2RlbENoYW5nZUxpc3RlbmVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dGhpcy5ncmFwaE1vZGVsQ2hhbmdlZChiLmdldFByb3BlcnR5KCJlZGl0IikuY2hhbmdlcyl9KTt0aGlzLm1vZGVsLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMuZ3JhcGhNb2RlbENoYW5nZUxpc3RlbmVyKTt0aGlzLmNyZWF0ZUhhbmRsZXJzKCk7bnVsbCE9YSYmdGhpcy5pbml0KGEpO3RoaXMudmlldy5yZXZhbGlkYXRlKCl9bXhMb2FkUmVzb3VyY2VzP214UmVzb3VyY2VzLmFkZChteENsaWVudC5iYXNlUGF0aCsiL3Jlc291cmNlcy9ncmFwaCIpOm14Q2xpZW50LmRlZmF1bHRCdW5kbGVzLnB1c2gobXhDbGllbnQuYmFzZVBhdGgrIi9yZXNvdXJjZXMvZ3JhcGgiKTtteEdyYXBoLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTsKbXhHcmFwaC5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhHcmFwaDtteEdyYXBoLnByb3RvdHlwZS5tb3VzZUxpc3RlbmVycz1udWxsO214R3JhcGgucHJvdG90eXBlLmlzTW91c2VEb3duPSExO214R3JhcGgucHJvdG90eXBlLm1vZGVsPW51bGw7bXhHcmFwaC5wcm90b3R5cGUudmlldz1udWxsO214R3JhcGgucHJvdG90eXBlLnN0eWxlc2hlZXQ9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5zZWxlY3Rpb25Nb2RlbD1udWxsO214R3JhcGgucHJvdG90eXBlLmNlbGxFZGl0b3I9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5jZWxsUmVuZGVyZXI9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5tdWx0aXBsaWNpdGllcz1udWxsO214R3JhcGgucHJvdG90eXBlLnJlbmRlckhpbnQ9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5kaWFsZWN0PW51bGw7bXhHcmFwaC5wcm90b3R5cGUuZ3JpZFNpemU9MTA7bXhHcmFwaC5wcm90b3R5cGUuZ3JpZEVuYWJsZWQ9ITA7Cm14R3JhcGgucHJvdG90eXBlLnBvcnRzRW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5uYXRpdmVEYmxDbGlja0VuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuZG91YmxlVGFwRW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5kb3VibGVUYXBUaW1lb3V0PTUwMDtteEdyYXBoLnByb3RvdHlwZS5kb3VibGVUYXBUb2xlcmFuY2U9MjU7bXhHcmFwaC5wcm90b3R5cGUubGFzdFRvdWNoWT0wO214R3JhcGgucHJvdG90eXBlLmxhc3RUb3VjaFk9MDtteEdyYXBoLnByb3RvdHlwZS5sYXN0VG91Y2hUaW1lPTA7bXhHcmFwaC5wcm90b3R5cGUudGFwQW5kSG9sZEVuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUudGFwQW5kSG9sZERlbGF5PTUwMDtteEdyYXBoLnByb3RvdHlwZS50YXBBbmRIb2xkSW5Qcm9ncmVzcz0hMTtteEdyYXBoLnByb3RvdHlwZS50YXBBbmRIb2xkVmFsaWQ9ITE7bXhHcmFwaC5wcm90b3R5cGUuaW5pdGlhbFRvdWNoWD0wOwpteEdyYXBoLnByb3RvdHlwZS5pbml0aWFsVG91Y2hZPTA7bXhHcmFwaC5wcm90b3R5cGUudG9sZXJhbmNlPTQ7bXhHcmFwaC5wcm90b3R5cGUuZGVmYXVsdE92ZXJsYXA9LjU7bXhHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFBhcmVudD1udWxsO214R3JhcGgucHJvdG90eXBlLmFsdGVybmF0ZUVkZ2VTdHlsZT1udWxsO214R3JhcGgucHJvdG90eXBlLmJhY2tncm91bmRJbWFnZT1udWxsO214R3JhcGgucHJvdG90eXBlLnBhZ2VWaXNpYmxlPSExO214R3JhcGgucHJvdG90eXBlLnBhZ2VCcmVha3NWaXNpYmxlPSExO214R3JhcGgucHJvdG90eXBlLnBhZ2VCcmVha0NvbG9yPSJncmF5IjtteEdyYXBoLnByb3RvdHlwZS5wYWdlQnJlYWtEYXNoZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUubWluUGFnZUJyZWFrRGlzdD0yMDtteEdyYXBoLnByb3RvdHlwZS5wcmVmZXJQYWdlU2l6ZT0hMTtteEdyYXBoLnByb3RvdHlwZS5wYWdlRm9ybWF0PW14Q29uc3RhbnRzLlBBR0VfRk9STUFUX0E0X1BPUlRSQUlUOwpteEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGU9MS41O214R3JhcGgucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuZXNjYXBlRW5hYmxlZD0hMDtteEdyYXBoLnByb3RvdHlwZS5pbnZva2VzU3RvcENlbGxFZGl0aW5nPSEwO214R3JhcGgucHJvdG90eXBlLmVudGVyU3RvcHNDZWxsRWRpdGluZz0hMTtteEdyYXBoLnByb3RvdHlwZS51c2VTY3JvbGxiYXJzRm9yUGFubmluZz0hMDtteEdyYXBoLnByb3RvdHlwZS5leHBvcnRFbmFibGVkPSEwO214R3JhcGgucHJvdG90eXBlLmltcG9ydEVuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNMb2NrZWQ9ITE7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNDbG9uZWFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuZm9sZGluZ0VuYWJsZWQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNFZGl0YWJsZT0hMDtteEdyYXBoLnByb3RvdHlwZS5jZWxsc0RlbGV0YWJsZT0hMDsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbHNNb3ZhYmxlPSEwO214R3JhcGgucHJvdG90eXBlLmVkZ2VMYWJlbHNNb3ZhYmxlPSEwO214R3JhcGgucHJvdG90eXBlLnZlcnRleExhYmVsc01vdmFibGU9ITE7bXhHcmFwaC5wcm90b3R5cGUuZHJvcEVuYWJsZWQ9ITE7bXhHcmFwaC5wcm90b3R5cGUuc3BsaXRFbmFibGVkPSEwO214R3JhcGgucHJvdG90eXBlLmNlbGxzUmVzaXphYmxlPSEwO214R3JhcGgucHJvdG90eXBlLmNlbGxzQmVuZGFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuY2VsbHNTZWxlY3RhYmxlPSEwO214R3JhcGgucHJvdG90eXBlLmNlbGxzRGlzY29ubmVjdGFibGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuYXV0b1NpemVDZWxscz0hMTtteEdyYXBoLnByb3RvdHlwZS5hdXRvU2l6ZUNlbGxzT25BZGQ9ITE7bXhHcmFwaC5wcm90b3R5cGUuYXV0b1Njcm9sbD0hMDtteEdyYXBoLnByb3RvdHlwZS5pZ25vcmVTY3JvbGxiYXJzPSExOwpteEdyYXBoLnByb3RvdHlwZS50cmFuc2xhdGVUb1Njcm9sbFBvc2l0aW9uPSExO214R3JhcGgucHJvdG90eXBlLnRpbWVyQXV0b1Njcm9sbD0hMTtteEdyYXBoLnByb3RvdHlwZS5hbGxvd0F1dG9QYW5uaW5nPSExO214R3JhcGgucHJvdG90eXBlLmF1dG9FeHRlbmQ9ITA7bXhHcmFwaC5wcm90b3R5cGUubWF4aW11bUdyYXBoQm91bmRzPW51bGw7bXhHcmFwaC5wcm90b3R5cGUubWluaW11bUdyYXBoU2l6ZT1udWxsO214R3JhcGgucHJvdG90eXBlLm1pbmltdW1Db250YWluZXJTaXplPW51bGw7bXhHcmFwaC5wcm90b3R5cGUubWF4aW11bUNvbnRhaW5lclNpemU9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5yZXNpemVDb250YWluZXI9ITE7bXhHcmFwaC5wcm90b3R5cGUuYm9yZGVyPTA7bXhHcmFwaC5wcm90b3R5cGUua2VlcEVkZ2VzSW5Gb3JlZ3JvdW5kPSExO214R3JhcGgucHJvdG90eXBlLmtlZXBFZGdlc0luQmFja2dyb3VuZD0hMTsKbXhHcmFwaC5wcm90b3R5cGUuYWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzPSEwO214R3JhcGgucHJvdG90eXBlLmNvbnN0cmFpbkNoaWxkcmVuPSEwO214R3JhcGgucHJvdG90eXBlLmNvbnN0cmFpblJlbGF0aXZlQ2hpbGRyZW49ITE7bXhHcmFwaC5wcm90b3R5cGUuZXh0ZW5kUGFyZW50cz0hMDtteEdyYXBoLnByb3RvdHlwZS5leHRlbmRQYXJlbnRzT25BZGQ9ITA7bXhHcmFwaC5wcm90b3R5cGUuZXh0ZW5kUGFyZW50c09uTW92ZT0hMTtteEdyYXBoLnByb3RvdHlwZS5yZWN1cnNpdmVSZXNpemU9ITE7bXhHcmFwaC5wcm90b3R5cGUuY29sbGFwc2VUb1ByZWZlcnJlZFNpemU9ITA7bXhHcmFwaC5wcm90b3R5cGUuem9vbUZhY3Rvcj0xLjI7bXhHcmFwaC5wcm90b3R5cGUua2VlcFNlbGVjdGlvblZpc2libGVPblpvb209ITE7bXhHcmFwaC5wcm90b3R5cGUuY2VudGVyWm9vbT0hMDtteEdyYXBoLnByb3RvdHlwZS5yZXNldFZpZXdPblJvb3RDaGFuZ2U9ITA7Cm14R3JhcGgucHJvdG90eXBlLnJlc2V0RWRnZXNPblJlc2l6ZT0hMTtteEdyYXBoLnByb3RvdHlwZS5yZXNldEVkZ2VzT25Nb3ZlPSExO214R3JhcGgucHJvdG90eXBlLnJlc2V0RWRnZXNPbkNvbm5lY3Q9ITA7bXhHcmFwaC5wcm90b3R5cGUuYWxsb3dMb29wcz0hMTtteEdyYXBoLnByb3RvdHlwZS5kZWZhdWx0TG9vcFN0eWxlPW14RWRnZVN0eWxlLkxvb3A7bXhHcmFwaC5wcm90b3R5cGUubXVsdGlncmFwaD0hMDtteEdyYXBoLnByb3RvdHlwZS5jb25uZWN0YWJsZUVkZ2VzPSExO214R3JhcGgucHJvdG90eXBlLmFsbG93RGFuZ2xpbmdFZGdlcz0hMDtteEdyYXBoLnByb3RvdHlwZS5jbG9uZUludmFsaWRFZGdlcz0hMTtteEdyYXBoLnByb3RvdHlwZS5kaXNjb25uZWN0T25Nb3ZlPSEwO214R3JhcGgucHJvdG90eXBlLmxhYmVsc1Zpc2libGU9ITA7bXhHcmFwaC5wcm90b3R5cGUuaHRtbExhYmVscz0hMTtteEdyYXBoLnByb3RvdHlwZS5zd2ltbGFuZVNlbGVjdGlvbkVuYWJsZWQ9ITA7Cm14R3JhcGgucHJvdG90eXBlLnN3aW1sYW5lTmVzdGluZz0hMDtteEdyYXBoLnByb3RvdHlwZS5zd2ltbGFuZUluZGljYXRvckNvbG9yQXR0cmlidXRlPW14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUjtteEdyYXBoLnByb3RvdHlwZS5pbWFnZUJ1bmRsZXM9bnVsbDtteEdyYXBoLnByb3RvdHlwZS5taW5GaXRTY2FsZT0uMTtteEdyYXBoLnByb3RvdHlwZS5tYXhGaXRTY2FsZT04O214R3JhcGgucHJvdG90eXBlLnBhbkR4PTA7bXhHcmFwaC5wcm90b3R5cGUucGFuRHk9MDtteEdyYXBoLnByb3RvdHlwZS5jb2xsYXBzZWRJbWFnZT1uZXcgbXhJbWFnZShteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvY29sbGFwc2VkLmdpZiIsOSw5KTtteEdyYXBoLnByb3RvdHlwZS5leHBhbmRlZEltYWdlPW5ldyBteEltYWdlKG14Q2xpZW50LmltYWdlQmFzZVBhdGgrIi9leHBhbmRlZC5naWYiLDksOSk7Cm14R3JhcGgucHJvdG90eXBlLndhcm5pbmdJbWFnZT1uZXcgbXhJbWFnZShteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvd2FybmluZyIrKG14Q2xpZW50LklTX01BQz8iLnBuZyI6Ii5naWYiKSwxNiwxNik7bXhHcmFwaC5wcm90b3R5cGUuYWxyZWFkeUNvbm5lY3RlZFJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImFscmVhZHlDb25uZWN0ZWQiOiIiO214R3JhcGgucHJvdG90eXBlLmNvbnRhaW5zVmFsaWRhdGlvbkVycm9yc1Jlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImNvbnRhaW5zVmFsaWRhdGlvbkVycm9ycyI6IiI7bXhHcmFwaC5wcm90b3R5cGUuY29sbGFwc2VFeHBhbmRSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJjb2xsYXBzZS1leHBhbmQiOiIiOwpteEdyYXBoLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe3RoaXMuY29udGFpbmVyPWE7dGhpcy5jZWxsRWRpdG9yPXRoaXMuY3JlYXRlQ2VsbEVkaXRvcigpO3RoaXMudmlldy5pbml0KCk7dGhpcy5zaXplRGlkQ2hhbmdlKCk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJtb3VzZWxlYXZlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMudG9vbHRpcEhhbmRsZXImJnRoaXMudG9vbHRpcEhhbmRsZXIuaGlkZSgpfSkpO214Q2xpZW50LklTX0lFJiYobXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInVubG9hZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3koKX0pKSxteEV2ZW50LmFkZExpc3RlbmVyKGEsInNlbGVjdHN0YXJ0IixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0VkaXRpbmcoKXx8IXRoaXMuaXNNb3VzZURvd24mJiFteEV2ZW50LmlzU2hpZnREb3duKGEpfSkpKTs4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJgphLmluc2VydEFkamFjZW50SFRNTCgiYmVmb3JlZW5kIiwiPCIrbXhDbGllbnQuVk1MX1BSRUZJWCsnOmdyb3VwIHN0eWxlPSJESVNQTEFZOiBub25lOyI+PC8nK214Q2xpZW50LlZNTF9QUkVGSVgrIjpncm91cD4iKX07Cm14R3JhcGgucHJvdG90eXBlLmNyZWF0ZUhhbmRsZXJzPWZ1bmN0aW9uKCl7dGhpcy50b29sdGlwSGFuZGxlcj10aGlzLmNyZWF0ZVRvb2x0aXBIYW5kbGVyKCk7dGhpcy50b29sdGlwSGFuZGxlci5zZXRFbmFibGVkKCExKTt0aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlcj10aGlzLmNyZWF0ZVNlbGVjdGlvbkNlbGxzSGFuZGxlcigpO3RoaXMuY29ubmVjdGlvbkhhbmRsZXI9dGhpcy5jcmVhdGVDb25uZWN0aW9uSGFuZGxlcigpO3RoaXMuY29ubmVjdGlvbkhhbmRsZXIuc2V0RW5hYmxlZCghMSk7dGhpcy5ncmFwaEhhbmRsZXI9dGhpcy5jcmVhdGVHcmFwaEhhbmRsZXIoKTt0aGlzLnBhbm5pbmdIYW5kbGVyPXRoaXMuY3JlYXRlUGFubmluZ0hhbmRsZXIoKTt0aGlzLnBhbm5pbmdIYW5kbGVyLnBhbm5pbmdFbmFibGVkPSExO3RoaXMucG9wdXBNZW51SGFuZGxlcj10aGlzLmNyZWF0ZVBvcHVwTWVudUhhbmRsZXIoKX07Cm14R3JhcGgucHJvdG90eXBlLmNyZWF0ZVRvb2x0aXBIYW5kbGVyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteFRvb2x0aXBIYW5kbGVyKHRoaXMpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVTZWxlY3Rpb25DZWxsc0hhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyKHRoaXMpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uSGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhDb25uZWN0aW9uSGFuZGxlcih0aGlzKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlR3JhcGhIYW5kbGVyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteEdyYXBoSGFuZGxlcih0aGlzKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlUGFubmluZ0hhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UGFubmluZ0hhbmRsZXIodGhpcyl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZVBvcHVwTWVudUhhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UG9wdXBNZW51SGFuZGxlcih0aGlzKX07Cm14R3JhcGgucHJvdG90eXBlLmNyZWF0ZVNlbGVjdGlvbk1vZGVsPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteEdyYXBoU2VsZWN0aW9uTW9kZWwodGhpcyl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZVN0eWxlc2hlZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14U3R5bGVzaGVldH07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlR3JhcGhWaWV3PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteEdyYXBoVmlldyh0aGlzKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlQ2VsbFJlbmRlcmVyPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBteENlbGxSZW5kZXJlcn07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlQ2VsbEVkaXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhDZWxsRWRpdG9yKHRoaXMpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRNb2RlbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsfTtteEdyYXBoLnByb3RvdHlwZS5nZXRWaWV3PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlld307Cm14R3JhcGgucHJvdG90eXBlLmdldFN0eWxlc2hlZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHlsZXNoZWV0fTtteEdyYXBoLnByb3RvdHlwZS5zZXRTdHlsZXNoZWV0PWZ1bmN0aW9uKGEpe3RoaXMuc3R5bGVzaGVldD1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Nb2RlbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsfTtteEdyYXBoLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25Nb2RlbD1mdW5jdGlvbihhKXt0aGlzLnNlbGVjdGlvbk1vZGVsPWF9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25DZWxsc0ZvckNoYW5nZXM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9bmV3IG14RGljdGlvbmFyeSxkPVtdLGU9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYoIWMuZ2V0KGEpJiZ0aGlzLm1vZGVsLmNvbnRhaW5zKGEpKWlmKHRoaXMubW9kZWwuaXNFZGdlKGEpfHx0aGlzLm1vZGVsLmlzVmVydGV4KGEpKWMucHV0KGEsITApLGQucHVzaChhKTtlbHNlIGZvcih2YXIgYj10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSksZj0wO2Y8YjtmKyspZSh0aGlzLm1vZGVsLmdldENoaWxkQXQoYSxmKSl9KSxmPTA7ZjxhLmxlbmd0aDtmKyspe3ZhciBnPWFbZl07aWYoZy5jb25zdHJ1Y3RvciE9bXhSb290Q2hhbmdlJiYobnVsbD09Ynx8IWIoZykpKXt2YXIgaz1udWxsO2cgaW5zdGFuY2VvZiBteENoaWxkQ2hhbmdlP2s9Zy5jaGlsZDpudWxsIT1nLmNlbGwmJmcuY2VsbCBpbnN0YW5jZW9mIG14Q2VsbCYmKGs9Zy5jZWxsKTtudWxsIT0KayYmZShrKX19cmV0dXJuIGR9O214R3JhcGgucHJvdG90eXBlLmdyYXBoTW9kZWxDaGFuZ2VkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMucHJvY2Vzc0NoYW5nZShhW2JdKTt0aGlzLnVwZGF0ZVNlbGVjdGlvbigpO3RoaXMudmlldy52YWxpZGF0ZSgpO3RoaXMuc2l6ZURpZENoYW5nZSgpfTsKbXhHcmFwaC5wcm90b3R5cGUudXBkYXRlU2VsZWN0aW9uPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKylpZih0aGlzLm1vZGVsLmNvbnRhaW5zKGFbY10pJiZ0aGlzLmlzQ2VsbFZpc2libGUoYVtjXSkpZm9yKHZhciBkPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbY10pO251bGwhPWQmJmQhPXRoaXMudmlldy5jdXJyZW50Um9vdDspe2lmKHRoaXMuaXNDZWxsQ29sbGFwc2VkKGQpfHwhdGhpcy5pc0NlbGxWaXNpYmxlKGQpKXtiLnB1c2goYVtjXSk7YnJlYWt9ZD10aGlzLm1vZGVsLmdldFBhcmVudChkKX1lbHNlIGIucHVzaChhW2NdKTt0aGlzLnJlbW92ZVNlbGVjdGlvbkNlbGxzKGIpfTsKbXhHcmFwaC5wcm90b3R5cGUucHJvY2Vzc0NoYW5nZT1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgbXhSb290Q2hhbmdlKXRoaXMuY2xlYXJTZWxlY3Rpb24oKSx0aGlzLnNldERlZmF1bHRQYXJlbnQobnVsbCksdGhpcy5yZW1vdmVTdGF0ZUZvckNlbGwoYS5wcmV2aW91cyksdGhpcy5yZXNldFZpZXdPblJvb3RDaGFuZ2UmJih0aGlzLnZpZXcuc2NhbGU9MSx0aGlzLnZpZXcudHJhbnNsYXRlLng9MCx0aGlzLnZpZXcudHJhbnNsYXRlLnk9MCksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ST09UKSk7ZWxzZSBpZihhIGluc3RhbmNlb2YgbXhDaGlsZENoYW5nZSl7dmFyIGI9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYS5jaGlsZCk7dGhpcy52aWV3LmludmFsaWRhdGUoYS5jaGlsZCwhMCwhMCk7aWYoIXRoaXMubW9kZWwuY29udGFpbnMoYil8fHRoaXMuaXNDZWxsQ29sbGFwc2VkKGIpKXRoaXMudmlldy5pbnZhbGlkYXRlKGEuY2hpbGQsITAsITApLHRoaXMucmVtb3ZlU3RhdGVGb3JDZWxsKGEuY2hpbGQpLAp0aGlzLnZpZXcuY3VycmVudFJvb3Q9PWEuY2hpbGQmJnRoaXMuaG9tZSgpO2IhPWEucHJldmlvdXMmJihudWxsIT1iJiZ0aGlzLnZpZXcuaW52YWxpZGF0ZShiLCExLCExKSxudWxsIT1hLnByZXZpb3VzJiZ0aGlzLnZpZXcuaW52YWxpZGF0ZShhLnByZXZpb3VzLCExLCExKSl9ZWxzZSBhIGluc3RhbmNlb2YgbXhUZXJtaW5hbENoYW5nZXx8YSBpbnN0YW5jZW9mIG14R2VvbWV0cnlDaGFuZ2U/KGEgaW5zdGFuY2VvZiBteFRlcm1pbmFsQ2hhbmdlfHxudWxsPT1hLnByZXZpb3VzJiZudWxsIT1hLmdlb21ldHJ5fHxudWxsIT1hLnByZXZpb3VzJiYhYS5wcmV2aW91cy5lcXVhbHMoYS5nZW9tZXRyeSkpJiZ0aGlzLnZpZXcuaW52YWxpZGF0ZShhLmNlbGwpOmEgaW5zdGFuY2VvZiBteFZhbHVlQ2hhbmdlP3RoaXMudmlldy5pbnZhbGlkYXRlKGEuY2VsbCwhMSwhMSk6YSBpbnN0YW5jZW9mIG14U3R5bGVDaGFuZ2U/KHRoaXMudmlldy5pbnZhbGlkYXRlKGEuY2VsbCwhMCwhMCksYT10aGlzLnZpZXcuZ2V0U3RhdGUoYS5jZWxsKSwKbnVsbCE9YSYmKGEuaW52YWxpZFN0eWxlPSEwKSk6bnVsbCE9YS5jZWxsJiZhLmNlbGwgaW5zdGFuY2VvZiBteENlbGwmJnRoaXMucmVtb3ZlU3RhdGVGb3JDZWxsKGEuY2VsbCl9O214R3JhcGgucHJvdG90eXBlLnJlbW92ZVN0YXRlRm9yQ2VsbD1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpLGM9MDtjPGI7YysrKXRoaXMucmVtb3ZlU3RhdGVGb3JDZWxsKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGMpKTt0aGlzLnZpZXcuaW52YWxpZGF0ZShhLCExLCEwKTt0aGlzLnZpZXcucmVtb3ZlU3RhdGUoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5hZGRDZWxsT3ZlcmxheT1mdW5jdGlvbihhLGIpe251bGw9PWEub3ZlcmxheXMmJihhLm92ZXJsYXlzPVtdKTthLm92ZXJsYXlzLnB1c2goYik7dmFyIGM9dGhpcy52aWV3LmdldFN0YXRlKGEpO251bGwhPWMmJnRoaXMuY2VsbFJlbmRlcmVyLnJlZHJhdyhjKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFERF9PVkVSTEFZLCJjZWxsIixhLCJvdmVybGF5IixiKSk7cmV0dXJuIGJ9O214R3JhcGgucHJvdG90eXBlLmdldENlbGxPdmVybGF5cz1mdW5jdGlvbihhKXtyZXR1cm4gYS5vdmVybGF5c307Cm14R3JhcGgucHJvdG90eXBlLnJlbW92ZUNlbGxPdmVybGF5PWZ1bmN0aW9uKGEsYil7aWYobnVsbD09Yil0aGlzLnJlbW92ZUNlbGxPdmVybGF5cyhhKTtlbHNle3ZhciBjPW14VXRpbHMuaW5kZXhPZihhLm92ZXJsYXlzLGIpOzA8PWM/KGEub3ZlcmxheXMuc3BsaWNlKGMsMSksMD09YS5vdmVybGF5cy5sZW5ndGgmJihhLm92ZXJsYXlzPW51bGwpLGM9dGhpcy52aWV3LmdldFN0YXRlKGEpLG51bGwhPWMmJnRoaXMuY2VsbFJlbmRlcmVyLnJlZHJhdyhjKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFTU9WRV9PVkVSTEFZLCJjZWxsIixhLCJvdmVybGF5IixiKSkpOmI9bnVsbH1yZXR1cm4gYn07Cm14R3JhcGgucHJvdG90eXBlLnJlbW92ZUNlbGxPdmVybGF5cz1mdW5jdGlvbihhKXt2YXIgYj1hLm92ZXJsYXlzO2lmKG51bGwhPWIpe2Eub3ZlcmxheXM9bnVsbDt2YXIgYz10aGlzLnZpZXcuZ2V0U3RhdGUoYSk7bnVsbCE9YyYmdGhpcy5jZWxsUmVuZGVyZXIucmVkcmF3KGMpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRU1PVkVfT1ZFUkxBWSwiY2VsbCIsYSwib3ZlcmxheSIsYltjXSkpfXJldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5jbGVhckNlbGxPdmVybGF5cz1mdW5jdGlvbihhKXthPW51bGwhPWE/YTp0aGlzLm1vZGVsLmdldFJvb3QoKTt0aGlzLnJlbW92ZUNlbGxPdmVybGF5cyhhKTtmb3IodmFyIGI9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpLGM9MDtjPGI7YysrKXt2YXIgZD10aGlzLm1vZGVsLmdldENoaWxkQXQoYSxjKTt0aGlzLmNsZWFyQ2VsbE92ZXJsYXlzKGQpfX07Cm14R3JhcGgucHJvdG90eXBlLnNldENlbGxXYXJuaW5nPWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPWImJjA8Yi5sZW5ndGgpcmV0dXJuIGM9bnVsbCE9Yz9jOnRoaXMud2FybmluZ0ltYWdlLGI9bmV3IG14Q2VsbE92ZXJsYXkoYywiPGZvbnQgY29sb3I9cmVkPiIrYisiPC9mb250PiIpLGQmJmIuYWRkTGlzdGVuZXIobXhFdmVudC5DTElDSyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGMpe3RoaXMuaXNFbmFibGVkKCkmJnRoaXMuc2V0U2VsZWN0aW9uQ2VsbChhKX0pKSx0aGlzLmFkZENlbGxPdmVybGF5KGEsYik7dGhpcy5yZW1vdmVDZWxsT3ZlcmxheXMoYSk7cmV0dXJuIG51bGx9O214R3JhcGgucHJvdG90eXBlLnN0YXJ0RWRpdGluZz1mdW5jdGlvbihhKXt0aGlzLnN0YXJ0RWRpdGluZ0F0Q2VsbChudWxsLGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuc3RhcnRFZGl0aW5nQXRDZWxsPWZ1bmN0aW9uKGEsYil7bnVsbCE9YiYmbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiKXx8KG51bGw9PWEmJihhPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbCgpLG51bGw9PWF8fHRoaXMuaXNDZWxsRWRpdGFibGUoYSl8fChhPW51bGwpKSxudWxsIT1hJiYodGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TVEFSVF9FRElUSU5HLCJjZWxsIixhLCJldmVudCIsYikpLHRoaXMuY2VsbEVkaXRvci5zdGFydEVkaXRpbmcoYSxiKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVESVRJTkdfU1RBUlRFRCwiY2VsbCIsYSwiZXZlbnQiLGIpKSkpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRFZGl0aW5nVmFsdWU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWVUb1N0cmluZyhhKX07Cm14R3JhcGgucHJvdG90eXBlLnN0b3BFZGl0aW5nPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbEVkaXRvci5zdG9wRWRpdGluZyhhKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVESVRJTkdfU1RPUFBFRCwiY2FuY2VsIixhKSl9O214R3JhcGgucHJvdG90eXBlLmxhYmVsQ2hhbmdlZD1mdW5jdGlvbihhLGIsYyl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD1hLnZhbHVlO3RoaXMuY2VsbExhYmVsQ2hhbmdlZChhLGIsdGhpcy5pc0F1dG9TaXplQ2VsbChhKSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5MQUJFTF9DSEFOR0VELCJjZWxsIixhLCJ2YWx1ZSIsYiwib2xkIixkLCJldmVudCIsYykpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmNlbGxMYWJlbENoYW5nZWQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5tb2RlbC5zZXRWYWx1ZShhLGIpLGMmJnRoaXMuY2VsbFNpemVVcGRhdGVkKGEsITEpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19O214R3JhcGgucHJvdG90eXBlLmVzY2FwZT1mdW5jdGlvbihhKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkVTQ0FQRSwiZXZlbnQiLGEpKX07Cm14R3JhcGgucHJvdG90eXBlLmNsaWNrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0RXZlbnQoKSxjPWEuZ2V0Q2VsbCgpLGQ9bmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DTElDSywiZXZlbnQiLGIsImNlbGwiLGMpO2EuaXNDb25zdW1lZCgpJiZkLmNvbnN1bWUoKTt0aGlzLmZpcmVFdmVudChkKTtpZih0aGlzLmlzRW5hYmxlZCgpJiYhbXhFdmVudC5pc0NvbnN1bWVkKGIpJiYhZC5pc0NvbnN1bWVkKCkpe2lmKG51bGwhPWMpe2lmKHRoaXMuaXNUcmFuc3BhcmVudENsaWNrRXZlbnQoYikpe3ZhciBlPSExO2E9dGhpcy5nZXRDZWxsQXQoYS5ncmFwaFgsYS5ncmFwaFksbnVsbCxudWxsLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pc0NlbGxTZWxlY3RlZChhLmNlbGwpO2U9ZXx8YjtyZXR1cm4hZXx8Ynx8YS5jZWxsIT1jJiZ0aGlzLm1vZGVsLmlzQW5jZXN0b3IoYS5jZWxsLGMpfSkpO251bGwhPWEmJihjPWEpfX1lbHNlIGlmKHRoaXMuaXNTd2ltbGFuZVNlbGVjdGlvbkVuYWJsZWQoKSYmCihjPXRoaXMuZ2V0U3dpbWxhbmVBdChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCkpLCF0aGlzLmlzVG9nZ2xlRXZlbnQoYikmJm51bGwhPWMpKXtkPWM7Zm9yKGE9W107bnVsbCE9ZDspe3ZhciBkPXRoaXMubW9kZWwuZ2V0UGFyZW50KGQpLGY9dGhpcy52aWV3LmdldFN0YXRlKGQpO3RoaXMuaXNTd2ltbGFuZShkKSYmbnVsbCE9ZiYmYS5wdXNoKGQpfWlmKDA8YS5sZW5ndGgpZm9yKGE9YS5yZXZlcnNlKCksYS5zcGxpY2UoMCwwLGMpLGEucHVzaChjKSxkPTA7ZDxhLmxlbmd0aC0yO2QrKyl0aGlzLmlzQ2VsbFNlbGVjdGVkKGFbZF0pJiYoYz1hW2QrMV0pfW51bGwhPWM/dGhpcy5zZWxlY3RDZWxsRm9yRXZlbnQoYyxiKTp0aGlzLmlzVG9nZ2xlRXZlbnQoYil8fHRoaXMuY2xlYXJTZWxlY3Rpb24oKX19OwpteEdyYXBoLnByb3RvdHlwZS5pc1NpYmxpbmdTZWxlY3RlZD1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5tb2RlbCxjPWIuZ2V0UGFyZW50KGEpLGQ9Yi5nZXRDaGlsZENvdW50KGMpLGU9MDtlPGQ7ZSsrKXt2YXIgZj1iLmdldENoaWxkQXQoYyxlKTtpZihhIT1mJiZ0aGlzLmlzQ2VsbFNlbGVjdGVkKGYpKXJldHVybiEwfXJldHVybiExfTtteEdyYXBoLnByb3RvdHlwZS5kYmxDbGljaz1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRE9VQkxFX0NMSUNLLCJldmVudCIsYSwiY2VsbCIsYik7dGhpcy5maXJlRXZlbnQoYyk7IXRoaXMuaXNFbmFibGVkKCl8fG14RXZlbnQuaXNDb25zdW1lZChhKXx8Yy5pc0NvbnN1bWVkKCl8fG51bGw9PWJ8fCF0aGlzLmlzQ2VsbEVkaXRhYmxlKGIpfHx0aGlzLmlzRWRpdGluZyhiKXx8KHRoaXMuc3RhcnRFZGl0aW5nQXRDZWxsKGIsYSksbXhFdmVudC5jb25zdW1lKGEpKX07Cm14R3JhcGgucHJvdG90eXBlLnRhcEFuZEhvbGQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRFdmVudCgpLGM9bmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5UQVBfQU5EX0hPTEQsImV2ZW50IixiLCJjZWxsIixhLmdldENlbGwoKSk7dGhpcy5maXJlRXZlbnQoYyk7Yy5pc0NvbnN1bWVkKCkmJih0aGlzLnBhbm5pbmdIYW5kbGVyLnBhbm5pbmdUcmlnZ2VyPSExKTt0aGlzLmlzRW5hYmxlZCgpJiYhbXhFdmVudC5pc0NvbnN1bWVkKGIpJiYhYy5pc0NvbnN1bWVkKCkmJnRoaXMuY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCkmJihiPXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1hcmtlci5nZXRDZWxsKGEpKSxudWxsIT1iJiYodGhpcy5jb25uZWN0aW9uSGFuZGxlci5tYXJrZXIuY3VycmVudENvbG9yPXRoaXMuY29ubmVjdGlvbkhhbmRsZXIubWFya2VyLnZhbGlkQ29sb3IsdGhpcy5jb25uZWN0aW9uSGFuZGxlci5tYXJrZXIubWFya2VkU3RhdGU9YiwKdGhpcy5jb25uZWN0aW9uSGFuZGxlci5tYXJrZXIubWFyaygpLHRoaXMuY29ubmVjdGlvbkhhbmRsZXIuZmlyc3Q9bmV3IG14UG9pbnQoYS5nZXRHcmFwaFgoKSxhLmdldEdyYXBoWSgpKSx0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmVkZ2VTdGF0ZT10aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmNyZWF0ZUVkZ2VTdGF0ZShhKSx0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLnByZXZpb3VzPWIsdGhpcy5jb25uZWN0aW9uSGFuZGxlci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TVEFSVCwic3RhdGUiLHRoaXMuY29ubmVjdGlvbkhhbmRsZXIucHJldmlvdXMpKSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuc2Nyb2xsUG9pbnRUb1Zpc2libGU9ZnVuY3Rpb24oYSxiLGMsZCl7aWYodGhpcy50aW1lckF1dG9TY3JvbGx8fCF0aGlzLmlnbm9yZVNjcm9sbGJhcnMmJiFteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpKXRoaXMuYWxsb3dBdXRvUGFubmluZyYmIXRoaXMucGFubmluZ0hhbmRsZXIuaXNBY3RpdmUoKSYmKG51bGw9PXRoaXMucGFubmluZ01hbmFnZXImJih0aGlzLnBhbm5pbmdNYW5hZ2VyPXRoaXMuY3JlYXRlUGFubmluZ01hbmFnZXIoKSksdGhpcy5wYW5uaW5nTWFuYWdlci5wYW5UbyhhK3RoaXMucGFuRHgsYit0aGlzLnBhbkR5KSk7ZWxzZXt2YXIgZT10aGlzLmNvbnRhaW5lcjtkPW51bGwhPWQ/ZDoyMDtpZihhPj1lLnNjcm9sbExlZnQmJmI+PWUuc2Nyb2xsVG9wJiZhPD1lLnNjcm9sbExlZnQrZS5jbGllbnRXaWR0aCYmYjw9ZS5zY3JvbGxUb3ArZS5jbGllbnRIZWlnaHQpe3ZhciBmPWUuc2Nyb2xsTGVmdCtlLmNsaWVudFdpZHRoLQphO2lmKGY8ZCl7aWYoYT1lLnNjcm9sbExlZnQsZS5zY3JvbGxMZWZ0Kz1kLWYsYyYmYT09ZS5zY3JvbGxMZWZ0KXtpZih0aGlzLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHKXthPXRoaXMudmlldy5nZXREcmF3UGFuZSgpLm93bmVyU1ZHRWxlbWVudDt2YXIgZz10aGlzLmNvbnRhaW5lci5zY3JvbGxXaWR0aCtkLWZ9ZWxzZSBnPU1hdGgubWF4KGUuY2xpZW50V2lkdGgsZS5zY3JvbGxXaWR0aCkrZC1mLGE9dGhpcy52aWV3LmdldENhbnZhcygpO2Euc3R5bGUud2lkdGg9ZysicHgiO2Uuc2Nyb2xsTGVmdCs9ZC1mfX1lbHNlIGY9YS1lLnNjcm9sbExlZnQsZjxkJiYoZS5zY3JvbGxMZWZ0LT1kLWYpO2Y9ZS5zY3JvbGxUb3ArZS5jbGllbnRIZWlnaHQtYjtmPGQ/KGE9ZS5zY3JvbGxUb3AsZS5zY3JvbGxUb3ArPWQtZixhPT1lLnNjcm9sbFRvcCYmYyYmKHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/KGE9dGhpcy52aWV3LmdldERyYXdQYW5lKCkub3duZXJTVkdFbGVtZW50LApiPXRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodCtkLWYpOihiPU1hdGgubWF4KGUuY2xpZW50SGVpZ2h0LGUuc2Nyb2xsSGVpZ2h0KStkLWYsYT10aGlzLnZpZXcuZ2V0Q2FudmFzKCkpLGEuc3R5bGUuaGVpZ2h0PWIrInB4IixlLnNjcm9sbFRvcCs9ZC1mKSk6KGY9Yi1lLnNjcm9sbFRvcCxmPGQmJihlLnNjcm9sbFRvcC09ZC1mKSl9fX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlUGFubmluZ01hbmFnZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UGFubmluZ01hbmFnZXIodGhpcyl9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRCb3JkZXJTaXplcz1mdW5jdGlvbigpe3ZhciBhPW14VXRpbHMuZ2V0Q3VycmVudFN0eWxlKHRoaXMuY29udGFpbmVyKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKG14VXRpbHMucGFyc2VDc3NOdW1iZXIoYS5wYWRkaW5nTGVmdCkrKCJub25lIiE9YS5ib3JkZXJMZWZ0U3R5bGU/bXhVdGlscy5wYXJzZUNzc051bWJlcihhLmJvcmRlckxlZnRXaWR0aCk6MCksbXhVdGlscy5wYXJzZUNzc051bWJlcihhLnBhZGRpbmdUb3ApKygibm9uZSIhPWEuYm9yZGVyVG9wU3R5bGU/bXhVdGlscy5wYXJzZUNzc051bWJlcihhLmJvcmRlclRvcFdpZHRoKTowKSxteFV0aWxzLnBhcnNlQ3NzTnVtYmVyKGEucGFkZGluZ1JpZ2h0KSsoIm5vbmUiIT1hLmJvcmRlclJpZ2h0U3R5bGU/bXhVdGlscy5wYXJzZUNzc051bWJlcihhLmJvcmRlclJpZ2h0V2lkdGgpOjApLG14VXRpbHMucGFyc2VDc3NOdW1iZXIoYS5wYWRkaW5nQm90dG9tKSsoIm5vbmUiIT1hLmJvcmRlckJvdHRvbVN0eWxlPwpteFV0aWxzLnBhcnNlQ3NzTnVtYmVyKGEuYm9yZGVyQm90dG9tV2lkdGgpOjApKX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0UHJlZmVycmVkUGFnZVNpemU9ZnVuY3Rpb24oYSxiLGMpe2E9dGhpcy52aWV3LnRyYW5zbGF0ZTt2YXIgZD10aGlzLnBhZ2VGb3JtYXQsZT10aGlzLnBhZ2VTY2FsZSxkPW5ldyBteFJlY3RhbmdsZSgwLDAsTWF0aC5jZWlsKGQud2lkdGgqZSksTWF0aC5jZWlsKGQuaGVpZ2h0KmUpKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCwodGhpcy5wYWdlQnJlYWtzVmlzaWJsZT9NYXRoLmNlaWwoYi9kLndpZHRoKToxKSpkLndpZHRoKzIrYS54LCh0aGlzLnBhZ2VCcmVha3NWaXNpYmxlP01hdGguY2VpbChjL2QuaGVpZ2h0KToxKSpkLmhlaWdodCsyK2EueSl9OwpteEdyYXBoLnByb3RvdHlwZS5maXQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7aWYobnVsbCE9dGhpcy5jb250YWluZXIpe2E9bnVsbCE9YT9hOnRoaXMuZ2V0Qm9yZGVyKCk7Yj1udWxsIT1iP2I6ITE7Yz1udWxsIT1jP2M6MDtkPW51bGwhPWQ/ZDohMDtlPW51bGwhPWU/ZTohMTtmPW51bGwhPWY/ZjohMTt2YXIgaz10aGlzLmdldEJvcmRlclNpemVzKCksbD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aC1rLngtay53aWR0aC0xLG09bnVsbCE9Zz9nOnRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodC1rLnktay5oZWlnaHQtMTtnPXRoaXMudmlldy5nZXRHcmFwaEJvdW5kcygpO2lmKDA8Zy53aWR0aCYmMDxnLmhlaWdodCl7YiYmbnVsbCE9Zy54JiZudWxsIT1nLnkmJihnPWcuY2xvbmUoKSxnLndpZHRoKz1nLngsZy5oZWlnaHQrPWcueSxnLng9MCxnLnk9MCk7dmFyIGs9dGhpcy52aWV3LnNjYWxlLG49Zy53aWR0aC9rLHA9Zy5oZWlnaHQvaztudWxsIT10aGlzLmJhY2tncm91bmRJbWFnZSYmCihuPU1hdGgubWF4KG4sdGhpcy5iYWNrZ3JvdW5kSW1hZ2Uud2lkdGgtZy54L2spLHA9TWF0aC5tYXgocCx0aGlzLmJhY2tncm91bmRJbWFnZS5oZWlnaHQtZy55L2spKTt2YXIgcT0oYj9hOjIqYSkrYysxLGw9bC1xLG09bS1xO2U9ZT9tL3A6Zj9sL246TWF0aC5taW4obC9uLG0vcCk7bnVsbCE9dGhpcy5taW5GaXRTY2FsZSYmKGU9TWF0aC5tYXgoZSx0aGlzLm1pbkZpdFNjYWxlKSk7bnVsbCE9dGhpcy5tYXhGaXRTY2FsZSYmKGU9TWF0aC5taW4oZSx0aGlzLm1heEZpdFNjYWxlKSk7aWYoZCliP3RoaXMudmlldy5zY2FsZSE9ZSYmdGhpcy52aWV3LnNldFNjYWxlKGUpOm14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lcik/KHRoaXMudmlldy5zZXRTY2FsZShlKSxhPXRoaXMuZ2V0R3JhcGhCb3VuZHMoKSxudWxsIT1hLngmJih0aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0PWEueCksbnVsbCE9YS55JiYodGhpcy5jb250YWluZXIuc2Nyb2xsVG9wPWEueSkpOnRoaXMudmlldy5zY2FsZUFuZFRyYW5zbGF0ZShlLApudWxsIT1nLng/TWF0aC5mbG9vcih0aGlzLnZpZXcudHJhbnNsYXRlLngtZy54L2srYS9lK2MvMik6YSxudWxsIT1nLnk/TWF0aC5mbG9vcih0aGlzLnZpZXcudHJhbnNsYXRlLnktZy55L2srYS9lK2MvMik6YSk7ZWxzZSByZXR1cm4gZX19cmV0dXJuIHRoaXMudmlldy5zY2FsZX07Cm14R3JhcGgucHJvdG90eXBlLnNpemVEaWRDaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEdyYXBoQm91bmRzKCk7aWYobnVsbCE9dGhpcy5jb250YWluZXIpe3ZhciBiPXRoaXMuZ2V0Qm9yZGVyKCksYz1NYXRoLm1heCgwLGEueCkrYS53aWR0aCsyKmIsYj1NYXRoLm1heCgwLGEueSkrYS5oZWlnaHQrMipiO251bGwhPXRoaXMubWluaW11bUNvbnRhaW5lclNpemUmJihjPU1hdGgubWF4KGMsdGhpcy5taW5pbXVtQ29udGFpbmVyU2l6ZS53aWR0aCksYj1NYXRoLm1heChiLHRoaXMubWluaW11bUNvbnRhaW5lclNpemUuaGVpZ2h0KSk7dGhpcy5yZXNpemVDb250YWluZXImJnRoaXMuZG9SZXNpemVDb250YWluZXIoYyxiKTtpZih0aGlzLnByZWZlclBhZ2VTaXplfHwhbXhDbGllbnQuSVNfSUUmJnRoaXMucGFnZVZpc2libGUpe3ZhciBkPXRoaXMuZ2V0UHJlZmVycmVkUGFnZVNpemUoYSxNYXRoLm1heCgxLGMpLE1hdGgubWF4KDEsYikpO251bGwhPWQmJihjPWQud2lkdGgqdGhpcy52aWV3LnNjYWxlLApiPWQuaGVpZ2h0KnRoaXMudmlldy5zY2FsZSl9bnVsbCE9dGhpcy5taW5pbXVtR3JhcGhTaXplJiYoYz1NYXRoLm1heChjLHRoaXMubWluaW11bUdyYXBoU2l6ZS53aWR0aCp0aGlzLnZpZXcuc2NhbGUpLGI9TWF0aC5tYXgoYix0aGlzLm1pbmltdW1HcmFwaFNpemUuaGVpZ2h0KnRoaXMudmlldy5zY2FsZSkpO2M9TWF0aC5jZWlsKGMpO2I9TWF0aC5jZWlsKGIpO3RoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/KGQ9dGhpcy52aWV3LmdldERyYXdQYW5lKCkub3duZXJTVkdFbGVtZW50LG51bGwhPWQmJihkLnN0eWxlLm1pbldpZHRoPU1hdGgubWF4KDEsYykrInB4IixkLnN0eWxlLm1pbkhlaWdodD1NYXRoLm1heCgxLGIpKyJweCIsZC5zdHlsZS53aWR0aD0iMTAwJSIsZC5zdHlsZS5oZWlnaHQ9IjEwMCUiKSk6bXhDbGllbnQuSVNfUVVJUktTP3RoaXMudmlldy51cGRhdGVIdG1sQ2FudmFzU2l6ZShNYXRoLm1heCgxLGMpLE1hdGgubWF4KDEsYikpOih0aGlzLnZpZXcuY2FudmFzLnN0eWxlLm1pbldpZHRoPQpNYXRoLm1heCgxLGMpKyJweCIsdGhpcy52aWV3LmNhbnZhcy5zdHlsZS5taW5IZWlnaHQ9TWF0aC5tYXgoMSxiKSsicHgiKTt0aGlzLnVwZGF0ZVBhZ2VCcmVha3ModGhpcy5wYWdlQnJlYWtzVmlzaWJsZSxjLGIpfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0laRSwiYm91bmRzIixhKSl9O214R3JhcGgucHJvdG90eXBlLmRvUmVzaXplQ29udGFpbmVyPWZ1bmN0aW9uKGEsYil7bnVsbCE9dGhpcy5tYXhpbXVtQ29udGFpbmVyU2l6ZSYmKGE9TWF0aC5taW4odGhpcy5tYXhpbXVtQ29udGFpbmVyU2l6ZS53aWR0aCxhKSxiPU1hdGgubWluKHRoaXMubWF4aW11bUNvbnRhaW5lclNpemUuaGVpZ2h0LGIpKTt0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aD1NYXRoLmNlaWwoYSkrInB4Ijt0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9TWF0aC5jZWlsKGIpKyJweCJ9OwpteEdyYXBoLnByb3RvdHlwZS51cGRhdGVQYWdlQnJlYWtzPWZ1bmN0aW9uKGEsYixjKXtiPXRoaXMudmlldy5zY2FsZTtjPXRoaXMudmlldy50cmFuc2xhdGU7dmFyIGQ9dGhpcy5wYWdlRm9ybWF0LGU9Yip0aGlzLnBhZ2VTY2FsZSxmPW5ldyBteFJlY3RhbmdsZSgwLDAsZC53aWR0aCplLGQuaGVpZ2h0KmUpLGQ9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZSh0aGlzLmdldEdyYXBoQm91bmRzKCkpO2Qud2lkdGg9TWF0aC5tYXgoMSxkLndpZHRoKTtkLmhlaWdodD1NYXRoLm1heCgxLGQuaGVpZ2h0KTtmLng9TWF0aC5mbG9vcigoZC54LWMueCpiKS9mLndpZHRoKSpmLndpZHRoK2MueCpiO2YueT1NYXRoLmZsb29yKChkLnktYy55KmIpL2YuaGVpZ2h0KSpmLmhlaWdodCtjLnkqYjtkLndpZHRoPU1hdGguY2VpbCgoZC53aWR0aCsoZC54LWYueCkpL2Yud2lkdGgpKmYud2lkdGg7ZC5oZWlnaHQ9TWF0aC5jZWlsKChkLmhlaWdodCsoZC55LWYueSkpL2YuaGVpZ2h0KSpmLmhlaWdodDsKdmFyIGc9KGE9YSYmTWF0aC5taW4oZi53aWR0aCxmLmhlaWdodCk+dGhpcy5taW5QYWdlQnJlYWtEaXN0KT9NYXRoLmNlaWwoZC5oZWlnaHQvZi5oZWlnaHQpKzE6MCxrPWE/TWF0aC5jZWlsKGQud2lkdGgvZi53aWR0aCkrMTowLGw9KGstMSkqZi53aWR0aCxtPShnLTEpKmYuaGVpZ2h0O251bGw9PXRoaXMuaG9yaXpvbnRhbFBhZ2VCcmVha3MmJjA8ZyYmKHRoaXMuaG9yaXpvbnRhbFBhZ2VCcmVha3M9W10pO251bGw9PXRoaXMudmVydGljYWxQYWdlQnJlYWtzJiYwPGsmJih0aGlzLnZlcnRpY2FsUGFnZUJyZWFrcz1bXSk7YT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZihudWxsIT1hKXtmb3IodmFyIGI9YT09dGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcz9nOmssYz0wO2M8PWI7YysrKXt2YXIgZD1hPT10aGlzLmhvcml6b250YWxQYWdlQnJlYWtzP1tuZXcgbXhQb2ludChNYXRoLnJvdW5kKGYueCksTWF0aC5yb3VuZChmLnkrYypmLmhlaWdodCkpLG5ldyBteFBvaW50KE1hdGgucm91bmQoZi54KwpsKSxNYXRoLnJvdW5kKGYueStjKmYuaGVpZ2h0KSldOltuZXcgbXhQb2ludChNYXRoLnJvdW5kKGYueCtjKmYud2lkdGgpLE1hdGgucm91bmQoZi55KSksbmV3IG14UG9pbnQoTWF0aC5yb3VuZChmLngrYypmLndpZHRoKSxNYXRoLnJvdW5kKGYueSttKSldO251bGwhPWFbY10/KGFbY10ucG9pbnRzPWQsYVtjXS5yZWRyYXcoKSk6KGQ9bmV3IG14UG9seWxpbmUoZCx0aGlzLnBhZ2VCcmVha0NvbG9yKSxkLmRpYWxlY3Q9dGhpcy5kaWFsZWN0LGQucG9pbnRlckV2ZW50cz0hMSxkLmlzRGFzaGVkPXRoaXMucGFnZUJyZWFrRGFzaGVkLGQuaW5pdCh0aGlzLnZpZXcuYmFja2dyb3VuZFBhbmUpLGQucmVkcmF3KCksYVtjXT1kKX1mb3IoYz1iO2M8YS5sZW5ndGg7YysrKWFbY10uZGVzdHJveSgpO2Euc3BsaWNlKGIsYS5sZW5ndGgtYil9fSk7YSh0aGlzLmhvcml6b250YWxQYWdlQnJlYWtzKTthKHRoaXMudmVydGljYWxQYWdlQnJlYWtzKX07Cm14R3JhcGgucHJvdG90eXBlLmdldEN1cnJlbnRDZWxsU3R5bGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iP251bGw6dGhpcy52aWV3LmdldFN0YXRlKGEpO3JldHVybiBudWxsIT1jP2Muc3R5bGU6dGhpcy5nZXRDZWxsU3R5bGUoYSl9O214R3JhcGgucHJvdG90eXBlLmdldENlbGxTdHlsZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm1vZGVsLmdldFN0eWxlKGEpO2E9dGhpcy5tb2RlbC5pc0VkZ2UoYSk/dGhpcy5zdHlsZXNoZWV0LmdldERlZmF1bHRFZGdlU3R5bGUoKTp0aGlzLnN0eWxlc2hlZXQuZ2V0RGVmYXVsdFZlcnRleFN0eWxlKCk7bnVsbCE9YiYmKGE9dGhpcy5wb3N0UHJvY2Vzc0NlbGxTdHlsZSh0aGlzLnN0eWxlc2hlZXQuZ2V0Q2VsbFN0eWxlKGIsYSkpKTtudWxsPT1hJiYoYT17fSk7cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5wb3N0UHJvY2Vzc0NlbGxTdHlsZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj1hW214Q29uc3RhbnRzLlNUWUxFX0lNQUdFXSxjPXRoaXMuZ2V0SW1hZ2VGcm9tQnVuZGxlcyhiKTtudWxsIT1jP2FbbXhDb25zdGFudHMuU1RZTEVfSU1BR0VdPWM6Yz1iO251bGwhPWMmJiJkYXRhOmltYWdlLyI9PWMuc3Vic3RyaW5nKDAsMTEpJiYoImRhdGE6aW1hZ2Uvc3ZnK3htbCw8Ij09Yy5zdWJzdHJpbmcoMCwyMCk/Yz1jLnN1YnN0cmluZygwLDE5KStlbmNvZGVVUklDb21wb25lbnQoYy5zdWJzdHJpbmcoMTkpKToiZGF0YTppbWFnZS9zdmcreG1sLCUzQyIhPWMuc3Vic3RyaW5nKDAsMjIpJiYoYj1jLmluZGV4T2YoIiwiKSwwPGImJiI7YmFzZTY0LCIhPWMuc3Vic3RyaW5nKGItNyxiKzEpJiYoYz1jLnN1YnN0cmluZygwLGIpKyI7YmFzZTY0LCIrYy5zdWJzdHJpbmcoYisxKSkpLGFbbXhDb25zdGFudHMuU1RZTEVfSU1BR0VdPWMpfXJldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbFN0eWxlPWZ1bmN0aW9uKGEsYil7Yj1ifHx0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7aWYobnVsbCE9Yil7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl0aGlzLm1vZGVsLnNldFN0eWxlKGJbY10sYSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19O214R3JhcGgucHJvdG90eXBlLnRvZ2dsZUNlbGxTdHlsZT1mdW5jdGlvbihhLGIsYyl7Yz1jfHx0aGlzLmdldFNlbGVjdGlvbkNlbGwoKTtyZXR1cm4gdGhpcy50b2dnbGVDZWxsU3R5bGVzKGEsYixbY10pfTsKbXhHcmFwaC5wcm90b3R5cGUudG9nZ2xlQ2VsbFN0eWxlcz1mdW5jdGlvbihhLGIsYyl7Yj1udWxsIT1iP2I6ITE7Yz1jfHx0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7dmFyIGQ9bnVsbDtudWxsIT1jJiYwPGMubGVuZ3RoJiYoZD10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoY1swXSksZD1teFV0aWxzLmdldFZhbHVlKGQsYSxiKT8wOjEsdGhpcy5zZXRDZWxsU3R5bGVzKGEsZCxjKSk7cmV0dXJuIGR9O214R3JhcGgucHJvdG90eXBlLnNldENlbGxTdHlsZXM9ZnVuY3Rpb24oYSxiLGMpe2M9Y3x8dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpO214VXRpbHMuc2V0Q2VsbFN0eWxlcyh0aGlzLm1vZGVsLGMsYSxiKX07bXhHcmFwaC5wcm90b3R5cGUudG9nZ2xlQ2VsbFN0eWxlRmxhZ3M9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc2V0Q2VsbFN0eWxlRmxhZ3MoYSxiLG51bGwsYyl9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsU3R5bGVGbGFncz1mdW5jdGlvbihhLGIsYyxkKXtkPWR8fHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtudWxsIT1kJiYwPGQubGVuZ3RoJiYobnVsbD09YyYmKGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGRbMF0pLGM9KHBhcnNlSW50KGNbYV18fDApJmIpIT1iKSxteFV0aWxzLnNldENlbGxTdHlsZUZsYWdzKHRoaXMubW9kZWwsZCxhLGIsYykpfTsKbXhHcmFwaC5wcm90b3R5cGUuYWxpZ25DZWxscz1mdW5jdGlvbihhLGIsYyl7bnVsbD09YiYmKGI9dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKTtpZihudWxsIT1iJiYxPGIubGVuZ3RoKXtpZihudWxsPT1jKWZvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLnZpZXcuZ2V0U3RhdGUoYltkXSk7aWYobnVsbCE9ZSYmIXRoaXMubW9kZWwuaXNFZGdlKGJbZF0pKWlmKG51bGw9PWMpaWYoYT09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKXtjPWUueCtlLndpZHRoLzI7YnJlYWt9ZWxzZSBpZihhPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCljPWUueCtlLndpZHRoO2Vsc2UgaWYoYT09bXhDb25zdGFudHMuQUxJR05fVE9QKWM9ZS55O2Vsc2UgaWYoYT09bXhDb25zdGFudHMuQUxJR05fTUlERExFKXtjPWUueStlLmhlaWdodC8yO2JyZWFrfWVsc2UgYz1hPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/ZS55K2UuaGVpZ2h0OmUueDtlbHNlIGM9YT09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/Ck1hdGgubWF4KGMsZS54K2Uud2lkdGgpOmE9PW14Q29uc3RhbnRzLkFMSUdOX1RPUD9NYXRoLm1pbihjLGUueSk6YT09bXhDb25zdGFudHMuQUxJR05fQk9UVE9NP01hdGgubWF4KGMsZS55K2UuaGVpZ2h0KTpNYXRoLm1pbihjLGUueCl9aWYobnVsbCE9Yyl7dmFyIGY9dGhpcy52aWV3LnNjYWxlO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylpZihlPXRoaXMudmlldy5nZXRTdGF0ZShiW2RdKSxudWxsIT1lKXt2YXIgZz10aGlzLmdldENlbGxHZW9tZXRyeShiW2RdKTtudWxsPT1nfHx0aGlzLm1vZGVsLmlzRWRnZShiW2RdKXx8KGc9Zy5jbG9uZSgpLGE9PW14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUj9nLngrPShjLWUueC1lLndpZHRoLzIpL2Y6YT09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/Zy54Kz0oYy1lLngtZS53aWR0aCkvZjphPT1teENvbnN0YW50cy5BTElHTl9UT1A/Zy55Kz0oYy1lLnkpL2Y6YT09bXhDb25zdGFudHMuQUxJR05fTUlERExFPwpnLnkrPShjLWUueS1lLmhlaWdodC8yKS9mOmE9PW14Q29uc3RhbnRzLkFMSUdOX0JPVFRPTT9nLnkrPShjLWUueS1lLmhlaWdodCkvZjpnLngrPShjLWUueCkvZix0aGlzLnJlc2l6ZUNlbGwoYltkXSxnKSl9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5BTElHTl9DRUxMUywiYWxpZ24iLGEsImNlbGxzIixiKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19cmV0dXJuIGJ9OwpteEdyYXBoLnByb3RvdHlwZS5mbGlwRWRnZT1mdW5jdGlvbihhKXtpZihudWxsIT1hJiZudWxsIT10aGlzLmFsdGVybmF0ZUVkZ2VTdHlsZSl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYj10aGlzLm1vZGVsLmdldFN0eWxlKGEpO251bGw9PWJ8fDA9PWIubGVuZ3RoP3RoaXMubW9kZWwuc2V0U3R5bGUoYSx0aGlzLmFsdGVybmF0ZUVkZ2VTdHlsZSk6dGhpcy5tb2RlbC5zZXRTdHlsZShhLG51bGwpO3RoaXMucmVzZXRFZGdlKGEpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRkxJUF9FREdFLCJlZGdlIixhKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX1yZXR1cm4gYX07bXhHcmFwaC5wcm90b3R5cGUuYWRkSW1hZ2VCdW5kbGU9ZnVuY3Rpb24oYSl7dGhpcy5pbWFnZUJ1bmRsZXMucHVzaChhKX07Cm14R3JhcGgucHJvdG90eXBlLnJlbW92ZUltYWdlQnVuZGxlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTA7Yzx0aGlzLmltYWdlQnVuZGxlcy5sZW5ndGg7YysrKXRoaXMuaW1hZ2VCdW5kbGVzW2NdIT1hJiZiLnB1c2godGhpcy5pbWFnZUJ1bmRsZXNbY10pO3RoaXMuaW1hZ2VCdW5kbGVzPWJ9O214R3JhcGgucHJvdG90eXBlLmdldEltYWdlRnJvbUJ1bmRsZXM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSlmb3IodmFyIGI9MDtiPHRoaXMuaW1hZ2VCdW5kbGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuaW1hZ2VCdW5kbGVzW2JdLmdldEltYWdlKGEpO2lmKG51bGwhPWMpcmV0dXJuIGN9cmV0dXJuIG51bGx9OwpteEdyYXBoLnByb3RvdHlwZS5vcmRlckNlbGxzPWZ1bmN0aW9uKGEsYil7bnVsbD09YiYmKGI9bXhVdGlscy5zb3J0Q2VsbHModGhpcy5nZXRTZWxlY3Rpb25DZWxscygpLCEwKSk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmNlbGxzT3JkZXJlZChiLGEpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuT1JERVJfQ0VMTFMsImJhY2siLGEsImNlbGxzIixiKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBifTsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbHNPcmRlcmVkPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtjXSk7Yj90aGlzLm1vZGVsLmFkZChkLGFbY10sYyk6dGhpcy5tb2RlbC5hZGQoZCxhW2NdLHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChkKS0xKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNFTExTX09SREVSRUQsImJhY2siLGIsImNlbGxzIixhKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5ncm91cENlbGxzPWZ1bmN0aW9uKGEsYixjKXtudWxsPT1jJiYoYz1teFV0aWxzLnNvcnRDZWxscyh0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCksITApKTtjPXRoaXMuZ2V0Q2VsbHNGb3JHcm91cChjKTtudWxsPT1hJiYoYT10aGlzLmNyZWF0ZUdyb3VwQ2VsbChjKSk7dmFyIGQ9dGhpcy5nZXRCb3VuZHNGb3JHcm91cChhLGMsYik7aWYoMDxjLmxlbmd0aCYmbnVsbCE9ZCl7dmFyIGU9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7bnVsbD09ZSYmKGU9dGhpcy5tb2RlbC5nZXRQYXJlbnQoY1swXSkpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7bnVsbD09dGhpcy5nZXRDZWxsR2VvbWV0cnkoYSkmJnRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYSxuZXcgbXhHZW9tZXRyeSk7dmFyIGY9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGUpO3RoaXMuY2VsbHNBZGRlZChbYV0sZSxmLG51bGwsbnVsbCwhMSwhMSwhMSk7Zj10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSk7CnRoaXMuY2VsbHNBZGRlZChjLGEsZixudWxsLG51bGwsITEsITEsITEpO3RoaXMuY2VsbHNNb3ZlZChjLC1kLngsLWQueSwhMSwhMSwhMSk7dGhpcy5jZWxsc1Jlc2l6ZWQoW2FdLFtkXSwhMSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5HUk9VUF9DRUxMUywiZ3JvdXAiLGEsImJvcmRlciIsYiwiY2VsbHMiLGMpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fXJldHVybiBhfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDZWxsc0Zvckdyb3VwPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBjPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbMF0pO2IucHVzaChhWzBdKTtmb3IodmFyIGQ9MTtkPGEubGVuZ3RoO2QrKyl0aGlzLm1vZGVsLmdldFBhcmVudChhW2RdKT09YyYmYi5wdXNoKGFbZF0pfXJldHVybiBifTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRzRm9yR3JvdXA9ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShiLCEwKTtudWxsIT1iJiYodGhpcy5pc1N3aW1sYW5lKGEpJiYoYT10aGlzLmdldFN0YXJ0U2l6ZShhKSxiLngtPWEud2lkdGgsYi55LT1hLmhlaWdodCxiLndpZHRoKz1hLndpZHRoLGIuaGVpZ2h0Kz1hLmhlaWdodCksbnVsbCE9YyYmKGIueC09YyxiLnktPWMsYi53aWR0aCs9MipjLGIuaGVpZ2h0Kz0yKmMpKTtyZXR1cm4gYn07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlR3JvdXBDZWxsPWZ1bmN0aW9uKGEpe2E9bmV3IG14Q2VsbCgiIik7YS5zZXRWZXJ0ZXgoITApO2Euc2V0Q29ubmVjdGFibGUoITEpO3JldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUudW5ncm91cENlbGxzPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKG51bGw9PWEpe2E9dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpO2Zvcih2YXIgYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKyspMDx0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYVtkXSkmJmMucHVzaChhW2RdKTthPWN9aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLm1vZGVsLmdldENoaWxkcmVuKGFbZF0pO2lmKG51bGwhPWUmJjA8ZS5sZW5ndGgpe3ZhciBlPWUuc2xpY2UoKSxmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbZF0pLGc9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGYpO3RoaXMuY2VsbHNBZGRlZChlLGYsZyxudWxsLG51bGwsITApO2I9Yi5jb25jYXQoZSl9fXRoaXMucmVtb3ZlQ2VsbHNBZnRlclVuZ3JvdXAoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5VTkdST1VQX0NFTExTLAoiY2VsbHMiLGEpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fXJldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5yZW1vdmVDZWxsc0FmdGVyVW5ncm91cD1mdW5jdGlvbihhKXt0aGlzLmNlbGxzUmVtb3ZlZCh0aGlzLmFkZEFsbEVkZ2VzKGEpKX07bXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbHNGcm9tUGFyZW50PWZ1bmN0aW9uKGEpe251bGw9PWEmJihhPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYj10aGlzLmdldERlZmF1bHRQYXJlbnQoKSxjPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChiKTt0aGlzLmNlbGxzQWRkZWQoYSxiLGMsbnVsbCxudWxsLCEwKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFTU9WRV9DRUxMU19GUk9NX1BBUkVOVCwiY2VsbHMiLGEpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS51cGRhdGVHcm91cEJvdW5kcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtudWxsPT1hJiYoYT10aGlzLmdldFNlbGVjdGlvbkNlbGxzKCkpO2I9bnVsbCE9Yj9iOjA7Yz1udWxsIT1jP2M6ITE7ZD1udWxsIT1kP2Q6MDtlPW51bGwhPWU/ZTowO2Y9bnVsbCE9Zj9mOjA7Zz1udWxsIT1nP2c6MDt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgaz1hLmxlbmd0aC0xOzA8PWs7ay0tKXt2YXIgbD10aGlzLmdldENlbGxHZW9tZXRyeShhW2tdKTtpZihudWxsIT1sKXt2YXIgbT10aGlzLmdldENoaWxkQ2VsbHMoYVtrXSk7aWYobnVsbCE9bSYmMDxtLmxlbmd0aCl7dmFyIG49dGhpcy5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShtLCEwKTtpZihudWxsIT1uJiYwPG4ud2lkdGgmJjA8bi5oZWlnaHQpe3ZhciBwPTAscT0wO2lmKHRoaXMuaXNTd2ltbGFuZShhW2tdKSl2YXIgcj10aGlzLmdldFN0YXJ0U2l6ZShhW2tdKSxwPXIud2lkdGgscT0Kci5oZWlnaHQ7bD1sLmNsb25lKCk7YyYmKGwueD1NYXRoLnJvdW5kKGwueCtuLngtYi1wLWcpLGwueT1NYXRoLnJvdW5kKGwueStuLnktYi1xLWQpKTtsLndpZHRoPU1hdGgucm91bmQobi53aWR0aCsyKmIrcCtnK2UpO2wuaGVpZ2h0PU1hdGgucm91bmQobi5oZWlnaHQrMipiK3ErZCtmKTt0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGFba10sbCk7dGhpcy5tb3ZlQ2VsbHMobSxiK3Atbi54K2csYitxLW4ueStkKX19fX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3g9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZihudWxsIT1hJiYwPGEubGVuZ3RoKWZvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKHRoaXMubW9kZWwuaXNWZXJ0ZXgoYVtjXSl8fHRoaXMubW9kZWwuaXNFZGdlKGFbY10pKXt2YXIgZD10aGlzLnZpZXcuZ2V0Qm91bmRpbmdCb3godGhpcy52aWV3LmdldFN0YXRlKGFbY10pLCEwKTtudWxsIT1kJiYobnVsbD09Yj9iPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZCk6Yi5hZGQoZCkpfXJldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5jbG9uZUNlbGw9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuY2xvbmVDZWxscyhbYV0sYixjLGQpWzBdfTsKbXhHcmFwaC5wcm90b3R5cGUuY2xvbmVDZWxscz1mdW5jdGlvbihhLGIsYyxkKXtiPW51bGwhPWI/YjohMDt2YXIgZT1udWxsO2lmKG51bGwhPWEpe2Zvcih2YXIgZj1uZXcgbXhEaWN0aW9uYXJ5LGU9W10sZz0wO2c8YS5sZW5ndGg7ZysrKWYucHV0KGFbZ10sITApLGUucHVzaChhW2ddKTtpZigwPGUubGVuZ3RoKWZvcih2YXIgaz10aGlzLnZpZXcuc2NhbGUsbD10aGlzLnZpZXcudHJhbnNsYXRlLGU9dGhpcy5tb2RlbC5jbG9uZUNlbGxzKGEsITAsYyksZz0wO2c8YS5sZW5ndGg7ZysrKWlmKCFiJiZ0aGlzLm1vZGVsLmlzRWRnZShlW2ddKSYmbnVsbCE9dGhpcy5nZXRFZGdlVmFsaWRhdGlvbkVycm9yKGVbZ10sdGhpcy5tb2RlbC5nZXRUZXJtaW5hbChlW2ddLCEwKSx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGVbZ10sITEpKSllW2ddPW51bGw7ZWxzZXt2YXIgbT10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGVbZ10pO2lmKG51bGwhPW0pe3ZhciBuPXRoaXMudmlldy5nZXRTdGF0ZShhW2ddKSwKcD10aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtnXSkpO2lmKG51bGwhPW4mJm51bGwhPXApaWYoYz1kPzA6cC5vcmlnaW4ueCxwPWQ/MDpwLm9yaWdpbi55LHRoaXMubW9kZWwuaXNFZGdlKGVbZ10pKXtpZihuPW4uYWJzb2x1dGVQb2ludHMsbnVsbCE9bil7Zm9yKHZhciBxPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYVtnXSwhMCk7bnVsbCE9cSYmIWYuZ2V0KHEpOylxPXRoaXMubW9kZWwuZ2V0UGFyZW50KHEpO251bGw9PXEmJm51bGwhPW5bMF0mJm0uc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludChuWzBdLngvay1sLngsblswXS55L2stbC55KSwhMCk7Zm9yKHE9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhW2ddLCExKTtudWxsIT1xJiYhZi5nZXQocSk7KXE9dGhpcy5tb2RlbC5nZXRQYXJlbnQocSk7dmFyIHI9bi5sZW5ndGgtMTtudWxsPT1xJiZudWxsIT1uW3JdJiZtLnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQobltyXS54L2stbC54LG5bcl0ueS8Kay1sLnkpLCExKTttPW0ucG9pbnRzO2lmKG51bGwhPW0pZm9yKG49MDtuPG0ubGVuZ3RoO24rKyltW25dLngrPWMsbVtuXS55Kz1wfX1lbHNlIG0udHJhbnNsYXRlKGMscCl9fWVsc2UgZT1bXX1yZXR1cm4gZX07bXhHcmFwaC5wcm90b3R5cGUuaW5zZXJ0VmVydGV4PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsKXtiPXRoaXMuY3JlYXRlVmVydGV4KGEsYixjLGQsZSxmLGcsayxsKTtyZXR1cm4gdGhpcy5hZGRDZWxsKGIsYSl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZVZlcnRleD1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCl7YT1uZXcgbXhHZW9tZXRyeShkLGUsZixnKTthLnJlbGF0aXZlPW51bGwhPWw/bDohMTtjPW5ldyBteENlbGwoYyxhLGspO2Muc2V0SWQoYik7Yy5zZXRWZXJ0ZXgoITApO2Muc2V0Q29ubmVjdGFibGUoITApO3JldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuaW5zZXJ0RWRnZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7Yj10aGlzLmNyZWF0ZUVkZ2UoYSxiLGMsZCxlLGYpO3JldHVybiB0aGlzLmFkZEVkZ2UoYixhLGQsZSl9O214R3JhcGgucHJvdG90eXBlLmNyZWF0ZUVkZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2E9bmV3IG14Q2VsbChjLG5ldyBteEdlb21ldHJ5LGYpO2Euc2V0SWQoYik7YS5zZXRFZGdlKCEwKTthLmdlb21ldHJ5LnJlbGF0aXZlPSEwO3JldHVybiBhfTtteEdyYXBoLnByb3RvdHlwZS5hZGRFZGdlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuYWRkQ2VsbChhLGIsZSxjLGQpfTtteEdyYXBoLnByb3RvdHlwZS5hZGRDZWxsPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuYWRkQ2VsbHMoW2FdLGIsYyxkLGUpWzBdfTsKbXhHcmFwaC5wcm90b3R5cGUuYWRkQ2VsbHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe251bGw9PWImJihiPXRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpKTtudWxsPT1jJiYoYz10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYikpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5jZWxsc0FkZGVkKGEsYixjLGQsZSxudWxsIT1mP2Y6ITEsITApLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQUREX0NFTExTLCJjZWxscyIsYSwicGFyZW50IixiLCJpbmRleCIsYywic291cmNlIixkLCJ0YXJnZXQiLGUpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc0FkZGVkPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayl7aWYobnVsbCE9YSYmbnVsbCE9YiYmbnVsbCE9Yyl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGw9Zj90aGlzLnZpZXcuZ2V0U3RhdGUoYik6bnVsbCxtPW51bGwhPWw/bC5vcmlnaW46bnVsbCxuPW5ldyBteFBvaW50KDAsMCksbD0wO2w8YS5sZW5ndGg7bCsrKWlmKG51bGw9PWFbbF0pYy0tO2Vsc2V7dmFyIHA9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtsXSk7aWYobnVsbCE9bSYmYVtsXSE9YiYmYiE9cCl7dmFyIHE9dGhpcy52aWV3LmdldFN0YXRlKHApLHI9bnVsbCE9cT9xLm9yaWdpbjpuLHQ9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhW2xdKTtpZihudWxsIT10KXt2YXIgdT1yLngtbS54LHg9ci55LW0ueSx0PXQuY2xvbmUoKTt0LnRyYW5zbGF0ZSh1LHgpO3QucmVsYXRpdmV8fCF0aGlzLm1vZGVsLmlzVmVydGV4KGFbbF0pfHx0aGlzLmlzQWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzKCl8fAoodC54PU1hdGgubWF4KDAsdC54KSx0Lnk9TWF0aC5tYXgoMCx0LnkpKTt0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGFbbF0sdCl9fWI9PXAmJmMrbD50aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYikmJmMtLTt0aGlzLm1vZGVsLmFkZChiLGFbbF0sYytsKTt0aGlzLmF1dG9TaXplQ2VsbHNPbkFkZCYmdGhpcy5hdXRvU2l6ZUNlbGwoYVtsXSwhMCk7KG51bGw9PWt8fGspJiZ0aGlzLmlzRXh0ZW5kUGFyZW50c09uQWRkKGFbbF0pJiZ0aGlzLmlzRXh0ZW5kUGFyZW50KGFbbF0pJiZ0aGlzLmV4dGVuZFBhcmVudChhW2xdKTsobnVsbD09Z3x8ZykmJnRoaXMuY29uc3RyYWluQ2hpbGQoYVtsXSk7bnVsbCE9ZCYmdGhpcy5jZWxsQ29ubmVjdGVkKGFbbF0sZCwhMCk7bnVsbCE9ZSYmdGhpcy5jZWxsQ29ubmVjdGVkKGFbbF0sZSwhMSl9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DRUxMU19BRERFRCwiY2VsbHMiLGEsInBhcmVudCIsYiwiaW5kZXgiLGMsInNvdXJjZSIsCmQsInRhcmdldCIsZSwiYWJzb2x1dGUiLGYpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07bXhHcmFwaC5wcm90b3R5cGUuYXV0b1NpemVDZWxsPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9Yj9iOjEpZm9yKHZhciBjPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxkPTA7ZDxjO2QrKyl0aGlzLmF1dG9TaXplQ2VsbCh0aGlzLm1vZGVsLmdldENoaWxkQXQoYSxkKSk7dGhpcy5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiZ0aGlzLmlzQXV0b1NpemVDZWxsKGEpJiZ0aGlzLnVwZGF0ZUNlbGxTaXplKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbHM9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDtudWxsPT1hJiYoYT10aGlzLmdldERlbGV0YWJsZUNlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpO2lmKGIpYT10aGlzLmdldERlbGV0YWJsZUNlbGxzKHRoaXMuYWRkQWxsRWRnZXMoYSkpO2Vsc2V7YT1hLnNsaWNlKCk7Zm9yKHZhciBjPXRoaXMuZ2V0RGVsZXRhYmxlQ2VsbHModGhpcy5nZXRBbGxFZGdlcyhhKSksZD1uZXcgbXhEaWN0aW9uYXJ5LGU9MDtlPGEubGVuZ3RoO2UrKylkLnB1dChhW2VdLCEwKTtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKW51bGwhPXRoaXMudmlldy5nZXRTdGF0ZShjW2VdKXx8ZC5nZXQoY1tlXSl8fChkLnB1dChjW2VdLCEwKSxhLnB1c2goY1tlXSkpfXRoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5jZWxsc1JlbW92ZWQoYSksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRU1PVkVfQ0VMTFMsImNlbGxzIiwKYSwiaW5jbHVkZUVkZ2VzIixiKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbHNSZW1vdmVkPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBiPXRoaXMudmlldy5zY2FsZSxjPXRoaXMudmlldy50cmFuc2xhdGU7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGQ9bmV3IG14RGljdGlvbmFyeSxlPTA7ZTxhLmxlbmd0aDtlKyspZC5wdXQoYVtlXSwhMCk7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7Zm9yKHZhciBmPXRoaXMuZ2V0QWxsRWRnZXMoW2FbZV1dKSxnPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGQsZil7dmFyIGc9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShkKTtpZihudWxsIT1nKXtmb3IodmFyIGs9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChkLGYpLGw9ITEsbT1rO251bGwhPW07KXtpZihhW2VdPT1tKXtsPSEwO2JyZWFrfW09dGhpcy5tb2RlbC5nZXRQYXJlbnQobSl9bCYmKGc9Zy5jbG9uZSgpLGw9dGhpcy52aWV3LmdldFN0YXRlKGQpLG51bGwhPWwmJm51bGwhPWwuYWJzb2x1dGVQb2ludHM/CihrPWwuYWJzb2x1dGVQb2ludHMsbT1mPzA6ay5sZW5ndGgtMSxnLnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQoa1ttXS54L2ItYy54LWwub3JpZ2luLngsa1ttXS55L2ItYy55LWwub3JpZ2luLnkpLGYpKTooaz10aGlzLnZpZXcuZ2V0U3RhdGUoayksbnVsbCE9ayYmZy5zZXRUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KGsuZ2V0Q2VudGVyWCgpL2ItYy54LGsuZ2V0Q2VudGVyWSgpL2ItYy55KSxmKSksdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShkLGcpLHRoaXMubW9kZWwuc2V0VGVybWluYWwoZCxudWxsLGYpKX19KSxrPTA7azxmLmxlbmd0aDtrKyspZC5nZXQoZltrXSl8fChkLnB1dChmW2tdLCEwKSxnKGZba10sITApLGcoZltrXSwhMSkpO3RoaXMubW9kZWwucmVtb3ZlKGFbZV0pfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQ0VMTFNfUkVNT1ZFRCwiY2VsbHMiLGEpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fX07Cm14R3JhcGgucHJvdG90eXBlLnNwbGl0RWRnZT1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGspe2Q9ZHx8MDtlPWV8fDA7az1udWxsIT1rP2s6dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7Zj10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsITApO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7aWYobnVsbD09Yyl7Yz10aGlzLmNsb25lQ2VsbChhKTt2YXIgbD10aGlzLnZpZXcuZ2V0U3RhdGUoYSksbT10aGlzLmdldENlbGxHZW9tZXRyeShjKTtpZihudWxsIT1tJiZudWxsIT1tLnBvaW50cyYmbnVsbCE9bCl7dmFyIG49dGhpcy52aWV3LnRyYW5zbGF0ZSxwPXRoaXMudmlldy5zY2FsZSxxPW14VXRpbHMuZmluZE5lYXJlc3RTZWdtZW50KGwsKGQrbi54KSpwLChlK24ueSkqcCk7bS5wb2ludHM9bS5wb2ludHMuc2xpY2UoMCxxKTttPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGEpO251bGwhPW0mJm51bGwhPW0ucG9pbnRzJiYobT1tLmNsb25lKCksbS5wb2ludHM9bS5wb2ludHMuc2xpY2UocSksCnRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYSxtKSl9fXRoaXMuY2VsbHNNb3ZlZChiLGQsZSwhMSwhMSk7dGhpcy5jZWxsc0FkZGVkKGIsayx0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoayksbnVsbCxudWxsLCEwKTt0aGlzLmNlbGxzQWRkZWQoW2NdLGssdGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGspLGYsYlswXSwhMSk7dGhpcy5jZWxsQ29ubmVjdGVkKGEsYlswXSwhMCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5TUExJVF9FREdFLCJlZGdlIixhLCJjZWxscyIsYiwibmV3RWRnZSIsYywiZHgiLGQsImR5IixlKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUudG9nZ2xlQ2VsbHM9ZnVuY3Rpb24oYSxiLGMpe251bGw9PWImJihiPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7YyYmKGI9dGhpcy5hZGRBbGxFZGdlcyhiKSk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmNlbGxzVG9nZ2xlZChiLGEpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuVE9HR0xFX0NFTExTLCJzaG93IixhLCJjZWxscyIsYiwiaW5jbHVkZUVkZ2VzIixjKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5jZWxsc1RvZ2dsZWQ9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiYwPGEubGVuZ3RoKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXRoaXMubW9kZWwuc2V0VmlzaWJsZShhW2NdLGIpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTsKbXhHcmFwaC5wcm90b3R5cGUuZm9sZENlbGxzPWZ1bmN0aW9uKGEsYixjLGQsZSl7Yj1udWxsIT1iP2I6ITE7bnVsbD09YyYmKGM9dGhpcy5nZXRGb2xkYWJsZUNlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxhKSk7dGhpcy5zdG9wRWRpdGluZyghMSk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmNlbGxzRm9sZGVkKGMsYSxiLGQpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRk9MRF9DRUxMUywiY29sbGFwc2UiLGEsInJlY3Vyc2UiLGIsImNlbGxzIixjKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbHNGb2xkZWQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKylpZigoIWR8fHRoaXMuaXNDZWxsRm9sZGFibGUoYVtlXSxiKSkmJmIhPXRoaXMuaXNDZWxsQ29sbGFwc2VkKGFbZV0pKXt0aGlzLm1vZGVsLnNldENvbGxhcHNlZChhW2VdLGIpO3RoaXMuc3dhcEJvdW5kcyhhW2VdLGIpO3RoaXMuaXNFeHRlbmRQYXJlbnQoYVtlXSkmJnRoaXMuZXh0ZW5kUGFyZW50KGFbZV0pO2lmKGMpe3ZhciBmPXRoaXMubW9kZWwuZ2V0Q2hpbGRyZW4oYVtlXSk7dGhpcy5jZWxsc0ZvbGRlZChmLGIsYyl9dGhpcy5jb25zdHJhaW5DaGlsZChhW2VdKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNFTExTX0ZPTERFRCwiY2VsbHMiLGEsImNvbGxhcHNlIixiLCJyZWN1cnNlIixjKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5zd2FwQm91bmRzPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9YSl7dmFyIGM9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKTtudWxsIT1jJiYoYz1jLmNsb25lKCksdGhpcy51cGRhdGVBbHRlcm5hdGVCb3VuZHMoYSxjLGIpLGMuc3dhcCgpLHRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYSxjKSl9fTsKbXhHcmFwaC5wcm90b3R5cGUudXBkYXRlQWx0ZXJuYXRlQm91bmRzPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT1hJiZudWxsIT1iKXtjPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtpZihudWxsPT1iLmFsdGVybmF0ZUJvdW5kcyl7dmFyIGQ9Yjt0aGlzLmNvbGxhcHNlVG9QcmVmZXJyZWRTaXplJiYoYT10aGlzLmdldFByZWZlcnJlZFNpemVGb3JDZWxsKGEpLG51bGwhPWEmJihkPWEsYT1teFV0aWxzLmdldFZhbHVlKGMsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFKSwwPGEmJihkLmhlaWdodD1NYXRoLm1heChkLmhlaWdodCxhKSkpKTtiLmFsdGVybmF0ZUJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoMCwwLGQud2lkdGgsZC5oZWlnaHQpfWlmKG51bGwhPWIuYWx0ZXJuYXRlQm91bmRzKXtiLmFsdGVybmF0ZUJvdW5kcy54PWIueDtiLmFsdGVybmF0ZUJvdW5kcy55PWIueTt2YXIgZT1teFV0aWxzLnRvUmFkaWFucyhjW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8MCk7CjAhPWUmJihjPWIuYWx0ZXJuYXRlQm91bmRzLmdldENlbnRlclgoKS1iLmdldENlbnRlclgoKSxkPWIuYWx0ZXJuYXRlQm91bmRzLmdldENlbnRlclkoKS1iLmdldENlbnRlclkoKSxhPU1hdGguY29zKGUpLGU9TWF0aC5zaW4oZSksYi5hbHRlcm5hdGVCb3VuZHMueCs9YSpjLWUqZC1jLGIuYWx0ZXJuYXRlQm91bmRzLnkrPWUqYythKmQtZCl9fX07bXhHcmFwaC5wcm90b3R5cGUuYWRkQWxsRWRnZXM9ZnVuY3Rpb24oYSl7dmFyIGI9YS5zbGljZSgpO3JldHVybiBteFV0aWxzLnJlbW92ZUR1cGxpY2F0ZXMoYi5jb25jYXQodGhpcy5nZXRBbGxFZGdlcyhhKSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0QWxsRWRnZXM9ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYobnVsbCE9YSlmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7Zm9yKHZhciBkPXRoaXMubW9kZWwuZ2V0RWRnZUNvdW50KGFbY10pLGU9MDtlPGQ7ZSsrKWIucHVzaCh0aGlzLm1vZGVsLmdldEVkZ2VBdChhW2NdLGUpKTtkPXRoaXMubW9kZWwuZ2V0Q2hpbGRyZW4oYVtjXSk7Yj1iLmNvbmNhdCh0aGlzLmdldEFsbEVkZ2VzKGQpKX1yZXR1cm4gYn07bXhHcmFwaC5wcm90b3R5cGUudXBkYXRlQ2VsbFNpemU9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e3RoaXMuY2VsbFNpemVVcGRhdGVkKGEsYiksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5VUERBVEVfQ0VMTF9TSVpFLCJjZWxsIixhLCJpZ25vcmVDaGlsZHJlbiIsYikpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLmNlbGxTaXplVXBkYXRlZD1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGM9dGhpcy5nZXRQcmVmZXJyZWRTaXplRm9yQ2VsbChhKSxkPXRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoYSk7aWYobnVsbCE9YyYmbnVsbCE9ZCl7dmFyIGU9dGhpcy5pc0NlbGxDb2xsYXBzZWQoYSksZD1kLmNsb25lKCk7aWYodGhpcy5pc1N3aW1sYW5lKGEpKXt2YXIgZj10aGlzLmdldENlbGxTdHlsZShhKSxnPXRoaXMubW9kZWwuZ2V0U3R5bGUoYSk7bnVsbD09ZyYmKGc9IiIpO214VXRpbHMuZ2V0VmFsdWUoZixteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLCEwKT8oZz1teFV0aWxzLnNldFN0eWxlKGcsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFLGMuaGVpZ2h0KzgpLGUmJihkLmhlaWdodD1jLmhlaWdodCs4KSxkLndpZHRoPWMud2lkdGgpOihnPW14VXRpbHMuc2V0U3R5bGUoZyxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsCmMud2lkdGgrOCksZSYmKGQud2lkdGg9Yy53aWR0aCs4KSxkLmhlaWdodD1jLmhlaWdodCk7dGhpcy5tb2RlbC5zZXRTdHlsZShhLGcpfWVsc2V7dmFyIGs9dGhpcy52aWV3LmNyZWF0ZVN0YXRlKGEpLGw9ay5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9BTElHTl18fG14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUjtsPT1teENvbnN0YW50cy5BTElHTl9SSUdIVD9kLngrPWQud2lkdGgtYy53aWR0aDpsPT1teENvbnN0YW50cy5BTElHTl9DRU5URVImJihkLngrPU1hdGgucm91bmQoKGQud2lkdGgtYy53aWR0aCkvMikpO3ZhciBtPXRoaXMuZ2V0VmVydGljYWxBbGlnbihrKTttPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/ZC55Kz1kLmhlaWdodC1jLmhlaWdodDptPT1teENvbnN0YW50cy5BTElHTl9NSURETEUmJihkLnkrPU1hdGgucm91bmQoKGQuaGVpZ2h0LWMuaGVpZ2h0KS8yKSk7ZC53aWR0aD1jLndpZHRoO2QuaGVpZ2h0PWMuaGVpZ2h0fWlmKCFiJiYhZSl7dmFyIG49dGhpcy52aWV3LmdldEJvdW5kcyh0aGlzLm1vZGVsLmdldENoaWxkcmVuKGEpKTsKaWYobnVsbCE9bil7dmFyIHA9dGhpcy52aWV3LnRyYW5zbGF0ZSxxPXRoaXMudmlldy5zY2FsZSxyPShuLnkrbi5oZWlnaHQpL3EtZC55LXAueTtkLndpZHRoPU1hdGgubWF4KGQud2lkdGgsKG4ueCtuLndpZHRoKS9xLWQueC1wLngpO2QuaGVpZ2h0PU1hdGgubWF4KGQuaGVpZ2h0LHIpfX10aGlzLmNlbGxzUmVzaXplZChbYV0sW2RdLCExKX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5nZXRQcmVmZXJyZWRTaXplRm9yQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBjPW51bGw7aWYobnVsbCE9YSl7dmFyIGQ9dGhpcy52aWV3LmNyZWF0ZVN0YXRlKGEpLGU9ZC5zdHlsZTtpZighdGhpcy5tb2RlbC5pc0VkZ2UoYSkpe3ZhciBmPWVbbXhDb25zdGFudHMuU1RZTEVfRk9OVFNJWkVdfHxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFLGc9MCxjPTA7bnVsbD09dGhpcy5nZXRJbWFnZShkKSYmbnVsbD09ZVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV18fGVbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdIT1teENvbnN0YW50cy5TSEFQRV9MQUJFTHx8KGVbbXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR05dPT1teENvbnN0YW50cy5BTElHTl9NSURETEUmJihnKz1wYXJzZUZsb2F0KGVbbXhDb25zdGFudHMuU1RZTEVfSU1BR0VfV0lEVEhdKXx8bXhMYWJlbC5wcm90b3R5cGUuaW1hZ2VTaXplKSxlW214Q29uc3RhbnRzLlNUWUxFX0FMSUdOXSE9Cm14Q29uc3RhbnRzLkFMSUdOX0NFTlRFUiYmKGMrPXBhcnNlRmxvYXQoZVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV9IRUlHSFRdKXx8bXhMYWJlbC5wcm90b3R5cGUuaW1hZ2VTaXplKSk7dmFyIGc9ZysyKihlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkddfHwwKSxnPWcrKGVbbXhDb25zdGFudHMuU1RZTEVfU1BBQ0lOR19MRUZUXXx8MCksZz1nKyhlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfUklHSFRdfHwwKSxjPWMrMiooZVtteENvbnN0YW50cy5TVFlMRV9TUEFDSU5HXXx8MCksYz1jKyhlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfVE9QXXx8MCksYz1jKyhlW214Q29uc3RhbnRzLlNUWUxFX1NQQUNJTkdfQk9UVE9NXXx8MCksaz10aGlzLmdldEZvbGRpbmdJbWFnZShkKTtudWxsIT1rJiYoZys9ay53aWR0aCs4KTtrPXRoaXMuY2VsbFJlbmRlcmVyLmdldExhYmVsVmFsdWUoZCk7bnVsbCE9ayYmMDxrLmxlbmd0aD8odGhpcy5pc0h0bWxMYWJlbChkLmNlbGwpfHwoaz0KbXhVdGlscy5odG1sRW50aXRpZXMoaywhMSkpLGs9ay5yZXBsYWNlKC9cbi9nLCI8YnI+IiksZj1teFV0aWxzLmdldFNpemVGb3JTdHJpbmcoayxmLGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVEZBTUlMWV0sYixlW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRV0pLGQ9Zi53aWR0aCtnLGM9Zi5oZWlnaHQrYyxteFV0aWxzLmdldFZhbHVlKGUsbXhDb25zdGFudHMuU1RZTEVfSE9SSVpPTlRBTCwhMCl8fChlPWMsYz1kLGQ9ZSksdGhpcy5ncmlkRW5hYmxlZCYmKGQ9dGhpcy5zbmFwKGQrdGhpcy5ncmlkU2l6ZS8yKSxjPXRoaXMuc25hcChjK3RoaXMuZ3JpZFNpemUvMikpLGM9bmV3IG14UmVjdGFuZ2xlKDAsMCxkLGMpKTooZT00KnRoaXMuZ3JpZFNpemUsYz1uZXcgbXhSZWN0YW5nbGUoMCwwLGUsZSkpfX1yZXR1cm4gY307bXhHcmFwaC5wcm90b3R5cGUucmVzaXplQ2VsbD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMucmVzaXplQ2VsbHMoW2FdLFtiXSxjKVswXX07Cm14R3JhcGgucHJvdG90eXBlLnJlc2l6ZUNlbGxzPWZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/Yzp0aGlzLmlzUmVjdXJzaXZlUmVzaXplKCk7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD10aGlzLmNlbGxzUmVzaXplZChhLGIsYyk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5SRVNJWkVfQ0VMTFMsImNlbGxzIixhLCJib3VuZHMiLGIsInByZXZpb3VzIixkKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfXJldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuY2VsbHNSZXNpemVkPWZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/YzohMTt2YXIgZD1bXTtpZihudWxsIT1hJiZudWxsIT1iJiZhLmxlbmd0aD09Yi5sZW5ndGgpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspZC5wdXNoKHRoaXMuY2VsbFJlc2l6ZWQoYVtlXSxiW2VdLCExLGMpKSx0aGlzLmlzRXh0ZW5kUGFyZW50KGFbZV0pJiZ0aGlzLmV4dGVuZFBhcmVudChhW2VdKSx0aGlzLmNvbnN0cmFpbkNoaWxkKGFbZV0pO3RoaXMucmVzZXRFZGdlc09uUmVzaXplJiZ0aGlzLnJlc2V0RWRnZXMoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DRUxMU19SRVNJWkVELCJjZWxscyIsYSwiYm91bmRzIixiLCJwcmV2aW91cyIsZCkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19cmV0dXJuIGR9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsUmVzaXplZD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGEpO2lmKG51bGwhPWUmJihlLnghPWIueHx8ZS55IT1iLnl8fGUud2lkdGghPWIud2lkdGh8fGUuaGVpZ2h0IT1iLmhlaWdodCkpe3ZhciBmPWUuY2xvbmUoKTshYyYmZi5yZWxhdGl2ZT8oYz1mLm9mZnNldCxudWxsIT1jJiYoYy54Kz1iLngtZi54LGMueSs9Yi55LWYueSkpOihmLng9Yi54LGYueT1iLnkpO2Yud2lkdGg9Yi53aWR0aDtmLmhlaWdodD1iLmhlaWdodDtmLnJlbGF0aXZlfHwhdGhpcy5tb2RlbC5pc1ZlcnRleChhKXx8dGhpcy5pc0FsbG93TmVnYXRpdmVDb29yZGluYXRlcygpfHwoZi54PU1hdGgubWF4KDAsZi54KSxmLnk9TWF0aC5tYXgoMCxmLnkpKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2QmJnRoaXMucmVzaXplQ2hpbGRDZWxscyhhLGYpLHRoaXMubW9kZWwuc2V0R2VvbWV0cnkoYSxmKSx0aGlzLmNvbnN0cmFpbkNoaWxkQ2VsbHMoYSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX1yZXR1cm4gZX07Cm14R3JhcGgucHJvdG90eXBlLnJlc2l6ZUNoaWxkQ2VsbHM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKSxkPWIud2lkdGgvYy53aWR0aCxjPWIuaGVpZ2h0L2MuaGVpZ2h0LGU9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGEpLGY9MDtmPGU7ZisrKXRoaXMuc2NhbGVDZWxsKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGYpLGQsYywhMCl9O214R3JhcGgucHJvdG90eXBlLmNvbnN0cmFpbkNoaWxkQ2VsbHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxjPTA7YzxiO2MrKyl0aGlzLmNvbnN0cmFpbkNoaWxkKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLGMpKX07Cm14R3JhcGgucHJvdG90eXBlLnNjYWxlQ2VsbD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLm1vZGVsLmdldEdlb21ldHJ5KGEpO2lmKG51bGwhPWUpe3ZhciBmPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKSxlPWUuY2xvbmUoKSxnPWUueCxrPWUueSxsPWUud2lkdGgsbT1lLmhlaWdodDtlLnNjYWxlKGIsYywiZml4ZWQiPT1mW214Q29uc3RhbnRzLlNUWUxFX0FTUEVDVF0pOyIxIj09ZltteENvbnN0YW50cy5TVFlMRV9SRVNJWkVfV0lEVEhdP2Uud2lkdGg9bCpiOiIwIj09ZltteENvbnN0YW50cy5TVFlMRV9SRVNJWkVfV0lEVEhdJiYoZS53aWR0aD1sKTsiMSI9PWZbbXhDb25zdGFudHMuU1RZTEVfUkVTSVpFX0hFSUdIVF0/ZS5oZWlnaHQ9bSpjOiIwIj09ZltteENvbnN0YW50cy5TVFlMRV9SRVNJWkVfSEVJR0hUXSYmKGUuaGVpZ2h0PW0pO3RoaXMuaXNDZWxsTW92YWJsZShhKXx8KGUueD1nLGUueT1rKTt0aGlzLmlzQ2VsbFJlc2l6YWJsZShhKXx8KGUud2lkdGg9bCwKZS5oZWlnaHQ9bSk7dGhpcy5tb2RlbC5pc1ZlcnRleChhKT90aGlzLmNlbGxSZXNpemVkKGEsZSwhMCxkKTp0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGEsZSl9fTtteEdyYXBoLnByb3RvdHlwZS5leHRlbmRQYXJlbnQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSksYz10aGlzLmdldENlbGxHZW9tZXRyeShiKTtudWxsPT1ifHxudWxsPT1jfHx0aGlzLmlzQ2VsbENvbGxhcHNlZChiKXx8KGE9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYSksbnVsbCE9YSYmIWEucmVsYXRpdmUmJihjLndpZHRoPGEueCthLndpZHRofHxjLmhlaWdodDxhLnkrYS5oZWlnaHQpJiYoYz1jLmNsb25lKCksYy53aWR0aD1NYXRoLm1heChjLndpZHRoLGEueCthLndpZHRoKSxjLmhlaWdodD1NYXRoLm1heChjLmhlaWdodCxhLnkrYS5oZWlnaHQpLHRoaXMuY2VsbHNSZXNpemVkKFtiXSxbY10sITEpKSl9fTsKbXhHcmFwaC5wcm90b3R5cGUuaW1wb3J0Q2VsbHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JldHVybiB0aGlzLm1vdmVDZWxscyhhLGIsYywhMCxkLGUsZil9OwpteEdyYXBoLnByb3RvdHlwZS5tb3ZlQ2VsbHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7Yj1udWxsIT1iP2I6MDtjPW51bGwhPWM/YzowO2Q9bnVsbCE9ZD9kOiExO2lmKG51bGwhPWEmJigwIT1ifHwwIT1jfHxkfHxudWxsIT1lKSl7YT10aGlzLm1vZGVsLmdldFRvcG1vc3RDZWxscyhhKTt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgaz1uZXcgbXhEaWN0aW9uYXJ5LGw9MDtsPGEubGVuZ3RoO2wrKylrLnB1dChhW2xdLCEwKTtmb3IodmFyIG09bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Zm9yKDtudWxsIT1hOyl7aWYoay5nZXQoYSkpcmV0dXJuITA7YT10aGlzLm1vZGVsLmdldFBhcmVudChhKX1yZXR1cm4hMX0pLG49W10sbD0wO2w8YS5sZW5ndGg7bCsrKXt2YXIgcD10aGlzLmdldENlbGxHZW9tZXRyeShhW2xdKSxxPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbbF0pO251bGwhPXAmJnAucmVsYXRpdmUmJnRoaXMubW9kZWwuaXNFZGdlKHEpJiYobSh0aGlzLm1vZGVsLmdldFRlcm1pbmFsKHEsCiEwKSl8fG0odGhpcy5tb2RlbC5nZXRUZXJtaW5hbChxLCExKSkpfHxuLnB1c2goYVtsXSl9YT1uO2QmJihhPXRoaXMuY2xvbmVDZWxscyhhLHRoaXMuaXNDbG9uZUludmFsaWRFZGdlcygpLGcpLG51bGw9PWUmJihlPXRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpKSk7dmFyIHI9dGhpcy5pc0FsbG93TmVnYXRpdmVDb29yZGluYXRlcygpO251bGwhPWUmJnRoaXMuc2V0QWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzKCEwKTt0aGlzLmNlbGxzTW92ZWQoYSxiLGMsIWQmJnRoaXMuaXNEaXNjb25uZWN0T25Nb3ZlKCkmJnRoaXMuaXNBbGxvd0RhbmdsaW5nRWRnZXMoKSxudWxsPT1lLHRoaXMuaXNFeHRlbmRQYXJlbnRzT25Nb3ZlKCkmJm51bGw9PWUpO3RoaXMuc2V0QWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzKHIpO2lmKG51bGwhPWUpe3ZhciB0PXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChlKTt0aGlzLmNlbGxzQWRkZWQoYSxlLHQsbnVsbCxudWxsLCEwKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50Lk1PVkVfQ0VMTFMsCiJjZWxscyIsYSwiZHgiLGIsImR5IixjLCJjbG9uZSIsZCwidGFyZ2V0IixlLCJldmVudCIsZikpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsc01vdmVkPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZihudWxsIT1hJiYoMCE9Ynx8MCE9Yykpe2Y9bnVsbCE9Zj9mOiExO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7ZCYmdGhpcy5kaXNjb25uZWN0R3JhcGgoYSk7Zm9yKHZhciBnPTA7ZzxhLmxlbmd0aDtnKyspdGhpcy50cmFuc2xhdGVDZWxsKGFbZ10sYixjKSxmJiZ0aGlzLmlzRXh0ZW5kUGFyZW50KGFbZ10pP3RoaXMuZXh0ZW5kUGFyZW50KGFbZ10pOmUmJnRoaXMuY29uc3RyYWluQ2hpbGQoYVtnXSk7dGhpcy5yZXNldEVkZ2VzT25Nb3ZlJiZ0aGlzLnJlc2V0RWRnZXMoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DRUxMU19NT1ZFRCwiY2VsbHMiLGEsImR4IixiLCJkeSIsYywiZGlzY29ubmVjdCIsZCkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTsKbXhHcmFwaC5wcm90b3R5cGUudHJhbnNsYXRlQ2VsbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKTtpZihudWxsIT1kKXtiPXBhcnNlRmxvYXQoYik7Yz1wYXJzZUZsb2F0KGMpO2Q9ZC5jbG9uZSgpO2QudHJhbnNsYXRlKGIsYyk7ZC5yZWxhdGl2ZXx8IXRoaXMubW9kZWwuaXNWZXJ0ZXgoYSl8fHRoaXMuaXNBbGxvd05lZ2F0aXZlQ29vcmRpbmF0ZXMoKXx8KGQueD1NYXRoLm1heCgwLHBhcnNlRmxvYXQoZC54KSksZC55PU1hdGgubWF4KDAscGFyc2VGbG9hdChkLnkpKSk7aWYoZC5yZWxhdGl2ZSYmIXRoaXMubW9kZWwuaXNFZGdlKGEpKXt2YXIgZT10aGlzLm1vZGVsLmdldFBhcmVudChhKSxmPTA7dGhpcy5tb2RlbC5pc1ZlcnRleChlKSYmKGU9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGUpLGY9bXhVdGlscy5nZXRWYWx1ZShlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApKTswIT1mJiYoZj1teFV0aWxzLnRvUmFkaWFucygtZiksCmU9TWF0aC5jb3MoZiksZj1NYXRoLnNpbihmKSxjPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KGIsYyksZSxmLG5ldyBteFBvaW50KDAsMCkpLGI9Yy54LGM9Yy55KTtudWxsPT1kLm9mZnNldD9kLm9mZnNldD1uZXcgbXhQb2ludChiLGMpOihkLm9mZnNldC54PXBhcnNlRmxvYXQoZC5vZmZzZXQueCkrYixkLm9mZnNldC55PXBhcnNlRmxvYXQoZC5vZmZzZXQueSkrYyl9dGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLGQpfX07Cm14R3JhcGgucHJvdG90eXBlLmdldENlbGxDb250YWlubWVudEFyZWE9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmIXRoaXMubW9kZWwuaXNFZGdlKGEpKXt2YXIgYj10aGlzLm1vZGVsLmdldFBhcmVudChhKTtpZihudWxsIT1iJiZiIT10aGlzLmdldERlZmF1bHRQYXJlbnQoKSl7dmFyIGM9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShiKTtpZihudWxsIT1jKXt2YXIgZD1hPTAsZT1jLndpZHRoLGM9Yy5oZWlnaHQ7aWYodGhpcy5pc1N3aW1sYW5lKGIpKXt2YXIgZj10aGlzLmdldFN0YXJ0U2l6ZShiKSxnPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShiKSxiPW14VXRpbHMuZ2V0VmFsdWUoZyxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpLGs9MT09bXhVdGlscy5nZXRWYWx1ZShnLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILDApLGc9MT09bXhVdGlscy5nZXRWYWx1ZShnLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLDApO2lmKGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSHx8CmI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCl7dmFyIGw9Zi53aWR0aDtmLndpZHRoPWYuaGVpZ2h0O2YuaGVpZ2h0PWx9aWYoYj09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QmJiFnfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgmJiFrfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCYmZ3x8Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIJiZrKWE9Zi53aWR0aCxkPWYuaGVpZ2h0O2UtPWYud2lkdGg7Yy09Zi5oZWlnaHR9cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLGQsZSxjKX19fXJldHVybiBudWxsfTtteEdyYXBoLnByb3RvdHlwZS5nZXRNYXhpbXVtR3JhcGhCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXhpbXVtR3JhcGhCb3VuZHN9OwpteEdyYXBoLnByb3RvdHlwZS5jb25zdHJhaW5DaGlsZD1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe3ZhciBjPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGEpO2lmKG51bGwhPWMmJih0aGlzLmlzQ29uc3RyYWluUmVsYXRpdmVDaGlsZHJlbigpfHwhYy5yZWxhdGl2ZSkpe3ZhciBkPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpO3RoaXMuZ2V0Q2VsbEdlb21ldHJ5KGQpO3ZhciBlPXRoaXMuZ2V0TWF4aW11bUdyYXBoQm91bmRzKCk7bnVsbCE9ZSYmKGQ9dGhpcy5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShbZF0sITEpLG51bGwhPWQmJihlPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZSksZS54LT1kLngsZS55LT1kLnkpKTtpZih0aGlzLmlzQ29uc3RyYWluQ2hpbGQoYSkmJihkPXRoaXMuZ2V0Q2VsbENvbnRhaW5tZW50QXJlYShhKSxudWxsIT1kKSl7dmFyIGY9dGhpcy5nZXRPdmVybGFwKGEpOzA8ZiYmKGQ9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShkKSxkLngtPWQud2lkdGgqCmYsZC55LT1kLmhlaWdodCpmLGQud2lkdGgrPTIqZC53aWR0aCpmLGQuaGVpZ2h0Kz0yKmQuaGVpZ2h0KmYpO251bGw9PWU/ZT1kOihlPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZSksZS5pbnRlcnNlY3QoZCkpfWlmKG51bGwhPWUpe2Q9W2FdO2lmKCF0aGlzLmlzQ2VsbENvbGxhcHNlZChhKSlmb3IodmFyIGY9dGhpcy5tb2RlbC5nZXREZXNjZW5kYW50cyhhKSxnPTA7ZzxmLmxlbmd0aDtnKyspdGhpcy5pc0NlbGxWaXNpYmxlKGZbZ10pJiZkLnB1c2goZltnXSk7ZD10aGlzLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KGQsITEpO2lmKG51bGwhPWQpe2M9Yy5jbG9uZSgpO2Y9MDtjLndpZHRoPmUud2lkdGgmJihmPWMud2lkdGgtZS53aWR0aCxjLndpZHRoLT1mKTtkLngrZC53aWR0aD5lLngrZS53aWR0aCYmKGYtPWQueCtkLndpZHRoLWUueC1lLndpZHRoLWYpO2c9MDtjLmhlaWdodD5lLmhlaWdodCYmKGc9Yy5oZWlnaHQtZS5oZWlnaHQsYy5oZWlnaHQtPWcpO2QueStkLmhlaWdodD4KZS55K2UuaGVpZ2h0JiYoZy09ZC55K2QuaGVpZ2h0LWUueS1lLmhlaWdodC1nKTtkLng8ZS54JiYoZi09ZC54LWUueCk7ZC55PGUueSYmKGctPWQueS1lLnkpO2lmKDAhPWZ8fDAhPWcpYy5yZWxhdGl2ZT8obnVsbD09Yy5vZmZzZXQmJihjLm9mZnNldD1uZXcgbXhQb2ludCksYy5vZmZzZXQueCs9ZixjLm9mZnNldC55Kz1nKTooYy54Kz1mLGMueSs9Zyk7dGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLGMpfX19fX07Cm14R3JhcGgucHJvdG90eXBlLnJlc2V0RWRnZXM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7Zm9yKHZhciBiPW5ldyBteERpY3Rpb25hcnksYz0wO2M8YS5sZW5ndGg7YysrKWIucHV0KGFbY10sITApO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRFZGdlcyhhW2NdKTtpZihudWxsIT1kKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLnZpZXcuZ2V0U3RhdGUoZFtlXSksZz1udWxsIT1mP2YuZ2V0VmlzaWJsZVRlcm1pbmFsKCEwKTp0aGlzLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGRbZV0sITApLGs9bnVsbCE9Zj9mLmdldFZpc2libGVUZXJtaW5hbCghMSk6dGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChkW2VdLCExKTtiLmdldChnKSYmYi5nZXQoayl8fHRoaXMucmVzZXRFZGdlKGRbZV0pfXRoaXMucmVzZXRFZGdlcyh0aGlzLm1vZGVsLmdldENoaWxkcmVuKGFbY10pKX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5yZXNldEVkZ2U9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShhKTtudWxsIT1iJiZudWxsIT1iLnBvaW50cyYmMDxiLnBvaW50cy5sZW5ndGgmJihiPWIuY2xvbmUoKSxiLnBvaW50cz1bXSx0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGEsYikpO3JldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0T3V0bGluZUNvbnN0cmFpbnQ9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWIuc2hhcGUpe2M9dGhpcy52aWV3LmdldFBlcmltZXRlckJvdW5kcyhiKTt2YXIgZD1iLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTl07aWYoZD09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxkPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgpe2MueCs9Yy53aWR0aC8yLWMuaGVpZ2h0LzI7Yy55Kz1jLmhlaWdodC8yLWMud2lkdGgvMjt2YXIgZT1jLndpZHRoO2Mud2lkdGg9Yy5oZWlnaHQ7Yy5oZWlnaHQ9ZX12YXIgZj1teFV0aWxzLnRvUmFkaWFucyhiLnNoYXBlLmdldFNoYXBlUm90YXRpb24oKSk7aWYoMCE9Zil7dmFyIGU9TWF0aC5jb3MoLWYpLGY9TWF0aC5zaW4oLWYpLGc9bmV3IG14UG9pbnQoYy5nZXRDZW50ZXJYKCksYy5nZXRDZW50ZXJZKCkpO2E9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoYSxlLGYsZyl9dmFyIGc9Zj0xLGs9MCxsPQowO2lmKHRoaXMuZ2V0TW9kZWwoKS5pc1ZlcnRleChiLmNlbGwpKXt2YXIgbT1iLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZMSVBIXSxuPWIuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRkxJUFZdO251bGwhPWIuc2hhcGUmJm51bGwhPWIuc2hhcGUuc3RlbmNpbCYmKG09MT09bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLCJzdGVuY2lsRmxpcEgiLDApfHxtLG49MT09bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLCJzdGVuY2lsRmxpcFYiLDApfHxuKTtpZihkPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCllPW0sbT1uLG49ZTttJiYoZj0tMSxrPS1jLndpZHRoKTtuJiYoZz0tMSxsPS1jLmhlaWdodCl9YT1uZXcgbXhQb2ludCgoYS54LWMueCkqZi1rK2MueCwoYS55LWMueSkqZy1sK2MueSk7cmV0dXJuIG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDA9PWMud2lkdGg/MDpNYXRoLnJvdW5kKDFFMyoKKGEueC1jLngpL2Mud2lkdGgpLzFFMywwPT1jLmhlaWdodD8wOk1hdGgucm91bmQoMUUzKihhLnktYy55KS9jLmhlaWdodCkvMUUzKSwhMSl9cmV0dXJuIG51bGx9O214R3JhcGgucHJvdG90eXBlLmdldEFsbENvbm5lY3Rpb25Db25zdHJhaW50cz1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLnNoYXBlJiZudWxsIT1hLnNoYXBlLnN0ZW5jaWw/YS5zaGFwZS5zdGVuY2lsLmNvbnN0cmFpbnRzOm51bGx9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uQ29uc3RyYWludD1mdW5jdGlvbihhLGIsYyl7Yj1udWxsO3ZhciBkPWEuc3R5bGVbYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1g6bXhDb25zdGFudHMuU1RZTEVfRU5UUllfWF07aWYobnVsbCE9ZCl7dmFyIGU9YS5zdHlsZVtjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXTtudWxsIT1lJiYoYj1uZXcgbXhQb2ludChwYXJzZUZsb2F0KGQpLHBhcnNlRmxvYXQoZSkpKX12YXIgZD0hMSxmPWU9MDtudWxsIT1iJiYoZD1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1BFUklNRVRFUjpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9QRVJJTUVURVIsITApLGU9cGFyc2VGbG9hdChhLnN0eWxlW2M/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9EWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9EWF0pLGY9cGFyc2VGbG9hdChhLnN0eWxlW2M/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9EWToKbXhDb25zdGFudHMuU1RZTEVfRU5UUllfRFldKSxlPWlzRmluaXRlKGUpP2U6MCxmPWlzRmluaXRlKGYpP2Y6MCk7cmV0dXJuIG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KGIsZCxudWxsLGUsZil9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRDb25uZWN0aW9uQ29uc3RyYWludD1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1kKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e251bGw9PWR8fG51bGw9PWQucG9pbnQ/KHRoaXMuc2V0Q2VsbFN0eWxlcyhjP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9YLG51bGwsW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1k6bXhDb25zdGFudHMuU1RZTEVfRU5UUllfWSxudWxsLFthXSksdGhpcy5zZXRDZWxsU3R5bGVzKGM/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9EWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9EWCxudWxsLFthXSksdGhpcy5zZXRDZWxsU3R5bGVzKGM/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9EWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9EWSxudWxsLFthXSksdGhpcy5zZXRDZWxsU3R5bGVzKGM/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9QRVJJTUVURVI6Cm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1BFUklNRVRFUixudWxsLFthXSkpOm51bGwhPWQucG9pbnQmJih0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1g6bXhDb25zdGFudHMuU1RZTEVfRU5UUllfWCxkLnBvaW50LngsW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1k6bXhDb25zdGFudHMuU1RZTEVfRU5UUllfWSxkLnBvaW50LnksW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX0RYOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX0RYLGQuZHgsW2FdKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX0RZOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX0RZLGQuZHksW2FdKSxkLnBlcmltZXRlcj90aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1BFUklNRVRFUjpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9QRVJJTUVURVIsCm51bGwsW2FdKTp0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9FWElUX1BFUklNRVRFUjpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9QRVJJTUVURVIsIjAiLFthXSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvblBvaW50PWZ1bmN0aW9uKGEsYixjKXtjPW51bGwhPWM/YzohMDt2YXIgZD1udWxsO2lmKG51bGwhPWEmJm51bGwhPWIucG9pbnQpe3ZhciBlPXRoaXMudmlldy5nZXRQZXJpbWV0ZXJCb3VuZHMoYSksZj1uZXcgbXhQb2ludChlLmdldENlbnRlclgoKSxlLmdldENlbnRlclkoKSksZz1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTl0saz0wO251bGwhPWcmJjE9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BTkNIT1JfUE9JTlRfRElSRUNUSU9OLDEpJiYoZz09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIP2srPTI3MDpnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9rKz0xODA6Zz09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIJiYoays9OTApLGchPW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCYmZyE9bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfHxlLnJvdGF0ZTkwKCkpOwp2YXIgZD10aGlzLnZpZXcuc2NhbGUsZD1uZXcgbXhQb2ludChlLngrYi5wb2ludC54KmUud2lkdGgrYi5keCpkLGUueStiLnBvaW50LnkqZS5oZWlnaHQrYi5keSpkKSxsPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwwO2lmKGIucGVyaW1ldGVyKTAhPWsmJihnPWU9MCw5MD09az9nPTE6MTgwPT1rP2U9LTE6MjcwPT1rJiYoZz0tMSksZD1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChkLGUsZyxmKSksZD10aGlzLnZpZXcuZ2V0UGVyaW1ldGVyUG9pbnQoYSxkLCExKTtlbHNlIGlmKGwrPWssdGhpcy5nZXRNb2RlbCgpLmlzVmVydGV4KGEuY2VsbCkpe2s9MT09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9GTElQSF07Yj0xPT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZMSVBWXTtudWxsIT1hLnNoYXBlJiZudWxsIT1hLnNoYXBlLnN0ZW5jaWwmJihrPTE9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwic3RlbmNpbEZsaXBIIiwwKXx8ayxiPTE9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwKInN0ZW5jaWxGbGlwViIsMCl8fGIpO2lmKGc9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8Zz09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKWE9ayxrPWIsYj1hO2smJihkLng9MiplLmdldENlbnRlclgoKS1kLngpO2ImJihkLnk9MiplLmdldENlbnRlclkoKS1kLnkpfTAhPWwmJm51bGwhPWQmJihhPW14VXRpbHMudG9SYWRpYW5zKGwpLGU9TWF0aC5jb3MoYSksZz1NYXRoLnNpbihhKSxkPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KGQsZSxnLGYpKX1jJiZudWxsIT1kJiYoZC54PU1hdGgucm91bmQoZC54KSxkLnk9TWF0aC5yb3VuZChkLnkpKTtyZXR1cm4gZH07Cm14R3JhcGgucHJvdG90eXBlLmNvbm5lY3RDZWxsPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGU9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhLGMpO3RoaXMuY2VsbENvbm5lY3RlZChhLGIsYyxkKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkNPTk5FQ1RfQ0VMTCwiZWRnZSIsYSwidGVybWluYWwiLGIsInNvdXJjZSIsYywicHJldmlvdXMiLGUpKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5jZWxsQ29ubmVjdGVkPWZ1bmN0aW9uKGEsYixjLGQpe2lmKG51bGwhPWEpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGU9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhLGMpO3RoaXMuc2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoYSxiLGMsZCk7dGhpcy5pc1BvcnRzRW5hYmxlZCgpJiYoZD1udWxsLHRoaXMuaXNQb3J0KGIpJiYoZD1iLmdldElkKCksYj10aGlzLmdldFRlcm1pbmFsRm9yUG9ydChiLGMpKSx0aGlzLnNldENlbGxTdHlsZXMoYz9teENvbnN0YW50cy5TVFlMRV9TT1VSQ0VfUE9SVDpteENvbnN0YW50cy5TVFlMRV9UQVJHRVRfUE9SVCxkLFthXSkpO3RoaXMubW9kZWwuc2V0VGVybWluYWwoYSxiLGMpO3RoaXMucmVzZXRFZGdlc09uQ29ubmVjdCYmdGhpcy5yZXNldEVkZ2UoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DRUxMX0NPTk5FQ1RFRCwiZWRnZSIsYSwidGVybWluYWwiLGIsInNvdXJjZSIsCmMsInByZXZpb3VzIixlKSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5kaXNjb25uZWN0R3JhcGg9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGI9dGhpcy52aWV3LnNjYWxlLGM9dGhpcy52aWV3LnRyYW5zbGF0ZSxkPW5ldyBteERpY3Rpb25hcnksZT0wO2U8YS5sZW5ndGg7ZSsrKWQucHV0KGFbZV0sITApO2ZvcihlPTA7ZTxhLmxlbmd0aDtlKyspaWYodGhpcy5tb2RlbC5pc0VkZ2UoYVtlXSkpe3ZhciBmPXRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoYVtlXSk7aWYobnVsbCE9Zil7dmFyIGc9dGhpcy52aWV3LmdldFN0YXRlKGFbZV0pLGs9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGFbZV0pKTtpZihudWxsIT1nJiZudWxsIT1rKXt2YXIgZj1mLmNsb25lKCksbD0tay5vcmlnaW4ueCxtPS1rLm9yaWdpbi55LG49Zy5hYnNvbHV0ZVBvaW50cyxwPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYVtlXSwhMCk7aWYobnVsbCE9cCYmdGhpcy5pc0NlbGxEaXNjb25uZWN0YWJsZShhW2VdLApwLCEwKSl7Zm9yKDtudWxsIT1wJiYhZC5nZXQocCk7KXA9dGhpcy5tb2RlbC5nZXRQYXJlbnQocCk7bnVsbD09cCYmKGYuc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludChuWzBdLngvYi1jLngrbCxuWzBdLnkvYi1jLnkrbSksITApLHRoaXMubW9kZWwuc2V0VGVybWluYWwoYVtlXSxudWxsLCEwKSl9dmFyIHE9dGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhW2VdLCExKTtpZihudWxsIT1xJiZ0aGlzLmlzQ2VsbERpc2Nvbm5lY3RhYmxlKGFbZV0scSwhMSkpe2Zvcig7bnVsbCE9cSYmIWQuZ2V0KHEpOylxPXRoaXMubW9kZWwuZ2V0UGFyZW50KHEpO2lmKG51bGw9PXEpe3ZhciByPW4ubGVuZ3RoLTE7Zi5zZXRUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KG5bcl0ueC9iLWMueCtsLG5bcl0ueS9iLWMueSttKSwhMSk7dGhpcy5tb2RlbC5zZXRUZXJtaW5hbChhW2VdLG51bGwsITEpfX10aGlzLm1vZGVsLnNldEdlb21ldHJ5KGFbZV0sZil9fX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX19OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDdXJyZW50Um9vdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuY3VycmVudFJvb3R9O214R3JhcGgucHJvdG90eXBlLmdldFRyYW5zbGF0ZUZvclJvb3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O214R3JhcGgucHJvdG90eXBlLmlzUG9ydD1mdW5jdGlvbihhKXtyZXR1cm4hMX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0VGVybWluYWxGb3JQb3J0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDaGlsZE9mZnNldEZvckNlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O214R3JhcGgucHJvdG90eXBlLmVudGVyR3JvdXA9ZnVuY3Rpb24oYSl7YT1hfHx0aGlzLmdldFNlbGVjdGlvbkNlbGwoKTtudWxsIT1hJiZ0aGlzLmlzVmFsaWRSb290KGEpJiYodGhpcy52aWV3LnNldEN1cnJlbnRSb290KGEpLHRoaXMuY2xlYXJTZWxlY3Rpb24oKSl9OwpteEdyYXBoLnByb3RvdHlwZS5leGl0R3JvdXA9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm1vZGVsLmdldFJvb3QoKSxiPXRoaXMuZ2V0Q3VycmVudFJvb3QoKTtpZihudWxsIT1iKXtmb3IodmFyIGM9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYik7YyE9YSYmIXRoaXMuaXNWYWxpZFJvb3QoYykmJnRoaXMubW9kZWwuZ2V0UGFyZW50KGMpIT1hOyljPXRoaXMubW9kZWwuZ2V0UGFyZW50KGMpO2M9PWF8fHRoaXMubW9kZWwuZ2V0UGFyZW50KGMpPT1hP3RoaXMudmlldy5zZXRDdXJyZW50Um9vdChudWxsKTp0aGlzLnZpZXcuc2V0Q3VycmVudFJvb3QoYyk7bnVsbCE9dGhpcy52aWV3LmdldFN0YXRlKGIpJiZ0aGlzLnNldFNlbGVjdGlvbkNlbGwoYil9fTtteEdyYXBoLnByb3RvdHlwZS5ob21lPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50Um9vdCgpO251bGwhPWEmJih0aGlzLnZpZXcuc2V0Q3VycmVudFJvb3QobnVsbCksbnVsbCE9dGhpcy52aWV3LmdldFN0YXRlKGEpJiZ0aGlzLnNldFNlbGVjdGlvbkNlbGwoYSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNWYWxpZFJvb3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWF9O214R3JhcGgucHJvdG90eXBlLmdldEdyYXBoQm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlldy5nZXRHcmFwaEJvdW5kcygpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDZWxsQm91bmRzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bYV07YiYmKGQ9ZC5jb25jYXQodGhpcy5tb2RlbC5nZXRFZGdlcyhhKSkpO2Q9dGhpcy52aWV3LmdldEJvdW5kcyhkKTtpZihjKXtjPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKTtmb3IodmFyIGU9MDtlPGM7ZSsrKXt2YXIgZj10aGlzLmdldENlbGxCb3VuZHModGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsZSksYiwhMCk7bnVsbCE9ZD9kLmFkZChmKTpkPWZ9fXJldHVybiBkfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3hGcm9tR2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMTt2YXIgYz1udWxsO2lmKG51bGwhPWEpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspaWYoYnx8dGhpcy5tb2RlbC5pc1ZlcnRleChhW2RdKSl7dmFyIGU9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYVtkXSk7aWYobnVsbCE9ZSl7dmFyIGY9bnVsbDtpZih0aGlzLm1vZGVsLmlzRWRnZShhW2RdKSl7Zj1mdW5jdGlvbihhKXtudWxsIT1hJiYobnVsbD09Zz9nPW5ldyBteFJlY3RhbmdsZShhLngsYS55LDAsMCk6Zy5hZGQobmV3IG14UmVjdGFuZ2xlKGEueCxhLnksMCwwKSkpfTtudWxsPT10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGFbZF0sITApJiZmKGUuZ2V0VGVybWluYWxQb2ludCghMCkpO251bGw9PXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYVtkXSwhMSkmJmYoZS5nZXRUZXJtaW5hbFBvaW50KCExKSk7ZT1lLnBvaW50cztpZihudWxsIT1lJiYwPGUubGVuZ3RoKWZvcih2YXIgZz0KbmV3IG14UmVjdGFuZ2xlKGVbMF0ueCxlWzBdLnksMCwwKSxrPTE7azxlLmxlbmd0aDtrKyspZihlW2tdKTtmPWd9ZWxzZSBrPXRoaXMubW9kZWwuZ2V0UGFyZW50KGFbZF0pLGUucmVsYXRpdmU/dGhpcy5tb2RlbC5pc1ZlcnRleChrKSYmayE9dGhpcy52aWV3LmN1cnJlbnRSb290JiYoZz10aGlzLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KFtrXSwhMSksbnVsbCE9ZyYmKGY9bmV3IG14UmVjdGFuZ2xlKGUueCpnLndpZHRoLGUueSpnLmhlaWdodCxlLndpZHRoLGUuaGVpZ2h0KSwwPD1teFV0aWxzLmluZGV4T2YoYSxrKSYmKGYueCs9Zy54LGYueSs9Zy55KSkpOihmPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoZSksdGhpcy5tb2RlbC5pc1ZlcnRleChrKSYmMDw9bXhVdGlscy5pbmRleE9mKGEsaykmJihnPXRoaXMuZ2V0Qm91bmRpbmdCb3hGcm9tR2VvbWV0cnkoW2tdLCExKSxudWxsIT1nJiYoZi54Kz1nLngsZi55Kz1nLnkpKSksbnVsbCE9ZiYmbnVsbCE9ZS5vZmZzZXQmJgooZi54Kz1lLm9mZnNldC54LGYueSs9ZS5vZmZzZXQueSksZT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYVtkXSksbnVsbCE9ZiYmKGU9bXhVdGlscy5nZXRWYWx1ZShlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLDApLDAhPWUmJihmPW14VXRpbHMuZ2V0Qm91bmRpbmdCb3goZixlKSkpO251bGwhPWYmJihudWxsPT1jP2M9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShmKTpjLmFkZChmKSl9fXJldHVybiBjfTtteEdyYXBoLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGEpe3RoaXMudmlldy5jbGVhcihhLG51bGw9PWEpO3RoaXMudmlldy52YWxpZGF0ZSgpO3RoaXMuc2l6ZURpZENoYW5nZSgpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUkVGUkVTSCkpfTtteEdyYXBoLnByb3RvdHlwZS5zbmFwPWZ1bmN0aW9uKGEpe3RoaXMuZ3JpZEVuYWJsZWQmJihhPU1hdGgucm91bmQoYS90aGlzLmdyaWRTaXplKSp0aGlzLmdyaWRTaXplKTtyZXR1cm4gYX07Cm14R3JhcGgucHJvdG90eXBlLnNuYXBEZWx0YT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMudmlldy50cmFuc2xhdGUsZz10aGlzLnZpZXcuc2NhbGU7IWMmJnRoaXMuZ3JpZEVuYWJsZWQ/KGM9dGhpcy5ncmlkU2l6ZSpnKi41LGR8fChkPWIueC0odGhpcy5zbmFwKGIueC9nLWYueCkrZi54KSpnLGEueD1NYXRoLmFicyhhLngtZCk8Yz8wOnRoaXMuc25hcChhLngvZykqZy1kKSxlfHwoYj1iLnktKHRoaXMuc25hcChiLnkvZy1mLnkpK2YueSkqZyxhLnk9TWF0aC5hYnMoYS55LWIpPGM/MDp0aGlzLnNuYXAoYS55L2cpKmctYikpOihjPS41KmcsZHx8KGQ9Yi54LShNYXRoLnJvdW5kKGIueC9nLWYueCkrZi54KSpnLGEueD1NYXRoLmFicyhhLngtZCk8Yz8wOk1hdGgucm91bmQoYS54L2cpKmctZCksZXx8KGI9Yi55LShNYXRoLnJvdW5kKGIueS9nLWYueSkrZi55KSpnLGEueT1NYXRoLmFicyhhLnktYik8Yz8wOk1hdGgucm91bmQoYS55L2cpKmctYikpO3JldHVybiBhfTsKbXhHcmFwaC5wcm90b3R5cGUucGFuR3JhcGg9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nJiZteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpKXRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQ9LWEsdGhpcy5jb250YWluZXIuc2Nyb2xsVG9wPS1iO2Vsc2V7dmFyIGM9dGhpcy52aWV3LmdldENhbnZhcygpO2lmKHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkcpaWYoMD09YSYmMD09Yil7aWYobXhDbGllbnQuSVNfSUU/Yy5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsInRyYW5zbGF0ZSgiK2ErIiwiK2IrIikiKTpjLnJlbW92ZUF0dHJpYnV0ZSgidHJhbnNmb3JtIiksbnVsbCE9dGhpcy5zaGlmdFByZXZpZXcxKXtmb3IodmFyIGQ9dGhpcy5zaGlmdFByZXZpZXcxLmZpcnN0Q2hpbGQ7bnVsbCE9ZDspe3ZhciBlPWQubmV4dFNpYmxpbmc7dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZCk7ZD1lfW51bGwhPXRoaXMuc2hpZnRQcmV2aWV3MS5wYXJlbnROb2RlJiYKdGhpcy5zaGlmdFByZXZpZXcxLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zaGlmdFByZXZpZXcxKTt0aGlzLnNoaWZ0UHJldmlldzE9bnVsbDt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjLnBhcmVudE5vZGUpO2ZvcihkPXRoaXMuc2hpZnRQcmV2aWV3Mi5maXJzdENoaWxkO251bGwhPWQ7KWU9ZC5uZXh0U2libGluZyx0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkKSxkPWU7bnVsbCE9dGhpcy5zaGlmdFByZXZpZXcyLnBhcmVudE5vZGUmJnRoaXMuc2hpZnRQcmV2aWV3Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2hpZnRQcmV2aWV3Mik7dGhpcy5zaGlmdFByZXZpZXcyPW51bGx9fWVsc2V7Yy5zZXRBdHRyaWJ1dGUoInRyYW5zZm9ybSIsInRyYW5zbGF0ZSgiK2ErIiwiK2IrIikiKTtpZihudWxsPT10aGlzLnNoaWZ0UHJldmlldzEpe3RoaXMuc2hpZnRQcmV2aWV3MT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt0aGlzLnNoaWZ0UHJldmlldzEuc3R5bGUucG9zaXRpb249CiJhYnNvbHV0ZSI7dGhpcy5zaGlmdFByZXZpZXcxLnN0eWxlLm92ZXJmbG93PSJ2aXNpYmxlIjt0aGlzLnNoaWZ0UHJldmlldzI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7dGhpcy5zaGlmdFByZXZpZXcyLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7dGhpcy5zaGlmdFByZXZpZXcyLnN0eWxlLm92ZXJmbG93PSJ2aXNpYmxlIjtmb3IodmFyIGY9dGhpcy5zaGlmdFByZXZpZXcxLGQ9dGhpcy5jb250YWluZXIuZmlyc3RDaGlsZDtudWxsIT1kOyllPWQubmV4dFNpYmxpbmcsZCE9Yy5wYXJlbnROb2RlP2YuYXBwZW5kQ2hpbGQoZCk6Zj10aGlzLnNoaWZ0UHJldmlldzIsZD1lO251bGwhPXRoaXMuc2hpZnRQcmV2aWV3MS5maXJzdENoaWxkJiZ0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5zaGlmdFByZXZpZXcxLGMucGFyZW50Tm9kZSk7bnVsbCE9dGhpcy5zaGlmdFByZXZpZXcyLmZpcnN0Q2hpbGQmJnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2hpZnRQcmV2aWV3Mil9dGhpcy5zaGlmdFByZXZpZXcxLnN0eWxlLmxlZnQ9CmErInB4Ijt0aGlzLnNoaWZ0UHJldmlldzEuc3R5bGUudG9wPWIrInB4Ijt0aGlzLnNoaWZ0UHJldmlldzIuc3R5bGUubGVmdD1hKyJweCI7dGhpcy5zaGlmdFByZXZpZXcyLnN0eWxlLnRvcD1iKyJweCJ9ZWxzZSBjLnN0eWxlLmxlZnQ9YSsicHgiLGMuc3R5bGUudG9wPWIrInB4Ijt0aGlzLnBhbkR4PWE7dGhpcy5wYW5EeT1iO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUEFOKSl9fTtteEdyYXBoLnByb3RvdHlwZS56b29tSW49ZnVuY3Rpb24oKXt0aGlzLnpvb20odGhpcy56b29tRmFjdG9yKX07bXhHcmFwaC5wcm90b3R5cGUuem9vbU91dD1mdW5jdGlvbigpe3RoaXMuem9vbSgxL3RoaXMuem9vbUZhY3Rvcil9OwpteEdyYXBoLnByb3RvdHlwZS56b29tQWN0dWFsPWZ1bmN0aW9uKCl7MT09dGhpcy52aWV3LnNjYWxlP3RoaXMudmlldy5zZXRUcmFuc2xhdGUoMCwwKToodGhpcy52aWV3LnRyYW5zbGF0ZS54PTAsdGhpcy52aWV3LnRyYW5zbGF0ZS55PTAsdGhpcy52aWV3LnNldFNjYWxlKDEpKX07bXhHcmFwaC5wcm90b3R5cGUuem9vbVRvPWZ1bmN0aW9uKGEsYil7dGhpcy56b29tKGEvdGhpcy52aWV3LnNjYWxlLGIpfTsKbXhHcmFwaC5wcm90b3R5cGUuY2VudGVyPWZ1bmN0aW9uKGEsYixjLGQpe2E9bnVsbCE9YT9hOiEwO2I9bnVsbCE9Yj9iOiEwO2M9bnVsbCE9Yz9jOi41O2Q9bnVsbCE9ZD9kOi41O3ZhciBlPW14VXRpbHMuaGFzU2Nyb2xsYmFycyh0aGlzLmNvbnRhaW5lciksZj0yKnRoaXMuZ2V0Qm9yZGVyKCksZz10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aC1mLGY9dGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0LWYsaz10aGlzLmdldEdyYXBoQm91bmRzKCksbD10aGlzLnZpZXcudHJhbnNsYXRlLG09dGhpcy52aWV3LnNjYWxlLG49YT9nLWsud2lkdGg6MCxwPWI/Zi1rLmhlaWdodDowO2U/KGsueC09bC54LGsueS09bC55LGE9dGhpcy5jb250YWluZXIuc2Nyb2xsV2lkdGgsYj10aGlzLmNvbnRhaW5lci5zY3JvbGxIZWlnaHQsYT5nJiYobj0wKSxiPmYmJihwPTApLHRoaXMudmlldy5zZXRUcmFuc2xhdGUoTWF0aC5mbG9vcihuLzItay54KSxNYXRoLmZsb29yKHAvMi1rLnkpKSx0aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0PQooYS1nKS8yLHRoaXMuY29udGFpbmVyLnNjcm9sbFRvcD0oYi1mKS8yKTp0aGlzLnZpZXcuc2V0VHJhbnNsYXRlKGE/TWF0aC5mbG9vcihsLngtay54Km0rbipjL20pOmwueCxiP01hdGguZmxvb3IobC55LWsueSptK3AqZC9tKTpsLnkpfTsKbXhHcmFwaC5wcm90b3R5cGUuem9vbT1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOnRoaXMuY2VudGVyWm9vbTt2YXIgYz1NYXRoLnJvdW5kKHRoaXMudmlldy5zY2FsZSphKjEwMCkvMTAwLGQ9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbCgpKTthPWMvdGhpcy52aWV3LnNjYWxlO2lmKHRoaXMua2VlcFNlbGVjdGlvblZpc2libGVPblpvb20mJm51bGwhPWQpZD1uZXcgbXhSZWN0YW5nbGUoZC54KmEsZC55KmEsZC53aWR0aCphLGQuaGVpZ2h0KmEpLHRoaXMudmlldy5zY2FsZT1jLHRoaXMuc2Nyb2xsUmVjdFRvVmlzaWJsZShkKXx8KHRoaXMudmlldy5yZXZhbGlkYXRlKCksdGhpcy52aWV3LnNldFNjYWxlKGMpKTtlbHNlIGlmKGQ9bXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuY29udGFpbmVyKSxiJiYhZCl7dmFyIGQ9dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsZT10aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7aWYoMTxhKXZhciBmPShhLTEpLwooMipjKSxkPWQqLWYsZT1lKi1mO2Vsc2UgZj0oMS9hLTEpLygyKnRoaXMudmlldy5zY2FsZSksZCo9ZixlKj1mO3RoaXMudmlldy5zY2FsZUFuZFRyYW5zbGF0ZShjLHRoaXMudmlldy50cmFuc2xhdGUueCtkLHRoaXMudmlldy50cmFuc2xhdGUueStlKX1lbHNle3ZhciBmPXRoaXMudmlldy50cmFuc2xhdGUueCxnPXRoaXMudmlldy50cmFuc2xhdGUueSxrPXRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQsbD10aGlzLmNvbnRhaW5lci5zY3JvbGxUb3A7dGhpcy52aWV3LnNldFNjYWxlKGMpO2QmJihlPWQ9MCxiJiYoZD10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCooYS0xKS8yLGU9dGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0KihhLTEpLzIpLHRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQ9KHRoaXMudmlldy50cmFuc2xhdGUueC1mKSp0aGlzLnZpZXcuc2NhbGUrTWF0aC5yb3VuZChrKmErZCksdGhpcy5jb250YWluZXIuc2Nyb2xsVG9wPSh0aGlzLnZpZXcudHJhbnNsYXRlLnktCmcpKnRoaXMudmlldy5zY2FsZStNYXRoLnJvdW5kKGwqYStlKSl9fTsKbXhHcmFwaC5wcm90b3R5cGUuem9vbVRvUmVjdD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aC9hLndpZHRoLyh0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQvYS5oZWlnaHQpO2EueD1NYXRoLm1heCgwLGEueCk7YS55PU1hdGgubWF4KDAsYS55KTt2YXIgYz1NYXRoLm1pbih0aGlzLmNvbnRhaW5lci5zY3JvbGxXaWR0aCxhLngrYS53aWR0aCksZD1NYXRoLm1pbih0aGlzLmNvbnRhaW5lci5zY3JvbGxIZWlnaHQsYS55K2EuaGVpZ2h0KTthLndpZHRoPWMtYS54O2EuaGVpZ2h0PWQtYS55OzE+Yj8oYj1hLmhlaWdodC9iLGM9KGItYS5oZWlnaHQpLzIsYS5oZWlnaHQ9YixhLnktPU1hdGgubWluKGEueSxjKSxkPU1hdGgubWluKHRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodCxhLnkrYS5oZWlnaHQpLGEuaGVpZ2h0PWQtYS55KTooYio9YS53aWR0aCxjPShiLWEud2lkdGgpLzIsYS53aWR0aD1iLGEueC09TWF0aC5taW4oYS54LGMpLGM9TWF0aC5taW4odGhpcy5jb250YWluZXIuc2Nyb2xsV2lkdGgsCmEueCthLndpZHRoKSxhLndpZHRoPWMtYS54KTtiPXRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoL2Eud2lkdGg7Yz10aGlzLnZpZXcuc2NhbGUqYjtteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpPyh0aGlzLnZpZXcuc2V0U2NhbGUoYyksdGhpcy5jb250YWluZXIuc2Nyb2xsTGVmdD1NYXRoLnJvdW5kKGEueCpiKSx0aGlzLmNvbnRhaW5lci5zY3JvbGxUb3A9TWF0aC5yb3VuZChhLnkqYikpOnRoaXMudmlldy5zY2FsZUFuZFRyYW5zbGF0ZShjLHRoaXMudmlldy50cmFuc2xhdGUueC1hLngvdGhpcy52aWV3LnNjYWxlLHRoaXMudmlldy50cmFuc2xhdGUueS1hLnkvdGhpcy52aWV3LnNjYWxlKX07Cm14R3JhcGgucHJvdG90eXBlLnNjcm9sbENlbGxUb1Zpc2libGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz0tdGhpcy52aWV3LnRyYW5zbGF0ZS54LGQ9LXRoaXMudmlldy50cmFuc2xhdGUueSxlPXRoaXMudmlldy5nZXRTdGF0ZShhKTtudWxsIT1lJiYoYz1uZXcgbXhSZWN0YW5nbGUoYytlLngsZCtlLnksZS53aWR0aCxlLmhlaWdodCksYiYmbnVsbCE9dGhpcy5jb250YWluZXImJihkPXRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLGU9dGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0LGMueD1jLmdldENlbnRlclgoKS1kLzIsYy53aWR0aD1kLGMueT1jLmdldENlbnRlclkoKS1lLzIsYy5oZWlnaHQ9ZSksZD1uZXcgbXhQb2ludCh0aGlzLnZpZXcudHJhbnNsYXRlLngsdGhpcy52aWV3LnRyYW5zbGF0ZS55KSx0aGlzLnNjcm9sbFJlY3RUb1Zpc2libGUoYykmJihjPW5ldyBteFBvaW50KHRoaXMudmlldy50cmFuc2xhdGUueCx0aGlzLnZpZXcudHJhbnNsYXRlLnkpLHRoaXMudmlldy50cmFuc2xhdGUueD0KZC54LHRoaXMudmlldy50cmFuc2xhdGUueT1kLnksdGhpcy52aWV3LnNldFRyYW5zbGF0ZShjLngsYy55KSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuc2Nyb2xsUmVjdFRvVmlzaWJsZT1mdW5jdGlvbihhKXt2YXIgYj0hMTtpZihudWxsIT1hKXt2YXIgYz10aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCxkPXRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCxlPU1hdGgubWluKGMsYS53aWR0aCksZj1NYXRoLm1pbihkLGEuaGVpZ2h0KTtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpKXtjPXRoaXMuY29udGFpbmVyO2EueCs9dGhpcy52aWV3LnRyYW5zbGF0ZS54O2EueSs9dGhpcy52aWV3LnRyYW5zbGF0ZS55O3ZhciBnPWMuc2Nyb2xsTGVmdC1hLngsZD1NYXRoLm1heChnLWMuc2Nyb2xsTGVmdCwwKTswPGc/Yy5zY3JvbGxMZWZ0LT1nKzI6KGc9YS54K2UtYy5zY3JvbGxMZWZ0LWMuY2xpZW50V2lkdGgsMDxnJiYoYy5zY3JvbGxMZWZ0Kz1nKzIpKTtlPWMuc2Nyb2xsVG9wLWEueTtnPU1hdGgubWF4KDAsZS1jLnNjcm9sbFRvcCk7MDxlP2Muc2Nyb2xsVG9wLT1lKzI6KGU9YS55KwpmLWMuc2Nyb2xsVG9wLWMuY2xpZW50SGVpZ2h0LDA8ZSYmKGMuc2Nyb2xsVG9wKz1lKzIpKTt0aGlzLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nfHwwPT1kJiYwPT1nfHx0aGlzLnZpZXcuc2V0VHJhbnNsYXRlKGQsZyl9ZWxzZXt2YXIgZz0tdGhpcy52aWV3LnRyYW5zbGF0ZS54LGs9LXRoaXMudmlldy50cmFuc2xhdGUueSxsPXRoaXMudmlldy5zY2FsZTthLngrZT5nK2MmJih0aGlzLnZpZXcudHJhbnNsYXRlLngtPShhLngrZS1jLWcpL2wsYj0hMCk7YS55K2Y+aytkJiYodGhpcy52aWV3LnRyYW5zbGF0ZS55LT0oYS55K2YtZC1rKS9sLGI9ITApO2EueDxnJiYodGhpcy52aWV3LnRyYW5zbGF0ZS54Kz0oZy1hLngpL2wsYj0hMCk7YS55PGsmJih0aGlzLnZpZXcudHJhbnNsYXRlLnkrPShrLWEueSkvbCxiPSEwKTtiJiYodGhpcy52aWV3LnJlZnJlc2goKSxudWxsIT10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlciYmdGhpcy5zZWxlY3Rpb25DZWxsc0hhbmRsZXIucmVmcmVzaCgpKX19cmV0dXJuIGJ9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDZWxsR2VvbWV0cnk9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoYSl9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbFZpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuaXNWaXNpYmxlKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxDb2xsYXBzZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuaXNDb2xsYXBzZWQoYSl9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbENvbm5lY3RhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1vZGVsLmlzQ29ubmVjdGFibGUoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc09ydGhvZ29uYWw9ZnVuY3Rpb24oYSl7dmFyIGI9YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9PUlRIT0dPTkFMXTtpZihudWxsIT1iKXJldHVybiBiO2E9dGhpcy52aWV3LmdldEVkZ2VTdHlsZShhKTtyZXR1cm4gYT09bXhFZGdlU3R5bGUuU2VnbWVudENvbm5lY3Rvcnx8YT09bXhFZGdlU3R5bGUuRWxib3dDb25uZWN0b3J8fGE9PW14RWRnZVN0eWxlLlNpZGVUb1NpZGV8fGE9PW14RWRnZVN0eWxlLlRvcFRvQm90dG9tfHxhPT1teEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbnx8YT09bXhFZGdlU3R5bGUuT3J0aENvbm5lY3Rvcn07bXhHcmFwaC5wcm90b3R5cGUuaXNMb29wPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApO2E9YS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSk7cmV0dXJuIG51bGwhPWImJmI9PWF9O214R3JhcGgucHJvdG90eXBlLmlzQ2xvbmVFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNUcmFuc3BhcmVudENsaWNrRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITF9O214R3JhcGgucHJvdG90eXBlLmlzVG9nZ2xlRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14Q2xpZW50LklTX01BQz9teEV2ZW50LmlzTWV0YURvd24oYSk6bXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc0dyaWRFbmFibGVkRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJiFteEV2ZW50LmlzQWx0RG93bihhKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDb25zdHJhaW5lZEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzU2hpZnREb3duKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc0lnbm9yZVRlcm1pbmFsRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITF9O214R3JhcGgucHJvdG90eXBlLnZhbGlkYXRpb25BbGVydD1mdW5jdGlvbihhKXtteFV0aWxzLmFsZXJ0KGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNFZGdlVmFsaWQ9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBudWxsPT10aGlzLmdldEVkZ2VWYWxpZGF0aW9uRXJyb3IoYSxiLGMpfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZVZhbGlkYXRpb25FcnJvcj1mdW5jdGlvbihhLGIsYyl7aWYobnVsbCE9YSYmIXRoaXMuaXNBbGxvd0RhbmdsaW5nRWRnZXMoKSYmKG51bGw9PWJ8fG51bGw9PWMpKXJldHVybiIiO2lmKG51bGwhPWEmJm51bGw9PXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMCkmJm51bGw9PXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMSkpcmV0dXJuIG51bGw7aWYoIXRoaXMuYWxsb3dMb29wcyYmYj09YyYmbnVsbCE9Ynx8IXRoaXMuaXNWYWxpZENvbm5lY3Rpb24oYixjKSlyZXR1cm4iIjtpZihudWxsIT1iJiZudWxsIT1jKXt2YXIgZD0iIjtpZighdGhpcy5tdWx0aWdyYXBoKXt2YXIgZT10aGlzLm1vZGVsLmdldEVkZ2VzQmV0d2VlbihiLGMsITApO2lmKDE8ZS5sZW5ndGh8fDE9PWUubGVuZ3RoJiZlWzBdIT1hKWQrPShteFJlc291cmNlcy5nZXQodGhpcy5hbHJlYWR5Q29ubmVjdGVkUmVzb3VyY2UpfHx0aGlzLmFscmVhZHlDb25uZWN0ZWRSZXNvdXJjZSkrCiJcbiJ9dmFyIGU9dGhpcy5tb2RlbC5nZXREaXJlY3RlZEVkZ2VDb3VudChiLCEwLGEpLGY9dGhpcy5tb2RlbC5nZXREaXJlY3RlZEVkZ2VDb3VudChjLCExLGEpO2lmKG51bGwhPXRoaXMubXVsdGlwbGljaXRpZXMpZm9yKHZhciBnPTA7Zzx0aGlzLm11bHRpcGxpY2l0aWVzLmxlbmd0aDtnKyspe3ZhciBrPXRoaXMubXVsdGlwbGljaXRpZXNbZ10uY2hlY2sodGhpcyxhLGIsYyxlLGYpO251bGwhPWsmJihkKz1rKX1rPXRoaXMudmFsaWRhdGVFZGdlKGEsYixjKTtudWxsIT1rJiYoZCs9ayk7cmV0dXJuIDA8ZC5sZW5ndGg/ZDpudWxsfXJldHVybiB0aGlzLmFsbG93RGFuZ2xpbmdFZGdlcz9udWxsOiIifTtteEdyYXBoLnByb3RvdHlwZS52YWxpZGF0ZUVkZ2U9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBudWxsfTsKbXhHcmFwaC5wcm90b3R5cGUudmFsaWRhdGVHcmFwaD1mdW5jdGlvbihhLGIpe2E9bnVsbCE9YT9hOnRoaXMubW9kZWwuZ2V0Um9vdCgpO2I9bnVsbCE9Yj9iOnt9O2Zvcih2YXIgYz0hMCxkPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxlPTA7ZTxkO2UrKyl7dmFyIGY9dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGEsZSksZz1iO3RoaXMuaXNWYWxpZFJvb3QoZikmJihnPXt9KTtnPXRoaXMudmFsaWRhdGVHcmFwaChmLGcpO251bGwhPWc/dGhpcy5zZXRDZWxsV2FybmluZyhmLGcucmVwbGFjZSgvXG4vZywiPGJyPiIpKTp0aGlzLnNldENlbGxXYXJuaW5nKGYsbnVsbCk7Yz1jJiZudWxsPT1nfWQ9IiI7dGhpcy5pc0NlbGxDb2xsYXBzZWQoYSkmJiFjJiYoZCs9KG14UmVzb3VyY2VzLmdldCh0aGlzLmNvbnRhaW5zVmFsaWRhdGlvbkVycm9yc1Jlc291cmNlKXx8dGhpcy5jb250YWluc1ZhbGlkYXRpb25FcnJvcnNSZXNvdXJjZSkrIlxuIik7ZD10aGlzLm1vZGVsLmlzRWRnZShhKT9kKwoodGhpcy5nZXRFZGdlVmFsaWRhdGlvbkVycm9yKGEsdGhpcy5tb2RlbC5nZXRUZXJtaW5hbChhLCEwKSx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsITEpKXx8IiIpOmQrKHRoaXMuZ2V0Q2VsbFZhbGlkYXRpb25FcnJvcihhKXx8IiIpO2U9dGhpcy52YWxpZGF0ZUNlbGwoYSxiKTtudWxsIT1lJiYoZCs9ZSk7bnVsbD09dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSkmJnRoaXMudmlldy52YWxpZGF0ZSgpO3JldHVybiAwPGQubGVuZ3RofHwhYz9kOm51bGx9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDZWxsVmFsaWRhdGlvbkVycm9yPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubW9kZWwuZ2V0RGlyZWN0ZWRFZGdlQ291bnQoYSwhMCksYz10aGlzLm1vZGVsLmdldERpcmVjdGVkRWRnZUNvdW50KGEsITEpO2E9dGhpcy5tb2RlbC5nZXRWYWx1ZShhKTt2YXIgZD0iIjtpZihudWxsIT10aGlzLm11bHRpcGxpY2l0aWVzKWZvcih2YXIgZT0wO2U8dGhpcy5tdWx0aXBsaWNpdGllcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLm11bHRpcGxpY2l0aWVzW2VdO2Yuc291cmNlJiZteFV0aWxzLmlzTm9kZShhLGYudHlwZSxmLmF0dHIsZi52YWx1ZSkmJihiPmYubWF4fHxiPGYubWluKT9kKz1mLmNvdW50RXJyb3IrIlxuIjohZi5zb3VyY2UmJm14VXRpbHMuaXNOb2RlKGEsZi50eXBlLGYuYXR0cixmLnZhbHVlKSYmKGM+Zi5tYXh8fGM8Zi5taW4pJiYoZCs9Zi5jb3VudEVycm9yKyJcbiIpfXJldHVybiAwPGQubGVuZ3RoP2Q6bnVsbH07Cm14R3JhcGgucHJvdG90eXBlLnZhbGlkYXRlQ2VsbD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsfTtteEdyYXBoLnByb3RvdHlwZS5nZXRCYWNrZ3JvdW5kSW1hZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kSW1hZ2V9O214R3JhcGgucHJvdG90eXBlLnNldEJhY2tncm91bmRJbWFnZT1mdW5jdGlvbihhKXt0aGlzLmJhY2tncm91bmRJbWFnZT1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRGb2xkaW5nSW1hZ2U9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSYmdGhpcy5mb2xkaW5nRW5hYmxlZCYmIXRoaXMuZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSl7dmFyIGI9dGhpcy5pc0NlbGxDb2xsYXBzZWQoYS5jZWxsKTtpZih0aGlzLmlzQ2VsbEZvbGRhYmxlKGEuY2VsbCwhYikpcmV0dXJuIGI/dGhpcy5jb2xsYXBzZWRJbWFnZTp0aGlzLmV4cGFuZGVkSW1hZ2V9cmV0dXJuIG51bGx9OwpteEdyYXBoLnByb3RvdHlwZS5jb252ZXJ0VmFsdWVUb1N0cmluZz1mdW5jdGlvbihhKXthPXRoaXMubW9kZWwuZ2V0VmFsdWUoYSk7aWYobnVsbCE9YSl7aWYobXhVdGlscy5pc05vZGUoYSkpcmV0dXJuIGEubm9kZU5hbWU7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGEudG9TdHJpbmcpcmV0dXJuIGEudG9TdHJpbmcoKX1yZXR1cm4iIn07bXhHcmFwaC5wcm90b3R5cGUuZ2V0TGFiZWw9ZnVuY3Rpb24oYSl7dmFyIGI9IiI7aWYodGhpcy5sYWJlbHNWaXNpYmxlJiZudWxsIT1hKXt2YXIgYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7bXhVdGlscy5nZXRWYWx1ZShjLG14Q29uc3RhbnRzLlNUWUxFX05PTEFCRUwsITEpfHwoYj10aGlzLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGEpKX1yZXR1cm4gYn07bXhHcmFwaC5wcm90b3R5cGUuaXNIdG1sTGFiZWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNIdG1sTGFiZWxzKCl9O214R3JhcGgucHJvdG90eXBlLmlzSHRtbExhYmVscz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmh0bWxMYWJlbHN9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRIdG1sTGFiZWxzPWZ1bmN0aW9uKGEpe3RoaXMuaHRtbExhYmVscz1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1dyYXBwaW5nPWZ1bmN0aW9uKGEpe3JldHVybiJ3cmFwIj09dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpW214Q29uc3RhbnRzLlNUWUxFX1dISVRFX1NQQUNFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNMYWJlbENsaXBwZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuImhpZGRlbiI9PXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKVtteENvbnN0YW50cy5TVFlMRV9PVkVSRkxPV119OwpteEdyYXBoLnByb3RvdHlwZS5nZXRUb29sdGlwPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW51bGw7bnVsbCE9YSYmKG51bGw9PWEuY29udHJvbHx8YiE9YS5jb250cm9sLm5vZGUmJmIucGFyZW50Tm9kZSE9YS5jb250cm9sLm5vZGV8fChlPXRoaXMuY29sbGFwc2VFeHBhbmRSZXNvdXJjZSxlPW14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldChlKXx8ZSkucmVwbGFjZSgvXFxuL2csIjxicj4iKSksbnVsbD09ZSYmbnVsbCE9YS5vdmVybGF5cyYmYS5vdmVybGF5cy52aXNpdChmdW5jdGlvbihhLGMpe251bGwhPWV8fGIhPWMubm9kZSYmYi5wYXJlbnROb2RlIT1jLm5vZGV8fChlPWMub3ZlcmxheS50b1N0cmluZygpKX0pLG51bGw9PWUmJihjPXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmdldEhhbmRsZXIoYS5jZWxsKSxudWxsIT1jJiYiZnVuY3Rpb24iPT10eXBlb2YgYy5nZXRUb29sdGlwRm9yTm9kZSYmKGU9Yy5nZXRUb29sdGlwRm9yTm9kZShiKSkpLG51bGw9PQplJiYoZT10aGlzLmdldFRvb2x0aXBGb3JDZWxsKGEuY2VsbCkpKTtyZXR1cm4gZX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0VG9vbHRpcEZvckNlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEuZ2V0VG9vbHRpcD9hLmdldFRvb2x0aXAoKTp0aGlzLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGEpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRMaW5rRm9yQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q3Vyc29yRm9yTW91c2VFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRDdXJzb3JGb3JDZWxsKGEuZ2V0Q2VsbCgpKX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q3Vyc29yRm9yQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmdldFN0YXJ0U2l6ZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBteFJlY3RhbmdsZSxkPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhLGIpLGU9cGFyc2VJbnQobXhVdGlscy5nZXRWYWx1ZShkLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5ERUZBVUxUX1NUQVJUU0laRSkpO214VXRpbHMuZ2V0VmFsdWUoZCxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLCEwKT9jLmhlaWdodD1lOmMud2lkdGg9ZTtyZXR1cm4gY307Cm14R3JhcGgucHJvdG90eXBlLmdldFN3aW1sYW5lRGlyZWN0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0VmFsdWUoYSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpLGM9MT09bXhVdGlscy5nZXRWYWx1ZShhLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBILDApLGQ9MT09bXhVdGlscy5nZXRWYWx1ZShhLG14Q29uc3RhbnRzLlNUWUxFX0ZMSVBWLDApO2E9bXhVdGlscy5nZXRWYWx1ZShhLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApPzA6MztiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/YS0tOmI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2ErPTI6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIJiYoYSs9MSk7Yj1teFV0aWxzLm1vZChhLDIpO2MmJjE9PWImJihhKz0yKTtkJiYwPT1iJiYoYSs9Mik7cmV0dXJuW214Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCxteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCwKbXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRILG14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUXVtteFV0aWxzLm1vZChhLDQpXX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0QWN0dWFsU3RhcnRTaXplPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14UmVjdGFuZ2xlO2lmKHRoaXMuaXNTd2ltbGFuZShhLGIpKXt2YXIgZD10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSxiKSxlPXBhcnNlSW50KG14VXRpbHMuZ2V0VmFsdWUoZCxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9TVEFSVFNJWkUpKSxkPXRoaXMuZ2V0U3dpbWxhbmVEaXJlY3Rpb24oZCk7ZD09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIP2MueT1lOmQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUP2MueD1lOmQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9jLmhlaWdodD1lOmMud2lkdGg9ZX1yZXR1cm4gY307Cm14R3JhcGgucHJvdG90eXBlLmdldEltYWdlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLnN0eWxlP2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSU1BR0VdOm51bGx9O214R3JhcGgucHJvdG90eXBlLmlzVHJhbnNwYXJlbnRTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYj0hMTtpZihudWxsIT1hKXZhciBiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUixteENvbnN0YW50cy5OT05FKSxjPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuTk9ORSksYj1iPT1teENvbnN0YW50cy5OT05FJiZjPT1teENvbnN0YW50cy5OT05FJiZudWxsPT10aGlzLmdldEltYWdlKGEpO3JldHVybiBifTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0VmVydGljYWxBbGlnbj1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9YS5zdHlsZT9hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0FMSUdOXXx8bXhDb25zdGFudHMuQUxJR05fTUlERExFOm51bGx9O214R3JhcGgucHJvdG90eXBlLmdldEluZGljYXRvckNvbG9yPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLnN0eWxlP2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSU5ESUNBVE9SX0NPTE9SXTpudWxsfTtteEdyYXBoLnByb3RvdHlwZS5nZXRJbmRpY2F0b3JHcmFkaWVudENvbG9yPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZudWxsIT1hLnN0eWxlP2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfSU5ESUNBVE9SX0dSQURJRU5UQ09MT1JdOm51bGx9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRJbmRpY2F0b3JTaGFwZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmbnVsbCE9YS5zdHlsZT9hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0lORElDQVRPUl9TSEFQRV06bnVsbH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0SW5kaWNhdG9ySW1hZ2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEuc3R5bGU/YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTkRJQ0FUT1JfSU1BR0VdOm51bGx9O214R3JhcGgucHJvdG90eXBlLmdldEJvcmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJvcmRlcn07bXhHcmFwaC5wcm90b3R5cGUuc2V0Qm9yZGVyPWZ1bmN0aW9uKGEpe3RoaXMuYm9yZGVyPWF9OwpteEdyYXBoLnByb3RvdHlwZS5pc1N3aW1sYW5lPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGw9PWF8fHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpPT10aGlzLm1vZGVsLmdldFJvb3QoKXx8dGhpcy5tb2RlbC5pc0VkZ2UoYSk/ITE6dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEsYilbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdPT1teENvbnN0YW50cy5TSEFQRV9TV0lNTEFORX07bXhHcmFwaC5wcm90b3R5cGUuaXNSZXNpemVDb250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXNpemVDb250YWluZXJ9O214R3JhcGgucHJvdG90eXBlLnNldFJlc2l6ZUNvbnRhaW5lcj1mdW5jdGlvbihhKXt0aGlzLnJlc2l6ZUNvbnRhaW5lcj1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteEdyYXBoLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNFc2NhcGVFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXNjYXBlRW5hYmxlZH07bXhHcmFwaC5wcm90b3R5cGUuc2V0RXNjYXBlRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVzY2FwZUVuYWJsZWQ9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNJbnZva2VzU3RvcENlbGxFZGl0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52b2tlc1N0b3BDZWxsRWRpdGluZ307bXhHcmFwaC5wcm90b3R5cGUuc2V0SW52b2tlc1N0b3BDZWxsRWRpdGluZz1mdW5jdGlvbihhKXt0aGlzLmludm9rZXNTdG9wQ2VsbEVkaXRpbmc9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNFbnRlclN0b3BzQ2VsbEVkaXRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnRlclN0b3BzQ2VsbEVkaXRpbmd9O214R3JhcGgucHJvdG90eXBlLnNldEVudGVyU3RvcHNDZWxsRWRpdGluZz1mdW5jdGlvbihhKXt0aGlzLmVudGVyU3RvcHNDZWxsRWRpdGluZz1hfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsTG9ja2VkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubW9kZWwuZ2V0R2VvbWV0cnkoYSk7cmV0dXJuIHRoaXMuaXNDZWxsc0xvY2tlZCgpfHxudWxsIT1iJiZ0aGlzLm1vZGVsLmlzVmVydGV4KGEpJiZiLnJlbGF0aXZlfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxzTG9ja2VkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbHNMb2NrZWR9O214R3JhcGgucHJvdG90eXBlLnNldENlbGxzTG9ja2VkPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNMb2NrZWQ9YX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2xvbmVhYmxlQ2VsbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuZmlsdGVyQ2VsbHMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0NlbGxDbG9uZWFibGUoYSl9KSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxDbG9uZWFibGU9ZnVuY3Rpb24oYSl7YT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIHRoaXMuaXNDZWxsc0Nsb25lYWJsZSgpJiYwIT1hW214Q29uc3RhbnRzLlNUWUxFX0NMT05FQUJMRV19O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbHNDbG9uZWFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsc0Nsb25lYWJsZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNDbG9uZWFibGU9ZnVuY3Rpb24oYSl7dGhpcy5jZWxsc0Nsb25lYWJsZT1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRFeHBvcnRhYmxlQ2VsbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuZmlsdGVyQ2VsbHMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jYW5FeHBvcnRDZWxsKGEpfSkpfTtteEdyYXBoLnByb3RvdHlwZS5jYW5FeHBvcnRDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmV4cG9ydEVuYWJsZWR9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRJbXBvcnRhYmxlQ2VsbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuZmlsdGVyQ2VsbHMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jYW5JbXBvcnRDZWxsKGEpfSkpfTtteEdyYXBoLnByb3RvdHlwZS5jYW5JbXBvcnRDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmltcG9ydEVuYWJsZWR9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbFNlbGVjdGFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNDZWxsc1NlbGVjdGFibGUoKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc1NlbGVjdGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsc1NlbGVjdGFibGV9O214R3JhcGgucHJvdG90eXBlLnNldENlbGxzU2VsZWN0YWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzU2VsZWN0YWJsZT1hfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0RGVsZXRhYmxlQ2VsbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuZmlsdGVyQ2VsbHMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0NlbGxEZWxldGFibGUoYSl9KSl9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbERlbGV0YWJsZT1mdW5jdGlvbihhKXthPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4gdGhpcy5pc0NlbGxzRGVsZXRhYmxlKCkmJjAhPWFbbXhDb25zdGFudHMuU1RZTEVfREVMRVRBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc0RlbGV0YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGxzRGVsZXRhYmxlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsc0RlbGV0YWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzRGVsZXRhYmxlPWF9OwpteEdyYXBoLnByb3RvdHlwZS5pc0xhYmVsTW92YWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5pc0NlbGxMb2NrZWQoYSkmJih0aGlzLm1vZGVsLmlzRWRnZShhKSYmdGhpcy5lZGdlTGFiZWxzTW92YWJsZXx8dGhpcy5tb2RlbC5pc1ZlcnRleChhKSYmdGhpcy52ZXJ0ZXhMYWJlbHNNb3ZhYmxlKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsUm90YXRhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiAwIT10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSlbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0TW92YWJsZUNlbGxzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1vZGVsLmZpbHRlckNlbGxzKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNDZWxsTW92YWJsZShhKX0pKX07Cm14R3JhcGgucHJvdG90eXBlLmlzQ2VsbE1vdmFibGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzQ2VsbHNNb3ZhYmxlKCkmJiF0aGlzLmlzQ2VsbExvY2tlZChhKSYmMCE9YltteENvbnN0YW50cy5TVFlMRV9NT1ZBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc01vdmFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsc01vdmFibGV9O214R3JhcGgucHJvdG90eXBlLnNldENlbGxzTW92YWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzTW92YWJsZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0dyaWRFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JpZEVuYWJsZWR9O214R3JhcGgucHJvdG90eXBlLnNldEdyaWRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZ3JpZEVuYWJsZWQ9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNQb3J0c0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3J0c0VuYWJsZWR9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRQb3J0c0VuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5wb3J0c0VuYWJsZWQ9YX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0R3JpZFNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmlkU2l6ZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0R3JpZFNpemU9ZnVuY3Rpb24oYSl7dGhpcy5ncmlkU2l6ZT1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRUb2xlcmFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2xlcmFuY2V9O214R3JhcGgucHJvdG90eXBlLnNldFRvbGVyYW5jZT1mdW5jdGlvbihhKXt0aGlzLnRvbGVyYW5jZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1ZlcnRleExhYmVsc01vdmFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXhMYWJlbHNNb3ZhYmxlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRWZXJ0ZXhMYWJlbHNNb3ZhYmxlPWZ1bmN0aW9uKGEpe3RoaXMudmVydGV4TGFiZWxzTW92YWJsZT1hfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNFZGdlTGFiZWxzTW92YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VMYWJlbHNNb3ZhYmxlfTtteEdyYXBoLnByb3RvdHlwZS5zZXRFZGdlTGFiZWxzTW92YWJsZT1mdW5jdGlvbihhKXt0aGlzLmVkZ2VMYWJlbHNNb3ZhYmxlPWF9O214R3JhcGgucHJvdG90eXBlLmlzU3dpbWxhbmVOZXN0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3dpbWxhbmVOZXN0aW5nfTtteEdyYXBoLnByb3RvdHlwZS5zZXRTd2ltbGFuZU5lc3Rpbmc9ZnVuY3Rpb24oYSl7dGhpcy5zd2ltbGFuZU5lc3Rpbmc9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNTd2ltbGFuZVNlbGVjdGlvbkVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zd2ltbGFuZVNlbGVjdGlvbkVuYWJsZWR9O214R3JhcGgucHJvdG90eXBlLnNldFN3aW1sYW5lU2VsZWN0aW9uRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLnN3aW1sYW5lU2VsZWN0aW9uRW5hYmxlZD1hfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNNdWx0aWdyYXBoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubXVsdGlncmFwaH07bXhHcmFwaC5wcm90b3R5cGUuc2V0TXVsdGlncmFwaD1mdW5jdGlvbihhKXt0aGlzLm11bHRpZ3JhcGg9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNBbGxvd0xvb3BzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxsb3dMb29wc307bXhHcmFwaC5wcm90b3R5cGUuc2V0QWxsb3dEYW5nbGluZ0VkZ2VzPWZ1bmN0aW9uKGEpe3RoaXMuYWxsb3dEYW5nbGluZ0VkZ2VzPWF9O214R3JhcGgucHJvdG90eXBlLmlzQWxsb3dEYW5nbGluZ0VkZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxsb3dEYW5nbGluZ0VkZ2VzfTtteEdyYXBoLnByb3RvdHlwZS5zZXRDb25uZWN0YWJsZUVkZ2VzPWZ1bmN0aW9uKGEpe3RoaXMuY29ubmVjdGFibGVFZGdlcz1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlRWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25uZWN0YWJsZUVkZ2VzfTsKbXhHcmFwaC5wcm90b3R5cGUuc2V0Q2xvbmVJbnZhbGlkRWRnZXM9ZnVuY3Rpb24oYSl7dGhpcy5jbG9uZUludmFsaWRFZGdlcz1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0Nsb25lSW52YWxpZEVkZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmVJbnZhbGlkRWRnZXN9O214R3JhcGgucHJvdG90eXBlLnNldEFsbG93TG9vcHM9ZnVuY3Rpb24oYSl7dGhpcy5hbGxvd0xvb3BzPWF9O214R3JhcGgucHJvdG90eXBlLmlzRGlzY29ubmVjdE9uTW92ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc2Nvbm5lY3RPbk1vdmV9O214R3JhcGgucHJvdG90eXBlLnNldERpc2Nvbm5lY3RPbk1vdmU9ZnVuY3Rpb24oYSl7dGhpcy5kaXNjb25uZWN0T25Nb3ZlPWF9O214R3JhcGgucHJvdG90eXBlLmlzRHJvcEVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kcm9wRW5hYmxlZH07Cm14R3JhcGgucHJvdG90eXBlLnNldERyb3BFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZHJvcEVuYWJsZWQ9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNTcGxpdEVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpdEVuYWJsZWR9O214R3JhcGgucHJvdG90eXBlLnNldFNwbGl0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLnNwbGl0RW5hYmxlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxSZXNpemFibGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzQ2VsbHNSZXNpemFibGUoKSYmIXRoaXMuaXNDZWxsTG9ja2VkKGEpJiYiMCIhPW14VXRpbHMuZ2V0VmFsdWUoYixteENvbnN0YW50cy5TVFlMRV9SRVNJWkFCTEUsIjEiKX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc1Jlc2l6YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGxzUmVzaXphYmxlfTsKbXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNSZXNpemFibGU9ZnVuY3Rpb24oYSl7dGhpcy5jZWxsc1Jlc2l6YWJsZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1Rlcm1pbmFsUG9pbnRNb3ZhYmxlPWZ1bmN0aW9uKGEsYil7cmV0dXJuITB9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbEJlbmRhYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4gdGhpcy5pc0NlbGxzQmVuZGFibGUoKSYmIXRoaXMuaXNDZWxsTG9ja2VkKGEpJiYwIT1iW214Q29uc3RhbnRzLlNUWUxFX0JFTkRBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc0JlbmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbHNCZW5kYWJsZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNCZW5kYWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzQmVuZGFibGU9YX07Cm14R3JhcGgucHJvdG90eXBlLmlzQ2VsbEVkaXRhYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4gdGhpcy5pc0NlbGxzRWRpdGFibGUoKSYmIXRoaXMuaXNDZWxsTG9ja2VkKGEpJiYwIT1iW214Q29uc3RhbnRzLlNUWUxFX0VESVRBQkxFXX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsc0VkaXRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbHNFZGl0YWJsZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q2VsbHNFZGl0YWJsZT1mdW5jdGlvbihhKXt0aGlzLmNlbGxzRWRpdGFibGU9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsRGlzY29ubmVjdGFibGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLmlzQ2VsbHNEaXNjb25uZWN0YWJsZSgpJiYhdGhpcy5pc0NlbGxMb2NrZWQoYSl9O214R3JhcGgucHJvdG90eXBlLmlzQ2VsbHNEaXNjb25uZWN0YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGxzRGlzY29ubmVjdGFibGV9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRDZWxsc0Rpc2Nvbm5lY3RhYmxlPWZ1bmN0aW9uKGEpe3RoaXMuY2VsbHNEaXNjb25uZWN0YWJsZT1hfTtteEdyYXBoLnByb3RvdHlwZS5pc1ZhbGlkU291cmNlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hJiZ0aGlzLmFsbG93RGFuZ2xpbmdFZGdlc3x8bnVsbCE9YSYmKCF0aGlzLm1vZGVsLmlzRWRnZShhKXx8dGhpcy5jb25uZWN0YWJsZUVkZ2VzKSYmdGhpcy5pc0NlbGxDb25uZWN0YWJsZShhKX07bXhHcmFwaC5wcm90b3R5cGUuaXNWYWxpZFRhcmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc1ZhbGlkU291cmNlKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc1ZhbGlkQ29ubmVjdGlvbj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmlzVmFsaWRTb3VyY2UoYSkmJnRoaXMuaXNWYWxpZFRhcmdldChiKX07bXhHcmFwaC5wcm90b3R5cGUuc2V0Q29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5zZXRFbmFibGVkKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNDb25uZWN0YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmlzRW5hYmxlZCgpfTtteEdyYXBoLnByb3RvdHlwZS5zZXRUb29sdGlwcz1mdW5jdGlvbihhKXt0aGlzLnRvb2x0aXBIYW5kbGVyLnNldEVuYWJsZWQoYSl9O214R3JhcGgucHJvdG90eXBlLnNldFBhbm5pbmc9ZnVuY3Rpb24oYSl7dGhpcy5wYW5uaW5nSGFuZGxlci5wYW5uaW5nRW5hYmxlZD1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0VkaXRpbmc9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5jZWxsRWRpdG9yKXt2YXIgYj10aGlzLmNlbGxFZGl0b3IuZ2V0RWRpdGluZ0NlbGwoKTtyZXR1cm4gbnVsbD09YT9udWxsIT1iOmE9PWJ9cmV0dXJuITF9O214R3JhcGgucHJvdG90eXBlLmlzQXV0b1NpemVDZWxsPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzQXV0b1NpemVDZWxscygpfHwxPT1hW214Q29uc3RhbnRzLlNUWUxFX0FVVE9TSVpFXX07Cm14R3JhcGgucHJvdG90eXBlLmlzQXV0b1NpemVDZWxscz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF1dG9TaXplQ2VsbHN9O214R3JhcGgucHJvdG90eXBlLnNldEF1dG9TaXplQ2VsbHM9ZnVuY3Rpb24oYSl7dGhpcy5hdXRvU2l6ZUNlbGxzPWF9O214R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50PWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdldE1vZGVsKCkuaXNFZGdlKGEpJiZ0aGlzLmlzRXh0ZW5kUGFyZW50cygpfTtteEdyYXBoLnByb3RvdHlwZS5pc0V4dGVuZFBhcmVudHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHRlbmRQYXJlbnRzfTtteEdyYXBoLnByb3RvdHlwZS5zZXRFeHRlbmRQYXJlbnRzPWZ1bmN0aW9uKGEpe3RoaXMuZXh0ZW5kUGFyZW50cz1hfTtteEdyYXBoLnByb3RvdHlwZS5pc0V4dGVuZFBhcmVudHNPbkFkZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5leHRlbmRQYXJlbnRzT25BZGR9OwpteEdyYXBoLnByb3RvdHlwZS5zZXRFeHRlbmRQYXJlbnRzT25BZGQ9ZnVuY3Rpb24oYSl7dGhpcy5leHRlbmRQYXJlbnRzT25BZGQ9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNFeHRlbmRQYXJlbnRzT25Nb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXh0ZW5kUGFyZW50c09uTW92ZX07bXhHcmFwaC5wcm90b3R5cGUuc2V0RXh0ZW5kUGFyZW50c09uTW92ZT1mdW5jdGlvbihhKXt0aGlzLmV4dGVuZFBhcmVudHNPbk1vdmU9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNSZWN1cnNpdmVSZXNpemU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucmVjdXJzaXZlUmVzaXplfTtteEdyYXBoLnByb3RvdHlwZS5zZXRSZWN1cnNpdmVSZXNpemU9ZnVuY3Rpb24oYSl7dGhpcy5yZWN1cnNpdmVSZXNpemU9YX07bXhHcmFwaC5wcm90b3R5cGUuaXNDb25zdHJhaW5DaGlsZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc0NvbnN0cmFpbkNoaWxkcmVuKCkmJiF0aGlzLmdldE1vZGVsKCkuaXNFZGdlKHRoaXMuZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYSkpfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNDb25zdHJhaW5DaGlsZHJlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cmFpbkNoaWxkcmVufTtteEdyYXBoLnByb3RvdHlwZS5zZXRDb25zdHJhaW5DaGlsZHJlbj1mdW5jdGlvbihhKXt0aGlzLmNvbnN0cmFpbkNoaWxkcmVuPWF9O214R3JhcGgucHJvdG90eXBlLmlzQ29uc3RyYWluUmVsYXRpdmVDaGlsZHJlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cmFpblJlbGF0aXZlQ2hpbGRyZW59O214R3JhcGgucHJvdG90eXBlLnNldENvbnN0cmFpblJlbGF0aXZlQ2hpbGRyZW49ZnVuY3Rpb24oYSl7dGhpcy5jb25zdHJhaW5SZWxhdGl2ZUNoaWxkcmVuPWF9O214R3JhcGgucHJvdG90eXBlLmlzQWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzfTsKbXhHcmFwaC5wcm90b3R5cGUuc2V0QWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKGEpe3RoaXMuYWxsb3dOZWdhdGl2ZUNvb3JkaW5hdGVzPWF9O214R3JhcGgucHJvdG90eXBlLmdldE92ZXJsYXA9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNBbGxvd092ZXJsYXBQYXJlbnQoYSk/dGhpcy5kZWZhdWx0T3ZlcmxhcDowfTtteEdyYXBoLnByb3RvdHlwZS5pc0FsbG93T3ZlcmxhcFBhcmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Rm9sZGFibGVDZWxscz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm1vZGVsLmZpbHRlckNlbGxzKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNDZWxsRm9sZGFibGUoYSxiKX0pKX07Cm14R3JhcGgucHJvdG90eXBlLmlzQ2VsbEZvbGRhYmxlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiAwPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSYmMCE9Y1tteENvbnN0YW50cy5TVFlMRV9GT0xEQUJMRV19O214R3JhcGgucHJvdG90eXBlLmlzVmFsaWREcm9wVGFyZ2V0PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbnVsbCE9YSYmKHRoaXMuaXNTcGxpdEVuYWJsZWQoKSYmdGhpcy5pc1NwbGl0VGFyZ2V0KGEsYixjKXx8IXRoaXMubW9kZWwuaXNFZGdlKGEpJiYodGhpcy5pc1N3aW1sYW5lKGEpfHwwPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSYmIXRoaXMuaXNDZWxsQ29sbGFwc2VkKGEpKSl9OwpteEdyYXBoLnByb3RvdHlwZS5pc1NwbGl0VGFyZ2V0PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5tb2RlbC5pc0VkZ2UoYSkmJm51bGwhPWImJjE9PWIubGVuZ3RoJiZ0aGlzLmlzQ2VsbENvbm5lY3RhYmxlKGJbMF0pJiZudWxsPT10aGlzLmdldEVkZ2VWYWxpZGF0aW9uRXJyb3IoYSx0aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsITApLGJbMF0pPyhjPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoYSwhMCksYT10aGlzLm1vZGVsLmdldFRlcm1pbmFsKGEsITEpLCF0aGlzLm1vZGVsLmlzQW5jZXN0b3IoYlswXSxjKSYmIXRoaXMubW9kZWwuaXNBbmNlc3RvcihiWzBdLGEpKTohMX07Cm14R3JhcGgucHJvdG90eXBlLmdldERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoIXRoaXMuaXNTd2ltbGFuZU5lc3RpbmcoKSlmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKylpZih0aGlzLmlzU3dpbWxhbmUoYVtlXSkpcmV0dXJuIG51bGw7ZT1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoYiksbXhFdmVudC5nZXRDbGllbnRZKGIpKTtlLngtPXRoaXMucGFuRHg7ZS55LT10aGlzLnBhbkR5O2U9dGhpcy5nZXRTd2ltbGFuZUF0KGUueCxlLnkpO2lmKG51bGw9PWMpYz1lO2Vsc2UgaWYobnVsbCE9ZSl7Zm9yKHZhciBmPXRoaXMubW9kZWwuZ2V0UGFyZW50KGUpO251bGwhPWYmJnRoaXMuaXNTd2ltbGFuZShmKSYmZiE9YzspZj10aGlzLm1vZGVsLmdldFBhcmVudChmKTtmPT1jJiYoYz1lKX1mb3IoO251bGwhPWMmJiF0aGlzLmlzVmFsaWREcm9wVGFyZ2V0KGMsYSxiKSYmIXRoaXMubW9kZWwuaXNMYXllcihjKTspYz10aGlzLm1vZGVsLmdldFBhcmVudChjKTsKaWYobnVsbD09ZHx8IWQpZm9yKHZhciBnPWM7bnVsbCE9ZyYmMD5teFV0aWxzLmluZGV4T2YoYSxnKTspZz10aGlzLm1vZGVsLmdldFBhcmVudChnKTtyZXR1cm4gdGhpcy5tb2RlbC5pc0xheWVyKGMpfHxudWxsIT1nP251bGw6Y307bXhHcmFwaC5wcm90b3R5cGUuZ2V0RGVmYXVsdFBhcmVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0Q3VycmVudFJvb3QoKTtudWxsPT1hJiYoYT10aGlzLmRlZmF1bHRQYXJlbnQsbnVsbD09YSYmKGE9dGhpcy5tb2RlbC5nZXRSb290KCksYT10aGlzLm1vZGVsLmdldENoaWxkQXQoYSwwKSkpO3JldHVybiBhfTtteEdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0UGFyZW50PWZ1bmN0aW9uKGEpe3RoaXMuZGVmYXVsdFBhcmVudD1hfTtteEdyYXBoLnByb3RvdHlwZS5nZXRTd2ltbGFuZT1mdW5jdGlvbihhKXtmb3IoO251bGwhPWEmJiF0aGlzLmlzU3dpbWxhbmUoYSk7KWE9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRTd2ltbGFuZUF0PWZ1bmN0aW9uKGEsYixjKXtudWxsPT1jJiYoYz10aGlzLmdldEN1cnJlbnRSb290KCksbnVsbD09YyYmKGM9dGhpcy5tb2RlbC5nZXRSb290KCkpKTtpZihudWxsIT1jKWZvcih2YXIgZD10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYyksZT0wO2U8ZDtlKyspe3ZhciBmPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChjLGUpO2lmKG51bGwhPWYpe3ZhciBnPXRoaXMuZ2V0U3dpbWxhbmVBdChhLGIsZik7aWYobnVsbCE9ZylyZXR1cm4gZztpZih0aGlzLmlzQ2VsbFZpc2libGUoZikmJnRoaXMuaXNTd2ltbGFuZShmKSYmKGc9dGhpcy52aWV3LmdldFN0YXRlKGYpLHRoaXMuaW50ZXJzZWN0cyhnLGEsYikpKXJldHVybiBmfX1yZXR1cm4gbnVsbH07Cm14R3JhcGgucHJvdG90eXBlLmdldENlbGxBdD1mdW5jdGlvbihhLGIsYyxkLGUsZil7ZD1udWxsIT1kP2Q6ITA7ZT1udWxsIT1lP2U6ITA7bnVsbD09YyYmKGM9dGhpcy5nZXRDdXJyZW50Um9vdCgpLG51bGw9PWMmJihjPXRoaXMuZ2V0TW9kZWwoKS5nZXRSb290KCkpKTtpZihudWxsIT1jKWZvcih2YXIgZz10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYyktMTswPD1nO2ctLSl7dmFyIGs9dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGMsZyksbD10aGlzLmdldENlbGxBdChhLGIsayxkLGUsZik7aWYobnVsbCE9bClyZXR1cm4gbDtpZih0aGlzLmlzQ2VsbFZpc2libGUoaykmJihlJiZ0aGlzLm1vZGVsLmlzRWRnZShrKXx8ZCYmdGhpcy5tb2RlbC5pc1ZlcnRleChrKSkmJihsPXRoaXMudmlldy5nZXRTdGF0ZShrKSxudWxsIT1sJiYobnVsbD09Znx8IWYobCxhLGIpKSYmdGhpcy5pbnRlcnNlY3RzKGwsYSxiKSkpcmV0dXJuIGt9cmV0dXJuIG51bGx9OwpteEdyYXBoLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT1hKXt2YXIgZD1hLmFic29sdXRlUG9pbnRzO2lmKG51bGwhPWQpe2E9dGhpcy50b2xlcmFuY2UqdGhpcy50b2xlcmFuY2U7Zm9yKHZhciBlPWRbMF0sZj0xO2Y8ZC5sZW5ndGg7ZisrKXt2YXIgZz1kW2ZdO2lmKG14VXRpbHMucHRTZWdEaXN0U3EoZS54LGUueSxnLngsZy55LGIsYyk8PWEpcmV0dXJuITA7ZT1nfX1lbHNlIGlmKGU9bXhVdGlscy50b1JhZGlhbnMobXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OKXx8MCksMCE9ZSYmKGQ9TWF0aC5jb3MoLWUpLGU9TWF0aC5zaW4oLWUpLGY9bmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS5nZXRDZW50ZXJZKCkpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoYixjKSxkLGUsZiksYj1lLngsYz1lLnkpLG14VXRpbHMuY29udGFpbnMoYSxiLGMpKXJldHVybiEwfXJldHVybiExfTsKbXhHcmFwaC5wcm90b3R5cGUuaGl0c1N3aW1sYW5lQ29udGVudD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5nZXRWaWV3KCkuZ2V0U3RhdGUoYSk7YT10aGlzLmdldFN0YXJ0U2l6ZShhKTtpZihudWxsIT1kKXt2YXIgZT10aGlzLmdldFZpZXcoKS5nZXRTY2FsZSgpO2ItPWQueDtjLT1kLnk7aWYoMDxhLndpZHRoJiYwPGImJmI+YS53aWR0aCplfHwwPGEuaGVpZ2h0JiYwPGMmJmM+YS5oZWlnaHQqZSlyZXR1cm4hMH1yZXR1cm4hMX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2hpbGRWZXJ0aWNlcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5nZXRDaGlsZENlbGxzKGEsITAsITEpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRDaGlsZEVkZ2VzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldENoaWxkQ2VsbHMoYSwhMSwhMCl9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRDaGlsZENlbGxzPWZ1bmN0aW9uKGEsYixjKXthPW51bGwhPWE/YTp0aGlzLmdldERlZmF1bHRQYXJlbnQoKTthPXRoaXMubW9kZWwuZ2V0Q2hpbGRDZWxscyhhLG51bGwhPWI/YjohMSxudWxsIT1jP2M6ITEpO2I9W107Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyl0aGlzLmlzQ2VsbFZpc2libGUoYVtjXSkmJmIucHVzaChhW2NdKTtyZXR1cm4gYn07bXhHcmFwaC5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbnM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5nZXRFZGdlcyhhLGIsITAsITAsITEpfTtteEdyYXBoLnByb3RvdHlwZS5nZXRJbmNvbWluZ0VkZ2VzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoYSxiLCEwLCExLCExKX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0T3V0Z29pbmdFZGdlcz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmdldEVkZ2VzKGEsYiwhMSwhMCwhMSl9OwpteEdyYXBoLnByb3RvdHlwZS5nZXRFZGdlcz1mdW5jdGlvbihhLGIsYyxkLGUsZil7Yz1udWxsIT1jP2M6ITA7ZD1udWxsIT1kP2Q6ITA7ZT1udWxsIT1lP2U6ITA7Zj1udWxsIT1mP2Y6ITE7Zm9yKHZhciBnPVtdLGs9dGhpcy5pc0NlbGxDb2xsYXBzZWQoYSksbD10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSksbT0wO208bDttKyspe3ZhciBuPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChhLG0pO2lmKGt8fCF0aGlzLmlzQ2VsbFZpc2libGUobikpZz1nLmNvbmNhdCh0aGlzLm1vZGVsLmdldEVkZ2VzKG4sYyxkKSl9Zz1nLmNvbmNhdCh0aGlzLm1vZGVsLmdldEVkZ2VzKGEsYyxkKSk7az1bXTtmb3IobT0wO208Zy5sZW5ndGg7bSsrKW49dGhpcy52aWV3LmdldFN0YXRlKGdbbV0pLGw9bnVsbCE9bj9uLmdldFZpc2libGVUZXJtaW5hbCghMCk6dGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChnW21dLCEwKSxuPW51bGwhPW4/bi5nZXRWaXNpYmxlVGVybWluYWwoITEpOnRoaXMudmlldy5nZXRWaXNpYmxlVGVybWluYWwoZ1ttXSwKITEpLChlJiZsPT1ufHxsIT1uJiYoYyYmbj09YSYmKG51bGw9PWJ8fHRoaXMuaXNWYWxpZEFuY2VzdG9yKGwsYixmKSl8fGQmJmw9PWEmJihudWxsPT1ifHx0aGlzLmlzVmFsaWRBbmNlc3RvcihuLGIsZikpKSkmJmsucHVzaChnW21dKTtyZXR1cm4ga307bXhHcmFwaC5wcm90b3R5cGUuaXNWYWxpZEFuY2VzdG9yPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYz90aGlzLm1vZGVsLmlzQW5jZXN0b3IoYixhKTp0aGlzLm1vZGVsLmdldFBhcmVudChhKT09Yn07Cm14R3JhcGgucHJvdG90eXBlLmdldE9wcG9zaXRlcz1mdW5jdGlvbihhLGIsYyxkKXtjPW51bGwhPWM/YzohMDtkPW51bGwhPWQ/ZDohMDt2YXIgZT1bXSxmPW5ldyBteERpY3Rpb25hcnk7aWYobnVsbCE9YSlmb3IodmFyIGc9MDtnPGEubGVuZ3RoO2crKyl7dmFyIGs9dGhpcy52aWV3LmdldFN0YXRlKGFbZ10pLGw9bnVsbCE9az9rLmdldFZpc2libGVUZXJtaW5hbCghMCk6dGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChhW2ddLCEwKSxrPW51bGwhPWs/ay5nZXRWaXNpYmxlVGVybWluYWwoITEpOnRoaXMudmlldy5nZXRWaXNpYmxlVGVybWluYWwoYVtnXSwhMSk7bD09YiYmbnVsbCE9ayYmayE9YiYmZD9mLmdldChrKXx8KGYucHV0KGssITApLGUucHVzaChrKSk6az09YiYmbnVsbCE9bCYmbCE9YiYmYyYmIWYuZ2V0KGwpJiYoZi5wdXQobCwhMCksZS5wdXNoKGwpKX1yZXR1cm4gZX07Cm14R3JhcGgucHJvdG90eXBlLmdldEVkZ2VzQmV0d2Vlbj1mdW5jdGlvbihhLGIsYyl7Yz1udWxsIT1jP2M6ITE7Zm9yKHZhciBkPXRoaXMuZ2V0RWRnZXMoYSksZT1bXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMudmlldy5nZXRTdGF0ZShkW2ZdKSxrPW51bGwhPWc/Zy5nZXRWaXNpYmxlVGVybWluYWwoITApOnRoaXMudmlldy5nZXRWaXNpYmxlVGVybWluYWwoZFtmXSwhMCksZz1udWxsIT1nP2cuZ2V0VmlzaWJsZVRlcm1pbmFsKCExKTp0aGlzLnZpZXcuZ2V0VmlzaWJsZVRlcm1pbmFsKGRbZl0sITEpOyhrPT1hJiZnPT1ifHwhYyYmaz09YiYmZz09YSkmJmUucHVzaChkW2ZdKX1yZXR1cm4gZX07Cm14R3JhcGgucHJvdG90eXBlLmdldFBvaW50Rm9yRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoYSksbXhFdmVudC5nZXRDbGllbnRZKGEpKSxkPXRoaXMudmlldy5zY2FsZSxlPXRoaXMudmlldy50cmFuc2xhdGUsZj0wIT1iP3RoaXMuZ3JpZFNpemUvMjowO2MueD10aGlzLnNuYXAoYy54L2QtZS54LWYpO2MueT10aGlzLnNuYXAoYy55L2QtZS55LWYpO3JldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2Y9bnVsbCE9Zj9mOltdO2lmKDA8Y3x8MDxkKXt2YXIgZz10aGlzLmdldE1vZGVsKCksaz1hK2MsbD1iK2Q7bnVsbD09ZSYmKGU9dGhpcy5nZXRDdXJyZW50Um9vdCgpLG51bGw9PWUmJihlPWcuZ2V0Um9vdCgpKSk7aWYobnVsbCE9ZSlmb3IodmFyIG09Zy5nZXRDaGlsZENvdW50KGUpLG49MDtuPG07bisrKXt2YXIgcD1nLmdldENoaWxkQXQoZSxuKSxxPXRoaXMudmlldy5nZXRTdGF0ZShwKTtpZihudWxsIT1xJiZ0aGlzLmlzQ2VsbFZpc2libGUocCkpe3ZhciByPW14VXRpbHMuZ2V0VmFsdWUocS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTil8fDA7MCE9ciYmKHE9bXhVdGlscy5nZXRCb3VuZGluZ0JveChxLHIpKTsoZy5pc0VkZ2UocCl8fGcuaXNWZXJ0ZXgocCkpJiZxLng+PWEmJnEueStxLmhlaWdodDw9bCYmcS55Pj1iJiZxLngrcS53aWR0aDw9az9mLnB1c2gocCk6dGhpcy5nZXRDZWxscyhhLApiLGMsZCxwLGYpfX19cmV0dXJuIGZ9O214R3JhcGgucHJvdG90eXBlLmdldENlbGxzQmV5b25kPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9W107aWYoZHx8ZSlpZihudWxsPT1jJiYoYz10aGlzLmdldERlZmF1bHRQYXJlbnQoKSksbnVsbCE9Yylmb3IodmFyIGc9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGMpLGs9MDtrPGc7aysrKXt2YXIgbD10aGlzLm1vZGVsLmdldENoaWxkQXQoYyxrKSxtPXRoaXMudmlldy5nZXRTdGF0ZShsKTt0aGlzLmlzQ2VsbFZpc2libGUobCkmJm51bGwhPW0mJighZHx8bS54Pj1hKSYmKCFlfHxtLnk+PWIpJiZmLnB1c2gobCl9cmV0dXJuIGZ9OwpteEdyYXBoLnByb3RvdHlwZS5maW5kVHJlZVJvb3RzPWZ1bmN0aW9uKGEsYixjKXtiPW51bGwhPWI/YjohMTtjPW51bGwhPWM/YzohMTt2YXIgZD1bXTtpZihudWxsIT1hKXtmb3IodmFyIGU9dGhpcy5nZXRNb2RlbCgpLGY9ZS5nZXRDaGlsZENvdW50KGEpLGc9bnVsbCxrPTAsbD0wO2w8ZjtsKyspe3ZhciBtPWUuZ2V0Q2hpbGRBdChhLGwpO2lmKHRoaXMubW9kZWwuaXNWZXJ0ZXgobSkmJnRoaXMuaXNDZWxsVmlzaWJsZShtKSl7Zm9yKHZhciBuPXRoaXMuZ2V0Q29ubmVjdGlvbnMobSxiP2E6bnVsbCkscD0wLHE9MCxyPTA7cjxuLmxlbmd0aDtyKyspdGhpcy52aWV3LmdldFZpc2libGVUZXJtaW5hbChuW3JdLCEwKT09bT9wKys6cSsrOyhjJiYwPT1wJiYwPHF8fCFjJiYwPT1xJiYwPHApJiZkLnB1c2gobSk7bj1jP3EtcDpwLXE7bj5rJiYoaz1uLGc9bSl9fTA9PWQubGVuZ3RoJiZudWxsIT1nJiZkLnB1c2goZyl9cmV0dXJuIGR9OwpteEdyYXBoLnByb3RvdHlwZS50cmF2ZXJzZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7aWYobnVsbCE9YyYmbnVsbCE9YSYmKGI9bnVsbCE9Yj9iOiEwLGY9bnVsbCE9Zj9mOiExLGU9ZXx8bmV3IG14RGljdGlvbmFyeSwhZS5nZXQoYSkmJihlLnB1dChhLCEwKSxkPWMoYSxkKSxudWxsPT1kfHxkKSkmJihkPXRoaXMubW9kZWwuZ2V0RWRnZUNvdW50KGEpLDA8ZCkpZm9yKHZhciBnPTA7ZzxkO2crKyl7dmFyIGs9dGhpcy5tb2RlbC5nZXRFZGdlQXQoYSxnKSxsPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoaywhMCk9PWE7YiYmIWYhPWx8fChsPXRoaXMubW9kZWwuZ2V0VGVybWluYWwoaywhbCksdGhpcy50cmF2ZXJzZShsLGIsYyxrLGUsZikpfX07bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsU2VsZWN0ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc1NlbGVjdGVkKGEpfTtteEdyYXBoLnByb3RvdHlwZS5pc1NlbGVjdGlvbkVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc0VtcHR5KCl9OwpteEdyYXBoLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2xlYXIoKX07bXhHcmFwaC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmNlbGxzLmxlbmd0aH07bXhHcmFwaC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQ2VsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2VsbHNbMF19O214R3JhcGgucHJvdG90eXBlLmdldFNlbGVjdGlvbkNlbGxzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jZWxscy5zbGljZSgpfTtteEdyYXBoLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25DZWxsPWZ1bmN0aW9uKGEpe3RoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5zZXRDZWxsKGEpfTtteEdyYXBoLnByb3RvdHlwZS5zZXRTZWxlY3Rpb25DZWxscz1mdW5jdGlvbihhKXt0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuc2V0Q2VsbHMoYSl9OwpteEdyYXBoLnByb3RvdHlwZS5hZGRTZWxlY3Rpb25DZWxsPWZ1bmN0aW9uKGEpe3RoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRDZWxsKGEpfTtteEdyYXBoLnByb3RvdHlwZS5hZGRTZWxlY3Rpb25DZWxscz1mdW5jdGlvbihhKXt0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuYWRkQ2VsbHMoYSl9O214R3JhcGgucHJvdG90eXBlLnJlbW92ZVNlbGVjdGlvbkNlbGw9ZnVuY3Rpb24oYSl7dGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnJlbW92ZUNlbGwoYSl9O214R3JhcGgucHJvdG90eXBlLnJlbW92ZVNlbGVjdGlvbkNlbGxzPWZ1bmN0aW9uKGEpe3RoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5yZW1vdmVDZWxscyhhKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0UmVnaW9uPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRDZWxscyhhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpO3RoaXMuc2VsZWN0Q2VsbHNGb3JFdmVudChjLGIpO3JldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0TmV4dENlbGw9ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdENlbGwoITApfTtteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RQcmV2aW91c0NlbGw9ZnVuY3Rpb24oKXt0aGlzLnNlbGVjdENlbGwoKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0UGFyZW50Q2VsbD1mdW5jdGlvbigpe3RoaXMuc2VsZWN0Q2VsbCghMSwhMCl9O214R3JhcGgucHJvdG90eXBlLnNlbGVjdENoaWxkQ2VsbD1mdW5jdGlvbigpe3RoaXMuc2VsZWN0Q2VsbCghMSwhMSwhMCl9OwpteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnNlbGVjdGlvbk1vZGVsLGU9MDxkLmNlbGxzLmxlbmd0aD9kLmNlbGxzWzBdOm51bGw7MTxkLmNlbGxzLmxlbmd0aCYmZC5jbGVhcigpO3ZhciBkPW51bGwhPWU/dGhpcy5tb2RlbC5nZXRQYXJlbnQoZSk6dGhpcy5nZXREZWZhdWx0UGFyZW50KCksZj10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoZCk7bnVsbD09ZSYmMDxmPyhhPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChkLDApLHRoaXMuc2V0U2VsZWN0aW9uQ2VsbChhKSk6bnVsbCE9ZSYmIWJ8fG51bGw9PXRoaXMudmlldy5nZXRTdGF0ZShkKXx8bnVsbD09dGhpcy5tb2RlbC5nZXRHZW9tZXRyeShkKT9udWxsIT1lJiZjPzA8dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGUpJiYoYT10aGlzLm1vZGVsLmdldENoaWxkQXQoZSwwKSx0aGlzLnNldFNlbGVjdGlvbkNlbGwoYSkpOjA8ZiYmKGI9ZC5nZXRJbmRleChlKSxhPyhiKyssYT10aGlzLm1vZGVsLmdldENoaWxkQXQoZCwKYiVmKSk6KGItLSxhPXRoaXMubW9kZWwuZ2V0Q2hpbGRBdChkLDA+Yj9mLTE6YikpLHRoaXMuc2V0U2VsZWN0aW9uQ2VsbChhKSk6dGhpcy5nZXRDdXJyZW50Um9vdCgpIT1kJiZ0aGlzLnNldFNlbGVjdGlvbkNlbGwoZCl9O214R3JhcGgucHJvdG90eXBlLnNlbGVjdEFsbD1mdW5jdGlvbihhLGIpe2E9YXx8dGhpcy5nZXREZWZhdWx0UGFyZW50KCk7dmFyIGM9Yj90aGlzLm1vZGVsLmZpbHRlckRlc2NlbmRhbnRzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiBiIT1hJiZudWxsIT10aGlzLnZpZXcuZ2V0U3RhdGUoYil9KSxhKTp0aGlzLm1vZGVsLmdldENoaWxkcmVuKGEpO251bGwhPWMmJnRoaXMuc2V0U2VsZWN0aW9uQ2VsbHMoYyl9O214R3JhcGgucHJvdG90eXBlLnNlbGVjdFZlcnRpY2VzPWZ1bmN0aW9uKGEsYil7dGhpcy5zZWxlY3RDZWxscyghMCwhMSxhLGIpfTsKbXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0RWRnZXM9ZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RDZWxscyghMSwhMCxhKX07bXhHcmFwaC5wcm90b3R5cGUuc2VsZWN0Q2VsbHM9ZnVuY3Rpb24oYSxiLGMsZCl7Yz1jfHx0aGlzLmdldERlZmF1bHRQYXJlbnQoKTt2YXIgZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXtyZXR1cm4gbnVsbCE9dGhpcy52aWV3LmdldFN0YXRlKGMpJiYoKGR8fDA9PXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChjKSkmJnRoaXMubW9kZWwuaXNWZXJ0ZXgoYykmJmEmJiF0aGlzLm1vZGVsLmlzRWRnZSh0aGlzLm1vZGVsLmdldFBhcmVudChjKSl8fHRoaXMubW9kZWwuaXNFZGdlKGMpJiZiKX0pO2M9dGhpcy5tb2RlbC5maWx0ZXJEZXNjZW5kYW50cyhlLGMpO251bGwhPWMmJnRoaXMuc2V0U2VsZWN0aW9uQ2VsbHMoYyl9OwpteEdyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsRm9yRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmlzQ2VsbFNlbGVjdGVkKGEpO3RoaXMuaXNUb2dnbGVFdmVudChiKT9jP3RoaXMucmVtb3ZlU2VsZWN0aW9uQ2VsbChhKTp0aGlzLmFkZFNlbGVjdGlvbkNlbGwoYSk6YyYmMT09dGhpcy5nZXRTZWxlY3Rpb25Db3VudCgpfHx0aGlzLnNldFNlbGVjdGlvbkNlbGwoYSl9O214R3JhcGgucHJvdG90eXBlLnNlbGVjdENlbGxzRm9yRXZlbnQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmlzVG9nZ2xlRXZlbnQoYik/dGhpcy5hZGRTZWxlY3Rpb25DZWxscyhhKTp0aGlzLnNldFNlbGVjdGlvbkNlbGxzKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlSGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKG51bGwhPWEpaWYodGhpcy5tb2RlbC5pc0VkZ2UoYS5jZWxsKSl2YXIgYj1hLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKSxjPWEuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITEpLGQ9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYS5jZWxsKSxiPXRoaXMudmlldy5nZXRFZGdlU3R5bGUoYSxudWxsIT1kP2QucG9pbnRzOm51bGwsYixjKSxiPXRoaXMuY3JlYXRlRWRnZUhhbmRsZXIoYSxiKTtlbHNlIGI9dGhpcy5jcmVhdGVWZXJ0ZXhIYW5kbGVyKGEpO3JldHVybiBifTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVWZXJ0ZXhIYW5kbGVyPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhWZXJ0ZXhIYW5kbGVyKGEpfTsKbXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlRWRnZUhhbmRsZXI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj09bXhFZGdlU3R5bGUuTG9vcHx8Yj09bXhFZGdlU3R5bGUuRWxib3dDb25uZWN0b3J8fGI9PW14RWRnZVN0eWxlLlNpZGVUb1NpZGV8fGI9PW14RWRnZVN0eWxlLlRvcFRvQm90dG9tP3RoaXMuY3JlYXRlRWxib3dFZGdlSGFuZGxlcihhKTpiPT1teEVkZ2VTdHlsZS5TZWdtZW50Q29ubmVjdG9yfHxiPT1teEVkZ2VTdHlsZS5PcnRoQ29ubmVjdG9yP3RoaXMuY3JlYXRlRWRnZVNlZ21lbnRIYW5kbGVyKGEpOm5ldyBteEVkZ2VIYW5kbGVyKGEpfTtteEdyYXBoLnByb3RvdHlwZS5jcmVhdGVFZGdlU2VnbWVudEhhbmRsZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteEVkZ2VTZWdtZW50SGFuZGxlcihhKX07bXhHcmFwaC5wcm90b3R5cGUuY3JlYXRlRWxib3dFZGdlSGFuZGxlcj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IG14RWxib3dFZGdlSGFuZGxlcihhKX07Cm14R3JhcGgucHJvdG90eXBlLmFkZE1vdXNlTGlzdGVuZXI9ZnVuY3Rpb24oYSl7bnVsbD09dGhpcy5tb3VzZUxpc3RlbmVycyYmKHRoaXMubW91c2VMaXN0ZW5lcnM9W10pO3RoaXMubW91c2VMaXN0ZW5lcnMucHVzaChhKX07bXhHcmFwaC5wcm90b3R5cGUucmVtb3ZlTW91c2VMaXN0ZW5lcj1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLm1vdXNlTGlzdGVuZXJzKWZvcih2YXIgYj0wO2I8dGhpcy5tb3VzZUxpc3RlbmVycy5sZW5ndGg7YisrKWlmKHRoaXMubW91c2VMaXN0ZW5lcnNbYl09PWEpe3RoaXMubW91c2VMaXN0ZW5lcnMuc3BsaWNlKGIsMSk7YnJlYWt9fTsKbXhHcmFwaC5wcm90b3R5cGUudXBkYXRlTW91c2VFdmVudD1mdW5jdGlvbihhLGIpe2lmKG51bGw9PWEuZ3JhcGhYfHxudWxsPT1hLmdyYXBoWSl7dmFyIGM9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5jb250YWluZXIsYS5nZXRYKCksYS5nZXRZKCkpO2EuZ3JhcGhYPWMueC10aGlzLnBhbkR4O2EuZ3JhcGhZPWMueS10aGlzLnBhbkR5O251bGw9PWEuZ2V0Q2VsbCgpJiZ0aGlzLmlzTW91c2VEb3duJiZiPT1teEV2ZW50Lk1PVVNFX01PVkUmJihhLnN0YXRlPXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLmdldENlbGxBdChjLngsYy55LG51bGwsbnVsbCxudWxsLGZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hLnNoYXBlfHxhLnNoYXBlLnBhaW50QmFja2dyb3VuZCE9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kfHwiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT0lOVEVSX0VWRU5UUywiMSIpfHxudWxsIT1hLnNoYXBlLmZpbGwmJgphLnNoYXBlLmZpbGwhPW14Q29uc3RhbnRzLk5PTkV9KSkpfXJldHVybiBhfTtteEdyYXBoLnByb3RvdHlwZS5nZXRTdGF0ZUZvclRvdWNoRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9bXhFdmVudC5nZXRDbGllbnRYKGEpO2E9bXhFdmVudC5nZXRDbGllbnRZKGEpO2I9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5jb250YWluZXIsYixhKTtyZXR1cm4gdGhpcy52aWV3LmdldFN0YXRlKHRoaXMuZ2V0Q2VsbEF0KGIueCxiLnkpKX07Cm14R3JhcGgucHJvdG90eXBlLmlzRXZlbnRJZ25vcmVkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1teEV2ZW50LmlzTW91c2VFdmVudChiLmdldEV2ZW50KCkpLGU9ITE7Yi5nZXRFdmVudCgpPT10aGlzLmxhc3RFdmVudD9lPSEwOnRoaXMubGFzdEV2ZW50PWIuZ2V0RXZlbnQoKTtudWxsIT10aGlzLmV2ZW50U291cmNlJiZhIT1teEV2ZW50Lk1PVVNFX01PVkU/KG14RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyh0aGlzLmV2ZW50U291cmNlLG51bGwsdGhpcy5tb3VzZU1vdmVSZWRpcmVjdCx0aGlzLm1vdXNlVXBSZWRpcmVjdCksdGhpcy5ldmVudFNvdXJjZT10aGlzLm1vdXNlVXBSZWRpcmVjdD10aGlzLm1vdXNlTW92ZVJlZGlyZWN0PW51bGwpOm14Q2xpZW50LklTX0dDfHxudWxsPT10aGlzLmV2ZW50U291cmNlfHxiLmdldFNvdXJjZSgpPT10aGlzLmV2ZW50U291cmNlPyFteENsaWVudC5JU19UT1VDSHx8YSE9bXhFdmVudC5NT1VTRV9ET1dOfHxkfHxteEV2ZW50LmlzUGVuRXZlbnQoYi5nZXRFdmVudCgpKXx8Cih0aGlzLmV2ZW50U291cmNlPWIuZ2V0U291cmNlKCksdGhpcy5tb3VzZU1vdmVSZWRpcmVjdD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfTU9WRSxuZXcgbXhNb3VzZUV2ZW50KGEsdGhpcy5nZXRTdGF0ZUZvclRvdWNoRXZlbnQoYSkpKX0pLHRoaXMubW91c2VVcFJlZGlyZWN0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGEsdGhpcy5nZXRTdGF0ZUZvclRvdWNoRXZlbnQoYSkpKX0pLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLmV2ZW50U291cmNlLG51bGwsdGhpcy5tb3VzZU1vdmVSZWRpcmVjdCx0aGlzLm1vdXNlVXBSZWRpcmVjdCkpOmU9ITA7dGhpcy5pc1N5bnRoZXRpY0V2ZW50SWdub3JlZChhLGIsYykmJihlPSEwKTtpZighbXhFdmVudC5pc1BvcHVwVHJpZ2dlcih0aGlzLmxhc3RFdmVudCkmJgphIT1teEV2ZW50Lk1PVVNFX01PVkUmJjI9PXRoaXMubGFzdEV2ZW50LmRldGFpbClyZXR1cm4hMDthPT1teEV2ZW50Lk1PVVNFX1VQJiZ0aGlzLmlzTW91c2VEb3duP3RoaXMuaXNNb3VzZURvd249ITE6YSE9bXhFdmVudC5NT1VTRV9ET1dOfHx0aGlzLmlzTW91c2VEb3duPyFlJiYoKCFteENsaWVudC5JU19GRnx8YSE9bXhFdmVudC5NT1VTRV9NT1ZFKSYmdGhpcy5pc01vdXNlRG93biYmdGhpcy5pc01vdXNlVHJpZ2dlciE9ZHx8YT09bXhFdmVudC5NT1VTRV9ET1dOJiZ0aGlzLmlzTW91c2VEb3dufHxhPT1teEV2ZW50Lk1PVVNFX1VQJiYhdGhpcy5pc01vdXNlRG93bikmJihlPSEwKToodGhpcy5pc01vdXNlRG93bj0hMCx0aGlzLmlzTW91c2VUcmlnZ2VyPWQpO2V8fGEhPW14RXZlbnQuTU9VU0VfRE9XTnx8KHRoaXMubGFzdE1vdXNlWD1iLmdldFgoKSx0aGlzLmxhc3RNb3VzZVk9Yi5nZXRZKCkpO3JldHVybiBlfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNTeW50aGV0aWNFdmVudElnbm9yZWQ9ZnVuY3Rpb24oYSxiLGMpe2M9ITE7Yj1teEV2ZW50LmlzTW91c2VFdmVudChiLmdldEV2ZW50KCkpO3RoaXMuaWdub3JlTW91c2VFdmVudHMmJmImJmEhPW14RXZlbnQuTU9VU0VfTU9WRT8odGhpcy5pZ25vcmVNb3VzZUV2ZW50cz1hIT1teEV2ZW50Lk1PVVNFX1VQLGM9ITApOm14Q2xpZW50LklTX0ZGJiYhYiYmYT09bXhFdmVudC5NT1VTRV9VUCYmKHRoaXMuaWdub3JlTW91c2VFdmVudHM9ITApO3JldHVybiBjfTsKbXhHcmFwaC5wcm90b3R5cGUuaXNFdmVudFNvdXJjZUlnbm9yZWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLmdldFNvdXJjZSgpLGQ9bnVsbCE9Yy5ub2RlTmFtZT9jLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk6IiIsZT0hbXhFdmVudC5pc01vdXNlRXZlbnQoYi5nZXRFdmVudCgpKXx8bXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihiLmdldEV2ZW50KCkpO3JldHVybiBhPT1teEV2ZW50Lk1PVVNFX0RPV04mJmUmJigic2VsZWN0Ij09ZHx8Im9wdGlvbiI9PWR8fCJpbnB1dCI9PWQmJiJjaGVja2JveCIhPWMudHlwZSYmInJhZGlvIiE9Yy50eXBlJiYiYnV0dG9uIiE9Yy50eXBlJiYic3VibWl0IiE9Yy50eXBlJiYiZmlsZSIhPWMudHlwZSl9O214R3JhcGgucHJvdG90eXBlLmdldEV2ZW50U3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9OwpteEdyYXBoLnByb3RvdHlwZS5maXJlTW91c2VFdmVudD1mdW5jdGlvbihhLGIsYyl7aWYodGhpcy5pc0V2ZW50U291cmNlSWdub3JlZChhLGIpKW51bGwhPXRoaXMudG9vbHRpcEhhbmRsZXImJnRoaXMudG9vbHRpcEhhbmRsZXIuaGlkZSgpO2Vsc2V7bnVsbD09YyYmKGM9dGhpcyk7Yj10aGlzLnVwZGF0ZU1vdXNlRXZlbnQoYixhKTtpZighdGhpcy5uYXRpdmVEYmxDbGlja0VuYWJsZWQmJiFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGIuZ2V0RXZlbnQoKSl8fHRoaXMuZG91YmxlVGFwRW5hYmxlZCYmbXhDbGllbnQuSVNfVE9VQ0gmJihteEV2ZW50LmlzVG91Y2hFdmVudChiLmdldEV2ZW50KCkpfHxteEV2ZW50LmlzUGVuRXZlbnQoYi5nZXRFdmVudCgpKSkpe3ZhciBkPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2lmKCFteENsaWVudC5JU19RVUlSS1MmJmE9PW14RXZlbnQuTU9VU0VfRE9XTnx8bXhDbGllbnQuSVNfUVVJUktTJiZhPT1teEV2ZW50Lk1PVVNFX1VQJiYhdGhpcy5maXJlRG91YmxlQ2xpY2spaWYobnVsbCE9CnRoaXMubGFzdFRvdWNoRXZlbnQmJnRoaXMubGFzdFRvdWNoRXZlbnQhPWIuZ2V0RXZlbnQoKSYmZC10aGlzLmxhc3RUb3VjaFRpbWU8dGhpcy5kb3VibGVUYXBUaW1lb3V0JiZNYXRoLmFicyh0aGlzLmxhc3RUb3VjaFgtYi5nZXRYKCkpPHRoaXMuZG91YmxlVGFwVG9sZXJhbmNlJiZNYXRoLmFicyh0aGlzLmxhc3RUb3VjaFktYi5nZXRZKCkpPHRoaXMuZG91YmxlVGFwVG9sZXJhbmNlJiYyPnRoaXMuZG91YmxlQ2xpY2tDb3VudGVyKXtpZih0aGlzLmRvdWJsZUNsaWNrQ291bnRlcisrLGQ9ITEsYT09bXhFdmVudC5NT1VTRV9VUD9iLmdldENlbGwoKT09dGhpcy5sYXN0VG91Y2hDZWxsJiZudWxsIT10aGlzLmxhc3RUb3VjaENlbGwmJih0aGlzLmxhc3RUb3VjaFRpbWU9MCxkPXRoaXMubGFzdFRvdWNoQ2VsbCx0aGlzLmxhc3RUb3VjaENlbGw9bnVsbCxteENsaWVudC5JU19RVUlSS1MmJmIuZ2V0U291cmNlKCkuZmlyZUV2ZW50KCJvbmRibGNsaWNrIiksdGhpcy5kYmxDbGljayhiLmdldEV2ZW50KCksCmQpLGQ9ITApOih0aGlzLmZpcmVEb3VibGVDbGljaz0hMCx0aGlzLmxhc3RUb3VjaFRpbWU9MCksIW14Q2xpZW50LklTX1FVSVJLU3x8ZCl7bXhFdmVudC5jb25zdW1lKGIuZ2V0RXZlbnQoKSk7cmV0dXJufX1lbHNle2lmKG51bGw9PXRoaXMubGFzdFRvdWNoRXZlbnR8fHRoaXMubGFzdFRvdWNoRXZlbnQhPWIuZ2V0RXZlbnQoKSl0aGlzLmxhc3RUb3VjaENlbGw9Yi5nZXRDZWxsKCksdGhpcy5sYXN0VG91Y2hYPWIuZ2V0WCgpLHRoaXMubGFzdFRvdWNoWT1iLmdldFkoKSx0aGlzLmxhc3RUb3VjaFRpbWU9ZCx0aGlzLmxhc3RUb3VjaEV2ZW50PWIuZ2V0RXZlbnQoKSx0aGlzLmRvdWJsZUNsaWNrQ291bnRlcj0wfWVsc2UgaWYoKHRoaXMuaXNNb3VzZURvd258fGE9PW14RXZlbnQuTU9VU0VfVVApJiZ0aGlzLmZpcmVEb3VibGVDbGljayl7dGhpcy5maXJlRG91YmxlQ2xpY2s9ITE7ZD10aGlzLmxhc3RUb3VjaENlbGw7dGhpcy5sYXN0VG91Y2hDZWxsPW51bGw7dGhpcy5pc01vdXNlRG93bj0KITE7KG51bGwhPWR8fChteEV2ZW50LmlzVG91Y2hFdmVudChiLmdldEV2ZW50KCkpfHxteEV2ZW50LmlzUGVuRXZlbnQoYi5nZXRFdmVudCgpKSkmJihteENsaWVudC5JU19HQ3x8bXhDbGllbnQuSVNfU0YpKSYmTWF0aC5hYnModGhpcy5sYXN0VG91Y2hYLWIuZ2V0WCgpKTx0aGlzLmRvdWJsZVRhcFRvbGVyYW5jZSYmTWF0aC5hYnModGhpcy5sYXN0VG91Y2hZLWIuZ2V0WSgpKTx0aGlzLmRvdWJsZVRhcFRvbGVyYW5jZT90aGlzLmRibENsaWNrKGIuZ2V0RXZlbnQoKSxkKTpteEV2ZW50LmNvbnN1bWUoYi5nZXRFdmVudCgpKTtyZXR1cm59fWlmKCF0aGlzLmlzRXZlbnRJZ25vcmVkKGEsYixjKSl7Yi5zdGF0ZT10aGlzLmdldEV2ZW50U3RhdGUoYi5nZXRTdGF0ZSgpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkZJUkVfTU9VU0VfRVZFTlQsImV2ZW50TmFtZSIsYSwiZXZlbnQiLGIpKTtpZihteENsaWVudC5JU19PUHx8bXhDbGllbnQuSVNfU0Z8fG14Q2xpZW50LklTX0dDfHwKbXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfSUUmJm14Q2xpZW50LklTX1NWR3x8Yi5nZXRFdmVudCgpLnRhcmdldCE9dGhpcy5jb250YWluZXIpe2lmKGE9PW14RXZlbnQuTU9VU0VfTU9WRSYmdGhpcy5pc01vdXNlRG93biYmdGhpcy5hdXRvU2Nyb2xsJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KSl0aGlzLnNjcm9sbFBvaW50VG9WaXNpYmxlKGIuZ2V0R3JhcGhYKCksYi5nZXRHcmFwaFkoKSx0aGlzLmF1dG9FeHRlbmQpO2Vsc2UgaWYoYT09bXhFdmVudC5NT1VTRV9VUCYmdGhpcy5pZ25vcmVTY3JvbGxiYXJzJiZ0aGlzLnRyYW5zbGF0ZVRvU2Nyb2xsUG9zaXRpb24mJigwIT10aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0fHwwIT10aGlzLmNvbnRhaW5lci5zY3JvbGxUb3ApKXt2YXIgZD10aGlzLnZpZXcuc2NhbGUsZT10aGlzLnZpZXcudHJhbnNsYXRlO3RoaXMudmlldy5zZXRUcmFuc2xhdGUoZS54LXRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQvCmQsZS55LXRoaXMuY29udGFpbmVyLnNjcm9sbFRvcC9kKTt0aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0PTA7dGhpcy5jb250YWluZXIuc2Nyb2xsVG9wPTB9aWYobnVsbCE9dGhpcy5tb3VzZUxpc3RlbmVycylmb3IoZD1bYyxiXSxiLmdldEV2ZW50KCkucHJldmVudERlZmF1bHR8fChiLmdldEV2ZW50KCkucmV0dXJuVmFsdWU9ITApLGU9MDtlPHRoaXMubW91c2VMaXN0ZW5lcnMubGVuZ3RoO2UrKyl7dmFyIGY9dGhpcy5tb3VzZUxpc3RlbmVyc1tlXTthPT1teEV2ZW50Lk1PVVNFX0RPV04/Zi5tb3VzZURvd24uYXBwbHkoZixkKTphPT1teEV2ZW50Lk1PVVNFX01PVkU/Zi5tb3VzZU1vdmUuYXBwbHkoZixkKTphPT1teEV2ZW50Lk1PVVNFX1VQJiZmLm1vdXNlVXAuYXBwbHkoZixkKX1hPT1teEV2ZW50Lk1PVVNFX1VQJiZ0aGlzLmNsaWNrKGIpfShteEV2ZW50LmlzVG91Y2hFdmVudChiLmdldEV2ZW50KCkpfHxteEV2ZW50LmlzUGVuRXZlbnQoYi5nZXRFdmVudCgpKSkmJmE9PW14RXZlbnQuTU9VU0VfRE9XTiYmCnRoaXMudGFwQW5kSG9sZEVuYWJsZWQmJiF0aGlzLnRhcEFuZEhvbGRJblByb2dyZXNzPyh0aGlzLnRhcEFuZEhvbGRJblByb2dyZXNzPSEwLHRoaXMuaW5pdGlhbFRvdWNoWD1iLmdldEdyYXBoWCgpLHRoaXMuaW5pdGlhbFRvdWNoWT1iLmdldEdyYXBoWSgpLHRoaXMudGFwQW5kSG9sZFRocmVhZCYmd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRhcEFuZEhvbGRUaHJlYWQpLHRoaXMudGFwQW5kSG9sZFRocmVhZD13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudGFwQW5kSG9sZFZhbGlkJiZ0aGlzLnRhcEFuZEhvbGQoYik7dGhpcy50YXBBbmRIb2xkVmFsaWQ9dGhpcy50YXBBbmRIb2xkSW5Qcm9ncmVzcz0hMX0pLHRoaXMudGFwQW5kSG9sZERlbGF5KSx0aGlzLnRhcEFuZEhvbGRWYWxpZD0hMCk6YT09bXhFdmVudC5NT1VTRV9VUD90aGlzLnRhcEFuZEhvbGRWYWxpZD10aGlzLnRhcEFuZEhvbGRJblByb2dyZXNzPSExOnRoaXMudGFwQW5kSG9sZFZhbGlkJiYKKHRoaXMudGFwQW5kSG9sZFZhbGlkPU1hdGguYWJzKHRoaXMuaW5pdGlhbFRvdWNoWC1iLmdldEdyYXBoWCgpKTx0aGlzLnRvbGVyYW5jZSYmTWF0aC5hYnModGhpcy5pbml0aWFsVG91Y2hZLWIuZ2V0R3JhcGhZKCkpPHRoaXMudG9sZXJhbmNlKTthPT1teEV2ZW50Lk1PVVNFX0RPV04mJnRoaXMuaXNFZGl0aW5nKCkmJiF0aGlzLmNlbGxFZGl0b3IuaXNFdmVudFNvdXJjZShiLmdldEV2ZW50KCkpJiZ0aGlzLnN0b3BFZGl0aW5nKCF0aGlzLmlzSW52b2tlc1N0b3BDZWxsRWRpdGluZygpKTt0aGlzLmNvbnN1bWVNb3VzZUV2ZW50KGEsYixjKX19fTtteEdyYXBoLnByb3RvdHlwZS5jb25zdW1lTW91c2VFdmVudD1mdW5jdGlvbihhLGIsYyl7YT09bXhFdmVudC5NT1VTRV9ET1dOJiZteEV2ZW50LmlzVG91Y2hFdmVudChiLmdldEV2ZW50KCkpJiZiLmNvbnN1bWUoITEpfTsKbXhHcmFwaC5wcm90b3R5cGUuZmlyZUdlc3R1cmVFdmVudD1mdW5jdGlvbihhLGIpe3RoaXMubGFzdFRvdWNoVGltZT0wO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuR0VTVFVSRSwiZXZlbnQiLGEsImNlbGwiLGIpKX07Cm14R3JhcGgucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3llZHx8KHRoaXMuZGVzdHJveWVkPSEwLG51bGwhPXRoaXMudG9vbHRpcEhhbmRsZXImJnRoaXMudG9vbHRpcEhhbmRsZXIuZGVzdHJveSgpLG51bGwhPXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyJiZ0aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5kZXN0cm95KCksbnVsbCE9dGhpcy5wYW5uaW5nSGFuZGxlciYmdGhpcy5wYW5uaW5nSGFuZGxlci5kZXN0cm95KCksbnVsbCE9dGhpcy5wb3B1cE1lbnVIYW5kbGVyJiZ0aGlzLnBvcHVwTWVudUhhbmRsZXIuZGVzdHJveSgpLG51bGwhPXRoaXMuY29ubmVjdGlvbkhhbmRsZXImJnRoaXMuY29ubmVjdGlvbkhhbmRsZXIuZGVzdHJveSgpLG51bGwhPXRoaXMuZ3JhcGhIYW5kbGVyJiZ0aGlzLmdyYXBoSGFuZGxlci5kZXN0cm95KCksbnVsbCE9dGhpcy5jZWxsRWRpdG9yJiZ0aGlzLmNlbGxFZGl0b3IuZGVzdHJveSgpLG51bGwhPXRoaXMudmlldyYmdGhpcy52aWV3LmRlc3Ryb3koKSwKbnVsbCE9dGhpcy5tb2RlbCYmbnVsbCE9dGhpcy5ncmFwaE1vZGVsQ2hhbmdlTGlzdGVuZXImJih0aGlzLm1vZGVsLnJlbW92ZUxpc3RlbmVyKHRoaXMuZ3JhcGhNb2RlbENoYW5nZUxpc3RlbmVyKSx0aGlzLmdyYXBoTW9kZWxDaGFuZ2VMaXN0ZW5lcj1udWxsKSx0aGlzLmNvbnRhaW5lcj1udWxsKX07ZnVuY3Rpb24gbXhDZWxsT3ZlcmxheShhLGIsYyxkLGUsZil7dGhpcy5pbWFnZT1hO3RoaXMudG9vbHRpcD1iO3RoaXMuYWxpZ249bnVsbCE9Yz9jOnRoaXMuYWxpZ247dGhpcy52ZXJ0aWNhbEFsaWduPW51bGwhPWQ/ZDp0aGlzLnZlcnRpY2FsQWxpZ247dGhpcy5vZmZzZXQ9bnVsbCE9ZT9lOm5ldyBteFBvaW50O3RoaXMuY3Vyc29yPW51bGwhPWY/ZjoiaGVscCJ9bXhDZWxsT3ZlcmxheS5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhDZWxsT3ZlcmxheTtteENlbGxPdmVybGF5LnByb3RvdHlwZS5pbWFnZT1udWxsOwpteENlbGxPdmVybGF5LnByb3RvdHlwZS50b29sdGlwPW51bGw7bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUuYWxpZ249bXhDb25zdGFudHMuQUxJR05fUklHSFQ7bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUudmVydGljYWxBbGlnbj1teENvbnN0YW50cy5BTElHTl9CT1RUT007bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUub2Zmc2V0PW51bGw7bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUuY3Vyc29yPW51bGw7bXhDZWxsT3ZlcmxheS5wcm90b3R5cGUuZGVmYXVsdE92ZXJsYXA9LjU7Cm14Q2VsbE92ZXJsYXkucHJvdG90eXBlLmdldEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXcuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoYS5jZWxsKSxjPWEudmlldy5zY2FsZSxkPXRoaXMuaW1hZ2Uud2lkdGgsZT10aGlzLmltYWdlLmhlaWdodDtpZihiKWlmKGI9YS5hYnNvbHV0ZVBvaW50cywxPT1iLmxlbmd0aCUyKWI9YltNYXRoLmZsb29yKGIubGVuZ3RoLzIpXTtlbHNle3ZhciBmPWIubGVuZ3RoLzI7YT1iW2YtMV07Yj1iW2ZdO2I9bmV3IG14UG9pbnQoYS54KyhiLngtYS54KS8yLGEueSsoYi55LWEueSkvMil9ZWxzZSBiPW5ldyBteFBvaW50LGIueD10aGlzLmFsaWduPT1teENvbnN0YW50cy5BTElHTl9MRUZUP2EueDp0aGlzLmFsaWduPT1teENvbnN0YW50cy5BTElHTl9DRU5URVI/YS54K2Eud2lkdGgvMjphLngrYS53aWR0aCxiLnk9dGhpcy52ZXJ0aWNhbEFsaWduPT1teENvbnN0YW50cy5BTElHTl9UT1A/YS55OnRoaXMudmVydGljYWxBbGlnbj09bXhDb25zdGFudHMuQUxJR05fTUlERExFPwphLnkrYS5oZWlnaHQvMjphLnkrYS5oZWlnaHQ7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKGIueC0oZCp0aGlzLmRlZmF1bHRPdmVybGFwLXRoaXMub2Zmc2V0LngpKmMpLE1hdGgucm91bmQoYi55LShlKnRoaXMuZGVmYXVsdE92ZXJsYXAtdGhpcy5vZmZzZXQueSkqYyksZCpjLGUqYyl9O214Q2VsbE92ZXJsYXkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9vbHRpcH07ZnVuY3Rpb24gbXhPdXRsaW5lKGEsYil7dGhpcy5zb3VyY2U9YTtudWxsIT1iJiZ0aGlzLmluaXQoYil9bXhPdXRsaW5lLnByb3RvdHlwZS5zb3VyY2U9bnVsbDtteE91dGxpbmUucHJvdG90eXBlLm91dGxpbmU9bnVsbDtteE91dGxpbmUucHJvdG90eXBlLmdyYXBoUmVuZGVySGludD1teENvbnN0YW50cy5SRU5ERVJJTkdfSElOVF9GQVNURVI7bXhPdXRsaW5lLnByb3RvdHlwZS5lbmFibGVkPSEwO214T3V0bGluZS5wcm90b3R5cGUuc2hvd1ZpZXdwb3J0PSEwOwpteE91dGxpbmUucHJvdG90eXBlLmJvcmRlcj0xMDtteE91dGxpbmUucHJvdG90eXBlLnNpemVyU2l6ZT04O214T3V0bGluZS5wcm90b3R5cGUubGFiZWxzVmlzaWJsZT0hMTtteE91dGxpbmUucHJvdG90eXBlLnVwZGF0ZU9uUGFuPSExO214T3V0bGluZS5wcm90b3R5cGUuc2l6ZXJJbWFnZT1udWxsO214T3V0bGluZS5wcm90b3R5cGUubWluU2NhbGU9MUUtNDtteE91dGxpbmUucHJvdG90eXBlLnN1c3BlbmRlZD0hMTtteE91dGxpbmUucHJvdG90eXBlLmZvcmNlVm1sSGFuZGxlcz04PT1kb2N1bWVudC5kb2N1bWVudE1vZGU7bXhPdXRsaW5lLnByb3RvdHlwZS5jcmVhdGVHcmFwaD1mdW5jdGlvbihhKXthPW5ldyBteEdyYXBoKGEsdGhpcy5zb3VyY2UuZ2V0TW9kZWwoKSx0aGlzLmdyYXBoUmVuZGVySGludCx0aGlzLnNvdXJjZS5nZXRTdHlsZXNoZWV0KCkpO2EuZm9sZGluZ0VuYWJsZWQ9ITE7YS5hdXRvU2Nyb2xsPSExO3JldHVybiBhfTsKbXhPdXRsaW5lLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe3RoaXMub3V0bGluZT10aGlzLmNyZWF0ZUdyYXBoKGEpO3ZhciBiPXRoaXMub3V0bGluZS5ncmFwaE1vZGVsQ2hhbmdlZDt0aGlzLm91dGxpbmUuZ3JhcGhNb2RlbENoYW5nZWQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zdXNwZW5kZWR8fG51bGw9PXRoaXMub3V0bGluZXx8Yi5hcHBseSh0aGlzLm91dGxpbmUsYXJndW1lbnRzKX0pO214Q2xpZW50LklTX1NWRyYmKGE9dGhpcy5vdXRsaW5lLmdldFZpZXcoKS5nZXRDYW52YXMoKS5wYXJlbnROb2RlLGEuc2V0QXR0cmlidXRlKCJzaGFwZS1yZW5kZXJpbmciLCJvcHRpbWl6ZVNwZWVkIiksYS5zZXRBdHRyaWJ1dGUoImltYWdlLXJlbmRlcmluZyIsIm9wdGltaXplU3BlZWQiKSk7dGhpcy5vdXRsaW5lLmxhYmVsc1Zpc2libGU9dGhpcy5sYWJlbHNWaXNpYmxlO3RoaXMub3V0bGluZS5zZXRFbmFibGVkKCExKTt0aGlzLnVwZGF0ZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEsYil7dGhpcy5zdXNwZW5kZWR8fHRoaXMuYWN0aXZlfHx0aGlzLnVwZGF0ZSgpfSk7dGhpcy5zb3VyY2UuZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLnVwZGF0ZUhhbmRsZXIpO3RoaXMub3V0bGluZS5hZGRNb3VzZUxpc3RlbmVyKHRoaXMpO2E9dGhpcy5zb3VyY2UuZ2V0VmlldygpO2EuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRSx0aGlzLnVwZGF0ZUhhbmRsZXIpO2EuYWRkTGlzdGVuZXIobXhFdmVudC5UUkFOU0xBVEUsdGhpcy51cGRhdGVIYW5kbGVyKTthLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEVfQU5EX1RSQU5TTEFURSx0aGlzLnVwZGF0ZUhhbmRsZXIpO2EuYWRkTGlzdGVuZXIobXhFdmVudC5ET1dOLHRoaXMudXBkYXRlSGFuZGxlcik7YS5hZGRMaXN0ZW5lcihteEV2ZW50LlVQLHRoaXMudXBkYXRlSGFuZGxlcik7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLnNvdXJjZS5jb250YWluZXIsInNjcm9sbCIsdGhpcy51cGRhdGVIYW5kbGVyKTsKdGhpcy5wYW5IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlT25QYW4mJnRoaXMudXBkYXRlSGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTt0aGlzLnNvdXJjZS5hZGRMaXN0ZW5lcihteEV2ZW50LlBBTix0aGlzLnBhbkhhbmRsZXIpO3RoaXMucmVmcmVzaEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5vdXRsaW5lLnNldFN0eWxlc2hlZXQodGhpcy5zb3VyY2UuZ2V0U3R5bGVzaGVldCgpKTt0aGlzLm91dGxpbmUucmVmcmVzaCgpfSk7dGhpcy5zb3VyY2UuYWRkTGlzdGVuZXIobXhFdmVudC5SRUZSRVNILHRoaXMucmVmcmVzaEhhbmRsZXIpO3RoaXMuYm91bmRzPW5ldyBteFJlY3RhbmdsZSgwLDAsMCwwKTt0aGlzLnNlbGVjdGlvbkJvcmRlcj1uZXcgbXhSZWN0YW5nbGVTaGFwZSh0aGlzLmJvdW5kcyxudWxsLG14Q29uc3RhbnRzLk9VVExJTkVfQ09MT1IsbXhDb25zdGFudHMuT1VUTElORV9TVFJPS0VXSURUSCk7CnRoaXMuc2VsZWN0aW9uQm9yZGVyLmRpYWxlY3Q9dGhpcy5vdXRsaW5lLmRpYWxlY3Q7dGhpcy5mb3JjZVZtbEhhbmRsZXMmJih0aGlzLnNlbGVjdGlvbkJvcmRlci5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuITF9KTt0aGlzLnNlbGVjdGlvbkJvcmRlci5pbml0KHRoaXMub3V0bGluZS5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSk7YT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldFNvdXJjZShhKSxjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMub3V0bGluZS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChhKSl9KSxmPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyhiLG51bGwsYyxmKTt0aGlzLm91dGxpbmUuZmlyZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9VUCxuZXcgbXhNb3VzZUV2ZW50KGEpKX0pOwpteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoYixudWxsLGMsZik7dGhpcy5vdXRsaW5lLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGEpKX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLGEpO3RoaXMuc2l6ZXI9dGhpcy5jcmVhdGVTaXplcigpO3RoaXMuZm9yY2VWbWxIYW5kbGVzJiYodGhpcy5zaXplci5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuITF9KTt0aGlzLnNpemVyLmluaXQodGhpcy5vdXRsaW5lLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKTt0aGlzLmVuYWJsZWQmJih0aGlzLnNpemVyLm5vZGUuc3R5bGUuY3Vyc29yPSJud3NlLXJlc2l6ZSIpO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLnNpemVyLm5vZGUsYSk7dGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZS5zdHlsZS5kaXNwbGF5PXRoaXMuc2hvd1ZpZXdwb3J0PyIiOiJub25lIjt0aGlzLnNpemVyLm5vZGUuc3R5bGUuZGlzcGxheT0KdGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZS5zdHlsZS5kaXNwbGF5O3RoaXMuc2VsZWN0aW9uQm9yZGVyLm5vZGUuc3R5bGUuY3Vyc29yPSJtb3ZlIjt0aGlzLnVwZGF0ZSghMSl9O214T3V0bGluZS5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhPdXRsaW5lLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteE91dGxpbmUucHJvdG90eXBlLnNldFpvb21FbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuc2l6ZXIubm9kZS5zdHlsZS52aXNpYmlsaXR5PWE/InZpc2libGUiOiJoaWRkZW4ifTtteE91dGxpbmUucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZSghMCl9OwpteE91dGxpbmUucHJvdG90eXBlLmNyZWF0ZVNpemVyPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbCE9dGhpcy5zaXplckltYWdlP25ldyBteEltYWdlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLnNpemVySW1hZ2Uud2lkdGgsdGhpcy5zaXplckltYWdlLmhlaWdodCksdGhpcy5zaXplckltYWdlLnNyYyk6bmV3IG14UmVjdGFuZ2xlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLnNpemVyU2l6ZSx0aGlzLnNpemVyU2l6ZSksbXhDb25zdGFudHMuT1VUTElORV9IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLk9VVExJTkVfSEFORExFX1NUUk9LRUNPTE9SKTthLmRpYWxlY3Q9dGhpcy5vdXRsaW5lLmRpYWxlY3Q7cmV0dXJuIGF9O214T3V0bGluZS5wcm90b3R5cGUuZ2V0U291cmNlQ29udGFpbmVyU2l6ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLHRoaXMuc291cmNlLmNvbnRhaW5lci5zY3JvbGxXaWR0aCx0aGlzLnNvdXJjZS5jb250YWluZXIuc2Nyb2xsSGVpZ2h0KX07Cm14T3V0bGluZS5wcm90b3R5cGUuZ2V0T3V0bGluZU9mZnNldD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07bXhPdXRsaW5lLnByb3RvdHlwZS5nZXRTb3VyY2VHcmFwaEJvdW5kcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNvdXJjZS5nZXRHcmFwaEJvdW5kcygpfTsKbXhPdXRsaW5lLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5zb3VyY2UmJm51bGwhPXRoaXMuc291cmNlLmNvbnRhaW5lciYmbnVsbCE9dGhpcy5vdXRsaW5lJiZudWxsIT10aGlzLm91dGxpbmUuY29udGFpbmVyKXt2YXIgYj10aGlzLnNvdXJjZS52aWV3LnNjYWxlLGM9dGhpcy5nZXRTb3VyY2VHcmFwaEJvdW5kcygpLGM9bmV3IG14UmVjdGFuZ2xlKGMueC9iK3RoaXMuc291cmNlLnBhbkR4LGMueS9iK3RoaXMuc291cmNlLnBhbkR5LGMud2lkdGgvYixjLmhlaWdodC9iKSxkPW5ldyBteFJlY3RhbmdsZSgwLDAsdGhpcy5zb3VyY2UuY29udGFpbmVyLmNsaWVudFdpZHRoL2IsdGhpcy5zb3VyY2UuY29udGFpbmVyLmNsaWVudEhlaWdodC9iKSxlPWMuY2xvbmUoKTtlLmFkZChkKTtkPXRoaXMuZ2V0U291cmNlQ29udGFpbmVyU2l6ZSgpO2I9TWF0aC5taW4oTWF0aC5tYXgoMCx0aGlzLm91dGxpbmUuY29udGFpbmVyLmNsaWVudFdpZHRoLXRoaXMuYm9yZGVyKS8KTWF0aC5tYXgoZC53aWR0aC9iLGUud2lkdGgpLE1hdGgubWF4KDAsdGhpcy5vdXRsaW5lLmNvbnRhaW5lci5jbGllbnRIZWlnaHQtdGhpcy5ib3JkZXIpL01hdGgubWF4KGQuaGVpZ2h0L2IsZS5oZWlnaHQpKTtkPWlzTmFOKGIpP3RoaXMubWluU2NhbGU6TWF0aC5tYXgodGhpcy5taW5TY2FsZSxiKTtpZigwPGQpe3RoaXMub3V0bGluZS5nZXRWaWV3KCkuc2NhbGUhPWQmJih0aGlzLm91dGxpbmUuZ2V0VmlldygpLnNjYWxlPWQsYT0hMCk7Yj10aGlzLm91dGxpbmUuZ2V0VmlldygpO2IuY3VycmVudFJvb3QhPXRoaXMuc291cmNlLmdldFZpZXcoKS5jdXJyZW50Um9vdCYmYi5zZXRDdXJyZW50Um9vdCh0aGlzLnNvdXJjZS5nZXRWaWV3KCkuY3VycmVudFJvb3QpO3ZhciBlPXRoaXMuc291cmNlLnZpZXcudHJhbnNsYXRlLGY9ZS54K3RoaXMuc291cmNlLnBhbkR4LGc9ZS55K3RoaXMuc291cmNlLnBhbkR5LGQ9dGhpcy5nZXRPdXRsaW5lT2Zmc2V0KGQpO251bGwhPWQmJihmKz1kLngsCmcrPWQueSk7MD5jLngmJihmLT1jLngpOzA+Yy55JiYoZy09Yy55KTtpZihiLnRyYW5zbGF0ZS54IT1mfHxiLnRyYW5zbGF0ZS55IT1nKWIudHJhbnNsYXRlLng9ZixiLnRyYW5zbGF0ZS55PWcsYT0hMDt2YXIgYz1iLnRyYW5zbGF0ZSxkPXRoaXMuc291cmNlLmdldFZpZXcoKS5zY2FsZSxmPWQvYi5zY2FsZSxnPTEvYi5zY2FsZSxrPXRoaXMuc291cmNlLmNvbnRhaW5lcjt0aGlzLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoKGMueC1lLngtdGhpcy5zb3VyY2UucGFuRHgpL2csKGMueS1lLnktdGhpcy5zb3VyY2UucGFuRHkpL2csay5jbGllbnRXaWR0aC9mLGsuY2xpZW50SGVpZ2h0L2YpO3RoaXMuYm91bmRzLngrPXRoaXMuc291cmNlLmNvbnRhaW5lci5zY3JvbGxMZWZ0KmIuc2NhbGUvZDt0aGlzLmJvdW5kcy55Kz10aGlzLnNvdXJjZS5jb250YWluZXIuc2Nyb2xsVG9wKmIuc2NhbGUvZDtjPXRoaXMuc2VsZWN0aW9uQm9yZGVyLmJvdW5kcztpZihjLnghPXRoaXMuYm91bmRzLnh8fApjLnkhPXRoaXMuYm91bmRzLnl8fGMud2lkdGghPXRoaXMuYm91bmRzLndpZHRofHxjLmhlaWdodCE9dGhpcy5ib3VuZHMuaGVpZ2h0KXRoaXMuc2VsZWN0aW9uQm9yZGVyLmJvdW5kcz10aGlzLmJvdW5kcyx0aGlzLnNlbGVjdGlvbkJvcmRlci5yZWRyYXcoKTtjPXRoaXMuc2l6ZXIuYm91bmRzO2I9bmV3IG14UmVjdGFuZ2xlKHRoaXMuYm91bmRzLngrdGhpcy5ib3VuZHMud2lkdGgtYy53aWR0aC8yLHRoaXMuYm91bmRzLnkrdGhpcy5ib3VuZHMuaGVpZ2h0LWMuaGVpZ2h0LzIsYy53aWR0aCxjLmhlaWdodCk7aWYoYy54IT1iLnh8fGMueSE9Yi55fHxjLndpZHRoIT1iLndpZHRofHxjLmhlaWdodCE9Yi5oZWlnaHQpdGhpcy5zaXplci5ib3VuZHM9YiwiaGlkZGVuIiE9dGhpcy5zaXplci5ub2RlLnN0eWxlLnZpc2liaWxpdHkmJnRoaXMuc2l6ZXIucmVkcmF3KCk7YSYmdGhpcy5vdXRsaW5lLnZpZXcucmV2YWxpZGF0ZSgpfX19OwpteE91dGxpbmUucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe2lmKHRoaXMuZW5hYmxlZCYmdGhpcy5zaG93Vmlld3BvcnQpe3ZhciBjPW14RXZlbnQuaXNNb3VzZUV2ZW50KGIuZ2V0RXZlbnQoKSk/MDp0aGlzLnNvdXJjZS50b2xlcmFuY2UsYz10aGlzLnNvdXJjZS5hbGxvd0hhbmRsZUJvdW5kc0NoZWNrJiYobXhDbGllbnQuSVNfSUV8fDA8Yyk/bmV3IG14UmVjdGFuZ2xlKGIuZ2V0R3JhcGhYKCktYyxiLmdldEdyYXBoWSgpLWMsMipjLDIqYyk6bnVsbDt0aGlzLnpvb209Yi5pc1NvdXJjZSh0aGlzLnNpemVyKXx8bnVsbCE9YyYmbXhVdGlscy5pbnRlcnNlY3RzKHNoYXBlLmJvdW5kcyxjKTt0aGlzLnN0YXJ0WD1iLmdldFgoKTt0aGlzLnN0YXJ0WT1iLmdldFkoKTt0aGlzLmFjdGl2ZT0hMDt0aGlzLnNvdXJjZS51c2VTY3JvbGxiYXJzRm9yUGFubmluZyYmbXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuc291cmNlLmNvbnRhaW5lcik/KHRoaXMuZHgwPXRoaXMuc291cmNlLmNvbnRhaW5lci5zY3JvbGxMZWZ0LAp0aGlzLmR5MD10aGlzLnNvdXJjZS5jb250YWluZXIuc2Nyb2xsVG9wKTp0aGlzLmR5MD10aGlzLmR4MD0wfWIuY29uc3VtZSgpfTsKbXhPdXRsaW5lLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmFjdGl2ZSl7dGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZS5zdHlsZS5kaXNwbGF5PXRoaXMuc2hvd1ZpZXdwb3J0PyIiOiJub25lIjt0aGlzLnNpemVyLm5vZGUuc3R5bGUuZGlzcGxheT10aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLnN0eWxlLmRpc3BsYXk7dmFyIGM9dGhpcy5nZXRUcmFuc2xhdGVGb3JFdmVudChiKSxkPWMueCxlPWMueTtpZih0aGlzLnpvb20pYz10aGlzLnNvdXJjZS5jb250YWluZXIsZT1kLyhjLmNsaWVudFdpZHRoL2MuY2xpZW50SGVpZ2h0KSxjPW5ldyBteFJlY3RhbmdsZSh0aGlzLmJvdW5kcy54LHRoaXMuYm91bmRzLnksTWF0aC5tYXgoMSx0aGlzLmJvdW5kcy53aWR0aCtkKSxNYXRoLm1heCgxLHRoaXMuYm91bmRzLmhlaWdodCtlKSksdGhpcy5zZWxlY3Rpb25Cb3JkZXIuYm91bmRzPWMsdGhpcy5zZWxlY3Rpb25Cb3JkZXIucmVkcmF3KCk7ZWxzZXt2YXIgZj10aGlzLm91dGxpbmUuZ2V0VmlldygpLnNjYWxlLApjPW5ldyBteFJlY3RhbmdsZSh0aGlzLmJvdW5kcy54K2QsdGhpcy5ib3VuZHMueStlLHRoaXMuYm91bmRzLndpZHRoLHRoaXMuYm91bmRzLmhlaWdodCk7dGhpcy5zZWxlY3Rpb25Cb3JkZXIuYm91bmRzPWM7dGhpcy5zZWxlY3Rpb25Cb3JkZXIucmVkcmF3KCk7ZD1kL2YqdGhpcy5zb3VyY2UuZ2V0VmlldygpLnNjYWxlO2U9ZS9mKnRoaXMuc291cmNlLmdldFZpZXcoKS5zY2FsZTt0aGlzLnNvdXJjZS5wYW5HcmFwaCgtZC10aGlzLmR4MCwtZS10aGlzLmR5MCl9ZD10aGlzLnNpemVyLmJvdW5kczt0aGlzLnNpemVyLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoYy54K2Mud2lkdGgtZC53aWR0aC8yLGMueStjLmhlaWdodC1kLmhlaWdodC8yLGQud2lkdGgsZC5oZWlnaHQpOyJoaWRkZW4iIT10aGlzLnNpemVyLm5vZGUuc3R5bGUudmlzaWJpbGl0eSYmdGhpcy5zaXplci5yZWRyYXcoKTtiLmNvbnN1bWUoKX19OwpteE91dGxpbmUucHJvdG90eXBlLmdldFRyYW5zbGF0ZUZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhQb2ludChhLmdldFgoKS10aGlzLnN0YXJ0WCxhLmdldFkoKS10aGlzLnN0YXJ0WSl9OwpteE91dGxpbmUucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmFjdGl2ZSl7dmFyIGM9dGhpcy5nZXRUcmFuc2xhdGVGb3JFdmVudChiKSxkPWMueCxjPWMueTtpZigwPE1hdGguYWJzKGQpfHwwPE1hdGguYWJzKGMpKXtpZih0aGlzLnpvb20pe3ZhciBjPXRoaXMuc2VsZWN0aW9uQm9yZGVyLmJvdW5kcy53aWR0aCxlPXRoaXMuc291cmNlLmdldFZpZXcoKS5zY2FsZTt0aGlzLnNvdXJjZS56b29tVG8oTWF0aC5tYXgodGhpcy5taW5TY2FsZSxlLWQqZS9jKSwhMSl9ZWxzZSB0aGlzLnNvdXJjZS51c2VTY3JvbGxiYXJzRm9yUGFubmluZyYmbXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuc291cmNlLmNvbnRhaW5lcil8fCh0aGlzLnNvdXJjZS5wYW5HcmFwaCgwLDApLGQvPXRoaXMub3V0bGluZS5nZXRWaWV3KCkuc2NhbGUsYy89dGhpcy5vdXRsaW5lLmdldFZpZXcoKS5zY2FsZSxlPXRoaXMuc291cmNlLmdldFZpZXcoKS50cmFuc2xhdGUsdGhpcy5zb3VyY2UuZ2V0VmlldygpLnNldFRyYW5zbGF0ZShlLngtCmQsZS55LWMpKTt0aGlzLnVwZGF0ZSgpO2IuY29uc3VtZSgpfXRoaXMuaW5kZXg9bnVsbDt0aGlzLmFjdGl2ZT0hMX19OwpteE91dGxpbmUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnNvdXJjZSYmKHRoaXMuc291cmNlLnJlbW92ZUxpc3RlbmVyKHRoaXMucGFuSGFuZGxlciksdGhpcy5zb3VyY2UucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoSGFuZGxlciksdGhpcy5zb3VyY2UuZ2V0TW9kZWwoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnVwZGF0ZUhhbmRsZXIpLHRoaXMuc291cmNlLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnVwZGF0ZUhhbmRsZXIpLG14RXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5zb3VyY2UuY29udGFpbmVyLCJzY3JvbGwiLHRoaXMudXBkYXRlSGFuZGxlciksdGhpcy5zb3VyY2U9bnVsbCk7bnVsbCE9dGhpcy5vdXRsaW5lJiYodGhpcy5vdXRsaW5lLnJlbW92ZU1vdXNlTGlzdGVuZXIodGhpcyksdGhpcy5vdXRsaW5lLmRlc3Ryb3koKSx0aGlzLm91dGxpbmU9bnVsbCk7bnVsbCE9dGhpcy5zZWxlY3Rpb25Cb3JkZXImJih0aGlzLnNlbGVjdGlvbkJvcmRlci5kZXN0cm95KCksCnRoaXMuc2VsZWN0aW9uQm9yZGVyPW51bGwpO251bGwhPXRoaXMuc2l6ZXImJih0aGlzLnNpemVyLmRlc3Ryb3koKSx0aGlzLnNpemVyPW51bGwpfTtmdW5jdGlvbiBteE11bHRpcGxpY2l0eShhLGIsYyxkLGUsZixnLGssbCxtKXt0aGlzLnNvdXJjZT1hO3RoaXMudHlwZT1iO3RoaXMuYXR0cj1jO3RoaXMudmFsdWU9ZDt0aGlzLm1pbj1udWxsIT1lP2U6MDt0aGlzLm1heD1udWxsIT1mP2Y6Im4iO3RoaXMudmFsaWROZWlnaGJvcnM9Zzt0aGlzLmNvdW50RXJyb3I9bXhSZXNvdXJjZXMuZ2V0KGspfHxrO3RoaXMudHlwZUVycm9yPW14UmVzb3VyY2VzLmdldChsKXx8bDt0aGlzLnZhbGlkTmVpZ2hib3JzQWxsb3dlZD1udWxsIT1tP206ITB9bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLnR5cGU9bnVsbDtteE11bHRpcGxpY2l0eS5wcm90b3R5cGUuYXR0cj1udWxsO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS52YWx1ZT1udWxsO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS5zb3VyY2U9bnVsbDsKbXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLm1pbj1udWxsO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS5tYXg9bnVsbDtteE11bHRpcGxpY2l0eS5wcm90b3R5cGUudmFsaWROZWlnaGJvcnM9bnVsbDtteE11bHRpcGxpY2l0eS5wcm90b3R5cGUudmFsaWROZWlnaGJvcnNBbGxvd2VkPSEwO214TXVsdGlwbGljaXR5LnByb3RvdHlwZS5jb3VudEVycm9yPW51bGw7bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLnR5cGVFcnJvcj1udWxsOwpteE11bHRpcGxpY2l0eS5wcm90b3R5cGUuY2hlY2s9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPSIiO2lmKHRoaXMuc291cmNlJiZ0aGlzLmNoZWNrVGVybWluYWwoYSxjLGIpfHwhdGhpcy5zb3VyY2UmJnRoaXMuY2hlY2tUZXJtaW5hbChhLGQsYikpbnVsbCE9dGhpcy5jb3VudEVycm9yJiYodGhpcy5zb3VyY2UmJigwPT10aGlzLm1heHx8ZT49dGhpcy5tYXgpfHwhdGhpcy5zb3VyY2UmJigwPT10aGlzLm1heHx8Zj49dGhpcy5tYXgpKSYmKGcrPXRoaXMuY291bnRFcnJvcisiXG4iKSxudWxsIT10aGlzLnZhbGlkTmVpZ2hib3JzJiZudWxsIT10aGlzLnR5cGVFcnJvciYmMDx0aGlzLnZhbGlkTmVpZ2hib3JzLmxlbmd0aCYmKHRoaXMuY2hlY2tOZWlnaGJvcnMoYSxiLGMsZCl8fChnKz10aGlzLnR5cGVFcnJvcisiXG4iKSk7cmV0dXJuIDA8Zy5sZW5ndGg/ZzpudWxsfTsKbXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLmNoZWNrTmVpZ2hib3JzPWZ1bmN0aW9uKGEsYixjLGQpe2I9YS5tb2RlbC5nZXRWYWx1ZShjKTtkPWEubW9kZWwuZ2V0VmFsdWUoZCk7Yz0hdGhpcy52YWxpZE5laWdoYm9yc0FsbG93ZWQ7Zm9yKHZhciBlPXRoaXMudmFsaWROZWlnaGJvcnMsZj0wO2Y8ZS5sZW5ndGg7ZisrKWlmKHRoaXMuc291cmNlJiZ0aGlzLmNoZWNrVHlwZShhLGQsZVtmXSkpe2M9dGhpcy52YWxpZE5laWdoYm9yc0FsbG93ZWQ7YnJlYWt9ZWxzZSBpZighdGhpcy5zb3VyY2UmJnRoaXMuY2hlY2tUeXBlKGEsYixlW2ZdKSl7Yz10aGlzLnZhbGlkTmVpZ2hib3JzQWxsb3dlZDticmVha31yZXR1cm4gY307bXhNdWx0aXBsaWNpdHkucHJvdG90eXBlLmNoZWNrVGVybWluYWw9ZnVuY3Rpb24oYSxiLGMpe2I9YS5tb2RlbC5nZXRWYWx1ZShiKTtyZXR1cm4gdGhpcy5jaGVja1R5cGUoYSxiLHRoaXMudHlwZSx0aGlzLmF0dHIsdGhpcy52YWx1ZSl9OwpteE11bHRpcGxpY2l0eS5wcm90b3R5cGUuY2hlY2tUeXBlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG51bGwhPWI/aXNOYU4oYi5ub2RlVHlwZSk/Yj09YzpteFV0aWxzLmlzTm9kZShiLGMsZCxlKTohMX07CmZ1bmN0aW9uIG14TGF5b3V0TWFuYWdlcihhKXt0aGlzLnVuZG9IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5iZWZvcmVVbmRvKGMuZ2V0UHJvcGVydHkoImVkaXQiKSl9KTt0aGlzLm1vdmVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5jZWxsc01vdmVkKGMuZ2V0UHJvcGVydHkoImNlbGxzIiksYy5nZXRQcm9wZXJ0eSgiZXZlbnQiKSl9KTt0aGlzLnJlc2l6ZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt0aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmNlbGxzUmVzaXplZChjLmdldFByb3BlcnR5KCJjZWxscyIpLGMuZ2V0UHJvcGVydHkoImJvdW5kcyIpLGMuZ2V0UHJvcGVydHkoInByZXZpb3VzIikpfSk7dGhpcy5zZXRHcmFwaChhKX1teExheW91dE1hbmFnZXIucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlOwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14TGF5b3V0TWFuYWdlcjtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5idWJibGluZz0hMDtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS51bmRvSGFuZGxlcj1udWxsO214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUubW92ZUhhbmRsZXI9bnVsbDtteExheW91dE1hbmFnZXIucHJvdG90eXBlLnJlc2l6ZUhhbmRsZXI9bnVsbDtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5pc0J1YmJsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnViYmxpbmd9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLnNldEJ1YmJsaW5nPWZ1bmN0aW9uKGEpe3RoaXMuYnViYmxpbmc9YX07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRHcmFwaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBofTsKbXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5zZXRHcmFwaD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmdyYXBoKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCk7Yi5yZW1vdmVMaXN0ZW5lcih0aGlzLnVuZG9IYW5kbGVyKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMubW92ZUhhbmRsZXIpO3RoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNpemVIYW5kbGVyKX10aGlzLmdyYXBoPWE7bnVsbCE9dGhpcy5ncmFwaCYmKGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGIuYWRkTGlzdGVuZXIobXhFdmVudC5CRUZPUkVfVU5ETyx0aGlzLnVuZG9IYW5kbGVyKSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuTU9WRV9DRUxMUyx0aGlzLm1vdmVIYW5kbGVyKSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUkVTSVpFX0NFTExTLHRoaXMucmVzaXplSGFuZGxlcikpfTsKbXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5oYXNMYXlvdXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0TGF5b3V0KGEsbXhFdmVudC5MQVlPVVRfQ0VMTFMpfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmdldExheW91dD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmJlZm9yZVVuZG89ZnVuY3Rpb24oYSl7dGhpcy5leGVjdXRlTGF5b3V0Rm9yQ2VsbHModGhpcy5nZXRDZWxsc0ZvckNoYW5nZXMoYS5jaGFuZ2VzKSl9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmNlbGxzTW92ZWQ9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hJiZudWxsIT1iKWZvcih2YXIgYz1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdldEdyYXBoKCkuY29udGFpbmVyLG14RXZlbnQuZ2V0Q2xpZW50WChiKSxteEV2ZW50LmdldENsaWVudFkoYikpLGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5nZXRBbmNlc3RvckxheW91dChhW2RdLG14RXZlbnQuTU9WRV9DRUxMUyk7bnVsbCE9ZSYmZS5tb3ZlQ2VsbChhW2RdLGMueCxjLnkpfX07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5jZWxsc1Jlc2l6ZWQ9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWEmJm51bGwhPWIpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMuZ2V0QW5jZXN0b3JMYXlvdXQoYVtkXSxteEV2ZW50LlJFU0laRV9DRUxMUyk7bnVsbCE9ZSYmZS5yZXNpemVDZWxsKGFbZF0sYltkXSxjW2RdKX19OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmdldEFuY2VzdG9yTGF5b3V0PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuZ2V0R3JhcGgoKS5nZXRNb2RlbCgpO251bGwhPWE7KXt2YXIgZD10aGlzLmdldExheW91dChhLGIpO2lmKG51bGwhPWQpcmV0dXJuIGQ7YT1jLmdldFBhcmVudChhKX1yZXR1cm4gbnVsbH07bXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRDZWxsc0ZvckNoYW5nZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXTtpZihkIGluc3RhbmNlb2YgbXhSb290Q2hhbmdlKXJldHVybltdO2I9Yi5jb25jYXQodGhpcy5nZXRDZWxsc0ZvckNoYW5nZShkKSl9cmV0dXJuIGJ9OwpteExheW91dE1hbmFnZXIucHJvdG90eXBlLmdldENlbGxzRm9yQ2hhbmdlPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgbXhDaGlsZENoYW5nZT90aGlzLmFkZENlbGxzV2l0aExheW91dChhLmNoaWxkLHRoaXMuYWRkQ2VsbHNXaXRoTGF5b3V0KGEucHJldmlvdXMpKTphIGluc3RhbmNlb2YgbXhUZXJtaW5hbENoYW5nZXx8YSBpbnN0YW5jZW9mIG14R2VvbWV0cnlDaGFuZ2V8fGEgaW5zdGFuY2VvZiBteFZpc2libGVDaGFuZ2V8fGEgaW5zdGFuY2VvZiBteFN0eWxlQ2hhbmdlP3RoaXMuYWRkQ2VsbHNXaXRoTGF5b3V0KGEuY2VsbCk6W119O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuYWRkQ2VsbHNXaXRoTGF5b3V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYWRkRGVzY2VuZGFudHNXaXRoTGF5b3V0KGEsdGhpcy5hZGRBbmNlc3RvcnNXaXRoTGF5b3V0KGEsYikpfTsKbXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5hZGRBbmNlc3RvcnNXaXRoTGF5b3V0PWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6W107aWYobnVsbCE9YSYmKG51bGwhPXRoaXMuaGFzTGF5b3V0KGEpJiZiLnB1c2goYSksdGhpcy5pc0J1YmJsaW5nKCkpKXt2YXIgYz10aGlzLmdldEdyYXBoKCkuZ2V0TW9kZWwoKTt0aGlzLmFkZEFuY2VzdG9yc1dpdGhMYXlvdXQoYy5nZXRQYXJlbnQoYSksYil9cmV0dXJuIGJ9O214TGF5b3V0TWFuYWdlci5wcm90b3R5cGUuYWRkRGVzY2VuZGFudHNXaXRoTGF5b3V0PWZ1bmN0aW9uKGEsYil7Yj1udWxsIT1iP2I6W107aWYobnVsbCE9YSYmdGhpcy5oYXNMYXlvdXQoYSkpZm9yKHZhciBjPXRoaXMuZ2V0R3JhcGgoKS5nZXRNb2RlbCgpLGQ9MDtkPGMuZ2V0Q2hpbGRDb3VudChhKTtkKyspe3ZhciBlPWMuZ2V0Q2hpbGRBdChhLGQpO3RoaXMuaGFzTGF5b3V0KGUpJiYoYi5wdXNoKGUpLHRoaXMuYWRkRGVzY2VuZGFudHNXaXRoTGF5b3V0KGUsYikpfXJldHVybiBifTsKbXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5leGVjdXRlTGF5b3V0Rm9yQ2VsbHM9ZnVuY3Rpb24oYSl7YT1teFV0aWxzLnNvcnRDZWxscyhhLCEwKTt0aGlzLmxheW91dENlbGxzKGEsITEpO3RoaXMubGF5b3V0Q2VsbHMoYS5yZXZlcnNlKCksITApfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmxheW91dENlbGxzPWZ1bmN0aW9uKGEsYil7aWYoMDxhLmxlbmd0aCl7dmFyIGM9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCk7Yy5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGQ9bnVsbCxlPTA7ZTxhLmxlbmd0aDtlKyspYVtlXSE9Yy5nZXRSb290KCkmJmFbZV0hPWQmJih0aGlzLmV4ZWN1dGVMYXlvdXQoYVtlXSxiKSxkPWFbZV0pO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuTEFZT1VUX0NFTExTLCJjZWxscyIsYSkpfWZpbmFsbHl7Yy5lbmRVcGRhdGUoKX19fTsKbXhMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5leGVjdXRlTGF5b3V0PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRMYXlvdXQoYSxiP214RXZlbnQuRU5EX1VQREFURTpteEV2ZW50LkJFR0lOX1VQREFURSk7bnVsbCE9YyYmYy5leGVjdXRlKGEpfTtteExheW91dE1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnNldEdyYXBoKG51bGwpfTsKZnVuY3Rpb24gbXhTd2ltbGFuZU1hbmFnZXIoYSxiLGMsZCl7dGhpcy5ob3Jpem9udGFsPW51bGwhPWI/YjohMDt0aGlzLmFkZEVuYWJsZWQ9bnVsbCE9Yz9jOiEwO3RoaXMucmVzaXplRW5hYmxlZD1udWxsIT1kP2Q6ITA7dGhpcy5hZGRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5pc0FkZEVuYWJsZWQoKSYmdGhpcy5jZWxsc0FkZGVkKGIuZ2V0UHJvcGVydHkoImNlbGxzIikpfSk7dGhpcy5yZXNpemVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5pc1Jlc2l6ZUVuYWJsZWQoKSYmdGhpcy5jZWxsc1Jlc2l6ZWQoYi5nZXRQcm9wZXJ0eSgiY2VsbHMiKSl9KTt0aGlzLnNldEdyYXBoKGEpfW14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZT1uZXcgbXhFdmVudFNvdXJjZTtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhTd2ltbGFuZU1hbmFnZXI7Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5ncmFwaD1udWxsO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5lbmFibGVkPSEwO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5ob3Jpem9udGFsPSEwO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5hZGRFbmFibGVkPSEwO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5yZXNpemVFbmFibGVkPSEwO214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5hZGRIYW5kbGVyPW51bGw7bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLnJlc2l6ZUhhbmRsZXI9bnVsbDtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5pc0hvcml6b250YWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3Jpem9udGFsfTsKbXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLnNldEhvcml6b250YWw9ZnVuY3Rpb24oYSl7dGhpcy5ob3Jpem9udGFsPWF9O214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5pc0FkZEVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGRFbmFibGVkfTtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuc2V0QWRkRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmFkZEVuYWJsZWQ9YX07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmlzUmVzaXplRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc2l6ZUVuYWJsZWR9O214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5zZXRSZXNpemVFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMucmVzaXplRW5hYmxlZD1hfTtteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhcGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaH07Cm14U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5zZXRHcmFwaD1mdW5jdGlvbihhKXtudWxsIT10aGlzLmdyYXBoJiYodGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmFkZEhhbmRsZXIpLHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNpemVIYW5kbGVyKSk7dGhpcy5ncmFwaD1hO251bGwhPXRoaXMuZ3JhcGgmJih0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuQUREX0NFTExTLHRoaXMuYWRkSGFuZGxlciksdGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkNFTExTX1JFU0laRUQsdGhpcy5yZXNpemVIYW5kbGVyKSl9O214U3dpbWxhbmVNYW5hZ2VyLnByb3RvdHlwZS5pc1N3aW1sYW5lSWdub3JlZD1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5nZXRHcmFwaCgpLmlzU3dpbWxhbmUoYSl9OwpteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuaXNDZWxsSG9yaXpvbnRhbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEpPyhhPXRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGEpLDE9PW14VXRpbHMuZ2V0VmFsdWUoYSxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLDEpKTohdGhpcy5pc0hvcml6b250YWwoKX07bXhTd2ltbGFuZU1hbmFnZXIucHJvdG90eXBlLmNlbGxzQWRkZWQ9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCk7Yi5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl0aGlzLmlzU3dpbWxhbmVJZ25vcmVkKGFbY10pfHx0aGlzLnN3aW1sYW5lQWRkZWQoYVtjXSl9ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX19OwpteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuc3dpbWxhbmVBZGRlZD1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCksYz1iLmdldFBhcmVudChhKSxkPWIuZ2V0Q2hpbGRDb3VudChjKSxlPW51bGwsZj0wO2Y8ZDtmKyspe3ZhciBnPWIuZ2V0Q2hpbGRBdChjLGYpO2lmKGchPWEmJiF0aGlzLmlzU3dpbWxhbmVJZ25vcmVkKGcpJiYoZT1iLmdldEdlb21ldHJ5KGcpLG51bGwhPWUpKWJyZWFrfW51bGwhPWUmJihiPW51bGwhPWM/dGhpcy5pc0NlbGxIb3Jpem9udGFsKGMpOnRoaXMuaG9yaXpvbnRhbCx0aGlzLnJlc2l6ZVN3aW1sYW5lKGEsZS53aWR0aCxlLmhlaWdodCxiKSl9OwpteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuY2VsbHNSZXNpemVkPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPXRoaXMuZ2V0R3JhcGgoKS5nZXRNb2RlbCgpO2IuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYoIXRoaXMuaXNTd2ltbGFuZUlnbm9yZWQoYVtjXSkpe3ZhciBkPWIuZ2V0R2VvbWV0cnkoYVtjXSk7aWYobnVsbCE9ZCl7Zm9yKHZhciBlPW5ldyBteFJlY3RhbmdsZSgwLDAsZC53aWR0aCxkLmhlaWdodCksZj1hW2NdLGc9ZjtudWxsIT1nOyl7dmFyIGY9ZyxnPWIuZ2V0UGFyZW50KGcpLGs9dGhpcy5ncmFwaC5pc1N3aW1sYW5lKGcpP3RoaXMuZ3JhcGguZ2V0U3RhcnRTaXplKGcpOm5ldyBteFJlY3RhbmdsZTtlLndpZHRoKz1rLndpZHRoO2UuaGVpZ2h0Kz1rLmhlaWdodH12YXIgbD1udWxsIT1nP3RoaXMuaXNDZWxsSG9yaXpvbnRhbChnKTp0aGlzLmhvcml6b250YWw7dGhpcy5yZXNpemVTd2ltbGFuZShmLGUud2lkdGgsCmUuaGVpZ2h0LGwpfX19ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX19OwpteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUucmVzaXplU3dpbWxhbmU9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5nZXRHcmFwaCgpLmdldE1vZGVsKCk7ZS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZj10aGlzLmlzQ2VsbEhvcml6b250YWwoYSk7aWYoIXRoaXMuaXNTd2ltbGFuZUlnbm9yZWQoYSkpe3ZhciBnPWUuZ2V0R2VvbWV0cnkoYSk7bnVsbCE9ZyYmKGQmJmcuaGVpZ2h0IT1jfHwhZCYmZy53aWR0aCE9YikmJihnPWcuY2xvbmUoKSxkP2cuaGVpZ2h0PWM6Zy53aWR0aD1iLGUuc2V0R2VvbWV0cnkoYSxnKSl9dmFyIGs9dGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEpP3RoaXMuZ3JhcGguZ2V0U3RhcnRTaXplKGEpOm5ldyBteFJlY3RhbmdsZTtiLT1rLndpZHRoO2MtPWsuaGVpZ2h0O3ZhciBsPWUuZ2V0Q2hpbGRDb3VudChhKTtmb3IoZD0wO2Q8bDtkKyspe3ZhciBtPWUuZ2V0Q2hpbGRBdChhLGQpO3RoaXMucmVzaXplU3dpbWxhbmUobSxiLGMsZil9fWZpbmFsbHl7ZS5lbmRVcGRhdGUoKX19OwpteFN3aW1sYW5lTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuc2V0R3JhcGgobnVsbCl9OwpmdW5jdGlvbiBteFRlbXBvcmFyeUNlbGxTdGF0ZXMoYSxiLGMsZCxlKXtiPW51bGwhPWI/YjoxO3RoaXMudmlldz1hO3RoaXMub2xkVmFsaWRhdGVDZWxsU3RhdGU9YS52YWxpZGF0ZUNlbGxTdGF0ZTt0aGlzLm9sZEJvdW5kcz1hLmdldEdyYXBoQm91bmRzKCk7dGhpcy5vbGRTdGF0ZXM9YS5nZXRTdGF0ZXMoKTt0aGlzLm9sZFNjYWxlPWEuZ2V0U2NhbGUoKTt0aGlzLm9sZERvUmVkcmF3U2hhcGU9YS5ncmFwaC5jZWxsUmVuZGVyZXIuZG9SZWRyYXdTaGFwZTt2YXIgZj10aGlzO251bGwhPWUmJihhLmdyYXBoLmNlbGxSZW5kZXJlci5kb1JlZHJhd1NoYXBlPWZ1bmN0aW9uKGIpe3ZhciBjPWIuc2hhcGUucGFpbnQ7Yi5zaGFwZS5wYWludD1mdW5jdGlvbihhKXt2YXIgZD1lKGIpO251bGwhPWQmJmEuc2V0TGluayhkKTtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT1kJiZhLnNldExpbmsobnVsbCl9O2Yub2xkRG9SZWRyYXdTaGFwZS5hcHBseShhLmdyYXBoLmNlbGxSZW5kZXJlciwKYXJndW1lbnRzKTtiLnNoYXBlLnBhaW50PWN9KTthLnZhbGlkYXRlQ2VsbFN0YXRlPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIG51bGw9PWJ8fG51bGw9PWR8fGQoYik/Zi5vbGRWYWxpZGF0ZUNlbGxTdGF0ZS5hcHBseShhLGFyZ3VtZW50cyk6bnVsbH07YS5zZXRTdGF0ZXMobmV3IG14RGljdGlvbmFyeSk7YS5zZXRTY2FsZShiKTtpZihudWxsIT1jKXthLnJlc2V0VmFsaWRhdGlvblN0YXRlKCk7Yj1udWxsO2Zvcih2YXIgZz0wO2c8Yy5sZW5ndGg7ZysrKXt2YXIgaz1hLmdldEJvdW5kaW5nQm94KGEudmFsaWRhdGVDZWxsU3RhdGUoYS52YWxpZGF0ZUNlbGwoY1tnXSkpKTtudWxsPT1iP2I9azpiLmFkZChrKX1hLnNldEdyYXBoQm91bmRzKGJ8fG5ldyBteFJlY3RhbmdsZSl9fW14VGVtcG9yYXJ5Q2VsbFN0YXRlcy5wcm90b3R5cGUudmlldz1udWxsO214VGVtcG9yYXJ5Q2VsbFN0YXRlcy5wcm90b3R5cGUub2xkU3RhdGVzPW51bGw7Cm14VGVtcG9yYXJ5Q2VsbFN0YXRlcy5wcm90b3R5cGUub2xkQm91bmRzPW51bGw7bXhUZW1wb3JhcnlDZWxsU3RhdGVzLnByb3RvdHlwZS5vbGRTY2FsZT1udWxsO214VGVtcG9yYXJ5Q2VsbFN0YXRlcy5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudmlldy5zZXRTY2FsZSh0aGlzLm9sZFNjYWxlKTt0aGlzLnZpZXcuc2V0U3RhdGVzKHRoaXMub2xkU3RhdGVzKTt0aGlzLnZpZXcuc2V0R3JhcGhCb3VuZHModGhpcy5vbGRCb3VuZHMpO3RoaXMudmlldy52YWxpZGF0ZUNlbGxTdGF0ZT10aGlzLm9sZFZhbGlkYXRlQ2VsbFN0YXRlO3RoaXMudmlldy5ncmFwaC5jZWxsUmVuZGVyZXIuZG9SZWRyYXdTaGFwZT10aGlzLm9sZERvUmVkcmF3U2hhcGV9O2Z1bmN0aW9uIG14Q2VsbFN0YXRlUHJldmlldyhhKXt0aGlzLmRlbHRhcz1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuZ3JhcGg9YX1teENlbGxTdGF0ZVByZXZpZXcucHJvdG90eXBlLmdyYXBoPW51bGw7Cm14Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUuZGVsdGFzPW51bGw7bXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS5jb3VudD0wO214Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLmNvdW50fTtteENlbGxTdGF0ZVByZXZpZXcucHJvdG90eXBlLm1vdmVTdGF0ZT1mdW5jdGlvbihhLGIsYyxkLGUpe2Q9bnVsbCE9ZD9kOiEwO2U9bnVsbCE9ZT9lOiEwO3ZhciBmPXRoaXMuZGVsdGFzLmdldChhLmNlbGwpO251bGw9PWY/KGY9e3BvaW50Om5ldyBteFBvaW50KGIsYyksc3RhdGU6YX0sdGhpcy5kZWx0YXMucHV0KGEuY2VsbCxmKSx0aGlzLmNvdW50KyspOmQ/KGYucG9pbnQueCs9YixmLnBvaW50LnkrPWMpOihmLnBvaW50Lng9YixmLnBvaW50Lnk9Yyk7ZSYmdGhpcy5hZGRFZGdlcyhhKTtyZXR1cm4gZi5wb2ludH07Cm14Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihhKXt0aGlzLmRlbHRhcy52aXNpdChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RoaXMudHJhbnNsYXRlU3RhdGUoYy5zdGF0ZSxjLnBvaW50LngsYy5wb2ludC55KX0pKTt0aGlzLmRlbHRhcy52aXNpdChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGMpe3RoaXMucmV2YWxpZGF0ZVN0YXRlKGMuc3RhdGUsYy5wb2ludC54LGMucG9pbnQueSxhKX0pKX07Cm14Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUudHJhbnNsYXRlU3RhdGU9ZnVuY3Rpb24oYSxiLGMpe2lmKG51bGwhPWEpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtpZihkLmlzVmVydGV4KGEuY2VsbCkpe2Eudmlldy51cGRhdGVDZWxsU3RhdGUoYSk7dmFyIGU9ZC5nZXRHZW9tZXRyeShhLmNlbGwpOzA9PWImJjA9PWN8fG51bGw9PWV8fGUucmVsYXRpdmUmJm51bGw9PXRoaXMuZGVsdGFzLmdldChhLmNlbGwpfHwoYS54Kz1iLGEueSs9Yyl9Zm9yKHZhciBlPWQuZ2V0Q2hpbGRDb3VudChhLmNlbGwpLGY9MDtmPGU7ZisrKXRoaXMudHJhbnNsYXRlU3RhdGUoYS52aWV3LmdldFN0YXRlKGQuZ2V0Q2hpbGRBdChhLmNlbGwsZikpLGIsYyl9fTsKbXhDZWxsU3RhdGVQcmV2aWV3LnByb3RvdHlwZS5yZXZhbGlkYXRlU3RhdGU9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9YSl7dmFyIGU9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2UuaXNFZGdlKGEuY2VsbCkmJmEudmlldy51cGRhdGVDZWxsU3RhdGUoYSk7dmFyIGY9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYS5jZWxsKSxnPWEudmlldy5nZXRTdGF0ZShlLmdldFBhcmVudChhLmNlbGwpKTswPT1iJiYwPT1jfHxudWxsPT1mfHwhZi5yZWxhdGl2ZXx8IWUuaXNWZXJ0ZXgoYS5jZWxsKXx8bnVsbCE9ZyYmIWUuaXNWZXJ0ZXgoZy5jZWxsKSYmbnVsbD09dGhpcy5kZWx0YXMuZ2V0KGEuY2VsbCl8fChhLngrPWIsYS55Kz1jKTt0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcoYSk7bnVsbCE9ZCYmZChhKTtmPWUuZ2V0Q2hpbGRDb3VudChhLmNlbGwpO2ZvcihnPTA7ZzxmO2crKyl0aGlzLnJldmFsaWRhdGVTdGF0ZSh0aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoZS5nZXRDaGlsZEF0KGEuY2VsbCwKZykpLGIsYyxkKX19O214Q2VsbFN0YXRlUHJldmlldy5wcm90b3R5cGUuYWRkRWRnZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxjPWIuZ2V0RWRnZUNvdW50KGEuY2VsbCksZD0wO2Q8YztkKyspe3ZhciBlPWEudmlldy5nZXRTdGF0ZShiLmdldEVkZ2VBdChhLmNlbGwsZCkpO251bGwhPWUmJnRoaXMubW92ZVN0YXRlKGUsMCwwKX19O2Z1bmN0aW9uIG14Q29ubmVjdGlvbkNvbnN0cmFpbnQoYSxiLGMsZCxlKXt0aGlzLnBvaW50PWE7dGhpcy5wZXJpbWV0ZXI9bnVsbCE9Yj9iOiEwO3RoaXMubmFtZT1jO3RoaXMuZHg9ZD9kOjA7dGhpcy5keT1lP2U6MH1teENvbm5lY3Rpb25Db25zdHJhaW50LnByb3RvdHlwZS5wb2ludD1udWxsO214Q29ubmVjdGlvbkNvbnN0cmFpbnQucHJvdG90eXBlLnBlcmltZXRlcj1udWxsO214Q29ubmVjdGlvbkNvbnN0cmFpbnQucHJvdG90eXBlLm5hbWU9bnVsbDsKbXhDb25uZWN0aW9uQ29uc3RyYWludC5wcm90b3R5cGUuZHg9bnVsbDtteENvbm5lY3Rpb25Db25zdHJhaW50LnByb3RvdHlwZS5keT1udWxsOwpmdW5jdGlvbiBteEdyYXBoSGFuZGxlcihhKXt0aGlzLmdyYXBoPWE7dGhpcy5ncmFwaC5hZGRNb3VzZUxpc3RlbmVyKHRoaXMpO3RoaXMucGFuSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc3VzcGVuZGVkfHwodGhpcy51cGRhdGVQcmV2aWV3KCksdGhpcy51cGRhdGVIaW50KCkpfSk7dGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LlBBTix0aGlzLnBhbkhhbmRsZXIpO3RoaXMuZXNjYXBlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RoaXMucmVzZXQoKX0pO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FU0NBUEUsdGhpcy5lc2NhcGVIYW5kbGVyKTt0aGlzLnJlZnJlc2hIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmZpcnN0JiYhdGhpcy5zdXNwZW5kZWQpe3ZhciBhPXRoaXMuY3VycmVudER4LApiPXRoaXMuY3VycmVudER5O3RoaXMuY3VycmVudER5PXRoaXMuY3VycmVudER4PTA7dGhpcy51cGRhdGVQcmV2aWV3KCk7dGhpcy5ib3VuZHM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0Qm91bmRzKHRoaXMuY2VsbHMpO3RoaXMucEJvdW5kcz10aGlzLmdldFByZXZpZXdCb3VuZHModGhpcy5jZWxscyk7bnVsbD09dGhpcy5wQm91bmRzP3RoaXMucmVzZXQoKToodGhpcy5jdXJyZW50RHg9YSx0aGlzLmN1cnJlbnREeT1iLHRoaXMudXBkYXRlUHJldmlldygpLHRoaXMudXBkYXRlSGludCgpLHRoaXMubGl2ZVByZXZpZXdVc2VkJiZ0aGlzLnNldEhhbmRsZXNWaXNpYmxlRm9yQ2VsbHModGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlZFNlbGVjdGlvbkNlbGxzKCksITEpKX19KSwwKX0pO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLnJlZnJlc2hIYW5kbGVyKTt0aGlzLmtleUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEpe251bGw9PXRoaXMuZ3JhcGguY29udGFpbmVyfHwiaGlkZGVuIj09dGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eXx8bnVsbD09dGhpcy5maXJzdHx8dGhpcy5zdXNwZW5kZWR8fChhPXRoaXMuZ3JhcGguaXNDbG9uZUV2ZW50KGEpJiZ0aGlzLmdyYXBoLmlzQ2VsbHNDbG9uZWFibGUoKSYmdGhpcy5pc0Nsb25lRW5hYmxlZCgpLGEhPXRoaXMuY2xvbmluZyYmKHRoaXMuY2xvbmluZz1hLHRoaXMuY2hlY2tQcmV2aWV3KCksdGhpcy51cGRhdGVQcmV2aWV3KCkpKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoZG9jdW1lbnQsImtleWRvd24iLHRoaXMua2V5SGFuZGxlcik7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwia2V5dXAiLHRoaXMua2V5SGFuZGxlcil9bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1heENlbGxzPW14Q2xpZW50LklTX0lFPzIwOjUwOwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaGlnaGxpZ2h0RW5hYmxlZD0hMDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuY2xvbmVFbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlRW5hYmxlZD0hMDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ3VpZGVzRW5hYmxlZD0hMTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlc1Zpc2libGU9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmd1aWRlPW51bGw7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmN1cnJlbnREeD1udWxsO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jdXJyZW50RHk9bnVsbDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUudXBkYXRlQ3Vyc29yPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zZWxlY3RFbmFibGVkPSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVDZWxsc0Zyb21QYXJlbnQ9ITA7Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVFbXB0eVBhcmVudHM9ITE7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3RPbkRyb3A9ITE7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNjcm9sbE9uTW92ZT0hMDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUubWluaW11bVNpemU9NjtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucHJldmlld0NvbG9yPSJibGFjayI7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmh0bWxQcmV2aWV3PSExO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zaGFwZT1udWxsO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zY2FsZUdyaWQ9ITE7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJvdGF0aW9uRW5hYmxlZD0hMDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUubWF4TGl2ZVByZXZpZXc9MDtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuYWxsb3dMaXZlUHJldmlldz1teENsaWVudC5JU19TVkc7Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmFibGVkfTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzQ2xvbmVFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmVFbmFibGVkfTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuc2V0Q2xvbmVFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuY2xvbmVFbmFibGVkPWF9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc01vdmVFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW92ZUVuYWJsZWR9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zZXRNb3ZlRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLm1vdmVFbmFibGVkPWF9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc1NlbGVjdEVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxlY3RFbmFibGVkfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldFNlbGVjdEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RFbmFibGVkPWF9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc1JlbW92ZUNlbGxzRnJvbVBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlbW92ZUNlbGxzRnJvbVBhcmVudH07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldFJlbW92ZUNlbGxzRnJvbVBhcmVudD1mdW5jdGlvbihhKXt0aGlzLnJlbW92ZUNlbGxzRnJvbVBhcmVudD1hfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzUHJvcGFnYXRlU2VsZWN0aW9uQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGEpO2lmKGIpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO3JldHVybiF0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZShhKSYmIXRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGMpJiYhdGhpcy5ncmFwaC5pc1NpYmxpbmdTZWxlY3RlZChhKSYmKG51bGw9PWR8fGQucmVsYXRpdmV8fCF0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYykpfXJldHVybiF0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGMpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmdldEluaXRpYWxDZWxsRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRTdGF0ZSgpO2lmKCF0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoYS5nZXRFdmVudCgpKSYmbnVsbCE9YiYmIXRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0ZWQoYi5jZWxsKSl7YT10aGlzLmdyYXBoLm1vZGVsO2Zvcih2YXIgYz10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYS5nZXRQYXJlbnQoYi5jZWxsKSk7bnVsbCE9YyYmIXRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0ZWQoYy5jZWxsKSYmKGEuaXNWZXJ0ZXgoYy5jZWxsKXx8YS5pc0VkZ2UoYy5jZWxsKSkmJnRoaXMuaXNQcm9wYWdhdGVTZWxlY3Rpb25DZWxsKGIuY2VsbCwhMCk7KWI9YyxjPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGIuY2VsbCkpfXJldHVybiBudWxsIT1iP2IuY2VsbDpudWxsfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzRGVsYXllZFNlbGVjdGlvbj1mdW5jdGlvbihhLGIpe2lmKCF0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoYi5nZXRFdmVudCgpKSlmb3IoO251bGwhPWE7KXtpZih0aGlzLmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5pc0hhbmRsZWQoYSkpcmV0dXJuIHRoaXMuZ3JhcGguY2VsbEVkaXRvci5nZXRFZGl0aW5nQ2VsbCgpIT1hO2E9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoYSl9cmV0dXJuIHRoaXMuZ3JhcGguaXNUb2dnbGVFdmVudChiLmdldEV2ZW50KCkpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdERlbGF5ZWQ9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuZ3JhcGgucG9wdXBNZW51SGFuZGxlci5pc1BvcHVwVHJpZ2dlcihhKSl7dmFyIGI9YS5nZXRDZWxsKCk7bnVsbD09YiYmKGI9dGhpcy5jZWxsKTt2YXIgYz10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYik7aWYobnVsbCE9Yyl7aWYoIWEuaXNTb3VyY2UoYy5jb250cm9sKSYmIXRoaXMuZ3JhcGguaXNUb2dnbGVFdmVudChhLmdldEV2ZW50KCkpKWZvcih2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCksZD1jLmdldFBhcmVudChiKTtudWxsIT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoZCkmJihjLmlzVmVydGV4KGQpfHxjLmlzRWRnZShkKSkmJnRoaXMuaXNQcm9wYWdhdGVTZWxlY3Rpb25DZWxsKGIsITEpOyliPWQsZD1jLmdldFBhcmVudChiKTt0aGlzLmdyYXBoLnNlbGVjdENlbGxGb3JFdmVudChiLGEuZ2V0RXZlbnQoKSl9fX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jb25zdW1lTW91c2VFdmVudD1mdW5jdGlvbihhLGIpe2IuY29uc3VtZSgpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmbnVsbCE9Yi5nZXRTdGF0ZSgpJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpKXt2YXIgYz10aGlzLmdldEluaXRpYWxDZWxsRm9yRXZlbnQoYik7dGhpcy5kZWxheWVkU2VsZWN0aW9uPXRoaXMuaXNEZWxheWVkU2VsZWN0aW9uKGMsYik7dGhpcy5jZWxsPW51bGw7dGhpcy5pc1NlbGVjdEVuYWJsZWQoKSYmIXRoaXMuZGVsYXllZFNlbGVjdGlvbiYmdGhpcy5ncmFwaC5zZWxlY3RDZWxsRm9yRXZlbnQoYyxiLmdldEV2ZW50KCkpO2lmKHRoaXMuaXNNb3ZlRW5hYmxlZCgpKXt2YXIgZD10aGlzLmdyYXBoLm1vZGVsLGU9ZC5nZXRHZW9tZXRyeShjKTt0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUoYykmJighZC5pc0VkZ2UoYyl8fDE8dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpfHwKbnVsbCE9ZS5wb2ludHMmJjA8ZS5wb2ludHMubGVuZ3RofHxudWxsPT1kLmdldFRlcm1pbmFsKGMsITApfHxudWxsPT1kLmdldFRlcm1pbmFsKGMsITEpfHx0aGlzLmdyYXBoLmFsbG93RGFuZ2xpbmdFZGdlc3x8dGhpcy5ncmFwaC5pc0Nsb25lRXZlbnQoYi5nZXRFdmVudCgpKSYmdGhpcy5ncmFwaC5pc0NlbGxzQ2xvbmVhYmxlKCkpP3RoaXMuc3RhcnQoYyxiLmdldFgoKSxiLmdldFkoKSk6dGhpcy5kZWxheWVkU2VsZWN0aW9uJiYodGhpcy5jZWxsPWMpO3RoaXMuY2VsbFdhc0NsaWNrZWQ9ITA7dGhpcy5jb25zdW1lTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX0RPV04sYil9fX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRHdWlkZVN0YXRlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpLGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKSYmYi5pc1ZlcnRleChhKSYmbnVsbCE9Yi5nZXRHZW9tZXRyeShhKSYmIWIuZ2V0R2VvbWV0cnkoYSkucmVsYXRpdmV9KTtyZXR1cm4gdGhpcy5ncmFwaC52aWV3LmdldENlbGxTdGF0ZXMoYi5maWx0ZXJEZXNjZW5kYW50cyhjLGEpKX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmdldENlbGxzPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmRlbGF5ZWRTZWxlY3Rpb24mJnRoaXMuZ3JhcGguaXNDZWxsTW92YWJsZShhKT9bYV06dGhpcy5ncmFwaC5nZXRNb3ZhYmxlQ2VsbHModGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25DZWxscygpKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRQcmV2aWV3Qm91bmRzPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRCb3VuZGluZ0JveChhKTtudWxsIT1hJiYoYS53aWR0aD1NYXRoLm1heCgwLGEud2lkdGgtMSksYS5oZWlnaHQ9TWF0aC5tYXgoMCxhLmhlaWdodC0xKSxhLndpZHRoPHRoaXMubWluaW11bVNpemU/KGEueC09KHRoaXMubWluaW11bVNpemUtYS53aWR0aCkvMixhLndpZHRoPXRoaXMubWluaW11bVNpemUpOihhLng9TWF0aC5yb3VuZChhLngpLGEud2lkdGg9TWF0aC5jZWlsKGEud2lkdGgpKSxhLmhlaWdodDx0aGlzLm1pbmltdW1TaXplPyhhLnktPSh0aGlzLm1pbmltdW1TaXplLWEuaGVpZ2h0KS8yLGEuaGVpZ2h0PXRoaXMubWluaW11bVNpemUpOihhLnk9TWF0aC5yb3VuZChhLnkpLGEuaGVpZ2h0PU1hdGguY2VpbChhLmhlaWdodCkpKTtyZXR1cm4gYX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveD1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpZm9yKHZhciBjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxkPTA7ZDxhLmxlbmd0aDtkKyspaWYoYy5pc1ZlcnRleChhW2RdKXx8Yy5pc0VkZ2UoYVtkXSkpe3ZhciBlPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhW2RdKTtpZihudWxsIT1lKXt2YXIgZj1lO2MuaXNWZXJ0ZXgoYVtkXSkmJm51bGwhPWUuc2hhcGUmJm51bGwhPWUuc2hhcGUuYm91bmRpbmdCb3gmJihmPWUuc2hhcGUuYm91bmRpbmdCb3gpO251bGw9PWI/Yj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpOmIuYWRkKGYpfX1yZXR1cm4gYn07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQcmV2aWV3U2hhcGU9ZnVuY3Rpb24oYSl7YT1uZXcgbXhSZWN0YW5nbGVTaGFwZShhLG51bGwsdGhpcy5wcmV2aWV3Q29sb3IpO2EuaXNEYXNoZWQ9ITA7dGhpcy5odG1sUHJldmlldz8oYS5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxhLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooYS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsYS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpLGEucG9pbnRlckV2ZW50cz0hMSxteENsaWVudC5JU19JT1MmJihhLmdldFN2Z1NjcmVlbk9mZnNldD1mdW5jdGlvbigpe3JldHVybiAwfSkpO3JldHVybiBhfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuY2VsbD1hO3RoaXMuZmlyc3Q9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5ncmFwaC5jb250YWluZXIsYixjKTt0aGlzLmNlbGxzPW51bGwhPWQ/ZDp0aGlzLmdldENlbGxzKHRoaXMuY2VsbCk7dGhpcy5ib3VuZHM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0Qm91bmRzKHRoaXMuY2VsbHMpO3RoaXMucEJvdW5kcz10aGlzLmdldFByZXZpZXdCb3VuZHModGhpcy5jZWxscyk7dGhpcy5hbGxDZWxscz1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuY2xvbmluZz0hMTtmb3IoYj10aGlzLmNlbGxDb3VudD0wO2I8dGhpcy5jZWxscy5sZW5ndGg7YisrKXRoaXMuY2VsbENvdW50Kz10aGlzLmFkZFN0YXRlcyh0aGlzLmNlbGxzW2JdLHRoaXMuYWxsQ2VsbHMpO2lmKHRoaXMuZ3VpZGVzRW5hYmxlZCl7dGhpcy5ndWlkZT1uZXcgbXhHdWlkZSh0aGlzLmdyYXBoLHRoaXMuZ2V0R3VpZGVTdGF0ZXMoKSk7CnZhciBlPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGEpLGY9Mj50aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoZSksZz1uZXcgbXhEaWN0aW9uYXJ5O2E9dGhpcy5ncmFwaC5nZXRPcHBvc2l0ZXModGhpcy5ncmFwaC5nZXRFZGdlcyh0aGlzLmNlbGwpLHRoaXMuY2VsbCk7Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKyljPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhW2JdKSxudWxsPT1jfHxnLmdldChjKXx8Zy5wdXQoYywhMCk7dGhpcy5ndWlkZS5pc1N0YXRlSWdub3JlZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChhLmNlbGwpO3JldHVybiBudWxsIT1hLmNlbGwmJighdGhpcy5jbG9uaW5nJiZ0aGlzLmlzQ2VsbE1vdmluZyhhLmNlbGwpfHxhLmNlbGwhPSh0aGlzLnRhcmdldHx8ZSkmJiFmJiYhZy5nZXQoYSkmJihudWxsPT10aGlzLnRhcmdldHx8Mjw9dGhpcy5ncmFwaC5tb2RlbC5nZXRDaGlsZENvdW50KHRoaXMudGFyZ2V0KSkmJgpiIT0odGhpcy50YXJnZXR8fGUpKX0pfX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmFkZFN0YXRlcz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKSxkPTA7aWYobnVsbCE9YyYmbnVsbD09Yi5nZXQoYSkpe2IucHV0KGEsYyk7ZCsrO2Zvcih2YXIgYz10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoYSksZT0wO2U8YztlKyspZCs9dGhpcy5hZGRTdGF0ZXModGhpcy5ncmFwaC5tb2RlbC5nZXRDaGlsZEF0KGEsZSksYil9cmV0dXJuIGR9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc0NlbGxNb3Zpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuYWxsQ2VsbHMuZ2V0KGEpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnVzZUd1aWRlc0ZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT10aGlzLmd1aWRlP3RoaXMuZ3VpZGUuaXNFbmFibGVkRm9yRXZlbnQoYS5nZXRFdmVudCgpKSYmIXRoaXMuZ3JhcGguaXNDb25zdHJhaW5lZEV2ZW50KGEuZ2V0RXZlbnQoKSk6ITB9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zbmFwPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2NhbGVHcmlkP3RoaXMuZ3JhcGgudmlldy5zY2FsZToxO2EueD10aGlzLmdyYXBoLnNuYXAoYS54L2IpKmI7YS55PXRoaXMuZ3JhcGguc25hcChhLnkvYikqYjtyZXR1cm4gYX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXREZWx0YT1mdW5jdGlvbihhKXthPW14VXRpbHMuY29udmVydFBvaW50KHRoaXMuZ3JhcGguY29udGFpbmVyLGEuZ2V0WCgpLGEuZ2V0WSgpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54LXRoaXMuZmlyc3QueC10aGlzLmdyYXBoLnBhbkR4LGEueS10aGlzLmZpcnN0LnktdGhpcy5ncmFwaC5wYW5EeSl9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVIaW50PWZ1bmN0aW9uKGEpe307bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ9ZnVuY3Rpb24oKXt9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yb3VuZExlbmd0aD1mdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5yb3VuZCgxMDAqYSkvMTAwfTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNWYWxpZERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQodGhpcy5jZWxsKSE9YX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5jaGVja1ByZXZpZXc9ZnVuY3Rpb24oKXt0aGlzLmxpdmVQcmV2aWV3QWN0aXZlJiZ0aGlzLmNsb25pbmc/KHRoaXMucmVzZXRMaXZlUHJldmlldygpLHRoaXMubGl2ZVByZXZpZXdBY3RpdmU9ITEpOnRoaXMubWF4TGl2ZVByZXZpZXc+PXRoaXMuY2VsbENvdW50JiYhdGhpcy5saXZlUHJldmlld0FjdGl2ZSYmdGhpcy5hbGxvd0xpdmVQcmV2aWV3P3RoaXMuY2xvbmluZyYmdGhpcy5saXZlUHJldmlld0FjdGl2ZXx8KHRoaXMubGl2ZVByZXZpZXdVc2VkPXRoaXMubGl2ZVByZXZpZXdBY3RpdmU9ITApOnRoaXMubGl2ZVByZXZpZXdVc2VkfHxudWxsIT10aGlzLnNoYXBlfHwodGhpcy5zaGFwZT10aGlzLmNyZWF0ZVByZXZpZXdTaGFwZSh0aGlzLmJvdW5kcykpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGg7aWYoYi5pc0NvbnN1bWVkKCl8fCFjLmlzTW91c2VEb3dufHxudWxsPT10aGlzLmNlbGx8fG51bGw9PXRoaXMuZmlyc3R8fG51bGw9PXRoaXMuYm91bmRzfHx0aGlzLnN1c3BlbmRlZCkhdGhpcy5pc01vdmVFbmFibGVkKCkmJiF0aGlzLmlzQ2xvbmVFbmFibGVkKCl8fCF0aGlzLnVwZGF0ZUN1cnNvcnx8Yi5pc0NvbnN1bWVkKCl8fG51bGw9PWIuZ2V0U3RhdGUoKSYmbnVsbD09Yi5zb3VyY2VTdGF0ZXx8Yy5pc01vdXNlRG93bnx8KGQ9Yy5nZXRDdXJzb3JGb3JNb3VzZUV2ZW50KGIpLG51bGw9PWQmJmMuaXNFbmFibGVkKCkmJmMuaXNDZWxsTW92YWJsZShiLmdldENlbGwoKSkmJihkPWMuZ2V0TW9kZWwoKS5pc0VkZ2UoYi5nZXRDZWxsKCkpP214Q29uc3RhbnRzLkNVUlNPUl9NT1ZBQkxFX0VER0U6bXhDb25zdGFudHMuQ1VSU09SX01PVkFCTEVfVkVSVEVYKSxudWxsIT0KZCYmbnVsbCE9Yi5zb3VyY2VTdGF0ZSYmYi5zb3VyY2VTdGF0ZS5zZXRDdXJzb3IoZCkpO2Vsc2UgaWYobXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpKXRoaXMucmVzZXQoKTtlbHNle3ZhciBkPXRoaXMuZ2V0RGVsdGEoYiksZT1jLnRvbGVyYW5jZTtpZihudWxsIT10aGlzLnNoYXBlfHx0aGlzLmxpdmVQcmV2aWV3QWN0aXZlfHxNYXRoLmFicyhkLngpPmV8fE1hdGguYWJzKGQueSk+ZSl7bnVsbD09dGhpcy5oaWdobGlnaHQmJih0aGlzLmhpZ2hsaWdodD1uZXcgbXhDZWxsSGlnaGxpZ2h0KHRoaXMuZ3JhcGgsbXhDb25zdGFudHMuRFJPUF9UQVJHRVRfQ09MT1IsMykpO3ZhciBlPWMuaXNDbG9uZUV2ZW50KGIuZ2V0RXZlbnQoKSkmJmMuaXNDZWxsc0Nsb25lYWJsZSgpJiZ0aGlzLmlzQ2xvbmVFbmFibGVkKCksZj1jLmlzR3JpZEVuYWJsZWRFdmVudChiLmdldEV2ZW50KCkpLGc9Yi5nZXRDZWxsKCksaz0hMCxsPW51bGw7dGhpcy5jbG9uaW5nPWU7Yy5pc0Ryb3BFbmFibGVkKCkmJgp0aGlzLmhpZ2hsaWdodEVuYWJsZWQmJihsPWMuZ2V0RHJvcFRhcmdldCh0aGlzLmNlbGxzLGIuZ2V0RXZlbnQoKSxnLGUpKTt2YXIgbT1jLmdldFZpZXcoKS5nZXRTdGF0ZShsKSxuPSExO251bGwhPW0mJihlfHx0aGlzLmlzVmFsaWREcm9wVGFyZ2V0KGwsYikpPyh0aGlzLnRhcmdldCE9bCYmKHRoaXMudGFyZ2V0PWwsdGhpcy5zZXRIaWdobGlnaHRDb2xvcihteENvbnN0YW50cy5EUk9QX1RBUkdFVF9DT0xPUikpLG49ITApOih0aGlzLnRhcmdldD1udWxsLHRoaXMuY29ubmVjdE9uRHJvcCYmbnVsbCE9ZyYmMT09dGhpcy5jZWxscy5sZW5ndGgmJmMuZ2V0TW9kZWwoKS5pc1ZlcnRleChnKSYmYy5pc0NlbGxDb25uZWN0YWJsZShnKSYmKG09Yy5nZXRWaWV3KCkuZ2V0U3RhdGUoZyksbnVsbCE9bSYmKGc9bnVsbD09Yy5nZXRFZGdlVmFsaWRhdGlvbkVycm9yKG51bGwsdGhpcy5jZWxsLGcpP214Q29uc3RhbnRzLlZBTElEX0NPTE9SOm14Q29uc3RhbnRzLklOVkFMSURfQ09OTkVDVF9UQVJHRVRfQ09MT1IsCnRoaXMuc2V0SGlnaGxpZ2h0Q29sb3IoZyksbj0hMCkpKTtudWxsIT1tJiZuP3RoaXMuaGlnaGxpZ2h0LmhpZ2hsaWdodChtKTp0aGlzLmhpZ2hsaWdodC5oaWRlKCk7bnVsbCE9dGhpcy5ndWlkZSYmdGhpcy51c2VHdWlkZXNGb3JFdmVudChiKT8oZD10aGlzLmd1aWRlLm1vdmUodGhpcy5ib3VuZHMsZCxmLGUpLGs9ITEpOmQ9dGhpcy5ncmFwaC5zbmFwRGVsdGEoZCx0aGlzLmJvdW5kcywhZiwhMSwhMSk7bnVsbCE9dGhpcy5ndWlkZSYmayYmdGhpcy5ndWlkZS5oaWRlKCk7Yy5pc0NvbnN0cmFpbmVkRXZlbnQoYi5nZXRFdmVudCgpKSYmKE1hdGguYWJzKGQueCk+TWF0aC5hYnMoZC55KT9kLnk9MDpkLng9MCk7dGhpcy5jaGVja1ByZXZpZXcoKTtpZih0aGlzLmN1cnJlbnREeCE9ZC54fHx0aGlzLmN1cnJlbnREeSE9ZC55KXRoaXMuY3VycmVudER4PWQueCx0aGlzLmN1cnJlbnREeT1kLnksdGhpcy51cGRhdGVQcmV2aWV3KCl9dGhpcy51cGRhdGVIaW50KGIpO3RoaXMuY29uc3VtZU1vdXNlRXZlbnQobXhFdmVudC5NT1VTRV9NT1ZFLApiKTtteEV2ZW50LmNvbnN1bWUoYi5nZXRFdmVudCgpKX19O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3PWZ1bmN0aW9uKGEpe3RoaXMubGl2ZVByZXZpZXdVc2VkJiYhYT9udWxsIT10aGlzLmNlbGxzJiYodGhpcy5zZXRIYW5kbGVzVmlzaWJsZUZvckNlbGxzKHRoaXMuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscygpLCExKSx0aGlzLnVwZGF0ZUxpdmVQcmV2aWV3KHRoaXMuY3VycmVudER4LHRoaXMuY3VycmVudER5KSk6dGhpcy51cGRhdGVQcmV2aWV3U2hhcGUoKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U2hhcGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnNoYXBlJiZudWxsIT10aGlzLnBCb3VuZHMmJih0aGlzLnNoYXBlLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZCh0aGlzLnBCb3VuZHMueCt0aGlzLmN1cnJlbnREeCksTWF0aC5yb3VuZCh0aGlzLnBCb3VuZHMueSt0aGlzLmN1cnJlbnREeSksdGhpcy5wQm91bmRzLndpZHRoLHRoaXMucEJvdW5kcy5oZWlnaHQpLHRoaXMuc2hhcGUucmVkcmF3KCkpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUxpdmVQcmV2aWV3PWZ1bmN0aW9uKGEsYil7aWYoIXRoaXMuc3VzcGVuZGVkKXt2YXIgYz1bXTtudWxsIT10aGlzLmFsbENlbGxzJiZ0aGlzLmFsbENlbGxzLnZpc2l0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGQsZSl7aWYobnVsbD09dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGUuY2VsbCkpZS5kZXN0cm95KCk7ZWxzZXt2YXIgZj1lLmNsb25lKCk7Yy5wdXNoKFtlLGZdKTtudWxsIT1lLnNoYXBlJiYobnVsbD09ZS5zaGFwZS5vcmlnaW5hbFBvaW50ZXJFdmVudHMmJihlLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cz1lLnNoYXBlLnBvaW50ZXJFdmVudHMpLGUuc2hhcGUucG9pbnRlckV2ZW50cz0hMSxudWxsIT1lLnRleHQmJihudWxsPT1lLnRleHQub3JpZ2luYWxQb2ludGVyRXZlbnRzJiYoZS50ZXh0Lm9yaWdpbmFsUG9pbnRlckV2ZW50cz1lLnRleHQucG9pbnRlckV2ZW50cyksZS50ZXh0LnBvaW50ZXJFdmVudHM9CiExKSk7dGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleChlLmNlbGwpJiYoZS54Kz1hLGUueSs9Yix0aGlzLmNsb25pbmd8fChlLnZpZXcuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyhlLCEwKSxlLnZpZXcuaW52YWxpZGF0ZShlLmNlbGwpLGUuaW52YWxpZD0hMSxudWxsIT1lLmNvbnRyb2wmJm51bGwhPWUuY29udHJvbC5ub2RlJiYoZS5jb250cm9sLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIikpKX19KSk7aWYoMD09Yy5sZW5ndGgpdGhpcy5yZXNldCgpO2Vsc2V7Zm9yKHZhciBkPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV1bMF07aWYodGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoZi5jZWxsKSl7dmFyIGc9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoZi5jZWxsKSxrPVtdO2lmKG51bGwhPWcmJm51bGwhPWcucG9pbnRzKWZvcih2YXIgbD0wO2w8Zy5wb2ludHMubGVuZ3RoO2wrKyludWxsIT1nLnBvaW50c1tsXSYmay5wdXNoKG5ldyBteFBvaW50KGcucG9pbnRzW2xdLngrCmEvZCxnLnBvaW50c1tsXS55K2IvZCkpO3ZhciBnPWYudmlzaWJsZVNvdXJjZVN0YXRlLGw9Zi52aXNpYmxlVGFyZ2V0U3RhdGUsbT1jW2VdWzFdLmFic29sdXRlUG9pbnRzO251bGwhPWcmJnRoaXMuaXNDZWxsTW92aW5nKGcuY2VsbCk/Zi52aWV3LnVwZGF0ZUZpeGVkVGVybWluYWxQb2ludChmLGcsITAsdGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludChmLGcsITApKTooZz1tWzBdLGYuc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KGcueCthLGcueStiKSwhMCksZz1udWxsKTtudWxsIT1sJiZ0aGlzLmlzQ2VsbE1vdmluZyhsLmNlbGwpP2Yudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoZixsLCExLHRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQoZixsLCExKSk6KGw9bVttLmxlbmd0aC0xXSxmLnNldEFic29sdXRlVGVybWluYWxQb2ludChuZXcgbXhQb2ludChsLngrYSxsLnkrYiksITEpLGw9bnVsbCk7Zi52aWV3LnVwZGF0ZVBvaW50cyhmLAprLGcsbCk7Zi52aWV3LnVwZGF0ZUZsb2F0aW5nVGVybWluYWxQb2ludHMoZixnLGwpO2Yudmlldy51cGRhdGVFZGdlTGFiZWxPZmZzZXQoZik7Zi5pbnZhbGlkPSExO3RoaXMuY2xvbmluZ3x8Zi52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcoZiwhMCl9fXRoaXMuZ3JhcGgudmlldy52YWxpZGF0ZSgpO3RoaXMucmVkcmF3SGFuZGxlcyhjKTt0aGlzLnJlc2V0UHJldmlld1N0YXRlcyhjKX19fTtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucmVkcmF3SGFuZGxlcz1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihhW2JdWzBdLmNlbGwpO251bGwhPWMmJmMucmVkcmF3KCEwKX19O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZXNldFByZXZpZXdTdGF0ZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspYVtiXVswXS5zZXRTdGF0ZShhW2JdWzFdKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zdXNwZW5kPWZ1bmN0aW9uKCl7dGhpcy5zdXNwZW5kZWR8fCh0aGlzLmxpdmVQcmV2aWV3VXNlZCYmdGhpcy51cGRhdGVMaXZlUHJldmlldygwLDApLG51bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIiksbnVsbCE9dGhpcy5ndWlkZSYmdGhpcy5ndWlkZS5zZXRWaXNpYmxlKCExKSx0aGlzLnN1c3BlbmRlZD0hMCl9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXt0aGlzLnN1c3BlbmRlZCYmKHRoaXMuc3VzcGVuZGVkPW51bGwsdGhpcy5saXZlUHJldmlld1VzZWQmJih0aGlzLmxpdmVQcmV2aWV3QWN0aXZlPSEwKSxudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiKSxudWxsIT10aGlzLmd1aWRlJiZ0aGlzLmd1aWRlLnNldFZpc2libGUoITApKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZXNldExpdmVQcmV2aWV3PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hbGxDZWxscyYmKHRoaXMuYWxsQ2VsbHMudmlzaXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXtudWxsIT1iLnNoYXBlJiZudWxsIT1iLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cyYmKGIuc2hhcGUucG9pbnRlckV2ZW50cz1iLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cyxiLnNoYXBlLm9yaWdpbmFsUG9pbnRlckV2ZW50cz1udWxsLGIuc2hhcGUuYm91bmRzPW51bGwsbnVsbCE9Yi50ZXh0JiYoYi50ZXh0LnBvaW50ZXJFdmVudHM9Yi50ZXh0Lm9yaWdpbmFsUG9pbnRlckV2ZW50cyxiLnRleHQub3JpZ2luYWxQb2ludGVyRXZlbnRzPW51bGwpKTtudWxsIT1iLmNvbnRyb2wmJm51bGwhPWIuY29udHJvbC5ub2RlJiYiaGlkZGVuIj09Yi5jb250cm9sLm5vZGUuc3R5bGUudmlzaWJpbGl0eSYmKGIuY29udHJvbC5ub2RlLnN0eWxlLnZpc2liaWxpdHk9CiIiKTtiLnZpZXcuaW52YWxpZGF0ZShiLmNlbGwpfSkpLHRoaXMuZ3JhcGgudmlldy52YWxpZGF0ZSgpKX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlRm9yQ2VsbHM9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmhhbmRsZXNWaXNpYmxlIT1iKXt0aGlzLmhhbmRsZXNWaXNpYmxlPWI7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ3JhcGguc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmdldEhhbmRsZXIoYVtjXSk7bnVsbCE9ZCYmKGQuc2V0SGFuZGxlc1Zpc2libGUoYiksYiYmZC5yZWRyYXcoKSl9fX07bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNldEhpZ2hsaWdodENvbG9yPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuaGlnaGxpZ2h0JiZ0aGlzLmhpZ2hsaWdodC5zZXRIaWdobGlnaHRDb2xvcihhKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYoIWIuaXNDb25zdW1lZCgpKWlmKHRoaXMubGl2ZVByZXZpZXdVc2VkJiZ0aGlzLnJlc2V0TGl2ZVByZXZpZXcoKSxudWxsPT10aGlzLmNlbGx8fG51bGw9PXRoaXMuZmlyc3R8fG51bGw9PXRoaXMuc2hhcGUmJiF0aGlzLmxpdmVQcmV2aWV3VXNlZHx8bnVsbD09dGhpcy5jdXJyZW50RHh8fG51bGw9PXRoaXMuY3VycmVudER5KXRoaXMuaXNTZWxlY3RFbmFibGVkKCkmJnRoaXMuZGVsYXllZFNlbGVjdGlvbiYmbnVsbCE9dGhpcy5jZWxsJiZ0aGlzLnNlbGVjdERlbGF5ZWQoYik7ZWxzZXt2YXIgYz10aGlzLmdyYXBoLGQ9Yi5nZXRDZWxsKCk7aWYodGhpcy5jb25uZWN0T25Ecm9wJiZudWxsPT10aGlzLnRhcmdldCYmbnVsbCE9ZCYmYy5nZXRNb2RlbCgpLmlzVmVydGV4KGQpJiZjLmlzQ2VsbENvbm5lY3RhYmxlKGQpJiZjLmlzRWRnZVZhbGlkKG51bGwsdGhpcy5jZWxsLGQpKWMuY29ubmVjdGlvbkhhbmRsZXIuY29ubmVjdCh0aGlzLmNlbGwsCmQsYi5nZXRFdmVudCgpKTtlbHNle3ZhciBkPWMuaXNDbG9uZUV2ZW50KGIuZ2V0RXZlbnQoKSkmJmMuaXNDZWxsc0Nsb25lYWJsZSgpJiZ0aGlzLmlzQ2xvbmVFbmFibGVkKCksZT1jLmdldFZpZXcoKS5zY2FsZSxmPXRoaXMucm91bmRMZW5ndGgodGhpcy5jdXJyZW50RHgvZSksZT10aGlzLnJvdW5kTGVuZ3RoKHRoaXMuY3VycmVudER5L2UpLGc9dGhpcy50YXJnZXQ7Yy5pc1NwbGl0RW5hYmxlZCgpJiZjLmlzU3BsaXRUYXJnZXQoZyx0aGlzLmNlbGxzLGIuZ2V0RXZlbnQoKSk/Yy5zcGxpdEVkZ2UoZyx0aGlzLmNlbGxzLG51bGwsZixlLGIuZ2V0R3JhcGhYKCksYi5nZXRHcmFwaFkoKSk6dGhpcy5tb3ZlQ2VsbHModGhpcy5jZWxscyxmLGUsZCx0aGlzLnRhcmdldCxiLmdldEV2ZW50KCkpfX10aGlzLmNlbGxXYXNDbGlja2VkJiZ0aGlzLmNvbnN1bWVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsYik7dGhpcy5yZXNldCgpfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5saXZlUHJldmlld1VzZWQmJih0aGlzLnJlc2V0TGl2ZVByZXZpZXcoKSx0aGlzLnNldEhhbmRsZXNWaXNpYmxlRm9yQ2VsbHModGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlZFNlbGVjdGlvbkNlbGxzKCksITApKTt0aGlzLmRlc3Ryb3lTaGFwZXMoKTt0aGlzLnJlbW92ZUhpbnQoKTt0aGlzLmRlbGF5ZWRTZWxlY3Rpb249ITE7dGhpcy5saXZlUHJldmlld1VzZWQ9dGhpcy5saXZlUHJldmlld0FjdGl2ZT1udWxsO3RoaXMuY2VsbFdhc0NsaWNrZWQ9ITE7dGhpcy5jZWxsQ291bnQ9dGhpcy5jdXJyZW50RHk9dGhpcy5jdXJyZW50RHg9dGhpcy5zdXNwZW5kZWQ9bnVsbDt0aGlzLmNsb25pbmc9ITE7dGhpcy5jZWxsPXRoaXMuY2VsbHM9dGhpcy5maXJzdD10aGlzLnRhcmdldD10aGlzLmd1aWRlcz10aGlzLnBCb3VuZHM9dGhpcy5hbGxDZWxscz1udWxsfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNob3VsZFJlbW92ZUNlbGxzRnJvbVBhcmVudD1mdW5jdGlvbihhLGIsYyl7aWYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYoYT10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdGF0ZShhKSxudWxsIT1hKSl7Yz1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdyYXBoLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoYyksbXhFdmVudC5nZXRDbGllbnRZKGMpKTt2YXIgZD1teFV0aWxzLnRvUmFkaWFucyhteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04pfHwwKTtpZigwIT1kKXtiPU1hdGguY29zKC1kKTt2YXIgZD1NYXRoLnNpbigtZCksZT1uZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLmdldENlbnRlclkoKSk7Yz1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChjLGIsZCxlKX1yZXR1cm4hbXhVdGlscy5jb250YWlucyhhLGMueCxjLnkpfXJldHVybiExfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdmVDZWxscz1mdW5jdGlvbihhLGIsYyxkLGUsZil7ZCYmKGE9dGhpcy5ncmFwaC5nZXRDbG9uZWFibGVDZWxscyhhKSk7dmFyIGc9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudCh0aGlzLmNlbGwpO251bGw9PWUmJnRoaXMuaXNSZW1vdmVDZWxsc0Zyb21QYXJlbnQoKSYmdGhpcy5zaG91bGRSZW1vdmVDZWxsc0Zyb21QYXJlbnQoZyxhLGYpJiYoZT10aGlzLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKSk7ZD1kJiYhdGhpcy5ncmFwaC5pc0NlbGxMb2NrZWQoZXx8dGhpcy5ncmFwaC5nZXREZWZhdWx0UGFyZW50KCkpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtnPVtdO2lmKCFkJiZudWxsIT1lJiZ0aGlzLnJlbW92ZUVtcHR5UGFyZW50cyl7Zm9yKHZhciBrPW5ldyBteERpY3Rpb25hcnksbD0wO2w8YS5sZW5ndGg7bCsrKWsucHV0KGFbbF0sITApO2ZvcihsPTA7bDxhLmxlbmd0aDtsKyspe3ZhciBtPQp0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChhW2xdKTtudWxsPT1tfHxrLmdldChtKXx8KGsucHV0KG0sITApLGcucHVzaChtKSl9fWE9dGhpcy5ncmFwaC5tb3ZlQ2VsbHMoYSxiLGMsZCxlLGYpO2I9W107Zm9yKGw9MDtsPGcubGVuZ3RoO2wrKyl0aGlzLnNob3VsZFJlbW92ZVBhcmVudChnW2xdKSYmYi5wdXNoKGdbbF0pO3RoaXMuZ3JhcGgucmVtb3ZlQ2VsbHMoYiwhMSl9ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9ZCYmdGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxscyhhKTt0aGlzLmlzU2VsZWN0RW5hYmxlZCgpJiZ0aGlzLnNjcm9sbE9uTW92ZSYmdGhpcy5ncmFwaC5zY3JvbGxDZWxsVG9WaXNpYmxlKGFbMF0pfTsKbXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnNob3VsZFJlbW92ZVBhcmVudD1mdW5jdGlvbihhKXthPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKTtyZXR1cm4gbnVsbCE9YSYmKHRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGEuY2VsbCl8fHRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYS5jZWxsKSkmJnRoaXMuZ3JhcGguaXNDZWxsRGVsZXRhYmxlKGEuY2VsbCkmJjA9PXRoaXMuZ3JhcGgubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmNlbGwpJiZ0aGlzLmdyYXBoLmlzVHJhbnNwYXJlbnRTdGF0ZShhKX07Cm14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95U2hhcGVzPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGUuZGVzdHJveSgpLHRoaXMuc2hhcGU9bnVsbCk7bnVsbCE9dGhpcy5ndWlkZSYmKHRoaXMuZ3VpZGUuZGVzdHJveSgpLHRoaXMuZ3VpZGU9bnVsbCk7bnVsbCE9dGhpcy5oaWdobGlnaHQmJih0aGlzLmhpZ2hsaWdodC5kZXN0cm95KCksdGhpcy5oaWdobGlnaHQ9bnVsbCl9OwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMucGFuSGFuZGxlcik7bnVsbCE9dGhpcy5lc2NhcGVIYW5kbGVyJiYodGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmVzY2FwZUhhbmRsZXIpLHRoaXMuZXNjYXBlSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLnJlZnJlc2hIYW5kbGVyJiYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaEhhbmRsZXIpLHRoaXMucmVmcmVzaEhhbmRsZXI9bnVsbCk7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwia2V5ZG93biIsdGhpcy5rZXlIYW5kbGVyKTtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCJrZXl1cCIsdGhpcy5rZXlIYW5kbGVyKTt0aGlzLmRlc3Ryb3lTaGFwZXMoKTt0aGlzLnJlbW92ZUhpbnQoKX07CmZ1bmN0aW9uIG14UGFubmluZ0hhbmRsZXIoYSl7bnVsbCE9YSYmKHRoaXMuZ3JhcGg9YSx0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIodGhpcyksdGhpcy5mb3JjZVBhbm5pbmdIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dmFyIGI9Yy5nZXRQcm9wZXJ0eSgiZXZlbnROYW1lIiksZT1jLmdldFByb3BlcnR5KCJldmVudCIpO2I9PW14RXZlbnQuTU9VU0VfRE9XTiYmdGhpcy5pc0ZvcmNlUGFubmluZ0V2ZW50KGUpJiYodGhpcy5zdGFydChlKSx0aGlzLmFjdGl2ZT0hMCx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlBBTl9TVEFSVCwiZXZlbnQiLGUpKSxlLmNvbnN1bWUoKSl9KSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRklSRV9NT1VTRV9FVkVOVCx0aGlzLmZvcmNlUGFubmluZ0hhbmRsZXIpLHRoaXMuZ2VzdHVyZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtpZih0aGlzLmlzUGluY2hFbmFibGVkKCkpe3ZhciBiPQpjLmdldFByb3BlcnR5KCJldmVudCIpO214RXZlbnQuaXNDb25zdW1lZChiKXx8Imdlc3R1cmVzdGFydCIhPWIudHlwZT8iZ2VzdHVyZWVuZCI9PWIudHlwZSYmbnVsbCE9dGhpcy5pbml0aWFsU2NhbGUmJih0aGlzLmluaXRpYWxTY2FsZT1udWxsKToodGhpcy5pbml0aWFsU2NhbGU9dGhpcy5ncmFwaC52aWV3LnNjYWxlLHRoaXMuYWN0aXZlfHxudWxsPT10aGlzLm1vdXNlRG93bkV2ZW50fHwodGhpcy5zdGFydCh0aGlzLm1vdXNlRG93bkV2ZW50KSx0aGlzLm1vdXNlRG93bkV2ZW50PW51bGwpKTtudWxsIT10aGlzLmluaXRpYWxTY2FsZSYmdGhpcy56b29tR3JhcGgoYil9fSksdGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkdFU1RVUkUsdGhpcy5nZXN0dXJlSGFuZGxlciksdGhpcy5tb3VzZVVwTGlzdGVuZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZSYmdGhpcy5yZXNldCgpfSksbXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2V1cCIsCnRoaXMubW91c2VVcExpc3RlbmVyKSl9bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGU9bmV3IG14RXZlbnRTb3VyY2U7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0b3I9bXhQYW5uaW5nSGFuZGxlcjtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5ncmFwaD1udWxsO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnVzZUxlZnRCdXR0b25Gb3JQYW5uaW5nPSExO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnVzZVBvcHVwVHJpZ2dlcj0hMDtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pZ25vcmVDZWxsPSExO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnByZXZpZXdFbmFibGVkPSEwO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnVzZUdyaWQ9ITE7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUucGFubmluZ0VuYWJsZWQ9ITA7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUucGluY2hFbmFibGVkPSEwOwpteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tYXhTY2FsZT04O214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLm1pblNjYWxlPS4wMTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5keD1udWxsO214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLmR5PW51bGw7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuc3RhcnRYPTA7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuc3RhcnRZPTA7bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNBY3RpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hY3RpdmV8fG51bGwhPXRoaXMuaW5pdGlhbFNjYWxlfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pc1Bhbm5pbmdFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFubmluZ0VuYWJsZWR9O214UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLnNldFBhbm5pbmdFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMucGFubmluZ0VuYWJsZWQ9YX07Cm14UGFubmluZ0hhbmRsZXIucHJvdG90eXBlLmlzUGluY2hFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGluY2hFbmFibGVkfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5zZXRQaW5jaEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5waW5jaEVuYWJsZWQ9YX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNQYW5uaW5nVHJpZ2dlcj1mdW5jdGlvbihhKXt2YXIgYj1hLmdldEV2ZW50KCk7cmV0dXJuIHRoaXMudXNlTGVmdEJ1dHRvbkZvclBhbm5pbmcmJm51bGw9PWEuZ2V0U3RhdGUoKSYmbXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihiKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGIpJiZteEV2ZW50LmlzU2hpZnREb3duKGIpfHx0aGlzLnVzZVBvcHVwVHJpZ2dlciYmbXhFdmVudC5pc1BvcHVwVHJpZ2dlcihiKX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNGb3JjZVBhbm5pbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pZ25vcmVDZWxsfHxteEV2ZW50LmlzTXVsdGlUb3VjaEV2ZW50KGEuZ2V0RXZlbnQoKSl9OwpteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt0aGlzLm1vdXNlRG93bkV2ZW50PWI7IWIuaXNDb25zdW1lZCgpJiZ0aGlzLmlzUGFubmluZ0VuYWJsZWQoKSYmIXRoaXMuYWN0aXZlJiZ0aGlzLmlzUGFubmluZ1RyaWdnZXIoYikmJih0aGlzLnN0YXJ0KGIpLHRoaXMuY29uc3VtZVBhbm5pbmdUcmlnZ2VyKGIpKX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oYSl7dGhpcy5keDA9LXRoaXMuZ3JhcGguY29udGFpbmVyLnNjcm9sbExlZnQ7dGhpcy5keTA9LXRoaXMuZ3JhcGguY29udGFpbmVyLnNjcm9sbFRvcDt0aGlzLnN0YXJ0WD1hLmdldFgoKTt0aGlzLnN0YXJ0WT1hLmdldFkoKTt0aGlzLmR5PXRoaXMuZHg9bnVsbDt0aGlzLnBhbm5pbmdUcmlnZ2VyPSEwfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5jb25zdW1lUGFubmluZ1RyaWdnZXI9ZnVuY3Rpb24oYSl7YS5jb25zdW1lKCl9OwpteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXt0aGlzLmR4PWIuZ2V0WCgpLXRoaXMuc3RhcnRYO3RoaXMuZHk9Yi5nZXRZKCktdGhpcy5zdGFydFk7aWYodGhpcy5hY3RpdmUpdGhpcy5wcmV2aWV3RW5hYmxlZCYmKHRoaXMudXNlR3JpZCYmKHRoaXMuZHg9dGhpcy5ncmFwaC5zbmFwKHRoaXMuZHgpLHRoaXMuZHk9dGhpcy5ncmFwaC5zbmFwKHRoaXMuZHkpKSx0aGlzLmdyYXBoLnBhbkdyYXBoKHRoaXMuZHgrdGhpcy5keDAsdGhpcy5keSt0aGlzLmR5MCkpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuUEFOLCJldmVudCIsYikpO2Vsc2UgaWYodGhpcy5wYW5uaW5nVHJpZ2dlcil7dmFyIGM9dGhpcy5hY3RpdmU7dGhpcy5hY3RpdmU9TWF0aC5hYnModGhpcy5keCk+dGhpcy5ncmFwaC50b2xlcmFuY2V8fE1hdGguYWJzKHRoaXMuZHkpPnRoaXMuZ3JhcGgudG9sZXJhbmNlOyFjJiZ0aGlzLmFjdGl2ZSYmdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5QQU5fU1RBUlQsCiJldmVudCIsYikpfSh0aGlzLmFjdGl2ZXx8dGhpcy5wYW5uaW5nVHJpZ2dlcikmJmIuY29uc3VtZSgpfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5hY3RpdmUpe2lmKG51bGwhPXRoaXMuZHgmJm51bGwhPXRoaXMuZHkpe2lmKCF0aGlzLmdyYXBoLnVzZVNjcm9sbGJhcnNGb3JQYW5uaW5nfHwhbXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuZ3JhcGguY29udGFpbmVyKSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZD10aGlzLmdyYXBoLmdldFZpZXcoKS50cmFuc2xhdGU7dGhpcy5ncmFwaC5wYW5HcmFwaCgwLDApO3RoaXMucGFuR3JhcGgoZC54K3RoaXMuZHgvYyxkLnkrdGhpcy5keS9jKX1iLmNvbnN1bWUoKX10aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlBBTl9FTkQsImV2ZW50IixiKSl9dGhpcy5yZXNldCgpfTsKbXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuem9vbUdyYXBoPWZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgucm91bmQodGhpcy5pbml0aWFsU2NhbGUqYS5zY2FsZSoxMDApLzEwMDtudWxsIT10aGlzLm1pblNjYWxlJiYoYj1NYXRoLm1heCh0aGlzLm1pblNjYWxlLGIpKTtudWxsIT10aGlzLm1heFNjYWxlJiYoYj1NYXRoLm1pbih0aGlzLm1heFNjYWxlLGIpKTt0aGlzLmdyYXBoLnZpZXcuc2NhbGUhPWImJih0aGlzLmdyYXBoLnpvb21UbyhiKSxteEV2ZW50LmNvbnN1bWUoYSkpfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMucGFubmluZ1RyaWdnZXI9ITE7dGhpcy5tb3VzZURvd25FdmVudD1udWxsO3RoaXMuYWN0aXZlPSExO3RoaXMuZHk9dGhpcy5keD1udWxsfTtteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5wYW5HcmFwaD1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGguZ2V0VmlldygpLnNldFRyYW5zbGF0ZShhLGIpfTsKbXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuZm9yY2VQYW5uaW5nSGFuZGxlcik7dGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmdlc3R1cmVIYW5kbGVyKTtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCJtb3VzZXVwIix0aGlzLm1vdXNlVXBMaXN0ZW5lcil9OwpmdW5jdGlvbiBteFBvcHVwTWVudUhhbmRsZXIoYSxiKXtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZmFjdG9yeU1ldGhvZD1iLHRoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKSx0aGlzLmdlc3R1cmVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dGhpcy5pblRvbGVyYW5jZT0hMX0pLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5HRVNUVVJFLHRoaXMuZ2VzdHVyZUhhbmRsZXIpLHRoaXMuaW5pdCgpKX1teFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlPW5ldyBteFBvcHVwTWVudTtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPW14UG9wdXBNZW51SGFuZGxlcjtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5zZWxlY3RPblBvcHVwPSEwOwpteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uT25CYWNrZ3JvdW5kPSEwO214UG9wdXBNZW51SGFuZGxlci5wcm90b3R5cGUudHJpZ2dlclg9bnVsbDtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLnRyaWdnZXJZPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5zY3JlZW5YPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5zY3JlZW5ZPW51bGw7bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMuZGl2LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGgudG9vbHRpcEhhbmRsZXIuaGlkZSgpfSkpfTtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmlzU2VsZWN0T25Qb3B1cD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zZWxlY3RPblBvcHVwfTsKbXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt0aGlzLmlzRW5hYmxlZCgpJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpJiYodGhpcy5oaWRlTWVudSgpLHRoaXMudHJpZ2dlclg9Yi5nZXRHcmFwaFgoKSx0aGlzLnRyaWdnZXJZPWIuZ2V0R3JhcGhZKCksdGhpcy5zY3JlZW5YPW14RXZlbnQuZ2V0TWFpbkV2ZW50KGIuZ2V0RXZlbnQoKSkuc2NyZWVuWCx0aGlzLnNjcmVlblk9bXhFdmVudC5nZXRNYWluRXZlbnQoYi5nZXRFdmVudCgpKS5zY3JlZW5ZLHRoaXMucG9wdXBUcmlnZ2VyPXRoaXMuaXNQb3B1cFRyaWdnZXIoYiksdGhpcy5pblRvbGVyYW5jZT0hMCl9OwpteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe3RoaXMuaW5Ub2xlcmFuY2UmJm51bGwhPXRoaXMuc2NyZWVuWCYmbnVsbCE9dGhpcy5zY3JlZW5ZJiYoTWF0aC5hYnMobXhFdmVudC5nZXRNYWluRXZlbnQoYi5nZXRFdmVudCgpKS5zY3JlZW5YLXRoaXMuc2NyZWVuWCk+dGhpcy5ncmFwaC50b2xlcmFuY2V8fE1hdGguYWJzKG14RXZlbnQuZ2V0TWFpbkV2ZW50KGIuZ2V0RXZlbnQoKSkuc2NyZWVuWS10aGlzLnNjcmVlblkpPnRoaXMuZ3JhcGgudG9sZXJhbmNlKSYmKHRoaXMuaW5Ub2xlcmFuY2U9ITEpfTsKbXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5wb3B1cFRyaWdnZXImJnRoaXMuaW5Ub2xlcmFuY2UmJm51bGwhPXRoaXMudHJpZ2dlclgmJm51bGwhPXRoaXMudHJpZ2dlclkpe3ZhciBjPXRoaXMuZ2V0Q2VsbEZvclBvcHVwRXZlbnQoYik7dGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmdGhpcy5pc1NlbGVjdE9uUG9wdXAoYikmJm51bGwhPWMmJiF0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGMpP3RoaXMuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChjKTp0aGlzLmNsZWFyU2VsZWN0aW9uT25CYWNrZ3JvdW5kJiZudWxsPT1jJiZ0aGlzLmdyYXBoLmNsZWFyU2VsZWN0aW9uKCk7dGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlKCk7dmFyIGQ9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oKTt0aGlzLnBvcHVwKGIuZ2V0WCgpK2QueCsxLGIuZ2V0WSgpK2QueSsxLGMsYi5nZXRFdmVudCgpKTtiLmNvbnN1bWUoKX10aGlzLmluVG9sZXJhbmNlPQp0aGlzLnBvcHVwVHJpZ2dlcj0hMX07bXhQb3B1cE1lbnVIYW5kbGVyLnByb3RvdHlwZS5nZXRDZWxsRm9yUG9wdXBFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gYS5nZXRDZWxsKCl9O214UG9wdXBNZW51SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuZ2VzdHVyZUhhbmRsZXIpO214UG9wdXBNZW51LnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMpfTsKZnVuY3Rpb24gbXhDZWxsTWFya2VyKGEsYixjLGQpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMudmFsaWRDb2xvcj1udWxsIT1iP2I6bXhDb25zdGFudHMuREVGQVVMVF9WQUxJRF9DT0xPUix0aGlzLmludmFsaWRDb2xvcj1udWxsIT1jP2M6bXhDb25zdGFudHMuREVGQVVMVF9JTlZBTElEX0NPTE9SLHRoaXMuaG90c3BvdD1udWxsIT1kP2Q6bXhDb25zdGFudHMuREVGQVVMVF9IT1RTUE9ULHRoaXMuaGlnaGxpZ2h0PW5ldyBteENlbGxIaWdobGlnaHQoYSkpfW14VXRpbHMuZXh0ZW5kKG14Q2VsbE1hcmtlcixteEV2ZW50U291cmNlKTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhDZWxsTWFya2VyLnByb3RvdHlwZS5lbmFibGVkPSEwO214Q2VsbE1hcmtlci5wcm90b3R5cGUuaG90c3BvdD1teENvbnN0YW50cy5ERUZBVUxUX0hPVFNQT1Q7bXhDZWxsTWFya2VyLnByb3RvdHlwZS5ob3RzcG90RW5hYmxlZD0hMTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS52YWxpZENvbG9yPW51bGw7bXhDZWxsTWFya2VyLnByb3RvdHlwZS5pbnZhbGlkQ29sb3I9bnVsbDtteENlbGxNYXJrZXIucHJvdG90eXBlLmN1cnJlbnRDb2xvcj1udWxsO214Q2VsbE1hcmtlci5wcm90b3R5cGUudmFsaWRTdGF0ZT1udWxsO214Q2VsbE1hcmtlci5wcm90b3R5cGUubWFya2VkU3RhdGU9bnVsbDtteENlbGxNYXJrZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214Q2VsbE1hcmtlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5zZXRIb3RzcG90PWZ1bmN0aW9uKGEpe3RoaXMuaG90c3BvdD1hfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdldEhvdHNwb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob3RzcG90fTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS5zZXRIb3RzcG90RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmhvdHNwb3RFbmFibGVkPWF9O214Q2VsbE1hcmtlci5wcm90b3R5cGUuaXNIb3RzcG90RW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhvdHNwb3RFbmFibGVkfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmhhc1ZhbGlkU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy52YWxpZFN0YXRlfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdldFZhbGlkU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWxpZFN0YXRlfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmdldE1hcmtlZFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFya2VkU3RhdGV9O214Q2VsbE1hcmtlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnZhbGlkU3RhdGU9bnVsbDtudWxsIT10aGlzLm1hcmtlZFN0YXRlJiYodGhpcy5tYXJrZWRTdGF0ZT1udWxsLHRoaXMudW5tYXJrKCkpfTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7dGhpcy5pc0VuYWJsZWQoKSYmKGI9dGhpcy5nZXRTdGF0ZShhKSx0aGlzLnNldEN1cnJlbnRTdGF0ZShiLGEpKTtyZXR1cm4gYn07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5zZXRDdXJyZW50U3RhdGU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW51bGwhPWE/dGhpcy5pc1ZhbGlkU3RhdGUoYSk6ITE7Yz1udWxsIT1jP2M6dGhpcy5nZXRNYXJrZXJDb2xvcihiLmdldEV2ZW50KCksYSxkKTt0aGlzLnZhbGlkU3RhdGU9ZD9hOm51bGw7aWYoYSE9dGhpcy5tYXJrZWRTdGF0ZXx8YyE9dGhpcy5jdXJyZW50Q29sb3IpdGhpcy5jdXJyZW50Q29sb3I9YyxudWxsIT1hJiZudWxsIT10aGlzLmN1cnJlbnRDb2xvcj8odGhpcy5tYXJrZWRTdGF0ZT1hLHRoaXMubWFyaygpKTpudWxsIT10aGlzLm1hcmtlZFN0YXRlJiYodGhpcy5tYXJrZWRTdGF0ZT1udWxsLHRoaXMudW5tYXJrKCkpfTsKbXhDZWxsTWFya2VyLnByb3RvdHlwZS5tYXJrQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGEpO251bGwhPWMmJih0aGlzLmN1cnJlbnRDb2xvcj1udWxsIT1iP2I6dGhpcy52YWxpZENvbG9yLHRoaXMubWFya2VkU3RhdGU9Yyx0aGlzLm1hcmsoKSl9O214Q2VsbE1hcmtlci5wcm90b3R5cGUubWFyaz1mdW5jdGlvbigpe3RoaXMuaGlnaGxpZ2h0LnNldEhpZ2hsaWdodENvbG9yKHRoaXMuY3VycmVudENvbG9yKTt0aGlzLmhpZ2hsaWdodC5oaWdobGlnaHQodGhpcy5tYXJrZWRTdGF0ZSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5NQVJLLCJzdGF0ZSIsdGhpcy5tYXJrZWRTdGF0ZSkpfTtteENlbGxNYXJrZXIucHJvdG90eXBlLnVubWFyaz1mdW5jdGlvbigpe3RoaXMubWFyaygpfTtteENlbGxNYXJrZXIucHJvdG90eXBlLmlzVmFsaWRTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4hMH07Cm14Q2VsbE1hcmtlci5wcm90b3R5cGUuZ2V0TWFya2VyQ29sb3I9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjP3RoaXMudmFsaWRDb2xvcjp0aGlzLmludmFsaWRDb2xvcn07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldFZpZXcoKSxjPXRoaXMuZ2V0Q2VsbChhKSxiPXRoaXMuZ2V0U3RhdGVUb01hcmsoYi5nZXRTdGF0ZShjKSk7cmV0dXJuIG51bGwhPWImJnRoaXMuaW50ZXJzZWN0cyhiLGEpP2I6bnVsbH07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRDZWxsPWZ1bmN0aW9uKGEpe3JldHVybiBhLmdldENlbGwoKX07bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRTdGF0ZVRvTWFyaz1mdW5jdGlvbihhKXtyZXR1cm4gYX07Cm14Q2VsbE1hcmtlci5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmhvdHNwb3RFbmFibGVkP214VXRpbHMuaW50ZXJzZWN0c0hvdHNwb3QoYSxiLmdldEdyYXBoWCgpLGIuZ2V0R3JhcGhZKCksdGhpcy5ob3RzcG90LG14Q29uc3RhbnRzLk1JTl9IT1RTUE9UX1NJWkUsbXhDb25zdGFudHMuTUFYX0hPVFNQT1RfU0laRSk6ITB9O214Q2VsbE1hcmtlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGguZ2V0VmlldygpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVzZXRIYW5kbGVyKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuaGlnaGxpZ2h0LmRlc3Ryb3koKX07CmZ1bmN0aW9uIG14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyKGEpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTt0aGlzLmdyYXBoPWE7dGhpcy5oYW5kbGVycz1uZXcgbXhEaWN0aW9uYXJ5O3RoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKTt0aGlzLnJlZnJlc2hIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5yZWZyZXNoKCl9KTt0aGlzLmdyYXBoLmdldFNlbGVjdGlvbk1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMucmVmcmVzaEhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEUsdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5UUkFOU0xBVEUsdGhpcy5yZWZyZXNoSGFuZGxlcik7CnRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEVfQU5EX1RSQU5TTEFURSx0aGlzLnJlZnJlc2hIYW5kbGVyKTt0aGlzLmdyYXBoLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPV04sdGhpcy5yZWZyZXNoSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VUCx0aGlzLnJlZnJlc2hIYW5kbGVyKX1teFV0aWxzLmV4dGVuZChteFNlbGVjdGlvbkNlbGxzSGFuZGxlcixteEV2ZW50U291cmNlKTtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUucmVmcmVzaEhhbmRsZXI9bnVsbDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUubWF4SGFuZGxlcnM9MTAwOwpteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlcnM9bnVsbDtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVyPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmhhbmRsZXJzLmdldChhKX07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmlzSGFuZGxlZD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRIYW5kbGVyKGEpfTtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmhhbmRsZXJzLnZpc2l0KGZ1bmN0aW9uKGEsYil7Yi5yZXNldC5hcHBseShiKX0pfTsKbXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNlbGxzKCl9OwpteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuaGFuZGxlcnM7dGhpcy5oYW5kbGVycz1uZXcgbXhEaWN0aW9uYXJ5O2Zvcih2YXIgYj1teFV0aWxzLnNvcnRDZWxscyh0aGlzLmdldEhhbmRsZWRTZWxlY3Rpb25DZWxscygpLCExKSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShiW2NdKTtpZihudWxsIT1kKXt2YXIgZT1hLnJlbW92ZShiW2NdKTtudWxsIT1lJiYoZS5zdGF0ZSE9ZD8oZS5kZXN0cm95KCksZT1udWxsKTp0aGlzLmlzSGFuZGxlckFjdGl2ZShlKXx8KG51bGwhPWUucmVmcmVzaCYmZS5yZWZyZXNoKCksZS5yZWRyYXcoKSkpO251bGw9PWUmJihlPXRoaXMuZ3JhcGguY3JlYXRlSGFuZGxlcihkKSx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkFERCwic3RhdGUiLGQpKSk7bnVsbCE9ZSYmdGhpcy5oYW5kbGVycy5wdXQoYltjXSxlKX19YS52aXNpdChteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxiKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFTU9WRSwic3RhdGUiLGIuc3RhdGUpKTtiLmRlc3Ryb3koKX0pKX07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLmlzSGFuZGxlckFjdGl2ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS5pbmRleH07bXhTZWxlY3Rpb25DZWxsc0hhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5oYW5kbGVycy5yZW1vdmUoYS5jZWxsKTtpZihudWxsIT1iKXt2YXIgYz1iLmluZGV4LGQ9Yi5zdGFydFgsZT1iLnN0YXJ0WTtiLmRlc3Ryb3koKTtiPXRoaXMuZ3JhcGguY3JlYXRlSGFuZGxlcihhKTtudWxsIT1iJiYodGhpcy5oYW5kbGVycy5wdXQoYS5jZWxsLGIpLG51bGwhPWMmJm51bGwhPWQmJm51bGwhPWUmJmIuc3RhcnQoZCxlLGMpKX19OwpteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSl7dmFyIGM9W2EsYl07dGhpcy5oYW5kbGVycy52aXNpdChmdW5jdGlvbihhLGIpe2IubW91c2VEb3duLmFwcGx5KGIsYyl9KX19O214U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZ0aGlzLmlzRW5hYmxlZCgpKXt2YXIgYz1bYSxiXTt0aGlzLmhhbmRsZXJzLnZpc2l0KGZ1bmN0aW9uKGEsYil7Yi5tb3VzZU1vdmUuYXBwbHkoYixjKX0pfX07Cm14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSl7dmFyIGM9W2EsYl07dGhpcy5oYW5kbGVycy52aXNpdChmdW5jdGlvbihhLGIpe2IubW91c2VVcC5hcHBseShiLGMpfSl9fTtteFNlbGVjdGlvbkNlbGxzSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTtudWxsIT10aGlzLnJlZnJlc2hIYW5kbGVyJiYodGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Nb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaEhhbmRsZXIpLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlZnJlc2hIYW5kbGVyKSx0aGlzLnJlZnJlc2hIYW5kbGVyPW51bGwpfTsKZnVuY3Rpb24gbXhDb25uZWN0aW9uSGFuZGxlcihhLGIpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZmFjdG9yeU1ldGhvZD1iLHRoaXMuaW5pdCgpLHRoaXMuZXNjYXBlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3RoaXMucmVzZXQoKX0pLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FU0NBUEUsdGhpcy5lc2NhcGVIYW5kbGVyKSl9bXhVdGlscy5leHRlbmQobXhDb25uZWN0aW9uSGFuZGxlcixteEV2ZW50U291cmNlKTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5ncmFwaD1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmZhY3RvcnlNZXRob2Q9ITA7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUubW92ZUljb25Gcm9udD0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5tb3ZlSWNvbkJhY2s9ITE7Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3RJbWFnZT1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnRhcmdldENvbm5lY3RJbWFnZT0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5lbmFibGVkPSEwO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnNlbGVjdD0hMDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVUYXJnZXQ9ITE7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUubWFya2VyPW51bGw7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29uc3RyYWludEhhbmRsZXI9bnVsbDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5lcnJvcj1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLndheXBvaW50c0VuYWJsZWQ9ITE7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaWdub3JlTW91c2VEb3duPSExO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmZpcnN0PW51bGw7Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3RJY29uT2Zmc2V0PW5ldyBteFBvaW50KDAsbXhDb25zdGFudHMuVE9PTFRJUF9WRVJUSUNBTF9PRkZTRVQpO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmVkZ2VTdGF0ZT1udWxsO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNoYW5nZUhhbmRsZXI9bnVsbDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5kcmlsbEhhbmRsZXI9bnVsbDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd25Db3VudGVyPTA7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUubW92ZVByZXZpZXdBd2F5PW14Q2xpZW50LklTX1ZNTDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5vdXRsaW5lQ29ubmVjdD0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5saXZlUHJldmlldz0hMTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jdXJzb3I9bnVsbDsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlU291cmNlPSExO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzSW5zZXJ0QmVmb3JlPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlU291cmNlJiZiIT1jfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc0NyZWF0ZVRhcmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jcmVhdGVUYXJnZXR9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnNldENyZWF0ZVRhcmdldD1mdW5jdGlvbihhKXt0aGlzLmNyZWF0ZVRhcmdldD1hfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2hhcGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxpdmVQcmV2aWV3JiZudWxsIT10aGlzLmVkZ2VTdGF0ZT90aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5jcmVhdGVTaGFwZSh0aGlzLmVkZ2VTdGF0ZSk6bmV3IG14UG9seWxpbmUoW10sbXhDb25zdGFudHMuSU5WQUxJRF9DT0xPUik7YS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkc7YS5zY2FsZT10aGlzLmdyYXBoLnZpZXcuc2NhbGU7YS5wb2ludGVyRXZlbnRzPSExO2EuaXNEYXNoZWQ9ITA7YS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpO214RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyhhLm5vZGUsdGhpcy5ncmFwaCxudWxsKTtyZXR1cm4gYX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIodGhpcyk7dGhpcy5tYXJrZXI9dGhpcy5jcmVhdGVNYXJrZXIoKTt0aGlzLmNvbnN0cmFpbnRIYW5kbGVyPW5ldyBteENvbnN0cmFpbnRIYW5kbGVyKHRoaXMuZ3JhcGgpO3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT10aGlzLmljb25TdGF0ZSYmKHRoaXMuaWNvblN0YXRlPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKHRoaXMuaWNvblN0YXRlLmNlbGwpKTtudWxsIT10aGlzLmljb25TdGF0ZT8odGhpcy5yZWRyYXdJY29ucyh0aGlzLmljb25zLHRoaXMuaWNvblN0YXRlKSx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLnJlc2V0KCkpOm51bGwhPXRoaXMucHJldmlvdXMmJm51bGw9PXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLnByZXZpb3VzLmNlbGwpJiZ0aGlzLnJlc2V0KCl9KTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsCnRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRSx0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuVFJBTlNMQVRFLHRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLHRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5kcmlsbEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5yZXNldCgpfSk7dGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LlNUQVJUX0VESVRJTkcsdGhpcy5kcmlsbEhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuRE9XTix0aGlzLmRyaWxsSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VUCx0aGlzLmRyaWxsSGFuZGxlcil9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4hMH07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlcj1mdW5jdGlvbigpe3ZhciBhPW5ldyBteENlbGxNYXJrZXIodGhpcy5ncmFwaCk7YS5ob3RzcG90RW5hYmxlZD0hMDthLmdldENlbGw9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dmFyIGM9bXhDZWxsTWFya2VyLnByb3RvdHlwZS5nZXRDZWxsLmFwcGx5KGEsYXJndW1lbnRzKTt0aGlzLmVycm9yPW51bGw7bnVsbD09YyYmbnVsbCE9dGhpcy5jdXJyZW50UG9pbnQmJihjPXRoaXMuZ3JhcGguZ2V0Q2VsbEF0KHRoaXMuY3VycmVudFBvaW50LngsdGhpcy5jdXJyZW50UG9pbnQueSkpO2lmKG51bGwhPWMmJiF0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGMpKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGMpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChkKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShkKSYmKGM9ZCl9aWYodGhpcy5ncmFwaC5pc1N3aW1sYW5lKGMpJiYKbnVsbCE9dGhpcy5jdXJyZW50UG9pbnQmJnRoaXMuZ3JhcGguaGl0c1N3aW1sYW5lQ29udGVudChjLHRoaXMuY3VycmVudFBvaW50LngsdGhpcy5jdXJyZW50UG9pbnQueSl8fCF0aGlzLmlzQ29ubmVjdGFibGVDZWxsKGMpKWM9bnVsbDtudWxsIT1jP3RoaXMuaXNDb25uZWN0aW5nKCk/bnVsbCE9dGhpcy5wcmV2aW91cyYmKHRoaXMuZXJyb3I9dGhpcy52YWxpZGF0ZUNvbm5lY3Rpb24odGhpcy5wcmV2aW91cy5jZWxsLGMpLG51bGwhPXRoaXMuZXJyb3ImJjA9PXRoaXMuZXJyb3IubGVuZ3RoJiYoYz1udWxsLHRoaXMuaXNDcmVhdGVUYXJnZXQoYi5nZXRFdmVudCgpKSYmKHRoaXMuZXJyb3I9bnVsbCkpKTp0aGlzLmlzVmFsaWRTb3VyY2UoYyxiKXx8KGM9bnVsbCk6IXRoaXMuaXNDb25uZWN0aW5nKCl8fHRoaXMuaXNDcmVhdGVUYXJnZXQoYi5nZXRFdmVudCgpKXx8dGhpcy5ncmFwaC5hbGxvd0RhbmdsaW5nRWRnZXN8fCh0aGlzLmVycm9yPSIiKTtyZXR1cm4gY30pO2EuaXNWYWxpZFN0YXRlPQpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5pc0Nvbm5lY3RpbmcoKT9udWxsPT10aGlzLmVycm9yOm14Q2VsbE1hcmtlci5wcm90b3R5cGUuaXNWYWxpZFN0YXRlLmFwcGx5KGEsYXJndW1lbnRzKX0pO2EuZ2V0TWFya2VyQ29sb3I9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixjLGQpe3JldHVybiBudWxsPT10aGlzLmNvbm5lY3RJbWFnZXx8dGhpcy5pc0Nvbm5lY3RpbmcoKT9teENlbGxNYXJrZXIucHJvdG90eXBlLmdldE1hcmtlckNvbG9yLmFwcGx5KGEsYXJndW1lbnRzKTpudWxsfSk7YS5pbnRlcnNlY3RzPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7cmV0dXJuIG51bGwhPXRoaXMuY29ubmVjdEltYWdlfHx0aGlzLmlzQ29ubmVjdGluZygpPyEwOm14Q2VsbE1hcmtlci5wcm90b3R5cGUuaW50ZXJzZWN0cy5hcHBseShhLGFyZ3VtZW50cyl9KTtyZXR1cm4gYX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMucHJldmlvdXM9YTt0aGlzLmZpcnN0PW5ldyBteFBvaW50KGIsYyk7dGhpcy5lZGdlU3RhdGU9bnVsbCE9ZD9kOnRoaXMuY3JlYXRlRWRnZVN0YXRlKG51bGwpO3RoaXMubWFya2VyLmN1cnJlbnRDb2xvcj10aGlzLm1hcmtlci52YWxpZENvbG9yO3RoaXMubWFya2VyLm1hcmtlZFN0YXRlPWE7dGhpcy5tYXJrZXIubWFyaygpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU1RBUlQsInN0YXRlIix0aGlzLnByZXZpb3VzKSl9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzQ29ubmVjdGluZz1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmZpcnN0JiZudWxsIT10aGlzLnNoYXBlfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc1ZhbGlkU291cmNlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ3JhcGguaXNWYWxpZFNvdXJjZShhKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmlzVmFsaWRUYXJnZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnZhbGlkYXRlQ29ubmVjdGlvbj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmlzVmFsaWRUYXJnZXQoYik/dGhpcy5ncmFwaC5nZXRFZGdlVmFsaWRhdGlvbkVycm9yKG51bGwsYSxiKToiIn07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0Q29ubmVjdEltYWdlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNvbm5lY3RJbWFnZX07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNNb3ZlSWNvblRvRnJvbnRGb3JTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS50ZXh0JiZhLnRleHQubm9kZS5wYXJlbnROb2RlPT10aGlzLmdyYXBoLmNvbnRhaW5lcj8hMDp0aGlzLm1vdmVJY29uRnJvbnR9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVJY29ucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldENvbm5lY3RJbWFnZShhKTtpZihudWxsIT1iJiZudWxsIT1hKXt0aGlzLmljb25TdGF0ZT1hO3ZhciBjPVtdLGQ9bmV3IG14UmVjdGFuZ2xlKDAsMCxiLndpZHRoLGIuaGVpZ2h0KSxlPW5ldyBteEltYWdlU2hhcGUoZCxiLnNyYyxudWxsLG51bGwsMCk7ZS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExO3RoaXMuaXNNb3ZlSWNvblRvRnJvbnRGb3JTdGF0ZShhKT8oZS5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxlLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooZS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9TVkc6bXhDb25zdGFudHMuRElBTEVDVF9WTUwsZS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpLHRoaXMubW92ZUljb25CYWNrJiYKbnVsbCE9ZS5ub2RlLnByZXZpb3VzU2libGluZyYmZS5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUubm9kZSxlLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKSk7ZS5ub2RlLnN0eWxlLmN1cnNvcj1teENvbnN0YW50cy5DVVJTT1JfQ09OTkVDVDt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRTdGF0ZT90aGlzLmN1cnJlbnRTdGF0ZTphfSksYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmlzQ29uc3VtZWQoYSl8fCh0aGlzLmljb249ZSx0aGlzLmdyYXBoLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGEsZigpKSkpfSk7bXhFdmVudC5yZWRpcmVjdE1vdXNlRXZlbnRzKGUubm9kZSx0aGlzLmdyYXBoLGYsYik7Yy5wdXNoKGUpO3RoaXMucmVkcmF3SWNvbnMoYyx0aGlzLmljb25TdGF0ZSk7cmV0dXJuIGN9cmV0dXJuIG51bGx9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdJY29ucz1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEmJm51bGwhPWFbMF0mJm51bGwhPWIpe3ZhciBjPXRoaXMuZ2V0SWNvblBvc2l0aW9uKGFbMF0sYik7YVswXS5ib3VuZHMueD1jLng7YVswXS5ib3VuZHMueT1jLnk7YVswXS5yZWRyYXcoKX19OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5nZXRJY29uUG9zaXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxkPWIuZ2V0Q2VudGVyWCgpLGU9Yi5nZXRDZW50ZXJZKCk7aWYodGhpcy5ncmFwaC5pc1N3aW1sYW5lKGIuY2VsbCkpe3ZhciBmPXRoaXMuZ3JhcGguZ2V0U3RhcnRTaXplKGIuY2VsbCksZD0wIT1mLndpZHRoP2IueCtmLndpZHRoKmMvMjpkLGU9MCE9Zi5oZWlnaHQ/Yi55K2YuaGVpZ2h0KmMvMjplLGY9bXhVdGlscy50b1JhZGlhbnMobXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OKXx8MCk7aWYoMCE9Zil2YXIgYz1NYXRoLmNvcyhmKSxmPU1hdGguc2luKGYpLGc9bmV3IG14UG9pbnQoYi5nZXRDZW50ZXJYKCksYi5nZXRDZW50ZXJZKCkpLGU9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoZCxlKSxjLGYsZyksZD1lLngsZT1lLnl9cmV0dXJuIG5ldyBteFBvaW50KGQtCmEuYm91bmRzLndpZHRoLzIsZS1hLmJvdW5kcy5oZWlnaHQvMil9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3lJY29ucz1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuaWNvbnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5pY29ucy5sZW5ndGg7YSsrKXRoaXMuaWNvbnNbYV0uZGVzdHJveSgpO3RoaXMuaWNvblN0YXRlPXRoaXMuc2VsZWN0ZWRJY29uPXRoaXMuaWNvbj10aGlzLmljb25zPW51bGx9fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc1N0YXJ0RXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50fHxudWxsIT10aGlzLnByZXZpb3VzJiZudWxsPT10aGlzLmVycm9yJiYobnVsbD09dGhpcy5pY29uc3x8bnVsbCE9dGhpcy5pY29ucyYmbnVsbCE9dGhpcy5pY29uKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe3RoaXMubW91c2VEb3duQ291bnRlcisrO2lmKHRoaXMuaXNFbmFibGVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkmJiFiLmlzQ29uc3VtZWQoKSYmIXRoaXMuaXNDb25uZWN0aW5nKCkmJnRoaXMuaXNTdGFydEV2ZW50KGIpKXtudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50JiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyYmbnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50UG9pbnQ/KHRoaXMuc291cmNlQ29uc3RyYWludD10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50LHRoaXMucHJldmlvdXM9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMsdGhpcy5maXJzdD10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludC5jbG9uZSgpKTp0aGlzLmZpcnN0PW5ldyBteFBvaW50KGIuZ2V0R3JhcGhYKCksCmIuZ2V0R3JhcGhZKCkpO3RoaXMuZWRnZVN0YXRlPXRoaXMuY3JlYXRlRWRnZVN0YXRlKGIpO3RoaXMubW91c2VEb3duQ291bnRlcj0xO3RoaXMud2F5cG9pbnRzRW5hYmxlZCYmbnVsbD09dGhpcy5zaGFwZSYmKHRoaXMud2F5cG9pbnRzPW51bGwsdGhpcy5zaGFwZT10aGlzLmNyZWF0ZVNoYXBlKCksbnVsbCE9dGhpcy5lZGdlU3RhdGUmJnRoaXMuc2hhcGUuYXBwbHkodGhpcy5lZGdlU3RhdGUpKTtpZihudWxsPT10aGlzLnByZXZpb3VzJiZudWxsIT10aGlzLmVkZ2VTdGF0ZSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRQb2ludEZvckV2ZW50KGIuZ2V0RXZlbnQoKSk7dGhpcy5lZGdlU3RhdGUuY2VsbC5nZW9tZXRyeS5zZXRUZXJtaW5hbFBvaW50KGMsITApfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU1RBUlQsInN0YXRlIix0aGlzLnByZXZpb3VzKSk7Yi5jb25zdW1lKCl9dGhpcy5zZWxlY3RlZEljb249dGhpcy5pY29uO3RoaXMuaWNvbj1udWxsfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNJbW1lZGlhdGVDb25uZWN0U291cmNlPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdyYXBoLmlzQ2VsbE1vdmFibGUoYS5jZWxsKX07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWRnZVN0YXRlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNPdXRsaW5lQ29ubmVjdEV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKSxjPWEuZ2V0RXZlbnQoKSxkPW14RXZlbnQuZ2V0Q2xpZW50WChjKSxjPW14RXZlbnQuZ2V0Q2xpZW50WShjKSxlPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxmPXRoaXMuY3VycmVudFBvaW50LngtdGhpcy5ncmFwaC5jb250YWluZXIuc2Nyb2xsTGVmdCtiLngtKCh3aW5kb3cucGFnZVhPZmZzZXR8fGUuc2Nyb2xsTGVmdCktKGUuY2xpZW50TGVmdHx8MCkpLGI9dGhpcy5jdXJyZW50UG9pbnQueS10aGlzLmdyYXBoLmNvbnRhaW5lci5zY3JvbGxUb3ArYi55LSgod2luZG93LnBhZ2VZT2Zmc2V0fHxlLnNjcm9sbFRvcCktKGUuY2xpZW50VG9wfHwwKSk7cmV0dXJuIHRoaXMub3V0bGluZUNvbm5lY3QmJiFteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSkmJihhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSl8fApteEV2ZW50LmlzQWx0RG93bihhLmdldEV2ZW50KCkpJiZudWxsIT1hLmdldFN0YXRlKCl8fHRoaXMubWFya2VyLmhpZ2hsaWdodC5pc0hpZ2hsaWdodEF0KGQsYyl8fChmIT1kfHxiIT1jKSYmbnVsbD09YS5nZXRTdGF0ZSgpJiZ0aGlzLm1hcmtlci5oaWdobGlnaHQuaXNIaWdobGlnaHRBdChmLGIpKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUN1cnJlbnRTdGF0ZT1mdW5jdGlvbihhLGIpe3RoaXMuY29uc3RyYWludEhhbmRsZXIudXBkYXRlKGEsbnVsbD09dGhpcy5maXJzdCwhMSxudWxsPT10aGlzLmZpcnN0fHxhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSk/bnVsbDpiKTtpZihudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyYmbnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCludWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zdGF0ZSYmdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnN0YXRlLmNlbGw9PXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzLmNlbGw/InRyYW5zcGFyZW50IiE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZSYmKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2U9InRyYW5zcGFyZW50IiwKdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnJlcGFpbnQoKSk6dGhpcy5tYXJrZXIubWFya0NlbGwodGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCwidHJhbnNwYXJlbnQiKSxudWxsIT10aGlzLnByZXZpb3VzJiYodGhpcy5lcnJvcj10aGlzLnZhbGlkYXRlQ29ubmVjdGlvbih0aGlzLnByZXZpb3VzLmNlbGwsdGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCksbnVsbD09dGhpcy5lcnJvciYmKHRoaXMuY3VycmVudFN0YXRlPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzKSwobnVsbCE9dGhpcy5lcnJvcnx8bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJiF0aGlzLmlzQ2VsbEVuYWJsZWQodGhpcy5jdXJyZW50U3RhdGUuY2VsbCkpJiZ0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLnJlc2V0KCkpO2Vsc2V7dGhpcy5ncmFwaC5pc0lnbm9yZVRlcm1pbmFsRXZlbnQoYS5nZXRFdmVudCgpKT8odGhpcy5tYXJrZXIucmVzZXQoKSx0aGlzLmN1cnJlbnRTdGF0ZT0KbnVsbCk6KHRoaXMubWFya2VyLnByb2Nlc3MoYSksdGhpcy5jdXJyZW50U3RhdGU9dGhpcy5tYXJrZXIuZ2V0VmFsaWRTdGF0ZSgpKTtudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8dGhpcy5pc0NlbGxFbmFibGVkKHRoaXMuY3VycmVudFN0YXRlLmNlbGwpfHwodGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpLHRoaXMubWFya2VyLnJlc2V0KCksdGhpcy5jdXJyZW50U3RhdGU9bnVsbCk7dmFyIGM9dGhpcy5pc091dGxpbmVDb25uZWN0RXZlbnQoYSk7bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJmMmJihhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSkmJihiPW5ldyBteFBvaW50KGEuZ2V0R3JhcGhYKCksYS5nZXRHcmFwaFkoKSkpLGM9dGhpcy5ncmFwaC5nZXRPdXRsaW5lQ29uc3RyYWludChiLHRoaXMuY3VycmVudFN0YXRlLGEpLHRoaXMuY29uc3RyYWludEhhbmRsZXIuc2V0Rm9jdXMoYSx0aGlzLmN1cnJlbnRTdGF0ZSwhMSksdGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludD0KYyx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludD1iKTt0aGlzLm91dGxpbmVDb25uZWN0JiZudWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSYmKGM9dGhpcy5ncmFwaC52aWV3LnNjYWxlLG51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzPyh0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlPW14Q29uc3RhbnRzLk9VVExJTkVfSElHSExJR0hUX0NPTE9SLHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2V3aWR0aD1teENvbnN0YW50cy5PVVRMSU5FX0hJR0hMSUdIVF9TVFJPS0VXSURUSC9jL2MsdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnJlcGFpbnQoKSk6dGhpcy5tYXJrZXIuaGFzVmFsaWRTdGF0ZSgpJiYodGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShhLmdldENlbGwoKSkmJgp0aGlzLm1hcmtlci5nZXRWYWxpZFN0YXRlKCkhPWEuZ2V0U3RhdGUoKT8odGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZT0idHJhbnNwYXJlbnQiLHRoaXMuY3VycmVudFN0YXRlPW51bGwpOnRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZS5zdHJva2U9bXhDb25zdGFudHMuREVGQVVMVF9WQUxJRF9DT0xPUix0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tld2lkdGg9bXhDb25zdGFudHMuSElHSExJR0hUX1NUUk9LRVdJRFRIL2MvYyx0aGlzLm1hcmtlci5oaWdobGlnaHQucmVwYWludCgpKSl9fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc0NlbGxFbmFibGVkPWZ1bmN0aW9uKGEpe3JldHVybiEwfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29udmVydFdheXBvaW50PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFNjYWxlKCksYz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRUcmFuc2xhdGUoKTthLng9YS54L2ItYy54O2EueT1hLnkvYi1jLnl9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9QcmV2aWV3PWZ1bmN0aW9uKGEsYil7aWYoIW14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSkmJm51bGwhPXRoaXMucHJldmlvdXMpe3ZhciBjPXRoaXMuZ3JhcGguZ3JpZFNpemUqdGhpcy5ncmFwaC52aWV3LnNjYWxlLzIsZD1udWxsIT10aGlzLnNvdXJjZUNvbnN0cmFpbnQ/dGhpcy5maXJzdDpuZXcgbXhQb2ludCh0aGlzLnByZXZpb3VzLmdldENlbnRlclgoKSx0aGlzLnByZXZpb3VzLmdldENlbnRlclkoKSk7TWF0aC5hYnMoZC54LWEuZ2V0R3JhcGhYKCkpPGMmJihiLng9ZC54KTtNYXRoLmFicyhkLnktYS5nZXRHcmFwaFkoKSk8YyYmKGIueT1kLnkpfX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2lmKGIuaXNDb25zdW1lZCgpfHwhdGhpcy5pZ25vcmVNb3VzZURvd24mJm51bGw9PXRoaXMuZmlyc3QmJnRoaXMuZ3JhcGguaXNNb3VzZURvd24pdGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpO2Vsc2V7dGhpcy5pc0VuYWJsZWQoKXx8bnVsbD09dGhpcy5jdXJyZW50U3RhdGV8fCh0aGlzLmRlc3Ryb3lJY29ucygpLHRoaXMuY3VycmVudFN0YXRlPW51bGwpO3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLGQ9Yy5zY2FsZSxlPWMudHJhbnNsYXRlLGM9bmV3IG14UG9pbnQoYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpKTt0aGlzLmVycm9yPW51bGw7dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYi5nZXRFdmVudCgpKSYmKGM9bmV3IG14UG9pbnQoKHRoaXMuZ3JhcGguc25hcChjLngvZC1lLngpK2UueCkqZCwodGhpcy5ncmFwaC5zbmFwKGMueS9kLWUueSkrZS55KSpkKSk7CnRoaXMuc25hcFRvUHJldmlldyhiLGMpO3RoaXMuY3VycmVudFBvaW50PWM7KG51bGwhPXRoaXMuZmlyc3R8fHRoaXMuaXNFbmFibGVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkpJiYobnVsbCE9dGhpcy5zaGFwZXx8bnVsbD09dGhpcy5maXJzdHx8TWF0aC5hYnMoYi5nZXRHcmFwaFgoKS10aGlzLmZpcnN0LngpPnRoaXMuZ3JhcGgudG9sZXJhbmNlfHxNYXRoLmFicyhiLmdldEdyYXBoWSgpLXRoaXMuZmlyc3QueSk+dGhpcy5ncmFwaC50b2xlcmFuY2UpJiZ0aGlzLnVwZGF0ZUN1cnJlbnRTdGF0ZShiLGMpO2lmKG51bGwhPXRoaXMuZmlyc3Qpe3ZhciBmPW51bGwsZD1jO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludD8oZj10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50LApkPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudFBvaW50LmNsb25lKCkpOm51bGwhPXRoaXMucHJldmlvdXMmJiF0aGlzLmdyYXBoLmlzSWdub3JlVGVybWluYWxFdmVudChiLmdldEV2ZW50KCkpJiZteEV2ZW50LmlzU2hpZnREb3duKGIuZ2V0RXZlbnQoKSkmJihNYXRoLmFicyh0aGlzLnByZXZpb3VzLmdldENlbnRlclgoKS1jLngpPE1hdGguYWJzKHRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWSgpLWMueSk/Yy54PXRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWCgpOmMueT10aGlzLnByZXZpb3VzLmdldENlbnRlclkoKSk7ZT10aGlzLmZpcnN0O2lmKG51bGwhPXRoaXMuc2VsZWN0ZWRJY29uKXt2YXIgZz10aGlzLnNlbGVjdGVkSWNvbi5ib3VuZHMud2lkdGgsaz10aGlzLnNlbGVjdGVkSWNvbi5ib3VuZHMuaGVpZ2h0O251bGwhPXRoaXMuY3VycmVudFN0YXRlJiZ0aGlzLnRhcmdldENvbm5lY3RJbWFnZT8oZz10aGlzLmdldEljb25Qb3NpdGlvbih0aGlzLnNlbGVjdGVkSWNvbiwKdGhpcy5jdXJyZW50U3RhdGUpLHRoaXMuc2VsZWN0ZWRJY29uLmJvdW5kcy54PWcueCx0aGlzLnNlbGVjdGVkSWNvbi5ib3VuZHMueT1nLnkpOihnPW5ldyBteFJlY3RhbmdsZShiLmdldEdyYXBoWCgpK3RoaXMuY29ubmVjdEljb25PZmZzZXQueCxiLmdldEdyYXBoWSgpK3RoaXMuY29ubmVjdEljb25PZmZzZXQueSxnLGspLHRoaXMuc2VsZWN0ZWRJY29uLmJvdW5kcz1nKTt0aGlzLnNlbGVjdGVkSWNvbi5yZWRyYXcoKX1udWxsIT10aGlzLmVkZ2VTdGF0ZT8odGhpcy51cGRhdGVFZGdlU3RhdGUoZCxmKSxkPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzW3RoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzLmxlbmd0aC0xXSxlPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzWzBdKToobnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJm51bGw9PXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJihnPXRoaXMuZ2V0VGFyZ2V0UGVyaW1ldGVyUG9pbnQodGhpcy5jdXJyZW50U3RhdGUsCmIpLG51bGwhPWcmJihkPWcpKSxudWxsPT10aGlzLnNvdXJjZUNvbnN0cmFpbnQmJm51bGwhPXRoaXMucHJldmlvdXMmJihnPXRoaXMuZ2V0U291cmNlUGVyaW1ldGVyUG9pbnQodGhpcy5wcmV2aW91cyxudWxsIT10aGlzLndheXBvaW50cyYmMDx0aGlzLndheXBvaW50cy5sZW5ndGg/dGhpcy53YXlwb2ludHNbMF06ZCxiKSxudWxsIT1nJiYoZT1nKSkpO2lmKG51bGw9PXRoaXMuY3VycmVudFN0YXRlJiZ0aGlzLm1vdmVQcmV2aWV3QXdheSl7Zz1lO251bGwhPXRoaXMuZWRnZVN0YXRlJiYyPD10aGlzLmVkZ2VTdGF0ZS5hYnNvbHV0ZVBvaW50cy5sZW5ndGgmJihmPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzW3RoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzLmxlbmd0aC0yXSxudWxsIT1mJiYoZz1mKSk7Zj1kLngtZy54O2c9ZC55LWcueTtrPU1hdGguc3FydChmKmYrZypnKTtpZigwPT1rKXJldHVybjt0aGlzLm9yaWdpbmFsUG9pbnQ9ZC5jbG9uZSgpO2QueC09NCpmLwprO2QueS09NCpnL2t9ZWxzZSB0aGlzLm9yaWdpbmFsUG9pbnQ9bnVsbDtudWxsPT10aGlzLnNoYXBlJiYoZj1NYXRoLmFicyhiLmdldEdyYXBoWCgpLXRoaXMuZmlyc3QueCksZz1NYXRoLmFicyhiLmdldEdyYXBoWSgpLXRoaXMuZmlyc3QueSksZj50aGlzLmdyYXBoLnRvbGVyYW5jZXx8Zz50aGlzLmdyYXBoLnRvbGVyYW5jZSkmJih0aGlzLnNoYXBlPXRoaXMuY3JlYXRlU2hhcGUoKSxudWxsIT10aGlzLmVkZ2VTdGF0ZSYmdGhpcy5zaGFwZS5hcHBseSh0aGlzLmVkZ2VTdGF0ZSksdGhpcy51cGRhdGVDdXJyZW50U3RhdGUoYixjKSk7bnVsbCE9dGhpcy5zaGFwZSYmKG51bGwhPXRoaXMuZWRnZVN0YXRlP3RoaXMuc2hhcGUucG9pbnRzPXRoaXMuZWRnZVN0YXRlLmFic29sdXRlUG9pbnRzOihjPVtlXSxudWxsIT10aGlzLndheXBvaW50cyYmKGM9Yy5jb25jYXQodGhpcy53YXlwb2ludHMpKSxjLnB1c2goZCksdGhpcy5zaGFwZS5wb2ludHM9YyksdGhpcy5kcmF3UHJldmlldygpKTsKbnVsbCE9dGhpcy5jdXJzb3ImJih0aGlzLmdyYXBoLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9dGhpcy5jdXJzb3IpO214RXZlbnQuY29uc3VtZShiLmdldEV2ZW50KCkpO2IuY29uc3VtZSgpfWVsc2UgdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKT90aGlzLnByZXZpb3VzIT10aGlzLmN1cnJlbnRTdGF0ZSYmbnVsbD09dGhpcy5lZGdlU3RhdGU/KHRoaXMuZGVzdHJveUljb25zKCksbnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJm51bGw9PXRoaXMuZXJyb3ImJm51bGw9PXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJih0aGlzLmljb25zPXRoaXMuY3JlYXRlSWNvbnModGhpcy5jdXJyZW50U3RhdGUpLG51bGw9PXRoaXMuaWNvbnMmJih0aGlzLmN1cnJlbnRTdGF0ZS5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX0NPTk5FQ1QpLGIuY29uc3VtZSgpKSksdGhpcy5wcmV2aW91cz10aGlzLmN1cnJlbnRTdGF0ZSk6dGhpcy5wcmV2aW91cyE9CnRoaXMuY3VycmVudFN0YXRlfHxudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8bnVsbCE9dGhpcy5pY29uc3x8dGhpcy5ncmFwaC5pc01vdXNlRG93bnx8Yi5jb25zdW1lKCk6dGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpO2lmKCF0aGlzLmdyYXBoLmlzTW91c2VEb3duJiZudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmbnVsbCE9dGhpcy5pY29ucyl7Yz0hMTtkPWIuZ2V0U291cmNlKCk7Zm9yKGU9MDtlPHRoaXMuaWNvbnMubGVuZ3RoJiYhYztlKyspYz1kPT10aGlzLmljb25zW2VdLm5vZGV8fGQucGFyZW50Tm9kZT09dGhpcy5pY29uc1tlXS5ub2RlO2N8fHRoaXMudXBkYXRlSWNvbnModGhpcy5jdXJyZW50U3RhdGUsdGhpcy5pY29ucyxiKX19fTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUudXBkYXRlRWRnZVN0YXRlPWZ1bmN0aW9uKGEsYil7bnVsbCE9dGhpcy5zb3VyY2VDb25zdHJhaW50JiZudWxsIT10aGlzLnNvdXJjZUNvbnN0cmFpbnQucG9pbnQmJih0aGlzLmVkZ2VTdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FWElUX1hdPXRoaXMuc291cmNlQ29uc3RyYWludC5wb2ludC54LHRoaXMuZWRnZVN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWV09dGhpcy5zb3VyY2VDb25zdHJhaW50LnBvaW50LnkpO251bGwhPWImJm51bGwhPWIucG9pbnQ/KHRoaXMuZWRnZVN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1hdPWIucG9pbnQueCx0aGlzLmVkZ2VTdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXT1iLnBvaW50LnkpOihkZWxldGUgdGhpcy5lZGdlU3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5UUllfWF0sZGVsZXRlIHRoaXMuZWRnZVN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1ldKTsKdGhpcy5lZGdlU3RhdGUuYWJzb2x1dGVQb2ludHM9W251bGwsbnVsbCE9dGhpcy5jdXJyZW50U3RhdGU/bnVsbDphXTt0aGlzLmdyYXBoLnZpZXcudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50KHRoaXMuZWRnZVN0YXRlLHRoaXMucHJldmlvdXMsITAsdGhpcy5zb3VyY2VDb25zdHJhaW50KTtudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmKG51bGw9PWImJihiPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQodGhpcy5lZGdlU3RhdGUsdGhpcy5wcmV2aW91cywhMSkpLHRoaXMuZWRnZVN0YXRlLnNldEFic29sdXRlVGVybWluYWxQb2ludChudWxsLCExKSx0aGlzLmdyYXBoLnZpZXcudXBkYXRlRml4ZWRUZXJtaW5hbFBvaW50KHRoaXMuZWRnZVN0YXRlLHRoaXMuY3VycmVudFN0YXRlLCExLGIpKTt2YXIgYz1udWxsO2lmKG51bGwhPXRoaXMud2F5cG9pbnRzKWZvcih2YXIgYz1bXSxkPTA7ZDx0aGlzLndheXBvaW50cy5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLndheXBvaW50c1tkXS5jbG9uZSgpOwp0aGlzLmNvbnZlcnRXYXlwb2ludChlKTtjW2RdPWV9dGhpcy5ncmFwaC52aWV3LnVwZGF0ZVBvaW50cyh0aGlzLmVkZ2VTdGF0ZSxjLHRoaXMucHJldmlvdXMsdGhpcy5jdXJyZW50U3RhdGUpO3RoaXMuZ3JhcGgudmlldy51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnRzKHRoaXMuZWRnZVN0YXRlLHRoaXMucHJldmlvdXMsdGhpcy5jdXJyZW50U3RhdGUpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0VGFyZ2V0UGVyaW1ldGVyUG9pbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsLGQ9YS52aWV3LGU9ZC5nZXRQZXJpbWV0ZXJGdW5jdGlvbihhKTtpZihudWxsIT1lKXt2YXIgZj1udWxsIT10aGlzLndheXBvaW50cyYmMDx0aGlzLndheXBvaW50cy5sZW5ndGg/dGhpcy53YXlwb2ludHNbdGhpcy53YXlwb2ludHMubGVuZ3RoLTFdOm5ldyBteFBvaW50KHRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWCgpLHRoaXMucHJldmlvdXMuZ2V0Q2VudGVyWSgpKSxkPWUoZC5nZXRQZXJpbWV0ZXJCb3VuZHMoYSksdGhpcy5lZGdlU3RhdGUsZiwhMSk7bnVsbCE9ZCYmKGM9ZCl9ZWxzZSBjPW5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEuZ2V0Q2VudGVyWSgpKTtyZXR1cm4gY307Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmdldFNvdXJjZVBlcmltZXRlclBvaW50PWZ1bmN0aW9uKGEsYixjKXtjPW51bGw7dmFyIGQ9YS52aWV3LGU9ZC5nZXRQZXJpbWV0ZXJGdW5jdGlvbihhKSxmPW5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpLGEuZ2V0Q2VudGVyWSgpKTtpZihudWxsIT1lKXt2YXIgZz1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCksaz1NYXRoLlBJLzE4MCotZzswIT1nJiYoYj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuZXcgbXhQb2ludChiLngsYi55KSxNYXRoLmNvcyhrKSxNYXRoLnNpbihrKSxmKSk7YT1lKGQuZ2V0UGVyaW1ldGVyQm91bmRzKGEpLGEsYiwhMSk7bnVsbCE9YSYmKDAhPWcmJihhPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KGEueCxhLnkpLE1hdGguY29zKC1rKSxNYXRoLnNpbigtayksZikpLGM9YSl9ZWxzZSBjPWY7cmV0dXJuIGN9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS51cGRhdGVJY29ucz1mdW5jdGlvbihhLGIsYyl7fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pc1N0b3BFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YS5nZXRTdGF0ZSgpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuYWRkV2F5cG9pbnRGb3JFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdyYXBoLmNvbnRhaW5lcixhLmdldFgoKSxhLmdldFkoKSksYz1NYXRoLmFicyhiLngtdGhpcy5maXJzdC54KSxiPU1hdGguYWJzKGIueS10aGlzLmZpcnN0LnkpO2lmKG51bGwhPXRoaXMud2F5cG9pbnRzfHwxPHRoaXMubW91c2VEb3duQ291bnRlciYmKGM+dGhpcy5ncmFwaC50b2xlcmFuY2V8fGI+dGhpcy5ncmFwaC50b2xlcmFuY2UpKW51bGw9PXRoaXMud2F5cG9pbnRzJiYodGhpcy53YXlwb2ludHM9W10pLGM9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGI9bmV3IG14UG9pbnQodGhpcy5ncmFwaC5zbmFwKGEuZ2V0R3JhcGhYKCkvYykqYyx0aGlzLmdyYXBoLnNuYXAoYS5nZXRHcmFwaFkoKS9jKSpjKSx0aGlzLndheXBvaW50cy5wdXNoKGIpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY2hlY2tDb25zdHJhaW50cz1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1hfHxudWxsPT1ifHxudWxsPT1hLnBvaW50fHxudWxsPT1iLnBvaW50fHwhYS5wb2ludC5lcXVhbHMoYi5wb2ludCl8fGEuZHghPWIuZHh8fGEuZHkhPWIuZHl8fGEucGVyaW1ldGVyIT1iLnBlcmltZXRlcn07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXtpZighYi5pc0NvbnN1bWVkKCkmJnRoaXMuaXNDb25uZWN0aW5nKCkpe2lmKHRoaXMud2F5cG9pbnRzRW5hYmxlZCYmIXRoaXMuaXNTdG9wRXZlbnQoYikpe3RoaXMuYWRkV2F5cG9pbnRGb3JFdmVudChiKTtiLmNvbnN1bWUoKTtyZXR1cm59dmFyIGM9dGhpcy5zb3VyY2VDb25zdHJhaW50LGQ9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCxlPW51bGwhPXRoaXMucHJldmlvdXM/dGhpcy5wcmV2aW91cy5jZWxsOm51bGwsZj1udWxsO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiYoZj10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cy5jZWxsKTtudWxsPT1mJiZudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmKGY9dGhpcy5jdXJyZW50U3RhdGUuY2VsbCk7Cm51bGwhPXRoaXMuZXJyb3J8fG51bGwhPWUmJm51bGwhPWYmJmU9PWYmJiF0aGlzLmNoZWNrQ29uc3RyYWludHMoYyxkKT8obnVsbCE9dGhpcy5wcmV2aW91cyYmbnVsbCE9dGhpcy5tYXJrZXIudmFsaWRTdGF0ZSYmdGhpcy5wcmV2aW91cy5jZWxsPT10aGlzLm1hcmtlci52YWxpZFN0YXRlLmNlbGwmJnRoaXMuZ3JhcGguc2VsZWN0Q2VsbEZvckV2ZW50KHRoaXMubWFya2VyLnNvdXJjZSxiLmdldEV2ZW50KCkpLG51bGwhPXRoaXMuZXJyb3ImJjA8dGhpcy5lcnJvci5sZW5ndGgmJnRoaXMuZ3JhcGgudmFsaWRhdGlvbkFsZXJ0KHRoaXMuZXJyb3IpKTp0aGlzLmNvbm5lY3QoZSxmLGIuZ2V0RXZlbnQoKSxiLmdldENlbGwoKSk7dGhpcy5kZXN0cm95SWNvbnMoKTtiLmNvbnN1bWUoKX1udWxsIT10aGlzLmZpcnN0JiZ0aGlzLnJlc2V0KCl9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe251bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLmRlc3Ryb3koKSx0aGlzLnNoYXBlPW51bGwpO251bGwhPXRoaXMuY3Vyc29yJiZudWxsIT10aGlzLmdyYXBoLmNvbnRhaW5lciYmKHRoaXMuZ3JhcGguY29udGFpbmVyLnN0eWxlLmN1cnNvcj0iIik7dGhpcy5kZXN0cm95SWNvbnMoKTt0aGlzLm1hcmtlci5yZXNldCgpO3RoaXMuY29uc3RyYWludEhhbmRsZXIucmVzZXQoKTt0aGlzLnNvdXJjZUNvbnN0cmFpbnQ9dGhpcy5lcnJvcj10aGlzLnByZXZpb3VzPXRoaXMuZWRnZVN0YXRlPXRoaXMuY3VycmVudFBvaW50PXRoaXMub3JpZ2luYWxQb2ludD1udWxsO3RoaXMubW91c2VEb3duQ291bnRlcj0wO3RoaXMuZmlyc3Q9bnVsbDt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJFU0VUKSl9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5kcmF3UHJldmlldz1mdW5jdGlvbigpe3RoaXMudXBkYXRlUHJldmlldyhudWxsPT10aGlzLmVycm9yKTt0aGlzLnNoYXBlLnJlZHJhdygpfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3PWZ1bmN0aW9uKGEpe3RoaXMuc2hhcGUuc3Ryb2tld2lkdGg9dGhpcy5nZXRFZGdlV2lkdGgoYSk7dGhpcy5zaGFwZS5zdHJva2U9dGhpcy5nZXRFZGdlQ29sb3IoYSl9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmdldEVkZ2VDb2xvcj1mdW5jdGlvbihhKXtyZXR1cm4gYT9teENvbnN0YW50cy5WQUxJRF9DT0xPUjpteENvbnN0YW50cy5JTlZBTElEX0NPTE9SfTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5nZXRFZGdlV2lkdGg9ZnVuY3Rpb24oYSl7cmV0dXJuIGE/MzoxfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihhLGIsYyxkKXtpZihudWxsIT1ifHx0aGlzLmlzQ3JlYXRlVGFyZ2V0KGMpfHx0aGlzLmdyYXBoLmFsbG93RGFuZ2xpbmdFZGdlcyl7dmFyIGU9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGY9ITEsZz1udWxsO2UuYmVnaW5VcGRhdGUoKTt0cnl7aWYobnVsbCE9YSYmbnVsbD09YiYmIXRoaXMuZ3JhcGguaXNJZ25vcmVUZXJtaW5hbEV2ZW50KGMpJiZ0aGlzLmlzQ3JlYXRlVGFyZ2V0KGMpJiYoYj10aGlzLmNyZWF0ZVRhcmdldFZlcnRleChjLGEpLG51bGwhPWIpKXtkPXRoaXMuZ3JhcGguZ2V0RHJvcFRhcmdldChbYl0sYyxkKTtmPSEwO2lmKG51bGwhPWQmJnRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc0VkZ2UoZCkpZD10aGlzLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKTtlbHNle3ZhciBrPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFN0YXRlKGQpO2lmKG51bGwhPWspe3ZhciBsPWUuZ2V0R2VvbWV0cnkoYik7CmwueC09ay5vcmlnaW4ueDtsLnktPWsub3JpZ2luLnl9fXRoaXMuZ3JhcGguYWRkQ2VsbChiLGQpfXZhciBtPXRoaXMuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpO251bGwhPWEmJm51bGwhPWImJmUuZ2V0UGFyZW50KGEpPT1lLmdldFBhcmVudChiKSYmZS5nZXRQYXJlbnQoZS5nZXRQYXJlbnQoYSkpIT1lLmdldFJvb3QoKSYmKG09ZS5nZXRQYXJlbnQoYSksbnVsbCE9YS5nZW9tZXRyeSYmYS5nZW9tZXRyeS5yZWxhdGl2ZSYmbnVsbCE9Yi5nZW9tZXRyeSYmYi5nZW9tZXRyeS5yZWxhdGl2ZSYmKG09ZS5nZXRQYXJlbnQobSkpKTt2YXIgbj1rPW51bGw7bnVsbCE9dGhpcy5lZGdlU3RhdGUmJihrPXRoaXMuZWRnZVN0YXRlLmNlbGwudmFsdWUsbj10aGlzLmVkZ2VTdGF0ZS5jZWxsLnN0eWxlKTtnPXRoaXMuaW5zZXJ0RWRnZShtLG51bGwsayxhLGIsbik7aWYobnVsbCE9Zyl7dGhpcy5ncmFwaC5zZXRDb25uZWN0aW9uQ29uc3RyYWludChnLGEsITAsdGhpcy5zb3VyY2VDb25zdHJhaW50KTsKdGhpcy5ncmFwaC5zZXRDb25uZWN0aW9uQ29uc3RyYWludChnLGIsITEsdGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludCk7bnVsbCE9dGhpcy5lZGdlU3RhdGUmJmUuc2V0R2VvbWV0cnkoZyx0aGlzLmVkZ2VTdGF0ZS5jZWxsLmdlb21ldHJ5KTttPWUuZ2V0UGFyZW50KGEpO2lmKHRoaXMuaXNJbnNlcnRCZWZvcmUoZyxhLGIsYyxkKSl7Zm9yKGw9YTtudWxsIT1sLnBhcmVudCYmbnVsbCE9bC5nZW9tZXRyeSYmbC5nZW9tZXRyeS5yZWxhdGl2ZSYmbC5wYXJlbnQhPWcucGFyZW50OylsPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KGwpO251bGwhPWwmJm51bGwhPWwucGFyZW50JiZsLnBhcmVudD09Zy5wYXJlbnQmJmUuYWRkKG0sZyxsLnBhcmVudC5nZXRJbmRleChsKSl9dmFyIHA9ZS5nZXRHZW9tZXRyeShnKTtudWxsPT1wJiYocD1uZXcgbXhHZW9tZXRyeSxwLnJlbGF0aXZlPSEwLGUuc2V0R2VvbWV0cnkoZyxwKSk7aWYobnVsbCE9dGhpcy53YXlwb2ludHMmJgowPHRoaXMud2F5cG9pbnRzLmxlbmd0aCl7dmFyIHE9dGhpcy5ncmFwaC52aWV3LnNjYWxlLHI9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZTtwLnBvaW50cz1bXTtmb3IoYT0wO2E8dGhpcy53YXlwb2ludHMubGVuZ3RoO2ErKyl7dmFyIHQ9dGhpcy53YXlwb2ludHNbYV07cC5wb2ludHMucHVzaChuZXcgbXhQb2ludCh0LngvcS1yLngsdC55L3Etci55KSl9fWlmKG51bGw9PWIpe3ZhciB1PXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUscT10aGlzLmdyYXBoLnZpZXcuc2NhbGUsdD1udWxsIT10aGlzLm9yaWdpbmFsUG9pbnQ/bmV3IG14UG9pbnQodGhpcy5vcmlnaW5hbFBvaW50LngvcS11LngsdGhpcy5vcmlnaW5hbFBvaW50LnkvcS11LnkpOm5ldyBteFBvaW50KHRoaXMuY3VycmVudFBvaW50LngvcS11LngsdGhpcy5jdXJyZW50UG9pbnQueS9xLXUueSk7dC54LT10aGlzLmdyYXBoLnBhbkR4L3RoaXMuZ3JhcGgudmlldy5zY2FsZTt0LnktPXRoaXMuZ3JhcGgucGFuRHkvdGhpcy5ncmFwaC52aWV3LnNjYWxlOwpwLnNldFRlcm1pbmFsUG9pbnQodCwhMSl9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DT05ORUNULCJjZWxsIixnLCJ0ZXJtaW5hbCIsYiwiZXZlbnQiLGMsInRhcmdldCIsZCwidGVybWluYWxJbnNlcnRlZCIsZikpfX1jYXRjaCh4KXtteExvZy5zaG93KCksbXhMb2cuZGVidWcoeC5tZXNzYWdlKX1maW5hbGx5e2UuZW5kVXBkYXRlKCl9dGhpcy5zZWxlY3QmJnRoaXMuc2VsZWN0Q2VsbHMoZyxmP2I6bnVsbCl9fTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5zZWxlY3RDZWxscz1mdW5jdGlvbihhLGIpe3RoaXMuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChhKX07Cm14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmluc2VydEVkZ2U9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKG51bGw9PXRoaXMuZmFjdG9yeU1ldGhvZClyZXR1cm4gdGhpcy5ncmFwaC5pbnNlcnRFZGdlKGEsYixjLGQsZSxmKTtiPXRoaXMuY3JlYXRlRWRnZShjLGQsZSxmKTtyZXR1cm4gdGhpcy5ncmFwaC5hZGRFZGdlKGIsYSxkLGUpfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlVGFyZ2V0VmVydGV4PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGIpO251bGwhPWMmJmMucmVsYXRpdmU7KWI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChiKSxjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGIpO3ZhciBkPXRoaXMuZ3JhcGguY2xvbmVDZWxsKGIpLGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KGQpO2lmKG51bGwhPWMpe3ZhciBlPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZj10aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz1uZXcgbXhQb2ludCh0aGlzLmN1cnJlbnRQb2ludC54L2YtZS54LHRoaXMuY3VycmVudFBvaW50LnkvZi1lLnkpO2MueD1NYXRoLnJvdW5kKGcueC1jLndpZHRoLzItdGhpcy5ncmFwaC5wYW5EeC9mKTtjLnk9TWF0aC5yb3VuZChnLnktYy5oZWlnaHQvMi10aGlzLmdyYXBoLnBhbkR5L2YpO2c9dGhpcy5nZXRBbGlnbm1lbnRUb2xlcmFuY2UoKTsKaWYoMDxnKXt2YXIgaz10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYik7aWYobnVsbCE9ayl7dmFyIGw9ay54L2YtZS54LGU9ay55L2YtZS55O01hdGguYWJzKGwtYy54KTw9ZyYmKGMueD1NYXRoLnJvdW5kKGwpKTtNYXRoLmFicyhlLWMueSk8PWcmJihjLnk9TWF0aC5yb3VuZChlKSl9fX1yZXR1cm4gZH07bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0QWxpZ25tZW50VG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWQoKT90aGlzLmdyYXBoLmdyaWRTaXplLzI6dGhpcy5ncmFwaC50b2xlcmFuY2V9OwpteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFZGdlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW51bGw7bnVsbCE9dGhpcy5mYWN0b3J5TWV0aG9kJiYoZT10aGlzLmZhY3RvcnlNZXRob2QoYixjLGQpKTtudWxsPT1lJiYoZT1uZXcgbXhDZWxsKGF8fCIiKSxlLnNldEVkZ2UoITApLGUuc2V0U3R5bGUoZCksYT1uZXcgbXhHZW9tZXRyeSxhLnJlbGF0aXZlPSEwLGUuc2V0R2VvbWV0cnkoYSkpO3JldHVybiBlfTsKbXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGgucmVtb3ZlTW91c2VMaXN0ZW5lcih0aGlzKTtudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5kZXN0cm95KCksdGhpcy5zaGFwZT1udWxsKTtudWxsIT10aGlzLm1hcmtlciYmKHRoaXMubWFya2VyLmRlc3Ryb3koKSx0aGlzLm1hcmtlcj1udWxsKTtudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyJiYodGhpcy5jb25zdHJhaW50SGFuZGxlci5kZXN0cm95KCksdGhpcy5jb25zdHJhaW50SGFuZGxlcj1udWxsKTtudWxsIT10aGlzLmNoYW5nZUhhbmRsZXImJih0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLmNoYW5nZUhhbmRsZXIpLHRoaXMuY2hhbmdlSGFuZGxlcj1udWxsKTtudWxsIT10aGlzLmRyaWxsSGFuZGxlciYmKHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5kcmlsbEhhbmRsZXIpLAp0aGlzLmdyYXBoLmdldFZpZXcoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLmRyaWxsSGFuZGxlciksdGhpcy5kcmlsbEhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5lc2NhcGVIYW5kbGVyJiYodGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcih0aGlzLmVzY2FwZUhhbmRsZXIpLHRoaXMuZXNjYXBlSGFuZGxlcj1udWxsKX07CmZ1bmN0aW9uIG14Q29uc3RyYWludEhhbmRsZXIoYSl7dGhpcy5ncmFwaD1hO3RoaXMucmVzZXRIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7bnVsbCE9dGhpcy5jdXJyZW50Rm9jdXMmJm51bGw9PXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmN1cnJlbnRGb2N1cy5jZWxsKT90aGlzLnJlc2V0KCk6dGhpcy5yZWRyYXcoKX0pO3RoaXMuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlNDQUxFX0FORF9UUkFOU0xBVEUsdGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlRSQU5TTEFURSx0aGlzLnJlc2V0SGFuZGxlcik7dGhpcy5ncmFwaC52aWV3LmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEUsdGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5ST09ULAp0aGlzLnJlc2V0SGFuZGxlcil9bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUucG9pbnRJbWFnZT1uZXcgbXhJbWFnZShteENsaWVudC5pbWFnZUJhc2VQYXRoKyIvcG9pbnQuZ2lmIiw1LDUpO214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZW5hYmxlZD0hMDtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5oaWdobGlnaHRDb2xvcj1teENvbnN0YW50cy5ERUZBVUxUX1ZBTElEX0NPTE9SO214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9O214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnNldEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lbmFibGVkPWF9OwpteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuZm9jdXNJY29ucyl7Zm9yKHZhciBhPTA7YTx0aGlzLmZvY3VzSWNvbnMubGVuZ3RoO2ErKyl0aGlzLmZvY3VzSWNvbnNbYV0uZGVzdHJveSgpO3RoaXMuZm9jdXNJY29ucz1udWxsfW51bGwhPXRoaXMuZm9jdXNIaWdobGlnaHQmJih0aGlzLmZvY3VzSGlnaGxpZ2h0LmRlc3Ryb3koKSx0aGlzLmZvY3VzSGlnaGxpZ2h0PW51bGwpO3RoaXMuZm9jdXNQb2ludHM9dGhpcy5jdXJyZW50Rm9jdXM9dGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50Rm9jdXNBcmVhPXRoaXMuY3VycmVudENvbnN0cmFpbnQ9bnVsbH07bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZ2V0VG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyYXBoLmdldFRvbGVyYW5jZSgpfTsKbXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZ2V0SW1hZ2VGb3JDb25zdHJhaW50PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5wb2ludEltYWdlfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5pc0V2ZW50SWdub3JlZD1mdW5jdGlvbihhLGIpe3JldHVybiExfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5pc1N0YXRlSWdub3JlZD1mdW5jdGlvbihhLGIpe3JldHVybiExfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95SWNvbnM9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmZvY3VzSWNvbnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5mb2N1c0ljb25zLmxlbmd0aDthKyspdGhpcy5mb2N1c0ljb25zW2FdLmRlc3Ryb3koKTt0aGlzLmZvY3VzUG9pbnRzPXRoaXMuZm9jdXNJY29ucz1udWxsfX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3lGb2N1c0hpZ2hsaWdodD1mdW5jdGlvbigpe251bGwhPXRoaXMuZm9jdXNIaWdobGlnaHQmJih0aGlzLmZvY3VzSGlnaGxpZ2h0LmRlc3Ryb3koKSx0aGlzLmZvY3VzSGlnaGxpZ2h0PW51bGwpfTtteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5pc0tlZXBGb2N1c0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl9OwpteENvbnN0cmFpbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRDZWxsRm9yRXZlbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldENlbGwoKTtudWxsIT1jfHxudWxsPT1ifHxhLmdldEdyYXBoWCgpPT1iLngmJmEuZ2V0R3JhcGhZKCk9PWIueXx8KGM9dGhpcy5ncmFwaC5nZXRDZWxsQXQoYi54LGIueSkpO2lmKG51bGwhPWMmJiF0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGMpKXt2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0UGFyZW50KGMpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChkKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShkKSYmKGM9ZCl9cmV0dXJuIHRoaXMuZ3JhcGguaXNDZWxsTG9ja2VkKGMpP251bGw6Y307Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIsYyxkKXtpZih0aGlzLmlzRW5hYmxlZCgpJiYhdGhpcy5pc0V2ZW50SWdub3JlZChhKSl7bnVsbD09dGhpcy5tb3VzZWxlYXZlSGFuZGxlciYmbnVsbCE9dGhpcy5ncmFwaC5jb250YWluZXImJih0aGlzLm1vdXNlbGVhdmVIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXNldCgpfSksbXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmdyYXBoLmNvbnRhaW5lciwibW91c2VsZWF2ZSIsdGhpcy5yZXNldEhhbmRsZXIpKTt2YXIgZT10aGlzLmdldFRvbGVyYW5jZShhKSxmPW51bGwhPWQ/ZC54OmEuZ2V0R3JhcGhYKCksZz1udWxsIT1kP2QueTphLmdldEdyYXBoWSgpLGY9bmV3IG14UmVjdGFuZ2xlKGYtZSxnLWUsMiplLDIqZSksZT1uZXcgbXhSZWN0YW5nbGUoYS5nZXRHcmFwaFgoKS1lLGEuZ2V0R3JhcGhZKCktZSwyKmUsMiplKSxrPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZSh0aGlzLmdldENlbGxGb3JFdmVudChhLApkKSk7dGhpcy5pc0tlZXBGb2N1c0V2ZW50KGEpfHxudWxsIT10aGlzLmN1cnJlbnRGb2N1c0FyZWEmJm51bGwhPXRoaXMuY3VycmVudEZvY3VzJiZudWxsPT1rJiZ0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNWZXJ0ZXgodGhpcy5jdXJyZW50Rm9jdXMuY2VsbCkmJm14VXRpbHMuaW50ZXJzZWN0cyh0aGlzLmN1cnJlbnRGb2N1c0FyZWEsZSl8fGs9PXRoaXMuY3VycmVudEZvY3VzfHwodGhpcy5jdXJyZW50Rm9jdXM9dGhpcy5jdXJyZW50Rm9jdXNBcmVhPW51bGwsdGhpcy5zZXRGb2N1cyhhLGssYikpO2E9dGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50Q29uc3RyYWludD1udWxsO2lmKG51bGwhPXRoaXMuZm9jdXNJY29ucyYmbnVsbCE9dGhpcy5jb25zdHJhaW50cyYmKG51bGw9PWt8fHRoaXMuY3VycmVudEZvY3VzPT1rKSlmb3IodmFyIGc9ZS5nZXRDZW50ZXJYKCksbD1lLmdldENlbnRlclkoKSxtPTA7bTx0aGlzLmZvY3VzSWNvbnMubGVuZ3RoO20rKyl7dmFyIG49Zy10aGlzLmZvY3VzSWNvbnNbbV0uYm91bmRzLmdldENlbnRlclgoKSwKcD1sLXRoaXMuZm9jdXNJY29uc1ttXS5ib3VuZHMuZ2V0Q2VudGVyWSgpLG49bipuK3AqcDtpZigodGhpcy5pbnRlcnNlY3RzKHRoaXMuZm9jdXNJY29uc1ttXSxlLGIsYyl8fG51bGwhPWQmJnRoaXMuaW50ZXJzZWN0cyh0aGlzLmZvY3VzSWNvbnNbbV0sZixiLGMpKSYmKG51bGw9PWF8fG48YSkpe3RoaXMuY3VycmVudENvbnN0cmFpbnQ9dGhpcy5jb25zdHJhaW50c1ttXTt0aGlzLmN1cnJlbnRQb2ludD10aGlzLmZvY3VzUG9pbnRzW21dO2E9bjtuPXRoaXMuZm9jdXNJY29uc1ttXS5ib3VuZHMuY2xvbmUoKTtuLmdyb3cobXhDb25zdGFudHMuSElHSExJR0hUX1NJWkUrMSk7LS1uLndpZHRoOy0tbi5oZWlnaHQ7aWYobnVsbD09dGhpcy5mb2N1c0hpZ2hsaWdodCl7cD10aGlzLmNyZWF0ZUhpZ2hsaWdodFNoYXBlKCk7cC5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9TVkc6bXhDb25zdGFudHMuRElBTEVDVF9WTUw7CnAucG9pbnRlckV2ZW50cz0hMTtwLmluaXQodGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSk7dGhpcy5mb2N1c0hpZ2hsaWdodD1wO3ZhciBxPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudEZvY3VzP3RoaXMuY3VycmVudEZvY3VzOmt9KTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMocC5ub2RlLHRoaXMuZ3JhcGgscSl9dGhpcy5mb2N1c0hpZ2hsaWdodC5ib3VuZHM9bjt0aGlzLmZvY3VzSGlnaGxpZ2h0LnJlZHJhdygpfX1udWxsPT10aGlzLmN1cnJlbnRDb25zdHJhaW50JiZ0aGlzLmRlc3Ryb3lGb2N1c0hpZ2hsaWdodCgpfWVsc2UgdGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jdXJyZW50Rm9jdXM9dGhpcy5jdXJyZW50Q29uc3RyYWludD1udWxsfTsKbXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5jdXJyZW50Rm9jdXMmJm51bGwhPXRoaXMuY29uc3RyYWludHMmJm51bGwhPXRoaXMuZm9jdXNJY29ucyl7dmFyIGE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuY3VycmVudEZvY3VzLmNlbGwpO3RoaXMuY3VycmVudEZvY3VzPWE7dGhpcy5jdXJyZW50Rm9jdXNBcmVhPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpO2Zvcih2YXIgYj0wO2I8dGhpcy5jb25zdHJhaW50cy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChhLHRoaXMuY29uc3RyYWludHNbYl0pLGQ9dGhpcy5nZXRJbWFnZUZvckNvbnN0cmFpbnQoYSx0aGlzLmNvbnN0cmFpbnRzW2JdLGMpLGQ9bmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQoYy54LWQud2lkdGgvMiksTWF0aC5yb3VuZChjLnktZC5oZWlnaHQvMiksZC53aWR0aCxkLmhlaWdodCk7CnRoaXMuZm9jdXNJY29uc1tiXS5ib3VuZHM9ZDt0aGlzLmZvY3VzSWNvbnNbYl0ucmVkcmF3KCk7dGhpcy5jdXJyZW50Rm9jdXNBcmVhLmFkZCh0aGlzLmZvY3VzSWNvbnNbYl0uYm91bmRzKTt0aGlzLmZvY3VzUG9pbnRzW2JdPWN9fX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnNldEZvY3VzPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmNvbnN0cmFpbnRzPW51bGwhPWImJiF0aGlzLmlzU3RhdGVJZ25vcmVkKGIsYykmJnRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYi5jZWxsKT90aGlzLmlzRW5hYmxlZCgpP3RoaXMuZ3JhcGguZ2V0QWxsQ29ubmVjdGlvbkNvbnN0cmFpbnRzKGIsYyl8fFtdOltdOm51bGw7aWYobnVsbCE9dGhpcy5jb25zdHJhaW50cyl7dGhpcy5jdXJyZW50Rm9jdXM9Yjt0aGlzLmN1cnJlbnRGb2N1c0FyZWE9bmV3IG14UmVjdGFuZ2xlKGIueCxiLnksYi53aWR0aCxiLmhlaWdodCk7aWYobnVsbCE9dGhpcy5mb2N1c0ljb25zKXtmb3IoYz0wO2M8dGhpcy5mb2N1c0ljb25zLmxlbmd0aDtjKyspdGhpcy5mb2N1c0ljb25zW2NdLmRlc3Ryb3koKTt0aGlzLmZvY3VzUG9pbnRzPXRoaXMuZm9jdXNJY29ucz1udWxsfXRoaXMuZm9jdXNQb2ludHM9W107dGhpcy5mb2N1c0ljb25zPVtdO2ZvcihjPQowO2M8dGhpcy5jb25zdHJhaW50cy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChiLHRoaXMuY29uc3RyYWludHNbY10pLGU9dGhpcy5nZXRJbWFnZUZvckNvbnN0cmFpbnQoYix0aGlzLmNvbnN0cmFpbnRzW2NdLGQpLGY9ZS5zcmMsZT1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChkLngtZS53aWR0aC8yKSxNYXRoLnJvdW5kKGQueS1lLmhlaWdodC8yKSxlLndpZHRoLGUuaGVpZ2h0KSxmPW5ldyBteEltYWdlU2hhcGUoZSxmKTtmLmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX01JWEVESFRNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRztmLnByZXNlcnZlSW1hZ2VBc3BlY3Q9ITE7Zi5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldERlY29yYXRvclBhbmUoKSk7KG14Q2xpZW50LklTX1FVSVJLU3x8OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSYmbXhFdmVudC5hZGRMaXN0ZW5lcihmLm5vZGUsCiJkcmFnc3RhcnQiLGZ1bmN0aW9uKGEpe214RXZlbnQuY29uc3VtZShhKTtyZXR1cm4hMX0pO251bGwhPWYubm9kZS5wcmV2aW91c1NpYmxpbmcmJmYubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmLm5vZGUsZi5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7ZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRGb2N1cz90aGlzLmN1cnJlbnRGb2N1czpifSk7Zi5yZWRyYXcoKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMoZi5ub2RlLHRoaXMuZ3JhcGgsZSk7dGhpcy5jdXJyZW50Rm9jdXNBcmVhLmFkZChmLmJvdW5kcyk7dGhpcy5mb2N1c0ljb25zLnB1c2goZik7dGhpcy5mb2N1c1BvaW50cy5wdXNoKGQpfXRoaXMuY3VycmVudEZvY3VzQXJlYS5ncm93KHRoaXMuZ2V0VG9sZXJhbmNlKGEpKX1lbHNlIHRoaXMuZGVzdHJveUljb25zKCksdGhpcy5kZXN0cm95Rm9jdXNIaWdobGlnaHQoKX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUhpZ2hsaWdodFNoYXBlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14UmVjdGFuZ2xlU2hhcGUobnVsbCx0aGlzLmhpZ2hsaWdodENvbG9yLHRoaXMuaGlnaGxpZ2h0Q29sb3IsbXhDb25zdGFudHMuSElHSExJR0hUX1NUUk9LRVdJRFRIKTthLm9wYWNpdHk9bXhDb25zdGFudHMuSElHSExJR0hUX09QQUNJVFk7cmV0dXJuIGF9O214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIG14VXRpbHMuaW50ZXJzZWN0cyhhLmJvdW5kcyxiKX07Cm14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnJlc2V0KCk7bnVsbCE9dGhpcy5yZXNldEhhbmRsZXImJih0aGlzLmdyYXBoLm1vZGVsLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVzZXRIYW5kbGVyKSx0aGlzLmdyYXBoLnZpZXcucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpLHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpLHRoaXMucmVzZXRIYW5kbGVyPW51bGwpO251bGwhPXRoaXMubW91c2VsZWF2ZUhhbmRsZXImJm51bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmdyYXBoLmNvbnRhaW5lciwibW91c2VsZWF2ZSIsdGhpcy5tb3VzZWxlYXZlSGFuZGxlciksdGhpcy5tb3VzZWxlYXZlSGFuZGxlcj1udWxsKX07CmZ1bmN0aW9uIG14UnViYmVyYmFuZChhKXtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKSx0aGlzLmZvcmNlUnViYmVyYmFuZEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt2YXIgYj1jLmdldFByb3BlcnR5KCJldmVudE5hbWUiKSxlPWMuZ2V0UHJvcGVydHkoImV2ZW50Iik7aWYoYj09bXhFdmVudC5NT1VTRV9ET1dOJiZ0aGlzLmlzRm9yY2VSdWJiZXJiYW5kRXZlbnQoZSkpe3ZhciBiPW14VXRpbHMuZ2V0T2Zmc2V0KHRoaXMuZ3JhcGguY29udGFpbmVyKSxmPW14VXRpbHMuZ2V0U2Nyb2xsT3JpZ2luKHRoaXMuZ3JhcGguY29udGFpbmVyKTtmLngtPWIueDtmLnktPWIueTt0aGlzLnN0YXJ0KGUuZ2V0WCgpK2YueCxlLmdldFkoKStmLnkpO2UuY29uc3VtZSghMSl9fSksdGhpcy5ncmFwaC5hZGRMaXN0ZW5lcihteEV2ZW50LkZJUkVfTU9VU0VfRVZFTlQsdGhpcy5mb3JjZVJ1YmJlcmJhbmRIYW5kbGVyKSwKdGhpcy5wYW5IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXBhaW50KCl9KSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUEFOLHRoaXMucGFuSGFuZGxlciksdGhpcy5nZXN0dXJlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe251bGwhPXRoaXMuZmlyc3QmJnRoaXMucmVzZXQoKX0pLHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5HRVNUVVJFLHRoaXMuZ2VzdHVyZUhhbmRsZXIpLG14Q2xpZW50LklTX0lFJiZteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywidW5sb2FkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZGVzdHJveSgpfSkpKX1teFJ1YmJlcmJhbmQucHJvdG90eXBlLmRlZmF1bHRPcGFjaXR5PTIwO214UnViYmVyYmFuZC5wcm90b3R5cGUuZW5hYmxlZD0hMDtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmRpdj1udWxsO214UnViYmVyYmFuZC5wcm90b3R5cGUuc2hhcmVkRGl2PW51bGw7Cm14UnViYmVyYmFuZC5wcm90b3R5cGUuY3VycmVudFg9MDtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmN1cnJlbnRZPTA7bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5mYWRlT3V0PSExO214UnViYmVyYmFuZC5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmlzRm9yY2VSdWJiZXJiYW5kRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSl9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmdGhpcy5pc0VuYWJsZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmbnVsbD09Yi5nZXRTdGF0ZSgpJiYhbXhFdmVudC5pc011bHRpVG91Y2hFdmVudChiLmdldEV2ZW50KCkpKXt2YXIgYz1teFV0aWxzLmdldE9mZnNldCh0aGlzLmdyYXBoLmNvbnRhaW5lciksZD1teFV0aWxzLmdldFNjcm9sbE9yaWdpbih0aGlzLmdyYXBoLmNvbnRhaW5lcik7ZC54LT1jLng7ZC55LT1jLnk7dGhpcy5zdGFydChiLmdldFgoKStkLngsYi5nZXRZKCkrZC55KTtiLmNvbnN1bWUoITEpfX07Cm14UnViYmVyYmFuZC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2E9bmV3IG14TW91c2VFdmVudChhKTt2YXIgYj1teFV0aWxzLmNvbnZlcnRQb2ludChkLGEuZ2V0WCgpLGEuZ2V0WSgpKTthLmdyYXBoWD1iLng7YS5ncmFwaFk9Yi55O3JldHVybiBhfXRoaXMuZmlyc3Q9bmV3IG14UG9pbnQoYSxiKTt2YXIgZD10aGlzLmdyYXBoLmNvbnRhaW5lcjt0aGlzLmRyYWdIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMubW91c2VNb3ZlKHRoaXMuZ3JhcGgsYyhhKSl9KTt0aGlzLmRyb3BIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMubW91c2VVcCh0aGlzLmdyYXBoLGMoYSkpfSk7bXhDbGllbnQuSVNfRkYmJm14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLHRoaXMuZHJhZ0hhbmRsZXIsdGhpcy5kcm9wSGFuZGxlcil9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmbnVsbCE9dGhpcy5maXJzdCl7dmFyIGM9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4odGhpcy5ncmFwaC5jb250YWluZXIpLGQ9bXhVdGlscy5nZXRPZmZzZXQodGhpcy5ncmFwaC5jb250YWluZXIpO2MueC09ZC54O2MueS09ZC55O3ZhciBkPWIuZ2V0WCgpK2MueCxjPWIuZ2V0WSgpK2MueSxlPXRoaXMuZmlyc3QueC1kLGY9dGhpcy5maXJzdC55LWMsZz10aGlzLmdyYXBoLnRvbGVyYW5jZTtpZihudWxsIT10aGlzLmRpdnx8TWF0aC5hYnMoZSk+Z3x8TWF0aC5hYnMoZik+ZyludWxsPT10aGlzLmRpdiYmKHRoaXMuZGl2PXRoaXMuY3JlYXRlU2hhcGUoKSksbXhVdGlscy5jbGVhclNlbGVjdGlvbigpLHRoaXMudXBkYXRlKGQsYyksYi5jb25zdW1lKCl9fTsKbXhSdWJiZXJiYW5kLnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbigpe251bGw9PXRoaXMuc2hhcmVkRGl2JiYodGhpcy5zaGFyZWREaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksdGhpcy5zaGFyZWREaXYuY2xhc3NOYW1lPSJteFJ1YmJlcmJhbmQiLG14VXRpbHMuc2V0T3BhY2l0eSh0aGlzLnNoYXJlZERpdix0aGlzLmRlZmF1bHRPcGFjaXR5KSk7dGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zaGFyZWREaXYpO3ZhciBhPXRoaXMuc2hhcmVkRGl2O214Q2xpZW50LklTX1NWRyYmKCFteENsaWVudC5JU19JRXx8MTA8PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJnRoaXMuZmFkZU91dCYmKHRoaXMuc2hhcmVkRGl2PW51bGwpO3JldHVybiBhfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPXRoaXMuZGl2JiYibm9uZSIhPXRoaXMuZGl2LnN0eWxlLmRpc3BsYXl9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmlzQWN0aXZlKCk7dGhpcy5yZXNldCgpO2MmJih0aGlzLmV4ZWN1dGUoYi5nZXRFdmVudCgpKSxiLmNvbnN1bWUoKSl9O214UnViYmVyYmFuZC5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgbXhSZWN0YW5nbGUodGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KTt0aGlzLmdyYXBoLnNlbGVjdFJlZ2lvbihiLGEpfTsKbXhSdWJiZXJiYW5kLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuZGl2KWlmKG14Q2xpZW50LklTX1NWRyYmKCFteENsaWVudC5JU19JRXx8MTA8PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJnRoaXMuZmFkZU91dCl7dmFyIGE9dGhpcy5kaXY7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGEuc3R5bGUsInRyYW5zaXRpb24iLCJhbGwgMC4ycyBsaW5lYXIiKTthLnN0eWxlLnBvaW50ZXJFdmVudHM9Im5vbmUiO2Euc3R5bGUub3BhY2l0eT0wO3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfSwyMDApfWVsc2UgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7bXhFdmVudC5yZW1vdmVHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LG51bGwsdGhpcy5kcmFnSGFuZGxlcix0aGlzLmRyb3BIYW5kbGVyKTt0aGlzLmRyb3BIYW5kbGVyPXRoaXMuZHJhZ0hhbmRsZXI9bnVsbDt0aGlzLmN1cnJlbnRZPQp0aGlzLmN1cnJlbnRYPTA7dGhpcy5kaXY9dGhpcy5maXJzdD1udWxsfTtteFJ1YmJlcmJhbmQucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe3RoaXMuY3VycmVudFg9YTt0aGlzLmN1cnJlbnRZPWI7dGhpcy5yZXBhaW50KCl9OwpteFJ1YmJlcmJhbmQucHJvdG90eXBlLnJlcGFpbnQ9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmRpdil7dmFyIGE9dGhpcy5jdXJyZW50WC10aGlzLmdyYXBoLnBhbkR4LGI9dGhpcy5jdXJyZW50WS10aGlzLmdyYXBoLnBhbkR5O3RoaXMueD1NYXRoLm1pbih0aGlzLmZpcnN0LngsYSk7dGhpcy55PU1hdGgubWluKHRoaXMuZmlyc3QueSxiKTt0aGlzLndpZHRoPU1hdGgubWF4KHRoaXMuZmlyc3QueCxhKS10aGlzLng7dGhpcy5oZWlnaHQ9TWF0aC5tYXgodGhpcy5maXJzdC55LGIpLXRoaXMueTthPW14Q2xpZW50LklTX1ZNTD90aGlzLmdyYXBoLnBhbkR5OjA7dGhpcy5kaXYuc3R5bGUubGVmdD10aGlzLngrKG14Q2xpZW50LklTX1ZNTD90aGlzLmdyYXBoLnBhbkR4OjApKyJweCI7dGhpcy5kaXYuc3R5bGUudG9wPXRoaXMueSthKyJweCI7dGhpcy5kaXYuc3R5bGUud2lkdGg9TWF0aC5tYXgoMSx0aGlzLndpZHRoKSsicHgiO3RoaXMuZGl2LnN0eWxlLmhlaWdodD1NYXRoLm1heCgxLAp0aGlzLmhlaWdodCkrInB4In19O214UnViYmVyYmFuZC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZGVzdHJveWVkfHwodGhpcy5kZXN0cm95ZWQ9ITAsdGhpcy5ncmFwaC5yZW1vdmVNb3VzZUxpc3RlbmVyKHRoaXMpLHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5mb3JjZVJ1YmJlcmJhbmRIYW5kbGVyKSx0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMucGFuSGFuZGxlciksdGhpcy5yZXNldCgpLG51bGwhPXRoaXMuc2hhcmVkRGl2JiYodGhpcy5zaGFyZWREaXY9bnVsbCkpfTtmdW5jdGlvbiBteEhhbmRsZShhLGIsYyxkKXt0aGlzLmdyYXBoPWEudmlldy5ncmFwaDt0aGlzLnN0YXRlPWE7dGhpcy5jdXJzb3I9bnVsbCE9Yj9iOnRoaXMuY3Vyc29yO3RoaXMuaW1hZ2U9bnVsbCE9Yz9jOnRoaXMuaW1hZ2U7dGhpcy5zaGFwZT1udWxsIT1kP2Q6bnVsbDt0aGlzLmluaXQoKX1teEhhbmRsZS5wcm90b3R5cGUuY3Vyc29yPSJkZWZhdWx0IjsKbXhIYW5kbGUucHJvdG90eXBlLmltYWdlPW51bGw7bXhIYW5kbGUucHJvdG90eXBlLmlnbm9yZUdyaWQ9ITE7bXhIYW5kbGUucHJvdG90eXBlLmdldFBvc2l0aW9uPWZ1bmN0aW9uKGEpe307bXhIYW5kbGUucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGEsYixjKXt9O214SGFuZGxlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe307bXhIYW5kbGUucHJvdG90eXBlLmNvcHlTdHlsZT1mdW5jdGlvbihhKXt0aGlzLmdyYXBoLnNldENlbGxTdHlsZXMoYSx0aGlzLnN0YXRlLnN0eWxlW2FdLFt0aGlzLnN0YXRlLmNlbGxdKX07Cm14SGFuZGxlLnByb3RvdHlwZS5wcm9jZXNzRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGM9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZSxjPW5ldyBteFBvaW50KGEuZ2V0R3JhcGhYKCkvYi1jLngsYS5nZXRHcmFwaFkoKS9iLWMueSk7bnVsbCE9dGhpcy5zaGFwZSYmbnVsbCE9dGhpcy5zaGFwZS5ib3VuZHMmJihjLngtPXRoaXMuc2hhcGUuYm91bmRzLndpZHRoL2IvNCxjLnktPXRoaXMuc2hhcGUuYm91bmRzLmhlaWdodC9iLzQpO3ZhciBiPS1teFV0aWxzLnRvUmFkaWFucyh0aGlzLmdldFJvdGF0aW9uKCkpLGQ9LW14VXRpbHMudG9SYWRpYW5zKHRoaXMuZ2V0VG90YWxSb3RhdGlvbigpKS1iLGM9dGhpcy5mbGlwUG9pbnQodGhpcy5yb3RhdGVQb2ludCh0aGlzLnNuYXBQb2ludCh0aGlzLnJvdGF0ZVBvaW50KGMsYiksdGhpcy5pZ25vcmVHcmlkfHwhdGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYS5nZXRFdmVudCgpKSksZCkpO3RoaXMuc2V0UG9zaXRpb24odGhpcy5zdGF0ZS5nZXRQYWludEJvdW5kcygpLApjLGEpO3RoaXMucG9zaXRpb25DaGFuZ2VkKCk7dGhpcy5yZWRyYXcoKX07bXhIYW5kbGUucHJvdG90eXBlLnBvc2l0aW9uQ2hhbmdlZD1mdW5jdGlvbigpe251bGwhPXRoaXMuc3RhdGUudGV4dCYmdGhpcy5zdGF0ZS50ZXh0LmFwcGx5KHRoaXMuc3RhdGUpO251bGwhPXRoaXMuc3RhdGUuc2hhcGUmJnRoaXMuc3RhdGUuc2hhcGUuYXBwbHkodGhpcy5zdGF0ZSk7dGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIucmVkcmF3KHRoaXMuc3RhdGUsITApfTtteEhhbmRsZS5wcm90b3R5cGUuZ2V0Um90YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZT90aGlzLnN0YXRlLnNoYXBlLmdldFJvdGF0aW9uKCk6MH07bXhIYW5kbGUucHJvdG90eXBlLmdldFRvdGFsUm90YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZT90aGlzLnN0YXRlLnNoYXBlLmdldFNoYXBlUm90YXRpb24oKTowfTsKbXhIYW5kbGUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmlzSHRtbFJlcXVpcmVkKCk7bnVsbCE9dGhpcy5pbWFnZT8odGhpcy5zaGFwZT1uZXcgbXhJbWFnZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsdGhpcy5pbWFnZS53aWR0aCx0aGlzLmltYWdlLmhlaWdodCksdGhpcy5pbWFnZS5zcmMpLHRoaXMuc2hhcGUucHJlc2VydmVJbWFnZUFzcGVjdD0hMSk6bnVsbD09dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGU9dGhpcy5jcmVhdGVTaGFwZShhKSk7dGhpcy5pbml0U2hhcGUoYSl9O214SGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbihhKXthPW5ldyBteFJlY3RhbmdsZSgwLDAsbXhDb25zdGFudHMuSEFORExFX1NJWkUsbXhDb25zdGFudHMuSEFORExFX1NJWkUpO3JldHVybiBuZXcgbXhSZWN0YW5nbGVTaGFwZShhLG14Q29uc3RhbnRzLkhBTkRMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuSEFORExFX1NUUk9LRUNPTE9SKX07Cm14SGFuZGxlLnByb3RvdHlwZS5pbml0U2hhcGU9ZnVuY3Rpb24oYSl7YSYmdGhpcy5zaGFwZS5pc0h0bWxBbGxvd2VkKCk/KHRoaXMuc2hhcGUuZGlhbGVjdD1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwsdGhpcy5zaGFwZS5pbml0KHRoaXMuZ3JhcGguY29udGFpbmVyKSk6KHRoaXMuc2hhcGUuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfTUlYRURIVE1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHLG51bGwhPXRoaXMuY3Vyc29yJiZ0aGlzLnNoYXBlLmluaXQodGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSkpO214RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyh0aGlzLnNoYXBlLm5vZGUsdGhpcy5ncmFwaCx0aGlzLnN0YXRlKTt0aGlzLnNoYXBlLm5vZGUuc3R5bGUuY3Vyc29yPXRoaXMuY3Vyc29yfTsKbXhIYW5kbGUucHJvdG90eXBlLnJlZHJhdz1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuc2hhcGUmJm51bGwhPXRoaXMuc3RhdGUuc2hhcGUpe3ZhciBhPXRoaXMuZ2V0UG9zaXRpb24odGhpcy5zdGF0ZS5nZXRQYWludEJvdW5kcygpKTtpZihudWxsIT1hKXt2YXIgYj1teFV0aWxzLnRvUmFkaWFucyh0aGlzLmdldFRvdGFsUm90YXRpb24oKSksYT10aGlzLnJvdGF0ZVBvaW50KHRoaXMuZmxpcFBvaW50KGEpLGIpLGI9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGM9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZTt0aGlzLnNoYXBlLmJvdW5kcy54PU1hdGguZmxvb3IoKGEueCtjLngpKmItdGhpcy5zaGFwZS5ib3VuZHMud2lkdGgvMik7dGhpcy5zaGFwZS5ib3VuZHMueT1NYXRoLmZsb29yKChhLnkrYy55KSpiLXRoaXMuc2hhcGUuYm91bmRzLmhlaWdodC8yKTt0aGlzLnNoYXBlLnJlZHJhdygpfX19OwpteEhhbmRsZS5wcm90b3R5cGUuaXNIdG1sUmVxdWlyZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5zdGF0ZS50ZXh0JiZ0aGlzLnN0YXRlLnRleHQubm9kZS5wYXJlbnROb2RlPT10aGlzLmdyYXBoLmNvbnRhaW5lcn07bXhIYW5kbGUucHJvdG90eXBlLnJvdGF0ZVBvaW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5zdGF0ZS5nZXRDZWxsQm91bmRzKCksYz1uZXcgbXhQb2ludChjLmdldENlbnRlclgoKSxjLmdldENlbnRlclkoKSk7cmV0dXJuIG14VXRpbHMuZ2V0Um90YXRlZFBvaW50KGEsTWF0aC5jb3MoYiksTWF0aC5zaW4oYiksYyl9OwpteEhhbmRsZS5wcm90b3R5cGUuZmxpcFBvaW50PWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuc3RhdGUuc2hhcGUpe3ZhciBiPXRoaXMuc3RhdGUuZ2V0Q2VsbEJvdW5kcygpO3RoaXMuc3RhdGUuc2hhcGUuZmxpcEgmJihhLng9MipiLngrYi53aWR0aC1hLngpO3RoaXMuc3RhdGUuc2hhcGUuZmxpcFYmJihhLnk9MipiLnkrYi5oZWlnaHQtYS55KX1yZXR1cm4gYX07bXhIYW5kbGUucHJvdG90eXBlLnNuYXBQb2ludD1mdW5jdGlvbihhLGIpe2J8fChhLng9dGhpcy5ncmFwaC5zbmFwKGEueCksYS55PXRoaXMuZ3JhcGguc25hcChhLnkpKTtyZXR1cm4gYX07bXhIYW5kbGUucHJvdG90eXBlLnNldFZpc2libGU9ZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5zaGFwZSYmbnVsbCE9dGhpcy5zaGFwZS5ub2RlJiYodGhpcy5zaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSIpfTsKbXhIYW5kbGUucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5zZXRWaXNpYmxlKCEwKTt0aGlzLnN0YXRlLnN0eWxlPXRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5wb3NpdGlvbkNoYW5nZWQoKX07bXhIYW5kbGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5kZXN0cm95KCksdGhpcy5zaGFwZT1udWxsKX07CmZ1bmN0aW9uIG14VmVydGV4SGFuZGxlcihhKXtudWxsIT1hJiYodGhpcy5zdGF0ZT1hLHRoaXMuaW5pdCgpLHRoaXMuZXNjYXBlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3RoaXMubGl2ZVByZXZpZXcmJm51bGwhPXRoaXMuaW5kZXgmJih0aGlzLnN0YXRlLnZpZXcuZ3JhcGguY2VsbFJlbmRlcmVyLnJlZHJhdyh0aGlzLnN0YXRlLCEwKSx0aGlzLnN0YXRlLnZpZXcuaW52YWxpZGF0ZSh0aGlzLnN0YXRlLmNlbGwpLHRoaXMuc3RhdGUuaW52YWxpZD0hMSx0aGlzLnN0YXRlLnZpZXcudmFsaWRhdGUoKSk7dGhpcy5yZXNldCgpfSksdGhpcy5zdGF0ZS52aWV3LmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLHRoaXMuZXNjYXBlSGFuZGxlcikpfW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnN0YXRlPW51bGw7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5zaW5nbGVTaXplcj0hMTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pbmRleD1udWxsO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuYWxsb3dIYW5kbGVCb3VuZHNDaGVjaz0hMDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUltYWdlPW51bGw7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS50b2xlcmFuY2U9MDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0aW9uRW5hYmxlZD0hMTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnBhcmVudEhpZ2hsaWdodEVuYWJsZWQ9ITE7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGlvblJhc3Rlcj0hMDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0aW9uQ3Vyc29yPSJjcm9zc2hhaXIiO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubGl2ZVByZXZpZXc9ITE7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tYW5hZ2VTaXplcnM9ITE7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJhaW5Hcm91cEJ5Q2hpbGRyZW49ITE7Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUucm90YXRpb25IYW5kbGVWU3BhY2luZz0tMTY7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5ob3Jpem9udGFsT2Zmc2V0PTA7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS52ZXJ0aWNhbE9mZnNldD0wOwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmdyYXBoPXRoaXMuc3RhdGUudmlldy5ncmFwaDt0aGlzLnNlbGVjdGlvbkJvdW5kcz10aGlzLmdldFNlbGVjdGlvbkJvdW5kcyh0aGlzLnN0YXRlKTt0aGlzLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUodGhpcy5zZWxlY3Rpb25Cb3VuZHMueCx0aGlzLnNlbGVjdGlvbkJvdW5kcy55LHRoaXMuc2VsZWN0aW9uQm91bmRzLndpZHRoLHRoaXMuc2VsZWN0aW9uQm91bmRzLmhlaWdodCk7dGhpcy5zZWxlY3Rpb25Cb3JkZXI9dGhpcy5jcmVhdGVTZWxlY3Rpb25TaGFwZSh0aGlzLmJvdW5kcyk7dGhpcy5zZWxlY3Rpb25Cb3JkZXIuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfVk1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnBvaW50ZXJFdmVudHM9ITE7dGhpcy5zZWxlY3Rpb25Cb3JkZXIucm90YXRpb249Ck51bWJlcih0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKTt0aGlzLnNlbGVjdGlvbkJvcmRlci5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpO214RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyh0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLHRoaXMuZ3JhcGgsdGhpcy5zdGF0ZSk7dGhpcy5ncmFwaC5pc0NlbGxNb3ZhYmxlKHRoaXMuc3RhdGUuY2VsbCkmJnRoaXMuc2VsZWN0aW9uQm9yZGVyLnNldEN1cnNvcihteENvbnN0YW50cy5DVVJTT1JfTU9WQUJMRV9WRVJURVgpO2lmKDA+PW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxsc3x8dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpPG14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxscyl7dmFyIGE9dGhpcy5ncmFwaC5pc0NlbGxSZXNpemFibGUodGhpcy5zdGF0ZS5jZWxsKTt0aGlzLnNpemVycz1bXTtpZihhfHx0aGlzLmdyYXBoLmlzTGFiZWxNb3ZhYmxlKHRoaXMuc3RhdGUuY2VsbCkmJgoyPD10aGlzLnN0YXRlLndpZHRoJiYyPD10aGlzLnN0YXRlLmhlaWdodCl7dmFyIGI9MDthJiYodGhpcy5zaW5nbGVTaXplcnx8KHRoaXMuc2l6ZXJzLnB1c2godGhpcy5jcmVhdGVTaXplcigibnctcmVzaXplIixiKyspKSx0aGlzLnNpemVycy5wdXNoKHRoaXMuY3JlYXRlU2l6ZXIoIm4tcmVzaXplIixiKyspKSx0aGlzLnNpemVycy5wdXNoKHRoaXMuY3JlYXRlU2l6ZXIoIm5lLXJlc2l6ZSIsYisrKSksdGhpcy5zaXplcnMucHVzaCh0aGlzLmNyZWF0ZVNpemVyKCJ3LXJlc2l6ZSIsYisrKSksdGhpcy5zaXplcnMucHVzaCh0aGlzLmNyZWF0ZVNpemVyKCJlLXJlc2l6ZSIsYisrKSksdGhpcy5zaXplcnMucHVzaCh0aGlzLmNyZWF0ZVNpemVyKCJzdy1yZXNpemUiLGIrKykpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5jcmVhdGVTaXplcigicy1yZXNpemUiLGIrKykpKSx0aGlzLnNpemVycy5wdXNoKHRoaXMuY3JlYXRlU2l6ZXIoInNlLXJlc2l6ZSIsYisrKSkpO2E9dGhpcy5ncmFwaC5tb2RlbC5nZXRHZW9tZXRyeSh0aGlzLnN0YXRlLmNlbGwpOwpudWxsPT1hfHxhLnJlbGF0aXZlfHx0aGlzLmdyYXBoLmlzU3dpbWxhbmUodGhpcy5zdGF0ZS5jZWxsKXx8IXRoaXMuZ3JhcGguaXNMYWJlbE1vdmFibGUodGhpcy5zdGF0ZS5jZWxsKXx8KHRoaXMubGFiZWxTaGFwZT10aGlzLmNyZWF0ZVNpemVyKG14Q29uc3RhbnRzLkNVUlNPUl9MQUJFTF9IQU5ETEUsbXhFdmVudC5MQUJFTF9IQU5ETEUsbXhDb25zdGFudHMuTEFCRUxfSEFORExFX1NJWkUsbXhDb25zdGFudHMuTEFCRUxfSEFORExFX0ZJTExDT0xPUiksdGhpcy5zaXplcnMucHVzaCh0aGlzLmxhYmVsU2hhcGUpKX1lbHNlIHRoaXMuZ3JhcGguaXNDZWxsTW92YWJsZSh0aGlzLnN0YXRlLmNlbGwpJiYhdGhpcy5ncmFwaC5pc0NlbGxSZXNpemFibGUodGhpcy5zdGF0ZS5jZWxsKSYmMj50aGlzLnN0YXRlLndpZHRoJiYyPnRoaXMuc3RhdGUuaGVpZ2h0JiYodGhpcy5sYWJlbFNoYXBlPXRoaXMuY3JlYXRlU2l6ZXIobXhDb25zdGFudHMuQ1VSU09SX01PVkFCTEVfVkVSVEVYLG14RXZlbnQuTEFCRUxfSEFORExFLApudWxsLG14Q29uc3RhbnRzLkxBQkVMX0hBTkRMRV9GSUxMQ09MT1IpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5sYWJlbFNoYXBlKSl9dGhpcy5pc1JvdGF0aW9uSGFuZGxlVmlzaWJsZSgpJiYodGhpcy5yb3RhdGlvblNoYXBlPXRoaXMuY3JlYXRlU2l6ZXIodGhpcy5yb3RhdGlvbkN1cnNvcixteEV2ZW50LlJPVEFUSU9OX0hBTkRMRSxteENvbnN0YW50cy5IQU5ETEVfU0laRSszLG14Q29uc3RhbnRzLkhBTkRMRV9GSUxMQ09MT1IpLHRoaXMuc2l6ZXJzLnB1c2godGhpcy5yb3RhdGlvblNoYXBlKSk7dGhpcy5jdXN0b21IYW5kbGVzPXRoaXMuY3JlYXRlQ3VzdG9tSGFuZGxlcygpO3RoaXMucmVkcmF3KCk7dGhpcy5jb25zdHJhaW5Hcm91cEJ5Q2hpbGRyZW4mJnRoaXMudXBkYXRlTWluQm91bmRzKCl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzUm90YXRpb25IYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGguaXNFbmFibGVkKCkmJnRoaXMucm90YXRpb25FbmFibGVkJiZ0aGlzLmdyYXBoLmlzQ2VsbFJvdGF0YWJsZSh0aGlzLnN0YXRlLmNlbGwpJiYoMD49bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1heENlbGxzfHx0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk8bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1heENlbGxzKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc0NvbnN0cmFpbmVkRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNTaGlmdERvd24oYS5nZXRFdmVudCgpKXx8ImZpeGVkIj09dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9BU1BFQ1RdfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzQ2VudGVyZWRFdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiExfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVDdXN0b21IYW5kbGVzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZU1pbkJvdW5kcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguZ2V0Q2hpbGRDZWxscyh0aGlzLnN0YXRlLmNlbGwpO2lmKDA8YS5sZW5ndGgmJih0aGlzLm1pbkJvdW5kcz10aGlzLmdyYXBoLnZpZXcuZ2V0Qm91bmRzKGEpLG51bGwhPXRoaXMubWluQm91bmRzKSl7dmFyIGE9dGhpcy5zdGF0ZS52aWV3LnNjYWxlLGI9dGhpcy5zdGF0ZS52aWV3LnRyYW5zbGF0ZTt0aGlzLm1pbkJvdW5kcy54LT10aGlzLnN0YXRlLng7dGhpcy5taW5Cb3VuZHMueS09dGhpcy5zdGF0ZS55O3RoaXMubWluQm91bmRzLngvPWE7dGhpcy5taW5Cb3VuZHMueS89YTt0aGlzLm1pbkJvdW5kcy53aWR0aC89YTt0aGlzLm1pbkJvdW5kcy5oZWlnaHQvPWE7dGhpcy54MD10aGlzLnN0YXRlLngvYS1iLng7dGhpcy55MD10aGlzLnN0YXRlLnkvYS1iLnl9fTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Cb3VuZHM9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKGEueCksTWF0aC5yb3VuZChhLnkpLE1hdGgucm91bmQoYS53aWR0aCksTWF0aC5yb3VuZChhLmhlaWdodCkpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVBhcmVudEhpZ2hsaWdodFNoYXBlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmNyZWF0ZVNlbGVjdGlvblNoYXBlKGEpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVNlbGVjdGlvblNoYXBlPWZ1bmN0aW9uKGEpe2E9bmV3IG14UmVjdGFuZ2xlU2hhcGUobXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShhKSxudWxsLHRoaXMuZ2V0U2VsZWN0aW9uQ29sb3IoKSk7YS5zdHJva2V3aWR0aD10aGlzLmdldFNlbGVjdGlvblN0cm9rZVdpZHRoKCk7YS5pc0Rhc2hlZD10aGlzLmlzU2VsZWN0aW9uRGFzaGVkKCk7cmV0dXJuIGF9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbkNvbG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG14Q29uc3RhbnRzLlZFUlRFWF9TRUxFQ1RJT05fQ09MT1J9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uU3Ryb2tlV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuVkVSVEVYX1NFTEVDVElPTl9TVFJPS0VXSURUSH07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1NlbGVjdGlvbkRhc2hlZD1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5WRVJURVhfU0VMRUNUSU9OX0RBU0hFRH07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2l6ZXI9ZnVuY3Rpb24oYSxiLGMsZCl7Yz1jfHxteENvbnN0YW50cy5IQU5ETEVfU0laRTtjPW5ldyBteFJlY3RhbmdsZSgwLDAsYyxjKTtkPXRoaXMuY3JlYXRlU2l6ZXJTaGFwZShjLGIsZCk7ZC5pc0h0bWxBbGxvd2VkKCkmJm51bGwhPXRoaXMuc3RhdGUudGV4dCYmdGhpcy5zdGF0ZS50ZXh0Lm5vZGUucGFyZW50Tm9kZT09dGhpcy5ncmFwaC5jb250YWluZXI/KC0tZC5ib3VuZHMuaGVpZ2h0LC0tZC5ib3VuZHMud2lkdGgsZC5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxkLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooZC5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9NSVhFREhUTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsZC5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpKTsKbXhFdmVudC5yZWRpcmVjdE1vdXNlRXZlbnRzKGQubm9kZSx0aGlzLmdyYXBoLHRoaXMuc3RhdGUpO3RoaXMuZ3JhcGguaXNFbmFibGVkKCkmJmQuc2V0Q3Vyc29yKGEpO3RoaXMuaXNTaXplclZpc2libGUoYil8fChkLnZpc2libGU9ITEpO3JldHVybiBkfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzU2l6ZXJWaXNpYmxlPWZ1bmN0aW9uKGEpe3JldHVybiEwfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVTaXplclNoYXBlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbnVsbCE9dGhpcy5oYW5kbGVJbWFnZT8oYT1uZXcgbXhSZWN0YW5nbGUoYS54LGEueSx0aGlzLmhhbmRsZUltYWdlLndpZHRoLHRoaXMuaGFuZGxlSW1hZ2UuaGVpZ2h0KSxhPW5ldyBteEltYWdlU2hhcGUoYSx0aGlzLmhhbmRsZUltYWdlLnNyYyksYS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExLGEpOmI9PW14RXZlbnQuUk9UQVRJT05fSEFORExFP25ldyBteEVsbGlwc2UoYSxjfHxteENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUik6bmV3IG14UmVjdGFuZ2xlU2hhcGUoYSxjfHxteENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUil9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdmVTaXplclRvPWZ1bmN0aW9uKGEsYixjKXtudWxsIT1hJiYoYS5ib3VuZHMueD1NYXRoLmZsb29yKGItYS5ib3VuZHMud2lkdGgvMiksYS5ib3VuZHMueT1NYXRoLmZsb29yKGMtYS5ib3VuZHMuaGVpZ2h0LzIpLG51bGwhPWEubm9kZSYmIm5vbmUiIT1hLm5vZGUuc3R5bGUuZGlzcGxheSYmYS5yZWRyYXcoKSl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldEhhbmRsZUZvckV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPW14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSk/MTp0aGlzLnRvbGVyYW5jZSxjPXRoaXMuYWxsb3dIYW5kbGVCb3VuZHNDaGVjayYmKG14Q2xpZW50LklTX0lFfHwwPGIpP25ldyBteFJlY3RhbmdsZShhLmdldEdyYXBoWCgpLWIsYS5nZXRHcmFwaFkoKS1iLDIqYiwyKmIpOm51bGwsYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgZD1udWxsIT1iJiZiLmNvbnN0cnVjdG9yIT1teEltYWdlU2hhcGUmJnRoaXMuYWxsb3dIYW5kbGVCb3VuZHNDaGVjaz9uZXcgbXhSZWN0YW5nbGUoYS5nZXRHcmFwaFgoKS1iLnN2Z1N0cm9rZVRvbGVyYW5jZSxhLmdldEdyYXBoWSgpLWIuc3ZnU3Ryb2tlVG9sZXJhbmNlLDIqYi5zdmdTdHJva2VUb2xlcmFuY2UsMipiLnN2Z1N0cm9rZVRvbGVyYW5jZSk6YztyZXR1cm4gbnVsbCE9YiYmKGEuaXNTb3VyY2UoYil8fG51bGwhPQpkJiZteFV0aWxzLmludGVyc2VjdHMoYi5ib3VuZHMsZCkmJiJub25lIiE9Yi5ub2RlLnN0eWxlLmRpc3BsYXkmJiJoaWRkZW4iIT1iLm5vZGUuc3R5bGUudmlzaWJpbGl0eSl9KTtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJnRoaXMuaXNDdXN0b21IYW5kbGVFdmVudChhKSlmb3IodmFyIGQ9dGhpcy5jdXN0b21IYW5kbGVzLmxlbmd0aC0xOzA8PWQ7ZC0tKWlmKGIodGhpcy5jdXN0b21IYW5kbGVzW2RdLnNoYXBlKSlyZXR1cm4gbXhFdmVudC5DVVNUT01fSEFORExFLWQ7aWYoYih0aGlzLnJvdGF0aW9uU2hhcGUpKXJldHVybiBteEV2ZW50LlJPVEFUSU9OX0hBTkRMRTtpZihiKHRoaXMubGFiZWxTaGFwZSkpcmV0dXJuIG14RXZlbnQuTEFCRUxfSEFORExFO2lmKG51bGwhPXRoaXMuc2l6ZXJzKWZvcihkPTA7ZDx0aGlzLnNpemVycy5sZW5ndGg7ZCsrKWlmKGIodGhpcy5zaXplcnNbZF0pKXJldHVybiBkO3JldHVybiBudWxsfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc0N1c3RvbUhhbmRsZUV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiEwfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe2lmKCFiLmlzQ29uc3VtZWQoKSYmdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSl7dmFyIGM9dGhpcy5nZXRIYW5kbGVGb3JFdmVudChiKTtudWxsIT1jJiYodGhpcy5zdGFydChiLmdldEdyYXBoWCgpLGIuZ2V0R3JhcGhZKCksYyksYi5jb25zdW1lKCkpfX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc0xpdmVQcmV2aWV3Qm9yZGVyPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUuc2hhcGUmJm51bGw9PXRoaXMuc3RhdGUuc2hhcGUuZmlsbCYmbnVsbD09dGhpcy5zdGF0ZS5zaGFwZS5zdHJva2V9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT10aGlzLnNlbGVjdGlvbkJvcmRlcil7dGhpcy5saXZlUHJldmlld0FjdGl2ZT10aGlzLmxpdmVQcmV2aWV3JiYwPT10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQodGhpcy5zdGF0ZS5jZWxsKTt0aGlzLmluVG9sZXJhbmNlPSEwO3RoaXMuY2hpbGRPZmZzZXRZPXRoaXMuY2hpbGRPZmZzZXRYPTA7dGhpcy5pbmRleD1jO3RoaXMuc3RhcnRYPWE7dGhpcy5zdGFydFk9YjthPXRoaXMuc3RhdGUudmlldy5ncmFwaC5tb2RlbDtiPWEuZ2V0UGFyZW50KHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5zdGF0ZS52aWV3LmN1cnJlbnRSb290IT1iJiYoYS5pc1ZlcnRleChiKXx8YS5pc0VkZ2UoYikpJiYodGhpcy5wYXJlbnRTdGF0ZT10aGlzLnN0YXRlLnZpZXcuZ3JhcGgudmlldy5nZXRTdGF0ZShiKSk7dGhpcy5zZWxlY3Rpb25Cb3JkZXIubm9kZS5zdHlsZS5kaXNwbGF5PWM9PW14RXZlbnQuUk9UQVRJT05fSEFORExFPwoiaW5saW5lIjoibm9uZSI7aWYoIXRoaXMubGl2ZVByZXZpZXdBY3RpdmV8fHRoaXMuaXNMaXZlUHJldmlld0JvcmRlcigpKXRoaXMucHJldmlldz10aGlzLmNyZWF0ZVNlbGVjdGlvblNoYXBlKHRoaXMuYm91bmRzKSxteENsaWVudC5JU19TVkcmJjAhPU51bWJlcih0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKXx8bnVsbD09dGhpcy5zdGF0ZS50ZXh0fHx0aGlzLnN0YXRlLnRleHQubm9kZS5wYXJlbnROb2RlIT10aGlzLmdyYXBoLmNvbnRhaW5lcj8odGhpcy5wcmV2aWV3LmRpYWxlY3Q9dGhpcy5ncmFwaC5kaWFsZWN0IT1teENvbnN0YW50cy5ESUFMRUNUX1NWRz9teENvbnN0YW50cy5ESUFMRUNUX1ZNTDpteENvbnN0YW50cy5ESUFMRUNUX1NWRyx0aGlzLnByZXZpZXcuaW5pdCh0aGlzLmdyYXBoLnZpZXcuZ2V0T3ZlcmxheVBhbmUoKSkpOih0aGlzLnByZXZpZXcuZGlhbGVjdD1teENvbnN0YW50cy5ESUFMRUNUX1NUUklDVEhUTUwsdGhpcy5wcmV2aWV3LmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTsKYz09bXhFdmVudC5ST1RBVElPTl9IQU5ETEUmJihiPXRoaXMuZ2V0Um90YXRpb25IYW5kbGVQb3NpdGlvbigpLGE9Yi54LXRoaXMuc3RhdGUuZ2V0Q2VudGVyWCgpLGI9Yi55LXRoaXMuc3RhdGUuZ2V0Q2VudGVyWSgpLHRoaXMuc3RhcnRBbmdsZT0wIT1hPzE4MCpNYXRoLmF0YW4oYi9hKS9NYXRoLlBJKzkwOjA+Yj8xODA6MCx0aGlzLnN0YXJ0RGlzdD1NYXRoLnNxcnQoYSphK2IqYikpO2lmKHRoaXMubGl2ZVByZXZpZXdBY3RpdmUpZm9yKHRoaXMuaGlkZVNpemVycygpLGM9PW14RXZlbnQuUk9UQVRJT05fSEFORExFP3RoaXMucm90YXRpb25TaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXk9IiI6Yz09bXhFdmVudC5MQUJFTF9IQU5ETEU/dGhpcy5sYWJlbFNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheT0iIjpudWxsIT10aGlzLnNpemVycyYmbnVsbCE9dGhpcy5zaXplcnNbY10/dGhpcy5zaXplcnNbY10ubm9kZS5zdHlsZS5kaXNwbGF5PSIiOmM8PW14RXZlbnQuQ1VTVE9NX0hBTkRMRSYmCm51bGwhPXRoaXMuY3VzdG9tSGFuZGxlcyYmdGhpcy5jdXN0b21IYW5kbGVzW214RXZlbnQuQ1VTVE9NX0hBTkRMRS1jXS5zZXRWaXNpYmxlKCEwKSxjPXRoaXMuZ3JhcGguZ2V0RWRnZXModGhpcy5zdGF0ZS5jZWxsKSx0aGlzLmVkZ2VIYW5kbGVycz1bXSxhPTA7YTxjLmxlbmd0aDthKyspYj10aGlzLmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKGNbYV0pLG51bGwhPWImJnRoaXMuZWRnZUhhbmRsZXJzLnB1c2goYil9fTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuc2l6ZXJzKWZvcih2YXIgYj0wO2I8dGhpcy5zaXplcnMubGVuZ3RoO2IrKyl0aGlzLnNpemVyc1tiXS5ub2RlLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSI7aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKWZvcihiPTA7Yjx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2IrKyl0aGlzLmN1c3RvbUhhbmRsZXNbYl0uc2V0VmlzaWJsZShhKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaGlkZVNpemVycz1mdW5jdGlvbigpe3RoaXMuc2V0SGFuZGxlc1Zpc2libGUoITEpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNoZWNrVG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3RoaXMuaW5Ub2xlcmFuY2UmJm51bGwhPXRoaXMuc3RhcnRYJiZudWxsIT10aGlzLnN0YXJ0WSYmKG14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSl8fE1hdGguYWJzKGEuZ2V0R3JhcGhYKCktdGhpcy5zdGFydFgpPnRoaXMuZ3JhcGgudG9sZXJhbmNlfHxNYXRoLmFicyhhLmdldEdyYXBoWSgpLXRoaXMuc3RhcnRZKT50aGlzLmdyYXBoLnRvbGVyYW5jZSkmJih0aGlzLmluVG9sZXJhbmNlPSExKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVIaW50PWZ1bmN0aW9uKGEpe307bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVIaW50PWZ1bmN0aW9uKCl7fTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3VuZEFuZ2xlPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnJvdW5kKDEwKmEpLzEwfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdW5kTGVuZ3RoPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnJvdW5kKDEwMCphKS8xMDB9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe2IuaXNDb25zdW1lZCgpfHxudWxsPT10aGlzLmluZGV4P3RoaXMuZ3JhcGguaXNNb3VzZURvd258fG51bGw9PXRoaXMuZ2V0SGFuZGxlRm9yRXZlbnQoYil8fGIuY29uc3VtZSghMSk6KHRoaXMuY2hlY2tUb2xlcmFuY2UoYiksdGhpcy5pblRvbGVyYW5jZXx8KHRoaXMuaW5kZXg8PW14RXZlbnQuQ1VTVE9NX0hBTkRMRT9udWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJih0aGlzLmN1c3RvbUhhbmRsZXNbbXhFdmVudC5DVVNUT01fSEFORExFLXRoaXMuaW5kZXhdLnByb2Nlc3NFdmVudChiKSx0aGlzLmN1c3RvbUhhbmRsZXNbbXhFdmVudC5DVVNUT01fSEFORExFLXRoaXMuaW5kZXhdLmFjdGl2ZT0hMCx0aGlzLmlzTW92ZUN1c3RvbUhhbmRsZVByZXZpZXdUb0Zyb250KHRoaXMuY3VzdG9tSGFuZGxlc1tteEV2ZW50LkNVU1RPTV9IQU5ETEUtdGhpcy5pbmRleF0pJiZ0aGlzLm1vdmVUb0Zyb250KCkpOgp0aGlzLmluZGV4PT1teEV2ZW50LkxBQkVMX0hBTkRMRT90aGlzLm1vdmVMYWJlbChiKTp0aGlzLmluZGV4PT1teEV2ZW50LlJPVEFUSU9OX0hBTkRMRT90aGlzLnJvdGF0ZVZlcnRleChiKToodGhpcy5yZXNpemVWZXJ0ZXgoYiksdGhpcy51cGRhdGVIaW50KGIpKSksYi5jb25zdW1lKCkpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzTW92ZUN1c3RvbUhhbmRsZVByZXZpZXdUb0Zyb250PWZ1bmN0aW9uKGEpe3JldHVybiExfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlTGFiZWw9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14UG9pbnQoYS5nZXRHcmFwaFgoKSxhLmdldEdyYXBoWSgpKSxjPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZD10aGlzLmdyYXBoLnZpZXcuc2NhbGU7dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYS5nZXRFdmVudCgpKSYmKGIueD0odGhpcy5ncmFwaC5zbmFwKGIueC9kLWMueCkrYy54KSpkLGIueT0odGhpcy5ncmFwaC5zbmFwKGIueS9kLWMueSkrYy55KSpkKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzW251bGwhPXRoaXMucm90YXRpb25TaGFwZT90aGlzLnNpemVycy5sZW5ndGgtMjp0aGlzLnNpemVycy5sZW5ndGgtMV0sYi54LGIueSl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0ZVZlcnRleD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgbXhQb2ludChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCkpLGM9dGhpcy5zdGF0ZS54K3RoaXMuc3RhdGUud2lkdGgvMi1iLngsZD10aGlzLnN0YXRlLnkrdGhpcy5zdGF0ZS5oZWlnaHQvMi1iLnk7dGhpcy5jdXJyZW50QWxwaGE9MCE9Yz8xODAqTWF0aC5hdGFuKGQvYykvTWF0aC5QSSs5MDowPmQ/MTgwOjA7MDxjJiYodGhpcy5jdXJyZW50QWxwaGEtPTE4MCk7dGhpcy5jdXJyZW50QWxwaGEtPXRoaXMuc3RhcnRBbmdsZTt0aGlzLnJvdGF0aW9uUmFzdGVyJiZ0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWRFdmVudChhLmdldEV2ZW50KCkpPyhjPWIueC10aGlzLnN0YXRlLmdldENlbnRlclgoKSxkPWIueS10aGlzLnN0YXRlLmdldENlbnRlclkoKSxhPU1hdGguc3FydChjKmMrZCpkKSxyYXN0ZXI9Mj5hLXRoaXMuc3RhcnREaXN0PzE1OjI1PmEtdGhpcy5zdGFydERpc3Q/NToKMSx0aGlzLmN1cnJlbnRBbHBoYT1NYXRoLnJvdW5kKHRoaXMuY3VycmVudEFscGhhL3Jhc3RlcikqcmFzdGVyKTp0aGlzLmN1cnJlbnRBbHBoYT10aGlzLnJvdW5kQW5nbGUodGhpcy5jdXJyZW50QWxwaGEpO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnJvdGF0aW9uPXRoaXMuY3VycmVudEFscGhhO3RoaXMuc2VsZWN0aW9uQm9yZGVyLnJlZHJhdygpO3RoaXMubGl2ZVByZXZpZXdBY3RpdmUmJnRoaXMucmVkcmF3SGFuZGxlcygpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZXNpemVWZXJ0ZXg9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IG14UG9pbnQodGhpcy5zdGF0ZS5nZXRDZW50ZXJYKCksdGhpcy5zdGF0ZS5nZXRDZW50ZXJZKCkpLGM9bXhVdGlscy50b1JhZGlhbnModGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksZD1uZXcgbXhQb2ludChhLmdldEdyYXBoWCgpLGEuZ2V0R3JhcGhZKCkpLGU9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZSxmPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxnPU1hdGguY29zKC1jKSxrPU1hdGguc2luKC1jKSxsPWQueC10aGlzLnN0YXJ0WCxtPWQueS10aGlzLnN0YXJ0WSxkPWsqbCtnKm0sbD1nKmwtayptLG09ZCxnPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCk7dGhpcy51bnNjYWxlZEJvdW5kcz10aGlzLnVuaW9uKGcsbC9mLG0vZix0aGlzLmluZGV4LHRoaXMuZ3JhcGguaXNHcmlkRW5hYmxlZEV2ZW50KGEuZ2V0RXZlbnQoKSksCjEsbmV3IG14UG9pbnQoMCwwKSx0aGlzLmlzQ29uc3RyYWluZWRFdmVudChhKSx0aGlzLmlzQ2VudGVyZWRFdmVudCh0aGlzLnN0YXRlLGEpKTtnLnJlbGF0aXZlfHwoaz10aGlzLmdyYXBoLmdldE1heGltdW1HcmFwaEJvdW5kcygpLG51bGwhPWsmJm51bGwhPXRoaXMucGFyZW50U3RhdGUmJihrPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoayksay54LT0odGhpcy5wYXJlbnRTdGF0ZS54LWUueCpmKS9mLGsueS09KHRoaXMucGFyZW50U3RhdGUueS1lLnkqZikvZiksdGhpcy5ncmFwaC5pc0NvbnN0cmFpbkNoaWxkKHRoaXMuc3RhdGUuY2VsbCkmJihkPXRoaXMuZ3JhcGguZ2V0Q2VsbENvbnRhaW5tZW50QXJlYSh0aGlzLnN0YXRlLmNlbGwpLG51bGwhPWQmJihsPXRoaXMuZ3JhcGguZ2V0T3ZlcmxhcCh0aGlzLnN0YXRlLmNlbGwpLDA8bCYmKGQ9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShkKSxkLngtPWQud2lkdGgqbCxkLnktPWQuaGVpZ2h0KmwsZC53aWR0aCs9MipkLndpZHRoKgpsLGQuaGVpZ2h0Kz0yKmQuaGVpZ2h0KmwpLG51bGw9PWs/az1kOihrPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoayksay5pbnRlcnNlY3QoZCkpKSksbnVsbCE9ayYmKHRoaXMudW5zY2FsZWRCb3VuZHMueDxrLngmJih0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoLT1rLngtdGhpcy51bnNjYWxlZEJvdW5kcy54LHRoaXMudW5zY2FsZWRCb3VuZHMueD1rLngpLHRoaXMudW5zY2FsZWRCb3VuZHMueTxrLnkmJih0aGlzLnVuc2NhbGVkQm91bmRzLmhlaWdodC09ay55LXRoaXMudW5zY2FsZWRCb3VuZHMueSx0aGlzLnVuc2NhbGVkQm91bmRzLnk9ay55KSx0aGlzLnVuc2NhbGVkQm91bmRzLngrdGhpcy51bnNjYWxlZEJvdW5kcy53aWR0aD5rLngray53aWR0aCYmKHRoaXMudW5zY2FsZWRCb3VuZHMud2lkdGgtPXRoaXMudW5zY2FsZWRCb3VuZHMueCt0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoLWsueC1rLndpZHRoKSx0aGlzLnVuc2NhbGVkQm91bmRzLnkrdGhpcy51bnNjYWxlZEJvdW5kcy5oZWlnaHQ+CmsueStrLmhlaWdodCYmKHRoaXMudW5zY2FsZWRCb3VuZHMuaGVpZ2h0LT10aGlzLnVuc2NhbGVkQm91bmRzLnkrdGhpcy51bnNjYWxlZEJvdW5kcy5oZWlnaHQtay55LWsuaGVpZ2h0KSkpO2Q9dGhpcy5ib3VuZHM7dGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKChudWxsIT10aGlzLnBhcmVudFN0YXRlP3RoaXMucGFyZW50U3RhdGUueDplLngqZikrdGhpcy51bnNjYWxlZEJvdW5kcy54KmYsKG51bGwhPXRoaXMucGFyZW50U3RhdGU/dGhpcy5wYXJlbnRTdGF0ZS55OmUueSpmKSt0aGlzLnVuc2NhbGVkQm91bmRzLnkqZix0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoKmYsdGhpcy51bnNjYWxlZEJvdW5kcy5oZWlnaHQqZik7Zy5yZWxhdGl2ZSYmbnVsbCE9dGhpcy5wYXJlbnRTdGF0ZSYmKHRoaXMuYm91bmRzLngrPXRoaXMuc3RhdGUueC10aGlzLnBhcmVudFN0YXRlLngsdGhpcy5ib3VuZHMueSs9dGhpcy5zdGF0ZS55LXRoaXMucGFyZW50U3RhdGUueSk7Zz1NYXRoLmNvcyhjKTsKaz1NYXRoLnNpbihjKTtjPW5ldyBteFBvaW50KHRoaXMuYm91bmRzLmdldENlbnRlclgoKSx0aGlzLmJvdW5kcy5nZXRDZW50ZXJZKCkpO2w9Yy54LWIueDttPWMueS1iLnk7Yj1nKmwtayptLWw7Yz1rKmwrZyptLW07bD10aGlzLmJvdW5kcy54LXRoaXMuc3RhdGUueDttPXRoaXMuYm91bmRzLnktdGhpcy5zdGF0ZS55O2U9ZypsLWsqbTtnPWsqbCtnKm07dGhpcy5ib3VuZHMueCs9Yjt0aGlzLmJvdW5kcy55Kz1jO3RoaXMudW5zY2FsZWRCb3VuZHMueD10aGlzLnJvdW5kTGVuZ3RoKHRoaXMudW5zY2FsZWRCb3VuZHMueCtiL2YpO3RoaXMudW5zY2FsZWRCb3VuZHMueT10aGlzLnJvdW5kTGVuZ3RoKHRoaXMudW5zY2FsZWRCb3VuZHMueStjL2YpO3RoaXMudW5zY2FsZWRCb3VuZHMud2lkdGg9dGhpcy5yb3VuZExlbmd0aCh0aGlzLnVuc2NhbGVkQm91bmRzLndpZHRoKTt0aGlzLnVuc2NhbGVkQm91bmRzLmhlaWdodD10aGlzLnJvdW5kTGVuZ3RoKHRoaXMudW5zY2FsZWRCb3VuZHMuaGVpZ2h0KTsKdGhpcy5ncmFwaC5pc0NlbGxDb2xsYXBzZWQodGhpcy5zdGF0ZS5jZWxsKXx8MD09YiYmMD09Yz90aGlzLmNoaWxkT2Zmc2V0WT10aGlzLmNoaWxkT2Zmc2V0WD0wOih0aGlzLmNoaWxkT2Zmc2V0WD10aGlzLnN0YXRlLngtdGhpcy5ib3VuZHMueCtlLHRoaXMuY2hpbGRPZmZzZXRZPXRoaXMuc3RhdGUueS10aGlzLmJvdW5kcy55K2cpO2QuZXF1YWxzKHRoaXMuYm91bmRzKXx8KHRoaXMubGl2ZVByZXZpZXdBY3RpdmUmJnRoaXMudXBkYXRlTGl2ZVByZXZpZXcoYSksbnVsbCE9dGhpcy5wcmV2aWV3P3RoaXMuZHJhd1ByZXZpZXcoKTp0aGlzLnVwZGF0ZVBhcmVudEhpZ2hsaWdodCgpKX07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUudXBkYXRlTGl2ZVByZXZpZXc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC52aWV3LnNjYWxlLGM9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZTthPXRoaXMuc3RhdGUuY2xvbmUoKTt0aGlzLnN0YXRlLng9dGhpcy5ib3VuZHMueDt0aGlzLnN0YXRlLnk9dGhpcy5ib3VuZHMueTt0aGlzLnN0YXRlLm9yaWdpbj1uZXcgbXhQb2ludCh0aGlzLnN0YXRlLngvYi1jLngsdGhpcy5zdGF0ZS55L2ItYy55KTt0aGlzLnN0YXRlLndpZHRoPXRoaXMuYm91bmRzLndpZHRoO3RoaXMuc3RhdGUuaGVpZ2h0PXRoaXMuYm91bmRzLmhlaWdodDtiPXRoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQ7bmV3IG14UG9pbnQoYi54LGIueSk7dGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC54PTA7dGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55PTA7Yj10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeSh0aGlzLnN0YXRlLmNlbGwpO251bGwhPWImJihjPWIub2Zmc2V0fHwKdGhpcy5FTVBUWV9QT0lOVCxudWxsPT1jfHxiLnJlbGF0aXZlfHwodGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC54PXRoaXMuc3RhdGUudmlldy5zY2FsZSpjLngsdGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55PXRoaXMuc3RhdGUudmlldy5zY2FsZSpjLnkpLHRoaXMuc3RhdGUudmlldy51cGRhdGVWZXJ0ZXhMYWJlbE9mZnNldCh0aGlzLnN0YXRlKSk7dGhpcy5zdGF0ZS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcodGhpcy5zdGF0ZSwhMCk7dGhpcy5zdGF0ZS52aWV3LmludmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsKTt0aGlzLnN0YXRlLmludmFsaWQ9ITE7dGhpcy5zdGF0ZS52aWV3LnZhbGlkYXRlKCk7dGhpcy5yZWRyYXdIYW5kbGVzKCk7dGhpcy5tb3ZlVG9Gcm9udCgpO251bGwhPXRoaXMuc3RhdGUuY29udHJvbCYmbnVsbCE9dGhpcy5zdGF0ZS5jb250cm9sLm5vZGUmJih0aGlzLnN0YXRlLmNvbnRyb2wubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iKTt0aGlzLnN0YXRlLnNldFN0YXRlKGEpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlVG9Gcm9udD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuc3RhdGUudGV4dCYmbnVsbCE9dGhpcy5zdGF0ZS50ZXh0Lm5vZGUmJm51bGwhPXRoaXMuc3RhdGUudGV4dC5ub2RlLm5leHRTaWJsaW5nfHxudWxsIT10aGlzLnN0YXRlLnNoYXBlJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlLm5vZGUmJm51bGwhPXRoaXMuc3RhdGUuc2hhcGUubm9kZS5uZXh0U2libGluZyYmKG51bGw9PXRoaXMuc3RhdGUudGV4dHx8dGhpcy5zdGF0ZS5zaGFwZS5ub2RlLm5leHRTaWJsaW5nIT10aGlzLnN0YXRlLnRleHQubm9kZSkpbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZSYmbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZS5ub2RlJiZ0aGlzLnN0YXRlLnNoYXBlLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnN0YXRlLnNoYXBlLm5vZGUpLG51bGwhPXRoaXMuc3RhdGUudGV4dCYmbnVsbCE9dGhpcy5zdGF0ZS50ZXh0Lm5vZGUmJnRoaXMuc3RhdGUudGV4dC5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zdGF0ZS50ZXh0Lm5vZGUpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYobnVsbCE9dGhpcy5pbmRleCYmbnVsbCE9dGhpcy5zdGF0ZSl7dmFyIGM9bmV3IG14UG9pbnQoYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpKSxkPXRoaXMuaW5kZXg7dGhpcy5pbmRleD1udWxsO3RoaXMuc3RhdGUudmlldy5pbnZhbGlkYXRlKHRoaXMuc3RhdGUuY2VsbCwhMSwhMSk7dGhpcy5zdGF0ZS52aWV3LnZhbGlkYXRlKCk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKGQ8PW14RXZlbnQuQ1VTVE9NX0hBTkRMRSludWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJih0aGlzLmN1c3RvbUhhbmRsZXNbbXhFdmVudC5DVVNUT01fSEFORExFLWRdLmFjdGl2ZT0hMSx0aGlzLmN1c3RvbUhhbmRsZXNbbXhFdmVudC5DVVNUT01fSEFORExFLWRdLmV4ZWN1dGUoYikpO2Vsc2UgaWYoZD09bXhFdmVudC5ST1RBVElPTl9IQU5ETEUpaWYobnVsbCE9dGhpcy5jdXJyZW50QWxwaGEpe3ZhciBlPQp0aGlzLmN1cnJlbnRBbHBoYS0odGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fDApOzAhPWUmJnRoaXMucm90YXRlQ2VsbCh0aGlzLnN0YXRlLmNlbGwsZSl9ZWxzZSB0aGlzLnJvdGF0ZUNsaWNrKCk7ZWxzZXt2YXIgZj10aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWRFdmVudChiLmdldEV2ZW50KCkpLGc9bXhVdGlscy50b1JhZGlhbnModGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksaz1NYXRoLmNvcygtZyksbD1NYXRoLnNpbigtZyksbT1jLngtdGhpcy5zdGFydFgsbj1jLnktdGhpcy5zdGFydFksYz1sKm0raypuLG09ayptLWwqbixuPWMscD10aGlzLmdyYXBoLnZpZXcuc2NhbGUscT10aGlzLmlzUmVjdXJzaXZlUmVzaXplKHRoaXMuc3RhdGUsYik7dGhpcy5yZXNpemVDZWxsKHRoaXMuc3RhdGUuY2VsbCx0aGlzLnJvdW5kTGVuZ3RoKG0vcCksdGhpcy5yb3VuZExlbmd0aChuL3ApLGQsZix0aGlzLmlzQ29uc3RyYWluZWRFdmVudChiKSwKcSl9fWZpbmFsbHl7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfWIuY29uc3VtZSgpO3RoaXMucmVzZXQoKX19O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNSZWN1cnNpdmVSZXNpemU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5ncmFwaC5pc1JlY3Vyc2l2ZVJlc2l6ZSh0aGlzLnN0YXRlKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGVDbGljaz1mdW5jdGlvbigpe307Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUucm90YXRlQ2VsbD1mdW5jdGlvbihhLGIsYyl7aWYoMCE9Yil7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2lmKGQuaXNWZXJ0ZXgoYSl8fGQuaXNFZGdlKGEpKXtpZighZC5pc0VkZ2UoYSkpe3ZhciBlPSh0aGlzLmdyYXBoLmdldEN1cnJlbnRDZWxsU3R5bGUoYSlbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwwKStiO3RoaXMuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTixlLFthXSl9ZT10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKTtpZihudWxsIT1lKXt2YXIgZj10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShjKTtudWxsPT1mfHxkLmlzRWRnZShjKXx8KGU9ZS5jbG9uZSgpLGUucm90YXRlKGIsbmV3IG14UG9pbnQoZi53aWR0aC8yLGYuaGVpZ2h0LzIpKSxkLnNldEdlb21ldHJ5KGEsZSkpO2lmKGQuaXNWZXJ0ZXgoYSkmJiFlLnJlbGF0aXZlfHxkLmlzRWRnZShhKSlmb3IoYz0KZC5nZXRDaGlsZENvdW50KGEpLGU9MDtlPGM7ZSsrKXRoaXMucm90YXRlQ2VsbChkLmdldENoaWxkQXQoYSxlKSxiLGEpfX19fTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe251bGwhPXRoaXMuc2l6ZXJzJiZudWxsIT10aGlzLmluZGV4JiZudWxsIT10aGlzLnNpemVyc1t0aGlzLmluZGV4XSYmIm5vbmUiPT10aGlzLnNpemVyc1t0aGlzLmluZGV4XS5ub2RlLnN0eWxlLmRpc3BsYXkmJih0aGlzLnNpemVyc1t0aGlzLmluZGV4XS5ub2RlLnN0eWxlLmRpc3BsYXk9IiIpO3RoaXMuaW5kZXg9dGhpcy5pblRvbGVyYW5jZT10aGlzLmN1cnJlbnRBbHBoYT1udWxsO251bGwhPXRoaXMucHJldmlldyYmKHRoaXMucHJldmlldy5kZXN0cm95KCksdGhpcy5wcmV2aWV3PW51bGwpO2lmKHRoaXMubGl2ZVByZXZpZXdBY3RpdmUmJm51bGwhPXRoaXMuc2l6ZXJzKXtmb3IodmFyIGE9MDthPHRoaXMuc2l6ZXJzLmxlbmd0aDthKyspbnVsbCE9dGhpcy5zaXplcnNbYV0mJih0aGlzLnNpemVyc1thXS5ub2RlLnN0eWxlLmRpc3BsYXk9IiIpO251bGwhPXRoaXMuc3RhdGUuY29udHJvbCYmbnVsbCE9CnRoaXMuc3RhdGUuY29udHJvbC5ub2RlJiYodGhpcy5zdGF0ZS5jb250cm9sLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0iIil9aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKWZvcihhPTA7YTx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2ErKyl0aGlzLmN1c3RvbUhhbmRsZXNbYV0uYWN0aXZlPyh0aGlzLmN1c3RvbUhhbmRsZXNbYV0uYWN0aXZlPSExLHRoaXMuY3VzdG9tSGFuZGxlc1thXS5yZXNldCgpKTp0aGlzLmN1c3RvbUhhbmRsZXNbYV0uc2V0VmlzaWJsZSghMCk7bnVsbCE9dGhpcy5zZWxlY3Rpb25Cb3JkZXImJih0aGlzLnNlbGVjdGlvbkJvcmRlci5ub2RlLnN0eWxlLmRpc3BsYXk9ImlubGluZSIsdGhpcy5zZWxlY3Rpb25Cb3VuZHM9dGhpcy5nZXRTZWxlY3Rpb25Cb3VuZHModGhpcy5zdGF0ZSksdGhpcy5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKHRoaXMuc2VsZWN0aW9uQm91bmRzLngsdGhpcy5zZWxlY3Rpb25Cb3VuZHMueSx0aGlzLnNlbGVjdGlvbkJvdW5kcy53aWR0aCwKdGhpcy5zZWxlY3Rpb25Cb3VuZHMuaGVpZ2h0KSx0aGlzLmRyYXdQcmV2aWV3KCkpO3RoaXMucmVtb3ZlSGludCgpO3RoaXMucmVkcmF3SGFuZGxlcygpO3RoaXMubGl2ZVByZXZpZXdBY3RpdmU9dGhpcy51bnNjYWxlZEJvdW5kcz10aGlzLmVkZ2VIYW5kbGVycz1udWxsfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZXNpemVDZWxsPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2I9dGhpcy5ncmFwaC5tb2RlbC5nZXRHZW9tZXRyeShhKTtudWxsIT1iJiYoZD09bXhFdmVudC5MQUJFTF9IQU5ETEU/KGQ9LW14VXRpbHMudG9SYWRpYW5zKHRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpLGc9TWF0aC5jb3MoZCksYz1NYXRoLnNpbihkKSxkPXRoaXMuZ3JhcGgudmlldy5zY2FsZSxnPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG5ldyBteFBvaW50KE1hdGgucm91bmQoKHRoaXMubGFiZWxTaGFwZS5ib3VuZHMuZ2V0Q2VudGVyWCgpLXRoaXMuc3RhcnRYKS9kKSxNYXRoLnJvdW5kKCh0aGlzLmxhYmVsU2hhcGUuYm91bmRzLmdldENlbnRlclkoKS10aGlzLnN0YXJ0WSkvZCkpLGcsYyksYj1iLmNsb25lKCksbnVsbD09Yi5vZmZzZXQ/Yi5vZmZzZXQ9ZzooYi5vZmZzZXQueCs9Zy54LGIub2Zmc2V0LnkrPWcueSksdGhpcy5ncmFwaC5tb2RlbC5zZXRHZW9tZXRyeShhLApiKSk6bnVsbCE9dGhpcy51bnNjYWxlZEJvdW5kcyYmKGQ9dGhpcy5ncmFwaC52aWV3LnNjYWxlLDA9PXRoaXMuY2hpbGRPZmZzZXRYJiYwPT10aGlzLmNoaWxkT2Zmc2V0WXx8dGhpcy5tb3ZlQ2hpbGRyZW4oYSxNYXRoLnJvdW5kKHRoaXMuY2hpbGRPZmZzZXRYL2QpLE1hdGgucm91bmQodGhpcy5jaGlsZE9mZnNldFkvZCkpLHRoaXMuZ3JhcGgucmVzaXplQ2VsbChhLHRoaXMudW5zY2FsZWRCb3VuZHMsZykpKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3ZlQ2hpbGRyZW49ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1kLmdldENoaWxkQ291bnQoYSksZj0wO2Y8ZTtmKyspe3ZhciBnPWQuZ2V0Q2hpbGRBdChhLGYpLGs9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoZyk7bnVsbCE9ayYmKGs9ay5jbG9uZSgpLGsudHJhbnNsYXRlKGIsYyksZC5zZXRHZW9tZXRyeShnLGspKX19OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnVuaW9uPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxsKXtlPW51bGwhPWU/ZSYmdGhpcy5ncmFwaC5ncmlkRW5hYmxlZDp0aGlzLmdyYXBoLmdyaWRFbmFibGVkO2lmKHRoaXMuc2luZ2xlU2l6ZXIpcmV0dXJuIGQ9YS54K2Eud2lkdGgrYixnPWEueSthLmhlaWdodCtjLGUmJihkPXRoaXMuZ3JhcGguc25hcChkL2YpKmYsZz10aGlzLmdyYXBoLnNuYXAoZy9mKSpmKSxmPW5ldyBteFJlY3RhbmdsZShhLngsYS55LDAsMCksZi5hZGQobmV3IG14UmVjdGFuZ2xlKGQsZywwLDApKSxmO3ZhciBtPWEud2lkdGgsbj1hLmhlaWdodCxwPWEueC1nLngqZixxPXArbTthPWEueS1nLnkqZjt2YXIgcj1hK24sdD1wK20vMix1PWErbi8yOzQ8ZD8ocis9YyxyPWU/dGhpcy5ncmFwaC5zbmFwKHIvZikqZjpNYXRoLnJvdW5kKHIvZikqZik6Mz5kJiYoYSs9YyxhPWU/dGhpcy5ncmFwaC5zbmFwKGEvZikqZjpNYXRoLnJvdW5kKGEvZikqZik7aWYoMD09ZHx8CjM9PWR8fDU9PWQpcCs9YixwPWU/dGhpcy5ncmFwaC5zbmFwKHAvZikqZjpNYXRoLnJvdW5kKHAvZikqZjtlbHNlIGlmKDI9PWR8fDQ9PWR8fDc9PWQpcSs9YixxPWU/dGhpcy5ncmFwaC5zbmFwKHEvZikqZjpNYXRoLnJvdW5kKHEvZikqZjtlPXEtcDtjPXItYTtrJiYoaz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeSh0aGlzLnN0YXRlLmNlbGwpLG51bGwhPWsmJihrPWsud2lkdGgvay5oZWlnaHQsMT09ZHx8Mj09ZHx8Nz09ZHx8Nj09ZD9lPWMqazpjPWUvaywwPT1kJiYocD1xLWUsYT1yLWMpKSk7bCYmKGUrPWUtbSxjKz1jLW4scCs9dC0ocCtlLzIpLGErPXUtKGErYy8yKSk7MD5lJiYocCs9ZSxlPU1hdGguYWJzKGUpKTswPmMmJihhKz1jLGM9TWF0aC5hYnMoYykpO2Q9bmV3IG14UmVjdGFuZ2xlKHArZy54KmYsYStnLnkqZixlLGMpO251bGwhPXRoaXMubWluQm91bmRzJiYoZC53aWR0aD1NYXRoLm1heChkLndpZHRoLHRoaXMubWluQm91bmRzLngqZit0aGlzLm1pbkJvdW5kcy53aWR0aCoKZitNYXRoLm1heCgwLHRoaXMueDAqZi1kLngpKSxkLmhlaWdodD1NYXRoLm1heChkLmhlaWdodCx0aGlzLm1pbkJvdW5kcy55KmYrdGhpcy5taW5Cb3VuZHMuaGVpZ2h0KmYrTWF0aC5tYXgoMCx0aGlzLnkwKmYtZC55KSkpO3JldHVybiBkfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlZHJhdz1mdW5jdGlvbihhKXt0aGlzLnNlbGVjdGlvbkJvdW5kcz10aGlzLmdldFNlbGVjdGlvbkJvdW5kcyh0aGlzLnN0YXRlKTt0aGlzLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUodGhpcy5zZWxlY3Rpb25Cb3VuZHMueCx0aGlzLnNlbGVjdGlvbkJvdW5kcy55LHRoaXMuc2VsZWN0aW9uQm91bmRzLndpZHRoLHRoaXMuc2VsZWN0aW9uQm91bmRzLmhlaWdodCk7dGhpcy5kcmF3UHJldmlldygpO2F8fHRoaXMucmVkcmF3SGFuZGxlcygpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVQYWRkaW5nPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14UG9pbnQoMCwwKSxiPXRoaXMudG9sZXJhbmNlO251bGwhPXRoaXMuc2l6ZXJzJiYwPHRoaXMuc2l6ZXJzLmxlbmd0aCYmbnVsbCE9dGhpcy5zaXplcnNbMF0mJih0aGlzLmJvdW5kcy53aWR0aDwyKnRoaXMuc2l6ZXJzWzBdLmJvdW5kcy53aWR0aCsyKmJ8fHRoaXMuYm91bmRzLmhlaWdodDwyKnRoaXMuc2l6ZXJzWzBdLmJvdW5kcy5oZWlnaHQrMipiKSYmKGIvPTIsYS54PXRoaXMuc2l6ZXJzWzBdLmJvdW5kcy53aWR0aCtiLGEueT10aGlzLnNpemVyc1swXS5ib3VuZHMuaGVpZ2h0K2IpO3JldHVybiBhfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNpemVyQm91bmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRzfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdIYW5kbGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTaXplckJvdW5kcygpLGI9dGhpcy50b2xlcmFuY2U7dGhpcy52ZXJ0aWNhbE9mZnNldD10aGlzLmhvcml6b250YWxPZmZzZXQ9MDtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKHZhciBjPTA7Yzx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5jdXN0b21IYW5kbGVzW2NdLnNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheTt0aGlzLmN1c3RvbUhhbmRsZXNbY10ucmVkcmF3KCk7dGhpcy5jdXN0b21IYW5kbGVzW2NdLnNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheT1kO3RoaXMuY3VzdG9tSGFuZGxlc1tjXS5zaGFwZS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9dGhpcy5pc0N1c3RvbUhhbmRsZVZpc2libGUodGhpcy5jdXN0b21IYW5kbGVzW2NdKT8iIjoiaGlkZGVuIn1pZihudWxsIT10aGlzLnNpemVycyYmMDx0aGlzLnNpemVycy5sZW5ndGgmJgpudWxsIT10aGlzLnNpemVyc1swXSl7aWYobnVsbD09dGhpcy5pbmRleCYmdGhpcy5tYW5hZ2VTaXplcnMmJjg8PXRoaXMuc2l6ZXJzLmxlbmd0aCl7Yz10aGlzLmdldEhhbmRsZVBhZGRpbmcoKTt0aGlzLmhvcml6b250YWxPZmZzZXQ9Yy54O3RoaXMudmVydGljYWxPZmZzZXQ9Yy55O2lmKDAhPXRoaXMuaG9yaXpvbnRhbE9mZnNldHx8MCE9dGhpcy52ZXJ0aWNhbE9mZnNldClhPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpLGEueC09dGhpcy5ob3Jpem9udGFsT2Zmc2V0LzIsYS53aWR0aCs9dGhpcy5ob3Jpem9udGFsT2Zmc2V0LGEueS09dGhpcy52ZXJ0aWNhbE9mZnNldC8yLGEuaGVpZ2h0Kz10aGlzLnZlcnRpY2FsT2Zmc2V0Ozg8PXRoaXMuc2l6ZXJzLmxlbmd0aCYmKGEud2lkdGg8Mip0aGlzLnNpemVyc1swXS5ib3VuZHMud2lkdGgrMipifHxhLmhlaWdodDwyKnRoaXMuc2l6ZXJzWzBdLmJvdW5kcy5oZWlnaHQrMipiPyh0aGlzLnNpemVyc1swXS5ub2RlLnN0eWxlLmRpc3BsYXk9CiJub25lIix0aGlzLnNpemVyc1syXS5ub2RlLnN0eWxlLmRpc3BsYXk9Im5vbmUiLHRoaXMuc2l6ZXJzWzVdLm5vZGUuc3R5bGUuZGlzcGxheT0ibm9uZSIsdGhpcy5zaXplcnNbN10ubm9kZS5zdHlsZS5kaXNwbGF5PSJub25lIik6KHRoaXMuc2l6ZXJzWzBdLm5vZGUuc3R5bGUuZGlzcGxheT0iIix0aGlzLnNpemVyc1syXS5ub2RlLnN0eWxlLmRpc3BsYXk9IiIsdGhpcy5zaXplcnNbNV0ubm9kZS5zdHlsZS5kaXNwbGF5PSIiLHRoaXMuc2l6ZXJzWzddLm5vZGUuc3R5bGUuZGlzcGxheT0iIikpfWI9YS54K2Eud2lkdGg7Yz1hLnkrYS5oZWlnaHQ7aWYodGhpcy5zaW5nbGVTaXplcil0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzBdLGIsYyk7ZWxzZXt2YXIgZD1hLngrYS53aWR0aC8yLGU9YS55K2EuaGVpZ2h0LzI7aWYoODw9dGhpcy5zaXplcnMubGVuZ3RoKXt2YXIgZj0ibnctcmVzaXplIG4tcmVzaXplIG5lLXJlc2l6ZSBlLXJlc2l6ZSBzZS1yZXNpemUgcy1yZXNpemUgc3ctcmVzaXplIHctcmVzaXplIi5zcGxpdCgiICIpLApnPW14VXRpbHMudG9SYWRpYW5zKHRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpLGs9TWF0aC5jb3MoZyksbD1NYXRoLnNpbihnKSxnPU1hdGgucm91bmQoNCpnL01hdGguUEkpLG09bmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS5nZXRDZW50ZXJZKCkpLG49bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobmV3IG14UG9pbnQoYS54LGEueSksayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbMF0sbi54LG4ueSk7dGhpcy5zaXplcnNbMF0uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoMCtnLGYubGVuZ3RoKV0pO24ueD1kO24ueT1hLnk7bj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuLGssbCxtKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzFdLG4ueCxuLnkpO3RoaXMuc2l6ZXJzWzFdLnNldEN1cnNvcihmW214VXRpbHMubW9kKDErZyxmLmxlbmd0aCldKTtuLng9YjtuLnk9YS55O249bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQobiwKayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbMl0sbi54LG4ueSk7dGhpcy5zaXplcnNbMl0uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoMitnLGYubGVuZ3RoKV0pO24ueD1hLng7bi55PWU7bj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuLGssbCxtKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzNdLG4ueCxuLnkpO3RoaXMuc2l6ZXJzWzNdLnNldEN1cnNvcihmW214VXRpbHMubW9kKDcrZyxmLmxlbmd0aCldKTtuLng9YjtuLnk9ZTtuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbNF0sbi54LG4ueSk7dGhpcy5zaXplcnNbNF0uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoMytnLGYubGVuZ3RoKV0pO24ueD1hLng7bi55PWM7bj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuLGssbCxtKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzVdLG4ueCxuLnkpO3RoaXMuc2l6ZXJzWzVdLnNldEN1cnNvcihmW214VXRpbHMubW9kKDYrCmcsZi5sZW5ndGgpXSk7bi54PWQ7bi55PWM7bj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuLGssbCxtKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzZdLG4ueCxuLnkpO3RoaXMuc2l6ZXJzWzZdLnNldEN1cnNvcihmW214VXRpbHMubW9kKDUrZyxmLmxlbmd0aCldKTtuLng9YjtuLnk9YztuPW14VXRpbHMuZ2V0Um90YXRlZFBvaW50KG4sayxsLG0pO3RoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbN10sbi54LG4ueSk7dGhpcy5zaXplcnNbN10uc2V0Q3Vyc29yKGZbbXhVdGlscy5tb2QoNCtnLGYubGVuZ3RoKV0pO24ueD1kK3RoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQueDtuLnk9ZSt0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0Lnk7bj1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChuLGssbCxtKTt0aGlzLm1vdmVTaXplclRvKHRoaXMuc2l6ZXJzWzhdLG4ueCxuLnkpfWVsc2UgMjw9dGhpcy5zdGF0ZS53aWR0aCYmMjw9dGhpcy5zdGF0ZS5oZWlnaHQ/dGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnNpemVyc1swXSwKZCt0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0LngsZSt0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0LnkpOnRoaXMubW92ZVNpemVyVG8odGhpcy5zaXplcnNbMF0sdGhpcy5zdGF0ZS54LHRoaXMuc3RhdGUueSl9fW51bGwhPXRoaXMucm90YXRpb25TaGFwZSYmKGc9bXhVdGlscy50b1JhZGlhbnMobnVsbCE9dGhpcy5jdXJyZW50QWxwaGE/dGhpcy5jdXJyZW50QWxwaGE6dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksaz1NYXRoLmNvcyhnKSxsPU1hdGguc2luKGcpLG09bmV3IG14UG9pbnQodGhpcy5zdGF0ZS5nZXRDZW50ZXJYKCksdGhpcy5zdGF0ZS5nZXRDZW50ZXJZKCkpLG49bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQodGhpcy5nZXRSb3RhdGlvbkhhbmRsZVBvc2l0aW9uKCksayxsLG0pLG51bGwhPXRoaXMucm90YXRpb25TaGFwZS5ub2RlJiYodGhpcy5tb3ZlU2l6ZXJUbyh0aGlzLnJvdGF0aW9uU2hhcGUsbi54LG4ueSksdGhpcy5yb3RhdGlvblNoYXBlLm5vZGUuc3R5bGUudmlzaWJpbGl0eT0KdGhpcy5zdGF0ZS52aWV3LmdyYXBoLmlzRWRpdGluZygpPyJoaWRkZW4iOiIiKSk7bnVsbCE9dGhpcy5zZWxlY3Rpb25Cb3JkZXImJih0aGlzLnNlbGVjdGlvbkJvcmRlci5yb3RhdGlvbj1OdW1iZXIodGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIikpO2lmKG51bGwhPXRoaXMuZWRnZUhhbmRsZXJzKWZvcihjPTA7Yzx0aGlzLmVkZ2VIYW5kbGVycy5sZW5ndGg7YysrKXRoaXMuZWRnZUhhbmRsZXJzW2NdLnJlZHJhdygpfTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlVmlzaWJsZT1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5ncmFwaC5pc0VkaXRpbmcoKSYmMT09dGhpcy5zdGF0ZS52aWV3LmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFJvdGF0aW9uSGFuZGxlUG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UG9pbnQodGhpcy5ib3VuZHMueCt0aGlzLmJvdW5kcy53aWR0aC8yLHRoaXMuYm91bmRzLnkrdGhpcy5yb3RhdGlvbkhhbmRsZVZTcGFjaW5nKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1BhcmVudEhpZ2hsaWdodFZpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUudXBkYXRlUGFyZW50SGlnaGxpZ2h0PWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5zZWxlY3Rpb25Cb3JkZXImJnRoaXMuaXNQYXJlbnRIaWdobGlnaHRWaXNpYmxlKCkpaWYobnVsbCE9dGhpcy5wYXJlbnRIaWdobGlnaHQpe3ZhciBhPXRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KHRoaXMuc3RhdGUuY2VsbCk7aWYodGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleChhKSl7dmFyIGE9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEpLGI9dGhpcy5wYXJlbnRIaWdobGlnaHQuYm91bmRzO251bGw9PWF8fGIueD09YS54JiZiLnk9PWEueSYmYi53aWR0aD09YS53aWR0aCYmYi5oZWlnaHQ9PWEuaGVpZ2h0fHwodGhpcy5wYXJlbnRIaWdobGlnaHQuYm91bmRzPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYSksdGhpcy5wYXJlbnRIaWdobGlnaHQucmVkcmF3KCkpfWVsc2UgdGhpcy5wYXJlbnRIaWdobGlnaHQuZGVzdHJveSgpLHRoaXMucGFyZW50SGlnaGxpZ2h0PQpudWxsfWVsc2UgdGhpcy5wYXJlbnRIaWdobGlnaHRFbmFibGVkJiYoYT10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpLHRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYSkmJihhPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhKSxudWxsIT1hJiYodGhpcy5wYXJlbnRIaWdobGlnaHQ9dGhpcy5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZShhKSx0aGlzLnBhcmVudEhpZ2hsaWdodC5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsdGhpcy5wYXJlbnRIaWdobGlnaHQucG9pbnRlckV2ZW50cz0hMSx0aGlzLnBhcmVudEhpZ2hsaWdodC5yb3RhdGlvbj1OdW1iZXIoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksdGhpcy5wYXJlbnRIaWdobGlnaHQuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKSwKdGhpcy5wYXJlbnRIaWdobGlnaHQucmVkcmF3KCkpKSl9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmRyYXdQcmV2aWV3PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wcmV2aWV3JiYodGhpcy5wcmV2aWV3LmJvdW5kcz10aGlzLmJvdW5kcyx0aGlzLnByZXZpZXcubm9kZS5wYXJlbnROb2RlPT10aGlzLmdyYXBoLmNvbnRhaW5lciYmKHRoaXMucHJldmlldy5ib3VuZHMud2lkdGg9TWF0aC5tYXgoMCx0aGlzLnByZXZpZXcuYm91bmRzLndpZHRoLTEpLHRoaXMucHJldmlldy5ib3VuZHMuaGVpZ2h0PU1hdGgubWF4KDAsdGhpcy5wcmV2aWV3LmJvdW5kcy5oZWlnaHQtMSkpLHRoaXMucHJldmlldy5yb3RhdGlvbj1OdW1iZXIodGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fCIwIiksdGhpcy5wcmV2aWV3LnJlZHJhdygpKTt0aGlzLnNlbGVjdGlvbkJvcmRlci5ib3VuZHM9dGhpcy5nZXRTZWxlY3Rpb25Cb3JkZXJCb3VuZHMoKTt0aGlzLnNlbGVjdGlvbkJvcmRlci5yZWRyYXcoKTt0aGlzLnVwZGF0ZVBhcmVudEhpZ2hsaWdodCgpfTsKbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Cb3JkZXJCb3VuZHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3VuZHN9OwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmVzY2FwZUhhbmRsZXImJih0aGlzLnN0YXRlLnZpZXcuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5lc2NhcGVIYW5kbGVyKSx0aGlzLmVzY2FwZUhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5wcmV2aWV3JiYodGhpcy5wcmV2aWV3LmRlc3Ryb3koKSx0aGlzLnByZXZpZXc9bnVsbCk7bnVsbCE9dGhpcy5wYXJlbnRIaWdobGlnaHQmJih0aGlzLnBhcmVudEhpZ2hsaWdodC5kZXN0cm95KCksdGhpcy5wYXJlbnRIaWdobGlnaHQ9bnVsbCk7bnVsbCE9dGhpcy5zZWxlY3Rpb25Cb3JkZXImJih0aGlzLnNlbGVjdGlvbkJvcmRlci5kZXN0cm95KCksdGhpcy5zZWxlY3Rpb25Cb3JkZXI9bnVsbCk7dGhpcy5sYWJlbFNoYXBlPW51bGw7dGhpcy5yZW1vdmVIaW50KCk7aWYobnVsbCE9dGhpcy5zaXplcnMpe2Zvcih2YXIgYT0wO2E8dGhpcy5zaXplcnMubGVuZ3RoO2ErKyl0aGlzLnNpemVyc1thXS5kZXN0cm95KCk7CnRoaXMuc2l6ZXJzPW51bGx9aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKXtmb3IoYT0wO2E8dGhpcy5jdXN0b21IYW5kbGVzLmxlbmd0aDthKyspdGhpcy5jdXN0b21IYW5kbGVzW2FdLmRlc3Ryb3koKTt0aGlzLmN1c3RvbUhhbmRsZXM9bnVsbH19O2Z1bmN0aW9uIG14RWRnZUhhbmRsZXIoYSl7bnVsbCE9YSYmKHRoaXMuc3RhdGU9YSx0aGlzLmluaXQoKSx0aGlzLmVzY2FwZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixjKXt2YXIgZD1udWxsIT10aGlzLmluZGV4O3RoaXMucmVzZXQoKTtkJiZ0aGlzLmdyYXBoLmNlbGxSZW5kZXJlci5yZWRyYXcodGhpcy5zdGF0ZSwhMSxhLnZpZXcuaXNSZW5kZXJpbmcoKSl9KSx0aGlzLnN0YXRlLnZpZXcuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FU0NBUEUsdGhpcy5lc2NhcGVIYW5kbGVyKSl9bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZT1udWxsOwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tYXJrZXI9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJhaW50SGFuZGxlcj1udWxsO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmVycm9yPW51bGw7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc2hhcGU9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5iZW5kcz1udWxsO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmxhYmVsU2hhcGU9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jbG9uZUVuYWJsZWQ9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuYWRkRW5hYmxlZD0hMTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVFbmFibGVkPSExO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmRibENsaWNrUmVtb3ZlRW5hYmxlZD0hMTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tZXJnZVJlbW92ZUVuYWJsZWQ9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc3RyYWlnaHRSZW1vdmVFbmFibGVkPSExOwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS52aXJ0dWFsQmVuZHNFbmFibGVkPSExO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnZpcnR1YWxCZW5kT3BhY2l0eT0yMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5wYXJlbnRIaWdobGlnaHRFbmFibGVkPSExO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnByZWZlckh0bWw9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuYWxsb3dIYW5kbGVCb3VuZHNDaGVjaz0hMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9UZXJtaW5hbHM9ITE7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2U9bnVsbDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS50b2xlcmFuY2U9MDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5vdXRsaW5lQ29ubmVjdD0hMTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tYW5hZ2VMYWJlbEhhbmRsZT0hMTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3RoaXMuZ3JhcGg9dGhpcy5zdGF0ZS52aWV3LmdyYXBoO3RoaXMubWFya2VyPXRoaXMuY3JlYXRlTWFya2VyKCk7dGhpcy5jb25zdHJhaW50SGFuZGxlcj1uZXcgbXhDb25zdHJhaW50SGFuZGxlcih0aGlzLmdyYXBoKTt0aGlzLnBvaW50cz1bXTt0aGlzLmFic3BvaW50cz10aGlzLmdldFNlbGVjdGlvblBvaW50cyh0aGlzLnN0YXRlKTt0aGlzLnNoYXBlPXRoaXMuY3JlYXRlU2VsZWN0aW9uU2hhcGUodGhpcy5hYnNwb2ludHMpO3RoaXMuc2hhcGUuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfTUlYRURIVE1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHO3RoaXMuc2hhcGUuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKTt0aGlzLnNoYXBlLnBvaW50ZXJFdmVudHM9ITE7dGhpcy5zaGFwZS5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX01PVkFCTEVfRURHRSk7Cm14RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyh0aGlzLnNoYXBlLm5vZGUsdGhpcy5ncmFwaCx0aGlzLnN0YXRlKTt0aGlzLnByZWZlckh0bWw9bnVsbCE9dGhpcy5zdGF0ZS50ZXh0JiZ0aGlzLnN0YXRlLnRleHQubm9kZS5wYXJlbnROb2RlPT10aGlzLmdyYXBoLmNvbnRhaW5lcjtpZighdGhpcy5wcmVmZXJIdG1sKXt2YXIgYT10aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKTtudWxsIT1hJiYodGhpcy5wcmVmZXJIdG1sPW51bGwhPWEudGV4dCYmYS50ZXh0Lm5vZGUucGFyZW50Tm9kZT09dGhpcy5ncmFwaC5jb250YWluZXIpO3RoaXMucHJlZmVySHRtbHx8KGE9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksbnVsbCE9YSYmKHRoaXMucHJlZmVySHRtbD1udWxsIT1hLnRleHQmJmEudGV4dC5ub2RlLnBhcmVudE5vZGU9PXRoaXMuZ3JhcGguY29udGFpbmVyKSl9dGhpcy5wYXJlbnRIaWdobGlnaHRFbmFibGVkJiYoYT10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpLAp0aGlzLmdyYXBoLm1vZGVsLmlzVmVydGV4KGEpJiYoYT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSksbnVsbCE9YSYmKHRoaXMucGFyZW50SGlnaGxpZ2h0PXRoaXMuY3JlYXRlUGFyZW50SGlnaGxpZ2h0U2hhcGUoYSksdGhpcy5wYXJlbnRIaWdobGlnaHQuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfVk1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHLHRoaXMucGFyZW50SGlnaGxpZ2h0LnBvaW50ZXJFdmVudHM9ITEsdGhpcy5wYXJlbnRIaWdobGlnaHQucm90YXRpb249TnVtYmVyKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpLHRoaXMucGFyZW50SGlnaGxpZ2h0LmluaXQodGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0T3ZlcmxheVBhbmUoKSkpKSk7aWYodGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpPG14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxsc3x8CjA+PW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhDZWxscyl0aGlzLmJlbmRzPXRoaXMuY3JlYXRlQmVuZHMoKSx0aGlzLmlzVmlydHVhbEJlbmRzRW5hYmxlZCgpJiYodGhpcy52aXJ0dWFsQmVuZHM9dGhpcy5jcmVhdGVWaXJ0dWFsQmVuZHMoKSk7dGhpcy5sYWJlbD1uZXcgbXhQb2ludCh0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0LngsdGhpcy5zdGF0ZS5hYnNvbHV0ZU9mZnNldC55KTt0aGlzLmxhYmVsU2hhcGU9dGhpcy5jcmVhdGVMYWJlbEhhbmRsZVNoYXBlKCk7dGhpcy5pbml0QmVuZCh0aGlzLmxhYmVsU2hhcGUpO3RoaXMubGFiZWxTaGFwZS5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX0xBQkVMX0hBTkRMRSk7dGhpcy5jdXN0b21IYW5kbGVzPXRoaXMuY3JlYXRlQ3VzdG9tSGFuZGxlcygpO3RoaXMucmVkcmF3KCl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUhhbmRsZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzVmlydHVhbEJlbmRzRW5hYmxlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy52aXJ0dWFsQmVuZHNFbmFibGVkJiYobnVsbD09dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXXx8dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXT09bXhDb25zdGFudHMuTk9ORXx8MT09dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9OT0VER0VTVFlMRV0pJiYiYXJyb3ciIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU0hBUEUsbnVsbCl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQ2VsbEVuYWJsZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQWRkUG9pbnRFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc1NoaWZ0RG93bihhKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzUmVtb3ZlUG9pbnRFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc1NoaWZ0RG93bihhKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uUG9pbnRzPWZ1bmN0aW9uKGEpe3JldHVybiBhLmFic29sdXRlUG9pbnRzfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZT1mdW5jdGlvbihhKXthPW5ldyBteFJlY3RhbmdsZVNoYXBlKGEsbnVsbCx0aGlzLmdldFNlbGVjdGlvbkNvbG9yKCkpO2Euc3Ryb2tld2lkdGg9dGhpcy5nZXRTZWxlY3Rpb25TdHJva2VXaWR0aCgpO2EuaXNEYXNoZWQ9dGhpcy5pc1NlbGVjdGlvbkRhc2hlZCgpO3JldHVybiBhfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2VsZWN0aW9uU2hhcGU9ZnVuY3Rpb24oYSl7YT1uZXcgdGhpcy5zdGF0ZS5zaGFwZS5jb25zdHJ1Y3RvcjthLm91dGxpbmU9ITA7YS5hcHBseSh0aGlzLnN0YXRlKTthLmlzRGFzaGVkPXRoaXMuaXNTZWxlY3Rpb25EYXNoZWQoKTthLnN0cm9rZT10aGlzLmdldFNlbGVjdGlvbkNvbG9yKCk7YS5pc1NoYWRvdz0hMTtyZXR1cm4gYX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQ29sb3I9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDb25zdGFudHMuRURHRV9TRUxFQ1RJT05fQ09MT1J9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvblN0cm9rZVdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIG14Q29uc3RhbnRzLkVER0VfU0VMRUNUSU9OX1NUUk9LRVdJRFRIfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc1NlbGVjdGlvbkRhc2hlZD1mdW5jdGlvbigpe3JldHVybiBteENvbnN0YW50cy5FREdFX1NFTEVDVElPTl9EQVNIRUR9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RhYmxlQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4hMH07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0Q2VsbEF0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3V0bGluZUNvbm5lY3Q/bnVsbDp0aGlzLmdyYXBoLmdldENlbGxBdChhLGIpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlTWFya2VyPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbE1hcmtlcih0aGlzLmdyYXBoKSxiPXRoaXM7YS5nZXRDZWxsPWZ1bmN0aW9uKGEpe3ZhciBjPW14Q2VsbE1hcmtlci5wcm90b3R5cGUuZ2V0Q2VsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YyE9Yi5zdGF0ZS5jZWxsJiZudWxsIT1jfHxudWxsPT1iLmN1cnJlbnRQb2ludHx8KGM9Yi5ncmFwaC5nZXRDZWxsQXQoYi5jdXJyZW50UG9pbnQueCxiLmN1cnJlbnRQb2ludC55KSk7aWYobnVsbCE9YyYmIXRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYykpe3ZhciBlPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYyk7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGUpJiZ0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGUpJiYoYz1lKX1lPWIuZ3JhcGguZ2V0TW9kZWwoKTtpZih0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYykmJm51bGwhPWIuY3VycmVudFBvaW50JiYKdGhpcy5ncmFwaC5oaXRzU3dpbWxhbmVDb250ZW50KGMsYi5jdXJyZW50UG9pbnQueCxiLmN1cnJlbnRQb2ludC55KXx8IWIuaXNDb25uZWN0YWJsZUNlbGwoYyl8fGM9PWIuc3RhdGUuY2VsbHx8bnVsbCE9YyYmIWIuZ3JhcGguY29ubmVjdGFibGVFZGdlcyYmZS5pc0VkZ2UoYyl8fGUuaXNBbmNlc3RvcihiLnN0YXRlLmNlbGwsYykpYz1udWxsO3RoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYyl8fChjPW51bGwpO3JldHVybiBjfTthLmlzVmFsaWRTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYz1iLmdyYXBoLmdldE1vZGVsKCksYz1iLmdyYXBoLnZpZXcuZ2V0VGVybWluYWxQb3J0KGEsYi5ncmFwaC52aWV3LmdldFN0YXRlKGMuZ2V0VGVybWluYWwoYi5zdGF0ZS5jZWxsLCFiLmlzU291cmNlKSksIWIuaXNTb3VyY2UpLGM9bnVsbCE9Yz9jLmNlbGw6bnVsbDtiLmVycm9yPWIudmFsaWRhdGVDb25uZWN0aW9uKGIuaXNTb3VyY2U/YS5jZWxsOmMsYi5pc1NvdXJjZT9jOmEuY2VsbCk7CnJldHVybiBudWxsPT1iLmVycm9yfTtyZXR1cm4gYX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudmFsaWRhdGVDb25uZWN0aW9uPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ3JhcGguZ2V0RWRnZVZhbGlkYXRpb25FcnJvcih0aGlzLnN0YXRlLmNlbGwsYSxiKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUJlbmRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuc3RhdGUuY2VsbCxiPVtdLGM9MDtjPHRoaXMuYWJzcG9pbnRzLmxlbmd0aDtjKyspaWYodGhpcy5pc0hhbmRsZVZpc2libGUoYykpe3ZhciBkPWM9PXRoaXMuYWJzcG9pbnRzLmxlbmd0aC0xLGU9MD09Y3x8ZDsoZXx8dGhpcy5ncmFwaC5pc0NlbGxCZW5kYWJsZShhKSkmJm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMuY3JlYXRlSGFuZGxlU2hhcGUoYSk7dGhpcy5pbml0QmVuZChkLG14VXRpbHMuYmluZCh0aGlzLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kYmxDbGlja1JlbW92ZUVuYWJsZWQmJnRoaXMucmVtb3ZlUG9pbnQodGhpcy5zdGF0ZSxhKX0pKSk7dGhpcy5pc0hhbmRsZUVuYWJsZWQoYykmJmQuc2V0Q3Vyc29yKGU/bXhDb25zdGFudHMuQ1VSU09SX1RFUk1JTkFMX0hBTkRMRTpteENvbnN0YW50cy5DVVJTT1JfQkVORF9IQU5ETEUpOwpiLnB1c2goZCk7ZXx8KHRoaXMucG9pbnRzLnB1c2gobmV3IG14UG9pbnQoMCwwKSksZC5ub2RlLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIpfSkoYyl9cmV0dXJuIGJ9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVZpcnR1YWxCZW5kcz1mdW5jdGlvbigpe3ZhciBhPVtdO2lmKHRoaXMuZ3JhcGguaXNDZWxsQmVuZGFibGUodGhpcy5zdGF0ZS5jZWxsKSlmb3IodmFyIGI9MTtiPHRoaXMuYWJzcG9pbnRzLmxlbmd0aDtiKyspbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5pbml0QmVuZChiKTtiLnNldEN1cnNvcihteENvbnN0YW50cy5DVVJTT1JfVklSVFVBTF9CRU5EX0hBTkRMRSk7YS5wdXNoKGIpfSkodGhpcy5jcmVhdGVIYW5kbGVTaGFwZSgpKTtyZXR1cm4gYX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNIYW5kbGVFbmFibGVkPWZ1bmN0aW9uKGEpe3JldHVybiEwfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNIYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApLGM9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksZD10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeSh0aGlzLnN0YXRlLmNlbGwpO3JldHVybihudWxsIT1kP3RoaXMuZ3JhcGgudmlldy5nZXRFZGdlU3R5bGUodGhpcy5zdGF0ZSxkLnBvaW50cyxiLGMpOm51bGwpIT1teEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbnx8MD09YXx8YT09dGhpcy5hYnNwb2ludHMubGVuZ3RoLTF9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVIYW5kbGVTaGFwZT1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmhhbmRsZUltYWdlKXJldHVybiBhPW5ldyBteEltYWdlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLmhhbmRsZUltYWdlLndpZHRoLHRoaXMuaGFuZGxlSW1hZ2UuaGVpZ2h0KSx0aGlzLmhhbmRsZUltYWdlLnNyYyksYS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExLGE7YT1teENvbnN0YW50cy5IQU5ETEVfU0laRTt0aGlzLnByZWZlckh0bWwmJi0tYTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCxhLGEpLG14Q29uc3RhbnRzLkhBTkRMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuSEFORExFX1NUUk9LRUNPTE9SKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUxhYmVsSGFuZGxlU2hhcGU9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLmxhYmVsSGFuZGxlSW1hZ2Upe3ZhciBhPW5ldyBteEltYWdlU2hhcGUobmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLmxhYmVsSGFuZGxlSW1hZ2Uud2lkdGgsdGhpcy5sYWJlbEhhbmRsZUltYWdlLmhlaWdodCksdGhpcy5sYWJlbEhhbmRsZUltYWdlLnNyYyk7YS5wcmVzZXJ2ZUltYWdlQXNwZWN0PSExO3JldHVybiBhfWE9bXhDb25zdGFudHMuTEFCRUxfSEFORExFX1NJWkU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsYSxhKSxteENvbnN0YW50cy5MQUJFTF9IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUil9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pbml0QmVuZD1mdW5jdGlvbihhLGIpe3RoaXMucHJlZmVySHRtbD8oYS5kaWFsZWN0PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCxhLmluaXQodGhpcy5ncmFwaC5jb250YWluZXIpKTooYS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9NSVhFREhUTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkcsYS5pbml0KHRoaXMuZ3JhcGguZ2V0VmlldygpLmdldE92ZXJsYXlQYW5lKCkpKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMoYS5ub2RlLHRoaXMuZ3JhcGgsdGhpcy5zdGF0ZSxudWxsLG51bGwsbnVsbCxiKTsobXhDbGllbnQuSVNfUVVJUktTfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUpJiZteEV2ZW50LmFkZExpc3RlbmVyKGEubm9kZSwiZHJhZ3N0YXJ0IixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSk7cmV0dXJuITF9KTtteENsaWVudC5JU19UT1VDSCYmCmEubm9kZS5zZXRBdHRyaWJ1dGUoInBvaW50ZXItZXZlbnRzIiwibm9uZSIpfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0SGFuZGxlRm9yRXZlbnQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXtpZihudWxsIT1iJiZudWxsIT1iLm5vZGUmJiJub25lIiE9Yi5ub2RlLnN0eWxlLmRpc3BsYXkmJiJoaWRkZW4iIT1iLm5vZGUuc3R5bGUudmlzaWJpbGl0eSYmKGEuaXNTb3VyY2UoYil8fG51bGwhPWQmJm14VXRpbHMuaW50ZXJzZWN0cyhiLmJvdW5kcyxkKSkpe3ZhciBjPWEuZ2V0R3JhcGhYKCktYi5ib3VuZHMuZ2V0Q2VudGVyWCgpO2I9YS5nZXRHcmFwaFkoKS1iLmJvdW5kcy5nZXRDZW50ZXJZKCk7Yz1jKmMrYipiO2lmKG51bGw9PWV8fGM8PWUpcmV0dXJuIGU9YywhMH1yZXR1cm4hMX12YXIgYz1teEV2ZW50LmlzTW91c2VFdmVudChhLmdldEV2ZW50KCkpPzE6dGhpcy50b2xlcmFuY2UsZD10aGlzLmFsbG93SGFuZGxlQm91bmRzQ2hlY2smJihteENsaWVudC5JU19JRXx8MDxjKT9uZXcgbXhSZWN0YW5nbGUoYS5nZXRHcmFwaFgoKS1jLGEuZ2V0R3JhcGhZKCktCmMsMipjLDIqYyk6bnVsbCxlPW51bGwsYz1udWxsO2lmKG51bGwhPXRoaXMuY3VzdG9tSGFuZGxlcyYmdGhpcy5pc0N1c3RvbUhhbmRsZUV2ZW50KGEpKWZvcih2YXIgZj10aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoLTE7MDw9ZjtmLS0paWYoYih0aGlzLmN1c3RvbUhhbmRsZXNbZl0uc2hhcGUpKXJldHVybiBteEV2ZW50LkNVU1RPTV9IQU5ETEUtZjtpZihhLmlzU291cmNlKHRoaXMuc3RhdGUudGV4dCl8fGIodGhpcy5sYWJlbFNoYXBlKSljPW14RXZlbnQuTEFCRUxfSEFORExFO2lmKG51bGwhPXRoaXMuYmVuZHMpZm9yKGY9MDtmPHRoaXMuYmVuZHMubGVuZ3RoO2YrKyliKHRoaXMuYmVuZHNbZl0pJiYoYz1mKTtpZihudWxsIT10aGlzLnZpcnR1YWxCZW5kcyYmdGhpcy5pc0FkZFZpcnR1YWxCZW5kRXZlbnQoYSkpZm9yKGY9MDtmPHRoaXMudmlydHVhbEJlbmRzLmxlbmd0aDtmKyspYih0aGlzLnZpcnR1YWxCZW5kc1tmXSkmJihjPW14RXZlbnQuVklSVFVBTF9IQU5ETEUtZik7cmV0dXJuIGN9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc0FkZFZpcnR1YWxCZW5kRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQ3VzdG9tSGFuZGxlRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuITB9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEhhbmRsZUZvckV2ZW50KGIpO2lmKG51bGwhPXRoaXMuYmVuZHMmJm51bGwhPXRoaXMuYmVuZHNbY10pe3ZhciBkPXRoaXMuYmVuZHNbY10uYm91bmRzO3RoaXMuc25hcFBvaW50PW5ldyBteFBvaW50KGQuZ2V0Q2VudGVyWCgpLGQuZ2V0Q2VudGVyWSgpKX1pZih0aGlzLmFkZEVuYWJsZWQmJm51bGw9PWMmJnRoaXMuaXNBZGRQb2ludEV2ZW50KGIuZ2V0RXZlbnQoKSkpdGhpcy5hZGRQb2ludCh0aGlzLnN0YXRlLGIuZ2V0RXZlbnQoKSksYi5jb25zdW1lKCk7ZWxzZSBpZihudWxsIT1jJiYhYi5pc0NvbnN1bWVkKCkmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCkpe2lmKHRoaXMucmVtb3ZlRW5hYmxlZCYmdGhpcy5pc1JlbW92ZVBvaW50RXZlbnQoYi5nZXRFdmVudCgpKSl0aGlzLnJlbW92ZVBvaW50KHRoaXMuc3RhdGUsYyk7ZWxzZSBpZihjIT1teEV2ZW50LkxBQkVMX0hBTkRMRXx8CnRoaXMuZ3JhcGguaXNMYWJlbE1vdmFibGUoYi5nZXRDZWxsKCkpKWM8PW14RXZlbnQuVklSVFVBTF9IQU5ETEUmJm14VXRpbHMuc2V0T3BhY2l0eSh0aGlzLnZpcnR1YWxCZW5kc1tteEV2ZW50LlZJUlRVQUxfSEFORExFLWNdLm5vZGUsMTAwKSx0aGlzLnN0YXJ0KGIuZ2V0WCgpLGIuZ2V0WSgpLGMpO2IuY29uc3VtZSgpfX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGEsYixjKXt0aGlzLnN0YXJ0WD1hO3RoaXMuc3RhcnRZPWI7dGhpcy5pc1NvdXJjZT1udWxsPT10aGlzLmJlbmRzPyExOjA9PWM7dGhpcy5pc1RhcmdldD1udWxsPT10aGlzLmJlbmRzPyExOmM9PXRoaXMuYmVuZHMubGVuZ3RoLTE7dGhpcy5pc0xhYmVsPWM9PW14RXZlbnQuTEFCRUxfSEFORExFO2lmKHRoaXMuaXNTb3VyY2V8fHRoaXMuaXNUYXJnZXQpe2lmKGE9dGhpcy5zdGF0ZS5jZWxsLGI9dGhpcy5ncmFwaC5tb2RlbC5nZXRUZXJtaW5hbChhLHRoaXMuaXNTb3VyY2UpLG51bGw9PWImJnRoaXMuZ3JhcGguaXNUZXJtaW5hbFBvaW50TW92YWJsZShhLHRoaXMuaXNTb3VyY2UpfHxudWxsIT1iJiZ0aGlzLmdyYXBoLmlzQ2VsbERpc2Nvbm5lY3RhYmxlKGEsYix0aGlzLmlzU291cmNlKSl0aGlzLmluZGV4PWN9ZWxzZSB0aGlzLmluZGV4PWM7aWYodGhpcy5pbmRleDw9bXhFdmVudC5DVVNUT01fSEFORExFJiZ0aGlzLmluZGV4PgpteEV2ZW50LlZJUlRVQUxfSEFORExFJiZudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGM9MDtjPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YysrKWMhPW14RXZlbnQuQ1VTVE9NX0hBTkRMRS10aGlzLmluZGV4JiZ0aGlzLmN1c3RvbUhhbmRsZXNbY10uc2V0VmlzaWJsZSghMSl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNsb25lUHJldmlld1N0YXRlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuc3RhdGUuY2xvbmUoKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0U25hcFRvVGVybWluYWxUb2xlcmFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC5ncmlkU2l6ZSp0aGlzLmdyYXBoLnZpZXcuc2NhbGUvMn07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUudXBkYXRlSGludD1mdW5jdGlvbihhLGIpe307bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludD1mdW5jdGlvbigpe307bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucm91bmRMZW5ndGg9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoYSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc1NuYXBUb1Rlcm1pbmFsc0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnNuYXBUb1Rlcm1pbmFscyYmIW14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRQb2ludEZvckV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0VmlldygpLGM9Yi5zY2FsZSxkPW5ldyBteFBvaW50KHRoaXMucm91bmRMZW5ndGgoYS5nZXRHcmFwaFgoKS9jKSpjLHRoaXMucm91bmRMZW5ndGgoYS5nZXRHcmFwaFkoKS9jKSpjKSxlPXRoaXMuZ2V0U25hcFRvVGVybWluYWxUb2xlcmFuY2UoKSxmPSExLGc9ITE7aWYoMDxlJiZ0aGlzLmlzU25hcFRvVGVybWluYWxzRXZlbnQoYSkpe3ZhciBrPWZ1bmN0aW9uKGEpe251bGwhPWEmJmwuY2FsbCh0aGlzLG5ldyBteFBvaW50KGIuZ2V0Um91dGluZ0NlbnRlclgoYSksYi5nZXRSb3V0aW5nQ2VudGVyWShhKSkpfSxsPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPWEueDtNYXRoLmFicyhkLngtYik8ZSYmKGQueD1iLGY9ITApO2E9YS55O01hdGguYWJzKGQueS1hKTxlJiYoZC55PWEsZz0hMCl9fTtrLmNhbGwodGhpcyx0aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKSk7CmsuY2FsbCh0aGlzLHRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITEpKTtpZihudWxsIT10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzKWZvcihrPTA7azx0aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLmxlbmd0aDtrKyspbC5jYWxsKHRoaXMsdGhpcy5zdGF0ZS5hYnNvbHV0ZVBvaW50c1trXSl9dGhpcy5ncmFwaC5pc0dyaWRFbmFibGVkRXZlbnQoYS5nZXRFdmVudCgpKSYmKGE9Yi50cmFuc2xhdGUsZnx8KGQueD0odGhpcy5ncmFwaC5zbmFwKGQueC9jLWEueCkrYS54KSpjKSxnfHwoZC55PSh0aGlzLmdyYXBoLnNuYXAoZC55L2MtYS55KSthLnkpKmMpKTtyZXR1cm4gZH07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmdldFByZXZpZXdUZXJtaW5hbFN0YXRlPWZ1bmN0aW9uKGEpe3RoaXMuY29uc3RyYWludEhhbmRsZXIudXBkYXRlKGEsdGhpcy5pc1NvdXJjZSwhMCxhLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSk/bnVsbDp0aGlzLmN1cnJlbnRQb2ludCk7aWYobnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQpcmV0dXJuIG51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodCYmbnVsbCE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnN0YXRlJiZ0aGlzLm1hcmtlci5oaWdobGlnaHQuc3RhdGUuY2VsbD09dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbD8idHJhbnNwYXJlbnQiIT10aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlJiYodGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZT0idHJhbnNwYXJlbnQiLAp0aGlzLm1hcmtlci5oaWdobGlnaHQucmVwYWludCgpKTp0aGlzLm1hcmtlci5tYXJrQ2VsbCh0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cy5jZWxsLCJ0cmFuc3BhcmVudCIpLGE9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGE9dGhpcy5ncmFwaC52aWV3LmdldFRlcm1pbmFsUG9ydCh0aGlzLnN0YXRlLHRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShhLmdldFRlcm1pbmFsKHRoaXMuc3RhdGUuY2VsbCwhdGhpcy5pc1NvdXJjZSkpLCF0aGlzLmlzU291cmNlKSxhPW51bGwhPWE/YS5jZWxsOm51bGwsdGhpcy5lcnJvcj10aGlzLnZhbGlkYXRlQ29ubmVjdGlvbih0aGlzLmlzU291cmNlP3RoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzLmNlbGw6YSx0aGlzLmlzU291cmNlP2E6dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Rm9jdXMuY2VsbCksYT1udWxsLG51bGw9PXRoaXMuZXJyb3ImJihhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzKSwKKG51bGwhPXRoaXMuZXJyb3J8fG51bGwhPWEmJiF0aGlzLmlzQ2VsbEVuYWJsZWQoYS5jZWxsKSkmJnRoaXMuY29uc3RyYWludEhhbmRsZXIucmVzZXQoKSxhO2lmKHRoaXMuZ3JhcGguaXNJZ25vcmVUZXJtaW5hbEV2ZW50KGEuZ2V0RXZlbnQoKSkpcmV0dXJuIHRoaXMubWFya2VyLnJlc2V0KCksbnVsbDt0aGlzLm1hcmtlci5wcm9jZXNzKGEpO2E9dGhpcy5tYXJrZXIuZ2V0VmFsaWRTdGF0ZSgpO251bGw9PWF8fHRoaXMuaXNDZWxsRW5hYmxlZChhLmNlbGwpfHwodGhpcy5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpLHRoaXMubWFya2VyLnJlc2V0KCkpO3JldHVybiB0aGlzLm1hcmtlci5nZXRWYWxpZFN0YXRlKCl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRQcmV2aWV3UG9pbnRzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKSxjPW51bGwhPWMucG9pbnRzP2MucG9pbnRzLnNsaWNlKCk6bnVsbCxkPW5ldyBteFBvaW50KGEueCxhLnkpLGU9bnVsbDtpZih0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0KXRoaXMuZ3JhcGgucmVzZXRFZGdlc09uQ29ubmVjdCYmKGM9bnVsbCk7ZWxzZSBpZih0aGlzLmNvbnZlcnRQb2ludChkLCExKSxudWxsPT1jKWM9W2RdO2Vsc2V7dGhpcy5pbmRleDw9bXhFdmVudC5WSVJUVUFMX0hBTkRMRSYmYy5zcGxpY2UobXhFdmVudC5WSVJUVUFMX0hBTkRMRS10aGlzLmluZGV4LDAsZCk7aWYoIXRoaXMuaXNTb3VyY2UmJiF0aGlzLmlzVGFyZ2V0KXtmb3IodmFyIGY9MDtmPHRoaXMuYmVuZHMubGVuZ3RoO2YrKylpZihmIT10aGlzLmluZGV4KXt2YXIgZz10aGlzLmJlbmRzW2ZdO251bGwhPWcmJm14VXRpbHMuY29udGFpbnMoZy5ib3VuZHMsCmEueCxhLnkpJiYodGhpcy5pbmRleDw9bXhFdmVudC5WSVJUVUFMX0hBTkRMRT9jLnNwbGljZShteEV2ZW50LlZJUlRVQUxfSEFORExFLXRoaXMuaW5kZXgsMSk6Yy5zcGxpY2UodGhpcy5pbmRleC0xLDEpLGU9Yyl9aWYobnVsbD09ZSYmdGhpcy5zdHJhaWdodFJlbW92ZUVuYWJsZWQmJihudWxsPT1ifHwhbXhFdmVudC5pc0FsdERvd24oYi5nZXRFdmVudCgpKSkpe2Y9dGhpcy5ncmFwaC50b2xlcmFuY2UqdGhpcy5ncmFwaC50b2xlcmFuY2U7Zz10aGlzLnN0YXRlLmFic29sdXRlUG9pbnRzLnNsaWNlKCk7Z1t0aGlzLmluZGV4XT1hO3ZhciBrPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITApO2lmKG51bGwhPWspe3ZhciBsPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvbkNvbnN0cmFpbnQodGhpcy5zdGF0ZSxrLCEwKTtpZihudWxsPT1sfHxudWxsPT10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChrLGwpKWdbMF09bmV3IG14UG9pbnQoay52aWV3LmdldFJvdXRpbmdDZW50ZXJYKGspLAprLnZpZXcuZ2V0Um91dGluZ0NlbnRlclkoaykpfWs9dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSk7bnVsbCE9ayYmKGw9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludCh0aGlzLnN0YXRlLGssITEpLG51bGw9PWx8fG51bGw9PXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KGssbCkpJiYoZ1tnLmxlbmd0aC0xXT1uZXcgbXhQb2ludChrLnZpZXcuZ2V0Um91dGluZ0NlbnRlclgoayksay52aWV3LmdldFJvdXRpbmdDZW50ZXJZKGspKSk7bD10aGlzLmluZGV4OzA8bCYmbDxnLmxlbmd0aC0xJiZteFV0aWxzLnB0U2VnRGlzdFNxKGdbbC0xXS54LGdbbC0xXS55LGdbbCsxXS54LGdbbCsxXS55LGEueCxhLnkpPGYmJihjLnNwbGljZShsLTEsMSksZT1jKX19bnVsbD09ZSYmdGhpcy5pbmRleD5teEV2ZW50LlZJUlRVQUxfSEFORExFJiYoY1t0aGlzLmluZGV4LTFdPWQpfXJldHVybiBudWxsIT1lP2U6Y307Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzT3V0bGluZUNvbm5lY3RFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldE9mZnNldCh0aGlzLmdyYXBoLmNvbnRhaW5lciksYz1hLmdldEV2ZW50KCksZD1teEV2ZW50LmdldENsaWVudFgoYyksYz1teEV2ZW50LmdldENsaWVudFkoYyksZT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsZj10aGlzLmN1cnJlbnRQb2ludC54LXRoaXMuZ3JhcGguY29udGFpbmVyLnNjcm9sbExlZnQrYi54LSgod2luZG93LnBhZ2VYT2Zmc2V0fHxlLnNjcm9sbExlZnQpLShlLmNsaWVudExlZnR8fDApKSxiPXRoaXMuY3VycmVudFBvaW50LnktdGhpcy5ncmFwaC5jb250YWluZXIuc2Nyb2xsVG9wK2IueS0oKHdpbmRvdy5wYWdlWU9mZnNldHx8ZS5zY3JvbGxUb3ApLShlLmNsaWVudFRvcHx8MCkpO3JldHVybiB0aGlzLm91dGxpbmVDb25uZWN0JiYhbXhFdmVudC5pc1NoaWZ0RG93bihhLmdldEV2ZW50KCkpJiYoYS5pc1NvdXJjZSh0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUpfHwKbXhFdmVudC5pc0FsdERvd24oYS5nZXRFdmVudCgpKSYmbnVsbCE9YS5nZXRTdGF0ZSgpfHx0aGlzLm1hcmtlci5oaWdobGlnaHQuaXNIaWdobGlnaHRBdChkLGMpfHwoZiE9ZHx8YiE9YykmJm51bGw9PWEuZ2V0U3RhdGUoKSYmdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LmlzSGlnaGxpZ2h0QXQoZixiKSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U3RhdGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmlzU291cmNlP2M6dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMCksZz10aGlzLmlzVGFyZ2V0P2M6dGhpcy5zdGF0ZS5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSksaz10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsZiwhMCksbD10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KGEsZywhMSksbT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50O251bGw9PW0mJmUmJihudWxsIT1jPyhkLmlzU291cmNlKHRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSkmJihiPW5ldyBteFBvaW50KGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFkoKSkpLG09dGhpcy5ncmFwaC5nZXRPdXRsaW5lQ29uc3RyYWludChiLGMsZCksdGhpcy5jb25zdHJhaW50SGFuZGxlci5zZXRGb2N1cyhkLGMsdGhpcy5pc1NvdXJjZSksCnRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQ9bSx0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRQb2ludD1iKTptPW5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KTtpZih0aGlzLm91dGxpbmVDb25uZWN0JiZudWxsIT10aGlzLm1hcmtlci5oaWdobGlnaHQmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodC5zaGFwZSl7dmFyIG49dGhpcy5ncmFwaC52aWV3LnNjYWxlO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzPyh0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlPWU/bXhDb25zdGFudHMuT1VUTElORV9ISUdITElHSFRfQ09MT1I6InRyYW5zcGFyZW50Iix0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tld2lkdGg9bXhDb25zdGFudHMuT1VUTElORV9ISUdITElHSFRfU1RST0tFV0lEVEgvbi9uLHRoaXMubWFya2VyLmhpZ2hsaWdodC5yZXBhaW50KCkpOgp0aGlzLm1hcmtlci5oYXNWYWxpZFN0YXRlKCkmJih0aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlPXRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoZC5nZXRDZWxsKCkpJiZ0aGlzLm1hcmtlci5nZXRWYWxpZFN0YXRlKCkhPWQuZ2V0U3RhdGUoKT8idHJhbnNwYXJlbnQiOm14Q29uc3RhbnRzLkRFRkFVTFRfVkFMSURfQ09MT1IsdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZXdpZHRoPW14Q29uc3RhbnRzLkhJR0hMSUdIVF9TVFJPS0VXSURUSC9uL24sdGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnJlcGFpbnQoKSl9dGhpcy5pc1NvdXJjZT9rPW06dGhpcy5pc1RhcmdldCYmKGw9bSk7aWYodGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldCludWxsIT1tJiZudWxsIT1tLnBvaW50PyhhLnN0eWxlW3RoaXMuaXNTb3VyY2U/bXhDb25zdGFudHMuU1RZTEVfRVhJVF9YOm14Q29uc3RhbnRzLlNUWUxFX0VOVFJZX1hdPW0ucG9pbnQueCxhLnN0eWxlW3RoaXMuaXNTb3VyY2U/Cm14Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXT1tLnBvaW50LnkpOihkZWxldGUgYS5zdHlsZVt0aGlzLmlzU291cmNlP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWDpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9YXSxkZWxldGUgYS5zdHlsZVt0aGlzLmlzU291cmNlP214Q29uc3RhbnRzLlNUWUxFX0VYSVRfWTpteENvbnN0YW50cy5TVFlMRV9FTlRSWV9ZXSk7YS5zZXRWaXNpYmxlVGVybWluYWxTdGF0ZShmLCEwKTthLnNldFZpc2libGVUZXJtaW5hbFN0YXRlKGcsITEpO3RoaXMuaXNTb3VyY2UmJm51bGw9PWZ8fGEudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoYSxmLCEwLGspO3RoaXMuaXNUYXJnZXQmJm51bGw9PWd8fGEudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnQoYSxnLCExLGwpOyh0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0KSYmbnVsbD09YyYmKGEuc2V0QWJzb2x1dGVUZXJtaW5hbFBvaW50KGIsdGhpcy5pc1NvdXJjZSksCm51bGw9PXRoaXMubWFya2VyLmdldE1hcmtlZFN0YXRlKCkmJih0aGlzLmVycm9yPXRoaXMuZ3JhcGguYWxsb3dEYW5nbGluZ0VkZ2VzP251bGw6IiIpKTthLnZpZXcudXBkYXRlUG9pbnRzKGEsdGhpcy5wb2ludHMsZixnKTthLnZpZXcudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50cyhhLGYsZyl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZU1vdmU9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLmluZGV4JiZudWxsIT10aGlzLm1hcmtlcil7dGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5nZXRQb2ludEZvckV2ZW50KGIpO3RoaXMuZXJyb3I9bnVsbDshdGhpcy5ncmFwaC5pc0lnbm9yZVRlcm1pbmFsRXZlbnQoYi5nZXRFdmVudCgpKSYmbXhFdmVudC5pc1NoaWZ0RG93bihiLmdldEV2ZW50KCkpJiZudWxsIT10aGlzLnNuYXBQb2ludCYmKE1hdGguYWJzKHRoaXMuc25hcFBvaW50LngtdGhpcy5jdXJyZW50UG9pbnQueCk8TWF0aC5hYnModGhpcy5zbmFwUG9pbnQueS10aGlzLmN1cnJlbnRQb2ludC55KT90aGlzLmN1cnJlbnRQb2ludC54PXRoaXMuc25hcFBvaW50Lng6dGhpcy5jdXJyZW50UG9pbnQueT10aGlzLnNuYXBQb2ludC55KTtpZih0aGlzLmluZGV4PD1teEV2ZW50LkNVU1RPTV9IQU5ETEUmJnRoaXMuaW5kZXg+bXhFdmVudC5WSVJUVUFMX0hBTkRMRSludWxsIT0KdGhpcy5jdXN0b21IYW5kbGVzJiZ0aGlzLmN1c3RvbUhhbmRsZXNbbXhFdmVudC5DVVNUT01fSEFORExFLXRoaXMuaW5kZXhdLnByb2Nlc3NFdmVudChiKTtlbHNlIGlmKHRoaXMuaXNMYWJlbCl0aGlzLmxhYmVsLng9dGhpcy5jdXJyZW50UG9pbnQueCx0aGlzLmxhYmVsLnk9dGhpcy5jdXJyZW50UG9pbnQueTtlbHNle3RoaXMucG9pbnRzPXRoaXMuZ2V0UHJldmlld1BvaW50cyh0aGlzLmN1cnJlbnRQb2ludCxiKTt2YXIgYz10aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0P3RoaXMuZ2V0UHJldmlld1Rlcm1pbmFsU3RhdGUoYik6bnVsbDtpZihudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50JiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyYmbnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50UG9pbnQpdGhpcy5jdXJyZW50UG9pbnQ9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50UG9pbnQuY2xvbmUoKTsKZWxzZSBpZih0aGlzLm91dGxpbmVDb25uZWN0KXt2YXIgZD10aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0P3RoaXMuaXNPdXRsaW5lQ29ubmVjdEV2ZW50KGIpOiExO2Q/Yz10aGlzLm1hcmtlci5oaWdobGlnaHQuc3RhdGU6bnVsbCE9YyYmYyE9Yi5nZXRTdGF0ZSgpJiZ0aGlzLmdyYXBoLmlzQ2VsbENvbm5lY3RhYmxlKGIuZ2V0Q2VsbCgpKSYmbnVsbCE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlJiYodGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZT0idHJhbnNwYXJlbnQiLHRoaXMubWFya2VyLmhpZ2hsaWdodC5yZXBhaW50KCksYz1udWxsKX1udWxsPT1jfHx0aGlzLmlzQ2VsbEVuYWJsZWQoYy5jZWxsKXx8KGM9bnVsbCx0aGlzLm1hcmtlci5yZXNldCgpKTt2YXIgZT10aGlzLmNsb25lUHJldmlld1N0YXRlKHRoaXMuY3VycmVudFBvaW50LG51bGwhPWM/Yy5jZWxsOm51bGwpO3RoaXMudXBkYXRlUHJldmlld1N0YXRlKGUsdGhpcy5jdXJyZW50UG9pbnQsCmMsYixkKTt0aGlzLnNldFByZXZpZXdDb2xvcihudWxsPT10aGlzLmVycm9yP3RoaXMubWFya2VyLnZhbGlkQ29sb3I6dGhpcy5tYXJrZXIuaW52YWxpZENvbG9yKTt0aGlzLmFic3BvaW50cz1lLmFic29sdXRlUG9pbnRzO3RoaXMuYWN0aXZlPSEwO3RoaXMudXBkYXRlSGludChiLHRoaXMuY3VycmVudFBvaW50KX10aGlzLmRyYXdQcmV2aWV3KCk7bXhFdmVudC5jb25zdW1lKGIuZ2V0RXZlbnQoKSk7Yi5jb25zdW1lKCl9ZWxzZSBteENsaWVudC5JU19JRSYmbnVsbCE9dGhpcy5nZXRIYW5kbGVGb3JFdmVudChiKSYmYi5jb25zdW1lKCExKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLmluZGV4JiZudWxsIT10aGlzLm1hcmtlcil7dmFyIGM9dGhpcy5zdGF0ZS5jZWxsLGQ9dGhpcy5pbmRleDt0aGlzLmluZGV4PW51bGw7aWYoYi5nZXRYKCkhPXRoaXMuc3RhcnRYfHxiLmdldFkoKSE9dGhpcy5zdGFydFkpe3ZhciBlPSF0aGlzLmdyYXBoLmlzSWdub3JlVGVybWluYWxFdmVudChiLmdldEV2ZW50KCkpJiZ0aGlzLmdyYXBoLmlzQ2xvbmVFdmVudChiLmdldEV2ZW50KCkpJiZ0aGlzLmNsb25lRW5hYmxlZCYmdGhpcy5ncmFwaC5pc0NlbGxzQ2xvbmVhYmxlKCk7aWYobnVsbCE9dGhpcy5lcnJvcikwPHRoaXMuZXJyb3IubGVuZ3RoJiZ0aGlzLmdyYXBoLnZhbGlkYXRpb25BbGVydCh0aGlzLmVycm9yKTtlbHNlIGlmKGQ8PW14RXZlbnQuQ1VTVE9NX0hBTkRMRSYmZD5teEV2ZW50LlZJUlRVQUxfSEFORExFKXtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpe3ZhciBmPQp0aGlzLmdyYXBoLmdldE1vZGVsKCk7Zi5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmN1c3RvbUhhbmRsZXNbbXhFdmVudC5DVVNUT01fSEFORExFLWRdLmV4ZWN1dGUoYil9ZmluYWxseXtmLmVuZFVwZGF0ZSgpfX19ZWxzZSBpZih0aGlzLmlzTGFiZWwpdGhpcy5tb3ZlTGFiZWwodGhpcy5zdGF0ZSx0aGlzLmxhYmVsLngsdGhpcy5sYWJlbC55KTtlbHNlIGlmKHRoaXMuaXNTb3VyY2V8fHRoaXMuaXNUYXJnZXQpaWYoZD1udWxsLG51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudENvbnN0cmFpbnQmJm51bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXIuY3VycmVudEZvY3VzJiYoZD10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cy5jZWxsKSxudWxsPT1kJiZ0aGlzLm1hcmtlci5oYXNWYWxpZFN0YXRlKCkmJm51bGwhPXRoaXMubWFya2VyLmhpZ2hsaWdodCYmbnVsbCE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlJiYidHJhbnNwYXJlbnQiIT10aGlzLm1hcmtlci5oaWdobGlnaHQuc2hhcGUuc3Ryb2tlJiYKIndoaXRlIiE9dGhpcy5tYXJrZXIuaGlnaGxpZ2h0LnNoYXBlLnN0cm9rZSYmKGQ9dGhpcy5tYXJrZXIudmFsaWRTdGF0ZS5jZWxsKSxudWxsIT1kKXt2YXIgZj10aGlzLmdyYXBoLmdldE1vZGVsKCksZz1mLmdldFBhcmVudChjKTtmLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKGUpe3ZhciBrPWYuZ2V0R2VvbWV0cnkoYyksZT10aGlzLmdyYXBoLmNsb25lQ2VsbChjKTtmLmFkZChnLGUsZi5nZXRDaGlsZENvdW50KGcpKTtudWxsIT1rJiYoaz1rLmNsb25lKCksZi5zZXRHZW9tZXRyeShlLGspKTt2YXIgbD1mLmdldFRlcm1pbmFsKGMsIXRoaXMuaXNTb3VyY2UpO3RoaXMuZ3JhcGguY29ubmVjdENlbGwoZSxsLCF0aGlzLmlzU291cmNlKTtjPWV9Yz10aGlzLmNvbm5lY3QoYyxkLHRoaXMuaXNTb3VyY2UsZSxiKX1maW5hbGx5e2YuZW5kVXBkYXRlKCl9fWVsc2UgdGhpcy5ncmFwaC5pc0FsbG93RGFuZ2xpbmdFZGdlcygpJiYoZj10aGlzLmFic3BvaW50c1t0aGlzLmlzU291cmNlPzA6dGhpcy5hYnNwb2ludHMubGVuZ3RoLQoxXSxmLng9dGhpcy5yb3VuZExlbmd0aChmLngvdGhpcy5ncmFwaC52aWV3LnNjYWxlLXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUueCksZi55PXRoaXMucm91bmRMZW5ndGgoZi55L3RoaXMuZ3JhcGgudmlldy5zY2FsZS10aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlLnkpLGs9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChjKSksbnVsbCE9ayYmKGYueC09ay5vcmlnaW4ueCxmLnktPWsub3JpZ2luLnkpLGYueC09dGhpcy5ncmFwaC5wYW5EeC90aGlzLmdyYXBoLnZpZXcuc2NhbGUsZi55LT10aGlzLmdyYXBoLnBhbkR5L3RoaXMuZ3JhcGgudmlldy5zY2FsZSxjPXRoaXMuY2hhbmdlVGVybWluYWxQb2ludChjLGYsdGhpcy5pc1NvdXJjZSxlKSk7ZWxzZSB0aGlzLmFjdGl2ZT9jPXRoaXMuY2hhbmdlUG9pbnRzKGMsdGhpcy5wb2ludHMsZSk6KHRoaXMuZ3JhcGguZ2V0VmlldygpLmludmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsKSwKdGhpcy5ncmFwaC5nZXRWaWV3KCkudmFsaWRhdGUodGhpcy5zdGF0ZS5jZWxsKSl9ZWxzZSB0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoYi5nZXRFdmVudCgpKSYmdGhpcy5ncmFwaC5zZWxlY3RDZWxsRm9yRXZlbnQodGhpcy5zdGF0ZS5jZWxsLGIuZ2V0RXZlbnQoKSk7bnVsbCE9dGhpcy5tYXJrZXImJih0aGlzLnJlc2V0KCksYyE9dGhpcy5zdGF0ZS5jZWxsJiZ0aGlzLmdyYXBoLnNldFNlbGVjdGlvbkNlbGwoYykpO2IuY29uc3VtZSgpfX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5hY3RpdmUmJnRoaXMucmVmcmVzaCgpO3RoaXMuc25hcFBvaW50PXRoaXMucG9pbnRzPXRoaXMubGFiZWw9dGhpcy5pbmRleD10aGlzLmVycm9yPW51bGw7dGhpcy5hY3RpdmU9dGhpcy5pc1RhcmdldD10aGlzLmlzU291cmNlPXRoaXMuaXNMYWJlbD0hMTtpZih0aGlzLmxpdmVQcmV2aWV3JiZudWxsIT10aGlzLnNpemVycylmb3IodmFyIGE9MDthPHRoaXMuc2l6ZXJzLmxlbmd0aDthKyspbnVsbCE9dGhpcy5zaXplcnNbYV0mJih0aGlzLnNpemVyc1thXS5ub2RlLnN0eWxlLmRpc3BsYXk9IiIpO251bGwhPXRoaXMubWFya2VyJiZ0aGlzLm1hcmtlci5yZXNldCgpO251bGwhPXRoaXMuY29uc3RyYWludEhhbmRsZXImJnRoaXMuY29uc3RyYWludEhhbmRsZXIucmVzZXQoKTtpZihudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKGE9MDthPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMuY3VzdG9tSGFuZGxlc1thXS5yZXNldCgpOwp0aGlzLnNldFByZXZpZXdDb2xvcihteENvbnN0YW50cy5FREdFX1NFTEVDVElPTl9DT0xPUik7dGhpcy5yZW1vdmVIaW50KCk7dGhpcy5yZWRyYXcoKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc2V0UHJldmlld0NvbG9yPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLnN0cm9rZT1hKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNvbnZlcnRQb2ludD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0VmlldygpLmdldFNjYWxlKCksZD10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRUcmFuc2xhdGUoKTtiJiYoYS54PXRoaXMuZ3JhcGguc25hcChhLngpLGEueT10aGlzLmdyYXBoLnNuYXAoYS55KSk7YS54PU1hdGgucm91bmQoYS54L2MtZC54KTthLnk9TWF0aC5yb3VuZChhLnkvYy1kLnkpO2M9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudCh0aGlzLnN0YXRlLmNlbGwpKTtudWxsIT1jJiYoYS54LT1jLm9yaWdpbi54LGEueS09Yy5vcmlnaW4ueSk7cmV0dXJuIGF9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3ZlTGFiZWw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxlPWQuZ2V0R2VvbWV0cnkoYS5jZWxsKTtpZihudWxsIT1lKXt2YXIgZj10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZSxlPWUuY2xvbmUoKTtpZihlLnJlbGF0aXZlKXt2YXIgZz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRSZWxhdGl2ZVBvaW50KGEsYixjKTtlLng9TWF0aC5yb3VuZCgxRTQqZy54KS8xRTQ7ZS55PU1hdGgucm91bmQoZy55KTtlLm9mZnNldD1uZXcgbXhQb2ludCgwLDApO2c9dGhpcy5ncmFwaC52aWV3LmdldFBvaW50KGEsZSk7ZS5vZmZzZXQ9bmV3IG14UG9pbnQoTWF0aC5yb3VuZCgoYi1nLngpL2YpLE1hdGgucm91bmQoKGMtZy55KS9mKSl9ZWxzZXt2YXIgaz1hLmFic29sdXRlUG9pbnRzLGc9a1swXSxrPWtbay5sZW5ndGgtMV07bnVsbCE9ZyYmbnVsbCE9ayYmKGUub2Zmc2V0PW5ldyBteFBvaW50KE1hdGgucm91bmQoKGItCihnLngrKGsueC1nLngpLzIpKS9mKSxNYXRoLnJvdW5kKChjLShnLnkrKGsueS1nLnkpLzIpKS9mKSksZS54PTAsZS55PTApfWQuc2V0R2VvbWV0cnkoYS5jZWxsLGUpfX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihhLGIsYyxkLGUpe2Q9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2QuZ2V0UGFyZW50KGEpO2QuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGY9dGhpcy5jb25zdHJhaW50SGFuZGxlci5jdXJyZW50Q29uc3RyYWludDtudWxsPT1mJiYoZj1uZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludCk7dGhpcy5ncmFwaC5jb25uZWN0Q2VsbChhLGIsYyxmKX1maW5hbGx5e2QuZW5kVXBkYXRlKCl9cmV0dXJuIGF9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jaGFuZ2VUZXJtaW5hbFBvaW50PWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKTtlLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKGQpe3ZhciBmPWUuZ2V0UGFyZW50KGEpLGc9ZS5nZXRUZXJtaW5hbChhLCFjKTthPXRoaXMuZ3JhcGguY2xvbmVDZWxsKGEpO2UuYWRkKGYsYSxlLmdldENoaWxkQ291bnQoZikpO2Uuc2V0VGVybWluYWwoYSxnLCFjKX12YXIgaz1lLmdldEdlb21ldHJ5KGEpO251bGwhPWsmJihrPWsuY2xvbmUoKSxrLnNldFRlcm1pbmFsUG9pbnQoYixjKSxlLnNldEdlb21ldHJ5KGEsayksdGhpcy5ncmFwaC5jb25uZWN0Q2VsbChhLG51bGwsYyxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludCkpfWZpbmFsbHl7ZS5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNoYW5nZVBvaW50cz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpO2QuYmVnaW5VcGRhdGUoKTt0cnl7aWYoYyl7dmFyIGU9ZC5nZXRQYXJlbnQoYSksZj1kLmdldFRlcm1pbmFsKGEsITApLGc9ZC5nZXRUZXJtaW5hbChhLCExKTthPXRoaXMuZ3JhcGguY2xvbmVDZWxsKGEpO2QuYWRkKGUsYSxkLmdldENoaWxkQ291bnQoZSkpO2Quc2V0VGVybWluYWwoYSxmLCEwKTtkLnNldFRlcm1pbmFsKGEsZywhMSl9dmFyIGs9ZC5nZXRHZW9tZXRyeShhKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay5wb2ludHM9YixkLnNldEdlb21ldHJ5KGEsaykpfWZpbmFsbHl7ZC5lbmRVcGRhdGUoKX1yZXR1cm4gYX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmFkZFBvaW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5ncmFwaC5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGIpLG14RXZlbnQuZ2V0Q2xpZW50WShiKSksZD10aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWRFdmVudChiKTt0aGlzLmNvbnZlcnRQb2ludChjLGQpO3RoaXMuYWRkUG9pbnRBdChhLGMueCxjLnkpO214RXZlbnQuY29uc3VtZShiKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmFkZFBvaW50QXQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEuY2VsbCk7Yj1uZXcgbXhQb2ludChiLGMpO2lmKG51bGwhPWQpe3ZhciBkPWQuY2xvbmUoKSxlPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGU7Yz10aGlzLmdyYXBoLnZpZXcuc2NhbGU7dmFyIGU9bmV3IG14UG9pbnQoZS54KmMsZS55KmMpLGY9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQodGhpcy5zdGF0ZS5jZWxsKTt0aGlzLmdyYXBoLm1vZGVsLmlzVmVydGV4KGYpJiYoZT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoZiksZT1uZXcgbXhQb2ludChlLngsZS55KSk7Yz1teFV0aWxzLmZpbmROZWFyZXN0U2VnbWVudChhLGIueCpjK2UueCxiLnkqYytlLnkpO251bGw9PWQucG9pbnRzP2QucG9pbnRzPVtiXTpkLnBvaW50cy5zcGxpY2UoYywwLGIpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5zZXRHZW9tZXRyeShhLmNlbGwsZCk7dGhpcy5yZWZyZXNoKCk7CnRoaXMucmVkcmF3KCl9fTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVQb2ludD1mdW5jdGlvbihhLGIpe2lmKDA8YiYmYjx0aGlzLmFic3BvaW50cy5sZW5ndGgtMSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKTtudWxsIT1jJiZudWxsIT1jLnBvaW50cyYmKGM9Yy5jbG9uZSgpLGMucG9pbnRzLnNwbGljZShiLTEsMSksdGhpcy5ncmFwaC5nZXRNb2RlbCgpLnNldEdlb21ldHJ5KGEuY2VsbCxjKSx0aGlzLnJlZnJlc2goKSx0aGlzLnJlZHJhdygpKX19OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVGaWxsQ29sb3I9ZnVuY3Rpb24oYSl7YT0wPT1hO3ZhciBiPXRoaXMuc3RhdGUuY2VsbCxjPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRUZXJtaW5hbChiLGEpLGQ9bXhDb25zdGFudHMuSEFORExFX0ZJTExDT0xPUjtudWxsIT1jJiYhdGhpcy5ncmFwaC5pc0NlbGxEaXNjb25uZWN0YWJsZShiLGMsYSl8fG51bGw9PWMmJiF0aGlzLmdyYXBoLmlzVGVybWluYWxQb2ludE1vdmFibGUoYixhKT9kPW14Q29uc3RhbnRzLkxPQ0tFRF9IQU5ETEVfRklMTENPTE9SOm51bGwhPWMmJnRoaXMuZ3JhcGguaXNDZWxsRGlzY29ubmVjdGFibGUoYixjLGEpJiYoZD1teENvbnN0YW50cy5DT05ORUNUX0hBTkRMRV9GSUxMQ09MT1IpO3JldHVybiBkfTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKGEpe3RoaXMuYWJzcG9pbnRzPXRoaXMuc3RhdGUuYWJzb2x1dGVQb2ludHMuc2xpY2UoKTt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0R2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKTtpZihudWxsIT1iJiYoYj1iLnBvaW50cyxudWxsIT10aGlzLmJlbmRzJiYwPHRoaXMuYmVuZHMubGVuZ3RoJiZudWxsIT1iKSl7bnVsbD09dGhpcy5wb2ludHMmJih0aGlzLnBvaW50cz1bXSk7Zm9yKHZhciBjPTE7Yzx0aGlzLmJlbmRzLmxlbmd0aC0xO2MrKyludWxsIT10aGlzLmJlbmRzW2NdJiZudWxsIT10aGlzLmFic3BvaW50c1tjXSYmKHRoaXMucG9pbnRzW2MtMV09YltjLTFdKX10aGlzLmRyYXdQcmV2aWV3KCk7YXx8dGhpcy5yZWRyYXdIYW5kbGVzKCl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdIYW5kbGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGF0ZS5jZWxsLGI9dGhpcy5sYWJlbFNoYXBlLmJvdW5kczt0aGlzLmxhYmVsPW5ldyBteFBvaW50KHRoaXMuc3RhdGUuYWJzb2x1dGVPZmZzZXQueCx0aGlzLnN0YXRlLmFic29sdXRlT2Zmc2V0LnkpO3RoaXMubGFiZWxTaGFwZS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQodGhpcy5sYWJlbC54LWIud2lkdGgvMiksTWF0aC5yb3VuZCh0aGlzLmxhYmVsLnktYi5oZWlnaHQvMiksYi53aWR0aCxiLmhlaWdodCk7Yj10aGlzLmdyYXBoLmdldExhYmVsKGEpO3RoaXMubGFiZWxTaGFwZS52aXNpYmxlPW51bGwhPWImJjA8Yi5sZW5ndGgmJnRoaXMuZ3JhcGguaXNMYWJlbE1vdmFibGUoYSk7aWYobnVsbCE9dGhpcy5iZW5kcyYmMDx0aGlzLmJlbmRzLmxlbmd0aCl7dmFyIGM9dGhpcy5hYnNwb2ludHMubGVuZ3RoLTEsYT10aGlzLmFic3BvaW50c1swXSxkPWEueCwKZT1hLnksYj10aGlzLmJlbmRzWzBdLmJvdW5kczt0aGlzLmJlbmRzWzBdLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5mbG9vcihkLWIud2lkdGgvMiksTWF0aC5mbG9vcihlLWIuaGVpZ2h0LzIpLGIud2lkdGgsYi5oZWlnaHQpO3RoaXMuYmVuZHNbMF0uZmlsbD10aGlzLmdldEhhbmRsZUZpbGxDb2xvcigwKTt0aGlzLmJlbmRzWzBdLnJlZHJhdygpO3RoaXMubWFuYWdlTGFiZWxIYW5kbGUmJnRoaXMuY2hlY2tMYWJlbEhhbmRsZSh0aGlzLmJlbmRzWzBdLmJvdW5kcyk7dmFyIGM9dGhpcy5hYnNwb2ludHNbY10sZD1jLngsZT1jLnksZj10aGlzLmJlbmRzLmxlbmd0aC0xLGI9dGhpcy5iZW5kc1tmXS5ib3VuZHM7dGhpcy5iZW5kc1tmXS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGguZmxvb3IoZC1iLndpZHRoLzIpLE1hdGguZmxvb3IoZS1iLmhlaWdodC8yKSxiLndpZHRoLGIuaGVpZ2h0KTt0aGlzLmJlbmRzW2ZdLmZpbGw9dGhpcy5nZXRIYW5kbGVGaWxsQ29sb3IoZik7CnRoaXMuYmVuZHNbZl0ucmVkcmF3KCk7dGhpcy5tYW5hZ2VMYWJlbEhhbmRsZSYmdGhpcy5jaGVja0xhYmVsSGFuZGxlKHRoaXMuYmVuZHNbZl0uYm91bmRzKTt0aGlzLnJlZHJhd0lubmVyQmVuZHMoYSxjKX1pZihudWxsIT10aGlzLmFic3BvaW50cyYmbnVsbCE9dGhpcy52aXJ0dWFsQmVuZHMmJjA8dGhpcy52aXJ0dWFsQmVuZHMubGVuZ3RoKWZvcihjPXRoaXMuYWJzcG9pbnRzWzBdLGE9MDthPHRoaXMudmlydHVhbEJlbmRzLmxlbmd0aDthKyspbnVsbCE9dGhpcy52aXJ0dWFsQmVuZHNbYV0mJm51bGwhPXRoaXMuYWJzcG9pbnRzW2ErMV0mJihkPXRoaXMuYWJzcG9pbnRzW2ErMV0sYj10aGlzLnZpcnR1YWxCZW5kc1thXSxiLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5mbG9vcihjLngrKGQueC1jLngpLzItYi5ib3VuZHMud2lkdGgvMiksTWF0aC5mbG9vcihjLnkrKGQueS1jLnkpLzItYi5ib3VuZHMuaGVpZ2h0LzIpLGIuYm91bmRzLndpZHRoLGIuYm91bmRzLmhlaWdodCksCmIucmVkcmF3KCksbXhVdGlscy5zZXRPcGFjaXR5KGIubm9kZSx0aGlzLnZpcnR1YWxCZW5kT3BhY2l0eSksYz1kLHRoaXMubWFuYWdlTGFiZWxIYW5kbGUmJnRoaXMuY2hlY2tMYWJlbEhhbmRsZShiLmJvdW5kcykpO251bGwhPXRoaXMubGFiZWxTaGFwZSYmdGhpcy5sYWJlbFNoYXBlLnJlZHJhdygpO2lmKG51bGwhPXRoaXMuY3VzdG9tSGFuZGxlcylmb3IoYT0wO2E8dGhpcy5jdXN0b21IYW5kbGVzLmxlbmd0aDthKyspYj10aGlzLmN1c3RvbUhhbmRsZXNbYV0uc2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5LHRoaXMuY3VzdG9tSGFuZGxlc1thXS5yZWRyYXcoKSx0aGlzLmN1c3RvbUhhbmRsZXNbYV0uc2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PWIsdGhpcy5jdXN0b21IYW5kbGVzW2FdLnNoYXBlLm5vZGUuc3R5bGUudmlzaWJpbGl0eT10aGlzLmlzQ3VzdG9tSGFuZGxlVmlzaWJsZSh0aGlzLmN1c3RvbUhhbmRsZXNbYV0pPyIiOiJoaWRkZW4ifTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNDdXN0b21IYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmdyYXBoLmlzRWRpdGluZygpJiYxPT10aGlzLnN0YXRlLnZpZXcuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuYmVuZHMpZm9yKHZhciBiPTA7Yjx0aGlzLmJlbmRzLmxlbmd0aDtiKyspdGhpcy5iZW5kc1tiXS5ub2RlLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSI7aWYobnVsbCE9dGhpcy52aXJ0dWFsQmVuZHMpZm9yKGI9MDtiPHRoaXMudmlydHVhbEJlbmRzLmxlbmd0aDtiKyspdGhpcy52aXJ0dWFsQmVuZHNbYl0ubm9kZS5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiO251bGwhPXRoaXMubGFiZWxTaGFwZSYmKHRoaXMubGFiZWxTaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSIpO2lmKG51bGwhPXRoaXMuY3VzdG9tSGFuZGxlcylmb3IoYj0wO2I8dGhpcy5jdXN0b21IYW5kbGVzLmxlbmd0aDtiKyspdGhpcy5jdXN0b21IYW5kbGVzW2JdLnNldFZpc2libGUoYSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdJbm5lckJlbmRzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTE7Yzx0aGlzLmJlbmRzLmxlbmd0aC0xO2MrKylpZihudWxsIT10aGlzLmJlbmRzW2NdKWlmKG51bGwhPXRoaXMuYWJzcG9pbnRzW2NdKXt2YXIgZD10aGlzLmFic3BvaW50c1tjXS54LGU9dGhpcy5hYnNwb2ludHNbY10ueSxmPXRoaXMuYmVuZHNbY10uYm91bmRzO3RoaXMuYmVuZHNbY10ubm9kZS5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIjt0aGlzLmJlbmRzW2NdLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChkLWYud2lkdGgvMiksTWF0aC5yb3VuZChlLWYuaGVpZ2h0LzIpLGYud2lkdGgsZi5oZWlnaHQpO3RoaXMubWFuYWdlTGFiZWxIYW5kbGU/dGhpcy5jaGVja0xhYmVsSGFuZGxlKHRoaXMuYmVuZHNbY10uYm91bmRzKTpudWxsPT10aGlzLmhhbmRsZUltYWdlJiZ0aGlzLmxhYmVsU2hhcGUudmlzaWJsZSYmbXhVdGlscy5pbnRlcnNlY3RzKHRoaXMuYmVuZHNbY10uYm91bmRzLAp0aGlzLmxhYmVsU2hhcGUuYm91bmRzKSYmKHc9bXhDb25zdGFudHMuSEFORExFX1NJWkUrMyxoPW14Q29uc3RhbnRzLkhBTkRMRV9TSVpFKzMsdGhpcy5iZW5kc1tjXS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKE1hdGgucm91bmQoZC13LzIpLE1hdGgucm91bmQoZS1oLzIpLHcsaCkpO3RoaXMuYmVuZHNbY10ucmVkcmF3KCl9ZWxzZSB0aGlzLmJlbmRzW2NdLmRlc3Ryb3koKSx0aGlzLmJlbmRzW2NdPW51bGx9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNoZWNrTGFiZWxIYW5kbGU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9dGhpcy5sYWJlbFNoYXBlKXt2YXIgYj10aGlzLmxhYmVsU2hhcGUuYm91bmRzO214VXRpbHMuaW50ZXJzZWN0cyhhLGIpJiYoYS5nZXRDZW50ZXJZKCk8Yi5nZXRDZW50ZXJZKCk/Yi55PWEueSthLmhlaWdodDpiLnk9YS55LWIuaGVpZ2h0KX19OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5kcmF3UHJldmlldz1mdW5jdGlvbigpe2lmKHRoaXMuaXNMYWJlbCl7dmFyIGE9dGhpcy5sYWJlbFNoYXBlLmJvdW5kcyxhPW5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKHRoaXMubGFiZWwueC1hLndpZHRoLzIpLE1hdGgucm91bmQodGhpcy5sYWJlbC55LWEuaGVpZ2h0LzIpLGEud2lkdGgsYS5oZWlnaHQpO3RoaXMubGFiZWxTaGFwZS5ib3VuZHMuZXF1YWxzKGEpfHwodGhpcy5sYWJlbFNoYXBlLmJvdW5kcz1hLHRoaXMubGFiZWxTaGFwZS5yZWRyYXcoKSl9bnVsbD09dGhpcy5zaGFwZXx8bXhVdGlscy5lcXVhbFBvaW50cyh0aGlzLnNoYXBlLnBvaW50cyx0aGlzLmFic3BvaW50cyl8fCh0aGlzLnNoYXBlLmFwcGx5KHRoaXMuc3RhdGUpLHRoaXMuc2hhcGUucG9pbnRzPXRoaXMuYWJzcG9pbnRzLnNsaWNlKCksdGhpcy5zaGFwZS5zY2FsZT10aGlzLnN0YXRlLnZpZXcuc2NhbGUsdGhpcy5zaGFwZS5pc0Rhc2hlZD10aGlzLmlzU2VsZWN0aW9uRGFzaGVkKCksCnRoaXMuc2hhcGUuc3Ryb2tlPXRoaXMuZ2V0U2VsZWN0aW9uQ29sb3IoKSx0aGlzLnNoYXBlLnN0cm9rZXdpZHRoPXRoaXMuZ2V0U2VsZWN0aW9uU3Ryb2tlV2lkdGgoKS90aGlzLnNoYXBlLnNjYWxlL3RoaXMuc2hhcGUuc2NhbGUsdGhpcy5zaGFwZS5pc1NoYWRvdz0hMSx0aGlzLnNoYXBlLnJlZHJhdygpKTtudWxsIT10aGlzLnBhcmVudEhpZ2hsaWdodCYmdGhpcy5wYXJlbnRIaWdobGlnaHQucmVkcmF3KCl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dGhpcy5hYnNwb2ludHM9dGhpcy5nZXRTZWxlY3Rpb25Qb2ludHModGhpcy5zdGF0ZSk7dGhpcy5wb2ludHM9W107bnVsbCE9dGhpcy5iZW5kcyYmKHRoaXMuZGVzdHJveUJlbmRzKHRoaXMuYmVuZHMpLHRoaXMuYmVuZHM9dGhpcy5jcmVhdGVCZW5kcygpKTtudWxsIT10aGlzLnZpcnR1YWxCZW5kcyYmKHRoaXMuZGVzdHJveUJlbmRzKHRoaXMudmlydHVhbEJlbmRzKSx0aGlzLnZpcnR1YWxCZW5kcz10aGlzLmNyZWF0ZVZpcnR1YWxCZW5kcygpKTtudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMmJih0aGlzLmRlc3Ryb3lCZW5kcyh0aGlzLmN1c3RvbUhhbmRsZXMpLHRoaXMuY3VzdG9tSGFuZGxlcz10aGlzLmNyZWF0ZUN1c3RvbUhhbmRsZXMoKSk7bnVsbCE9dGhpcy5sYWJlbFNoYXBlJiZudWxsIT10aGlzLmxhYmVsU2hhcGUubm9kZSYmbnVsbCE9dGhpcy5sYWJlbFNoYXBlLm5vZGUucGFyZW50Tm9kZSYmdGhpcy5sYWJlbFNoYXBlLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsU2hhcGUubm9kZSl9OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95QmVuZHM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSlmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyludWxsIT1hW2JdJiZhW2JdLmRlc3Ryb3koKX07Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmVzY2FwZUhhbmRsZXImJih0aGlzLnN0YXRlLnZpZXcuZ3JhcGgucmVtb3ZlTGlzdGVuZXIodGhpcy5lc2NhcGVIYW5kbGVyKSx0aGlzLmVzY2FwZUhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5tYXJrZXImJih0aGlzLm1hcmtlci5kZXN0cm95KCksdGhpcy5tYXJrZXI9bnVsbCk7bnVsbCE9dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGUuZGVzdHJveSgpLHRoaXMuc2hhcGU9bnVsbCk7bnVsbCE9dGhpcy5wYXJlbnRIaWdobGlnaHQmJih0aGlzLnBhcmVudEhpZ2hsaWdodC5kZXN0cm95KCksdGhpcy5wYXJlbnRIaWdobGlnaHQ9bnVsbCk7bnVsbCE9dGhpcy5sYWJlbFNoYXBlJiYodGhpcy5sYWJlbFNoYXBlLmRlc3Ryb3koKSx0aGlzLmxhYmVsU2hhcGU9bnVsbCk7bnVsbCE9dGhpcy5jb25zdHJhaW50SGFuZGxlciYmKHRoaXMuY29uc3RyYWludEhhbmRsZXIuZGVzdHJveSgpLHRoaXMuY29uc3RyYWludEhhbmRsZXI9Cm51bGwpO3RoaXMuZGVzdHJveUJlbmRzKHRoaXMudmlydHVhbEJlbmRzKTt0aGlzLnZpcnR1YWxCZW5kcz1udWxsO3RoaXMuZGVzdHJveUJlbmRzKHRoaXMuY3VzdG9tSGFuZGxlcyk7dGhpcy5jdXN0b21IYW5kbGVzPW51bGw7dGhpcy5kZXN0cm95QmVuZHModGhpcy5iZW5kcyk7dGhpcy5iZW5kcz1udWxsO3RoaXMucmVtb3ZlSGludCgpfTtmdW5jdGlvbiBteEVsYm93RWRnZUhhbmRsZXIoYSl7bXhFZGdlSGFuZGxlci5jYWxsKHRoaXMsYSl9bXhVdGlscy5leHRlbmQobXhFbGJvd0VkZ2VIYW5kbGVyLG14RWRnZUhhbmRsZXIpO214RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuZmxpcEVuYWJsZWQ9ITA7bXhFbGJvd0VkZ2VIYW5kbGVyLnByb3RvdHlwZS5kb3VibGVDbGlja09yaWVudGF0aW9uUmVzb3VyY2U9Im5vbmUiIT1teENsaWVudC5sYW5ndWFnZT8iZG91YmxlQ2xpY2tPcmllbnRhdGlvbiI6IiI7Cm14RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlQmVuZHM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiPXRoaXMuY3JlYXRlSGFuZGxlU2hhcGUoMCk7dGhpcy5pbml0QmVuZChiKTtiLnNldEN1cnNvcihteENvbnN0YW50cy5DVVJTT1JfVEVSTUlOQUxfSEFORExFKTthLnB1c2goYik7YS5wdXNoKHRoaXMuY3JlYXRlVmlydHVhbEJlbmQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7IW14RXZlbnQuaXNDb25zdW1lZChhKSYmdGhpcy5mbGlwRW5hYmxlZCYmKHRoaXMuZ3JhcGguZmxpcEVkZ2UodGhpcy5zdGF0ZS5jZWxsLGEpLG14RXZlbnQuY29uc3VtZShhKSl9KSkpO3RoaXMucG9pbnRzLnB1c2gobmV3IG14UG9pbnQoMCwwKSk7Yj10aGlzLmNyZWF0ZUhhbmRsZVNoYXBlKDIpO3RoaXMuaW5pdEJlbmQoYik7Yi5zZXRDdXJzb3IobXhDb25zdGFudHMuQ1VSU09SX1RFUk1JTkFMX0hBTkRMRSk7YS5wdXNoKGIpO3JldHVybiBhfTsKbXhFbGJvd0VkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVWaXJ0dWFsQmVuZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNyZWF0ZUhhbmRsZVNoYXBlKCk7dGhpcy5pbml0QmVuZChiLGEpO2Iuc2V0Q3Vyc29yKHRoaXMuZ2V0Q3Vyc29yRm9yQmVuZCgpKTt0aGlzLmdyYXBoLmlzQ2VsbEJlbmRhYmxlKHRoaXMuc3RhdGUuY2VsbCl8fChiLm5vZGUuc3R5bGUuZGlzcGxheT0ibm9uZSIpO3JldHVybiBifTsKbXhFbGJvd0VkZ2VIYW5kbGVyLnByb3RvdHlwZS5nZXRDdXJzb3JGb3JCZW5kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRURHRV09PW14RWRnZVN0eWxlLlRvcFRvQm90dG9tfHx0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VER0VdPT1teENvbnN0YW50cy5FREdFU1RZTEVfVE9QVE9CT1RUT018fCh0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VER0VdPT1teEVkZ2VTdHlsZS5FbGJvd0Nvbm5lY3Rvcnx8dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FREdFXT09bXhDb25zdGFudHMuRURHRVNUWUxFX0VMQk9XKSYmdGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTEJPV109PW14Q29uc3RhbnRzLkVMQk9XX1ZFUlRJQ0FMPyJyb3ctcmVzaXplIjoiY29sLXJlc2l6ZSJ9OwpteEVsYm93RWRnZUhhbmRsZXIucHJvdG90eXBlLmdldFRvb2x0aXBGb3JOb2RlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbD09dGhpcy5iZW5kc3x8bnVsbD09dGhpcy5iZW5kc1sxXXx8YSE9dGhpcy5iZW5kc1sxXS5ub2RlJiZhLnBhcmVudE5vZGUhPXRoaXMuYmVuZHNbMV0ubm9kZXx8KGI9dGhpcy5kb3VibGVDbGlja09yaWVudGF0aW9uUmVzb3VyY2UsYj1teFJlc291cmNlcy5nZXQoYil8fGIpO3JldHVybiBifTsKbXhFbGJvd0VkZ2VIYW5kbGVyLnByb3RvdHlwZS5jb252ZXJ0UG9pbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTY2FsZSgpLGQ9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0VHJhbnNsYXRlKCksZT10aGlzLnN0YXRlLm9yaWdpbjtiJiYoYS54PXRoaXMuZ3JhcGguc25hcChhLngpLGEueT10aGlzLmdyYXBoLnNuYXAoYS55KSk7YS54PU1hdGgucm91bmQoYS54L2MtZC54LWUueCk7YS55PU1hdGgucm91bmQoYS55L2MtZC55LWUueSk7cmV0dXJuIGF9OwpteEVsYm93RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0lubmVyQmVuZHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0R2VvbWV0cnkodGhpcy5zdGF0ZS5jZWxsKSxkPXRoaXMuc3RhdGUuYWJzb2x1dGVQb2ludHMsZT1udWxsOzE8ZC5sZW5ndGg/KGE9ZFsxXSxiPWRbZC5sZW5ndGgtMl0pOm51bGwhPWMucG9pbnRzJiYwPGMucG9pbnRzLmxlbmd0aCYmKGU9ZFswXSk7ZT1udWxsPT1lP25ldyBteFBvaW50KGEueCsoYi54LWEueCkvMixhLnkrKGIueS1hLnkpLzIpOm5ldyBteFBvaW50KHRoaXMuZ3JhcGguZ2V0VmlldygpLnNjYWxlKihlLngrdGhpcy5ncmFwaC5nZXRWaWV3KCkudHJhbnNsYXRlLngrdGhpcy5zdGF0ZS5vcmlnaW4ueCksdGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUqKGUueSt0aGlzLmdyYXBoLmdldFZpZXcoKS50cmFuc2xhdGUueSt0aGlzLnN0YXRlLm9yaWdpbi55KSk7ZD10aGlzLmJlbmRzWzFdLmJvdW5kcztjPWQud2lkdGg7CmQ9ZC5oZWlnaHQ7Yz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5yb3VuZChlLngtYy8yKSxNYXRoLnJvdW5kKGUueS1kLzIpLGMsZCk7dGhpcy5tYW5hZ2VMYWJlbEhhbmRsZT90aGlzLmNoZWNrTGFiZWxIYW5kbGUoYyk6bnVsbD09dGhpcy5oYW5kbGVJbWFnZSYmdGhpcy5sYWJlbFNoYXBlLnZpc2libGUmJm14VXRpbHMuaW50ZXJzZWN0cyhjLHRoaXMubGFiZWxTaGFwZS5ib3VuZHMpJiYoYz1teENvbnN0YW50cy5IQU5ETEVfU0laRSszLGQ9bXhDb25zdGFudHMuSEFORExFX1NJWkUrMyxjPW5ldyBteFJlY3RhbmdsZShNYXRoLmZsb29yKGUueC1jLzIpLE1hdGguZmxvb3IoZS55LWQvMiksYyxkKSk7dGhpcy5iZW5kc1sxXS5ib3VuZHM9Yzt0aGlzLmJlbmRzWzFdLnJlZHJhdygpO3RoaXMubWFuYWdlTGFiZWxIYW5kbGUmJnRoaXMuY2hlY2tMYWJlbEhhbmRsZSh0aGlzLmJlbmRzWzFdLmJvdW5kcyl9OwpmdW5jdGlvbiBteEVkZ2VTZWdtZW50SGFuZGxlcihhKXtteEVkZ2VIYW5kbGVyLmNhbGwodGhpcyxhKX1teFV0aWxzLmV4dGVuZChteEVkZ2VTZWdtZW50SGFuZGxlcixteEVsYm93RWRnZUhhbmRsZXIpOwpteEVkZ2VTZWdtZW50SGFuZGxlci5wcm90b3R5cGUuZ2V0Q3VycmVudFBvaW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc3RhdGUuYWJzb2x1dGVQb2ludHM7aWYobnVsbCE9YSl7dmFyIGI9TWF0aC5tYXgoMSx0aGlzLmdyYXBoLnZpZXcuc2NhbGUpO2lmKDI9PWEubGVuZ3RofHwzPT1hLmxlbmd0aCYmKE1hdGguYWJzKGFbMF0ueC1hWzFdLngpPGImJk1hdGguYWJzKGFbMV0ueC1hWzJdLngpPGJ8fE1hdGguYWJzKGFbMF0ueS1hWzFdLnkpPGImJk1hdGguYWJzKGFbMV0ueS1hWzJdLnkpPGIpKXZhciBiPWFbMF0ueCsoYVthLmxlbmd0aC0xXS54LWFbMF0ueCkvMixjPWFbMF0ueSsoYVthLmxlbmd0aC0xXS55LWFbMF0ueSkvMixhPVthWzBdLG5ldyBteFBvaW50KGIsYyksbmV3IG14UG9pbnQoYixjKSxhW2EubGVuZ3RoLTFdXX1yZXR1cm4gYX07Cm14RWRnZVNlZ21lbnRIYW5kbGVyLnByb3RvdHlwZS5nZXRQcmV2aWV3UG9pbnRzPWZ1bmN0aW9uKGEpe2lmKHRoaXMuaXNTb3VyY2V8fHRoaXMuaXNUYXJnZXQpcmV0dXJuIG14RWxib3dFZGdlSGFuZGxlci5wcm90b3R5cGUuZ2V0UHJldmlld1BvaW50cy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9dGhpcy5nZXRDdXJyZW50UG9pbnRzKCksYz10aGlzLmNvbnZlcnRQb2ludChiWzBdLmNsb25lKCksITEpO2E9dGhpcy5jb252ZXJ0UG9pbnQoYS5jbG9uZSgpLCExKTtmb3IodmFyIGQ9W10sZT0xO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLmNvbnZlcnRQb2ludChiW2VdLmNsb25lKCksITEpO2U9PXRoaXMuaW5kZXgmJigwPT1NYXRoLnJvdW5kKGMueC1mLngpJiYoYy54PWEueCxmLng9YS54KSwwPT1NYXRoLnJvdW5kKGMueS1mLnkpJiYoYy55PWEueSxmLnk9YS55KSk7ZTxiLmxlbmd0aC0xJiZkLnB1c2goZik7Yz1mfWlmKDE9PWQubGVuZ3RoKXt2YXIgYj10aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKSwKYz10aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCExKSxmPXRoaXMuc3RhdGUudmlldy5nZXRTY2FsZSgpLGc9dGhpcy5zdGF0ZS52aWV3LmdldFRyYW5zbGF0ZSgpLGU9ZFswXS54KmYrZy54LGY9ZFswXS55KmYrZy55O2lmKG51bGwhPWImJm14VXRpbHMuY29udGFpbnMoYixlLGYpfHxudWxsIT1jJiZteFV0aWxzLmNvbnRhaW5zKGMsZSxmKSlkPVthLGFdfXJldHVybiBkfTsKbXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVByZXZpZXdTdGF0ZT1mdW5jdGlvbihhLGIsYyxkKXtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U3RhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKCF0aGlzLmlzU291cmNlJiYhdGhpcy5pc1RhcmdldCl7Yj10aGlzLmNvbnZlcnRQb2ludChiLmNsb25lKCksITEpO2Zvcih2YXIgZT1hLmFic29sdXRlUG9pbnRzLGY9ZVswXSxnPWVbMV0saz1bXSxsPTI7bDxlLmxlbmd0aDtsKyspe3ZhciBtPWVbbF07MD09TWF0aC5yb3VuZChmLngtZy54KSYmMD09TWF0aC5yb3VuZChnLngtbS54KXx8MD09TWF0aC5yb3VuZChmLnktZy55KSYmMD09TWF0aC5yb3VuZChnLnktbS55KXx8ay5wdXNoKHRoaXMuY29udmVydFBvaW50KGcuY2xvbmUoKSwhMSkpO2Y9ZztnPW19Zj10aGlzLnN0YXRlLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKTtnPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoITEpOwpsPXRoaXMuc3RhdGUuYWJzb2x1dGVQb2ludHM7aWYoMD09ay5sZW5ndGgmJigwPT1NYXRoLnJvdW5kKGVbMF0ueC1lW2UubGVuZ3RoLTFdLngpfHwwPT1NYXRoLnJvdW5kKGVbMF0ueS1lW2UubGVuZ3RoLTFdLnkpKSlrPVtiLGJdO2Vsc2UgaWYoNT09ZS5sZW5ndGgmJjI9PWsubGVuZ3RoJiZudWxsIT1mJiZudWxsIT1nJiZudWxsIT1sJiYwPT1NYXRoLnJvdW5kKGxbMF0ueC1sW2wubGVuZ3RoLTFdLngpKXt2YXIgaz10aGlzLmdyYXBoLmdldFZpZXcoKSxsPWsuZ2V0U2NhbGUoKSxtPWsuZ2V0VHJhbnNsYXRlKCksZT1rLmdldFJvdXRpbmdDZW50ZXJZKGYpL2wtbS55LG49dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludChhLGYsITApO251bGwhPW4mJihuPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KGYsbiksbnVsbCE9biYmKHRoaXMuY29udmVydFBvaW50KG4sITEpLGU9bi55KSk7az1rLmdldFJvdXRpbmdDZW50ZXJZKGcpL2wtbS55O2lmKGw9dGhpcy5ncmFwaC5nZXRDb25uZWN0aW9uQ29uc3RyYWludChhLApnLCExKSluPXRoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KGcsbCksbnVsbCE9biYmKHRoaXMuY29udmVydFBvaW50KG4sITEpLGs9bi55KTtrPVtuZXcgbXhQb2ludChiLngsZSksbmV3IG14UG9pbnQoYi54LGspXX10aGlzLnBvaW50cz1rO2Eudmlldy51cGRhdGVGaXhlZFRlcm1pbmFsUG9pbnRzKGEsZixnKTthLnZpZXcudXBkYXRlUG9pbnRzKGEsdGhpcy5wb2ludHMsZixnKTthLnZpZXcudXBkYXRlRmxvYXRpbmdUZXJtaW5hbFBvaW50cyhhLGYsZyl9fTsKbXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmdyYXBoLmdldE1vZGVsKCksZz1mLmdldEdlb21ldHJ5KGEpLGs9bnVsbDtpZihudWxsIT1nJiZudWxsIT1nLnBvaW50cyYmMDxnLnBvaW50cy5sZW5ndGgpZm9yKHZhciBsPXRoaXMuYWJzcG9pbnRzLG09bFswXSxuPWxbMV0saz1bXSxwPTI7cDxsLmxlbmd0aDtwKyspe3ZhciBxPWxbcF07MD09TWF0aC5yb3VuZChtLngtbi54KSYmMD09TWF0aC5yb3VuZChuLngtcS54KXx8MD09TWF0aC5yb3VuZChtLnktbi55KSYmMD09TWF0aC5yb3VuZChuLnktcS55KXx8ay5wdXNoKHRoaXMuY29udmVydFBvaW50KG4uY2xvbmUoKSwhMSkpO209bjtuPXF9Zi5iZWdpblVwZGF0ZSgpO3RyeXtudWxsIT1rJiYoZz1mLmdldEdlb21ldHJ5KGEpLG51bGwhPWcmJihnPWcuY2xvbmUoKSxnLnBvaW50cz1rLGYuc2V0R2VvbWV0cnkoYSxnKSkpLGE9bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdC5hcHBseSh0aGlzLAphcmd1bWVudHMpfWZpbmFsbHl7Zi5lbmRVcGRhdGUoKX1yZXR1cm4gYX07bXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLmdldFRvb2x0aXBGb3JOb2RlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsfTtteEVkZ2VTZWdtZW50SGFuZGxlci5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oYSxiLGMpe214RWRnZUhhbmRsZXIucHJvdG90eXBlLnN0YXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsPT10aGlzLmJlbmRzfHxudWxsPT10aGlzLmJlbmRzW2NdfHx0aGlzLmlzU291cmNlfHx0aGlzLmlzVGFyZ2V0fHxteFV0aWxzLnNldE9wYWNpdHkodGhpcy5iZW5kc1tjXS5ub2RlLDEwMCl9OwpteEVkZ2VTZWdtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlQmVuZHM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiPXRoaXMuY3JlYXRlSGFuZGxlU2hhcGUoMCk7dGhpcy5pbml0QmVuZChiKTtiLnNldEN1cnNvcihteENvbnN0YW50cy5DVVJTT1JfVEVSTUlOQUxfSEFORExFKTthLnB1c2goYik7dmFyIGM9dGhpcy5nZXRDdXJyZW50UG9pbnRzKCk7aWYodGhpcy5ncmFwaC5pc0NlbGxCZW5kYWJsZSh0aGlzLnN0YXRlLmNlbGwpKXtudWxsPT10aGlzLnBvaW50cyYmKHRoaXMucG9pbnRzPVtdKTtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoLTE7ZCsrKXtiPXRoaXMuY3JlYXRlVmlydHVhbEJlbmQoKTthLnB1c2goYik7dmFyIGU9MD09TWF0aC5yb3VuZChjW2RdLngtY1tkKzFdLngpOzA9PU1hdGgucm91bmQoY1tkXS55LWNbZCsxXS55KSYmZDxjLmxlbmd0aC0yJiYoZT0wPT1NYXRoLnJvdW5kKGNbZF0ueC1jW2QrMl0ueCkpO2Iuc2V0Q3Vyc29yKGU/ImNvbC1yZXNpemUiOiJyb3ctcmVzaXplIik7CnRoaXMucG9pbnRzLnB1c2gobmV3IG14UG9pbnQoMCwwKSl9fWI9dGhpcy5jcmVhdGVIYW5kbGVTaGFwZShjLmxlbmd0aCk7dGhpcy5pbml0QmVuZChiKTtiLnNldEN1cnNvcihteENvbnN0YW50cy5DVVJTT1JfVEVSTUlOQUxfSEFORExFKTthLnB1c2goYik7cmV0dXJuIGF9O214RWRnZVNlZ21lbnRIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXt0aGlzLnJlZnJlc2goKTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTsKbXhFZGdlU2VnbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0lubmVyQmVuZHM9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLmdyYXBoLmlzQ2VsbEJlbmRhYmxlKHRoaXMuc3RhdGUuY2VsbCkpe3ZhciBjPXRoaXMuZ2V0Q3VycmVudFBvaW50cygpO2lmKG51bGwhPWMmJjE8Yy5sZW5ndGgpe3ZhciBkPSExO2lmKDQ9PWMubGVuZ3RoJiYwPT1NYXRoLnJvdW5kKGNbMV0ueC1jWzJdLngpJiYwPT1NYXRoLnJvdW5kKGNbMV0ueS1jWzJdLnkpKWlmKGQ9ITAsMD09TWF0aC5yb3VuZChjWzBdLnktY1tjLmxlbmd0aC0xXS55KSl7dmFyIGU9Y1swXS54KyhjW2MubGVuZ3RoLTFdLngtY1swXS54KS8yO2NbMV09bmV3IG14UG9pbnQoZSxjWzFdLnkpO2NbMl09bmV3IG14UG9pbnQoZSxjWzJdLnkpfWVsc2UgZT1jWzBdLnkrKGNbYy5sZW5ndGgtMV0ueS1jWzBdLnkpLzIsY1sxXT1uZXcgbXhQb2ludChjWzFdLngsZSksY1syXT1uZXcgbXhQb2ludChjWzJdLngsZSk7Zm9yKGU9MDtlPGMubGVuZ3RoLQoxO2UrKylpZihudWxsIT10aGlzLmJlbmRzW2UrMV0pe2E9Y1tlXTtiPWNbZSsxXTt2YXIgZj1uZXcgbXhQb2ludChhLngrKGIueC1hLngpLzIsYS55KyhiLnktYS55KS8yKSxnPXRoaXMuYmVuZHNbZSsxXS5ib3VuZHM7dGhpcy5iZW5kc1tlKzFdLmJvdW5kcz1uZXcgbXhSZWN0YW5nbGUoTWF0aC5mbG9vcihmLngtZy53aWR0aC8yKSxNYXRoLmZsb29yKGYueS1nLmhlaWdodC8yKSxnLndpZHRoLGcuaGVpZ2h0KTt0aGlzLmJlbmRzW2UrMV0ucmVkcmF3KCk7dGhpcy5tYW5hZ2VMYWJlbEhhbmRsZSYmdGhpcy5jaGVja0xhYmVsSGFuZGxlKHRoaXMuYmVuZHNbZSsxXS5ib3VuZHMpfWQmJihteFV0aWxzLnNldE9wYWNpdHkodGhpcy5iZW5kc1sxXS5ub2RlLHRoaXMudmlydHVhbEJlbmRPcGFjaXR5KSxteFV0aWxzLnNldE9wYWNpdHkodGhpcy5iZW5kc1szXS5ub2RlLHRoaXMudmlydHVhbEJlbmRPcGFjaXR5KSl9fX07CmZ1bmN0aW9uIG14S2V5SGFuZGxlcihhLGIpe251bGwhPWEmJih0aGlzLmdyYXBoPWEsdGhpcy50YXJnZXQ9Ynx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMubm9ybWFsS2V5cz1bXSx0aGlzLnNoaWZ0S2V5cz1bXSx0aGlzLmNvbnRyb2xLZXlzPVtdLHRoaXMuY29udHJvbFNoaWZ0S2V5cz1bXSx0aGlzLmtleWRvd25IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMua2V5RG93bihhKX0pLG14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy50YXJnZXQsImtleWRvd24iLHRoaXMua2V5ZG93bkhhbmRsZXIpLG14Q2xpZW50LklTX0lFJiZteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywidW5sb2FkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZGVzdHJveSgpfSkpKX1teEtleUhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhLZXlIYW5kbGVyLnByb3RvdHlwZS50YXJnZXQ9bnVsbDsKbXhLZXlIYW5kbGVyLnByb3RvdHlwZS5ub3JtYWxLZXlzPW51bGw7bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5zaGlmdEtleXM9bnVsbDtteEtleUhhbmRsZXIucHJvdG90eXBlLmNvbnRyb2xLZXlzPW51bGw7bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5jb250cm9sU2hpZnRLZXlzPW51bGw7bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5lbmFibGVkPSEwO214S2V5SGFuZGxlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZD1hfTtteEtleUhhbmRsZXIucHJvdG90eXBlLmJpbmRLZXk9ZnVuY3Rpb24oYSxiKXt0aGlzLm5vcm1hbEtleXNbYV09Yn07bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5iaW5kU2hpZnRLZXk9ZnVuY3Rpb24oYSxiKXt0aGlzLnNoaWZ0S2V5c1thXT1ifTsKbXhLZXlIYW5kbGVyLnByb3RvdHlwZS5iaW5kQ29udHJvbEtleT1mdW5jdGlvbihhLGIpe3RoaXMuY29udHJvbEtleXNbYV09Yn07bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5iaW5kQ29udHJvbFNoaWZ0S2V5PWZ1bmN0aW9uKGEsYil7dGhpcy5jb250cm9sU2hpZnRLZXlzW2FdPWJ9O214S2V5SGFuZGxlci5wcm90b3R5cGUuaXNDb250cm9sRG93bj1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfTtteEtleUhhbmRsZXIucHJvdG90eXBlLmdldEZ1bmN0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hfHxteEV2ZW50LmlzQWx0RG93bihhKT9udWxsOnRoaXMuaXNDb250cm9sRG93bihhKT9teEV2ZW50LmlzU2hpZnREb3duKGEpP3RoaXMuY29udHJvbFNoaWZ0S2V5c1thLmtleUNvZGVdOnRoaXMuY29udHJvbEtleXNbYS5rZXlDb2RlXTpteEV2ZW50LmlzU2hpZnREb3duKGEpP3RoaXMuc2hpZnRLZXlzW2Eua2V5Q29kZV06dGhpcy5ub3JtYWxLZXlzW2Eua2V5Q29kZV19OwpteEtleUhhbmRsZXIucHJvdG90eXBlLmlzR3JhcGhFdmVudD1mdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldFNvdXJjZShhKTtyZXR1cm4gYj09dGhpcy50YXJnZXR8fGIucGFyZW50Tm9kZT09dGhpcy50YXJnZXR8fG51bGwhPXRoaXMuZ3JhcGguY2VsbEVkaXRvciYmdGhpcy5ncmFwaC5jZWxsRWRpdG9yLmlzRXZlbnRTb3VyY2UoYSk/ITA6bXhVdGlscy5pc0FuY2VzdG9yTm9kZSh0aGlzLmdyYXBoLmNvbnRhaW5lcixiKX07bXhLZXlIYW5kbGVyLnByb3RvdHlwZS5rZXlEb3duPWZ1bmN0aW9uKGEpe2lmKHRoaXMuaXNFbmFibGVkRm9yRXZlbnQoYSkpaWYoMjc9PWEua2V5Q29kZSl0aGlzLmVzY2FwZShhKTtlbHNlIGlmKCF0aGlzLmlzRXZlbnRJZ25vcmVkKGEpKXt2YXIgYj10aGlzLmdldEZ1bmN0aW9uKGEpO251bGwhPWImJihiKGEpLG14RXZlbnQuY29uc3VtZShhKSl9fTsKbXhLZXlIYW5kbGVyLnByb3RvdHlwZS5pc0VuYWJsZWRGb3JFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ncmFwaC5pc0VuYWJsZWQoKSYmIW14RXZlbnQuaXNDb25zdW1lZChhKSYmdGhpcy5pc0dyYXBoRXZlbnQoYSkmJnRoaXMuaXNFbmFibGVkKCl9O214S2V5SGFuZGxlci5wcm90b3R5cGUuaXNFdmVudElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ3JhcGguaXNFZGl0aW5nKCl9O214S2V5SGFuZGxlci5wcm90b3R5cGUuZXNjYXBlPWZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguaXNFc2NhcGVFbmFibGVkKCkmJnRoaXMuZ3JhcGguZXNjYXBlKGEpfTsKbXhLZXlIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy50YXJnZXQmJm51bGwhPXRoaXMua2V5ZG93bkhhbmRsZXImJihteEV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMudGFyZ2V0LCJrZXlkb3duIix0aGlzLmtleWRvd25IYW5kbGVyKSx0aGlzLmtleWRvd25IYW5kbGVyPW51bGwpO3RoaXMudGFyZ2V0PW51bGx9O2Z1bmN0aW9uIG14VG9vbHRpcEhhbmRsZXIoYSxiKXtudWxsIT1hJiYodGhpcy5ncmFwaD1hLHRoaXMuZGVsYXk9Ynx8NTAwLHRoaXMuZ3JhcGguYWRkTW91c2VMaXN0ZW5lcih0aGlzKSl9bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuekluZGV4PTEwMDA1O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmdyYXBoPW51bGw7bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuZGVsYXk9bnVsbDtteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5pZ25vcmVUb3VjaEV2ZW50cz0hMDsKbXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaGlkZU9uSG92ZXI9ITE7bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveWVkPSExO214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLmVuYWJsZWQ9ITA7bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZH07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVuYWJsZWQ9YX07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaXNIaWRlT25Ib3Zlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZGVPbkhvdmVyfTtteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5zZXRIaWRlT25Ib3Zlcj1mdW5jdGlvbihhKXt0aGlzLmhpZGVPbkhvdmVyPWF9OwpteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7bnVsbCE9ZG9jdW1lbnQuYm9keSYmKHRoaXMuZGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHRoaXMuZGl2LmNsYXNzTmFtZT0ibXhUb29sdGlwIix0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kaXYpLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLmRpdixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhpZGVUb29sdGlwKCl9KSkpfTtteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5nZXRTdGF0ZUZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBhLmdldFN0YXRlKCl9O214VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bj1mdW5jdGlvbihhLGIpe3RoaXMucmVzZXQoYiwhMSk7dGhpcy5oaWRlVG9vbHRpcCgpfTsKbXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUubW91c2VNb3ZlPWZ1bmN0aW9uKGEsYil7aWYoYi5nZXRYKCkhPXRoaXMubGFzdFh8fGIuZ2V0WSgpIT10aGlzLmxhc3RZKXt0aGlzLnJlc2V0KGIsITApO3ZhciBjPXRoaXMuZ2V0U3RhdGVGb3JFdmVudChiKTsodGhpcy5pc0hpZGVPbkhvdmVyKCl8fGMhPXRoaXMuc3RhdGV8fGIuZ2V0U291cmNlKCkhPXRoaXMubm9kZSYmKCF0aGlzLnN0YXRlU291cmNlfHxudWxsIT1jJiZ0aGlzLnN0YXRlU291cmNlPT0oYi5pc1NvdXJjZShjLnNoYXBlKXx8IWIuaXNTb3VyY2UoYy50ZXh0KSkpKSYmdGhpcy5oaWRlVG9vbHRpcCgpfXRoaXMubGFzdFg9Yi5nZXRYKCk7dGhpcy5sYXN0WT1iLmdldFkoKX07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUubW91c2VVcD1mdW5jdGlvbihhLGIpe3RoaXMucmVzZXQoYiwhMCk7dGhpcy5oaWRlVG9vbHRpcCgpfTsKbXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUucmVzZXRUaW1lcj1mdW5jdGlvbigpe251bGwhPXRoaXMudGhyZWFkJiYod2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRocmVhZCksdGhpcy50aHJlYWQ9bnVsbCl9OwpteFRvb2x0aXBIYW5kbGVyLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbihhLGIsYyl7aWYoIXRoaXMuaWdub3JlVG91Y2hFdmVudHN8fG14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSkpaWYodGhpcy5yZXNldFRpbWVyKCksYz1udWxsIT1jP2M6dGhpcy5nZXRTdGF0ZUZvckV2ZW50KGEpLGImJnRoaXMuaXNFbmFibGVkKCkmJm51bGwhPWMmJihudWxsPT10aGlzLmRpdnx8ImhpZGRlbiI9PXRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkpKXt2YXIgZD1hLmdldFNvdXJjZSgpLGU9YS5nZXRYKCksZj1hLmdldFkoKSxnPWEuaXNTb3VyY2UoYy5zaGFwZSl8fGEuaXNTb3VyY2UoYy50ZXh0KTt0aGlzLnRocmVhZD13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKCF0aGlzLmdyYXBoLmlzRWRpdGluZygpJiYhdGhpcy5ncmFwaC5wb3B1cE1lbnVIYW5kbGVyLmlzTWVudVNob3dpbmcoKSYmIXRoaXMuZ3JhcGguaXNNb3VzZURvd24pe3ZhciBhPQp0aGlzLmdyYXBoLmdldFRvb2x0aXAoYyxkLGUsZik7dGhpcy5zaG93KGEsZSxmKTt0aGlzLnN0YXRlPWM7dGhpcy5ub2RlPWQ7dGhpcy5zdGF0ZVNvdXJjZT1nfX0pLHRoaXMuZGVsYXkpfX07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3RoaXMucmVzZXRUaW1lcigpO3RoaXMuaGlkZVRvb2x0aXAoKX07bXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuaGlkZVRvb2x0aXA9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmRpdiYmKHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIsdGhpcy5kaXYuaW5uZXJIVE1MPSIiKX07Cm14VG9vbHRpcEhhbmRsZXIucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oYSxiLGMpe2lmKCF0aGlzLmRlc3Ryb3llZCYmbnVsbCE9YSYmMDxhLmxlbmd0aCl7bnVsbD09dGhpcy5kaXYmJnRoaXMuaW5pdCgpO3ZhciBkPW14VXRpbHMuZ2V0U2Nyb2xsT3JpZ2luKCk7dGhpcy5kaXYuc3R5bGUuekluZGV4PXRoaXMuekluZGV4O3RoaXMuZGl2LnN0eWxlLmxlZnQ9YitkLngrInB4Ijt0aGlzLmRpdi5zdHlsZS50b3A9YytteENvbnN0YW50cy5UT09MVElQX1ZFUlRJQ0FMX09GRlNFVCtkLnkrInB4IjtteFV0aWxzLmlzTm9kZShhKT8odGhpcy5kaXYuaW5uZXJIVE1MPSIiLHRoaXMuZGl2LmFwcGVuZENoaWxkKGEpKTp0aGlzLmRpdi5pbm5lckhUTUw9YS5yZXBsYWNlKC9cbi9nLCI8YnI+Iik7dGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eT0iIjtteFV0aWxzLmZpdCh0aGlzLmRpdil9fTsKbXhUb29sdGlwSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZGVzdHJveWVkfHwodGhpcy5ncmFwaC5yZW1vdmVNb3VzZUxpc3RlbmVyKHRoaXMpLG14RXZlbnQucmVsZWFzZSh0aGlzLmRpdiksbnVsbCE9dGhpcy5kaXYmJm51bGwhPXRoaXMuZGl2LnBhcmVudE5vZGUmJnRoaXMuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaXYpLHRoaXMuZGVzdHJveWVkPSEwLHRoaXMuZGl2PW51bGwpfTtmdW5jdGlvbiBteENlbGxUcmFja2VyKGEsYixjKXtteENlbGxNYXJrZXIuY2FsbCh0aGlzLGEsYik7dGhpcy5ncmFwaC5hZGRNb3VzZUxpc3RlbmVyKHRoaXMpO251bGwhPWMmJih0aGlzLmdldENlbGw9Yyk7bXhDbGllbnQuSVNfSUUmJm14RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJ1bmxvYWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95KCl9KSl9bXhVdGlscy5leHRlbmQobXhDZWxsVHJhY2tlcixteENlbGxNYXJrZXIpOwpteENlbGxUcmFja2VyLnByb3RvdHlwZS5tb3VzZURvd249ZnVuY3Rpb24oYSxiKXt9O214Q2VsbFRyYWNrZXIucHJvdG90eXBlLm1vdXNlTW92ZT1mdW5jdGlvbihhLGIpe3RoaXMuaXNFbmFibGVkKCkmJnRoaXMucHJvY2VzcyhiKX07bXhDZWxsVHJhY2tlci5wcm90b3R5cGUubW91c2VVcD1mdW5jdGlvbihhLGIpe307bXhDZWxsVHJhY2tlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZGVzdHJveWVkfHwodGhpcy5kZXN0cm95ZWQ9ITAsdGhpcy5ncmFwaC5yZW1vdmVNb3VzZUxpc3RlbmVyKHRoaXMpLG14Q2VsbE1hcmtlci5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzKSl9OwpmdW5jdGlvbiBteENlbGxIaWdobGlnaHQoYSxiLGMsZCl7bnVsbCE9YSYmKHRoaXMuZ3JhcGg9YSx0aGlzLmhpZ2hsaWdodENvbG9yPW51bGwhPWI/YjpteENvbnN0YW50cy5ERUZBVUxUX1ZBTElEX0NPTE9SLHRoaXMuc3Ryb2tlV2lkdGg9bnVsbCE9Yz9jOm14Q29uc3RhbnRzLkhJR0hMSUdIVF9TVFJPS0VXSURUSCx0aGlzLmRhc2hlZD1udWxsIT1kP2Q6ITEsdGhpcy5vcGFjaXR5PW14Q29uc3RhbnRzLkhJR0hMSUdIVF9PUEFDSVRZLHRoaXMucmVwYWludEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnN0YXRlKXt2YXIgYT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUodGhpcy5zdGF0ZS5jZWxsKTtudWxsPT1hP3RoaXMuaGlkZSgpOih0aGlzLnN0YXRlPWEsdGhpcy5yZXBhaW50KCkpfX0pLHRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEUsdGhpcy5yZXBhaW50SGFuZGxlciksdGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5UUkFOU0xBVEUsCnRoaXMucmVwYWludEhhbmRsZXIpLHRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuU0NBTEVfQU5EX1RSQU5TTEFURSx0aGlzLnJlcGFpbnRIYW5kbGVyKSx0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5yZXBhaW50SGFuZGxlciksdGhpcy5yZXNldEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGUoKX0pLHRoaXMuZ3JhcGguZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuRE9XTix0aGlzLnJlc2V0SGFuZGxlciksdGhpcy5ncmFwaC5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VUCx0aGlzLnJlc2V0SGFuZGxlcikpfW14Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUua2VlcE9uVG9wPSExO214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuZ3JhcGg9bnVsbDtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLnN0YXRlPW51bGw7Cm14Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuc3BhY2luZz0yO214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUucmVzZXRIYW5kbGVyPW51bGw7bXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5zZXRIaWdobGlnaHRDb2xvcj1mdW5jdGlvbihhKXt0aGlzLmhpZ2hsaWdodENvbG9yPWE7bnVsbCE9dGhpcy5zaGFwZSYmKHRoaXMuc2hhcGUuc3Ryb2tlPWEpfTtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLmRyYXdIaWdobGlnaHQ9ZnVuY3Rpb24oKXt0aGlzLnNoYXBlPXRoaXMuY3JlYXRlU2hhcGUoKTt0aGlzLnJlcGFpbnQoKTt0aGlzLmtlZXBPblRvcHx8dGhpcy5zaGFwZS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZD09dGhpcy5zaGFwZS5ub2RlfHx0aGlzLnNoYXBlLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5zaGFwZS5ub2RlLHRoaXMuc2hhcGUubm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpfTsKbXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmNyZWF0ZVNoYXBlKHRoaXMuc3RhdGUpO2Euc3ZnU3Ryb2tlVG9sZXJhbmNlPXRoaXMuZ3JhcGgudG9sZXJhbmNlO2EucG9pbnRzPXRoaXMuc3RhdGUuYWJzb2x1dGVQb2ludHM7YS5hcHBseSh0aGlzLnN0YXRlKTthLnN0cm9rZT10aGlzLmhpZ2hsaWdodENvbG9yO2Eub3BhY2l0eT10aGlzLm9wYWNpdHk7YS5pc0Rhc2hlZD10aGlzLmRhc2hlZDthLmlzU2hhZG93PSExO2EuZGlhbGVjdD10aGlzLmdyYXBoLmRpYWxlY3QhPW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHP214Q29uc3RhbnRzLkRJQUxFQ1RfVk1MOm14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHO2EuaW5pdCh0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRPdmVybGF5UGFuZSgpKTtteEV2ZW50LnJlZGlyZWN0TW91c2VFdmVudHMoYS5ub2RlLHRoaXMuZ3JhcGgsdGhpcy5zdGF0ZSk7dGhpcy5ncmFwaC5kaWFsZWN0IT0KbXhDb25zdGFudHMuRElBTEVDVF9TVkc/YS5wb2ludGVyRXZlbnRzPSExOmEuc3ZnUG9pbnRlckV2ZW50cz0ic3Ryb2tlIjtyZXR1cm4gYX07bXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5nZXRTdHJva2VXaWR0aD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zdHJva2VXaWR0aH07Cm14Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUucmVwYWludD1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuc3RhdGUmJm51bGwhPXRoaXMuc2hhcGUpe3RoaXMuc2hhcGUuc2NhbGU9dGhpcy5zdGF0ZS52aWV3LnNjYWxlO3RoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKHRoaXMuc3RhdGUuY2VsbCk/KHRoaXMuc2hhcGUuc3Ryb2tld2lkdGg9dGhpcy5nZXRTdHJva2VXaWR0aCgpLHRoaXMuc2hhcGUucG9pbnRzPXRoaXMuc3RhdGUuYWJzb2x1dGVQb2ludHMsdGhpcy5zaGFwZS5vdXRsaW5lPSExKToodGhpcy5zaGFwZS5ib3VuZHM9bmV3IG14UmVjdGFuZ2xlKHRoaXMuc3RhdGUueC10aGlzLnNwYWNpbmcsdGhpcy5zdGF0ZS55LXRoaXMuc3BhY2luZyx0aGlzLnN0YXRlLndpZHRoKzIqdGhpcy5zcGFjaW5nLHRoaXMuc3RhdGUuaGVpZ2h0KzIqdGhpcy5zcGFjaW5nKSx0aGlzLnNoYXBlLnJvdGF0aW9uPU51bWJlcih0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8CiIwIiksdGhpcy5zaGFwZS5zdHJva2V3aWR0aD10aGlzLmdldFN0cm9rZVdpZHRoKCkvdGhpcy5zdGF0ZS52aWV3LnNjYWxlLHRoaXMuc2hhcGUub3V0bGluZT0hMCk7bnVsbCE9dGhpcy5zdGF0ZS5zaGFwZSYmdGhpcy5zaGFwZS5zZXRDdXJzb3IodGhpcy5zdGF0ZS5zaGFwZS5nZXRDdXJzb3IoKSk7aWYobXhDbGllbnQuSVNfUVVJUktTfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGUpInRyYW5zcGFyZW50Ij09dGhpcy5zaGFwZS5zdHJva2U/KHRoaXMuc2hhcGUuc3Ryb2tlPSJ3aGl0ZSIsdGhpcy5zaGFwZS5vcGFjaXR5PTEpOnRoaXMuc2hhcGUub3BhY2l0eT10aGlzLm9wYWNpdHk7dGhpcy5zaGFwZS5yZWRyYXcoKX19O214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3RoaXMuaGlnaGxpZ2h0KG51bGwpfTsKbXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5oaWdobGlnaHQ9ZnVuY3Rpb24oYSl7dGhpcy5zdGF0ZSE9YSYmKG51bGwhPXRoaXMuc2hhcGUmJih0aGlzLnNoYXBlLmRlc3Ryb3koKSx0aGlzLnNoYXBlPW51bGwpLHRoaXMuc3RhdGU9YSxudWxsIT10aGlzLnN0YXRlJiZ0aGlzLmRyYXdIaWdobGlnaHQoKSl9O214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUuaXNIaWdobGlnaHRBdD1mdW5jdGlvbihhLGIpe3ZhciBjPSExO2lmKG51bGwhPXRoaXMuc2hhcGUmJm51bGwhPWRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQmJiFteENsaWVudC5JU19RVUlSS1MpZm9yKHZhciBkPWRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoYSxiKTtudWxsIT1kOyl7aWYoZD09dGhpcy5zaGFwZS5ub2RlKXtjPSEwO2JyZWFrfWQ9ZC5wYXJlbnROb2RlfXJldHVybiBjfTsKbXhDZWxsSGlnaGxpZ2h0LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5ncmFwaC5nZXRWaWV3KCkucmVtb3ZlTGlzdGVuZXIodGhpcy5yZXNldEhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0VmlldygpLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVwYWludEhhbmRsZXIpO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLnJlcGFpbnRIYW5kbGVyKTtudWxsIT10aGlzLnNoYXBlJiYodGhpcy5zaGFwZS5kZXN0cm95KCksdGhpcy5zaGFwZT1udWxsKX07CmZ1bmN0aW9uIG14RGVmYXVsdEtleUhhbmRsZXIoYSl7aWYobnVsbCE9YSl7dGhpcy5lZGl0b3I9YTt0aGlzLmhhbmRsZXI9bmV3IG14S2V5SGFuZGxlcihhLmdyYXBoKTt2YXIgYj10aGlzLmhhbmRsZXIuZXNjYXBlO3RoaXMuaGFuZGxlci5lc2NhcGU9ZnVuY3Rpb24oYyl7Yi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5oaWRlUHJvcGVydGllcygpO2EuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuRVNDQVBFLCJldmVudCIsYykpfX19bXhEZWZhdWx0S2V5SGFuZGxlci5wcm90b3R5cGUuZWRpdG9yPW51bGw7bXhEZWZhdWx0S2V5SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlcj1udWxsOwpteERlZmF1bHRLZXlIYW5kbGVyLnByb3RvdHlwZS5iaW5kQWN0aW9uPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZWRpdG9yLmV4ZWN1dGUoYil9KTtjP3RoaXMuaGFuZGxlci5iaW5kQ29udHJvbEtleShhLGQpOnRoaXMuaGFuZGxlci5iaW5kS2V5KGEsZCl9O214RGVmYXVsdEtleUhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmhhbmRsZXIuZGVzdHJveSgpO3RoaXMuaGFuZGxlcj1udWxsfTtmdW5jdGlvbiBteERlZmF1bHRQb3B1cE1lbnUoYSl7dGhpcy5jb25maWc9YX1teERlZmF1bHRQb3B1cE1lbnUucHJvdG90eXBlLmltYWdlQmFzZVBhdGg9bnVsbDtteERlZmF1bHRQb3B1cE1lbnUucHJvdG90eXBlLmNvbmZpZz1udWxsOwpteERlZmF1bHRQb3B1cE1lbnUucHJvdG90eXBlLmNyZWF0ZU1lbnU9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbCE9dGhpcy5jb25maWcpe3ZhciBlPXRoaXMuY3JlYXRlQ29uZGl0aW9ucyhhLGMsZCk7dGhpcy5hZGRJdGVtcyhhLGIsYyxkLGUsdGhpcy5jb25maWcuZmlyc3RDaGlsZCxudWxsKX19OwpteERlZmF1bHRQb3B1cE1lbnUucHJvdG90eXBlLmFkZEl0ZW1zPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2Zvcih2YXIgaz0hMTtudWxsIT1mOyl7aWYoImFkZCI9PWYubm9kZU5hbWUpe3ZhciBsPWYuZ2V0QXR0cmlidXRlKCJpZiIpO2lmKG51bGw9PWx8fGVbbF0pe3ZhciBsPWYuZ2V0QXR0cmlidXRlKCJhcyIpLGw9bXhSZXNvdXJjZXMuZ2V0KGwpfHxsLG09bXhVdGlscy5ldmFsKG14VXRpbHMuZ2V0VGV4dENvbnRlbnQoZikpLG49Zi5nZXRBdHRyaWJ1dGUoImFjdGlvbiIpLHA9Zi5nZXRBdHRyaWJ1dGUoImljb24iKSxxPWYuZ2V0QXR0cmlidXRlKCJpY29uQ2xzIikscj1mLmdldEF0dHJpYnV0ZSgiZW5hYmxlZC1pZiIpLHI9bnVsbD09cnx8ZVtyXTtrJiYoYi5hZGRTZXBhcmF0b3IoZyksaz0hMSk7bnVsbCE9cCYmdGhpcy5pbWFnZUJhc2VQYXRoJiYocD10aGlzLmltYWdlQmFzZVBhdGgrcCk7bD10aGlzLmFkZEFjdGlvbihiLGEsbCxwLG0sbixjLGcscSxyKTt0aGlzLmFkZEl0ZW1zKGEsCmIsYyxkLGUsZi5maXJzdENoaWxkLGwpfX1lbHNlInNlcGFyYXRvciI9PWYubm9kZU5hbWUmJihrPSEwKTtmPWYubmV4dFNpYmxpbmd9fTtteERlZmF1bHRQb3B1cE1lbnUucHJvdG90eXBlLmFkZEFjdGlvbj1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGssbCxtKXtyZXR1cm4gYS5hZGRJdGVtKGMsZCxmdW5jdGlvbihhKXsiZnVuY3Rpb24iPT10eXBlb2YgZSYmZS5jYWxsKGIsYixnLGEpO251bGwhPWYmJmIuZXhlY3V0ZShmLGcsYSl9LGssbCxtKX07Cm14RGVmYXVsdFBvcHVwTWVudS5wcm90b3R5cGUuY3JlYXRlQ29uZGl0aW9ucz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5ncmFwaC5nZXRNb2RlbCgpLGU9ZC5nZXRDaGlsZENvdW50KGIpLGY9W107Zi5ub2NlbGw9bnVsbD09YjtmLm5jZWxscz0xPGEuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKTtmLm5vdFJvb3Q9ZC5nZXRSb290KCkhPWQuZ2V0UGFyZW50KGEuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpKTtmLmNlbGw9bnVsbCE9YjtkPW51bGwhPWImJjE9PWEuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKTtmLm5vbkVtcHR5PWQmJjA8ZTtmLmV4cGFuZGFibGU9ZCYmYS5ncmFwaC5pc0NlbGxGb2xkYWJsZShiLCExKTtmLmNvbGxhcHNhYmxlPWQmJmEuZ3JhcGguaXNDZWxsRm9sZGFibGUoYiwhMCk7Zi52YWxpZFJvb3Q9ZCYmYS5ncmFwaC5pc1ZhbGlkUm9vdChiKTtmLmVtcHR5VmFsaWRSb290PWYudmFsaWRSb290JiYwPT1lO2Yuc3dpbWxhbmU9ZCYmYS5ncmFwaC5pc1N3aW1sYW5lKGIpOwplPXRoaXMuY29uZmlnLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJjb25kaXRpb24iKTtmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKXt2YXIgZz1teFV0aWxzLmV2YWwobXhVdGlscy5nZXRUZXh0Q29udGVudChlW2RdKSksaz1lW2RdLmdldEF0dHJpYnV0ZSgibmFtZSIpO251bGwhPWsmJiJmdW5jdGlvbiI9PXR5cGVvZiBnJiYoZltrXT1nKGEsYixjKSl9cmV0dXJuIGZ9O2Z1bmN0aW9uIG14RGVmYXVsdFRvb2xiYXIoYSxiKXt0aGlzLmVkaXRvcj1iO251bGwhPWEmJm51bGwhPWImJnRoaXMuaW5pdChhKX1teERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5lZGl0b3I9bnVsbDtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS50b29sYmFyPW51bGw7bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUucmVzZXRIYW5kbGVyPW51bGw7bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuc3BhY2luZz00O214RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmNvbm5lY3RPbkRyb3A9ITE7Cm14RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSl7bnVsbCE9YSYmKHRoaXMudG9vbGJhcj1uZXcgbXhUb29sYmFyKGEpLHRoaXMudG9vbGJhci5hZGRMaXN0ZW5lcihteEV2ZW50LlNFTEVDVCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3ZhciBiPWMuZ2V0UHJvcGVydHkoImZ1bmN0aW9uIik7dGhpcy5lZGl0b3IuaW5zZXJ0RnVuY3Rpb249bnVsbCE9Yj9teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMudG9vbGJhci5yZXNldE1vZGUoKX0pOm51bGx9KSksdGhpcy5yZXNldEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT10aGlzLnRvb2xiYXImJnRoaXMudG9vbGJhci5yZXNldE1vZGUoITApfSksdGhpcy5lZGl0b3IuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5ET1VCTEVfQ0xJQ0ssdGhpcy5yZXNldEhhbmRsZXIpLHRoaXMuZWRpdG9yLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLAp0aGlzLnJlc2V0SGFuZGxlcikpfTtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5hZGRJdGVtPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9YyYmMDxjLmxlbmd0aCYmdGhpcy5lZGl0b3IuZXhlY3V0ZShjKX0pO3JldHVybiB0aGlzLnRvb2xiYXIuYWRkSXRlbShhLGIsZSxkKX07bXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuYWRkU2VwYXJhdG9yPWZ1bmN0aW9uKGEpe2E9YXx8bXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL3NlcGFyYXRvci5naWYiO3RoaXMudG9vbGJhci5hZGRTZXBhcmF0b3IoYSl9O214RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmFkZENvbWJvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9vbGJhci5hZGRDb21ibygpfTtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5hZGRBY3Rpb25Db21ibz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy50b29sYmFyLmFkZEFjdGlvbkNvbWJvKGEpfTsKbXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuYWRkQWN0aW9uT3B0aW9uPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZWRpdG9yLmV4ZWN1dGUoYyl9KTt0aGlzLmFkZE9wdGlvbihhLGIsZCl9O214RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmFkZE9wdGlvbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMudG9vbGJhci5hZGRPcHRpb24oYSxiLGMpfTtteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5hZGRNb2RlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmVkaXRvci5zZXRNb2RlKGMpO251bGwhPWUmJmUodGhpcy5lZGl0b3IpfSk7cmV0dXJuIHRoaXMudG9vbGJhci5hZGRTd2l0Y2hNb2RlKGEsYixmLGQpfTsKbXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuYWRkUHJvdG90eXBlPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBjP2MoKTpudWxsIT1jP3RoaXMuZWRpdG9yLmdyYXBoLmNsb25lQ2VsbChjKTpudWxsfSksaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpeyJmdW5jdGlvbiI9PXR5cGVvZiBlP2UodGhpcy5lZGl0b3IsZygpLGEsYik6dGhpcy5kcm9wKGcoKSxhLGIpO3RoaXMudG9vbGJhci5yZXNldE1vZGUoKTtteEV2ZW50LmNvbnN1bWUoYSl9KTthPXRoaXMudG9vbGJhci5hZGRNb2RlKGEsYixrLGQsbnVsbCxmKTt0aGlzLmluc3RhbGxEcm9wSGFuZGxlcihhLGZ1bmN0aW9uKGEsYixjKXtrKGIsYyl9KTtyZXR1cm4gYX07Cm14RGVmYXVsdFRvb2xiYXIucHJvdG90eXBlLmRyb3A9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZWRpdG9yLmdyYXBoLGU9ZC5nZXRNb2RlbCgpO2lmKG51bGwhPWMmJiFlLmlzRWRnZShjKSYmdGhpcy5jb25uZWN0T25Ecm9wJiZkLmlzQ2VsbENvbm5lY3RhYmxlKGMpKXRoaXMuY29ubmVjdChhLGIsYyk7ZWxzZXtmb3IoO251bGwhPWMmJiFkLmlzVmFsaWREcm9wVGFyZ2V0KGMsW2FdLGIpOyljPWUuZ2V0UGFyZW50KGMpO3RoaXMuaW5zZXJ0KGEsYixjKX19OwpteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5pbnNlcnQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZWRpdG9yLmdyYXBoO2lmKGQuY2FuSW1wb3J0Q2VsbChhKSl7dmFyIGU9bXhFdmVudC5nZXRDbGllbnRYKGIpLGY9bXhFdmVudC5nZXRDbGllbnRZKGIpLGU9bXhVdGlscy5jb252ZXJ0UG9pbnQoZC5jb250YWluZXIsZSxmKTtyZXR1cm4gZC5pc1NwbGl0RW5hYmxlZCgpJiZkLmlzU3BsaXRUYXJnZXQoYyxbYV0sYik/ZC5zcGxpdEVkZ2UoYyxbYV0sbnVsbCxlLngsZS55KTp0aGlzLmVkaXRvci5hZGRWZXJ0ZXgoYyxhLGUueCxlLnkpfXJldHVybiBudWxsfTsKbXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihhLGIsYyl7Yj10aGlzLmVkaXRvci5ncmFwaDt2YXIgZD1iLmdldE1vZGVsKCk7aWYobnVsbCE9YyYmYi5pc0NlbGxDb25uZWN0YWJsZShhKSYmYi5pc0VkZ2VWYWxpZChudWxsLGMsYSkpe3ZhciBlPW51bGw7ZC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZj1kLmdldEdlb21ldHJ5KGMpLGc9ZC5nZXRHZW9tZXRyeShhKS5jbG9uZSgpO2cueD1mLngrKGYud2lkdGgtZy53aWR0aCkvMjtnLnk9Zi55KyhmLmhlaWdodC1nLmhlaWdodCkvMjt2YXIgaz10aGlzLnNwYWNpbmcqYi5ncmlkU2l6ZSxsPTIwKmQuZ2V0RGlyZWN0ZWRFZGdlQ291bnQoYywhMCk7dGhpcy5lZGl0b3IuaG9yaXpvbnRhbEZsb3c/Zy54Kz0oZy53aWR0aCtmLndpZHRoKS8yK2srbDpnLnkrPShnLmhlaWdodCtmLmhlaWdodCkvMitrK2w7YS5zZXRHZW9tZXRyeShnKTt2YXIgbT1kLmdldFBhcmVudChjKTtiLmFkZENlbGwoYSxtKTtiLmNvbnN0cmFpbkNoaWxkKGEpOwplPXRoaXMuZWRpdG9yLmNyZWF0ZUVkZ2UoYyxhKTtpZihudWxsPT1kLmdldEdlb21ldHJ5KGUpKXt2YXIgbj1uZXcgbXhHZW9tZXRyeTtuLnJlbGF0aXZlPSEwO2Quc2V0R2VvbWV0cnkoZSxuKX1iLmFkZEVkZ2UoZSxtLGMsYSl9ZmluYWxseXtkLmVuZFVwZGF0ZSgpfWIuc2V0U2VsZWN0aW9uQ2VsbHMoW2EsZV0pO2Iuc2Nyb2xsQ2VsbFRvVmlzaWJsZShhKX19OwpteERlZmF1bHRUb29sYmFyLnByb3RvdHlwZS5pbnN0YWxsRHJvcEhhbmRsZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtjLnNldEF0dHJpYnV0ZSgic3JjIixhLmdldEF0dHJpYnV0ZSgic3JjIikpO3ZhciBkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUpe2Muc3R5bGUud2lkdGg9MiphLm9mZnNldFdpZHRoKyJweCI7Yy5zdHlsZS5oZWlnaHQ9MiphLm9mZnNldEhlaWdodCsicHgiO214VXRpbHMubWFrZURyYWdnYWJsZShhLHRoaXMuZWRpdG9yLmdyYXBoLGIsYyk7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcihjLCJsb2FkIixkKX0pO214Q2xpZW50LklTX0lFP2QoKTpteEV2ZW50LmFkZExpc3RlbmVyKGMsImxvYWQiLGQpfTsKbXhEZWZhdWx0VG9vbGJhci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe251bGwhPXRoaXMucmVzZXRIYW5kbGVyJiYodGhpcy5lZGl0b3IuZ3JhcGgucmVtb3ZlTGlzdGVuZXIoImRibGNsaWNrIix0aGlzLnJlc2V0SGFuZGxlciksdGhpcy5lZGl0b3IucmVtb3ZlTGlzdGVuZXIoImVzY2FwZSIsdGhpcy5yZXNldEhhbmRsZXIpLHRoaXMucmVzZXRIYW5kbGVyPW51bGwpO251bGwhPXRoaXMudG9vbGJhciYmKHRoaXMudG9vbGJhci5kZXN0cm95KCksdGhpcy50b29sYmFyPW51bGwpfTsKZnVuY3Rpb24gbXhFZGl0b3IoYSl7dGhpcy5hY3Rpb25zPVtdO3RoaXMuYWRkQWN0aW9ucygpO2lmKG51bGwhPWRvY3VtZW50LmJvZHkpe3RoaXMuY3ljbGVBdHRyaWJ1dGVWYWx1ZXM9W107dGhpcy5wb3B1cEhhbmRsZXI9bmV3IG14RGVmYXVsdFBvcHVwTWVudTt0aGlzLnVuZG9NYW5hZ2VyPW5ldyBteFVuZG9NYW5hZ2VyO3RoaXMuZ3JhcGg9dGhpcy5jcmVhdGVHcmFwaCgpO3RoaXMudG9vbGJhcj10aGlzLmNyZWF0ZVRvb2xiYXIoKTt0aGlzLmtleUhhbmRsZXI9bmV3IG14RGVmYXVsdEtleUhhbmRsZXIodGhpcyk7dGhpcy5jb25maWd1cmUoYSk7dGhpcy5ncmFwaC5zd2ltbGFuZUluZGljYXRvckNvbG9yQXR0cmlidXRlPXRoaXMuY3ljbGVBdHRyaWJ1dGVOYW1lO2lmKG51bGwhPXRoaXMub25Jbml0KXRoaXMub25Jbml0KCk7bXhDbGllbnQuSVNfSUUmJm14RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJ1bmxvYWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95KCl9KSl9fQpteExvYWRSZXNvdXJjZXM/bXhSZXNvdXJjZXMuYWRkKG14Q2xpZW50LmJhc2VQYXRoKyIvcmVzb3VyY2VzL2VkaXRvciIpOm14Q2xpZW50LmRlZmF1bHRCdW5kbGVzLnB1c2gobXhDbGllbnQuYmFzZVBhdGgrIi9yZXNvdXJjZXMvZWRpdG9yIik7bXhFZGl0b3IucHJvdG90eXBlPW5ldyBteEV2ZW50U291cmNlO214RWRpdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1teEVkaXRvcjtteEVkaXRvci5wcm90b3R5cGUuYXNrWm9vbVJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImFza1pvb20iOiIiO214RWRpdG9yLnByb3RvdHlwZS5sYXN0U2F2ZWRSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJsYXN0U2F2ZWQiOiIiO214RWRpdG9yLnByb3RvdHlwZS5jdXJyZW50RmlsZVJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/ImN1cnJlbnRGaWxlIjoiIjsKbXhFZGl0b3IucHJvdG90eXBlLnByb3BlcnRpZXNSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJwcm9wZXJ0aWVzIjoiIjtteEVkaXRvci5wcm90b3R5cGUudGFza3NSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJ0YXNrcyI6IiI7bXhFZGl0b3IucHJvdG90eXBlLmhlbHBSZXNvdXJjZT0ibm9uZSIhPW14Q2xpZW50Lmxhbmd1YWdlPyJoZWxwIjoiIjtteEVkaXRvci5wcm90b3R5cGUub3V0bGluZVJlc291cmNlPSJub25lIiE9bXhDbGllbnQubGFuZ3VhZ2U/Im91dGxpbmUiOiIiO214RWRpdG9yLnByb3RvdHlwZS5vdXRsaW5lPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmdyYXBoPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmdyYXBoUmVuZGVySGludD1udWxsO214RWRpdG9yLnByb3RvdHlwZS50b29sYmFyPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLnN0YXR1cz1udWxsO214RWRpdG9yLnByb3RvdHlwZS5wb3B1cEhhbmRsZXI9bnVsbDsKbXhFZGl0b3IucHJvdG90eXBlLnVuZG9NYW5hZ2VyPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLmtleUhhbmRsZXI9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuYWN0aW9ucz1udWxsO214RWRpdG9yLnByb3RvdHlwZS5kYmxDbGlja0FjdGlvbj0iZWRpdCI7bXhFZGl0b3IucHJvdG90eXBlLnN3aW1sYW5lUmVxdWlyZWQ9ITE7bXhFZGl0b3IucHJvdG90eXBlLmRpc2FibGVDb250ZXh0TWVudT0hMDtteEVkaXRvci5wcm90b3R5cGUuaW5zZXJ0RnVuY3Rpb249bnVsbDtteEVkaXRvci5wcm90b3R5cGUuZm9yY2VkSW5zZXJ0aW5nPSExO214RWRpdG9yLnByb3RvdHlwZS50ZW1wbGF0ZXM9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuZGVmYXVsdEVkZ2U9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuZGVmYXVsdEVkZ2VTdHlsZT1udWxsO214RWRpdG9yLnByb3RvdHlwZS5kZWZhdWx0R3JvdXA9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuZ3JvdXBCb3JkZXJTaXplPW51bGw7Cm14RWRpdG9yLnByb3RvdHlwZS5maWxlbmFtZT1udWxsO214RWRpdG9yLnByb3RvdHlwZS5saW5lZmVlZD0iJiN4YTsiO214RWRpdG9yLnByb3RvdHlwZS5wb3N0UGFyYW1ldGVyTmFtZT0ieG1sIjtteEVkaXRvci5wcm90b3R5cGUuZXNjYXBlUG9zdERhdGE9ITA7bXhFZGl0b3IucHJvdG90eXBlLnVybFBvc3Q9bnVsbDtteEVkaXRvci5wcm90b3R5cGUudXJsSW1hZ2U9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuaG9yaXpvbnRhbEZsb3c9ITE7bXhFZGl0b3IucHJvdG90eXBlLmxheW91dERpYWdyYW09ITE7bXhFZGl0b3IucHJvdG90eXBlLnN3aW1sYW5lU3BhY2luZz0wO214RWRpdG9yLnByb3RvdHlwZS5tYWludGFpblN3aW1sYW5lcz0hMTtteEVkaXRvci5wcm90b3R5cGUubGF5b3V0U3dpbWxhbmVzPSExO214RWRpdG9yLnByb3RvdHlwZS5jeWNsZUF0dHJpYnV0ZVZhbHVlcz1udWxsO214RWRpdG9yLnByb3RvdHlwZS5jeWNsZUF0dHJpYnV0ZUluZGV4PTA7Cm14RWRpdG9yLnByb3RvdHlwZS5jeWNsZUF0dHJpYnV0ZU5hbWU9ImZpbGxDb2xvciI7bXhFZGl0b3IucHJvdG90eXBlLnRhc2tzPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLnRhc2tzV2luZG93SW1hZ2U9bnVsbDtteEVkaXRvci5wcm90b3R5cGUudGFza3NUb3A9MjA7bXhFZGl0b3IucHJvdG90eXBlLmhlbHA9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuaGVscFdpbmRvd0ltYWdlPW51bGw7bXhFZGl0b3IucHJvdG90eXBlLnVybEhlbHA9bnVsbDtteEVkaXRvci5wcm90b3R5cGUuaGVscFdpZHRoPTMwMDtteEVkaXRvci5wcm90b3R5cGUuaGVscEhlaWdodD0yNjA7bXhFZGl0b3IucHJvdG90eXBlLnByb3BlcnRpZXNXaWR0aD0yNDA7bXhFZGl0b3IucHJvdG90eXBlLnByb3BlcnRpZXNIZWlnaHQ9bnVsbDtteEVkaXRvci5wcm90b3R5cGUubW92ZVByb3BlcnRpZXNEaWFsb2c9ITE7bXhFZGl0b3IucHJvdG90eXBlLnZhbGlkYXRpbmc9ITE7Cm14RWRpdG9yLnByb3RvdHlwZS5tb2RpZmllZD0hMTtteEVkaXRvci5wcm90b3R5cGUuaXNNb2RpZmllZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGlmaWVkfTtteEVkaXRvci5wcm90b3R5cGUuc2V0TW9kaWZpZWQ9ZnVuY3Rpb24oYSl7dGhpcy5tb2RpZmllZD1hfTsKbXhFZGl0b3IucHJvdG90eXBlLmFkZEFjdGlvbnM9ZnVuY3Rpb24oKXt0aGlzLmFkZEFjdGlvbigic2F2ZSIsZnVuY3Rpb24oYSl7YS5zYXZlKCl9KTt0aGlzLmFkZEFjdGlvbigicHJpbnQiLGZ1bmN0aW9uKGEpeyhuZXcgbXhQcmludFByZXZpZXcoYS5ncmFwaCwxKSkub3BlbigpfSk7dGhpcy5hZGRBY3Rpb24oInNob3ciLGZ1bmN0aW9uKGEpe214VXRpbHMuc2hvdyhhLmdyYXBoLG51bGwsMTAsMTApfSk7dGhpcy5hZGRBY3Rpb24oImV4cG9ydEltYWdlIixmdW5jdGlvbihhKXt2YXIgYj1hLmdldFVybEltYWdlKCk7aWYobnVsbD09Ynx8bXhDbGllbnQuSVNfTE9DQUwpYS5leGVjdXRlKCJzaG93Iik7ZWxzZXt2YXIgYz1teFV0aWxzLmdldFZpZXdYbWwoYS5ncmFwaCwxKSxjPW14VXRpbHMuZ2V0WG1sKGMsIlxuIik7bXhVdGlscy5zdWJtaXQoYixhLnBvc3RQYXJhbWV0ZXJOYW1lKyI9IitlbmNvZGVVUklDb21wb25lbnQoYyksZG9jdW1lbnQsIl9ibGFuayIpfX0pO3RoaXMuYWRkQWN0aW9uKCJyZWZyZXNoIiwKZnVuY3Rpb24oYSl7YS5ncmFwaC5yZWZyZXNoKCl9KTt0aGlzLmFkZEFjdGlvbigiY3V0IixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZteENsaXBib2FyZC5jdXQoYS5ncmFwaCl9KTt0aGlzLmFkZEFjdGlvbigiY29weSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmbXhDbGlwYm9hcmQuY29weShhLmdyYXBoKX0pO3RoaXMuYWRkQWN0aW9uKCJwYXN0ZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmbXhDbGlwYm9hcmQucGFzdGUoYS5ncmFwaCl9KTt0aGlzLmFkZEFjdGlvbigiZGVsZXRlIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnJlbW92ZUNlbGxzKCl9KTt0aGlzLmFkZEFjdGlvbigiZ3JvdXAiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbChhLmdyb3VwQ2VsbHMoKSl9KTt0aGlzLmFkZEFjdGlvbigidW5ncm91cCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmCmEuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbHMoYS5ncmFwaC51bmdyb3VwQ2VsbHMoKSl9KTt0aGlzLmFkZEFjdGlvbigicmVtb3ZlRnJvbVBhcmVudCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5yZW1vdmVDZWxsc0Zyb21QYXJlbnQoKX0pO3RoaXMuYWRkQWN0aW9uKCJ1bmRvIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLnVuZG8oKX0pO3RoaXMuYWRkQWN0aW9uKCJyZWRvIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLnJlZG8oKX0pO3RoaXMuYWRkQWN0aW9uKCJ6b29tSW4iLGZ1bmN0aW9uKGEpe2EuZ3JhcGguem9vbUluKCl9KTt0aGlzLmFkZEFjdGlvbigiem9vbU91dCIsZnVuY3Rpb24oYSl7YS5ncmFwaC56b29tT3V0KCl9KTt0aGlzLmFkZEFjdGlvbigiYWN0dWFsU2l6ZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC56b29tQWN0dWFsKCl9KTt0aGlzLmFkZEFjdGlvbigiZml0IixmdW5jdGlvbihhKXthLmdyYXBoLmZpdCgpfSk7CnRoaXMuYWRkQWN0aW9uKCJzaG93UHJvcGVydGllcyIsZnVuY3Rpb24oYSxiKXthLnNob3dQcm9wZXJ0aWVzKGIpfSk7dGhpcy5hZGRBY3Rpb24oInNlbGVjdEFsbCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5zZWxlY3RBbGwoKX0pO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3ROb25lIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmNsZWFyU2VsZWN0aW9uKCl9KTt0aGlzLmFkZEFjdGlvbigic2VsZWN0VmVydGljZXMiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2VsZWN0VmVydGljZXMoKX0pO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3RFZGdlcyIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5zZWxlY3RFZGdlcygpfSk7dGhpcy5hZGRBY3Rpb24oImVkaXQiLGZ1bmN0aW9uKGEsYil7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5pc0NlbGxFZGl0YWJsZShiKSYmYS5ncmFwaC5zdGFydEVkaXRpbmdBdENlbGwoYil9KTsKdGhpcy5hZGRBY3Rpb24oInRvQmFjayIsZnVuY3Rpb24oYSxiKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLm9yZGVyQ2VsbHMoITApfSk7dGhpcy5hZGRBY3Rpb24oInRvRnJvbnQiLGZ1bmN0aW9uKGEsYil7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5vcmRlckNlbGxzKCExKX0pO3RoaXMuYWRkQWN0aW9uKCJlbnRlckdyb3VwIixmdW5jdGlvbihhLGIpe2EuZ3JhcGguZW50ZXJHcm91cChiKX0pO3RoaXMuYWRkQWN0aW9uKCJleGl0R3JvdXAiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguZXhpdEdyb3VwKCl9KTt0aGlzLmFkZEFjdGlvbigiaG9tZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5ob21lKCl9KTt0aGlzLmFkZEFjdGlvbigic2VsZWN0UHJldmlvdXMiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2VsZWN0UHJldmlvdXNDZWxsKCl9KTt0aGlzLmFkZEFjdGlvbigic2VsZWN0TmV4dCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmCmEuZ3JhcGguc2VsZWN0TmV4dENlbGwoKX0pO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3RQYXJlbnQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2VsZWN0UGFyZW50Q2VsbCgpfSk7dGhpcy5hZGRBY3Rpb24oInNlbGVjdENoaWxkIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNlbGVjdENoaWxkQ2VsbCgpfSk7dGhpcy5hZGRBY3Rpb24oImNvbGxhcHNlIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmZvbGRDZWxscyghMCl9KTt0aGlzLmFkZEFjdGlvbigiY29sbGFwc2VBbGwiLGZ1bmN0aW9uKGEpe2lmKGEuZ3JhcGguaXNFbmFibGVkKCkpe3ZhciBiPWEuZ3JhcGguZ2V0Q2hpbGRWZXJ0aWNlcygpO2EuZ3JhcGguZm9sZENlbGxzKCEwLCExLGIpfX0pO3RoaXMuYWRkQWN0aW9uKCJleHBhbmQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguZm9sZENlbGxzKCExKX0pOwp0aGlzLmFkZEFjdGlvbigiZXhwYW5kQWxsIixmdW5jdGlvbihhKXtpZihhLmdyYXBoLmlzRW5hYmxlZCgpKXt2YXIgYj1hLmdyYXBoLmdldENoaWxkVmVydGljZXMoKTthLmdyYXBoLmZvbGRDZWxscyghMSwhMSxiKX19KTt0aGlzLmFkZEFjdGlvbigiYm9sZCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC50b2dnbGVDZWxsU3R5bGVGbGFncyhteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsbXhDb25zdGFudHMuRk9OVF9CT0xEKX0pO3RoaXMuYWRkQWN0aW9uKCJpdGFsaWMiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGgudG9nZ2xlQ2VsbFN0eWxlRmxhZ3MobXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLG14Q29uc3RhbnRzLkZPTlRfSVRBTElDKX0pO3RoaXMuYWRkQWN0aW9uKCJ1bmRlcmxpbmUiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGgudG9nZ2xlQ2VsbFN0eWxlRmxhZ3MobXhDb25zdGFudHMuU1RZTEVfRk9OVFNUWUxFLApteENvbnN0YW50cy5GT05UX1VOREVSTElORSl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25DZWxsc0xlZnQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguYWxpZ25DZWxscyhteENvbnN0YW50cy5BTElHTl9MRUZUKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkNlbGxzQ2VudGVyIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLmFsaWduQ2VsbHMobXhDb25zdGFudHMuQUxJR05fQ0VOVEVSKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkNlbGxzUmlnaHQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguYWxpZ25DZWxscyhteENvbnN0YW50cy5BTElHTl9SSUdIVCl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25DZWxsc1RvcCIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5hbGlnbkNlbGxzKG14Q29uc3RhbnRzLkFMSUdOX1RPUCl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25DZWxsc01pZGRsZSIsCmZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguYWxpZ25DZWxscyhteENvbnN0YW50cy5BTElHTl9NSURETEUpfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduQ2VsbHNCb3R0b20iLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguYWxpZ25DZWxscyhteENvbnN0YW50cy5BTElHTl9CT1RUT00pfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduRm9udExlZnQiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9BTElHTixteENvbnN0YW50cy5BTElHTl9MRUZUKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkZvbnRDZW50ZXIiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9BTElHTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduRm9udFJpZ2h0IixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiYKYS5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX1JJR0hUKX0pO3RoaXMuYWRkQWN0aW9uKCJhbGlnbkZvbnRUb3AiLGZ1bmN0aW9uKGEpe2EuZ3JhcGguaXNFbmFibGVkKCkmJmEuZ3JhcGguc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTixteENvbnN0YW50cy5BTElHTl9UT1ApfSk7dGhpcy5hZGRBY3Rpb24oImFsaWduRm9udE1pZGRsZSIsZnVuY3Rpb24oYSl7YS5ncmFwaC5pc0VuYWJsZWQoKSYmYS5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1ZFUlRJQ0FMX0FMSUdOLG14Q29uc3RhbnRzLkFMSUdOX01JRERMRSl9KTt0aGlzLmFkZEFjdGlvbigiYWxpZ25Gb250Qm90dG9tIixmdW5jdGlvbihhKXthLmdyYXBoLmlzRW5hYmxlZCgpJiZhLmdyYXBoLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfVkVSVElDQUxfQUxJR04sbXhDb25zdGFudHMuQUxJR05fQk9UVE9NKX0pOwp0aGlzLmFkZEFjdGlvbigiem9vbSIsZnVuY3Rpb24oYSl7dmFyIGI9MTAwKmEuZ3JhcGguZ2V0VmlldygpLnNjYWxlLGI9cGFyc2VGbG9hdChteFV0aWxzLnByb21wdChteFJlc291cmNlcy5nZXQoYS5hc2tab29tUmVzb3VyY2UpfHxhLmFza1pvb21SZXNvdXJjZSxiKSkvMTAwO2lzTmFOKGIpfHxhLmdyYXBoLmdldFZpZXcoKS5zZXRTY2FsZShiKX0pO3RoaXMuYWRkQWN0aW9uKCJ0b2dnbGVUYXNrcyIsZnVuY3Rpb24oYSl7bnVsbCE9YS50YXNrcz9hLnRhc2tzLnNldFZpc2libGUoIWEudGFza3MuaXNWaXNpYmxlKCkpOmEuc2hvd1Rhc2tzKCl9KTt0aGlzLmFkZEFjdGlvbigidG9nZ2xlSGVscCIsZnVuY3Rpb24oYSl7bnVsbCE9YS5oZWxwP2EuaGVscC5zZXRWaXNpYmxlKCFhLmhlbHAuaXNWaXNpYmxlKCkpOmEuc2hvd0hlbHAoKX0pO3RoaXMuYWRkQWN0aW9uKCJ0b2dnbGVPdXRsaW5lIixmdW5jdGlvbihhKXtudWxsPT1hLm91dGxpbmU/YS5zaG93T3V0bGluZSgpOmEub3V0bGluZS5zZXRWaXNpYmxlKCFhLm91dGxpbmUuaXNWaXNpYmxlKCkpfSk7CnRoaXMuYWRkQWN0aW9uKCJ0b2dnbGVDb25zb2xlIixmdW5jdGlvbihhKXtteExvZy5zZXRWaXNpYmxlKCFteExvZy5pc1Zpc2libGUoKSl9KX07bXhFZGl0b3IucHJvdG90eXBlLmNvbmZpZ3VyZT1mdW5jdGlvbihhKXtudWxsIT1hJiYoKG5ldyBteENvZGVjKGEub3duZXJEb2N1bWVudCkpLmRlY29kZShhLHRoaXMpLHRoaXMucmVzZXRIaXN0b3J5KCkpfTtteEVkaXRvci5wcm90b3R5cGUucmVzZXRGaXJzdFRpbWU9ZnVuY3Rpb24oKXtkb2N1bWVudC5jb29raWU9Im14Z3JhcGg9c2VlbjsgZXhwaXJlcz1GcmksIDI3IEp1bCAyMDAxIDAyOjQ3OjExIFVUQzsgcGF0aD0vIn07bXhFZGl0b3IucHJvdG90eXBlLnJlc2V0SGlzdG9yeT1mdW5jdGlvbigpe3RoaXMubGFzdFNuYXBzaG90PShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLmlnbm9yZWRDaGFuZ2VzPTA7dGhpcy5zZXRNb2RpZmllZCghMSl9OwpteEVkaXRvci5wcm90b3R5cGUuYWRkQWN0aW9uPWZ1bmN0aW9uKGEsYil7dGhpcy5hY3Rpb25zW2FdPWJ9O214RWRpdG9yLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmFjdGlvbnNbYV07aWYobnVsbCE9ZCl0cnl7dmFyIGU9YXJndW1lbnRzO2VbMF09dGhpcztkLmFwcGx5KHRoaXMsZSl9Y2F0Y2goZil7dGhyb3cgbXhVdGlscy5lcnJvcigiQ2Fubm90IGV4ZWN1dGUgIithKyI6ICIrZi5tZXNzYWdlLDI4MCwhMCksZjt9ZWxzZSBteFV0aWxzLmVycm9yKCJDYW5ub3QgZmluZCBhY3Rpb24gIithLDI4MCwhMCl9O214RWRpdG9yLnByb3RvdHlwZS5hZGRUZW1wbGF0ZT1mdW5jdGlvbihhLGIpe3RoaXMudGVtcGxhdGVzW2FdPWJ9O214RWRpdG9yLnByb3RvdHlwZS5nZXRUZW1wbGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy50ZW1wbGF0ZXNbYV19OwpteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlR3JhcGg9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhHcmFwaChudWxsLG51bGwsdGhpcy5ncmFwaFJlbmRlckhpbnQpO2Euc2V0VG9vbHRpcHMoITApO2Euc2V0UGFubmluZyghMCk7dGhpcy5pbnN0YWxsRGJsQ2xpY2tIYW5kbGVyKGEpO3RoaXMuaW5zdGFsbFVuZG9IYW5kbGVyKGEpO3RoaXMuaW5zdGFsbERyaWxsSGFuZGxlcihhKTt0aGlzLmluc3RhbGxDaGFuZ2VIYW5kbGVyKGEpO3RoaXMuaW5zdGFsbEluc2VydEhhbmRsZXIoYSk7YS5wb3B1cE1lbnVIYW5kbGVyLmZhY3RvcnlNZXRob2Q9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjLGQpe3JldHVybiB0aGlzLmNyZWF0ZVBvcHVwTWVudShhLGMsZCl9KTthLmNvbm5lY3Rpb25IYW5kbGVyLmZhY3RvcnlNZXRob2Q9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtyZXR1cm4gdGhpcy5jcmVhdGVFZGdlKGEsYyl9KTt0aGlzLmNyZWF0ZVN3aW1sYW5lTWFuYWdlcihhKTsKdGhpcy5jcmVhdGVMYXlvdXRNYW5hZ2VyKGEpO3JldHVybiBhfTtteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlU3dpbWxhbmVNYW5hZ2VyPWZ1bmN0aW9uKGEpe2E9bmV3IG14U3dpbWxhbmVNYW5hZ2VyKGEsITEpO2EuaXNIb3Jpem9udGFsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaG9yaXpvbnRhbEZsb3d9KTthLmlzRW5hYmxlZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiB0aGlzLm1haW50YWluU3dpbWxhbmVzfSk7cmV0dXJuIGF9OwpteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlTGF5b3V0TWFuYWdlcj1mdW5jdGlvbihhKXt2YXIgYj1uZXcgbXhMYXlvdXRNYW5hZ2VyKGEpLGM9dGhpcztiLmdldExheW91dD1mdW5jdGlvbihiKXt2YXIgZD1udWxsLGY9Yy5ncmFwaC5nZXRNb2RlbCgpO251bGwhPWYuZ2V0UGFyZW50KGIpJiYoYy5sYXlvdXRTd2ltbGFuZXMmJmEuaXNTd2ltbGFuZShiKT8obnVsbD09Yy5zd2ltbGFuZUxheW91dCYmKGMuc3dpbWxhbmVMYXlvdXQ9Yy5jcmVhdGVTd2ltbGFuZUxheW91dCgpKSxkPWMuc3dpbWxhbmVMYXlvdXQpOmMubGF5b3V0RGlhZ3JhbSYmKGEuaXNWYWxpZFJvb3QoYil8fG51bGw9PWYuZ2V0UGFyZW50KGYuZ2V0UGFyZW50KGIpKSkmJihudWxsPT1jLmRpYWdyYW1MYXlvdXQmJihjLmRpYWdyYW1MYXlvdXQ9Yy5jcmVhdGVEaWFncmFtTGF5b3V0KCkpLGQ9Yy5kaWFncmFtTGF5b3V0KSk7cmV0dXJuIGR9O3JldHVybiBifTsKbXhFZGl0b3IucHJvdG90eXBlLnNldEdyYXBoQ29udGFpbmVyPWZ1bmN0aW9uKGEpe251bGw9PXRoaXMuZ3JhcGguY29udGFpbmVyJiYodGhpcy5ncmFwaC5pbml0KGEpLHRoaXMucnViYmVyYmFuZD1uZXcgbXhSdWJiZXJiYW5kKHRoaXMuZ3JhcGgpLHRoaXMuZGlzYWJsZUNvbnRleHRNZW51JiZteEV2ZW50LmRpc2FibGVDb250ZXh0TWVudShhKSxteENsaWVudC5JU19RVUlSS1MmJm5ldyBteERpdlJlc2l6ZXIoYSkpfTtteEVkaXRvci5wcm90b3R5cGUuaW5zdGFsbERibENsaWNrSGFuZGxlcj1mdW5jdGlvbihhKXthLmFkZExpc3RlbmVyKG14RXZlbnQuRE9VQkxFX0NMSUNLLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yy5nZXRQcm9wZXJ0eSgiY2VsbCIpO251bGwhPWQmJmEuaXNFbmFibGVkKCkmJm51bGwhPXRoaXMuZGJsQ2xpY2tBY3Rpb24mJih0aGlzLmV4ZWN1dGUodGhpcy5kYmxDbGlja0FjdGlvbixkKSxjLmNvbnN1bWUoKSl9KSl9OwpteEVkaXRvci5wcm90b3R5cGUuaW5zdGFsbFVuZG9IYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5nZXRQcm9wZXJ0eSgiZWRpdCIpO3RoaXMudW5kb01hbmFnZXIudW5kb2FibGVFZGl0SGFwcGVuZWQoYyl9KTthLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5VTkRPLGIpO2EuZ2V0VmlldygpLmFkZExpc3RlbmVyKG14RXZlbnQuVU5ETyxiKTtiPWZ1bmN0aW9uKGIsZCl7dmFyIGM9ZC5nZXRQcm9wZXJ0eSgiZWRpdCIpLmNoYW5nZXM7YS5zZXRTZWxlY3Rpb25DZWxscyhhLmdldFNlbGVjdGlvbkNlbGxzRm9yQ2hhbmdlcyhjKSl9O3RoaXMudW5kb01hbmFnZXIuYWRkTGlzdGVuZXIobXhFdmVudC5VTkRPLGIpO3RoaXMudW5kb01hbmFnZXIuYWRkTGlzdGVuZXIobXhFdmVudC5SRURPLGIpfTsKbXhFZGl0b3IucHJvdG90eXBlLmluc3RhbGxEcmlsbEhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ST09UKSl9KTthLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPV04sYik7YS5nZXRWaWV3KCkuYWRkTGlzdGVuZXIobXhFdmVudC5VUCxiKX07Cm14RWRpdG9yLnByb3RvdHlwZS5pbnN0YWxsQ2hhbmdlSGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGQpe3RoaXMuc2V0TW9kaWZpZWQoITApOzE9PXRoaXMudmFsaWRhdGluZyYmYS52YWxpZGF0ZUdyYXBoKCk7Zm9yKHZhciBjPWQuZ2V0UHJvcGVydHkoImVkaXQiKS5jaGFuZ2VzLGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGc9Y1tmXTtpZihnIGluc3RhbmNlb2YgbXhSb290Q2hhbmdlfHxnIGluc3RhbmNlb2YgbXhWYWx1ZUNoYW5nZSYmZy5jZWxsPT10aGlzLmdyYXBoLm1vZGVsLnJvb3R8fGcgaW5zdGFuY2VvZiBteENlbGxBdHRyaWJ1dGVDaGFuZ2UmJmcuY2VsbD09dGhpcy5ncmFwaC5tb2RlbC5yb290KXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlJPT1QpKTticmVha319fSk7YS5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLGIpfTsKbXhFZGl0b3IucHJvdG90eXBlLmluc3RhbGxJbnNlcnRIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7YS5hZGRNb3VzZUxpc3RlbmVyKHttb3VzZURvd246ZnVuY3Rpb24oYSxkKXtudWxsPT1iLmluc2VydEZ1bmN0aW9ufHxkLmlzUG9wdXBUcmlnZ2VyKCl8fCFiLmZvcmNlZEluc2VydGluZyYmbnVsbCE9ZC5nZXRTdGF0ZSgpfHwoYi5ncmFwaC5jbGVhclNlbGVjdGlvbigpLGIuaW5zZXJ0RnVuY3Rpb24oZC5nZXRFdmVudCgpLGQuZ2V0Q2VsbCgpKSx0aGlzLmlzQWN0aXZlPSEwLGQuY29uc3VtZSgpKX0sbW91c2VNb3ZlOmZ1bmN0aW9uKGEsYil7dGhpcy5pc0FjdGl2ZSYmYi5jb25zdW1lKCl9LG1vdXNlVXA6ZnVuY3Rpb24oYSxiKXt0aGlzLmlzQWN0aXZlJiYodGhpcy5pc0FjdGl2ZT0hMSxiLmNvbnN1bWUoKSl9fSl9OwpteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlRGlhZ3JhbUxheW91dD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGguZ3JpZFNpemUsYj1uZXcgbXhTdGFja0xheW91dCh0aGlzLmdyYXBoLCF0aGlzLmhvcml6b250YWxGbG93LHRoaXMuc3dpbWxhbmVTcGFjaW5nLDIqYSwyKmEpO2IuaXNWZXJ0ZXhJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiFiLmdyYXBoLmlzU3dpbWxhbmUoYSl9O3JldHVybiBifTtteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlU3dpbWxhbmVMYXlvdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14Q29tcGFjdFRyZWVMYXlvdXQodGhpcy5ncmFwaCx0aGlzLmhvcml6b250YWxGbG93KX07bXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVRvb2xiYXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14RGVmYXVsdFRvb2xiYXIobnVsbCx0aGlzKX07Cm14RWRpdG9yLnByb3RvdHlwZS5zZXRUb29sYmFyQ29udGFpbmVyPWZ1bmN0aW9uKGEpe3RoaXMudG9vbGJhci5pbml0KGEpO214Q2xpZW50LklTX1FVSVJLUyYmbmV3IG14RGl2UmVzaXplcihhKX07Cm14RWRpdG9yLnByb3RvdHlwZS5zZXRTdGF0dXNDb250YWluZXI9ZnVuY3Rpb24oYSl7bnVsbD09dGhpcy5zdGF0dXMmJih0aGlzLnN0YXR1cz1hLHRoaXMuYWRkTGlzdGVuZXIobXhFdmVudC5TQVZFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9KG5ldyBEYXRlKS50b0xvY2FsZVN0cmluZygpO3RoaXMuc2V0U3RhdHVzKChteFJlc291cmNlcy5nZXQodGhpcy5sYXN0U2F2ZWRSZXNvdXJjZSl8fHRoaXMubGFzdFNhdmVkUmVzb3VyY2UpKyI6ICIrYSl9KSksdGhpcy5hZGRMaXN0ZW5lcihteEV2ZW50Lk9QRU4sbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNldFN0YXR1cygobXhSZXNvdXJjZXMuZ2V0KHRoaXMuY3VycmVudEZpbGVSZXNvdXJjZSl8fHRoaXMuY3VycmVudEZpbGVSZXNvdXJjZSkrIjogIit0aGlzLmZpbGVuYW1lKX0pKSxteENsaWVudC5JU19RVUlSS1MmJm5ldyBteERpdlJlc2l6ZXIoYSkpfTsKbXhFZGl0b3IucHJvdG90eXBlLnNldFN0YXR1cz1mdW5jdGlvbihhKXtudWxsIT10aGlzLnN0YXR1cyYmbnVsbCE9YSYmKHRoaXMuc3RhdHVzLmlubmVySFRNTD1hKX07bXhFZGl0b3IucHJvdG90eXBlLnNldFRpdGxlQ29udGFpbmVyPWZ1bmN0aW9uKGEpe3RoaXMuYWRkTGlzdGVuZXIobXhFdmVudC5ST09ULG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EuaW5uZXJIVE1MPXRoaXMuZ2V0VGl0bGUoKX0pKTtteENsaWVudC5JU19RVUlSS1MmJm5ldyBteERpdlJlc2l6ZXIoYSl9O214RWRpdG9yLnByb3RvdHlwZS50cmVlTGF5b3V0PWZ1bmN0aW9uKGEsYil7bnVsbCE9YSYmKG5ldyBteENvbXBhY3RUcmVlTGF5b3V0KHRoaXMuZ3JhcGgsYikpLmV4ZWN1dGUoYSl9OwpteEVkaXRvci5wcm90b3R5cGUuZ2V0VGl0bGU9ZnVuY3Rpb24oKXtmb3IodmFyIGE9IiIsYj10aGlzLmdyYXBoLGM9Yi5nZXRDdXJyZW50Um9vdCgpO251bGwhPWMmJm51bGwhPWIuZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYi5nZXRNb2RlbCgpLmdldFBhcmVudChjKSk7KWIuaXNWYWxpZFJvb3QoYykmJihhPSIgPiAiK2IuY29udmVydFZhbHVlVG9TdHJpbmcoYykrYSksYz1iLmdldE1vZGVsKCkuZ2V0UGFyZW50KGMpO3JldHVybiB0aGlzLmdldFJvb3RUaXRsZSgpK2F9O214RWRpdG9yLnByb3RvdHlwZS5nZXRSb290VGl0bGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpO3JldHVybiB0aGlzLmdyYXBoLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGEpfTtteEVkaXRvci5wcm90b3R5cGUudW5kbz1mdW5jdGlvbigpe3RoaXMudW5kb01hbmFnZXIudW5kbygpfTtteEVkaXRvci5wcm90b3R5cGUucmVkbz1mdW5jdGlvbigpe3RoaXMudW5kb01hbmFnZXIucmVkbygpfTsKbXhFZGl0b3IucHJvdG90eXBlLmdyb3VwQ2VsbHM9ZnVuY3Rpb24oKXt2YXIgYT1udWxsIT10aGlzLmdyb3VwQm9yZGVyU2l6ZT90aGlzLmdyb3VwQm9yZGVyU2l6ZTp0aGlzLmdyYXBoLmdyaWRTaXplO3JldHVybiB0aGlzLmdyYXBoLmdyb3VwQ2VsbHModGhpcy5jcmVhdGVHcm91cCgpLGEpfTtteEVkaXRvci5wcm90b3R5cGUuY3JlYXRlR3JvdXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC5nZXRNb2RlbCgpLmNsb25lQ2VsbCh0aGlzLmRlZmF1bHRHcm91cCl9O214RWRpdG9yLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPW14VXRpbHMubG9hZChhKS5nZXRYbWwoKTt0aGlzLnJlYWRHcmFwaE1vZGVsKGIuZG9jdW1lbnRFbGVtZW50KTt0aGlzLmZpbGVuYW1lPWE7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5PUEVOLCJmaWxlbmFtZSIsYSkpfX07Cm14RWRpdG9yLnByb3RvdHlwZS5yZWFkR3JhcGhNb2RlbD1mdW5jdGlvbihhKXsobmV3IG14Q29kZWMoYS5vd25lckRvY3VtZW50KSkuZGVjb2RlKGEsdGhpcy5ncmFwaC5nZXRNb2RlbCgpKTt0aGlzLnJlc2V0SGlzdG9yeSgpfTtteEVkaXRvci5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihhLGIpe2E9YXx8dGhpcy5nZXRVcmxQb3N0KCk7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7dmFyIGM9dGhpcy53cml0ZUdyYXBoTW9kZWwoYik7dGhpcy5wb3N0RGlhZ3JhbShhLGMpO3RoaXMuc2V0TW9kaWZpZWQoITEpfXRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuU0FWRSwidXJsIixhKSl9OwpteEVkaXRvci5wcm90b3R5cGUucG9zdERpYWdyYW09ZnVuY3Rpb24oYSxiKXt0aGlzLmVzY2FwZVBvc3REYXRhJiYoYj1lbmNvZGVVUklDb21wb25lbnQoYikpO214VXRpbHMucG9zdChhLHRoaXMucG9zdFBhcmFtZXRlck5hbWUrIj0iK2IsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5QT1NULCJyZXF1ZXN0IixjLCJ1cmwiLGEsImRhdGEiLGIpKX0pKX07bXhFZGl0b3IucHJvdG90eXBlLndyaXRlR3JhcGhNb2RlbD1mdW5jdGlvbihhKXthPW51bGwhPWE/YTp0aGlzLmxpbmVmZWVkO3ZhciBiPShuZXcgbXhDb2RlYykuZW5jb2RlKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKSk7cmV0dXJuIG14VXRpbHMuZ2V0WG1sKGIsYSl9O214RWRpdG9yLnByb3RvdHlwZS5nZXRVcmxQb3N0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXJsUG9zdH07bXhFZGl0b3IucHJvdG90eXBlLmdldFVybEltYWdlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXJsSW1hZ2V9OwpteEVkaXRvci5wcm90b3R5cGUuc3dhcFN0eWxlcz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0U3R5bGVzaGVldCgpLnN0eWxlc1tiXTt0aGlzLmdyYXBoLmdldFZpZXcoKS5nZXRTdHlsZXNoZWV0KCkucHV0Q2VsbFN0eWxlKGIsdGhpcy5ncmFwaC5nZXRTdHlsZXNoZWV0KCkuc3R5bGVzW2FdKTt0aGlzLmdyYXBoLmdldFN0eWxlc2hlZXQoKS5wdXRDZWxsU3R5bGUoYSxjKTt0aGlzLmdyYXBoLnJlZnJlc2goKX07Cm14RWRpdG9yLnByb3RvdHlwZS5zaG93UHJvcGVydGllcz1mdW5jdGlvbihhKXthPWF8fHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbCgpO251bGw9PWEmJihhPXRoaXMuZ3JhcGguZ2V0Q3VycmVudFJvb3QoKSxudWxsPT1hJiYoYT10aGlzLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpKSk7aWYobnVsbCE9YSl7dGhpcy5ncmFwaC5zdG9wRWRpdGluZyghMCk7dmFyIGI9bXhVdGlscy5nZXRPZmZzZXQodGhpcy5ncmFwaC5jb250YWluZXIpLGM9Yi54KzEwLGI9Yi55O2lmKG51bGw9PXRoaXMucHJvcGVydGllc3x8dGhpcy5tb3ZlUHJvcGVydGllc0RpYWxvZyl7dmFyIGQ9dGhpcy5ncmFwaC5nZXRDZWxsQm91bmRzKGEpO251bGwhPWQmJihjKz1kLngrTWF0aC5taW4oMjAwLGQud2lkdGgpLGIrPWQueSl9ZWxzZSBjPXRoaXMucHJvcGVydGllcy5nZXRYKCksYj10aGlzLnByb3BlcnRpZXMuZ2V0WSgpO3RoaXMuaGlkZVByb3BlcnRpZXMoKTthPXRoaXMuY3JlYXRlUHJvcGVydGllcyhhKTsKbnVsbCE9YSYmKHRoaXMucHJvcGVydGllcz1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KHRoaXMucHJvcGVydGllc1Jlc291cmNlKXx8dGhpcy5wcm9wZXJ0aWVzUmVzb3VyY2UsYSxjLGIsdGhpcy5wcm9wZXJ0aWVzV2lkdGgsdGhpcy5wcm9wZXJ0aWVzSGVpZ2h0LCExKSx0aGlzLnByb3BlcnRpZXMuc2V0VmlzaWJsZSghMCkpfX07bXhFZGl0b3IucHJvdG90eXBlLmlzUHJvcGVydGllc1Zpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5wcm9wZXJ0aWVzfTsKbXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVByb3BlcnRpZXM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9Yi5nZXRWYWx1ZShhKTtpZihteFV0aWxzLmlzTm9kZShjKSl7dmFyIGQ9bmV3IG14Rm9ybSgicHJvcGVydGllcyIpO2QuYWRkVGV4dCgiSUQiLGEuZ2V0SWQoKSkuc2V0QXR0cmlidXRlKCJyZWFkb25seSIsInRydWUiKTt2YXIgZT1udWxsLGY9bnVsbCxnPW51bGwsaz1udWxsLGw9bnVsbDtiLmlzVmVydGV4KGEpJiYoZT1iLmdldEdlb21ldHJ5KGEpLG51bGwhPWUmJihmPWQuYWRkVGV4dCgidG9wIixlLnkpLGc9ZC5hZGRUZXh0KCJsZWZ0IixlLngpLGs9ZC5hZGRUZXh0KCJ3aWR0aCIsZS53aWR0aCksbD1kLmFkZFRleHQoImhlaWdodCIsZS5oZWlnaHQpKSk7Zm9yKHZhciBtPWIuZ2V0U3R5bGUoYSksbj1kLmFkZFRleHQoIlN0eWxlIixtfHwiIikscD1jLmF0dHJpYnV0ZXMscT1bXSxjPTA7YzxwLmxlbmd0aDtjKyspcVtjXT1kLmFkZFRleHRhcmVhKHBbY10ubm9kZU5hbWUsCnBbY10udmFsdWUsImxhYmVsIj09cFtjXS5ub2RlTmFtZT80OjIpO2M9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVQcm9wZXJ0aWVzKCk7Yi5iZWdpblVwZGF0ZSgpO3RyeXtudWxsIT1lJiYoZT1lLmNsb25lKCksZS54PXBhcnNlRmxvYXQoZy52YWx1ZSksZS55PXBhcnNlRmxvYXQoZi52YWx1ZSksZS53aWR0aD1wYXJzZUZsb2F0KGsudmFsdWUpLGUuaGVpZ2h0PXBhcnNlRmxvYXQobC52YWx1ZSksYi5zZXRHZW9tZXRyeShhLGUpKTswPG4udmFsdWUubGVuZ3RoP2Iuc2V0U3R5bGUoYSxuLnZhbHVlKTpiLnNldFN0eWxlKGEsbnVsbCk7Zm9yKHZhciBjPTA7YzxwLmxlbmd0aDtjKyspe3ZhciBkPW5ldyBteENlbGxBdHRyaWJ1dGVDaGFuZ2UoYSxwW2NdLm5vZGVOYW1lLHFbY10udmFsdWUpO2IuZXhlY3V0ZShkKX10aGlzLmdyYXBoLmlzQXV0b1NpemVDZWxsKGEpJiZ0aGlzLmdyYXBoLnVwZGF0ZUNlbGxTaXplKGEpfWZpbmFsbHl7Yi5lbmRVcGRhdGUoKX19KTsKbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZVByb3BlcnRpZXMoKX0pO2QuYWRkQnV0dG9ucyhjLG0pO3JldHVybiBkLnRhYmxlfXJldHVybiBudWxsfTtteEVkaXRvci5wcm90b3R5cGUuaGlkZVByb3BlcnRpZXM9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnByb3BlcnRpZXMmJih0aGlzLnByb3BlcnRpZXMuZGVzdHJveSgpLHRoaXMucHJvcGVydGllcz1udWxsKX07Cm14RWRpdG9yLnByb3RvdHlwZS5zaG93VGFza3M9ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnRhc2tzKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLnN0eWxlLnBhZGRpbmc9IjRweCI7YS5zdHlsZS5wYWRkaW5nTGVmdD0iMjBweCI7dmFyIGI9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCxiPW5ldyBteFdpbmRvdyhteFJlc291cmNlcy5nZXQodGhpcy50YXNrc1Jlc291cmNlKXx8dGhpcy50YXNrc1Jlc291cmNlLGEsYi0yMjAsdGhpcy50YXNrc1RvcCwyMDApO2Iuc2V0Q2xvc2FibGUoITApO2IuZGVzdHJveU9uQ2xvc2U9ITE7dmFyIGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bXhFdmVudC5yZWxlYXNlKGEpO2EuaW5uZXJIVE1MPSIiO3RoaXMuY3JlYXRlVGFza3MoYSl9KTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsYyk7dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Nb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLApjKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUk9PVCxjKTtudWxsIT10aGlzLnRhc2tzV2luZG93SW1hZ2UmJmIuc2V0SW1hZ2UodGhpcy50YXNrc1dpbmRvd0ltYWdlKTt0aGlzLnRhc2tzPWI7dGhpcy5jcmVhdGVUYXNrcyhhKX10aGlzLnRhc2tzLnNldFZpc2libGUoITApfTtteEVkaXRvci5wcm90b3R5cGUucmVmcmVzaFRhc2tzPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMudGFza3MmJihhPXRoaXMudGFza3MuY29udGVudCxteEV2ZW50LnJlbGVhc2UoYSksYS5pbm5lckhUTUw9IiIsdGhpcy5jcmVhdGVUYXNrcyhhKSl9O214RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVUYXNrcz1mdW5jdGlvbihhKXt9OwpteEVkaXRvci5wcm90b3R5cGUuc2hvd0hlbHA9ZnVuY3Rpb24oYSl7aWYobnVsbD09dGhpcy5oZWxwKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpZnJhbWUiKTtiLnNldEF0dHJpYnV0ZSgic3JjIixteFJlc291cmNlcy5nZXQoInVybEhlbHAiKXx8dGhpcy51cmxIZWxwKTtiLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IiwiMTAwJSIpO2Iuc2V0QXR0cmlidXRlKCJ3aWR0aCIsIjEwMCUiKTtiLnNldEF0dHJpYnV0ZSgiZnJhbWVCb3JkZXIiLCIwIik7Yi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IndoaXRlIjthPWRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7dmFyIGM9ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsZD1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KHRoaXMuaGVscFJlc291cmNlKXx8dGhpcy5oZWxwUmVzb3VyY2UsYiwoYS10aGlzLmhlbHBXaWR0aCkvMiwoYy10aGlzLmhlbHBIZWlnaHQpLwozLHRoaXMuaGVscFdpZHRoLHRoaXMuaGVscEhlaWdodCk7ZC5zZXRNYXhpbWl6YWJsZSghMCk7ZC5zZXRDbG9zYWJsZSghMCk7ZC5kZXN0cm95T25DbG9zZT0hMTtkLnNldFJlc2l6YWJsZSghMCk7bnVsbCE9dGhpcy5oZWxwV2luZG93SW1hZ2UmJmQuc2V0SW1hZ2UodGhpcy5oZWxwV2luZG93SW1hZ2UpO214Q2xpZW50LklTX05TJiYoYT1mdW5jdGlvbihhKXtiLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixkLmRpdi5vZmZzZXRIZWlnaHQtMjYrInB4Iil9LGQuYWRkTGlzdGVuZXIobXhFdmVudC5SRVNJWkVfRU5ELGEpLGQuYWRkTGlzdGVuZXIobXhFdmVudC5NQVhJTUlaRSxhKSxkLmFkZExpc3RlbmVyKG14RXZlbnQuTk9STUFMSVpFLGEpLGQuYWRkTGlzdGVuZXIobXhFdmVudC5TSE9XLGEpKTt0aGlzLmhlbHA9ZH10aGlzLmhlbHAuc2V0VmlzaWJsZSghMCl9OwpteEVkaXRvci5wcm90b3R5cGUuc2hvd091dGxpbmU9ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLm91dGxpbmUpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Euc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7YS5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2Euc3R5bGUud2lkdGg9IjEwMCUiO2Euc3R5bGUuaGVpZ2h0PSIxMDAlIjthLnN0eWxlLmJhY2tncm91bmQ9IndoaXRlIjthLnN0eWxlLmN1cnNvcj0ibW92ZSI7OD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiYoYS5zdHlsZS5maWx0ZXI9InByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5hbHBoYShvcGFjaXR5PTEwMCkiKTt2YXIgYj1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KHRoaXMub3V0bGluZVJlc291cmNlKXx8dGhpcy5vdXRsaW5lUmVzb3VyY2UsYSw2MDAsNDgwLDIwMCwyMDAsITEpLGM9bmV3IG14T3V0bGluZSh0aGlzLmdyYXBoLGEpO2Iuc2V0Q2xvc2FibGUoITApO2Iuc2V0UmVzaXphYmxlKCEwKTsKYi5kZXN0cm95T25DbG9zZT0hMTtiLmFkZExpc3RlbmVyKG14RXZlbnQuUkVTSVpFX0VORCxmdW5jdGlvbigpe2MudXBkYXRlKCl9KTt0aGlzLm91dGxpbmU9Yjt0aGlzLm91dGxpbmUub3V0bGluZT1jfXRoaXMub3V0bGluZS5zZXRWaXNpYmxlKCEwKTt0aGlzLm91dGxpbmUub3V0bGluZS51cGRhdGUoITApfTtteEVkaXRvci5wcm90b3R5cGUuc2V0TW9kZT1mdW5jdGlvbihhKXsic2VsZWN0Ij09YT8odGhpcy5ncmFwaC5wYW5uaW5nSGFuZGxlci51c2VMZWZ0QnV0dG9uRm9yUGFubmluZz0hMSx0aGlzLmdyYXBoLnNldENvbm5lY3RhYmxlKCExKSk6ImNvbm5lY3QiPT1hPyh0aGlzLmdyYXBoLnBhbm5pbmdIYW5kbGVyLnVzZUxlZnRCdXR0b25Gb3JQYW5uaW5nPSExLHRoaXMuZ3JhcGguc2V0Q29ubmVjdGFibGUoITApKToicGFuIj09YSYmKHRoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIudXNlTGVmdEJ1dHRvbkZvclBhbm5pbmc9ITAsdGhpcy5ncmFwaC5zZXRDb25uZWN0YWJsZSghMSkpfTsKbXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVBvcHVwTWVudT1mdW5jdGlvbihhLGIsYyl7dGhpcy5wb3B1cEhhbmRsZXIuY3JlYXRlTWVudSh0aGlzLGEsYixjKX07bXhFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUVkZ2U9ZnVuY3Rpb24oYSxiKXt2YXIgYztpZihudWxsIT10aGlzLmRlZmF1bHRFZGdlKWM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmNsb25lQ2VsbCh0aGlzLmRlZmF1bHRFZGdlKTtlbHNle2M9bmV3IG14Q2VsbCgiIik7Yy5zZXRFZGdlKCEwKTt2YXIgZD1uZXcgbXhHZW9tZXRyeTtkLnJlbGF0aXZlPSEwO2Muc2V0R2VvbWV0cnkoZCl9ZD10aGlzLmdldEVkZ2VTdHlsZSgpO251bGwhPWQmJmMuc2V0U3R5bGUoZCk7cmV0dXJuIGN9O214RWRpdG9yLnByb3RvdHlwZS5nZXRFZGdlU3R5bGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWZhdWx0RWRnZVN0eWxlfTsKbXhFZGl0b3IucHJvdG90eXBlLmNvbnN1bWVDeWNsZUF0dHJpYnV0ZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9dGhpcy5jeWNsZUF0dHJpYnV0ZVZhbHVlcyYmMDx0aGlzLmN5Y2xlQXR0cmlidXRlVmFsdWVzLmxlbmd0aCYmdGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEpP3RoaXMuY3ljbGVBdHRyaWJ1dGVWYWx1ZXNbdGhpcy5jeWNsZUF0dHJpYnV0ZUluZGV4KysldGhpcy5jeWNsZUF0dHJpYnV0ZVZhbHVlcy5sZW5ndGhdOm51bGx9O214RWRpdG9yLnByb3RvdHlwZS5jeWNsZUF0dHJpYnV0ZT1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLmN5Y2xlQXR0cmlidXRlTmFtZSl7dmFyIGI9dGhpcy5jb25zdW1lQ3ljbGVBdHRyaWJ1dGUoYSk7bnVsbCE9YiYmYS5zZXRTdHlsZShhLmdldFN0eWxlKCkrIjsiK3RoaXMuY3ljbGVBdHRyaWJ1dGVOYW1lKyI9IitiKX19OwpteEVkaXRvci5wcm90b3R5cGUuYWRkVmVydGV4PWZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZT10aGlzLmdyYXBoLmdldE1vZGVsKCk7bnVsbCE9YSYmIXRoaXMuZ3JhcGguaXNWYWxpZERyb3BUYXJnZXQoYSk7KWE9ZS5nZXRQYXJlbnQoYSk7YT1udWxsIT1hP2E6dGhpcy5ncmFwaC5nZXRTd2ltbGFuZUF0KGMsZCk7dmFyIGY9dGhpcy5ncmFwaC5nZXRWaWV3KCkuc2NhbGUsZz1lLmdldEdlb21ldHJ5KGIpLGs9ZS5nZXRHZW9tZXRyeShhKTtpZih0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYikmJiF0aGlzLmdyYXBoLnN3aW1sYW5lTmVzdGluZylhPW51bGw7ZWxzZXtpZihudWxsPT1hJiZ0aGlzLnN3aW1sYW5lUmVxdWlyZWQpcmV0dXJuIG51bGw7aWYobnVsbCE9YSYmbnVsbCE9ayl7dmFyIGw9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUoYSk7aWYobnVsbCE9bCl7aWYoYy09bC5vcmlnaW4ueCpmLGQtPWwub3JpZ2luLnkqZix0aGlzLmdyYXBoLmlzQ29uc3RyYWluZWRNb3Zpbmcpe3ZhciBrPQpnLndpZHRoLG09Zy5oZWlnaHQsbj1sLngrbC53aWR0aDtjK2s+biYmKGMtPWMray1uKTtuPWwueStsLmhlaWdodDtkK20+biYmKGQtPWQrbS1uKX19ZWxzZSBudWxsIT1rJiYoYy09ay54KmYsZC09ay55KmYpfX1nPWcuY2xvbmUoKTtnLng9dGhpcy5ncmFwaC5zbmFwKGMvZi10aGlzLmdyYXBoLmdldFZpZXcoKS50cmFuc2xhdGUueC10aGlzLmdyYXBoLmdyaWRTaXplLzIpO2cueT10aGlzLmdyYXBoLnNuYXAoZC9mLXRoaXMuZ3JhcGguZ2V0VmlldygpLnRyYW5zbGF0ZS55LXRoaXMuZ3JhcGguZ3JpZFNpemUvMik7Yi5zZXRHZW9tZXRyeShnKTtudWxsPT1hJiYoYT10aGlzLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKSk7dGhpcy5jeWNsZUF0dHJpYnV0ZShiKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LkJFRk9SRV9BRERfVkVSVEVYLCJ2ZXJ0ZXgiLGIsInBhcmVudCIsYSkpO2UuYmVnaW5VcGRhdGUoKTt0cnl7Yj10aGlzLmdyYXBoLmFkZENlbGwoYiwKYSksbnVsbCE9YiYmKHRoaXMuZ3JhcGguY29uc3RyYWluQ2hpbGQoYiksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5BRERfVkVSVEVYLCJ2ZXJ0ZXgiLGIpKSl9ZmluYWxseXtlLmVuZFVwZGF0ZSgpfW51bGwhPWImJih0aGlzLmdyYXBoLnNldFNlbGVjdGlvbkNlbGwoYiksdGhpcy5ncmFwaC5zY3JvbGxDZWxsVG9WaXNpYmxlKGIpLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuQUZURVJfQUREX1ZFUlRFWCwidmVydGV4IixiKSkpO3JldHVybiBifTsKbXhFZGl0b3IucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3llZHx8KHRoaXMuZGVzdHJveWVkPSEwLG51bGwhPXRoaXMudGFza3MmJnRoaXMudGFza3MuZGVzdHJveSgpLG51bGwhPXRoaXMub3V0bGluZSYmdGhpcy5vdXRsaW5lLmRlc3Ryb3koKSxudWxsIT10aGlzLnByb3BlcnRpZXMmJnRoaXMucHJvcGVydGllcy5kZXN0cm95KCksbnVsbCE9dGhpcy5rZXlIYW5kbGVyJiZ0aGlzLmtleUhhbmRsZXIuZGVzdHJveSgpLG51bGwhPXRoaXMucnViYmVyYmFuZCYmdGhpcy5ydWJiZXJiYW5kLmRlc3Ryb3koKSxudWxsIT10aGlzLnRvb2xiYXImJnRoaXMudG9vbGJhci5kZXN0cm95KCksbnVsbCE9dGhpcy5ncmFwaCYmdGhpcy5ncmFwaC5kZXN0cm95KCksdGhpcy50ZW1wbGF0ZXM9dGhpcy5zdGF0dXM9bnVsbCl9Owp2YXIgbXhDb2RlY1JlZ2lzdHJ5PXtjb2RlY3M6W10sYWxpYXNlczpbXSxyZWdpc3RlcjpmdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj1hLmdldE5hbWUoKTtteENvZGVjUmVnaXN0cnkuY29kZWNzW2JdPWE7dmFyIGM9bXhVdGlscy5nZXRGdW5jdGlvbk5hbWUoYS50ZW1wbGF0ZS5jb25zdHJ1Y3Rvcik7YyE9YiYmbXhDb2RlY1JlZ2lzdHJ5LmFkZEFsaWFzKGMsYil9cmV0dXJuIGF9LGFkZEFsaWFzOmZ1bmN0aW9uKGEsYil7bXhDb2RlY1JlZ2lzdHJ5LmFsaWFzZXNbYV09Yn0sZ2V0Q29kZWM6ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtpZihudWxsIT1hKXt2YXIgYj1teFV0aWxzLmdldEZ1bmN0aW9uTmFtZShhKSxjPW14Q29kZWNSZWdpc3RyeS5hbGlhc2VzW2JdO251bGwhPWMmJihiPWMpO2I9bXhDb2RlY1JlZ2lzdHJ5LmNvZGVjc1tiXTtpZihudWxsPT1iKXRyeXtiPW5ldyBteE9iamVjdENvZGVjKG5ldyBhKSxteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoYil9Y2F0Y2goZCl7fX1yZXR1cm4gYn19OwpmdW5jdGlvbiBteENvZGVjKGEpe3RoaXMuZG9jdW1lbnQ9YXx8bXhVdGlscy5jcmVhdGVYbWxEb2N1bWVudCgpO3RoaXMub2JqZWN0cz1bXX1teENvZGVjLnByb3RvdHlwZS5kb2N1bWVudD1udWxsO214Q29kZWMucHJvdG90eXBlLm9iamVjdHM9bnVsbDtteENvZGVjLnByb3RvdHlwZS5lbGVtZW50cz1udWxsO214Q29kZWMucHJvdG90eXBlLmVuY29kZURlZmF1bHRzPSExO214Q29kZWMucHJvdG90eXBlLnB1dE9iamVjdD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm9iamVjdHNbYV09Yn07bXhDb2RlYy5wcm90b3R5cGUuZ2V0T2JqZWN0PWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmKGI9dGhpcy5vYmplY3RzW2FdLG51bGw9PWImJihiPXRoaXMubG9va3VwKGEpLG51bGw9PWImJihhPXRoaXMuZ2V0RWxlbWVudEJ5SWQoYSksbnVsbCE9YSYmKGI9dGhpcy5kZWNvZGUoYSkpKSkpO3JldHVybiBifTtteENvZGVjLnByb3RvdHlwZS5sb29rdXA9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9OwpteENvZGVjLnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZD1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZUVsZW1lbnRzKCk7cmV0dXJuIHRoaXMuZWxlbWVudHNbYV19O214Q29kZWMucHJvdG90eXBlLnVwZGF0ZUVsZW1lbnRzPWZ1bmN0aW9uKCl7bnVsbD09dGhpcy5lbGVtZW50cyYmKHRoaXMuZWxlbWVudHM9e30sbnVsbCE9dGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJnRoaXMuYWRkRWxlbWVudCh0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpfTsKbXhDb2RlYy5wcm90b3R5cGUuYWRkRWxlbWVudD1mdW5jdGlvbihhKXtpZihhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXt2YXIgYj1hLmdldEF0dHJpYnV0ZSgiaWQiKTtpZihudWxsIT1iKWlmKG51bGw9PXRoaXMuZWxlbWVudHNbYl0pdGhpcy5lbGVtZW50c1tiXT1hO2Vsc2UgaWYodGhpcy5lbGVtZW50c1tiXSE9YSl0aHJvdyBFcnJvcihiKyI6IER1cGxpY2F0ZSBJRCIpO31mb3IoYT1hLmZpcnN0Q2hpbGQ7bnVsbCE9YTspdGhpcy5hZGRFbGVtZW50KGEpLGE9YS5uZXh0U2libGluZ307bXhDb2RlYy5wcm90b3R5cGUuZ2V0SWQ9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbDtudWxsIT1hJiYoYj10aGlzLnJlZmVyZW5jZShhKSxudWxsPT1iJiZhIGluc3RhbmNlb2YgbXhDZWxsJiYoYj1hLmdldElkKCksbnVsbD09YiYmKGI9bXhDZWxsUGF0aC5jcmVhdGUoYSksMD09Yi5sZW5ndGgmJihiPSJyb290IikpKSk7cmV0dXJuIGJ9OwpteENvZGVjLnByb3RvdHlwZS5yZWZlcmVuY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O214Q29kZWMucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKG51bGwhPWEmJm51bGwhPWEuY29uc3RydWN0b3Ipe3ZhciBjPW14Q29kZWNSZWdpc3RyeS5nZXRDb2RlYyhhLmNvbnN0cnVjdG9yKTtudWxsIT1jP2I9Yy5lbmNvZGUodGhpcyxhKTpteFV0aWxzLmlzTm9kZShhKT9iPW14VXRpbHMuaW1wb3J0Tm9kZSh0aGlzLmRvY3VtZW50LGEsITApOm14TG9nLndhcm4oIm14Q29kZWMuZW5jb2RlOiBObyBjb2RlYyBmb3IgIitteFV0aWxzLmdldEZ1bmN0aW9uTmFtZShhLmNvbnN0cnVjdG9yKSl9cmV0dXJuIGJ9OwpteENvZGVjLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oYSxiKXt0aGlzLnVwZGF0ZUVsZW1lbnRzKCk7dmFyIGM9bnVsbDtpZihudWxsIT1hJiZhLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXtjPW51bGw7dHJ5e2M9d2luZG93W2Eubm9kZU5hbWVdfWNhdGNoKGQpe31jPW14Q29kZWNSZWdpc3RyeS5nZXRDb2RlYyhjKTtudWxsIT1jP2M9Yy5kZWNvZGUodGhpcyxhLGIpOihjPWEuY2xvbmVOb2RlKCEwKSxjLnJlbW92ZUF0dHJpYnV0ZSgiYXMiKSl9cmV0dXJuIGN9O214Q29kZWMucHJvdG90eXBlLmVuY29kZUNlbGw9ZnVuY3Rpb24oYSxiLGMpe2IuYXBwZW5kQ2hpbGQodGhpcy5lbmNvZGUoYSkpO2lmKG51bGw9PWN8fGMpe2M9YS5nZXRDaGlsZENvdW50KCk7Zm9yKHZhciBkPTA7ZDxjO2QrKyl0aGlzLmVuY29kZUNlbGwoYS5nZXRDaGlsZEF0KGQpLGIpfX07Cm14Q29kZWMucHJvdG90eXBlLmlzQ2VsbENvZGVjPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYiZnVuY3Rpb24iPT10eXBlb2YgYS5pc0NlbGxDb2RlYz9hLmlzQ2VsbENvZGVjKCk6ITF9O214Q29kZWMucHJvdG90eXBlLmRlY29kZUNlbGw9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/YjohMDt2YXIgYz1udWxsO2lmKG51bGwhPWEmJmEubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe2M9bXhDb2RlY1JlZ2lzdHJ5LmdldENvZGVjKGEubm9kZU5hbWUpO2lmKCF0aGlzLmlzQ2VsbENvZGVjKGMpKWZvcih2YXIgZD1hLmZpcnN0Q2hpbGQ7bnVsbCE9ZCYmIXRoaXMuaXNDZWxsQ29kZWMoYyk7KWM9bXhDb2RlY1JlZ2lzdHJ5LmdldENvZGVjKGQubm9kZU5hbWUpLGQ9ZC5uZXh0U2libGluZzt0aGlzLmlzQ2VsbENvZGVjKGMpfHwoYz1teENvZGVjUmVnaXN0cnkuZ2V0Q29kZWMobXhDZWxsKSk7Yz1jLmRlY29kZSh0aGlzLGEpO2ImJnRoaXMuaW5zZXJ0SW50b0dyYXBoKGMpfXJldHVybiBjfTsKbXhDb2RlYy5wcm90b3R5cGUuaW5zZXJ0SW50b0dyYXBoPWZ1bmN0aW9uKGEpe3ZhciBiPWEucGFyZW50LGM9YS5nZXRUZXJtaW5hbCghMCksZD1hLmdldFRlcm1pbmFsKCExKTthLnNldFRlcm1pbmFsKG51bGwsITEpO2Euc2V0VGVybWluYWwobnVsbCwhMCk7YS5wYXJlbnQ9bnVsbDtpZihudWxsIT1iKXtpZihiPT1hKXRocm93IEVycm9yKGIuaWQrIjogU2VsZiBSZWZlcmVuY2UiKTtiLmluc2VydChhKX1udWxsIT1jJiZjLmluc2VydEVkZ2UoYSwhMCk7bnVsbCE9ZCYmZC5pbnNlcnRFZGdlKGEsITEpfTtteENvZGVjLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWImJm51bGwhPWMmJmEuc2V0QXR0cmlidXRlKGIsYyl9OwpmdW5jdGlvbiBteE9iamVjdENvZGVjKGEsYixjLGQpe3RoaXMudGVtcGxhdGU9YTt0aGlzLmV4Y2x1ZGU9bnVsbCE9Yj9iOltdO3RoaXMuaWRyZWZzPW51bGwhPWM/YzpbXTt0aGlzLm1hcHBpbmc9bnVsbCE9ZD9kOltdO3RoaXMucmV2ZXJzZT17fTtmb3IodmFyIGUgaW4gdGhpcy5tYXBwaW5nKXRoaXMucmV2ZXJzZVt0aGlzLm1hcHBpbmdbZV1dPWV9bXhPYmplY3RDb2RlYy5hbGxvd0V2YWw9ITE7bXhPYmplY3RDb2RlYy5wcm90b3R5cGUudGVtcGxhdGU9bnVsbDtteE9iamVjdENvZGVjLnByb3RvdHlwZS5leGNsdWRlPW51bGw7bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuaWRyZWZzPW51bGw7bXhPYmplY3RDb2RlYy5wcm90b3R5cGUubWFwcGluZz1udWxsO214T2JqZWN0Q29kZWMucHJvdG90eXBlLnJldmVyc2U9bnVsbDtteE9iamVjdENvZGVjLnByb3RvdHlwZS5nZXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG14VXRpbHMuZ2V0RnVuY3Rpb25OYW1lKHRoaXMudGVtcGxhdGUuY29uc3RydWN0b3IpfTsKbXhPYmplY3RDb2RlYy5wcm90b3R5cGUuY2xvbmVUZW1wbGF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgdGhpcy50ZW1wbGF0ZS5jb25zdHJ1Y3Rvcn07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZ2V0RmllbGROYW1lPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPXRoaXMucmV2ZXJzZVthXTtudWxsIT1iJiYoYT1iKX1yZXR1cm4gYX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTmFtZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKXt2YXIgYj10aGlzLm1hcHBpbmdbYV07bnVsbCE9YiYmKGE9Yil9cmV0dXJuIGF9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmlzRXhjbHVkZWQ9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGI9PW14T2JqZWN0SWRlbnRpdHkuRklFTERfTkFNRXx8MDw9bXhVdGlscy5pbmRleE9mKHRoaXMuZXhjbHVkZSxiKX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmlzUmVmZXJlbmNlPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiAwPD1teFV0aWxzLmluZGV4T2YodGhpcy5pZHJlZnMsYil9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmdldE5hbWUoKSk7Yj10aGlzLmJlZm9yZUVuY29kZShhLGIsYyk7dGhpcy5lbmNvZGVPYmplY3QoYSxiLGMpO3JldHVybiB0aGlzLmFmdGVyRW5jb2RlKGEsYixjKX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZW5jb2RlT2JqZWN0PWZ1bmN0aW9uKGEsYixjKXthLnNldEF0dHJpYnV0ZShjLCJpZCIsYS5nZXRJZChiKSk7Zm9yKHZhciBkIGluIGIpe3ZhciBlPWQsZj1iW2VdO251bGw9PWZ8fHRoaXMuaXNFeGNsdWRlZChiLGUsZiwhMCl8fChteFV0aWxzLmlzSW50ZWdlcihlKSYmKGU9bnVsbCksdGhpcy5lbmNvZGVWYWx1ZShhLGIsZSxmLGMpKX19OwpteE9iamVjdENvZGVjLnByb3RvdHlwZS5lbmNvZGVWYWx1ZT1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKG51bGwhPWQpe2lmKHRoaXMuaXNSZWZlcmVuY2UoYixjLGQsITApKXt2YXIgZj1hLmdldElkKGQpO2lmKG51bGw9PWYpe214TG9nLndhcm4oIm14T2JqZWN0Q29kZWMuZW5jb2RlOiBObyBJRCBmb3IgIit0aGlzLmdldE5hbWUoKSsiLiIrYysiPSIrZCk7cmV0dXJufWQ9Zn1mPXRoaXMudGVtcGxhdGVbY107aWYobnVsbD09Y3x8YS5lbmNvZGVEZWZhdWx0c3x8ZiE9ZCljPXRoaXMuZ2V0QXR0cmlidXRlTmFtZShjKSx0aGlzLndyaXRlQXR0cmlidXRlKGEsYixjLGQsZSl9fTtteE9iamVjdENvZGVjLnByb3RvdHlwZS53cml0ZUF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyxkLGUpeyJvYmplY3QiIT10eXBlb2YgZD90aGlzLndyaXRlUHJpbWl0aXZlQXR0cmlidXRlKGEsYixjLGQsZSk6dGhpcy53cml0ZUNvbXBsZXhBdHRyaWJ1dGUoYSxiLGMsZCxlKX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLndyaXRlUHJpbWl0aXZlQXR0cmlidXRlPWZ1bmN0aW9uKGEsYixjLGQsZSl7ZD10aGlzLmNvbnZlcnRBdHRyaWJ1dGVUb1htbChhLGIsYyxkLGUpO251bGw9PWM/KGI9YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhZGQiKSwiZnVuY3Rpb24iPT10eXBlb2YgZD9iLmFwcGVuZENoaWxkKGEuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZCkpOmEuc2V0QXR0cmlidXRlKGIsInZhbHVlIixkKSxlLmFwcGVuZENoaWxkKGIpKToiZnVuY3Rpb24iIT10eXBlb2YgZCYmYS5zZXRBdHRyaWJ1dGUoZSxjLGQpfTsKbXhPYmplY3RDb2RlYy5wcm90b3R5cGUud3JpdGVDb21wbGV4QXR0cmlidXRlPWZ1bmN0aW9uKGEsYixjLGQsZSl7YT1hLmVuY29kZShkKTtudWxsIT1hPyhudWxsIT1jJiZhLnNldEF0dHJpYnV0ZSgiYXMiLGMpLGUuYXBwZW5kQ2hpbGQoYSkpOm14TG9nLndhcm4oIm14T2JqZWN0Q29kZWMuZW5jb2RlOiBObyBub2RlIGZvciAiK3RoaXMuZ2V0TmFtZSgpKyIuIitjKyI6ICIrZCl9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmNvbnZlcnRBdHRyaWJ1dGVUb1htbD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLmlzQm9vbGVhbkF0dHJpYnV0ZShhLGIsYyxkKSYmKGQ9MT09ZD8iMSI6IjAiKTtyZXR1cm4gZH07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuaXNCb29sZWFuQXR0cmlidXRlPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiJ1bmRlZmluZWQiPT10eXBlb2YgZC5sZW5ndGgmJigxPT1kfHwwPT1kKX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmNvbnZlcnRBdHRyaWJ1dGVGcm9tWG1sPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLnZhbHVlO3RoaXMuaXNOdW1lcmljQXR0cmlidXRlKGEsYixjKSYmKGQ9cGFyc2VGbG9hdChkKSxpc05hTihkKXx8IWlzRmluaXRlKGQpKSYmKGQ9MCk7cmV0dXJuIGR9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmlzTnVtZXJpY0F0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGMuY29uc3RydWN0b3I9PW14R2VvbWV0cnkmJigieCI9PWIubmFtZXx8InkiPT1iLm5hbWV8fCJ3aWR0aCI9PWIubmFtZXx8ImhlaWdodCI9PWIubmFtZSl8fGMuY29uc3RydWN0b3I9PW14UG9pbnQmJigieCI9PWIubmFtZXx8InkiPT1iLm5hbWUpfHxteFV0aWxzLmlzTnVtZXJpYyhiLnZhbHVlKX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuYmVmb3JlRW5jb2RlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYn07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmFmdGVyRW5jb2RlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gY307bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLmdldEF0dHJpYnV0ZSgiaWQiKSxlPWEub2JqZWN0c1tkXTtudWxsPT1lJiYoZT1jfHx0aGlzLmNsb25lVGVtcGxhdGUoKSxudWxsIT1kJiZhLnB1dE9iamVjdChkLGUpKTtiPXRoaXMuYmVmb3JlRGVjb2RlKGEsYixlKTt0aGlzLmRlY29kZU5vZGUoYSxiLGUpO3JldHVybiB0aGlzLmFmdGVyRGVjb2RlKGEsYixlKX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZGVjb2RlTm9kZT1mdW5jdGlvbihhLGIsYyl7bnVsbCE9YiYmKHRoaXMuZGVjb2RlQXR0cmlidXRlcyhhLGIsYyksdGhpcy5kZWNvZGVDaGlsZHJlbihhLGIsYykpfTsKbXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZGVjb2RlQXR0cmlidXRlcz1mdW5jdGlvbihhLGIsYyl7Yj1iLmF0dHJpYnV0ZXM7aWYobnVsbCE9Yilmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl0aGlzLmRlY29kZUF0dHJpYnV0ZShhLGJbZF0sYyl9O214T2JqZWN0Q29kZWMucHJvdG90eXBlLmlzSWdub3JlZEF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuImFzIj09Yi5ub2RlTmFtZXx8ImlkIj09Yi5ub2RlTmFtZX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmRlY29kZUF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIXRoaXMuaXNJZ25vcmVkQXR0cmlidXRlKGEsYixjKSl7dmFyIGQ9Yi5ub2RlTmFtZTtiPXRoaXMuY29udmVydEF0dHJpYnV0ZUZyb21YbWwoYSxiLGMpO3ZhciBlPXRoaXMuZ2V0RmllbGROYW1lKGQpO2lmKHRoaXMuaXNSZWZlcmVuY2UoYyxlLGIsITEpKXthPWEuZ2V0T2JqZWN0KGIpO2lmKG51bGw9PWEpe214TG9nLndhcm4oIm14T2JqZWN0Q29kZWMuZGVjb2RlOiBObyBvYmplY3QgZm9yICIrdGhpcy5nZXROYW1lKCkrIi4iK2QrIj0iK2IpO3JldHVybn1iPWF9dGhpcy5pc0V4Y2x1ZGVkKGMsZCxiLCExKXx8KGNbZF09Yil9fTsKbXhPYmplY3RDb2RlYy5wcm90b3R5cGUuZGVjb2RlQ2hpbGRyZW49ZnVuY3Rpb24oYSxiLGMpe2ZvcihiPWIuZmlyc3RDaGlsZDtudWxsIT1iOyl7dmFyIGQ9Yi5uZXh0U2libGluZztiLm5vZGVUeXBlIT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UfHx0aGlzLnByb2Nlc3NJbmNsdWRlKGEsYixjKXx8dGhpcy5kZWNvZGVDaGlsZChhLGIsYyk7Yj1kfX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmRlY29kZUNoaWxkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdldEZpZWxkTmFtZShiLmdldEF0dHJpYnV0ZSgiYXMiKSk7aWYobnVsbD09ZHx8IXRoaXMuaXNFeGNsdWRlZChjLGQsYiwhMSkpe3ZhciBlPXRoaXMuZ2V0RmllbGRUZW1wbGF0ZShjLGQsYik7ImFkZCI9PWIubm9kZU5hbWU/KGE9Yi5nZXRBdHRyaWJ1dGUoInZhbHVlIiksbnVsbD09YSYmbXhPYmplY3RDb2RlYy5hbGxvd0V2YWwmJihhPW14VXRpbHMuZXZhbChteFV0aWxzLmdldFRleHRDb250ZW50KGIpKSkpOmE9YS5kZWNvZGUoYixlKTt0cnl7dGhpcy5hZGRPYmplY3RWYWx1ZShjLGQsYSxlKX1jYXRjaChmKXt0aHJvdyBFcnJvcihmLm1lc3NhZ2UrIiBmb3IgIitiLm5vZGVOYW1lKTt9fX07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmdldEZpZWxkVGVtcGxhdGU9ZnVuY3Rpb24oYSxiLGMpe2E9YVtiXTthIGluc3RhbmNlb2YgQXJyYXkmJjA8YS5sZW5ndGgmJihhPW51bGwpO3JldHVybiBhfTtteE9iamVjdENvZGVjLnByb3RvdHlwZS5hZGRPYmplY3RWYWx1ZT1mdW5jdGlvbihhLGIsYyxkKXtudWxsIT1jJiZjIT1kJiYobnVsbCE9YiYmMDxiLmxlbmd0aD9hW2JdPWM6YS5wdXNoKGMpKX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUucHJvY2Vzc0luY2x1ZGU9ZnVuY3Rpb24oYSxiLGMpe2lmKCJpbmNsdWRlIj09Yi5ub2RlTmFtZSl7Yj1iLmdldEF0dHJpYnV0ZSgibmFtZSIpO2lmKG51bGwhPWIpdHJ5e3ZhciBkPW14VXRpbHMubG9hZChiKS5nZXREb2N1bWVudEVsZW1lbnQoKTtudWxsIT1kJiZhLmRlY29kZShkLGMpfWNhdGNoKGUpe31yZXR1cm4hMH1yZXR1cm4hMX07bXhPYmplY3RDb2RlYy5wcm90b3R5cGUuYmVmb3JlRGVjb2RlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYn07Cm14T2JqZWN0Q29kZWMucHJvdG90eXBlLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gY307Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteENlbGwsWyJjaGlsZHJlbiIsImVkZ2VzIiwib3ZlcmxheXMiLCJteFRyYW5zaWVudCJdLFsicGFyZW50Iiwic291cmNlIiwidGFyZ2V0Il0pO2EuaXNDZWxsQ29kZWM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07YS5pc051bWVyaWNBdHRyaWJ1dGU9ZnVuY3Rpb24oYSxjLGQpe3JldHVybiJ2YWx1ZSIhPT1jLm5vZGVOYW1lJiZteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc051bWVyaWNBdHRyaWJ1dGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfTthLmlzRXhjbHVkZWQ9ZnVuY3Rpb24oYSxjLGQsZSl7cmV0dXJuIG14T2JqZWN0Q29kZWMucHJvdG90eXBlLmlzRXhjbHVkZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHxlJiYidmFsdWUiPT1jJiZkLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UfTthLmFmdGVyRW5jb2RlPWZ1bmN0aW9uKGEsYyxkKXtpZihudWxsIT0KYy52YWx1ZSYmYy52YWx1ZS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7dmFyIGI9ZDtkPW14VXRpbHMuaW1wb3J0Tm9kZShhLmRvY3VtZW50LGMudmFsdWUsITApO2QuYXBwZW5kQ2hpbGQoYik7YT1iLmdldEF0dHJpYnV0ZSgiaWQiKTtkLnNldEF0dHJpYnV0ZSgiaWQiLGEpO2IucmVtb3ZlQXR0cmlidXRlKCJpZCIpfXJldHVybiBkfTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGMsZCl7dmFyIGI9Yy5jbG9uZU5vZGUoITApLGY9dGhpcy5nZXROYW1lKCk7Yy5ub2RlTmFtZSE9Zj8oYj1jLmdldEVsZW1lbnRzQnlUYWdOYW1lKGYpWzBdLG51bGwhPWImJmIucGFyZW50Tm9kZT09Yz8obXhVdGlscy5yZW1vdmVXaGl0ZXNwYWNlKGIsITApLG14VXRpbHMucmVtb3ZlV2hpdGVzcGFjZShiLCExKSxiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYikpOmI9bnVsbCxkLnZhbHVlPWMuY2xvbmVOb2RlKCEwKSxjPWQudmFsdWUuZ2V0QXR0cmlidXRlKCJpZCIpLG51bGwhPQpjJiYoZC5zZXRJZChjKSxkLnZhbHVlLnJlbW92ZUF0dHJpYnV0ZSgiaWQiKSkpOmQuc2V0SWQoYy5nZXRBdHRyaWJ1dGUoImlkIikpO2lmKG51bGwhPWIpZm9yKGM9MDtjPHRoaXMuaWRyZWZzLmxlbmd0aDtjKyspe3ZhciBmPXRoaXMuaWRyZWZzW2NdLGc9Yi5nZXRBdHRyaWJ1dGUoZik7aWYobnVsbCE9Zyl7Yi5yZW1vdmVBdHRyaWJ1dGUoZik7dmFyIGs9YS5vYmplY3RzW2ddfHxhLmxvb2t1cChnKTtudWxsPT1rJiYoZz1hLmdldEVsZW1lbnRCeUlkKGcpLG51bGwhPWcmJihrPShteENvZGVjUmVnaXN0cnkuY29kZWNzW2cubm9kZU5hbWVdfHx0aGlzKS5kZWNvZGUoYSxnKSkpO2RbZl09a319cmV0dXJuIGJ9O3JldHVybiBhfSgpKTsKbXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IG14R3JhcGhNb2RlbCk7YS5lbmNvZGVPYmplY3Q9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicm9vdCIpO2EuZW5jb2RlQ2VsbChjLmdldFJvb3QoKSxiKTtkLmFwcGVuZENoaWxkKGIpfTthLmRlY29kZUNoaWxkPWZ1bmN0aW9uKGEsYyxkKXsicm9vdCI9PWMubm9kZU5hbWU/dGhpcy5kZWNvZGVSb290KGEsYyxkKTpteE9iamVjdENvZGVjLnByb3RvdHlwZS5kZWNvZGVDaGlsZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2EuZGVjb2RlUm9vdD1mdW5jdGlvbihhLGMsZCl7dmFyIGI9bnVsbDtmb3IoYz1jLmZpcnN0Q2hpbGQ7bnVsbCE9Yzspe3ZhciBmPWEuZGVjb2RlQ2VsbChjKTtudWxsIT1mJiZudWxsPT1mLmdldFBhcmVudCgpJiYoYj1mKTtjPWMubmV4dFNpYmxpbmd9bnVsbCE9YiYmZC5zZXRSb290KGIpfTtyZXR1cm4gYX0oKSk7Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteFJvb3RDaGFuZ2UsWyJtb2RlbCIsInByZXZpb3VzIiwicm9vdCJdKTthLmFmdGVyRW5jb2RlPWZ1bmN0aW9uKGEsYyxkKXthLmVuY29kZUNlbGwoYy5yb290LGQpO3JldHVybiBkfTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGMsZCl7aWYobnVsbCE9Yy5maXJzdENoaWxkJiZjLmZpcnN0Q2hpbGQubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe2M9Yy5jbG9uZU5vZGUoITApO3ZhciBiPWMuZmlyc3RDaGlsZDtkLnJvb3Q9YS5kZWNvZGVDZWxsKGIsITEpO2Q9Yi5uZXh0U2libGluZztiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7Zm9yKGI9ZDtudWxsIT1iOylkPWIubmV4dFNpYmxpbmcsYS5kZWNvZGVDZWxsKGIpLGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSxiPWR9cmV0dXJuIGN9O2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxjLApkKXtkLnByZXZpb3VzPWQucm9vdDtyZXR1cm4gZH07cmV0dXJuIGF9KCkpOwpteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhDaGlsZENoYW5nZSxbIm1vZGVsIiwiY2hpbGQiLCJwcmV2aW91c0luZGV4Il0sWyJwYXJlbnQiLCJwcmV2aW91cyJdKTthLmlzUmVmZXJlbmNlPWZ1bmN0aW9uKGEsYyxkLGUpe3JldHVybiJjaGlsZCIhPWN8fGUmJiFhLm1vZGVsLmNvbnRhaW5zKGEucHJldmlvdXMpPzA8PW14VXRpbHMuaW5kZXhPZih0aGlzLmlkcmVmcyxjKTohMH07YS5pc0V4Y2x1ZGVkPWZ1bmN0aW9uKGEsYyxkLGUpe3JldHVybiBteE9iamVjdENvZGVjLnByb3RvdHlwZS5pc0V4Y2x1ZGVkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8ZSYmbnVsbCE9ZCYmKCJwcmV2aW91cyI9PWN8fCJwYXJlbnQiPT1jKSYmIWEubW9kZWwuY29udGFpbnMoZCl9O2EuYWZ0ZXJFbmNvZGU9ZnVuY3Rpb24oYSxjLGQpe3RoaXMuaXNSZWZlcmVuY2UoYywiY2hpbGQiLGMuY2hpbGQsITApP2Quc2V0QXR0cmlidXRlKCJjaGlsZCIsCmEuZ2V0SWQoYy5jaGlsZCkpOmEuZW5jb2RlQ2VsbChjLmNoaWxkLGQpO3JldHVybiBkfTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGMsZCl7aWYobnVsbCE9Yy5maXJzdENoaWxkJiZjLmZpcnN0Q2hpbGQubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe2M9Yy5jbG9uZU5vZGUoITApO3ZhciBiPWMuZmlyc3RDaGlsZDtkLmNoaWxkPWEuZGVjb2RlQ2VsbChiLCExKTtkPWIubmV4dFNpYmxpbmc7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO2ZvcihiPWQ7bnVsbCE9Yjspe2Q9Yi5uZXh0U2libGluZztpZihiLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UKXt2YXIgZj1iLmdldEF0dHJpYnV0ZSgiaWQiKTtudWxsPT1hLmxvb2t1cChmKSYmYS5kZWNvZGVDZWxsKGIpfWIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtiPWR9fWVsc2UgYj1jLmdldEF0dHJpYnV0ZSgiY2hpbGQiKSxkLmNoaWxkPWEuZ2V0T2JqZWN0KGIpO3JldHVybiBjfTsKYS5hZnRlckRlY29kZT1mdW5jdGlvbihhLGMsZCl7bnVsbCE9ZC5jaGlsZCYmKG51bGwhPWQuY2hpbGQucGFyZW50JiZudWxsIT1kLnByZXZpb3VzJiZkLmNoaWxkLnBhcmVudCE9ZC5wcmV2aW91cyYmKGQucHJldmlvdXM9ZC5jaGlsZC5wYXJlbnQpLGQuY2hpbGQucGFyZW50PWQucHJldmlvdXMsZC5wcmV2aW91cz1kLnBhcmVudCxkLnByZXZpb3VzSW5kZXg9ZC5pbmRleCk7cmV0dXJuIGR9O3JldHVybiBhfSgpKTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhUZXJtaW5hbENoYW5nZSxbIm1vZGVsIiwicHJldmlvdXMiXSxbImNlbGwiLCJ0ZXJtaW5hbCJdKTthLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsYyxkKXtkLnByZXZpb3VzPWQudGVybWluYWw7cmV0dXJuIGR9O3JldHVybiBhfSgpKTsKdmFyIG14R2VuZXJpY0NoYW5nZUNvZGVjPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IG14T2JqZWN0Q29kZWMoYSxbIm1vZGVsIiwicHJldmlvdXMiXSxbImNlbGwiXSk7Yy5hZnRlckRlY29kZT1mdW5jdGlvbihhLGMsZil7bXhVdGlscy5pc05vZGUoZi5jZWxsKSYmKGYuY2VsbD1hLmRlY29kZUNlbGwoZi5jZWxsLCExKSk7Zi5wcmV2aW91cz1mW2JdO3JldHVybiBmfTtyZXR1cm4gY307bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKG14R2VuZXJpY0NoYW5nZUNvZGVjKG5ldyBteFZhbHVlQ2hhbmdlLCJ2YWx1ZSIpKTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIobXhHZW5lcmljQ2hhbmdlQ29kZWMobmV3IG14U3R5bGVDaGFuZ2UsInN0eWxlIikpO214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihteEdlbmVyaWNDaGFuZ2VDb2RlYyhuZXcgbXhHZW9tZXRyeUNoYW5nZSwiZ2VvbWV0cnkiKSk7Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihteEdlbmVyaWNDaGFuZ2VDb2RlYyhuZXcgbXhDb2xsYXBzZUNoYW5nZSwiY29sbGFwc2VkIikpO214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihteEdlbmVyaWNDaGFuZ2VDb2RlYyhuZXcgbXhWaXNpYmxlQ2hhbmdlLCJ2aXNpYmxlIikpO214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihteEdlbmVyaWNDaGFuZ2VDb2RlYyhuZXcgbXhDZWxsQXR0cmlidXRlQ2hhbmdlLCJ2YWx1ZSIpKTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14T2JqZWN0Q29kZWMobmV3IG14R3JhcGgsImdyYXBoTGlzdGVuZXJzIGV2ZW50TGlzdGVuZXJzIHZpZXcgY29udGFpbmVyIGNlbGxSZW5kZXJlciBlZGl0b3Igc2VsZWN0aW9uIi5zcGxpdCgiICIpKX0oKSk7Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteEdyYXBoVmlldyk7YS5lbmNvZGU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gdGhpcy5lbmNvZGVDZWxsKGEsYyxjLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpKX07YS5lbmNvZGVDZWxsPWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj1jLmdyYXBoLmdldE1vZGVsKCksZj1jLmdldFN0YXRlKGQpLGc9Yi5nZXRQYXJlbnQoZCk7aWYobnVsbD09Z3x8bnVsbCE9Zil7dmFyIGs9Yi5nZXRDaGlsZENvdW50KGQpLGw9Yy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoZCksbT1udWxsO2c9PWIuZ2V0Um9vdCgpP209ImxheWVyIjpudWxsPT1nP209ImdyYXBoIjpiLmlzRWRnZShkKT9tPSJlZGdlIjowPGsmJm51bGwhPWw/bT0iZ3JvdXAiOmIuaXNWZXJ0ZXgoZCkmJihtPSJ2ZXJ0ZXgiKTtpZihudWxsIT1tKXt2YXIgbj1hLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobSk7bnVsbCE9Yy5ncmFwaC5nZXRMYWJlbChkKSYmCihuLnNldEF0dHJpYnV0ZSgibGFiZWwiLGMuZ3JhcGguZ2V0TGFiZWwoZCkpLGMuZ3JhcGguaXNIdG1sTGFiZWwoZCkmJm4uc2V0QXR0cmlidXRlKCJodG1sIiwhMCkpO2lmKG51bGw9PWcpe3ZhciBwPWMuZ2V0R3JhcGhCb3VuZHMoKTtudWxsIT1wJiYobi5zZXRBdHRyaWJ1dGUoIngiLE1hdGgucm91bmQocC54KSksbi5zZXRBdHRyaWJ1dGUoInkiLE1hdGgucm91bmQocC55KSksbi5zZXRBdHRyaWJ1dGUoIndpZHRoIixNYXRoLnJvdW5kKHAud2lkdGgpKSxuLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IixNYXRoLnJvdW5kKHAuaGVpZ2h0KSkpO24uc2V0QXR0cmlidXRlKCJzY2FsZSIsYy5zY2FsZSl9ZWxzZSBpZihudWxsIT1mJiZudWxsIT1sKXtmb3IocCBpbiBmLnN0eWxlKWc9Zi5zdHlsZVtwXSwiZnVuY3Rpb24iPT10eXBlb2YgZyYmIm9iamVjdCI9PXR5cGVvZiBnJiYoZz1teFN0eWxlUmVnaXN0cnkuZ2V0TmFtZShnKSksbnVsbCE9ZyYmImZ1bmN0aW9uIiE9dHlwZW9mIGcmJiJvYmplY3QiIT0KdHlwZW9mIGcmJm4uc2V0QXR0cmlidXRlKHAsZyk7Zz1mLmFic29sdXRlUG9pbnRzO2lmKG51bGwhPWcmJjA8Zy5sZW5ndGgpe2w9TWF0aC5yb3VuZChnWzBdLngpKyIsIitNYXRoLnJvdW5kKGdbMF0ueSk7Zm9yKHA9MTtwPGcubGVuZ3RoO3ArKylsKz0iICIrTWF0aC5yb3VuZChnW3BdLngpKyIsIitNYXRoLnJvdW5kKGdbcF0ueSk7bi5zZXRBdHRyaWJ1dGUoInBvaW50cyIsbCl9ZWxzZSBuLnNldEF0dHJpYnV0ZSgieCIsTWF0aC5yb3VuZChmLngpKSxuLnNldEF0dHJpYnV0ZSgieSIsTWF0aC5yb3VuZChmLnkpKSxuLnNldEF0dHJpYnV0ZSgid2lkdGgiLE1hdGgucm91bmQoZi53aWR0aCkpLG4uc2V0QXR0cmlidXRlKCJoZWlnaHQiLE1hdGgucm91bmQoZi5oZWlnaHQpKTtwPWYuYWJzb2x1dGVPZmZzZXQ7bnVsbCE9cCYmKDAhPXAueCYmbi5zZXRBdHRyaWJ1dGUoImR4IixNYXRoLnJvdW5kKHAueCkpLDAhPXAueSYmbi5zZXRBdHRyaWJ1dGUoImR5IixNYXRoLnJvdW5kKHAueSkpKX1mb3IocD0KMDtwPGs7cCsrKWY9dGhpcy5lbmNvZGVDZWxsKGEsYyxiLmdldENoaWxkQXQoZCxwKSksbnVsbCE9ZiYmbi5hcHBlbmRDaGlsZChmKX19cmV0dXJuIG59O3JldHVybiBhfSgpKTsKdmFyIG14U3R5bGVzaGVldENvZGVjPW14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteFN0eWxlc2hlZXQpO2EuZW5jb2RlPWZ1bmN0aW9uKGEsYyl7dmFyIGI9YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0TmFtZSgpKSxlO2ZvcihlIGluIGMuc3R5bGVzKXt2YXIgZj1jLnN0eWxlc1tlXSxnPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYWRkIik7aWYobnVsbCE9ZSl7Zy5zZXRBdHRyaWJ1dGUoImFzIixlKTtmb3IodmFyIGsgaW4gZil7dmFyIGw9dGhpcy5nZXRTdHJpbmdWYWx1ZShrLGZba10pO2lmKG51bGwhPWwpe3ZhciBtPWEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYWRkIik7bS5zZXRBdHRyaWJ1dGUoInZhbHVlIixsKTttLnNldEF0dHJpYnV0ZSgiYXMiLGspO2cuYXBwZW5kQ2hpbGQobSl9fTA8Zy5jaGlsZE5vZGVzLmxlbmd0aCYmYi5hcHBlbmRDaGlsZChnKX19cmV0dXJuIGJ9O2EuZ2V0U3RyaW5nVmFsdWU9CmZ1bmN0aW9uKGEsYyl7dmFyIGI9dHlwZW9mIGM7ImZ1bmN0aW9uIj09Yj9jPW14U3R5bGVSZWdpc3RyeS5nZXROYW1lKGMpOiJvYmplY3QiPT1iJiYoYz1udWxsKTtyZXR1cm4gY307YS5kZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe2Q9ZHx8bmV3IHRoaXMudGVtcGxhdGUuY29uc3RydWN0b3I7dmFyIGI9Yy5nZXRBdHRyaWJ1dGUoImlkIik7bnVsbCE9YiYmKGEub2JqZWN0c1tiXT1kKTtmb3IoYz1jLmZpcnN0Q2hpbGQ7bnVsbCE9Yzspe2lmKCF0aGlzLnByb2Nlc3NJbmNsdWRlKGEsYyxkKSYmImFkZCI9PWMubm9kZU5hbWUmJihiPWMuZ2V0QXR0cmlidXRlKCJhcyIpLG51bGwhPWIpKXt2YXIgZj1jLmdldEF0dHJpYnV0ZSgiZXh0ZW5kIiksZz1udWxsIT1mP214VXRpbHMuY2xvbmUoZC5zdHlsZXNbZl0pOm51bGw7bnVsbD09ZyYmKG51bGwhPWYmJm14TG9nLndhcm4oIm14U3R5bGVzaGVldENvZGVjLmRlY29kZTogc3R5bGVzaGVldCAiK2YrIiBub3QgZm91bmQgdG8gZXh0ZW5kIiksZz0Ke30pO2ZvcihmPWMuZmlyc3RDaGlsZDtudWxsIT1mOyl7aWYoZi5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCl7dmFyIGs9Zi5nZXRBdHRyaWJ1dGUoImFzIik7aWYoImFkZCI9PWYubm9kZU5hbWUpe3ZhciBsPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoZik7bnVsbCE9bCYmMDxsLmxlbmd0aCYmbXhTdHlsZXNoZWV0Q29kZWMuYWxsb3dFdmFsP2w9bXhVdGlscy5ldmFsKGwpOihsPWYuZ2V0QXR0cmlidXRlKCJ2YWx1ZSIpLG14VXRpbHMuaXNOdW1lcmljKGwpJiYobD1wYXJzZUZsb2F0KGwpKSk7bnVsbCE9bCYmKGdba109bCl9ZWxzZSJyZW1vdmUiPT1mLm5vZGVOYW1lJiZkZWxldGUgZ1trXX1mPWYubmV4dFNpYmxpbmd9ZC5wdXRDZWxsU3R5bGUoYixnKX1jPWMubmV4dFNpYmxpbmd9cmV0dXJuIGR9O3JldHVybiBhfSgpKTtteFN0eWxlc2hlZXRDb2RlYy5hbGxvd0V2YWw9ITA7Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteERlZmF1bHRLZXlIYW5kbGVyKTthLmVuY29kZT1mdW5jdGlvbihhLGMpe3JldHVybiBudWxsfTthLmRlY29kZT1mdW5jdGlvbihhLGMsZCl7aWYobnVsbCE9ZClmb3IoYz1jLmZpcnN0Q2hpbGQ7bnVsbCE9Yzspe2lmKCF0aGlzLnByb2Nlc3NJbmNsdWRlKGEsYyxkKSYmImFkZCI9PWMubm9kZU5hbWUpe3ZhciBiPWMuZ2V0QXR0cmlidXRlKCJhcyIpLGY9Yy5nZXRBdHRyaWJ1dGUoImFjdGlvbiIpLGc9Yy5nZXRBdHRyaWJ1dGUoImNvbnRyb2wiKTtkLmJpbmRBY3Rpb24oYixmLGcpfWM9Yy5uZXh0U2libGluZ31yZXR1cm4gZH07cmV0dXJuIGF9KCkpOwp2YXIgbXhEZWZhdWx0VG9vbGJhckNvZGVjPW14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteERlZmF1bHRUb29sYmFyKTthLmVuY29kZT1mdW5jdGlvbihhLGMpe3JldHVybiBudWxsfTthLmRlY29kZT1mdW5jdGlvbihhLGMsZCl7aWYobnVsbCE9ZCl7dmFyIGI9ZC5lZGl0b3I7Zm9yKGM9Yy5maXJzdENoaWxkO251bGwhPWM7KXtpZihjLm5vZGVUeXBlPT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UJiYhdGhpcy5wcm9jZXNzSW5jbHVkZShhLGMsZCkpaWYoInNlcGFyYXRvciI9PWMubm9kZU5hbWUpZC5hZGRTZXBhcmF0b3IoKTtlbHNlIGlmKCJiciI9PWMubm9kZU5hbWUpZC50b29sYmFyLmFkZEJyZWFrKCk7ZWxzZSBpZigiaHIiPT1jLm5vZGVOYW1lKWQudG9vbGJhci5hZGRMaW5lKCk7ZWxzZSBpZigiYWRkIj09Yy5ub2RlTmFtZSl7dmFyIGY9Yy5nZXRBdHRyaWJ1dGUoImFzIiksZj1teFJlc291cmNlcy5nZXQoZil8fApmLGc9Yy5nZXRBdHRyaWJ1dGUoImljb24iKSxrPWMuZ2V0QXR0cmlidXRlKCJwcmVzc2VkSWNvbiIpLGw9Yy5nZXRBdHRyaWJ1dGUoImFjdGlvbiIpLG09Yy5nZXRBdHRyaWJ1dGUoIm1vZGUiKSxuPWMuZ2V0QXR0cmlidXRlKCJ0ZW1wbGF0ZSIpLHA9IjAiIT1jLmdldEF0dHJpYnV0ZSgidG9nZ2xlIikscT1teFV0aWxzLmdldFRleHRDb250ZW50KGMpLHI9bnVsbDtpZihudWxsIT1sKXI9ZC5hZGRJdGVtKGYsZyxsLGspO2Vsc2UgaWYobnVsbCE9bSl2YXIgdD1teERlZmF1bHRUb29sYmFyQ29kZWMuYWxsb3dFdmFsP214VXRpbHMuZXZhbChxKTpudWxsLHI9ZC5hZGRNb2RlKGYsZyxtLGssdCk7ZWxzZSBpZihudWxsIT1ufHxudWxsIT1xJiYwPHEubGVuZ3RoKXI9Yi50ZW1wbGF0ZXNbbl0sbj1jLmdldEF0dHJpYnV0ZSgic3R5bGUiKSxudWxsIT1yJiZudWxsIT1uJiYocj1iLmdyYXBoLmNsb25lQ2VsbChyKSxyLnNldFN0eWxlKG4pKSxuPW51bGwsbnVsbCE9cSYmMDxxLmxlbmd0aCYmCm14RGVmYXVsdFRvb2xiYXJDb2RlYy5hbGxvd0V2YWwmJihuPW14VXRpbHMuZXZhbChxKSkscj1kLmFkZFByb3RvdHlwZShmLGcscixrLG4scCk7ZWxzZSBpZihrPW14VXRpbHMuZ2V0Q2hpbGROb2RlcyhjKSwwPGsubGVuZ3RoKWlmKG51bGw9PWcpZm9yKG49ZC5hZGRBY3Rpb25Db21ibyhmKSxmPTA7ZjxrLmxlbmd0aDtmKyspcD1rW2ZdLCJzZXBhcmF0b3IiPT1wLm5vZGVOYW1lP2QuYWRkT3B0aW9uKG4sIi0tLSIpOiJhZGQiPT1wLm5vZGVOYW1lJiYoZz1wLmdldEF0dHJpYnV0ZSgiYXMiKSxwPXAuZ2V0QXR0cmlidXRlKCJhY3Rpb24iKSxkLmFkZEFjdGlvbk9wdGlvbihuLGcscCkpO2Vsc2V7dmFyIHU9bnVsbCx4PWQuYWRkUHJvdG90eXBlKGYsZyxmdW5jdGlvbigpe3ZhciBhPWIudGVtcGxhdGVzW3UudmFsdWVdO2lmKG51bGwhPWEpe3ZhciBhPWEuY2xvbmUoKSxjPXUub3B0aW9uc1t1LnNlbGVjdGVkSW5kZXhdLmNlbGxTdHlsZTtudWxsIT1jJiZhLnNldFN0eWxlKGMpO3JldHVybiBhfW14TG9nLndhcm4oIlRlbXBsYXRlICIrCmErIiBub3QgZm91bmQiKTtyZXR1cm4gbnVsbH0sbnVsbCxudWxsLHApLHU9ZC5hZGRDb21ibygpO214RXZlbnQuYWRkTGlzdGVuZXIodSwiY2hhbmdlIixmdW5jdGlvbigpe2QudG9vbGJhci5zZWxlY3RNb2RlKHgsZnVuY3Rpb24oYSl7YT1teFV0aWxzLmNvbnZlcnRQb2ludChiLmdyYXBoLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoYSksbXhFdmVudC5nZXRDbGllbnRZKGEpKTtyZXR1cm4gYi5hZGRWZXJ0ZXgobnVsbCx0KCksYS54LGEueSl9KTtkLnRvb2xiYXIubm9SZXNldD0hMX0pO2ZvcihmPTA7ZjxrLmxlbmd0aDtmKyspcD1rW2ZdLCJzZXBhcmF0b3IiPT1wLm5vZGVOYW1lP2QuYWRkT3B0aW9uKHUsIi0tLSIpOiJhZGQiPT1wLm5vZGVOYW1lJiYoZz1wLmdldEF0dHJpYnV0ZSgiYXMiKSxxPXAuZ2V0QXR0cmlidXRlKCJ0ZW1wbGF0ZSIpLGQuYWRkT3B0aW9uKHUsZyxxfHxuKS5jZWxsU3R5bGU9cC5nZXRBdHRyaWJ1dGUoInN0eWxlIikpfW51bGwhPXImJihuPWMuZ2V0QXR0cmlidXRlKCJpZCIpLApudWxsIT1uJiYwPG4ubGVuZ3RoJiZyLnNldEF0dHJpYnV0ZSgiaWQiLG4pKX1jPWMubmV4dFNpYmxpbmd9fXJldHVybiBkfTtyZXR1cm4gYX0oKSk7bXhEZWZhdWx0VG9vbGJhckNvZGVjLmFsbG93RXZhbD0hMDtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhPYmplY3RDb2RlYyhuZXcgbXhEZWZhdWx0UG9wdXBNZW51KTthLmVuY29kZT1mdW5jdGlvbihhLGMpe3JldHVybiBudWxsfTthLmRlY29kZT1mdW5jdGlvbihhLGMsZCl7dmFyIGI9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaW5jbHVkZSIpWzBdO251bGwhPWI/dGhpcy5wcm9jZXNzSW5jbHVkZShhLGIsZCk6bnVsbCE9ZCYmKGQuY29uZmlnPWMpO3JldHVybiBkfTtyZXR1cm4gYX0oKSk7Cm14Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBteEVkaXRvciwibW9kaWZpZWQgbGFzdFNuYXBzaG90IGlnbm9yZWRDaGFuZ2VzIHVuZG9NYW5hZ2VyIGdyYXBoQ29udGFpbmVyIHRvb2xiYXJDb250YWluZXIiLnNwbGl0KCIgIikpO2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxjLGQpe2E9Yy5nZXRBdHRyaWJ1dGUoImRlZmF1bHRFZGdlIik7bnVsbCE9YSYmKGMucmVtb3ZlQXR0cmlidXRlKCJkZWZhdWx0RWRnZSIpLGQuZGVmYXVsdEVkZ2U9ZC50ZW1wbGF0ZXNbYV0pO2E9Yy5nZXRBdHRyaWJ1dGUoImRlZmF1bHRHcm91cCIpO251bGwhPWEmJihjLnJlbW92ZUF0dHJpYnV0ZSgiZGVmYXVsdEdyb3VwIiksZC5kZWZhdWx0R3JvdXA9ZC50ZW1wbGF0ZXNbYV0pO3JldHVybiBkfTthLmRlY29kZUNoaWxkPWZ1bmN0aW9uKGEsYyxkKXtpZigiQXJyYXkiPT1jLm5vZGVOYW1lKXtpZigidGVtcGxhdGVzIj09Yy5nZXRBdHRyaWJ1dGUoImFzIikpe3RoaXMuZGVjb2RlVGVtcGxhdGVzKGEsCmMsZCk7cmV0dXJufX1lbHNlIGlmKCJ1aSI9PWMubm9kZU5hbWUpe3RoaXMuZGVjb2RlVWkoYSxjLGQpO3JldHVybn1teE9iamVjdENvZGVjLnByb3RvdHlwZS5kZWNvZGVDaGlsZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2EuZGVjb2RlVWk9ZnVuY3Rpb24oYSxjLGQpe2ZvcihhPWMuZmlyc3RDaGlsZDtudWxsIT1hOyl7aWYoImFkZCI9PWEubm9kZU5hbWUpe2M9YS5nZXRBdHRyaWJ1dGUoImFzIik7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoImVsZW1lbnQiKSxmPWEuZ2V0QXR0cmlidXRlKCJzdHlsZSIpO2lmKG51bGwhPWIpYj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKSxudWxsIT1iJiZudWxsIT1mJiYoYi5zdHlsZS5jc3NUZXh0Kz0iOyIrZik7ZWxzZXt2YXIgZz1wYXJzZUludChhLmdldEF0dHJpYnV0ZSgieCIpKSxrPXBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCJ5IikpLGw9YS5nZXRBdHRyaWJ1dGUoIndpZHRoIiksbT1hLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IiksYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKYi5zdHlsZS5jc3NUZXh0PWY7KG5ldyBteFdpbmRvdyhteFJlc291cmNlcy5nZXQoYyl8fGMsYixnLGssbCxtLCExLCEwKSkuc2V0VmlzaWJsZSghMCl9ImdyYXBoIj09Yz9kLnNldEdyYXBoQ29udGFpbmVyKGIpOiJ0b29sYmFyIj09Yz9kLnNldFRvb2xiYXJDb250YWluZXIoYik6InRpdGxlIj09Yz9kLnNldFRpdGxlQ29udGFpbmVyKGIpOiJzdGF0dXMiPT1jP2Quc2V0U3RhdHVzQ29udGFpbmVyKGIpOiJtYXAiPT1jJiZkLnNldE1hcENvbnRhaW5lcihiKX1lbHNlInJlc291cmNlIj09YS5ub2RlTmFtZT9teFJlc291cmNlcy5hZGQoYS5nZXRBdHRyaWJ1dGUoImJhc2VuYW1lIikpOiJzdHlsZXNoZWV0Ij09YS5ub2RlTmFtZSYmbXhDbGllbnQubGluaygic3R5bGVzaGVldCIsYS5nZXRBdHRyaWJ1dGUoIm5hbWUiKSk7YT1hLm5leHRTaWJsaW5nfX07YS5kZWNvZGVUZW1wbGF0ZXM9ZnVuY3Rpb24oYSxjLGQpe251bGw9PWQudGVtcGxhdGVzJiYoZC50ZW1wbGF0ZXM9W10pO2M9bXhVdGlscy5nZXRDaGlsZE5vZGVzKGMpOwpmb3IodmFyIGI9MDtiPGMubGVuZ3RoO2IrKyl7Zm9yKHZhciBmPWNbYl0uZ2V0QXR0cmlidXRlKCJhcyIpLGc9Y1tiXS5maXJzdENoaWxkO251bGwhPWcmJjEhPWcubm9kZVR5cGU7KWc9Zy5uZXh0U2libGluZztudWxsIT1nJiYoZC50ZW1wbGF0ZXNbZl09YS5kZWNvZGVDZWxsKGcpKX19O3JldHVybiBhfSgpKTsvKgogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCBodHRwOi8vd3d3LmdudS5vcmcvY29weWxlZnQvbGVzc2VyLmh0bWwKIEBhdXRob3IgIEphbiBPZHZhcmtvLCBodHRwOi8vb2R2YXJrby5jegogQGNyZWF0ZWQgMjAwOC0wNi0xNQogQHVwZGF0ZWQgMjAxMi0wMS0xOQogQGxpbmsgICAgaHR0cDovL2pzY29sb3IuY29tCiovCnZhciBteEpTQ29sb3I9e2JpbmRDbGFzczoiY29sb3IiLGJpbmRpbmc6ITAscHJlbG9hZGluZzohMCxpbnN0YWxsOmZ1bmN0aW9uKCl7fSxpbml0OmZ1bmN0aW9uKCl7bXhKU0NvbG9yLnByZWxvYWRpbmcmJm14SlNDb2xvci5wcmVsb2FkKCl9LGdldERpcjpmdW5jdGlvbigpe3JldHVybiBJTUFHRV9QQVRIKyIvIn0sZGV0ZWN0RGlyOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPWxvY2F0aW9uLmhyZWYsYj1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYmFzZSIpLGM9MDtjPGIubGVuZ3RoO2MrPTEpYltjXS5ocmVmJiYoYT1iW2NdLmhyZWYpO2I9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInNjcmlwdCIpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKz0xKWlmKGJbY10uc3JjJiYvKF58XC8panNjb2xvclwuanMoWz8jXS4qKT8kL2kudGVzdChiW2NdLnNyYykpcmV0dXJuIGE9KG5ldyBteEpTQ29sb3IuVVJJKGJbY10uc3JjKSkudG9BYnNvbHV0ZShhKSxhLnBhdGg9YS5wYXRoLnJlcGxhY2UoL1teXC9dKyQvLAoiIiksYS5xdWVyeT1udWxsLGEuZnJhZ21lbnQ9bnVsbCxhLnRvU3RyaW5nKCk7cmV0dXJuITF9LHByZWxvYWQ6ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gbXhKU0NvbG9yLmltZ1JlcXVpcmUpbXhKU0NvbG9yLmltZ1JlcXVpcmUuaGFzT3duUHJvcGVydHkoYSkmJm14SlNDb2xvci5sb2FkSW1hZ2UoYSl9LGltYWdlczp7cGFkOlsxODEsMTAxXSxzbGQ6WzE2LDEwMV0sY3Jvc3M6WzE1LDE1XSxhcnJvdzpbNywxMV19LGltZ1JlcXVpcmU6e30saW1nTG9hZGVkOnt9LHJlcXVpcmVJbWFnZTpmdW5jdGlvbihhKXtteEpTQ29sb3IuaW1nUmVxdWlyZVthXT0hMH0sbG9hZEltYWdlOmZ1bmN0aW9uKGEpe214SlNDb2xvci5pbWdMb2FkZWRbYV18fChteEpTQ29sb3IuaW1nTG9hZGVkW2FdPW5ldyBJbWFnZSxteEpTQ29sb3IuaW1nTG9hZGVkW2FdLnNyYz1teEpTQ29sb3IuZ2V0RGlyKCkrYSl9LGZldGNoRWxlbWVudDpmdW5jdGlvbihhKXtyZXR1cm4ic3RyaW5nIj09PXR5cGVvZiBhP2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpOgphfSxhZGRFdmVudDpmdW5jdGlvbihhLGIsYyl7YS5hZGRFdmVudExpc3RlbmVyP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITEpOmEuYXR0YWNoRXZlbnQmJmEuYXR0YWNoRXZlbnQoIm9uIitiLGMpfSxmaXJlRXZlbnQ6ZnVuY3Rpb24oYSxiKXtpZihhKWlmKGRvY3VtZW50LmNyZWF0ZUV2ZW50KXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFdmVudCgiSFRNTEV2ZW50cyIpO2MuaW5pdEV2ZW50KGIsITAsITApO2EuZGlzcGF0Y2hFdmVudChjKX1lbHNlIGlmKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KWM9ZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSxhLmZpcmVFdmVudCgib24iK2IsYyk7ZWxzZSBpZihhWyJvbiIrYl0pYVsib24iK2JdKCl9LGdldEVsZW1lbnRQb3M6ZnVuY3Rpb24oYSl7dmFyIGI9YSxjPTAsZD0wO2lmKGIub2Zmc2V0UGFyZW50KXtkbyBjKz1iLm9mZnNldExlZnQsZCs9Yi5vZmZzZXRUb3A7d2hpbGUoYj1iLm9mZnNldFBhcmVudCl9Zm9yKDsoYT1hLnBhcmVudE5vZGUpJiYKIkJPRFkiIT09YS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpOyljLT1hLnNjcm9sbExlZnQsZC09YS5zY3JvbGxUb3A7cmV0dXJuW2MsZF19LGdldEVsZW1lbnRTaXplOmZ1bmN0aW9uKGEpe3JldHVyblthLm9mZnNldFdpZHRoLGEub2Zmc2V0SGVpZ2h0XX0sZ2V0UmVsTW91c2VQb3M6ZnVuY3Rpb24oYSl7dmFyIGI9MCxjPTA7YXx8KGE9d2luZG93LmV2ZW50KTsibnVtYmVyIj09PXR5cGVvZiBhLm9mZnNldFg/KGI9YS5vZmZzZXRYLGM9YS5vZmZzZXRZKToibnVtYmVyIj09PXR5cGVvZiBhLmxheWVyWCYmKGI9YS5sYXllclgsYz1hLmxheWVyWSk7cmV0dXJue3g6Yix5OmN9fSxnZXRWaWV3UG9zOmZ1bmN0aW9uKCl7cmV0dXJuIm51bWJlciI9PT10eXBlb2Ygd2luZG93LnBhZ2VZT2Zmc2V0P1t3aW5kb3cucGFnZVhPZmZzZXQsd2luZG93LnBhZ2VZT2Zmc2V0XTpkb2N1bWVudC5ib2R5JiYoZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0fHxkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCk/W2RvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCwKZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BdOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKT9bZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcF06WzAsMF19LGdldFZpZXdTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIm51bWJlciI9PT10eXBlb2Ygd2luZG93LmlubmVyV2lkdGg/W3dpbmRvdy5pbm5lcldpZHRoLHdpbmRvdy5pbm5lckhlaWdodF06ZG9jdW1lbnQuYm9keSYmKGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KT9bZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodF06ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KT8KW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XTpbMCwwXX0sVVJJOmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7Zm9yKHZhciBiPSIiO2E7KWlmKCIuLi8iPT09YS5zdWJzdHIoMCwzKXx8Ii4vIj09PWEuc3Vic3RyKDAsMikpYT1hLnJlcGxhY2UoL15cLisvLCIiKS5zdWJzdHIoMSk7ZWxzZSBpZigiLy4vIj09PWEuc3Vic3RyKDAsMyl8fCIvLiI9PT1hKWE9Ii8iK2Euc3Vic3RyKDMpO2Vsc2UgaWYoIi8uLi8iPT09YS5zdWJzdHIoMCw0KXx8Ii8uLiI9PT1hKWE9Ii8iK2Euc3Vic3RyKDQpLGI9Yi5yZXBsYWNlKC9cLz9bXlwvXSokLywiIik7ZWxzZSBpZigiLiI9PT1hfHwiLi4iPT09YSlhPSIiO2Vsc2V7dmFyIGM9YS5tYXRjaCgvXlwvP1teXC9dKi8pWzBdO2E9YS5zdWJzdHIoYy5sZW5ndGgpO2IrPWN9cmV0dXJuIGJ9dGhpcy5hdXRob3JpdHk9dGhpcy5zY2hlbWU9bnVsbDt0aGlzLnBhdGg9CiIiO3RoaXMuZnJhZ21lbnQ9dGhpcy5xdWVyeT1udWxsO3RoaXMucGFyc2U9ZnVuY3Rpb24oYSl7YT1hLm1hdGNoKC9eKChbQS1aYS16XVswLTlBLVphLXorLi1dKikoOikpPygoXC9cLykoW15cLz8jXSopKT8oW14/I10qKSgoXD8pKFteI10qKSk/KCgjKSguKikpPy8pO3RoaXMuc2NoZW1lPWFbM10/YVsyXTpudWxsO3RoaXMuYXV0aG9yaXR5PWFbNV0/YVs2XTpudWxsO3RoaXMucGF0aD1hWzddO3RoaXMucXVlcnk9YVs5XT9hWzEwXTpudWxsO3RoaXMuZnJhZ21lbnQ9YVsxMl0/YVsxM106bnVsbDtyZXR1cm4gdGhpc307dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPSIiO251bGwhPT10aGlzLnNjaGVtZSYmKGE9YSt0aGlzLnNjaGVtZSsiOiIpO251bGwhPT10aGlzLmF1dGhvcml0eSYmKGE9YSsiLy8iK3RoaXMuYXV0aG9yaXR5KTtudWxsIT09dGhpcy5wYXRoJiYoYSs9dGhpcy5wYXRoKTtudWxsIT09dGhpcy5xdWVyeSYmKGE9YSsiPyIrdGhpcy5xdWVyeSk7bnVsbCE9PQp0aGlzLmZyYWdtZW50JiYoYT1hKyIjIit0aGlzLmZyYWdtZW50KTtyZXR1cm4gYX07dGhpcy50b0Fic29sdXRlPWZ1bmN0aW9uKGEpe2E9bmV3IG14SlNDb2xvci5VUkkoYSk7dmFyIGM9bmV3IG14SlNDb2xvci5VUkk7aWYobnVsbD09PWEuc2NoZW1lKXJldHVybiExO251bGwhPT10aGlzLnNjaGVtZSYmdGhpcy5zY2hlbWUudG9Mb3dlckNhc2UoKT09PWEuc2NoZW1lLnRvTG93ZXJDYXNlKCkmJih0aGlzLnNjaGVtZT1udWxsKTtudWxsIT09dGhpcy5zY2hlbWU/KGMuc2NoZW1lPXRoaXMuc2NoZW1lLGMuYXV0aG9yaXR5PXRoaXMuYXV0aG9yaXR5LGMucGF0aD1iKHRoaXMucGF0aCksYy5xdWVyeT10aGlzLnF1ZXJ5KToobnVsbCE9PXRoaXMuYXV0aG9yaXR5PyhjLmF1dGhvcml0eT10aGlzLmF1dGhvcml0eSxjLnBhdGg9Yih0aGlzLnBhdGgpLGMucXVlcnk9dGhpcy5xdWVyeSk6KCIiPT09dGhpcy5wYXRoPyhjLnBhdGg9YS5wYXRoLGMucXVlcnk9bnVsbCE9PXRoaXMucXVlcnk/dGhpcy5xdWVyeToKYS5xdWVyeSk6KCIvIj09PXRoaXMucGF0aC5zdWJzdHIoMCwxKT9jLnBhdGg9Yih0aGlzLnBhdGgpOihjLnBhdGg9bnVsbCE9PWEuYXV0aG9yaXR5JiYiIj09PWEucGF0aD8iLyIrdGhpcy5wYXRoOmEucGF0aC5yZXBsYWNlKC9bXlwvXSskLywiIikrdGhpcy5wYXRoLGMucGF0aD1iKGMucGF0aCkpLGMucXVlcnk9dGhpcy5xdWVyeSksYy5hdXRob3JpdHk9YS5hdXRob3JpdHkpLGMuc2NoZW1lPWEuc2NoZW1lKTtjLmZyYWdtZW50PXRoaXMuZnJhZ21lbnQ7cmV0dXJuIGN9O2EmJnRoaXMucGFyc2UoYSl9LGNvbG9yOmZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyl7aWYobnVsbD09PWEpcmV0dXJuW2MsYyxjXTt2YXIgZD1NYXRoLmZsb29yKGEpLGU9YyooMS1iKTthPWMqKDEtYiooZCUyP2EtZDoxLShhLWQpKSk7c3dpdGNoKGQpe2Nhc2UgNjpjYXNlIDA6cmV0dXJuW2MsYSxlXTtjYXNlIDE6cmV0dXJuW2EsYyxlXTtjYXNlIDI6cmV0dXJuW2UsYyxhXTtjYXNlIDM6cmV0dXJuW2UsCmEsY107Y2FzZSA0OnJldHVyblthLGUsY107Y2FzZSA1OnJldHVybltjLGUsYV19fWZ1bmN0aW9uIGQoYixjKXtpZighbXhKU0NvbG9yLnBpY2tlcil7bXhKU0NvbG9yLnBpY2tlcj17Ym94OmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGJveEI6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IikscGFkOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHBhZEI6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IikscGFkTTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxzbGQ6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iiksc2xkQjpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxzbGRNOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGJ0bjpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxidG5TOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKSxidG5UOmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIucGlja2VyQ2xvc2VUZXh0KX07Zm9yKHZhciBkPQowO2Q8bXhKU0NvbG9yLmltYWdlcy5zbGRbMV07ZCs9NCl7dmFyIGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ay5zdHlsZS5oZWlnaHQ9IjRweCI7ay5zdHlsZS5mb250U2l6ZT0iMXB4IjtrLnN0eWxlLmxpbmVIZWlnaHQ9IjAiO214SlNDb2xvci5waWNrZXIuc2xkLmFwcGVuZENoaWxkKGspfW14SlNDb2xvci5waWNrZXIuc2xkQi5hcHBlbmRDaGlsZChteEpTQ29sb3IucGlja2VyLnNsZCk7bXhKU0NvbG9yLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5zbGRCKTtteEpTQ29sb3IucGlja2VyLmJveC5hcHBlbmRDaGlsZChteEpTQ29sb3IucGlja2VyLnNsZE0pO214SlNDb2xvci5waWNrZXIucGFkQi5hcHBlbmRDaGlsZChteEpTQ29sb3IucGlja2VyLnBhZCk7bXhKU0NvbG9yLnBpY2tlci5ib3guYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5wYWRCKTtteEpTQ29sb3IucGlja2VyLmJveC5hcHBlbmRDaGlsZChteEpTQ29sb3IucGlja2VyLnBhZE0pOwpteEpTQ29sb3IucGlja2VyLmJ0blMuYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5idG5UKTtteEpTQ29sb3IucGlja2VyLmJ0bi5hcHBlbmRDaGlsZChteEpTQ29sb3IucGlja2VyLmJ0blMpO214SlNDb2xvci5waWNrZXIuYm94LmFwcGVuZENoaWxkKG14SlNDb2xvci5waWNrZXIuYnRuKTtteEpTQ29sb3IucGlja2VyLmJveEIuYXBwZW5kQ2hpbGQobXhKU0NvbG9yLnBpY2tlci5ib3gpfXZhciBsPW14SlNDb2xvci5waWNrZXI7bC5ib3gub25tb3VzZXVwPWwuYm94Lm9ubW91c2VvdXQ9ZnVuY3Rpb24oKXtteENsaWVudC5JU19UT1VDSHx8YS5mb2N1cygpfTtsLmJveC5vbm1vdXNlZG93bj1mdW5jdGlvbigpe307bC5ib3gub25tb3VzZW1vdmU9ZnVuY3Rpb24oYSl7aWYoeXx8Qil5JiZtKGEpLEImJm4oYSksZG9jdW1lbnQuc2VsZWN0aW9uP2RvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpOndpbmRvdy5nZXRTZWxlY3Rpb24mJndpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKSwKcCgpfTtsLnBhZE0ub25tb3VzZXVwPWwucGFkTS5vbm1vdXNlb3V0PWZ1bmN0aW9uKCl7eSYmKHk9ITEsbXhKU0NvbG9yLmZpcmVFdmVudCh1LCJjaGFuZ2UiKSl9O2wucGFkTS5vbm1vdXNlZG93bj1mdW5jdGlvbihhKXtzd2l0Y2godCl7Y2FzZSAwOjA9PT1yLmhzdlsyXSYmci5mcm9tSFNWKG51bGwsbnVsbCwxKTticmVhaztjYXNlIDE6MD09PXIuaHN2WzFdJiZyLmZyb21IU1YobnVsbCwxLG51bGwpfXk9ITA7bShhKTtwKCl9O2wuc2xkTS5vbm1vdXNldXA9bC5zbGRNLm9ubW91c2VvdXQ9ZnVuY3Rpb24oKXtCJiYoQj0hMSxteEpTQ29sb3IuZmlyZUV2ZW50KHUsImNoYW5nZSIpKX07bC5zbGRNLm9ubW91c2Vkb3duPWZ1bmN0aW9uKGEpe0I9ITA7bihhKTtwKCl9O2Q9ZShyKTtsLmJveC5zdHlsZS53aWR0aD1kWzBdKyJweCI7bC5ib3guc3R5bGUuaGVpZ2h0PWRbMV0rInB4IjtsLmJveEIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtsLmJveEIuc3R5bGUuY2xlYXI9ImJvdGgiOwpsLmJveEIuc3R5bGUubGVmdD1iKyJweCI7bC5ib3hCLnN0eWxlLnRvcD1jKyJweCI7bC5ib3hCLnN0eWxlLnpJbmRleD1yLnBpY2tlclpJbmRleDtsLmJveEIuc3R5bGUuYm9yZGVyPXIucGlja2VyQm9yZGVyKyJweCBzb2xpZCI7bC5ib3hCLnN0eWxlLmJvcmRlckNvbG9yPXIucGlja2VyQm9yZGVyQ29sb3I7bC5ib3hCLnN0eWxlLmJhY2tncm91bmQ9ci5waWNrZXJGYWNlQ29sb3I7bC5wYWQuc3R5bGUud2lkdGg9bXhKU0NvbG9yLmltYWdlcy5wYWRbMF0rInB4IjtsLnBhZC5zdHlsZS5oZWlnaHQ9bXhKU0NvbG9yLmltYWdlcy5wYWRbMV0rInB4IjtsLnBhZEIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtsLnBhZEIuc3R5bGUubGVmdD1yLnBpY2tlckZhY2UrInB4IjtsLnBhZEIuc3R5bGUudG9wPXIucGlja2VyRmFjZSsicHgiO2wucGFkQi5zdHlsZS5ib3JkZXI9ci5waWNrZXJJbnNldCsicHggc29saWQiO2wucGFkQi5zdHlsZS5ib3JkZXJDb2xvcj1yLnBpY2tlckluc2V0Q29sb3I7CmwucGFkTS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2wucGFkTS5zdHlsZS5sZWZ0PSIwIjtsLnBhZE0uc3R5bGUudG9wPSIwIjtsLnBhZE0uc3R5bGUud2lkdGg9ci5waWNrZXJGYWNlKzIqci5waWNrZXJJbnNldCtteEpTQ29sb3IuaW1hZ2VzLnBhZFswXStteEpTQ29sb3IuaW1hZ2VzLmFycm93WzBdKyJweCI7bC5wYWRNLnN0eWxlLmhlaWdodD1sLmJveC5zdHlsZS5oZWlnaHQ7bC5wYWRNLnN0eWxlLmN1cnNvcj0iY3Jvc3NoYWlyIjtsLnNsZC5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtsLnNsZC5zdHlsZS53aWR0aD1teEpTQ29sb3IuaW1hZ2VzLnNsZFswXSsicHgiO2wuc2xkLnN0eWxlLmhlaWdodD1teEpTQ29sb3IuaW1hZ2VzLnNsZFsxXSsicHgiO2wuc2xkQi5zdHlsZS5kaXNwbGF5PXIuc2xpZGVyPyJibG9jayI6Im5vbmUiO2wuc2xkQi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2wuc2xkQi5zdHlsZS5yaWdodD1yLnBpY2tlckZhY2UrInB4IjtsLnNsZEIuc3R5bGUudG9wPQpyLnBpY2tlckZhY2UrInB4IjtsLnNsZEIuc3R5bGUuYm9yZGVyPXIucGlja2VySW5zZXQrInB4IHNvbGlkIjtsLnNsZEIuc3R5bGUuYm9yZGVyQ29sb3I9ci5waWNrZXJJbnNldENvbG9yO2wuc2xkTS5zdHlsZS5kaXNwbGF5PXIuc2xpZGVyPyJibG9jayI6Im5vbmUiO2wuc2xkTS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2wuc2xkTS5zdHlsZS5yaWdodD0iMCI7bC5zbGRNLnN0eWxlLnRvcD0iMCI7bC5zbGRNLnN0eWxlLndpZHRoPW14SlNDb2xvci5pbWFnZXMuc2xkWzBdK214SlNDb2xvci5pbWFnZXMuYXJyb3dbMF0rci5waWNrZXJGYWNlKzIqci5waWNrZXJJbnNldCsicHgiO2wuc2xkTS5zdHlsZS5oZWlnaHQ9bC5ib3guc3R5bGUuaGVpZ2h0O3RyeXtsLnNsZE0uc3R5bGUuY3Vyc29yPSJwb2ludGVyIn1jYXRjaChGKXtsLnNsZE0uc3R5bGUuY3Vyc29yPSJoYW5kIn1sLmJ0bi5zdHlsZS5kaXNwbGF5PXIucGlja2VyQ2xvc2FibGU/ImJsb2NrIjoibm9uZSI7bC5idG4uc3R5bGUucG9zaXRpb249CiJhYnNvbHV0ZSI7bC5idG4uc3R5bGUubGVmdD1yLnBpY2tlckZhY2UrInB4IjtsLmJ0bi5zdHlsZS5ib3R0b209ci5waWNrZXJGYWNlKyJweCI7bC5idG4uc3R5bGUucGFkZGluZz0iMCAxNXB4IjtsLmJ0bi5zdHlsZS5oZWlnaHQ9IjE4cHgiO2wuYnRuLnN0eWxlLmJvcmRlcj1yLnBpY2tlckluc2V0KyJweCBzb2xpZCI7KGZ1bmN0aW9uKCl7dmFyIGE9ci5waWNrZXJJbnNldENvbG9yLnNwbGl0KC9ccysvKTtsLmJ0bi5zdHlsZS5ib3JkZXJDb2xvcj0yPmEubGVuZ3RoP2FbMF06YVsxXSsiICIrYVswXSsiICIrYVswXSsiICIrYVsxXX0pKCk7bC5idG4uc3R5bGUuY29sb3I9ci5waWNrZXJCdXR0b25Db2xvcjtsLmJ0bi5zdHlsZS5mb250PSIxMnB4IHNhbnMtc2VyaWYiO2wuYnRuLnN0eWxlLnRleHRBbGlnbj0iY2VudGVyIjt0cnl7bC5idG4uc3R5bGUuY3Vyc29yPSJwb2ludGVyIn1jYXRjaChGKXtsLmJ0bi5zdHlsZS5jdXJzb3I9ImhhbmQifWwuYnRuLm9ubW91c2Vkb3duPWZ1bmN0aW9uKCl7ci5oaWRlUGlja2VyKCl9OwpsLmJ0blMuc3R5bGUubGluZUhlaWdodD1sLmJ0bi5zdHlsZS5oZWlnaHQ7c3dpdGNoKHQpe2Nhc2UgMDp2YXIgcT0iaHMucG5nIjticmVhaztjYXNlIDE6cT0iaHYucG5nIn1sLnBhZE0uc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoRHdBUEFLRUJBQUFBQVAvLy8vLy8vLy8vL3lINUJBRUtBQUlBTEFBQUFBQVBBQThBQUFJa2xCOFF4NTNiNG90U1VXY3Z5aXo0LzRBZVFKYm1LWTRwMUhIYXBCbHdQTC91VlJzRkFEcz0pIjtsLnBhZE0uc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IjtsLnNsZE0uc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQndBTEFLRUNBQUFBQVAvLy82ZzhlS2c4ZUNINUJBRUtBQUlBTEFBQUFBQUhBQXNBQUFJVFRJUVljTG5zZ0d4dmlqcnhxZFFxNkRSSkFRQTcpIjtsLnNsZE0uc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IjsKbC5wYWQuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoJyIrbXhKU0NvbG9yLmdldERpcigpK3ErIicpIjtsLnBhZC5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiO2wucGFkLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0iMCAwIjtmKCk7ZygpO214SlNDb2xvci5waWNrZXIub3duZXI9cjtkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYm9keSIpWzBdLmFwcGVuZENoaWxkKGwuYm94Qil9ZnVuY3Rpb24gZShhKXtyZXR1cm5bMiphLnBpY2tlckluc2V0KzIqYS5waWNrZXJGYWNlK214SlNDb2xvci5pbWFnZXMucGFkWzBdKyhhLnNsaWRlcj8yKmEucGlja2VySW5zZXQrMipteEpTQ29sb3IuaW1hZ2VzLmFycm93WzBdK214SlNDb2xvci5pbWFnZXMuc2xkWzBdOjApLGEucGlja2VyQ2xvc2FibGU/NCphLnBpY2tlckluc2V0KzMqYS5waWNrZXJGYWNlK214SlNDb2xvci5pbWFnZXMucGFkWzFdK2EucGlja2VyQnV0dG9uSGVpZ2h0OjIqYS5waWNrZXJJbnNldCsyKgphLnBpY2tlckZhY2UrbXhKU0NvbG9yLmltYWdlcy5wYWRbMV1dfWZ1bmN0aW9uIGYoKXtzd2l0Y2godCl7Y2FzZSAwOnZhciBhPTE7YnJlYWs7Y2FzZSAxOmE9Mn1teEpTQ29sb3IucGlja2VyLnBhZE0uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPXIucGlja2VyRmFjZStyLnBpY2tlckluc2V0K01hdGgucm91bmQoci5oc3ZbMF0vNioobXhKU0NvbG9yLmltYWdlcy5wYWRbMF0tMSkpLU1hdGguZmxvb3IobXhKU0NvbG9yLmltYWdlcy5jcm9zc1swXS8yKSsicHggIisoci5waWNrZXJGYWNlK3IucGlja2VySW5zZXQrTWF0aC5yb3VuZCgoMS1yLmhzdlthXSkqKG14SlNDb2xvci5pbWFnZXMucGFkWzFdLTEpKS1NYXRoLmZsb29yKG14SlNDb2xvci5pbWFnZXMuY3Jvc3NbMV0vMikpKyJweCI7YT1teEpTQ29sb3IucGlja2VyLnNsZC5jaGlsZE5vZGVzO3N3aXRjaCh0KXtjYXNlIDA6Zm9yKHZhciBiPWMoci5oc3ZbMF0sci5oc3ZbMV0sMSksZD0wO2Q8YS5sZW5ndGg7ZCs9MSlhW2RdLnN0eWxlLmJhY2tncm91bmRDb2xvcj0KInJnYigiK2JbMF0qKDEtZC9hLmxlbmd0aCkqMTAwKyIlLCIrYlsxXSooMS1kL2EubGVuZ3RoKSoxMDArIiUsIitiWzJdKigxLWQvYS5sZW5ndGgpKjEwMCsiJSkiO2JyZWFrO2Nhc2UgMTp2YXIgZSxmPVtyLmhzdlsyXSwwLDBdLGQ9TWF0aC5mbG9vcihyLmhzdlswXSksZz1kJTI/ci5oc3ZbMF0tZDoxLShyLmhzdlswXS1kKTtzd2l0Y2goZCl7Y2FzZSA2OmNhc2UgMDpiPVswLDEsMl07YnJlYWs7Y2FzZSAxOmI9WzEsMCwyXTticmVhaztjYXNlIDI6Yj1bMiwwLDFdO2JyZWFrO2Nhc2UgMzpiPVsyLDEsMF07YnJlYWs7Y2FzZSA0OmI9WzEsMiwwXTticmVhaztjYXNlIDU6Yj1bMCwyLDFdfWZvcihkPTA7ZDxhLmxlbmd0aDtkKz0xKWU9MS0xLyhhLmxlbmd0aC0xKSpkLGZbMV09ZlswXSooMS1lKmcpLGZbMl09ZlswXSooMS1lKSxhW2RdLnN0eWxlLmJhY2tncm91bmRDb2xvcj0icmdiKCIrMTAwKmZbYlswXV0rIiUsIisxMDAqZltiWzFdXSsiJSwiKzEwMCpmW2JbMl1dKyIlKSJ9fWZ1bmN0aW9uIGcoKXtzd2l0Y2godCl7Y2FzZSAwOnZhciBhPQoyO2JyZWFrO2Nhc2UgMTphPTF9bXhKU0NvbG9yLnBpY2tlci5zbGRNLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0iMCAiKyhyLnBpY2tlckZhY2Urci5waWNrZXJJbnNldCtNYXRoLnJvdW5kKCgxLXIuaHN2W2FdKSoobXhKU0NvbG9yLmltYWdlcy5zbGRbMV0tMSkpLU1hdGguZmxvb3IobXhKU0NvbG9yLmltYWdlcy5hcnJvd1sxXS8yKSkrInB4In1mdW5jdGlvbiBrKCl7cmV0dXJuIG14SlNDb2xvci5waWNrZXImJm14SlNDb2xvci5waWNrZXIub3duZXI9PT1yfWZ1bmN0aW9uIGwoKXt1IT09YSYmci5pbXBvcnRDb2xvcigpfWZ1bmN0aW9uIG0oYSl7dmFyIGI9bXhKU0NvbG9yLmdldFJlbE1vdXNlUG9zKGEpO2E9Yi54LXIucGlja2VyRmFjZS1yLnBpY2tlckluc2V0O2I9Yi55LXIucGlja2VyRmFjZS1yLnBpY2tlckluc2V0O3N3aXRjaCh0KXtjYXNlIDA6ci5mcm9tSFNWKDYvKG14SlNDb2xvci5pbWFnZXMucGFkWzBdLTEpKmEsMS1iLyhteEpTQ29sb3IuaW1hZ2VzLnBhZFsxXS0KMSksbnVsbCx2KTticmVhaztjYXNlIDE6ci5mcm9tSFNWKDYvKG14SlNDb2xvci5pbWFnZXMucGFkWzBdLTEpKmEsbnVsbCwxLWIvKG14SlNDb2xvci5pbWFnZXMucGFkWzFdLTEpLHYpfX1mdW5jdGlvbiBuKGEpe2E9bXhKU0NvbG9yLmdldFJlbE1vdXNlUG9zKGEpLnktci5waWNrZXJGYWNlLXIucGlja2VySW5zZXQ7c3dpdGNoKHQpe2Nhc2UgMDpyLmZyb21IU1YobnVsbCxudWxsLDEtYS8obXhKU0NvbG9yLmltYWdlcy5zbGRbMV0tMSksQyk7YnJlYWs7Y2FzZSAxOnIuZnJvbUhTVihudWxsLDEtYS8obXhKU0NvbG9yLmltYWdlcy5zbGRbMV0tMSksbnVsbCxDKX19ZnVuY3Rpb24gcCgpe2lmKHIub25JbW1lZGlhdGVDaGFuZ2UpaWYoInN0cmluZyI9PT10eXBlb2Ygci5vbkltbWVkaWF0ZUNoYW5nZSlldmFsKHIub25JbW1lZGlhdGVDaGFuZ2UpO2Vsc2Ugci5vbkltbWVkaWF0ZUNoYW5nZShyKX10aGlzLmFkanVzdD10aGlzLnJlcXVpcmVkPSEwO3RoaXMuaGFzaD0hMTt0aGlzLnNsaWRlcj0KdGhpcy5jYXBzPSEwO3RoaXMuc3R5bGVFbGVtZW50PXRoaXMudmFsdWVFbGVtZW50PWE7dGhpcy5vbkltbWVkaWF0ZUNoYW5nZT1udWxsO3RoaXMuaHN2PVswLDAsMV07dGhpcy5yZ2I9WzEsMSwxXTt0aGlzLnBpY2tlck9uZm9jdXM9ITA7dGhpcy5waWNrZXJNb2RlPSJIU1YiO3RoaXMucGlja2VyUG9zaXRpb249ImJvdHRvbSI7dGhpcy5waWNrZXJTbWFydFBvc2l0aW9uPSEwO3RoaXMucGlja2VyQnV0dG9uSGVpZ2h0PTIwO3RoaXMucGlja2VyQ2xvc2FibGU9ITE7dGhpcy5waWNrZXJDbG9zZVRleHQ9IkNsb3NlIjt0aGlzLnBpY2tlckJ1dHRvbkNvbG9yPSJCdXR0b25UZXh0Ijt0aGlzLnBpY2tlckZhY2U9MDt0aGlzLnBpY2tlckZhY2VDb2xvcj0iVGhyZWVERmFjZSI7dGhpcy5waWNrZXJCb3JkZXI9MTt0aGlzLnBpY2tlckJvcmRlckNvbG9yPSJUaHJlZURIaWdobGlnaHQgVGhyZWVEU2hhZG93IFRocmVlRFNoYWRvdyBUaHJlZURIaWdobGlnaHQiO3RoaXMucGlja2VySW5zZXQ9CjE7dGhpcy5waWNrZXJJbnNldENvbG9yPSJUaHJlZURTaGFkb3cgVGhyZWVESGlnaGxpZ2h0IFRocmVlREhpZ2hsaWdodCBUaHJlZURTaGFkb3ciO3RoaXMucGlja2VyWkluZGV4PTFFNDtmb3IodmFyIHEgaW4gYiliLmhhc093blByb3BlcnR5KHEpJiYodGhpc1txXT1iW3FdKTt0aGlzLmhpZGVQaWNrZXI9ZnVuY3Rpb24oKXtrKCkmJihkZWxldGUgbXhKU0NvbG9yLnBpY2tlci5vd25lcixkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYm9keSIpWzBdLnJlbW92ZUNoaWxkKG14SlNDb2xvci5waWNrZXIuYm94QikpfTt0aGlzLnNob3dQaWNrZXI9ZnVuY3Rpb24oKXtrKCl8fChteEpTQ29sb3IuZ2V0RWxlbWVudFBvcyhhKSxteEpTQ29sb3IuZ2V0RWxlbWVudFNpemUoYSksbXhKU0NvbG9yLmdldFZpZXdQb3MoKSxteEpTQ29sb3IuZ2V0Vmlld1NpemUoKSxlKHRoaXMpLHRoaXMucGlja2VyUG9zaXRpb24udG9Mb3dlckNhc2UoKSxkKDAsMCkpfTt0aGlzLmltcG9ydENvbG9yPQpmdW5jdGlvbigpe3U/dGhpcy5hZGp1c3Q/IXRoaXMucmVxdWlyZWQmJi9eXHMqJC8udGVzdCh1LnZhbHVlKT8odS52YWx1ZT0iIix4LnN0eWxlLmJhY2tncm91bmRJbWFnZT14LmpzY1N0eWxlLmJhY2tncm91bmRJbWFnZSx4LnN0eWxlLmJhY2tncm91bmRDb2xvcj14LmpzY1N0eWxlLmJhY2tncm91bmRDb2xvcix4LnN0eWxlLmNvbG9yPXguanNjU3R5bGUuY29sb3IsdGhpcy5leHBvcnRDb2xvcihBfHopKTp0aGlzLmZyb21TdHJpbmcodS52YWx1ZSl8fHRoaXMuZXhwb3J0Q29sb3IoKTp0aGlzLmZyb21TdHJpbmcodS52YWx1ZSxBKXx8KHguc3R5bGUuYmFja2dyb3VuZEltYWdlPXguanNjU3R5bGUuYmFja2dyb3VuZEltYWdlLHguc3R5bGUuYmFja2dyb3VuZENvbG9yPXguanNjU3R5bGUuYmFja2dyb3VuZENvbG9yLHguc3R5bGUuY29sb3I9eC5qc2NTdHlsZS5jb2xvcix0aGlzLmV4cG9ydENvbG9yKEF8eikpOnRoaXMuZXhwb3J0Q29sb3IoKX07dGhpcy5leHBvcnRDb2xvcj1mdW5jdGlvbihhKXtpZighKGEmCkEpJiZ1KXt2YXIgYj10aGlzLnRvU3RyaW5nKCk7dGhpcy5jYXBzJiYoYj1iLnRvVXBwZXJDYXNlKCkpO3RoaXMuaGFzaCYmKGI9IiMiK2IpO3UudmFsdWU9Yn1hJnp8fCF4fHwoeC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9Im5vbmUiLHguc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjIit0aGlzLnRvU3RyaW5nKCkseC5zdHlsZS5jb2xvcj0uNT4uMjEzKnRoaXMucmdiWzBdKy43MTUqdGhpcy5yZ2JbMV0rLjA3Mip0aGlzLnJnYlsyXT8iI0ZGRiI6IiMwMDAiKTthJkN8fCFrKCl8fGYoKTthJnZ8fCFrKCl8fGcoKX07dGhpcy5mcm9tSFNWPWZ1bmN0aW9uKGEsYixkLGUpezA+YSYmKGE9MCk7NjxhJiYoYT02KTswPmImJihiPTApOzE8YiYmKGI9MSk7MD5kJiYoZD0wKTsxPGQmJihkPTEpO3RoaXMucmdiPWMobnVsbD09PWE/dGhpcy5oc3ZbMF06dGhpcy5oc3ZbMF09YSxudWxsPT09Yj90aGlzLmhzdlsxXTp0aGlzLmhzdlsxXT1iLG51bGw9PT1kP3RoaXMuaHN2WzJdOnRoaXMuaHN2WzJdPQpkKTt0aGlzLmV4cG9ydENvbG9yKGUpfTt0aGlzLmZyb21SR0I9ZnVuY3Rpb24oYSxiLGMsZCl7MD5hJiYoYT0wKTsxPGEmJihhPTEpOzA+YiYmKGI9MCk7MTxiJiYoYj0xKTswPmMmJihjPTApOzE8YyYmKGM9MSk7YT1udWxsPT09YT90aGlzLnJnYlswXTp0aGlzLnJnYlswXT1hO2I9bnVsbD09PWI/dGhpcy5yZ2JbMV06dGhpcy5yZ2JbMV09Yjt2YXIgZT1udWxsPT09Yz90aGlzLnJnYlsyXTp0aGlzLnJnYlsyXT1jLGY9TWF0aC5taW4oTWF0aC5taW4oYSxiKSxlKTtjPU1hdGgubWF4KE1hdGgubWF4KGEsYiksZSk7dmFyIGc9Yy1mOzA9PT1nP2E9W251bGwsMCxjXTooYT1hPT09Zj8zKyhlLWIpL2c6Yj09PWY/NSsoYS1lKS9nOjErKGItYSkvZyxhPVs2PT09YT8wOmEsZy9jLGNdKTtudWxsIT09YVswXSYmKHRoaXMuaHN2WzBdPWFbMF0pOzAhPT1hWzJdJiYodGhpcy5oc3ZbMV09YVsxXSk7dGhpcy5oc3ZbMl09YVsyXTt0aGlzLmV4cG9ydENvbG9yKGQpfTt0aGlzLmZyb21TdHJpbmc9CmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5tYXRjaCgvXlxXKihbMC05QS1GXXszfShbMC05QS1GXXszfSk/KVxXKiQvaSk7cmV0dXJuIGM/KDY9PT1jWzFdLmxlbmd0aD90aGlzLmZyb21SR0IocGFyc2VJbnQoY1sxXS5zdWJzdHIoMCwyKSwxNikvMjU1LHBhcnNlSW50KGNbMV0uc3Vic3RyKDIsMiksMTYpLzI1NSxwYXJzZUludChjWzFdLnN1YnN0cig0LDIpLDE2KS8yNTUsYik6dGhpcy5mcm9tUkdCKHBhcnNlSW50KGNbMV0uY2hhckF0KDApK2NbMV0uY2hhckF0KDApLDE2KS8yNTUscGFyc2VJbnQoY1sxXS5jaGFyQXQoMSkrY1sxXS5jaGFyQXQoMSksMTYpLzI1NSxwYXJzZUludChjWzFdLmNoYXJBdCgyKStjWzFdLmNoYXJBdCgyKSwxNikvMjU1LGIpLCEwKTohMX07dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybigyNTZ8TWF0aC5yb3VuZCgyNTUqdGhpcy5yZ2JbMF0pKS50b1N0cmluZygxNikuc3Vic3RyKDEpKygyNTZ8TWF0aC5yb3VuZCgyNTUqdGhpcy5yZ2JbMV0pKS50b1N0cmluZygxNikuc3Vic3RyKDEpKwooMjU2fE1hdGgucm91bmQoMjU1KnRoaXMucmdiWzJdKSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKX07dmFyIHI9dGhpcyx0PSJodnMiPT09dGhpcy5waWNrZXJNb2RlLnRvTG93ZXJDYXNlKCk/MTowLHU9bXhKU0NvbG9yLmZldGNoRWxlbWVudCh0aGlzLnZhbHVlRWxlbWVudCkseD1teEpTQ29sb3IuZmV0Y2hFbGVtZW50KHRoaXMuc3R5bGVFbGVtZW50KSx5PSExLEI9ITEsQT0xLHo9MixDPTQsdj04O3UmJihxPWZ1bmN0aW9uKCl7ci5mcm9tU3RyaW5nKHUudmFsdWUsQSk7cCgpfSxteEpTQ29sb3IuYWRkRXZlbnQodSwia2V5dXAiLHEpLG14SlNDb2xvci5hZGRFdmVudCh1LCJpbnB1dCIscSksbXhKU0NvbG9yLmFkZEV2ZW50KHUsImJsdXIiLGwpLHUuc2V0QXR0cmlidXRlKCJhdXRvY29tcGxldGUiLCJvZmYiKSk7eCYmKHguanNjU3R5bGU9e2JhY2tncm91bmRJbWFnZTp4LnN0eWxlLmJhY2tncm91bmRJbWFnZSxiYWNrZ3JvdW5kQ29sb3I6eC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IsCmNvbG9yOnguc3R5bGUuY29sb3J9KTtzd2l0Y2godCl7Y2FzZSAwOm14SlNDb2xvci5yZXF1aXJlSW1hZ2UoImhzLnBuZyIpO2JyZWFrO2Nhc2UgMTpteEpTQ29sb3IucmVxdWlyZUltYWdlKCJodi5wbmciKX10aGlzLmltcG9ydENvbG9yKCl9fTtteEpTQ29sb3IuaW5zdGFsbCgpOwpFZGl0b3I9ZnVuY3Rpb24oYSxjLGYsZCxrKXtteEV2ZW50U291cmNlLmNhbGwodGhpcyk7dGhpcy5jaHJvbWVsZXNzPW51bGwhPWE/YTp0aGlzLmNocm9tZWxlc3M7dGhpcy5pbml0U3RlbmNpbFJlZ2lzdHJ5KCk7dGhpcy5ncmFwaD1kfHx0aGlzLmNyZWF0ZUdyYXBoKGMsZik7dGhpcy5lZGl0YWJsZT1udWxsIT1rP2s6IWE7dGhpcy51bmRvTWFuYWdlcj10aGlzLmNyZWF0ZVVuZG9NYW5hZ2VyKCk7dGhpcy5zdGF0dXM9IiI7dGhpcy5nZXRPckNyZWF0ZUZpbGVuYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsZW5hbWV8fG14UmVzb3VyY2VzLmdldCgiZHJhd2luZyIsW0VkaXRvci5wYWdlQ291bnRlcl0pKyIueG1sIn07dGhpcy5nZXRGaWxlbmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbGVuYW1lfTt0aGlzLnNldFN0YXR1cz1mdW5jdGlvbihhKXt0aGlzLnN0YXR1cz1hO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzdGF0dXNDaGFuZ2VkIikpfTt0aGlzLmdldFN0YXR1cz0KZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0dXN9O3RoaXMuZ3JhcGhDaGFuZ2VMaXN0ZW5lcj1mdW5jdGlvbihhLGQpe3ZhciBiPW51bGwhPWQ/ZC5nZXRQcm9wZXJ0eSgiZWRpdCIpOm51bGw7bnVsbCE9YiYmYi5pZ25vcmVFZGl0fHx0aGlzLnNldE1vZGlmaWVkKCEwKX07dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaENoYW5nZUxpc3RlbmVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pKTt0aGlzLmdyYXBoLnJlc2V0Vmlld09uUm9vdENoYW5nZT0hMTt0aGlzLmluaXQoKX07RWRpdG9yLnBhZ2VDb3VudGVyPTA7CihmdW5jdGlvbigpe3RyeXtmb3IodmFyIGE9d2luZG93O251bGwhPWEub3BlbmVyJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBhLm9wZW5lci5FZGl0b3ImJiFpc05hTihhLm9wZW5lci5FZGl0b3IucGFnZUNvdW50ZXIpJiZhLm9wZW5lciE9YTspYT1hLm9wZW5lcjtudWxsIT1hJiYoYS5FZGl0b3IucGFnZUNvdW50ZXIrKyxFZGl0b3IucGFnZUNvdW50ZXI9YS5FZGl0b3IucGFnZUNvdW50ZXIpfWNhdGNoKGMpe319KSgpO0VkaXRvci51c2VMb2NhbFN0b3JhZ2U9InVuZGVmaW5lZCIhPXR5cGVvZiBTdG9yYWdlJiZteENsaWVudC5JU19JT1M7CkVkaXRvci5tb3ZlSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnZDJsa2RHZzlJakk0Y0hnaUlHaGxhV2RvZEQwaU1qaHdlQ0krUEdjK1BDOW5QanhuUGp4blBqeG5Qanh3WVhSb0lIUnlZVzV6Wm05eWJUMGlkSEpoYm5Oc1lYUmxLREl1TkN3eUxqUXBjMk5oYkdVb01DNDRLWEp2ZEdGMFpTZzBOU3d4TWl3eE1pa2lJSE4wY205clpUMGlJekk1WWpabU1pSWdabWxzYkQwaUl6STVZalptTWlJZ1pEMGlUVEUxTEROc01pNHpMREl1TTJ3dE1pNDRPU3d5TGpnM2JERXVORElzTVM0ME1rd3hPQzQzTERZdU4wd3lNU3c1VmpOSU1UVjZJRTB6TERsc01pNHpMVEl1TTJ3eUxqZzNMREl1T0Rsc01TNDBNaTB4TGpReVREWXVOeXcxTGpOTU9Td3pTRE5XT1hvZ1RUa3NNakVnYkMweUxqTXRNaTR6YkRJdU9Ea3RNaTQ0TjJ3dE1TNDBNaTB4TGpReVREVXVNeXd4Tnk0elRETXNNVFYyTmtnNWVpQk5NakVzTVRWc0xUSXVNeXd5TGpOc0xUSXVPRGN0TWk0NE9Xd3RNUzQwTWl3eExqUXliREl1T0Rrc01pNDROMHd4TlN3eU1XZzJWakUxZWlJdlBqd3ZaejQ4TDJjK1BDOW5Qand2YzNablBnbz0iOklNQUdFX1BBVEgrCiIvbW92ZS5wbmciO0VkaXRvci5yb3dNb3ZlSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFjQUFBQUVCQU1BQUFDdzZEaE9BQUFBR0ZCTVZFVXpNelAvLy85dGJXMVFVRkNLaW9wQlFVRjhmSHhmWDEvSVhsbVhBQUFBRkVsRVFWUUltV05nTlZkellCQVVGQlJnZ0xNQUV6WUJ5MjlrRVBnQUFBQUFTVVZPUks1Q1lJST0iOklNQUdFX1BBVEgrIi90aHVtYl9ob3J6LnBuZyI7CkVkaXRvci5oZWxwSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCbWFXeHNQU0p1YjI1bElpQmtQU0pOTUNBd2FESTBkakkwU0RCNklpOCtQSEJoZEdnZ1pEMGlUVEV4SURFNGFESjJMVEpvTFRKMk1ucHRNUzB4TmtNMkxqUTRJRElnTWlBMkxqUTRJRElnTVRKek5DNDBPQ0F4TUNBeE1DQXhNQ0F4TUMwMExqUTRJREV3TFRFd1V6RTNMalV5SURJZ01USWdNbnB0TUNBeE9HTXROQzQwTVNBd0xUZ3RNeTQxT1MwNExUaHpNeTQxT1MwNElEZ3RPQ0E0SURNdU5Ua2dPQ0E0TFRNdU5Ua2dPQzA0SURoNmJUQXRNVFJqTFRJdU1qRWdNQzAwSURFdU56a3ROQ0EwYURKak1DMHhMakV1T1MweUlESXRNbk15SUM0NUlESWdNbU13SURJdE15QXhMamMxTFRNZ05XZ3lZekF0TWk0eU5TQXpMVEl1TlNBekxUVWdNQzB5TGpJeExURXVOemt0TkMwMExUUjZJaTgrUEM5emRtYysiOklNQUdFX1BBVEgrCiIvaGVscC5wbmciOwpFZGl0b3IuY2hlY2ttYXJrSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhGUUFWQU1RZkFHeHNiSHg4ZklxS2lvYUdodmIyOW5KeWN2cjYrc0RBd0pxYW1sdGJXNU9UaytucDZZR0JnZVRrNUx5OHZKaVltUDM5L2ZMeThxV2xwYTZ1cnNqSXlPTGk0dmo0K04vZjMrM3Q3ZlQwOUxDd3NIWjJkdWJtNXI2K3ZtWm1adi8vL3lIL0MxaE5VQ0JFWVhSaFdFMVFQRDk0Y0dGamEyVjBJR0psWjJsdVBTTHZ1NzhpSUdsa1BTSlhOVTB3VFhCRFpXaHBTSHB5WlZONlRsUmplbXRqT1dRaVB6NGdQSGc2ZUcxd2JXVjBZU0I0Yld4dWN6cDRQU0poWkc5aVpUcHVjenB0WlhSaEx5SWdlRHA0YlhCMGF6MGlRV1J2WW1VZ1dFMVFJRU52Y21VZ05TNHdMV013TmpBZ05qRXVNVE0wTnpjM0xDQXlNREV3THpBeUx6RXlMVEUzT2pNeU9qQXdJQ0FnSUNBZ0lDQWlQaUE4Y21SbU9sSkVSaUI0Yld4dWN6cHlaR1k5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZNREl2TWpJdGNtUm1MWE41Ym5SaGVDMXVjeU1pUGlBOGNtUm1Pa1JsYzJOeWFYQjBhVzl1SUhKa1pqcGhZbTkxZEQwaUlpQjRiV3h1Y3pwNGJYQTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzhpSUhodGJHNXpPbmh0Y0UxTlBTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZiVzB2SWlCNGJXeHVjenB6ZEZKbFpqMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMM05VZVhCbEwxSmxjMjkxY21ObFVtVm1JeUlnZUcxd09rTnlaV0YwYjNKVWIyOXNQU0pCWkc5aVpTQlFhRzkwYjNOb2IzQWdRMU0xSUZkcGJtUnZkM01pSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2T0VZNE5UWkVSVFE1UVVGQk1URkZNVUU1TVRWRE9UTTVNVVpHTVRFM00wUWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZPRVk0TlRaRVJUVTVRVUZCTVRGRk1VRTVNVFZET1RNNU1VWkdNVEUzTTBRaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEbzRSamcxTmtSRk1qbEJRVUV4TVVVeFFUa3hOVU01TXpreFJrWXhNVGN6UkNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvNFJqZzFOa1JGTXpsQlFVRXhNVVV4UVRreE5VTTVNemt4UmtZeE1UY3pSQ0l2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUGdILy92MzgrL3I1K1BmMjlmVHo4dkh3Nys3dDdPdnE2ZWpuNXVYazQrTGg0Ti9lM2R6YjJ0blkxOWJWMU5QUzBkRFB6czNNeThySnlNZkd4Y1REd3NIQXY3Njl2THU2dWJpM3RyVzBzN0t4c0srdXJheXJxcW1vcDZhbHBLT2lvYUNmbnAyY201cVptSmVXbFpTVGtwR1FqNDZOakl1S2lZaUhob1dFZzRLQmdIOStmWHg3ZW5sNGQzWjFkSE55Y1hCdmJtMXNhMnBwYUdkbVpXUmpZbUZnWDE1ZFhGdGFXVmhYVmxWVVUxSlJVRTlPVFV4TFNrbElSMFpGUkVOQ1FVQS9QajA4T3pvNU9EYzJOVFF6TWpFd0x5NHRMQ3NxS1NnbkppVWtJeUloSUI4ZUhSd2JHaGtZRnhZVkZCTVNFUkFQRGcwTUN3b0pDQWNHQlFRREFnRUFBQ0g1QkFFQUFCOEFMQUFBQUFBVkFCVUFBQVZJNENlT1pHbWVhS3F1Ykt0eWxrdFNnQ09MUnlMZDMrUUpFSm5oNFZIY01vT2ZZUVhRTEJjQkQ0UEE2bmdHbElJbkVIRWhQT0FOUmthSUZocThTdUhDRTFIYjhMaDhMZ3NCQURzPSI6SU1BR0VfUEFUSCsKIi9jaGVja21hcmsuZ2lmIjtFZGl0b3IubWF4aW1pemVJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCVUFBQUFWQkFNQUFBQmJPYmlsQUFBQUVsQk1WRVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnS3htaUFBQUFCWFJTVGxNQTc1OHZYMVB3M0JvQUFBQkpTVVJCVkFqWFk4QUpRa09ER0JoVVEwTWhiQVVHQmlZWTI0Q0JnUm5HRm1aZ01JU3dnd3dER1JoRWhWVkJiQVZtRVFZR1J3TW1CaklBUWkvQ1RJUmQ2RzVBdUEzZHpZUUJBSGowRUZkSGt2VjRBQUFBQUVsRlRrU3VRbUNDIjtFZGl0b3Iuem9vbU91dEltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJVQUFBQVZCQU1BQUFCYk9iaWxBQUFBRWxCTVZFVUFBQUFBQUFBc0xDeHhjWEVoSVNGZ1lHQ2hqVFV4QUFBQUFYUlNUbE1BUU9iWVpnQUFBRWRKUkVGVUNOZGpJQU13Q1FyQjJZS0NnZ0pRSnFNd0E3TWdsSzFvd01CZ3FBQlZBcElUZ0xKWlhGeGdiSVE0UWozQ0hJVDVnZ29JZTVrZ05rTTFLU0RZS0JLcXhQa0RBUG81QkFaQkU1NGhBQUFBQUVsRlRrU3VRbUNDIjsKRWRpdG9yLnpvb21JbkltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJVQUFBQVZCQU1BQUFCYk9iaWxBQUFBRWxCTVZFVUFBQUFBQUFBc0xDd2hJU0Z4Y1hGZ1lHQmF2S2FvQUFBQUFYUlNUbE1BUU9iWVpnQUFBRWxKUkVGVUNOZGpJQU13Q1FyQjJZS0NnZ0pRSnFNSUE0c2dsSzNvd016Z3FBQlZ3c0RNd0NnQVpUTWJHOFBZQ0hHRWVvUTVDUE1GRlJEMk1rRnNobXBTUUxCUkpGU0o4d2NBRXFjRU0ydWhsMk1BQUFBQVNVVk9SSzVDWUlJPSI7RWRpdG9yLnpvb21GaXRJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCVUFBQUFWQkFNQUFBQmJPYmlsQUFBQUQxQk1WRVVBQUFBQUFBQXdNREJ3Y0hCZ1lHQzF4bDA5QUFBQUFYUlNUbE1BUU9iWVpnQUFBRUZKUkVGVUNOZGpJQU13Q1FyQjJZS0NnZ0pRSnFNd0E3TWdsSzFvd01CZ3FBQlZBcElUd01kR3FFZVlnekJmVUFGaEx4UEVacWdtQlFRYlJVS0ZPSDhBQUs1T0EzbEErRkZPQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci5sYXllcnNJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCVUFBQUFWQ0FNQUFBQ2V5VldrQUFBQWFWQk1WRVVBQUFBZ0lDQUlDQWdkSFIwUER3OFdGaFlJQ0FnTEN3c1hGeGN2THk4T0RnNHVMaTRpSWlJcUtpb2tKQ1FZR0JnS0Nnb25KeWNGQlFVQ0FnSXFLaW9jSEJ3Y0hCd09EZzRlSGg0Y0hCd25KeWNKQ1FrVUZCUXFLaW9qSXlNdUxpNFpHUmtnSUNBRUJBVE9XWVhBQUFBQUduUlNUbE1BRDcrZm56OC9INy9mZjE4Lzc3K3ZyNStmbjM5L2IyOGZIMnhTb0tzQUFBQ1FTVVJCVkJqVHJZeEpFc01nREFSWlpNQVk3M3NnQ2NuL0h4bmhLdG5rN2o2b1JxMHBzZnVveW5kWi9TdU9Ea0hQTHpmVlQ2S2V5UGVQbko3S3Jua1JqV01YVG40U01uTjhtWGUyU1NNM3RzOEwvWlV4eHJiQVVMU1lKSlVMRTBJdzlwanBlbm9JQ2NnY1g2MW1HZ1RndEN2OUJlOTlwekNvRGhOUVdRbmNoRDFtdXA1KytDWUdjb1FleGFqWmJmd0FqLzBNRDhaT2FVZ0FBQUFBU1VWT1JLNUNZSUk9IjsKRWRpdG9yLnByZXZpb3VzSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlFBQUFBVUNBWUFBQUNOaVIwTkFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFoMGxFUVZRNGplM1VzUW5DVUJDQTRVOGhwYTFOc29FanBIUUpTMGR4QURkd0VNdU1JSmtnQTFoWUNoYkdRZ01pK0pDOHE0TC9BQi92RHU3eDc0Y1dXRVpoSlU0NFJtQTF6dWpSNUdJYlhGOVlOcmpEL1EwYkRSWTRmRUJaNFA0TGxnVG5DYkFmODRwVU04LzloWTA4dE1VdEVvUTFMcEVnck5CRmdsQ2hGWFI2UTZHZnd3UjZBR0tKTUY3NFZ0dDNBQUFBQUVsRlRrU3VRbUNDIjtFZGl0b3IubmV4dEltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJRQUFBQVVDQVlBQUFDTmlSME5BQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBaTBsRVFWUTRqZVhVSVE3Q1VBd0EwTWVHeFdJMnl5bHduQUxKVWRCY2dZdk03UVlMbWpPUUlBa0lQbUpaZ2hpSXZ5cG9VdFgwdGZuSkwzOFg1WmZhRWdVZVVjTWFuRkJIZ1MwU0xsaEhnZ2szYkNQQmhDZjJrZUNRUjh3andZVERwNllpWnhKbU9VMWpHdzd2R0FMZXNjdUJ4c0FyTmxPd2QvQ00xVlNNL3V0MXFDSXcrdU93aU1KK09GNENRekJDWG0zaHlBQUFBQUJKUlU1RXJrSmdnZz09IjsKRWRpdG9yLmVkaXRJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEN3QUxBSUFCQUZkWFYvLy8veUg1QkFFQUFBRUFMQUFBQUFBTEFBc0FBQUlaakI4QWlLdWM0anZMT0dxenJqWDZ6bWtXeUNoWGFVSkJBUUE3IjpJTUFHRV9QQVRIKyIvZWRpdC5naWYiO0VkaXRvci56b29tT3V0TGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQWlsQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vMk4yaU5BQUFBTFhSU1RsTUErdlRjS01NOTZHUkJId1h4aTBZYVgxSExyS1doaUhwV0VPbk9yNTJWYjJ4S1NEY1QxOVBLdjVsL05nZGs4K3ZpQUFBQkprbEVRVlE0eTRXVDJYYURNQXhFdldEMm5TU1VORW5USk4zci8vKzlTajdJTEFZNkwwaWpDNE9OWVZaUnBvNmNCeXJ6MllLU1VHb3JHVHB6NzFsUFZIdlQrYXZvQjV3SWtVL214azh2ZWNlU3VOb0xnNDRJenppWGp2cGloNzJ3S1FubTh5YzJVb2lQL0xBZDhqUWZlMlhmNFBxKzJFeVlJdnY5d2J6SEhDZ3d4RGRsQnRXWk9kcURmVENWZ3FweWdRcHNaYW9qVkFWYzlValF4bkFKRElCaGlRdjg0dHEzZ01RQ0FWVHhWb1NpYlhKZjh0TXVjN2UxVEIvRENtZWpCTmcvdzFZM2MrQU01dnY0dzd4TTU5L29YYW1ySGFMVnFQUStPVENubU1aeGd6MFNkTDV6amkwL2xkNmo4OHFHYTVLSWlCQjZXZUpHS2ZVS3dTTUtMdVhndmwxVFcwdG01UjlVUUwvZWZTRFlzbnp4RDhDaW5oQnNUVGR1Z0phdEtwSndmOHYrQURiOFFtdlc3QWVBQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci56b29tSW5MYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBaWxCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8yTjJpTkFBQUFMWFJTVGxNQSt2VGNLTU05NkdSQkh3WHhpMFlhWDFITHJLV2hpSHBXRU9uT3I1MlZiMnhLU0RjVDE5UEt2NWwvTmdkazgrdmlBQUFCS0VsRVFWUTR5NFdUNldLQ01CQ0VOd2tCd24yb0ZLdldxcjNMKzc5ZXM0RWtRSURPSDJkM1B4azJBQmlKbEI4SkNYanF3NExpa0hWR0xIVG0zbk0zVWVWTjU2OTBHQkJOMEd3eVYvM2trclVRUitXZUtuUkVlS3B6YVhXZDc3Q21KaVhHZlBJRUk0VjR5UTlUSVcvbnRsY01CZTczMVZ0czl3NVRXRzhGNWozbVFJNGh2cktwZEdlWUE3Q1g5cUFjbDY1MGdWSmFydHhSdWh5SFZnaEY4aWRRQUliRkx2Q0x1MjhCc1FFQzZhS3RDSzZQeWIzSlQ3UG1ibXROSDhOeTU2Q290RC8ycU9zNWNKYnVmZnhnWG1DaWIreGRkVlU1Uk5PaGt2dmtoVGxGZWh6VldDT2gzKytNWUVsT2hmZG92YUltblJZVm1xRGRzdWhOcDFRckJCRTZ1R0MyKzNaTmpHZGc1Qjk0b0QrOXV5VmdXVDc5QndBeEVCVFdkT3UzYldCVmdzbi9OL0FIVUQ5SUMwMU9lNDBBQUFBQVNVVk9SSzVDWUlJPSI7CkVkaXRvci5hY3R1YWxTaXplTGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQWlsQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vMk4yaU5BQUFBTFhSU1RsTUErdlRjS01NOTZHUkJId1h4aTBZYVgxSExyS1doaUhwV0VPbk9yNTJWYjJ4S1NEY1QxOVBLdjVsL05nZGs4K3ZpQUFBQklVbEVRVlE0eTRXVDJYcURJQkNGQnhEYzl5VFdORW5USk4zcis3OWVHVDRCRWJYbmF1Yk1yOGRCQmFNNDUwZENRcDRMV0ZBYXNjR0lSZDQ4ZUI0Y05ZRTdmNlhqZ0dpQ0ZzNWMrZG1sNkNGTjZqMVY2SVFJbEhQcGRWL3VzS2NtSmNWODhnUVRSWGpMRDlNaGIrZldxOFlHOS91Q21UQ0ZqZWVEZVk4NVVHS0lVR1V1cXpONDJrdjdvQ291cTlvSGFtbHpWUjFsVmZwQUl1MVFWUmlXK3NBdjdyNEZwQVlJWlpWc1JYQjlUUDVEZnBvMWQxdHJDZ3p6MWlpcHRIL3NVYmR6NEN6TjkrbUxlWEhuMytoZGRkZDRSRGVnc3J2endad1NzMkdMUFJKaWRBcUNMVGxWd2FNUHFwWU1XalRXQkIyV1JXODZwVmtoU0t5REsyYmR0MnRtYWdaRzRzQkQvZXZkTFFITEV2UWZBT0tSb0xDbUcxRkFCNnVLbWJ5K2d6K1JFRG43TzUrRXdRQUFBQUJKUlU1RXJrSmdnZz09IjsKRWRpdG9yLnByaW50TGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQVhWQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy85Ukt2dmxBQUFBSG5SU1RsTUF5ZG5sNzdxYk1MVDA5M0g3SzROZDRLdG4wODIrbFl0NWJra2xFZ1A0NG5RU0FBQUFwVWxFUVZRNHk3M1AyUTZESUJSRjBjT2diUkhIemhQLy81bTltQkFRS2pHMWNUMFljN0lUQU11MUxOUWdVWmlRMkRZb05RMHNDUWI2cWdIQWZSeDQ4b3BxM0o5QVo2eHVGN3VPZXc4SWsxT3NDWlJTMlVBQzlWK0Q5YStRWll4TkE0NVlGUWZ0UHRTa0FUT2h3N2RBYzB2UEJ3S1dpSU9qUDBKWjB5TXVRSjI3ZzM2RGlwT1VzcVJBTTBkUjhLRDEvSUxIYUhTRS93OERJeDA5RTNnL0JUY2U2ckhVQjVzQVBLdmZGK0pkQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci5sYXllcnNMYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBbVZCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8rL3Y3Ly8vK2JuWmtrQUFBQU1uUlNUbE1BQlByOEJ5aUQ4OEtzVGkvcnZKYjI3Mm1qZVVBMUN1UGUxTS9LalZ4WUh4TVA2S1owUzluWXpHUkdHUmF6bnBHSWJ6YUdVZjBBQUFIRVNVUkJWRGpMYlpMWllvSXdFRVZEZ0xDamJLSWdBbHFYcXQzbS96K3VOd3UxcmN5RGhqbDNrdG5ZTDdPWTI1NEMwVlgzeVdGWmZ6RHJPQ2xiYmdLeGkwWURIandsNGpiblJrWHhKUy9DMVlQM0RiQmhEMW43RXg0dWFBcWRWRGIzeUovNEovM25KRDJ0by9uZ1F6L0RmVXZ6TXA0Sko1c1NDYUY1b1htZW1nUURmRHh6YmkrS3E0c1Urdk5jdUFteDk0SnR5T1AyREQ0RXB6MmFzV1NDejRaLzRmRUN4eU5qOXpDOXhOTEhjZFBFTythd0RLZVNhVXUwVzR0d1pRaU8yaFlWaXNUUjNSQ3RLL2MxWDZ0NHhNRXBpR3FYcVZudEVCTG9sa1pac0tZNFF0d0g2anpxNjdkRUhsSnlzQjFhTk9EM1hUN24xVWthc1FONTlMNHlDMlJFTE1EU2VDUnR6M3lWMjJVYjNveklVVGtuWXg4SldxRGRReGJVZXM5OGNSMmtadFVTdmVGL2JBaGNlZHdFV21seElrcFpVeTRYT0NiNlZCamp4SHZid28vMWxCQUhIaTJKQ3IwTkk1NzBRaHlIcS9EaEpvRTJsTGd5QTRSVmU2S21aNDdPLzNiODZNQ1AwSFdhNzNBOC9DM1NVYzVRYzFhanQ2ZmdwWEorUkdwTXZEU2NoZXBaRE9PUVJjWlZJS2NLOTB4MkQ3ZXRxdEkrNTYrdTZuM3NQcmlPNm5mcGhpdFI0K08ybTNFYk03bGgzbWUxRk0xbytMTUk4ODdyTitzMy93WmRURmxwTlZKaU9BQUFBQUJKUlU1RXJrSmdnZz09IjsKRWRpdG9yLmNsb3NlTGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQVVWQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzhJTitkZUFBQUFHblJTVGxNQXV2QUlnL2RETS9RbE9ldUZoajBTNXM0dktnemp4SlJRTmlMU2V5MEFBQUROU1VSQlZEakxmWkxiRW9NZ0RFUWpSUlJzMVhxWC8vL1FObU9ISlNualBrSE9HUjdJRW1lb0d0SlpzdG53anFiUmZJc21nRWR0UENxZTlZbno3WlNjMDdyRTJRaVNjK3F2OFR2alJYQTJQRFVtM2RwZTgyaUpoT0VVZnhKSm8zYUN2K2pLbVJtSDRsY0NqQ2plaDlHV09kTC9HWlprWEgzUFlZRHJIQm5mYzREL1JWWmY1c2pvQzF3YXMrWTZIUXh3YVV4RnZxL2EwUHYzNDNWQ1R4ZkJTUmlCK2FiM00zZWlRWlhtTU5CSjNZOHBHUlp0WVE3RGdITVhKRWRQTFRhTi9xQmp6Sk9CYzNubU5jYnNBMTZiTVIwb0xxZitBQUFBQUVsRlRrU3VRbUNDIjsKRWRpdG9yLmVkaXRMYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBZ1ZCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzlkM3lKVEFBQUFLblJTVGxNQStoemkzblJRV3lYemttMGgyajN1NTRnekVnU1hqbFlvVEJnSnhMMmxvR3BBT1MzSnQ3V3htMzVHYTdnUkFBQUE2VWxFUVZRNHk2M1EyWGFDTUJTRjRRMEpCYXNvUTVESnFiWGpmdjhIYkNLMkJaTndvLzhGWEh4N3JjTUM3bFF1MGlYOHFVL3F0dkFXQ3BvcUg4ZFl6UzBTd2FWNWVLL1VBZjhYOXBkMkNXS3p1RjVKcmZ0cDFvd1h3bklHTFVhTDNQWW5kT0hmNGtOTlhXclhLL203Q0h1bms3SzhMRTZZdEJwY2tud0c5R0t4bnJvWSt5bEJYY3g0eEt5eC91L0V1WGk1MDljUDlWN09PMW95SG56cmRGVGNxTEcvNGliQkE1cElNci80eHZLenVRRGtWeTl3VzhTZ0JGRDZIRHZ1ek12clpjQzlRbGtmTXpJN3c2NG0rYjRQcUJNTkhCMDVsSDIxUFZ4Sm8yL2ZCWHhWNGhCMzhQY0QrNUFrSTRGdUVUc0FBQUFBU1VWT1JLNUNZSUk9IjsKRWRpdG9yLnByZXZpb3VzTGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQVBGQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1lTV2dUQUFBQUUzUlNUbE1BN2ZjaTQ5M2MwTVc4dUo2Q1prczRNeFFIRVpMNmV3QUFBRlpKUkVGVU9NdmRrc2tSZ0RBTUE0bER3ZzJCN2I5WE9sZ2UvS0t2ZHNhMjVLRmI1WGxSdnhYQy9ETkJFdjhJRk5qQmdHZERnWHRGZ1R5aHdEWGlRQVVIQ3Z3YTRVdjZtUjZVUisxbGVkMm1Wb252bCt0TUw0NXFDUU5RTEl4N0FBQUFBRWxGVGtTdVFtQ0MiO0VkaXRvci5uZXh0TGFyZ2VJbWFnZT0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFnQ0FNQUFBQkVwSXJHQUFBQVBGQk1WRVVBQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1lTV2dUQUFBQUUzUlNUbE1BN2ZjaTQ5M2MwTVc4dUo2Q1prczRNeFFIRVpMNmV3QUFBRlJKUkVGVU9NdmQwc2tSZ0NBUUJWRUZ3UTBWN2Z4ek5RUDZ3STA1djZwWi9reWoxYjdGTmdpazJnUXp6TGNBd2lVQWlnSE9Ud0RISzRBMUNtQjVCSkFOSkcxaFE5cWFmWWNxRmxaUDNJRmM5ZVZHclIraUlna0RRUlVYSUFBQUFBQkpSVTVFcmtKZ2dnPT0iOwpFZGl0b3IucmVmcmVzaExhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFvbEJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84RUxuYUNBQUFBTlhSU1RsTUFCZnlFMlFLVStkZk55eUR5b1ZZS3duVHY3Tis2cm50c1lsRk5RakVxRXczMTZ1U3pmMmMxSkIzR3ZxZWJpVnc2R0FqUUI0RFFyMTBBQUFFN1NVUkJWRGpMdlpMWGNvTXdFQUJQSWdSQ3gzVFQzQTN1ZHFMLy83VWdBZEdSY1I0eWs4aytpZHNkbWdTL1F5V0VxRC9heFMySkRWMzN6bG56TEhJelEyTURxOU9lSjNtOGw3NktLRU5ZbHhybU0vYjY1WXMxKzhZeG5URVpGSUVZMHZWaHN6RldmVUdaREpwUVREem5UZ0FlNWs0WGhReElMQjdydXpCUW4ra2t5RFh1SGZSdGpvWURFdkg3SjlMejk4ZEJaWFhMOTRYME9mY28yUEZsQ2hLYmpWekVkYWtvU2xLam9Ob3FQWWtKL3dVWkFZd2MrUHBMajFFaTcramRvQldsd1Fab0p2MkgxdzNDV2dSdm83ZGQ5RFA1YnRnd0NXejBNMDIrb1ZveENjSVdlWTlQTm1SNkIrK205cHJNeFlFSVNwQ0JZQmxmeTliYzc0NWlzN1VVVUxBZW0xV3c3RmZhbHNpQTJ1YUpzZ21XUDNwUUk5cTkveU1Ma2FhSEFwMmZ4aEhmZi9jTnE3ZEJkSFhoR1c3bCtNbzJ6VTBDZjhrbkoyeEEwb0o4ZW53QUFBQUFTVVZPUks1Q1lJST0iOwpFZGl0b3IuYmFja0xhcmdlSW1hZ2U9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBTUFBQUJFcElyR0FBQUFjbEJNVkVVQUFBRC8vLy8vLy8vLy8vLy8vLy8rL3Y3Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8rL3Y3Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzh2S0xmVEFBQUFKWFJTVGxNQUNoN2g5Z2J5M05MSXd6d1o1NXVWSmdINTdiKzh0YkNsallWMVJSTVE0NkZyVHpRdyt2dHhPUUFBQUo1SlJFRlVPTXVGMDBjV2d6QVFBMURSRFFGQ2J3RlNkZjhyWnBkVnJOSDJ6M3R1TXY3bWxkWlEyV04yeWk4eCtUVDhKdnlUa3F2d3BpS3Z3c09JckExZldyK1hHVGtsZmo4ZE9RUitEM0t5VUY2UXVmQmtKTjBoZkNhekV2NnNaQlJDSkRVY1Bhc0dLcHUxUkx0WUU4bGtIQVBCUUxvVHNLL1NmQXlSdzVGakF1aEN6QzJNU2owZ0orNjZsSGF0Z1hkS2JvRDl0ZlJFQjVtOS8rM2lDOWpIRFl2c0dOY1VBQUFBQUVsRlRrU3VRbUNDIjsKRWRpdG9yLmZ1bGxzY3JlZW5MYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQU1BQUFCRXBJckdBQUFBbGxCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vQUpjV29BQUFBTVhSU1RsTUErd0lGeFBXUENJYjQ0NnRuVXhtc29JeWtneFRlMjlqUW5wS0JlMk1Oc1poVlRSL0t5THVXYkZoRVBqVXE3TDl6K2JRaitnQUFBV3hKUkVGVU9NdHRrNGwyZ2tBTVJUT0RDTzRGdFFnSWJuV3BTOXY4Lzg4MWlaRmg4UjUxTk84R0orZ0FqTU44enVUUkZTdzA0Y0lPSFFjcUZISDZvYVFGR3hmMGplQmpFZ0I4WTUyVHBXOUFnNHpCNVFJQ1dPdEhyZ3dHdUZaQmN3K2dQUDBNRlM3K2lpRDVpbk9tRElRUzlzWmdUd1V6d0V6eXhoeEhWRUVVN05kRFVYc3FVUHRxaklnUjJJWlNDVDR1cHpTZUllT2RjTUhuZkRzeDNnaVBvZXpmVTZNclFHQjUvL1Nja0xFRzJ4WXNjSzRHZm5VRnFhaXgzOXpyd29vYU9EL2NYb1l1dkhLUUljN3B6ZDNIVlB1c3A2dDJGQVcvUm1qTW9uYmw4dndIRGVaby9Ha2xlSkM3ZStwNVhBL3JBcTFYL1YxMHdLYWcwNHJCcGEyL2QwTEw0T1lZY2VPRXRzRzVqeU1udEkxd1MrTjFCR2NRQmwvQ29Mb1BPbDlBQnJXL0JQNTNlMWJ3U0pISGxrSVZjaEp3bUh3eXlmSjRrSXZFbkt0d2t4TlNFY3Q4M0tTQ2hUN1dpV2dEWjNjY1owQk00dGxvSm93MllVQXRpZk5UM25qbnlEK3kvcE1zblA0RE4zWTR5bDFHeWswQUFBQUFTVVZPUks1Q1lJST0iOwpFZGl0b3IuY3RybEtleT1teENsaWVudC5JU19NQUM/IkNtZCI6IkN0cmwiO0VkaXRvci5oaW50T2Zmc2V0PTIwO0VkaXRvci5wb3B1cHNBbGxvd2VkPSEwO214VXRpbHMuZXh0ZW5kKEVkaXRvcixteEV2ZW50U291cmNlKTtFZGl0b3IucHJvdG90eXBlLm9yaWdpbmFsTm9Gb3JlaWduT2JqZWN0PW14Q2xpZW50Lk5PX0ZPO0VkaXRvci5wcm90b3R5cGUudHJhbnNwYXJlbnRJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaE1BQXdBSUFBQVAvLy93QUFBQ0g1QkFFQUFBQUFMQUFBQUFBd0FEQUFBQUl4aEkrcHkrMFBvNXkwMm91ejNyejdENGJpU0pibWlhYnF5cmJ1QzhmeVROZjJqZWY2enZmK0R3d0toOFNpOGVncEFBQTciOklNQUdFX1BBVEgrIi90cmFuc3BhcmVudC5naWYiO0VkaXRvci5wcm90b3R5cGUuZXh0ZW5kQ2FudmFzPSEwO0VkaXRvci5wcm90b3R5cGUuY2hyb21lbGVzcz0hMTtFZGl0b3IucHJvdG90eXBlLmNhbmNlbEZpcnN0PSEwOwpFZGl0b3IucHJvdG90eXBlLmVuYWJsZWQ9ITA7RWRpdG9yLnByb3RvdHlwZS5maWxlbmFtZT1udWxsO0VkaXRvci5wcm90b3R5cGUubW9kaWZpZWQ9ITE7RWRpdG9yLnByb3RvdHlwZS5hdXRvc2F2ZT0hMDtFZGl0b3IucHJvdG90eXBlLmluaXRpYWxUb3BTcGFjaW5nPTA7RWRpdG9yLnByb3RvdHlwZS5hcHBOYW1lPWRvY3VtZW50LnRpdGxlO0VkaXRvci5wcm90b3R5cGUuZWRpdEJsYW5rVXJsPXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCsiLy8iK3dpbmRvdy5sb2NhdGlvbi5ob3N0KyIvIjtFZGl0b3IucHJvdG90eXBlLmRlZmF1bHRHcmFwaE92ZXJmbG93PSJoaWRkZW4iO0VkaXRvci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe307RWRpdG9yLnByb3RvdHlwZS5pc0Nocm9tZWxlc3NWaWV3PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hyb21lbGVzc307RWRpdG9yLnByb3RvdHlwZS5zZXRBdXRvc2F2ZT1mdW5jdGlvbihhKXt0aGlzLmF1dG9zYXZlPWE7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImF1dG9zYXZlQ2hhbmdlZCIpKX07CkVkaXRvci5wcm90b3R5cGUuZ2V0RWRpdEJsYW5rVXJsPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVkaXRCbGFua1VybCthfTsKRWRpdG9yLnByb3RvdHlwZS5lZGl0QXNOZXc9ZnVuY3Rpb24oYSxjKXt2YXIgZj1udWxsIT1jPyI/dGl0bGU9IitlbmNvZGVVUklDb21wb25lbnQoYyk6IiI7bnVsbCE9dXJsUGFyYW1zLnVpJiYoZis9KDA8Zi5sZW5ndGg/IiYiOiI/IikrInVpPSIrdXJsUGFyYW1zLnVpKTtpZigidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cucG9zdE1lc3NhZ2UmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDEwPD1kb2N1bWVudC5kb2N1bWVudE1vZGUpKXt2YXIgZD1udWxsLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7InJlYWR5Ij09Yy5kYXRhJiZjLnNvdXJjZT09ZCYmKG14RXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCJtZXNzYWdlIixrKSxkLnBvc3RNZXNzYWdlKGEsIioiKSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywibWVzc2FnZSIsayk7ZD10aGlzLmdyYXBoLm9wZW5MaW5rKHRoaXMuZ2V0RWRpdEJsYW5rVXJsKGYrKDA8Zi5sZW5ndGg/IiYiOiI/IikrCiJjbGllbnQ9MSIpLG51bGwsITApfWVsc2UgdGhpcy5ncmFwaC5vcGVuTGluayh0aGlzLmdldEVkaXRCbGFua1VybChmKSsiI1IiK2VuY29kZVVSSUNvbXBvbmVudChhKSl9O0VkaXRvci5wcm90b3R5cGUuY3JlYXRlR3JhcGg9ZnVuY3Rpb24oYSxjKXt2YXIgZj1uZXcgR3JhcGgobnVsbCxjLG51bGwsbnVsbCxhKTtmLnRyYW5zcGFyZW50QmFja2dyb3VuZD0hMTt0aGlzLmNocm9tZWxlc3N8fChmLmlzQmxhbmtMaW5rPWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmlzRXh0ZXJuYWxQcm90b2NvbChhKX0pO3JldHVybiBmfTsKRWRpdG9yLnByb3RvdHlwZS5yZXNldEdyYXBoPWZ1bmN0aW9uKCl7dGhpcy5ncmFwaC5ncmlkRW5hYmxlZD0hdGhpcy5pc0Nocm9tZWxlc3NWaWV3KCl8fCIxIj09dXJsUGFyYW1zLmdyaWQ7dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD0hMDt0aGlzLmdyYXBoLnNldFRvb2x0aXBzKCEwKTt0aGlzLmdyYXBoLnNldENvbm5lY3RhYmxlKCEwKTt0aGlzLmdyYXBoLmZvbGRpbmdFbmFibGVkPSEwO3RoaXMuZ3JhcGguc2Nyb2xsYmFycz10aGlzLmdyYXBoLmRlZmF1bHRTY3JvbGxiYXJzO3RoaXMuZ3JhcGgucGFnZVZpc2libGU9dGhpcy5ncmFwaC5kZWZhdWx0UGFnZVZpc2libGU7dGhpcy5ncmFwaC5wYWdlQnJlYWtzVmlzaWJsZT10aGlzLmdyYXBoLnBhZ2VWaXNpYmxlO3RoaXMuZ3JhcGgucHJlZmVyUGFnZVNpemU9dGhpcy5ncmFwaC5wYWdlQnJlYWtzVmlzaWJsZTt0aGlzLmdyYXBoLmJhY2tncm91bmQ9bnVsbDt0aGlzLmdyYXBoLnBhZ2VTY2FsZT1teEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGU7CnRoaXMuZ3JhcGgucGFnZUZvcm1hdD1teEdyYXBoLnByb3RvdHlwZS5wYWdlRm9ybWF0O3RoaXMuZ3JhcGguY3VycmVudFNjYWxlPTE7dGhpcy5ncmFwaC5jdXJyZW50VHJhbnNsYXRlLng9MDt0aGlzLmdyYXBoLmN1cnJlbnRUcmFuc2xhdGUueT0wO3RoaXMudXBkYXRlR3JhcGhDb21wb25lbnRzKCk7dGhpcy5ncmFwaC52aWV3LnNldFNjYWxlKDEpfTsKRWRpdG9yLnByb3RvdHlwZS5yZWFkR3JhcGhTdGF0ZT1mdW5jdGlvbihhKXt0aGlzLmdyYXBoLmdyaWRFbmFibGVkPSIwIiE9YS5nZXRBdHRyaWJ1dGUoImdyaWQiKSYmKCF0aGlzLmlzQ2hyb21lbGVzc1ZpZXcoKXx8IjEiPT11cmxQYXJhbXMuZ3JpZCk7dGhpcy5ncmFwaC5ncmlkU2l6ZT1wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJncmlkU2l6ZSIpKXx8bXhHcmFwaC5wcm90b3R5cGUuZ3JpZFNpemU7dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD0iMCIhPWEuZ2V0QXR0cmlidXRlKCJndWlkZXMiKTt0aGlzLmdyYXBoLnNldFRvb2x0aXBzKCIwIiE9YS5nZXRBdHRyaWJ1dGUoInRvb2x0aXBzIikpO3RoaXMuZ3JhcGguc2V0Q29ubmVjdGFibGUoIjAiIT1hLmdldEF0dHJpYnV0ZSgiY29ubmVjdCIpKTt0aGlzLmdyYXBoLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkPSIwIiE9YS5nZXRBdHRyaWJ1dGUoImFycm93cyIpO3RoaXMuZ3JhcGguZm9sZGluZ0VuYWJsZWQ9CiIwIiE9YS5nZXRBdHRyaWJ1dGUoImZvbGQiKTt0aGlzLmlzQ2hyb21lbGVzc1ZpZXcoKSYmdGhpcy5ncmFwaC5mb2xkaW5nRW5hYmxlZCYmKHRoaXMuZ3JhcGguZm9sZGluZ0VuYWJsZWQ9IjEiPT11cmxQYXJhbXMubmF2LHRoaXMuZ3JhcGguY2VsbFJlbmRlcmVyLmZvcmNlQ29udHJvbENsaWNrSGFuZGxlcj10aGlzLmdyYXBoLmZvbGRpbmdFbmFibGVkKTt2YXIgYz1wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJwYWdlU2NhbGUiKSk7IWlzTmFOKGMpJiYwPGM/dGhpcy5ncmFwaC5wYWdlU2NhbGU9Yzp0aGlzLmdyYXBoLnBhZ2VTY2FsZT1teEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGU7dGhpcy5ncmFwaC5pc0xpZ2h0Ym94VmlldygpfHx0aGlzLmdyYXBoLmlzVmlld2VyKCk/dGhpcy5ncmFwaC5wYWdlVmlzaWJsZT0hMTooYz1hLmdldEF0dHJpYnV0ZSgicGFnZSIpLHRoaXMuZ3JhcGgucGFnZVZpc2libGU9bnVsbCE9Yz8iMCIhPWM6dGhpcy5ncmFwaC5kZWZhdWx0UGFnZVZpc2libGUpOwp0aGlzLmdyYXBoLnBhZ2VCcmVha3NWaXNpYmxlPXRoaXMuZ3JhcGgucGFnZVZpc2libGU7dGhpcy5ncmFwaC5wcmVmZXJQYWdlU2l6ZT10aGlzLmdyYXBoLnBhZ2VCcmVha3NWaXNpYmxlO3ZhciBjPXBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoInBhZ2VXaWR0aCIpKSxmPXBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoInBhZ2VIZWlnaHQiKSk7aXNOYU4oYyl8fGlzTmFOKGYpfHwodGhpcy5ncmFwaC5wYWdlRm9ybWF0PW5ldyBteFJlY3RhbmdsZSgwLDAsYyxmKSk7YT1hLmdldEF0dHJpYnV0ZSgiYmFja2dyb3VuZCIpO3RoaXMuZ3JhcGguYmFja2dyb3VuZD1udWxsIT1hJiYwPGEubGVuZ3RoP2E6bnVsbH07CkVkaXRvci5wcm90b3R5cGUuc2V0R3JhcGhYbWw9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGM9bmV3IG14Q29kZWMoYS5vd25lckRvY3VtZW50KTtpZigibXhHcmFwaE1vZGVsIj09YS5ub2RlTmFtZSl7dGhpcy5ncmFwaC5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt0aGlzLmdyYXBoLm1vZGVsLmNsZWFyKCksdGhpcy5ncmFwaC52aWV3LnNjYWxlPTEsdGhpcy5yZWFkR3JhcGhTdGF0ZShhKSx0aGlzLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpLGMuZGVjb2RlKGEsdGhpcy5ncmFwaC5nZXRNb2RlbCgpKX1maW5hbGx5e3RoaXMuZ3JhcGgubW9kZWwuZW5kVXBkYXRlKCl9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInJlc2V0R3JhcGhWaWV3IikpfWVsc2UgaWYoInJvb3QiPT1hLm5vZGVOYW1lKXt0aGlzLnJlc2V0R3JhcGgoKTt2YXIgZj1jLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm14R3JhcGhNb2RlbCIpO2YuYXBwZW5kQ2hpbGQoYSk7Yy5kZWNvZGUoZix0aGlzLmdyYXBoLmdldE1vZGVsKCkpOwp0aGlzLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJyZXNldEdyYXBoVmlldyIpKX1lbHNlIHRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJjYW5ub3RPcGVuRmlsZSIpLG5vZGU6YSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1lc3NhZ2V9fTt9ZWxzZSB0aGlzLnJlc2V0R3JhcGgoKSx0aGlzLmdyYXBoLm1vZGVsLmNsZWFyKCksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInJlc2V0R3JhcGhWaWV3IikpfTsKRWRpdG9yLnByb3RvdHlwZS5nZXRHcmFwaFhtbD1mdW5jdGlvbihhKXthPShudWxsIT1hP2E6MSk/KG5ldyBteENvZGVjKG14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKSkpLmVuY29kZSh0aGlzLmdyYXBoLmdldE1vZGVsKCkpOnRoaXMuZ3JhcGguZW5jb2RlQ2VsbHMobXhVdGlscy5zb3J0Q2VsbHModGhpcy5ncmFwaC5tb2RlbC5nZXRUb3Btb3N0Q2VsbHModGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25DZWxscygpKSkpO2lmKDAhPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUueHx8MCE9dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZS55KWEuc2V0QXR0cmlidXRlKCJkeCIsTWF0aC5yb3VuZCgxMDAqdGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZS54KS8xMDApLGEuc2V0QXR0cmlidXRlKCJkeSIsTWF0aC5yb3VuZCgxMDAqdGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZS55KS8xMDApO2Euc2V0QXR0cmlidXRlKCJncmlkIix0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWQoKT8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgiZ3JpZFNpemUiLAp0aGlzLmdyYXBoLmdyaWRTaXplKTthLnNldEF0dHJpYnV0ZSgiZ3VpZGVzIix0aGlzLmdyYXBoLmdyYXBoSGFuZGxlci5ndWlkZXNFbmFibGVkPyIxIjoiMCIpO2Euc2V0QXR0cmlidXRlKCJ0b29sdGlwcyIsdGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKT8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgiY29ubmVjdCIsdGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5pc0VuYWJsZWQoKT8iMSI6IjAiKTthLnNldEF0dHJpYnV0ZSgiYXJyb3dzIix0aGlzLmdyYXBoLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkPyIxIjoiMCIpO2Euc2V0QXR0cmlidXRlKCJmb2xkIix0aGlzLmdyYXBoLmZvbGRpbmdFbmFibGVkPyIxIjoiMCIpO2Euc2V0QXR0cmlidXRlKCJwYWdlIix0aGlzLmdyYXBoLnBhZ2VWaXNpYmxlPyIxIjoiMCIpO2Euc2V0QXR0cmlidXRlKCJwYWdlU2NhbGUiLHRoaXMuZ3JhcGgucGFnZVNjYWxlKTthLnNldEF0dHJpYnV0ZSgicGFnZVdpZHRoIix0aGlzLmdyYXBoLnBhZ2VGb3JtYXQud2lkdGgpOwphLnNldEF0dHJpYnV0ZSgicGFnZUhlaWdodCIsdGhpcy5ncmFwaC5wYWdlRm9ybWF0LmhlaWdodCk7bnVsbCE9dGhpcy5ncmFwaC5iYWNrZ3JvdW5kJiZhLnNldEF0dHJpYnV0ZSgiYmFja2dyb3VuZCIsdGhpcy5ncmFwaC5iYWNrZ3JvdW5kKTtyZXR1cm4gYX07RWRpdG9yLnByb3RvdHlwZS51cGRhdGVHcmFwaENvbXBvbmVudHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoO251bGwhPWEuY29udGFpbmVyJiYoYS52aWV3LnZhbGlkYXRlQmFja2dyb3VuZCgpLGEuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93PWEuc2Nyb2xsYmFycz8iYXV0byI6dGhpcy5kZWZhdWx0R3JhcGhPdmVyZmxvdyx0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgidXBkYXRlR3JhcGhDb21wb25lbnRzIikpKX07RWRpdG9yLnByb3RvdHlwZS5zZXRNb2RpZmllZD1mdW5jdGlvbihhKXt0aGlzLm1vZGlmaWVkPWF9OwpFZGl0b3IucHJvdG90eXBlLnNldEZpbGVuYW1lPWZ1bmN0aW9uKGEpe3RoaXMuZmlsZW5hbWU9YX07CkVkaXRvci5wcm90b3R5cGUuY3JlYXRlVW5kb01hbmFnZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLGM9bmV3IG14VW5kb01hbmFnZXI7dGhpcy51bmRvTGlzdGVuZXI9ZnVuY3Rpb24oYSxmKXtjLnVuZG9hYmxlRWRpdEhhcHBlbmVkKGYuZ2V0UHJvcGVydHkoImVkaXQiKSl9O3ZhciBmPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dGhpcy51bmRvTGlzdGVuZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSk7YS5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuVU5ETyxmKTthLmdldFZpZXcoKS5hZGRMaXN0ZW5lcihteEV2ZW50LlVORE8sZik7Zj1mdW5jdGlvbihkLGMpe3ZhciBmPWEuZ2V0U2VsZWN0aW9uQ2VsbHNGb3JDaGFuZ2VzKGMuZ2V0UHJvcGVydHkoImVkaXQiKS5jaGFuZ2VzLGZ1bmN0aW9uKGEpe3JldHVybiEoYSBpbnN0YW5jZW9mIG14Q2hpbGRDaGFuZ2UpfSk7aWYoMDxmLmxlbmd0aCl7YS5nZXRNb2RlbCgpO2Zvcih2YXIgaz1bXSxiPTA7YjwKZi5sZW5ndGg7YisrKW51bGwhPWEudmlldy5nZXRTdGF0ZShmW2JdKSYmay5wdXNoKGZbYl0pO2Euc2V0U2VsZWN0aW9uQ2VsbHMoayl9fTtjLmFkZExpc3RlbmVyKG14RXZlbnQuVU5ETyxmKTtjLmFkZExpc3RlbmVyKG14RXZlbnQuUkVETyxmKTtyZXR1cm4gY307RWRpdG9yLnByb3RvdHlwZS5pbml0U3RlbmNpbFJlZ2lzdHJ5PWZ1bmN0aW9uKCl7fTtFZGl0b3IucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmdyYXBoJiYodGhpcy5ncmFwaC5kZXN0cm95KCksdGhpcy5ncmFwaD1udWxsKX07T3BlbkZpbGU9ZnVuY3Rpb24oYSl7dGhpcy5jb25zdW1lcj10aGlzLnByb2R1Y2VyPW51bGw7dGhpcy5kb25lPWE7dGhpcy5hcmdzPW51bGx9O09wZW5GaWxlLnByb3RvdHlwZS5zZXRDb25zdW1lcj1mdW5jdGlvbihhKXt0aGlzLmNvbnN1bWVyPWE7dGhpcy5leGVjdXRlKCl9OwpPcGVuRmlsZS5wcm90b3R5cGUuc2V0RGF0YT1mdW5jdGlvbigpe3RoaXMuYXJncz1hcmd1bWVudHM7dGhpcy5leGVjdXRlKCl9O09wZW5GaWxlLnByb3RvdHlwZS5lcnJvcj1mdW5jdGlvbihhKXt0aGlzLmNhbmNlbCghMCk7bXhVdGlscy5hbGVydChhKX07T3BlbkZpbGUucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmNvbnN1bWVyJiZudWxsIT10aGlzLmFyZ3MmJih0aGlzLmNhbmNlbCghMSksdGhpcy5jb25zdW1lci5hcHBseSh0aGlzLHRoaXMuYXJncykpfTtPcGVuRmlsZS5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuZG9uZSYmdGhpcy5kb25lKG51bGwhPWE/YTohMCl9OwpmdW5jdGlvbiBEaWFsb2coYSxjLGYsZCxrLG0scSxiLGUsZyxuKXt2YXIgbD0wO214Q2xpZW50LklTX1ZNTCYmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OD5kb2N1bWVudC5kb2N1bWVudE1vZGUpJiYobD04MCk7Zis9bDtkKz1sO3ZhciBwPWYsdj1kLHQ9bXhVdGlscy5nZXREb2N1bWVudFNpemUoKTtudWxsIT13aW5kb3cuaW5uZXJIZWlnaHQmJih0LmhlaWdodD13aW5kb3cuaW5uZXJIZWlnaHQpO3ZhciB5PXQuaGVpZ2h0LHg9TWF0aC5tYXgoMSxNYXRoLnJvdW5kKCh0LndpZHRoLWYtNjQpLzIpKSxDPU1hdGgubWF4KDEsTWF0aC5yb3VuZCgoeS1kLWEuZm9vdGVySGVpZ2h0KS8zKSk7bXhDbGllbnQuSVNfUVVJUktTfHwoYy5zdHlsZS5tYXhIZWlnaHQ9IjEwMCUiKTtmPW51bGwhPWRvY3VtZW50LmJvZHk/TWF0aC5taW4oZixkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoLTY0KTpmO2Q9TWF0aC5taW4oZCx5LTY0KTswPGEuZGlhbG9ncy5sZW5ndGgmJih0aGlzLnpJbmRleCs9CjIqYS5kaWFsb2dzLmxlbmd0aCk7bnVsbD09dGhpcy5iZyYmKHRoaXMuYmc9YS5jcmVhdGVEaXYoImJhY2tncm91bmQiKSx0aGlzLmJnLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsdGhpcy5iZy5zdHlsZS5iYWNrZ3JvdW5kPURpYWxvZy5iYWNrZHJvcENvbG9yLHRoaXMuYmcuc3R5bGUuaGVpZ2h0PXkrInB4Iix0aGlzLmJnLnN0eWxlLnJpZ2h0PSIwcHgiLHRoaXMuYmcuc3R5bGUuekluZGV4PXRoaXMuekluZGV4LTIsbXhVdGlscy5zZXRPcGFjaXR5KHRoaXMuYmcsdGhpcy5iZ09wYWNpdHkpLG14Q2xpZW50LklTX1FVSVJLUyYmbmV3IG14RGl2UmVzaXplcih0aGlzLmJnKSk7dD1teFV0aWxzLmdldERvY3VtZW50U2Nyb2xsT3JpZ2luKGRvY3VtZW50KTt0aGlzLmJnLnN0eWxlLmxlZnQ9dC54KyJweCI7dGhpcy5iZy5zdHlsZS50b3A9dC55KyJweCI7eCs9dC54O0MrPXQueTtrJiZkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmcpO3ZhciBCPWEuY3JlYXRlRGl2KGU/ImdlVHJhbnNEaWFsb2ciOgoiZ2VEaWFsb2ciKTtrPXRoaXMuZ2V0UG9zaXRpb24oeCxDLGYsZCk7eD1rLng7Qz1rLnk7Qi5zdHlsZS53aWR0aD1mKyJweCI7Qi5zdHlsZS5oZWlnaHQ9ZCsicHgiO0Iuc3R5bGUubGVmdD14KyJweCI7Qi5zdHlsZS50b3A9QysicHgiO0Iuc3R5bGUuekluZGV4PXRoaXMuekluZGV4O0IuYXBwZW5kQ2hpbGQoYyk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChCKTshYiYmYy5jbGllbnRIZWlnaHQ+Qi5jbGllbnRIZWlnaHQtNjQmJihjLnN0eWxlLm92ZXJmbG93WT0iYXV0byIpO2lmKG0mJihtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpLG0uc2V0QXR0cmlidXRlKCJzcmMiLERpYWxvZy5wcm90b3R5cGUuY2xvc2VJbWFnZSksbS5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImNsb3NlIikpLG0uY2xhc3NOYW1lPSJnZURpYWxvZ0Nsb3NlIixtLnN0eWxlLnRvcD1DKzE0KyJweCIsbS5zdHlsZS5sZWZ0PXgrZiszOC1sKyJweCIsbS5zdHlsZS56SW5kZXg9CnRoaXMuekluZGV4LG14RXZlbnQuYWRkTGlzdGVuZXIobSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCEwKX0pKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG0pLHRoaXMuZGlhbG9nSW1nPW0sIW4pKXt2YXIgRD0hMTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnModGhpcy5iZyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtEPSEwfSksbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtEJiYoYS5oaWRlRGlhbG9nKCEwKSxEPSExKX0pKX10aGlzLnJlc2l6ZUxpc3RlbmVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbCE9Zyl7dmFyIGU9ZygpO251bGwhPWUmJihwPWY9ZS53LHY9ZD1lLmgpfWU9bXhVdGlscy5nZXREb2N1bWVudFNpemUoKTt5PWUuaGVpZ2h0O3RoaXMuYmcuc3R5bGUuaGVpZ2h0PXkrInB4Ijt4PU1hdGgubWF4KDEsTWF0aC5yb3VuZCgoZS53aWR0aC1mLTY0KS8yKSk7Qz1NYXRoLm1heCgxLApNYXRoLnJvdW5kKCh5LWQtYS5mb290ZXJIZWlnaHQpLzMpKTtmPW51bGwhPWRvY3VtZW50LmJvZHk/TWF0aC5taW4ocCxkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoLTY0KTpwO2Q9TWF0aC5taW4odix5LTY0KTtlPXRoaXMuZ2V0UG9zaXRpb24oeCxDLGYsZCk7eD1lLng7Qz1lLnk7Qi5zdHlsZS5sZWZ0PXgrInB4IjtCLnN0eWxlLnRvcD1DKyJweCI7Qi5zdHlsZS53aWR0aD1mKyJweCI7Qi5zdHlsZS5oZWlnaHQ9ZCsicHgiOyFiJiZjLmNsaWVudEhlaWdodD5CLmNsaWVudEhlaWdodC02NCYmKGMuc3R5bGUub3ZlcmZsb3dZPSJhdXRvIik7bnVsbCE9dGhpcy5kaWFsb2dJbWcmJih0aGlzLmRpYWxvZ0ltZy5zdHlsZS50b3A9QysxNCsicHgiLHRoaXMuZGlhbG9nSW1nLnN0eWxlLmxlZnQ9eCtmKzM4LWwrInB4Iil9KTtteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIix0aGlzLnJlc2l6ZUxpc3RlbmVyKTt0aGlzLm9uRGlhbG9nQ2xvc2U9cTt0aGlzLmNvbnRhaW5lcj0KQjthLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInNob3dEaWFsb2ciKSl9RGlhbG9nLmJhY2tkcm9wQ29sb3I9IndoaXRlIjtEaWFsb2cucHJvdG90eXBlLnpJbmRleD1teFBvcHVwTWVudS5wcm90b3R5cGUuekluZGV4LTE7CkRpYWxvZy5wcm90b3R5cGUubm9Db2xvckltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FNQUFBQW9MUTlUQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5QnBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU1DMWpNRFl3SURZeExqRXpORGMzTnl3Z01qQXhNQzh3TWk4eE1pMHhOem96TWpvd01DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTlROU0JYYVc1a2IzZHpJaUI0YlhCTlRUcEpibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPa0V6UkRsQk1VVXdPRFl4TVRFeFJURkNNekE0UkRkRE1qSkJNRU14UkRNM0lpQjRiWEJOVFRwRWIyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09rRXpSRGxCTVVVeE9EWXhNVEV4UlRGQ016QTRSRGRETWpKQk1FTXhSRE0zSWo0Z1BIaHRjRTFOT2tSbGNtbDJaV1JHY205dElITjBVbVZtT21sdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNlFUTkVPVUV4UkVVNE5qRXhNVEZGTVVJek1EaEVOME15TWtFd1F6RkVNemNpSUhOMFVtVm1PbVJ2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2UVRORU9VRXhSRVk0TmpFeE1URkZNVUl6TURoRU4wTXlNa0V3UXpGRU16Y2lMejRnUEM5eVpHWTZSR1Z6WTNKcGNIUnBiMjQrSUR3dmNtUm1PbEpFUmo0Z1BDOTRPbmh0Y0cxbGRHRStJRHcvZUhCaFkydGxkQ0JsYm1ROUluSWlQejV4aDNmbUFBQUFCbEJNVkVYLy8vL016TXc0NnFxREFBQUFHRWxFUVZSNDJtSmdnQUpHS0dBWUlJR0J0aDhLQUFJTUFFVVFBSUVsbkx1UUFBQUFBRWxGVGtTdVFtQ0MiOklNQUdFX1BBVEgrCiIvbm9jb2xvci5wbmciO0RpYWxvZy5wcm90b3R5cGUuY2xvc2VJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBSkFRTUFBQURhWDVSVEFBQUFCbEJNVkVWN21yMy8vLyt3a3NzcEFBQUFBblJTVGxQL0FPVzNNRW9BQUFBZFNVUkJWQWdkWTlqWHdDRER3TkRSd0hDd2dlRXhtQVN5Z1NMN0dnQjEyUWlxTkhaWkl3QUFBQUJKUlU1RXJrSmdnZz09IjpJTUFHRV9QQVRIKyIvY2xvc2UucG5nIjsKRGlhbG9nLnByb3RvdHlwZS5jbGVhckltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoRFFBS0FJQUJBTURBd1AvLy95SC9DMWhOVUNCRVlYUmhXRTFRUEQ5NGNHRmphMlYwSUdKbFoybHVQU0x2dTc4aUlHbGtQU0pYTlUwd1RYQkRaV2hwU0hweVpWTjZUbFJqZW10ak9XUWlQejRnUEhnNmVHMXdiV1YwWVNCNGJXeHVjenA0UFNKaFpHOWlaVHB1Y3pwdFpYUmhMeUlnZURwNGJYQjBhejBpUVdSdlltVWdXRTFRSUVOdmNtVWdOUzR3TFdNd05qQWdOakV1TVRNME56YzNMQ0F5TURFd0x6QXlMekV5TFRFM09qTXlPakF3SUNBZ0lDQWdJQ0FpUGlBOGNtUm1PbEpFUmlCNGJXeHVjenB5WkdZOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2TURJdk1qSXRjbVJtTFhONWJuUmhlQzF1Y3lNaVBpQThjbVJtT2tSbGMyTnlhWEIwYVc5dUlISmtaanBoWW05MWREMGlJaUI0Yld4dWN6cDRiWEE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM4aUlIaHRiRzV6T25odGNFMU5QU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2YlcwdklpQjRiV3h1Y3pwemRGSmxaajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDNOVWVYQmxMMUpsYzI5MWNtTmxVbVZtSXlJZ2VHMXdPa055WldGMGIzSlViMjlzUFNKQlpHOWlaU0JRYUc5MGIzTm9iM0FnUTFNMUlGZHBibVJ2ZDNNaUlIaHRjRTFOT2tsdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNk9VSXpPRU0xTnpJNE5qRXlNVEZGTVVFek1rTkRNVUUzTmpaRVJERTJRaklpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2T1VJek9FTTFOek00TmpFeU1URkZNVUV6TWtORE1VRTNOalpFUkRFMlFqSWlQaUE4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnYzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG81UWpNNFF6VTNNRGcyTVRJeE1VVXhRVE15UTBNeFFUYzJOa1JFTVRaQ01pSWdjM1JTWldZNlpHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzVRak00UXpVM01UZzJNVEl4TVVVeFFUTXlRME14UVRjMk5rUkVNVFpDTWlJdlBpQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNGdQQzl5WkdZNlVrUkdQaUE4TDNnNmVHMXdiV1YwWVQ0Z1BEOTRjR0ZqYTJWMElHVnVaRDBpY2lJL1BnSC8vdjM4Ky9yNStQZjI5ZlR6OHZIdzcrN3Q3T3ZxNmVqbjV1WGs0K0xoNE4vZTNkemIydG5ZMTliVjFOUFMwZERQenMzTXk4ckp5TWZHeGNURHdzSEF2NzY5dkx1NnViaTN0clcwczdLeHNLK3VyYXlycXFtb3A2YWxwS09pb2FDZm5wMmNtNXFabUplV2xaU1RrcEdRajQ2TmpJdUtpWWlIaG9XRWc0S0JnSDkrZlh4N2VubDRkM1oxZEhOeWNYQnZibTFzYTJwcGFHZG1aV1JqWW1GZ1gxNWRYRnRhV1ZoWFZsVlVVMUpSVUU5T1RVeExTa2xJUjBaRlJFTkNRVUEvUGowOE96bzVPRGMyTlRRek1qRXdMeTR0TENzcUtTZ25KaVVrSXlJaElCOGVIUndiR2hrWUZ4WVZGQk1TRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQUNINUJBRUFBQUVBTEFBQUFBQU5BQW9BQUFJWFRHQ0plYkQ5akVPVHFSbHR0WGRyQjMyUEoybmN5UlFBT3c9PSI6SU1BR0VfUEFUSCsKIi9jbGVhci5naWYiOwpEaWFsb2cucHJvdG90eXBlLmxvY2tlZEltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFNQ0FNQUFBQmhxNnpWQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5SnBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU1DMWpNRFl3SURZeExqRXpORGMzTnl3Z01qQXhNQzh3TWk4eE1pMHhOem96TWpvd01DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTlROU0JOWVdOcGJuUnZjMmdpSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TXpkRE1EWkNPREV4TnpJeE1URkZOVUkwUlRrNU5UZzRPVGN5TVVVeU9ERWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZNemRETURaQ09ESXhOekl4TVRGRk5VSTBSVGs1TlRnNE9UY3lNVVV5T0RFaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3pOME13TmtJM1JqRTNNakV4TVVVMVFqUkZPVGsxT0RnNU56SXhSVEk0TVNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvek4wTXdOa0k0TURFM01qRXhNVVUxUWpSRk9UazFPRGc1TnpJeFJUSTRNU0l2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUHZxTUNGWUFBQUFWVUV4VVJabVptYisvdjdLeXNxeXNyTXpNekxHeHNmLy8vNGc4TjFjQUFBQUhkRkpPVS8vLy8vLy8vd0FhU3dOR0FBQUFQRWxFUVZSNDJsVE1RUTRBSVFnRXdVYTAvLzlrVFFpck93ZVlPZ0RxQU1iWlVyMTBBR2xBd3g0L0JKMlFKNFUwTDVicllqb3Z2cHYzMnhaZ0FIWmFBVEZ0TWJ1NEFBQUFBRWxGVGtTdVFtQ0MiOklNQUdFX1BBVEgrCiIvbG9ja2VkLnBuZyI7CkRpYWxvZy5wcm90b3R5cGUudW5sb2NrZWRJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBTUNBTUFBQUJocTZ6VkFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeUpwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVNQzFqTURZd0lEWXhMakV6TkRjM055d2dNakF4TUM4d01pOHhNaTB4Tnpvek1qb3dNQ0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5UTlNCTllXTnBiblJ2YzJnaUlIaHRjRTFOT2tsdWMzUmhibU5sU1VROUluaHRjQzVwYVdRNk16ZERNRFpDTjBReE56SXhNVEZGTlVJMFJUazVOVGc0T1RjeU1VVXlPREVpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2TXpkRE1EWkNOMFV4TnpJeE1URkZOVUkwUlRrNU5UZzRPVGN5TVVVeU9ERWlQaUE4ZUcxd1RVMDZSR1Z5YVhabFpFWnliMjBnYzNSU1pXWTZhVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG96TjBNd05rSTNRakUzTWpFeE1VVTFRalJGT1RrMU9EZzVOekl4UlRJNE1TSWdjM1JTWldZNlpHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEb3pOME13TmtJM1F6RTNNakV4TVVVMVFqUkZPVGsxT0RnNU56SXhSVEk0TVNJdlBpQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNGdQQzl5WkdZNlVrUkdQaUE4TDNnNmVHMXdiV1YwWVQ0Z1BEOTRjR0ZqYTJWMElHVnVaRDBpY2lJL1BrS01wVndBQUFBWVVFeFVSWm1abWJLeXNyKy92Nnlzck9YbDVjek16TEd4c2YvLy96SE41bHdBQUFBSWRGSk9VLy8vLy8vLy8vOEEzb085V1FBQUFEeEpSRUZVZU5wVXpGRVNBQ0FFQk5CVnNmZS9jWkpVKzhNenM4Q0lBQkNpZHRmR09uZG5Zc1Q0MEhEU2lDY2JQZG9KbzEwbzlhSTY3N2Nwd0FDUm9BRjNkRk5sc3dBQUFBQkpSVTVFcmtKZ2dnPT0iOklNQUdFX1BBVEgrCiIvdW5sb2NrZWQucG5nIjtEaWFsb2cucHJvdG90eXBlLmJnT3BhY2l0eT04MDtEaWFsb2cucHJvdG90eXBlLmdldFBvc2l0aW9uPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG5ldyBteFBvaW50KGEsYyl9O0RpYWxvZy5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYSxjKXtpZihudWxsIT10aGlzLm9uRGlhbG9nQ2xvc2Upe2lmKDA9PXRoaXMub25EaWFsb2dDbG9zZShhLGMpKXJldHVybiExO3RoaXMub25EaWFsb2dDbG9zZT1udWxsfW51bGwhPXRoaXMuZGlhbG9nSW1nJiYodGhpcy5kaWFsb2dJbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpYWxvZ0ltZyksdGhpcy5kaWFsb2dJbWc9bnVsbCk7bnVsbCE9dGhpcy5iZyYmbnVsbCE9dGhpcy5iZy5wYXJlbnROb2RlJiZ0aGlzLmJnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iZyk7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsdGhpcy5yZXNpemVMaXN0ZW5lcik7dGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcil9Owp2YXIgRXJyb3JEaWFsb2c9ZnVuY3Rpb24oYSxjLGYsZCxrLG0scSxiLGUsZyxuKXtlPW51bGwhPWU/ZTohMDt2YXIgbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtsLnN0eWxlLnRleHRBbGlnbj0iY2VudGVyIjtpZihudWxsIT1jKXt2YXIgcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtwLnN0eWxlLnBhZGRpbmc9IjBweCI7cC5zdHlsZS5tYXJnaW49IjBweCI7cC5zdHlsZS5mb250U2l6ZT0iMThweCI7cC5zdHlsZS5wYWRkaW5nQm90dG9tPSIxNnB4IjtwLnN0eWxlLm1hcmdpbkJvdHRvbT0iMTBweCI7cC5zdHlsZS5ib3JkZXJCb3R0b209IjFweCBzb2xpZCAjYzBjMGMwIjtwLnN0eWxlLmNvbG9yPSJncmF5IjtwLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7cC5zdHlsZS50ZXh0T3ZlcmZsb3c9ImVsbGlwc2lzIjtwLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO214VXRpbHMud3JpdGUocCxjKTtwLnNldEF0dHJpYnV0ZSgidGl0bGUiLGMpO2wuYXBwZW5kQ2hpbGQocCl9Yz0KZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5zdHlsZS5saW5lSGVpZ2h0PSIxLjJlbSI7Yy5zdHlsZS5wYWRkaW5nPSI2cHgiO2MuaW5uZXJIVE1MPWY7bC5hcHBlbmRDaGlsZChjKTtmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Yuc3R5bGUubWFyZ2luVG9wPSIxMnB4IjtmLnN0eWxlLnRleHRBbGlnbj0iY2VudGVyIjtudWxsIT1tJiYoYz1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoInRyeUFnYWluIiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKTttKCl9KSxjLmNsYXNzTmFtZT0iZ2VCdG4iLGYuYXBwZW5kQ2hpbGQoYyksZi5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciIpO251bGwhPWcmJihnPW14VXRpbHMuYnV0dG9uKGcsZnVuY3Rpb24oKXtudWxsIT1uJiZuKCl9KSxnLmNsYXNzTmFtZT0iZ2VCdG4iLGYuYXBwZW5kQ2hpbGQoZykpO3ZhciB2PW14VXRpbHMuYnV0dG9uKGQsZnVuY3Rpb24oKXtlJiZhLmhpZGVEaWFsb2coKTtudWxsIT1rJiZrKCl9KTsKdi5jbGFzc05hbWU9ImdlQnRuIjtmLmFwcGVuZENoaWxkKHYpO251bGwhPXEmJihkPW14VXRpbHMuYnV0dG9uKHEsZnVuY3Rpb24oKXtlJiZhLmhpZGVEaWFsb2coKTtudWxsIT1iJiZiKCl9KSxkLmNsYXNzTmFtZT0iZ2VCdG4gZ2VQcmltYXJ5QnRuIixmLmFwcGVuZENoaWxkKGQpKTt0aGlzLmluaXQ9ZnVuY3Rpb24oKXt2LmZvY3VzKCl9O2wuYXBwZW5kQ2hpbGQoZik7dGhpcy5jb250YWluZXI9bH0sUHJpbnREaWFsb2c9ZnVuY3Rpb24oYSxjKXt0aGlzLmNyZWF0ZShhLGMpfTsKUHJpbnREaWFsb2cucHJvdG90eXBlLmNyZWF0ZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBjKGEpe3ZhciBlPWIuY2hlY2tlZHx8Zy5jaGVja2VkLGQ9cGFyc2VJbnQobC52YWx1ZSkvMTAwO2lzTmFOKGQpJiYoZD0xLGwudmFsdWU9IjEwMCUiKTt2YXIgZD0uNzUqZCxjPWYucGFnZUZvcm1hdHx8bXhDb25zdGFudHMuUEFHRV9GT1JNQVRfQTRfUE9SVFJBSVQscD0xL2YucGFnZVNjYWxlO2lmKGUpe3ZhciBtPWIuY2hlY2tlZD8xOnBhcnNlSW50KG4udmFsdWUpO2lzTmFOKG0pfHwocD1teFV0aWxzLmdldFNjYWxlRm9yUGFnZUNvdW50KG0sZixjKSl9Zi5nZXRHcmFwaEJvdW5kcygpO3ZhciB2PW09MCxjPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYyk7Yy53aWR0aD1NYXRoLmNlaWwoYy53aWR0aCpkKTtjLmhlaWdodD1NYXRoLmNlaWwoYy5oZWlnaHQqZCk7cCo9ZDshZSYmZi5wYWdlVmlzaWJsZT8oZD1mLmdldFBhZ2VMYXlvdXQoKSxtLT1kLngqYy53aWR0aCx2LT1kLnkqYy5oZWlnaHQpOgplPSEwO2U9UHJpbnREaWFsb2cuY3JlYXRlUHJpbnRQcmV2aWV3KGYscCxjLDAsbSx2LGUpO2Uub3BlbigpO2EmJlByaW50RGlhbG9nLnByaW50UHJldmlldyhlKX12YXIgZj1hLmVkaXRvci5ncmFwaCxkLGssbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0YWJsZSIpO20uc3R5bGUud2lkdGg9IjEwMCUiO20uc3R5bGUuaGVpZ2h0PSIxMDAlIjt2YXIgcT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0Ym9keSIpO2Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2Iuc2V0QXR0cmlidXRlKCJ0eXBlIiwiY2hlY2tib3giKTtrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7ay5zZXRBdHRyaWJ1dGUoImNvbHNwYW4iLCIyIik7ay5zdHlsZS5mb250U2l6ZT0iMTBwdCI7ay5hcHBlbmRDaGlsZChiKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShlLCIgIitteFJlc291cmNlcy5nZXQoImZpdFBhZ2UiKSk7CmsuYXBwZW5kQ2hpbGQoZSk7bXhFdmVudC5hZGRMaXN0ZW5lcihlLCJjbGljayIsZnVuY3Rpb24oYSl7Yi5jaGVja2VkPSFiLmNoZWNrZWQ7Zy5jaGVja2VkPSFiLmNoZWNrZWQ7bXhFdmVudC5jb25zdW1lKGEpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjaGFuZ2UiLGZ1bmN0aW9uKCl7Zy5jaGVja2VkPSFiLmNoZWNrZWR9KTtkLmFwcGVuZENoaWxkKGspO3EuYXBwZW5kQ2hpbGQoZCk7ZD1kLmNsb25lTm9kZSghMSk7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtnLnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94Iik7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO2suc3R5bGUuZm9udFNpemU9IjEwcHQiO2suYXBwZW5kQ2hpbGQoZyk7ZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShlLCIgIitteFJlc291cmNlcy5nZXQoInBvc3RlclByaW50IikrIjoiKTtrLmFwcGVuZENoaWxkKGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZSwKImNsaWNrIixmdW5jdGlvbihhKXtnLmNoZWNrZWQ9IWcuY2hlY2tlZDtiLmNoZWNrZWQ9IWcuY2hlY2tlZDtteEV2ZW50LmNvbnN1bWUoYSl9KTtkLmFwcGVuZENoaWxkKGspO3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7bi5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiMSIpO24uc2V0QXR0cmlidXRlKCJ0eXBlIiwibnVtYmVyIik7bi5zZXRBdHRyaWJ1dGUoIm1pbiIsIjEiKTtuLnNldEF0dHJpYnV0ZSgic2l6ZSIsIjQiKTtuLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpO24uc3R5bGUud2lkdGg9IjUwcHgiO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtrLnN0eWxlLmZvbnRTaXplPSIxMHB0IjtrLmFwcGVuZENoaWxkKG4pO214VXRpbHMud3JpdGUoaywiICIrbXhSZXNvdXJjZXMuZ2V0KCJwYWdlcyIpKyIgKG1heCkiKTtkLmFwcGVuZENoaWxkKGspO3EuYXBwZW5kQ2hpbGQoZCk7bXhFdmVudC5hZGRMaXN0ZW5lcihnLCJjaGFuZ2UiLApmdW5jdGlvbigpe2cuY2hlY2tlZD9uLnJlbW92ZUF0dHJpYnV0ZSgiZGlzYWJsZWQiKTpuLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpO2IuY2hlY2tlZD0hZy5jaGVja2VkfSk7ZD1kLmNsb25lTm9kZSghMSk7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO214VXRpbHMud3JpdGUoayxteFJlc291cmNlcy5nZXQoInBhZ2VTY2FsZSIpKyI6Iik7ZC5hcHBlbmRDaGlsZChrKTtrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtsLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIxMDAgJSIpO2wuc2V0QXR0cmlidXRlKCJzaXplIiwiNSIpO2wuc3R5bGUud2lkdGg9IjUwcHgiO2suYXBwZW5kQ2hpbGQobCk7ZC5hcHBlbmRDaGlsZChrKTtxLmFwcGVuZENoaWxkKGQpO2Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTtrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7ay5jb2xTcGFuPTI7Cmsuc3R5bGUucGFkZGluZ1RvcD0iMjBweCI7ay5zZXRBdHRyaWJ1dGUoImFsaWduIiwicmlnaHQiKTtlPW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKX0pO2UuY2xhc3NOYW1lPSJnZUJ0biI7YS5lZGl0b3IuY2FuY2VsRmlyc3QmJmsuYXBwZW5kQ2hpbGQoZSk7aWYoUHJpbnREaWFsb2cucHJldmlld0VuYWJsZWQpe3ZhciBwPW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgicHJldmlldyIpLGZ1bmN0aW9uKCl7YS5oaWRlRGlhbG9nKCk7YyghMSl9KTtwLmNsYXNzTmFtZT0iZ2VCdG4iO2suYXBwZW5kQ2hpbGQocCl9cD1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoUHJpbnREaWFsb2cucHJldmlld0VuYWJsZWQ/InByaW50Ijoib2siKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO2MoITApfSk7cC5jbGFzc05hbWU9ImdlQnRuIGdlUHJpbWFyeUJ0biI7ay5hcHBlbmRDaGlsZChwKTthLmVkaXRvci5jYW5jZWxGaXJzdHx8CmsuYXBwZW5kQ2hpbGQoZSk7ZC5hcHBlbmRDaGlsZChrKTtxLmFwcGVuZENoaWxkKGQpO20uYXBwZW5kQ2hpbGQocSk7dGhpcy5jb250YWluZXI9bX07UHJpbnREaWFsb2cucHJpbnRQcmV2aWV3PWZ1bmN0aW9uKGEpe3RyeXtpZihudWxsIT1hLnduZCl7dmFyIGM9ZnVuY3Rpb24oKXthLnduZC5mb2N1cygpO2Eud25kLnByaW50KCk7YS53bmQuY2xvc2UoKX07bXhDbGllbnQuSVNfR0M/d2luZG93LnNldFRpbWVvdXQoYyw1MDApOmMoKX19Y2F0Y2goZil7fX07ClByaW50RGlhbG9nLmNyZWF0ZVByaW50UHJldmlldz1mdW5jdGlvbihhLGMsZixkLGssbSxxKXtjPW5ldyBteFByaW50UHJldmlldyhhLGMsZixkLGssbSk7Yy50aXRsZT1teFJlc291cmNlcy5nZXQoInByZXZpZXciKTtjLnByaW50QmFja2dyb3VuZEltYWdlPSEwO2MuYXV0b09yaWdpbj1xO2E9YS5iYWNrZ3JvdW5kO2lmKG51bGw9PWF8fCIiPT1hfHxhPT1teENvbnN0YW50cy5OT05FKWE9IiNmZmZmZmYiO2MuYmFja2dyb3VuZENvbG9yPWE7dmFyIGI9Yy53cml0ZUhlYWQ7Yy53cml0ZUhlYWQ9ZnVuY3Rpb24oYSl7Yi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS53cml0ZWxuKCc8c3R5bGUgdHlwZT0idGV4dC9jc3MiPicpO2Eud3JpdGVsbigiQG1lZGlhIHNjcmVlbiB7Iik7YS53cml0ZWxuKCIgIGJvZHkgPiBkaXYgeyBwYWRkaW5nOjMwcHg7Ym94LXNpemluZzpjb250ZW50LWJveDsgfSIpO2Eud3JpdGVsbigifSIpO2Eud3JpdGVsbigiPC9zdHlsZT4iKX07cmV0dXJuIGN9OwpQcmludERpYWxvZy5wcmV2aWV3RW5hYmxlZD0hMDsKdmFyIFBhZ2VTZXR1cERpYWxvZz1mdW5jdGlvbihhKXtmdW5jdGlvbiBjKCl7bnVsbD09bnx8bj09bXhDb25zdGFudHMuTk9ORT8oZy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiIsZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgnIitEaWFsb2cucHJvdG90eXBlLm5vQ29sb3JJbWFnZSsiJykiKTooZy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9bixnLnN0eWxlLmJhY2tncm91bmRJbWFnZT0iIil9ZnVuY3Rpb24gZigpe251bGw9PXY/KHAucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpLHAuc3R5bGUuZm9udFNpemU9IiIscC5pbm5lckhUTUw9bXhSZXNvdXJjZXMuZ2V0KCJjaGFuZ2UiKSsiLi4uIik6KHAuc2V0QXR0cmlidXRlKCJ0aXRsZSIsdi5zcmMpLHAuc3R5bGUuZm9udFNpemU9IjExcHgiLHAuaW5uZXJIVE1MPXYuc3JjLnN1YnN0cmluZygwLDQyKSsiLi4uIil9dmFyIGQ9YS5lZGl0b3IuZ3JhcGgsayxtLHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTtxLnN0eWxlLndpZHRoPQoiMTAwJSI7cS5zdHlsZS5oZWlnaHQ9IjEwMCUiO3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5Iik7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTttLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7bS5zdHlsZS5mb250U2l6ZT0iMTBwdCI7bXhVdGlscy53cml0ZShtLG14UmVzb3VyY2VzLmdldCgicGFwZXJTaXplIikrIjoiKTtrLmFwcGVuZENoaWxkKG0pO209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTttLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7bS5zdHlsZS5mb250U2l6ZT0iMTBwdCI7dmFyIGU9UGFnZVNldHVwRGlhbG9nLmFkZFBhZ2VGb3JtYXRQYW5lbChtLCJwYWdlc2V0dXBkaWFsb2ciLGQucGFnZUZvcm1hdCk7ay5hcHBlbmRDaGlsZChtKTtiLmFwcGVuZENoaWxkKGspO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTttPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7Cm14VXRpbHMud3JpdGUobSxteFJlc291cmNlcy5nZXQoImJhY2tncm91bmQiKSsiOiIpO2suYXBwZW5kQ2hpbGQobSk7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO20uc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtnLnN0eWxlLndpZHRoPSIxOHB4IjtnLnN0eWxlLmhlaWdodD0iMThweCI7Zy5zdHlsZS5tYXJnaW5SaWdodD0iMjBweCI7Zy5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249ImNlbnRlciBjZW50ZXIiO2cuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0Ijt2YXIgbj1kLmJhY2tncm91bmQ7YygpO214RXZlbnQuYWRkTGlzdGVuZXIoZywiY2xpY2siLGZ1bmN0aW9uKGIpe2EucGlja0NvbG9yKG58fCJub25lIixmdW5jdGlvbihhKXtuPWE7YygpfSk7bXhFdmVudC5jb25zdW1lKGIpfSk7Cm0uYXBwZW5kQ2hpbGQoZyk7bXhVdGlscy53cml0ZShtLG14UmVzb3VyY2VzLmdldCgiZ3JpZFNpemUiKSsiOiIpO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7bC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJudW1iZXIiKTtsLnNldEF0dHJpYnV0ZSgibWluIiwiMCIpO2wuc3R5bGUud2lkdGg9IjQwcHgiO2wuc3R5bGUubWFyZ2luTGVmdD0iNnB4IjtsLnZhbHVlPWQuZ2V0R3JpZFNpemUoKTttLmFwcGVuZENoaWxkKGwpO214RXZlbnQuYWRkTGlzdGVuZXIobCwiY2hhbmdlIixmdW5jdGlvbigpe3ZhciBhPXBhcnNlSW50KGwudmFsdWUpO2wudmFsdWU9TWF0aC5tYXgoMSxpc05hTihhKT9kLmdldEdyaWRTaXplKCk6YSl9KTtrLmFwcGVuZENoaWxkKG0pO2IuYXBwZW5kQ2hpbGQoayk7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO209ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTtteFV0aWxzLndyaXRlKG0sbXhSZXNvdXJjZXMuZ2V0KCJpbWFnZSIpKwoiOiIpO2suYXBwZW5kQ2hpbGQobSk7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO3ZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTtwLnN0eWxlLnRleHREZWNvcmF0aW9uPSJ1bmRlcmxpbmUiO3Auc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtwLnN0eWxlLmNvbG9yPSIjYTBhMGEwIjt2YXIgdj1kLmJhY2tncm91bmRJbWFnZTtteEV2ZW50LmFkZExpc3RlbmVyKHAsImNsaWNrIixmdW5jdGlvbihiKXthLnNob3dCYWNrZ3JvdW5kSW1hZ2VEaWFsb2coZnVuY3Rpb24oYSl7dj1hO2YoKX0pO214RXZlbnQuY29uc3VtZShiKX0pO2YoKTttLmFwcGVuZENoaWxkKHApO2suYXBwZW5kQ2hpbGQobSk7Yi5hcHBlbmRDaGlsZChrKTtrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIik7bT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpO20uY29sU3Bhbj0yO20uc3R5bGUucGFkZGluZ1RvcD0iMTZweCI7bS5zZXRBdHRyaWJ1dGUoImFsaWduIiwicmlnaHQiKTt2YXIgdD0KbXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpfSk7dC5jbGFzc05hbWU9ImdlQnRuIjthLmVkaXRvci5jYW5jZWxGaXJzdCYmbS5hcHBlbmRDaGlsZCh0KTt2YXIgeT1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImFwcGx5IiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKTtkLmdyaWRTaXplIT09bC52YWx1ZSYmZC5zZXRHcmlkU2l6ZShwYXJzZUludChsLnZhbHVlKSk7dmFyIGI9bmV3IENoYW5nZVBhZ2VTZXR1cChhLG4sdixlLmdldCgpKTtiLmlnbm9yZUNvbG9yPWQuYmFja2dyb3VuZD09bjtiLmlnbm9yZUltYWdlPShudWxsIT1kLmJhY2tncm91bmRJbWFnZT9kLmJhY2tncm91bmRJbWFnZS5zcmM6bnVsbCk9PT0obnVsbCE9dj92LnNyYzpudWxsKTtkLnBhZ2VGb3JtYXQud2lkdGg9PWIucHJldmlvdXNGb3JtYXQud2lkdGgmJmQucGFnZUZvcm1hdC5oZWlnaHQ9PWIucHJldmlvdXNGb3JtYXQuaGVpZ2h0JiYKYi5pZ25vcmVDb2xvciYmYi5pZ25vcmVJbWFnZXx8ZC5tb2RlbC5leGVjdXRlKGIpfSk7eS5jbGFzc05hbWU9ImdlQnRuIGdlUHJpbWFyeUJ0biI7bS5hcHBlbmRDaGlsZCh5KTthLmVkaXRvci5jYW5jZWxGaXJzdHx8bS5hcHBlbmRDaGlsZCh0KTtrLmFwcGVuZENoaWxkKG0pO2IuYXBwZW5kQ2hpbGQoayk7cS5hcHBlbmRDaGlsZChiKTt0aGlzLmNvbnRhaW5lcj1xfTsKUGFnZVNldHVwRGlhbG9nLmFkZFBhZ2VGb3JtYXRQYW5lbD1mdW5jdGlvbihhLGMsZixkKXtmdW5jdGlvbiBrKGEsZCxjKXtpZihjfHxsIT1kb2N1bWVudC5hY3RpdmVFbGVtZW50JiZwIT1kb2N1bWVudC5hY3RpdmVFbGVtZW50KXthPSExO2ZvcihkPTA7ZDx0Lmxlbmd0aDtkKyspYz10W2RdLEI/ImN1c3RvbSI9PWMua2V5JiYoYi52YWx1ZT1jLmtleSxCPSExKTpudWxsIT1jLmZvcm1hdCYmKCJhNCI9PWMua2V5PzgyNj09Zi53aWR0aD8oZj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpLGYud2lkdGg9ODI3KTo4MjY9PWYuaGVpZ2h0JiYoZj1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGYpLGYuaGVpZ2h0PTgyNyk6ImE1Ij09Yy5rZXkmJig1ODQ9PWYud2lkdGg/KGY9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShmKSxmLndpZHRoPTU4Myk6NTg0PT1mLmhlaWdodCYmKGY9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShmKSxmLmhlaWdodD01ODMpKSxmLndpZHRoPT1jLmZvcm1hdC53aWR0aCYmCmYuaGVpZ2h0PT1jLmZvcm1hdC5oZWlnaHQ/KGIudmFsdWU9Yy5rZXksbS5zZXRBdHRyaWJ1dGUoImNoZWNrZWQiLCJjaGVja2VkIiksbS5kZWZhdWx0Q2hlY2tlZD0hMCxtLmNoZWNrZWQ9ITAscS5yZW1vdmVBdHRyaWJ1dGUoImNoZWNrZWQiKSxxLmRlZmF1bHRDaGVja2VkPSExLHEuY2hlY2tlZD0hMSxhPSEwKTpmLndpZHRoPT1jLmZvcm1hdC5oZWlnaHQmJmYuaGVpZ2h0PT1jLmZvcm1hdC53aWR0aCYmKGIudmFsdWU9Yy5rZXksbS5yZW1vdmVBdHRyaWJ1dGUoImNoZWNrZWQiKSxtLmRlZmF1bHRDaGVja2VkPSExLG0uY2hlY2tlZD0hMSxxLnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKSxxLmRlZmF1bHRDaGVja2VkPSEwLGE9cS5jaGVja2VkPSEwKSk7YT8oZS5zdHlsZS5kaXNwbGF5PSIiLG4uc3R5bGUuZGlzcGxheT0ibm9uZSIpOihsLnZhbHVlPWYud2lkdGgvMTAwLHAudmFsdWU9Zi5oZWlnaHQvMTAwLG0uc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpLApiLnZhbHVlPSJjdXN0b20iLGUuc3R5bGUuZGlzcGxheT0ibm9uZSIsbi5zdHlsZS5kaXNwbGF5PSIiKX19Yz0iZm9ybWF0LSIrYzt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO20uc2V0QXR0cmlidXRlKCJuYW1lIixjKTttLnNldEF0dHJpYnV0ZSgidHlwZSIsInJhZGlvIik7bS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwicG9ydHJhaXQiKTt2YXIgcT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO3Euc2V0QXR0cmlidXRlKCJuYW1lIixjKTtxLnNldEF0dHJpYnV0ZSgidHlwZSIsInJhZGlvIik7cS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwibGFuZHNjYXBlIik7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7Yi5zdHlsZS5tYXJnaW5Cb3R0b209IjhweCI7Yi5zdHlsZS53aWR0aD0iMjAycHgiO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Uuc3R5bGUubWFyZ2luTGVmdD0iNHB4IjtlLnN0eWxlLndpZHRoPSIyMTBweCI7CmUuc3R5bGUuaGVpZ2h0PSIyNHB4IjttLnN0eWxlLm1hcmdpblJpZ2h0PSI2cHgiO2UuYXBwZW5kQ2hpbGQobSk7Yz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7Yy5zdHlsZS5tYXhXaWR0aD0iMTAwcHgiO214VXRpbHMud3JpdGUoYyxteFJlc291cmNlcy5nZXQoInBvcnRyYWl0IikpO2UuYXBwZW5kQ2hpbGQoYyk7cS5zdHlsZS5tYXJnaW5MZWZ0PSIxMHB4IjtxLnN0eWxlLm1hcmdpblJpZ2h0PSI2cHgiO2UuYXBwZW5kQ2hpbGQocSk7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO2cuc3R5bGUud2lkdGg9IjEwMHB4IjtteFV0aWxzLndyaXRlKGcsbXhSZXNvdXJjZXMuZ2V0KCJsYW5kc2NhcGUiKSk7ZS5hcHBlbmRDaGlsZChnKTt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtuLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7bi5zdHlsZS53aWR0aD0iMjEwcHgiO24uc3R5bGUuaGVpZ2h0PSIyNHB4Ijt2YXIgbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpOwpsLnNldEF0dHJpYnV0ZSgic2l6ZSIsIjciKTtsLnN0eWxlLnRleHRBbGlnbj0icmlnaHQiO24uYXBwZW5kQ2hpbGQobCk7bXhVdGlscy53cml0ZShuLCIgaW4geCAiKTt2YXIgcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO3Auc2V0QXR0cmlidXRlKCJzaXplIiwiNyIpO3Auc3R5bGUudGV4dEFsaWduPSJyaWdodCI7bi5hcHBlbmRDaGlsZChwKTtteFV0aWxzLndyaXRlKG4sIiBpbiIpO2Uuc3R5bGUuZGlzcGxheT0ibm9uZSI7bi5zdHlsZS5kaXNwbGF5PSJub25lIjtmb3IodmFyIHY9e30sdD1QYWdlU2V0dXBEaWFsb2cuZ2V0Rm9ybWF0cygpLHk9MDt5PHQubGVuZ3RoO3krKyl7dmFyIHg9dFt5XTt2W3gua2V5XT14O3ZhciBDPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpO0Muc2V0QXR0cmlidXRlKCJ2YWx1ZSIseC5rZXkpO214VXRpbHMud3JpdGUoQyx4LnRpdGxlKTtiLmFwcGVuZENoaWxkKEMpfXZhciBCPSExO2soKTthLmFwcGVuZENoaWxkKGIpO214VXRpbHMuYnIoYSk7CmEuYXBwZW5kQ2hpbGQoZSk7YS5hcHBlbmRDaGlsZChuKTt2YXIgRD1mLHo9ZnVuY3Rpb24oYSxjKXt2YXIgZz12W2IudmFsdWVdO251bGwhPWcuZm9ybWF0PyhsLnZhbHVlPWcuZm9ybWF0LndpZHRoLzEwMCxwLnZhbHVlPWcuZm9ybWF0LmhlaWdodC8xMDAsbi5zdHlsZS5kaXNwbGF5PSJub25lIixlLnN0eWxlLmRpc3BsYXk9IiIpOihlLnN0eWxlLmRpc3BsYXk9Im5vbmUiLG4uc3R5bGUuZGlzcGxheT0iIik7Zz1wYXJzZUZsb2F0KGwudmFsdWUpO2lmKGlzTmFOKGcpfHwwPj1nKWwudmFsdWU9Zi53aWR0aC8xMDA7Zz1wYXJzZUZsb2F0KHAudmFsdWUpO2lmKGlzTmFOKGcpfHwwPj1nKXAudmFsdWU9Zi5oZWlnaHQvMTAwO2c9bmV3IG14UmVjdGFuZ2xlKDAsMCxNYXRoLmZsb29yKDEwMCpwYXJzZUZsb2F0KGwudmFsdWUpKSxNYXRoLmZsb29yKDEwMCpwYXJzZUZsb2F0KHAudmFsdWUpKSk7ImN1c3RvbSIhPWIudmFsdWUmJnEuY2hlY2tlZCYmKGc9bmV3IG14UmVjdGFuZ2xlKDAsMCwKZy5oZWlnaHQsZy53aWR0aCkpO2MmJkJ8fGcud2lkdGg9PUQud2lkdGgmJmcuaGVpZ2h0PT1ELmhlaWdodHx8KEQ9ZyxudWxsIT1kJiZkKEQpKX07bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsZnVuY3Rpb24oYSl7bS5jaGVja2VkPSEwO3ooYSk7bXhFdmVudC5jb25zdW1lKGEpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihnLCJjbGljayIsZnVuY3Rpb24oYSl7cS5jaGVja2VkPSEwO3ooYSk7bXhFdmVudC5jb25zdW1lKGEpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihsLCJibHVyIix6KTtteEV2ZW50LmFkZExpc3RlbmVyKGwsImNsaWNrIix6KTtteEV2ZW50LmFkZExpc3RlbmVyKHAsImJsdXIiLHopO214RXZlbnQuYWRkTGlzdGVuZXIocCwiY2xpY2siLHopO214RXZlbnQuYWRkTGlzdGVuZXIocSwiY2hhbmdlIix6KTtteEV2ZW50LmFkZExpc3RlbmVyKG0sImNoYW5nZSIseik7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjaGFuZ2UiLGZ1bmN0aW9uKGEpe0I9ImN1c3RvbSI9PWIudmFsdWU7CnooYSwhMCl9KTt6KCk7cmV0dXJue3NldDpmdW5jdGlvbihhKXtmPWE7ayhudWxsLG51bGwsITApfSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRH0sd2lkdGhJbnB1dDpsLGhlaWdodElucHV0OnB9fTsKUGFnZVNldHVwRGlhbG9nLmdldEZvcm1hdHM9ZnVuY3Rpb24oKXtyZXR1cm5be2tleToibGV0dGVyIix0aXRsZTonVVMtTGV0dGVyICg4LDUiIHggMTEiKScsZm9ybWF0Om14Q29uc3RhbnRzLlBBR0VfRk9STUFUX0xFVFRFUl9QT1JUUkFJVH0se2tleToibGVnYWwiLHRpdGxlOidVUy1MZWdhbCAoOCw1IiB4IDE0IiknLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDg1MCwxNDAwKX0se2tleToidGFibG9pZCIsdGl0bGU6J1VTLVRhYmxvaWQgKDExIiB4IDE3IiknLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDExMDAsMTcwMCl9LHtrZXk6ImV4ZWN1dGl2ZSIsdGl0bGU6J1VTLUV4ZWN1dGl2ZSAoNyIgeCAxMCIpJyxmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCw3MDAsMUUzKX0se2tleToiYTAiLHRpdGxlOiJBMCAoODQxIG1tIHggMTE4OSBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDMzMDAsNDY4MSl9LHtrZXk6ImExIix0aXRsZToiQTEgKDU5NCBtbSB4IDg0MSBtbSkiLApmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCwyMzM5LDMzMDApfSx7a2V5OiJhMiIsdGl0bGU6IkEyICg0MjAgbW0geCA1OTQgbW0pIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCwxNjU0LDIzMzYpfSx7a2V5OiJhMyIsdGl0bGU6IkEzICgyOTcgbW0geCA0MjAgbW0pIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCwxMTY5LDE2NTQpfSx7a2V5OiJhNCIsdGl0bGU6IkE0ICgyMTAgbW0geCAyOTcgbW0pIixmb3JtYXQ6bXhDb25zdGFudHMuUEFHRV9GT1JNQVRfQTRfUE9SVFJBSVR9LHtrZXk6ImE1Iix0aXRsZToiQTUgKDE0OCBtbSB4IDIxMCBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDU4Myw4MjcpfSx7a2V5OiJhNiIsdGl0bGU6IkE2ICgxMDUgbW0geCAxNDggbW0pIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCw0MTMsNTgzKX0se2tleToiYTciLHRpdGxlOiJBNyAoNzQgbW0geCAxMDUgbW0pIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCwyOTEsNDEzKX0sCntrZXk6ImI0Iix0aXRsZToiQjQgKDI1MCBtbSB4IDM1MyBtbSkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDk4MCwxMzkwKX0se2tleToiYjUiLHRpdGxlOiJCNSAoMTc2IG1tIHggMjUwIG1tKSIsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsNjkwLDk4MCl9LHtrZXk6IjE2LTkiLHRpdGxlOiIxNjo5ICgxNjAwIHggOTAwKSIsZm9ybWF0Om5ldyBteFJlY3RhbmdsZSgwLDAsMTYwMCw5MDApfSx7a2V5OiIxNi0xMCIsdGl0bGU6IjE2OjEwICgxOTIwIHggMTIwMCkiLGZvcm1hdDpuZXcgbXhSZWN0YW5nbGUoMCwwLDE5MjAsMTIwMCl9LHtrZXk6IjQtMyIsdGl0bGU6IjQ6MyAoMTYwMCB4IDEyMDApIixmb3JtYXQ6bmV3IG14UmVjdGFuZ2xlKDAsMCwxNjAwLDEyMDApfSx7a2V5OiJjdXN0b20iLHRpdGxlOm14UmVzb3VyY2VzLmdldCgiY3VzdG9tIiksZm9ybWF0Om51bGx9XX07CnZhciBGaWxlbmFtZURpYWxvZz1mdW5jdGlvbihhLGMsZixkLGssbSxxLGIsZSxnLG4sbCl7ZT1udWxsIT1lP2U6ITA7dmFyIHAsdix0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIikseT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0Ym9keSIpO3Quc3R5bGUubWFyZ2luVG9wPSI4cHgiO3A9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTt2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRkIik7di5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3Yuc3R5bGUuZm9udFNpemU9IjEwcHQiO3Yuc3R5bGUud2lkdGg9bj8iODBweCI6IjEyMHB4IjtteFV0aWxzLndyaXRlKHYsKGt8fG14UmVzb3VyY2VzLmdldCgiZmlsZW5hbWUiKSkrIjoiKTtwLmFwcGVuZENoaWxkKHYpO3ZhciB4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7eC5zZXRBdHRyaWJ1dGUoInZhbHVlIixjfHwiIik7eC5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO3guc3R5bGUud2lkdGg9bnVsbCE9bD9sKwoicHgiOiIxODBweCI7dmFyIEM9bXhVdGlscy5idXR0b24oZixmdW5jdGlvbigpe2lmKG51bGw9PW18fG0oeC52YWx1ZSkpZSYmYS5oaWRlRGlhbG9nKCksZCh4LnZhbHVlKX0pO0MuY2xhc3NOYW1lPSJnZUJ0biBnZVByaW1hcnlCdG4iO3RoaXMuaW5pdD1mdW5jdGlvbigpe2lmKG51bGwhPWt8fG51bGw9PXEpaWYoeC5mb2N1cygpLG14Q2xpZW50LklTX0dDfHxteENsaWVudC5JU19GRnx8NTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19RVUlSS1M/eC5zZWxlY3QoKTpkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKSxHcmFwaC5maWxlU3VwcG9ydCl7dmFyIGE9dC5wYXJlbnROb2RlO2lmKG51bGwhPWEpe3ZhciBiPW51bGw7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJkcmFnbGVhdmUiLGZ1bmN0aW9uKGEpe251bGwhPWImJihiLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIixiPW51bGwpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSk7Cm14RXZlbnQuYWRkTGlzdGVuZXIoYSwiZHJhZ292ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGw9PWImJighbXhDbGllbnQuSVNfSUV8fDEwPGRvY3VtZW50LmRvY3VtZW50TW9kZSkmJihiPXgsYi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNlYmYyZjkiKTthLnN0b3BQcm9wYWdhdGlvbigpO2EucHJldmVudERlZmF1bHQoKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImRyb3AiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWImJihiLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIixiPW51bGwpOzA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywidGV4dC91cmktbGlzdCIpJiYoeC52YWx1ZT1kZWNvZGVVUklDb21wb25lbnQoYS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgidGV4dC91cmktbGlzdCIpKSxDLmNsaWNrKCkpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpfX19O3Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTsKdi5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3YuYXBwZW5kQ2hpbGQoeCk7cC5hcHBlbmRDaGlsZCh2KTtpZihudWxsIT1rfHxudWxsPT1xKXkuYXBwZW5kQ2hpbGQocCksbnVsbCE9biYmKG51bGwhPWEuZWRpdG9yLmRpYWdyYW1GaWxlVHlwZXMmJihwPUZpbGVuYW1lRGlhbG9nLmNyZWF0ZUZpbGVUeXBlcyhhLHgsYS5lZGl0b3IuZGlhZ3JhbUZpbGVUeXBlcykscC5zdHlsZS5tYXJnaW5MZWZ0PSI2cHgiLHAuc3R5bGUud2lkdGg9Ijc0cHgiLHYuYXBwZW5kQ2hpbGQocCkseC5zdHlsZS53aWR0aD1udWxsIT1sP2wtNDArInB4IjoiMTQwcHgiKSx2LmFwcGVuZENoaWxkKEZpbGVuYW1lRGlhbG9nLmNyZWF0ZVR5cGVIaW50KGEseCxuKSkpO251bGwhPXEmJihwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRyIiksdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ZCIpLHYuY29sU3Bhbj0yLHYuYXBwZW5kQ2hpbGQocSkscC5hcHBlbmRDaGlsZCh2KSx5LmFwcGVuZENoaWxkKHApKTtwPQpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO3Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTt2LmNvbFNwYW49Mjt2LnN0eWxlLnBhZGRpbmdUb3A9IjIwcHgiO3Yuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2LnNldEF0dHJpYnV0ZSgiYWxpZ24iLCJyaWdodCIpO249bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO251bGwhPWcmJmcoKX0pO24uY2xhc3NOYW1lPSJnZUJ0biI7YS5lZGl0b3IuY2FuY2VsRmlyc3QmJnYuYXBwZW5kQ2hpbGQobik7bnVsbCE9YiYmKGw9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJoZWxwIiksZnVuY3Rpb24oKXthLmVkaXRvci5ncmFwaC5vcGVuTGluayhiKX0pLGwuY2xhc3NOYW1lPSJnZUJ0biIsdi5hcHBlbmRDaGlsZChsKSk7bXhFdmVudC5hZGRMaXN0ZW5lcih4LCJrZXlwcmVzcyIsZnVuY3Rpb24oYSl7MTM9PWEua2V5Q29kZSYmQy5jbGljaygpfSk7CnYuYXBwZW5kQ2hpbGQoQyk7YS5lZGl0b3IuY2FuY2VsRmlyc3R8fHYuYXBwZW5kQ2hpbGQobik7cC5hcHBlbmRDaGlsZCh2KTt5LmFwcGVuZENoaWxkKHApO3QuYXBwZW5kQ2hpbGQoeSk7dGhpcy5jb250YWluZXI9dH07RmlsZW5hbWVEaWFsb2cuZmlsZW5hbWVIZWxwTGluaz1udWxsOwpGaWxlbmFtZURpYWxvZy5jcmVhdGVUeXBlSGludD1mdW5jdGlvbihhLGMsZil7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7ZC5zdHlsZS5jc3NUZXh0PSJ2ZXJ0aWNhbC1hbGlnbjp0b3A7aGVpZ2h0OjE2cHg7d2lkdGg6MTZweDttYXJnaW4tbGVmdDo0cHg7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGJvdHRvbTtjdXJzb3I6cG9pbnRlcjsiO214VXRpbHMuc2V0T3BhY2l0eShkLDcwKTt2YXIgaz1mdW5jdGlvbigpe2Quc2V0QXR0cmlidXRlKCJzcmMiLEVkaXRvci5oZWxwSW1hZ2UpO2Quc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJoZWxwIikpO2Zvcih2YXIgYT0wO2E8Zi5sZW5ndGg7YSsrKWlmKDA8ZlthXS5leHQubGVuZ3RoJiZjLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKGMudmFsdWUubGVuZ3RoLWZbYV0uZXh0Lmxlbmd0aC0xKT09Ii4iK2ZbYV0uZXh0KXtkLnNldEF0dHJpYnV0ZSgic3JjIiwKbXhDbGllbnQuaW1hZ2VCYXNlUGF0aCsiL3dhcm5pbmcucG5nIik7ZC5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoZlthXS50aXRsZSkpO2JyZWFrfX07bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJrZXl1cCIsayk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjaGFuZ2UiLGspO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY2xpY2siLGZ1bmN0aW9uKGMpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKCJ0aXRsZSIpO2QuZ2V0QXR0cmlidXRlKCJzcmMiKT09RWRpdG9yLmhlbHBJbWFnZT9hLmVkaXRvci5ncmFwaC5vcGVuTGluayhGaWxlbmFtZURpYWxvZy5maWxlbmFtZUhlbHBMaW5rKToiIiE9ZiYmYS5zaG93RXJyb3IobnVsbCxmLG14UmVzb3VyY2VzLmdldCgiaGVscCIpLGZ1bmN0aW9uKCl7YS5lZGl0b3IuZ3JhcGgub3BlbkxpbmsoRmlsZW5hbWVEaWFsb2cuZmlsZW5hbWVIZWxwTGluayl9LG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJvayIpLG51bGwsbnVsbCxudWxsLDM0MCw5MCk7Cm14RXZlbnQuY29uc3VtZShjKX0pO2soKTtyZXR1cm4gZH07CkZpbGVuYW1lRGlhbG9nLmNyZWF0ZUZpbGVUeXBlcz1mdW5jdGlvbihhLGMsZil7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7Zm9yKGE9MDthPGYubGVuZ3RoO2ErKyl7dmFyIGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7ay5zZXRBdHRyaWJ1dGUoInZhbHVlIixhKTtteFV0aWxzLndyaXRlKGssbXhSZXNvdXJjZXMuZ2V0KGZbYV0uZGVzY3JpcHRpb24pKyIgKC4iK2ZbYV0uZXh0ZW5zaW9uKyIpIik7ZC5hcHBlbmRDaGlsZChrKX1teEV2ZW50LmFkZExpc3RlbmVyKGQsImNoYW5nZSIsZnVuY3Rpb24oYSl7YT1mW2QudmFsdWVdLmV4dGVuc2lvbjt2YXIgbT1jLnZhbHVlLmxhc3RJbmRleE9mKCIuIik7MDxtPyhhPWZbZC52YWx1ZV0uZXh0ZW5zaW9uLGMudmFsdWU9Yy52YWx1ZS5zdWJzdHJpbmcoMCxtKzEpK2EpOmMudmFsdWU9Yy52YWx1ZSsiLiIrYTsiY3JlYXRlRXZlbnQiaW4gZG9jdW1lbnQ/KGE9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoIkhUTUxFdmVudHMiKSwKYS5pbml0RXZlbnQoImNoYW5nZSIsITEsITApLGMuZGlzcGF0Y2hFdmVudChhKSk6Yy5maXJlRXZlbnQoIm9uY2hhbmdlIil9KTthPWZ1bmN0aW9uKGEpe3ZhciBtPWMudmFsdWUubGFzdEluZGV4T2YoIi4iKTthPTA7aWYoMDxtKWZvcih2YXIgbT1jLnZhbHVlLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKG0rMSksYj0wO2I8Zi5sZW5ndGg7YisrKWlmKG09PWZbYl0uZXh0ZW5zaW9uKXthPWI7YnJlYWt9ZC52YWx1ZT1hfTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNoYW5nZSIsYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJrZXl1cCIsYSk7YSgpO3JldHVybiBkfTsKKGZ1bmN0aW9uKCl7bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoO2lmKG51bGwhPWEuY29udGFpbmVyJiYhYS50cmFuc3BhcmVudEJhY2tncm91bmQpe2lmKGEucGFnZVZpc2libGUpe3ZhciBiPXRoaXMuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHMoKTtpZihudWxsPT10aGlzLmJhY2tncm91bmRQYWdlU2hhcGUpe2Zvcih2YXIgZT1hLmNvbnRhaW5lci5maXJzdENoaWxkO251bGwhPWUmJmUubm9kZVR5cGUhPW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQ7KWU9ZS5uZXh0U2libGluZztudWxsIT1lJiYodGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlPXRoaXMuY3JlYXRlQmFja2dyb3VuZFBhZ2VTaGFwZShiKSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuc2NhbGU9MSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuaXNTaGFkb3c9IW14Q2xpZW50LklTX1FVSVJLUyx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUuZGlhbGVjdD0KbXhDb25zdGFudHMuRElBTEVDVF9TVFJJQ1RIVE1MLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5pbml0KGEuY29udGFpbmVyKSxlLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsYS5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLGUpLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5yZWRyYXcoKSx0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUubm9kZS5jbGFzc05hbWU9ImdlQmFja2dyb3VuZFBhZ2UiLG14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUsImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmRibENsaWNrKGIpfSkpLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyh0aGlzLmJhY2tncm91bmRQYWdlU2hhcGUubm9kZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfRE9XTixuZXcgbXhNb3VzZUV2ZW50KGIpKX0pLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtudWxsIT1hLnRvb2x0aXBIYW5kbGVyJiZhLnRvb2x0aXBIYW5kbGVyLmlzSGlkZU9uSG92ZXIoKSYmYS50b29sdGlwSGFuZGxlci5oaWRlKCk7YS5pc01vdXNlRG93biYmIW14RXZlbnQuaXNDb25zdW1lZChiKSYmYS5maXJlTW91c2VFdmVudChteEV2ZW50Lk1PVVNFX01PVkUsbmV3IG14TW91c2VFdmVudChiKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmZpcmVNb3VzZUV2ZW50KG14RXZlbnQuTU9VU0VfVVAsbmV3IG14TW91c2VFdmVudChiKSl9KSkpfWVsc2UgdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLnNjYWxlPTEsdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmJvdW5kcz1iLHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5yZWRyYXcoKX1lbHNlIG51bGwhPXRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZSYmKHRoaXMuYmFja2dyb3VuZFBhZ2VTaGFwZS5kZXN0cm95KCksdGhpcy5iYWNrZ3JvdW5kUGFnZVNoYXBlPQpudWxsKTt0aGlzLnZhbGlkYXRlQmFja2dyb3VuZFN0eWxlcygpfX07bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFN0eWxlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGgsYj1udWxsPT1hLmJhY2tncm91bmR8fGEuYmFja2dyb3VuZD09bXhDb25zdGFudHMuTk9ORT9hLmRlZmF1bHRQYWdlQmFja2dyb3VuZENvbG9yOmEuYmFja2dyb3VuZCxlPW51bGwhPWImJnRoaXMuZ3JpZENvbG9yIT1iLnRvTG93ZXJDYXNlKCk/dGhpcy5ncmlkQ29sb3I6IiNmZmZmZmYiLGQ9Im5vbmUiLGM9IiI7aWYoYS5pc0dyaWRFbmFibGVkKCkpe2M9MTA7bXhDbGllbnQuSVNfU1ZHPyhkPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmNyZWF0ZVN2Z0dyaWQoZSkpKSxkPXdpbmRvdy5idG9hP2J0b2EoZCk6QmFzZTY0LmVuY29kZShkLCEwKSxkPSJ1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwiK2QrIikiLGM9YS5ncmlkU2l6ZSp0aGlzLnNjYWxlKnRoaXMuZ3JpZFN0ZXBzKToKZD0idXJsKCIrdGhpcy5ncmlkSW1hZ2UrIikiO3ZhciBmPWU9MDtudWxsIT1hLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZSYmKGY9dGhpcy5nZXRCYWNrZ3JvdW5kUGFnZUJvdW5kcygpLGU9MStmLngsZj0xK2YueSk7Yz0tTWF0aC5yb3VuZChjLW14VXRpbHMubW9kKHRoaXMudHJhbnNsYXRlLngqdGhpcy5zY2FsZS1lLGMpKSsicHggIistTWF0aC5yb3VuZChjLW14VXRpbHMubW9kKHRoaXMudHJhbnNsYXRlLnkqdGhpcy5zY2FsZS1mLGMpKSsicHgifWU9YS52aWV3LmNhbnZhcztudWxsIT1lLm93bmVyU1ZHRWxlbWVudCYmKGU9ZS5vd25lclNWR0VsZW1lbnQpO251bGwhPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlPyhhLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj1jLGEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlPWQsYS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUubm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9CmIsYS5jb250YWluZXIuY2xhc3NOYW1lPSJnZURpYWdyYW1Db250YWluZXIgZ2VEaWFncmFtQmFja2Ryb3AiLGUuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJub25lIixlLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIik6KGEuY29udGFpbmVyLmNsYXNzTmFtZT0iZ2VEaWFncmFtQ29udGFpbmVyIixlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj1jLGUuc3R5bGUuYmFja2dyb3VuZENvbG9yPWIsZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9ZCl9O214R3JhcGhWaWV3LnByb3RvdHlwZS5jcmVhdGVTdmdHcmlkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmdyYXBoLmdyaWRTaXplKnRoaXMuc2NhbGU7Yjx0aGlzLm1pbkdyaWRTaXplOyliKj0yO2Zvcih2YXIgZT10aGlzLmdyaWRTdGVwcypiLGQ9W10sYz0xO2M8dGhpcy5ncmlkU3RlcHM7YysrKXt2YXIgZj1jKmI7ZC5wdXNoKCJNIDAgIitmKyIgTCAiK2UrIiAiK2YrIiBNICIrZisiIDAgTCAiK2YrIiAiK2UpfXJldHVybic8c3ZnIHdpZHRoPSInKwplKyciIGhlaWdodD0iJytlKyciIHhtbG5zPSInK214Q29uc3RhbnRzLk5TX1NWRysnIj48ZGVmcz48cGF0dGVybiBpZD0iZ3JpZCIgd2lkdGg9IicrZSsnIiBoZWlnaHQ9IicrZSsnIiBwYXR0ZXJuVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48cGF0aCBkPSInK2Quam9pbigiICIpKyciIGZpbGw9Im5vbmUiIHN0cm9rZT0iJythKyciIG9wYWNpdHk9IjAuMiIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTSAnK2UrIiAwIEwgMCAwIDAgIitlKyciIGZpbGw9Im5vbmUiIHN0cm9rZT0iJythKyciIHN0cm9rZS13aWR0aD0iMSIvPjwvcGF0dGVybj48L2RlZnM+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmlkKSIvPjwvc3ZnPid9O3ZhciBhPW14R3JhcGgucHJvdG90eXBlLnBhbkdyYXBoO214R3JhcGgucHJvdG90eXBlLnBhbkdyYXBoPWZ1bmN0aW9uKGQsYil7YS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9dGhpcy5zaGlmdFByZXZpZXcxKXt2YXIgZT0KdGhpcy52aWV3LmNhbnZhcztudWxsIT1lLm93bmVyU1ZHRWxlbWVudCYmKGU9ZS5vd25lclNWR0VsZW1lbnQpO3ZhciBjPXRoaXMuZ3JpZFNpemUqdGhpcy52aWV3LnNjYWxlKnRoaXMudmlldy5ncmlkU3RlcHMsYz0tTWF0aC5yb3VuZChjLW14VXRpbHMubW9kKHRoaXMudmlldy50cmFuc2xhdGUueCp0aGlzLnZpZXcuc2NhbGUrZCxjKSkrInB4ICIrLU1hdGgucm91bmQoYy1teFV0aWxzLm1vZCh0aGlzLnZpZXcudHJhbnNsYXRlLnkqdGhpcy52aWV3LnNjYWxlK2IsYykpKyJweCI7ZS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249Y319O214R3JhcGgucHJvdG90eXBlLnVwZGF0ZVBhZ2VCcmVha3M9ZnVuY3Rpb24oYSxiLGUpe3ZhciBkPXRoaXMudmlldy5zY2FsZSxjPXRoaXMudmlldy50cmFuc2xhdGUsZj10aGlzLnBhZ2VGb3JtYXQscD1kKnRoaXMucGFnZVNjYWxlLHY9dGhpcy52aWV3LmdldEJhY2tncm91bmRQYWdlQm91bmRzKCk7Yj12LndpZHRoO2U9di5oZWlnaHQ7dmFyIHQ9Cm5ldyBteFJlY3RhbmdsZShkKmMueCxkKmMueSxmLndpZHRoKnAsZi5oZWlnaHQqcCkseT0oYT1hJiZNYXRoLm1pbih0LndpZHRoLHQuaGVpZ2h0KT50aGlzLm1pblBhZ2VCcmVha0Rpc3QpP01hdGguY2VpbChlL3QuaGVpZ2h0KS0xOjAsbT1hP01hdGguY2VpbChiL3Qud2lkdGgpLTE6MCxrPXYueCtiLHE9di55K2U7bnVsbD09dGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcyYmMDx5JiYodGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcz1bXSk7bnVsbD09dGhpcy52ZXJ0aWNhbFBhZ2VCcmVha3MmJjA8bSYmKHRoaXMudmVydGljYWxQYWdlQnJlYWtzPVtdKTthPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe2Zvcih2YXIgYj1hPT10aGlzLmhvcml6b250YWxQYWdlQnJlYWtzP3k6bSxlPTA7ZTw9YjtlKyspe3ZhciBkPWE9PXRoaXMuaG9yaXpvbnRhbFBhZ2VCcmVha3M/W25ldyBteFBvaW50KE1hdGgucm91bmQodi54KSxNYXRoLnJvdW5kKHYueSsoZSsxKSp0LmhlaWdodCkpLApuZXcgbXhQb2ludChNYXRoLnJvdW5kKGspLE1hdGgucm91bmQodi55KyhlKzEpKnQuaGVpZ2h0KSldOltuZXcgbXhQb2ludChNYXRoLnJvdW5kKHYueCsoZSsxKSp0LndpZHRoKSxNYXRoLnJvdW5kKHYueSkpLG5ldyBteFBvaW50KE1hdGgucm91bmQodi54KyhlKzEpKnQud2lkdGgpLE1hdGgucm91bmQocSkpXTtudWxsIT1hW2VdPyhhW2VdLnBvaW50cz1kLGFbZV0ucmVkcmF3KCkpOihkPW5ldyBteFBvbHlsaW5lKGQsdGhpcy5wYWdlQnJlYWtDb2xvciksZC5kaWFsZWN0PXRoaXMuZGlhbGVjdCxkLmlzRGFzaGVkPXRoaXMucGFnZUJyZWFrRGFzaGVkLGQucG9pbnRlckV2ZW50cz0hMSxkLmluaXQodGhpcy52aWV3LmJhY2tncm91bmRQYW5lKSxkLnJlZHJhdygpLGFbZV09ZCl9Zm9yKGU9YjtlPGEubGVuZ3RoO2UrKylhW2VdLmRlc3Ryb3koKTthLnNwbGljZShiLGEubGVuZ3RoLWIpfX0pO2EodGhpcy5ob3Jpem9udGFsUGFnZUJyZWFrcyk7YSh0aGlzLnZlcnRpY2FsUGFnZUJyZWFrcyl9Owp2YXIgYz1teEdyYXBoSGFuZGxlci5wcm90b3R5cGUuc2hvdWxkUmVtb3ZlQ2VsbHNGcm9tUGFyZW50O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5zaG91bGRSZW1vdmVDZWxsc0Zyb21QYXJlbnQ9ZnVuY3Rpb24oYSxiLGUpe2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKWlmKHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5pc1ZlcnRleChiW2RdKSl7dmFyIGY9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYltkXSk7aWYobnVsbCE9ZiYmZi5yZWxhdGl2ZSlyZXR1cm4hMX1yZXR1cm4gYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBmPW14Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlcjtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVNYXJrZXI9ZnVuY3Rpb24oKXt2YXIgYT1mLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmludGVyc2VjdHM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixlKXtyZXR1cm4gdGhpcy5pc0Nvbm5lY3RpbmcoKT8KITA6bXhDZWxsTWFya2VyLnByb3RvdHlwZS5pbnRlcnNlY3RzLmFwcGx5KGEsYXJndW1lbnRzKX0pO3JldHVybiBhfTtteEdyYXBoVmlldy5wcm90b3R5cGUuY3JlYXRlQmFja2dyb3VuZFBhZ2VTaGFwZT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlU2hhcGUoYSwiI2ZmZmZmZiIsdGhpcy5ncmFwaC5kZWZhdWx0UGFnZUJvcmRlckNvbG9yKX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmdldEJhY2tncm91bmRQYWdlQm91bmRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRHcmFwaEJvdW5kcygpLGI9MDxhLndpZHRoP2EueC90aGlzLnNjYWxlLXRoaXMudHJhbnNsYXRlLng6MCxlPTA8YS5oZWlnaHQ/YS55L3RoaXMuc2NhbGUtdGhpcy50cmFuc2xhdGUueTowLGQ9dGhpcy5ncmFwaC5wYWdlRm9ybWF0LGM9dGhpcy5ncmFwaC5wYWdlU2NhbGUsZj1kLndpZHRoKmMsZD1kLmhlaWdodCpjLGM9TWF0aC5mbG9vcihNYXRoLm1pbigwLGIpL2YpLHA9TWF0aC5mbG9vcihNYXRoLm1pbigwLAplKS9kKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLngrYypmKSx0aGlzLnNjYWxlKih0aGlzLnRyYW5zbGF0ZS55K3AqZCksdGhpcy5zY2FsZSooTWF0aC5jZWlsKE1hdGgubWF4KDEsYithLndpZHRoL3RoaXMuc2NhbGUpL2YpLWMpKmYsdGhpcy5zY2FsZSooTWF0aC5jZWlsKE1hdGgubWF4KDEsZSthLmhlaWdodC90aGlzLnNjYWxlKS9kKS1wKSpkKX07dmFyIGQ9bXhHcmFwaC5wcm90b3R5cGUucGFuR3JhcGg7bXhHcmFwaC5wcm90b3R5cGUucGFuR3JhcGg9ZnVuY3Rpb24oYSxiKXtkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmRpYWxlY3Q9PW14Q29uc3RhbnRzLkRJQUxFQ1RfU1ZHfHxudWxsPT10aGlzLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZXx8dGhpcy51c2VTY3JvbGxiYXJzRm9yUGFubmluZyYmbXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuY29udGFpbmVyKXx8KHRoaXMudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUuc3R5bGUubWFyZ2luTGVmdD0KYSsicHgiLHRoaXMudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUuc3R5bGUubWFyZ2luVG9wPWIrInB4Iil9O3ZhciBrPW14UG9wdXBNZW51LnByb3RvdHlwZS5hZGRJdGVtO214UG9wdXBNZW51LnByb3RvdHlwZS5hZGRJdGVtPWZ1bmN0aW9uKGEsYixlLGQsYyxmKXt2YXIgZz1rLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsPT1mfHxmfHxteEV2ZW50LmFkZExpc3RlbmVyKGcsIm1vdXNlZG93biIsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpfSk7cmV0dXJuIGd9O3ZhciBtPW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5pc1Byb3BhZ2F0ZVNlbGVjdGlvbkNlbGw7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzUHJvcGFnYXRlU2VsZWN0aW9uQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBlLGQ9dGhpcy5ncmFwaC5tb2RlbC5nZXRQYXJlbnQoYSk7aWYoYilyZXR1cm4gZT10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKSwhdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoYSkmJgohdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoZCkmJiF0aGlzLmdyYXBoLmlzU2libGluZ1NlbGVjdGVkKGEpJiYobnVsbD09ZXx8ZS5yZWxhdGl2ZXx8IXRoaXMuZ3JhcGguaXNDb250YWluZXIoZCl8fHRoaXMuZ3JhcGguaXNQYXJ0KGEpKTtlPW0uYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKHRoaXMuZ3JhcGguaXNUYWJsZUNlbGwoYSl8fHRoaXMuZ3JhcGguaXNUYWJsZVJvdyhhKSllPWQsdGhpcy5ncmFwaC5pc1RhYmxlKGUpfHwoZT10aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudChlKSksZT0hdGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuaXNIYW5kbGVkKGUpfHx0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGEpfHx0aGlzLmdyYXBoLmlzVGFibGVDZWxsKGEpJiZ0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGQpO3JldHVybiBlfTtteFBvcHVwTWVudUhhbmRsZXIucHJvdG90eXBlLmdldENlbGxGb3JQb3B1cEV2ZW50PWZ1bmN0aW9uKGEpe2E9YS5nZXRDZWxsKCk7Zm9yKHZhciBiPQp0aGlzLmdyYXBoLmdldE1vZGVsKCksZT1iLmdldFBhcmVudChhKSxkPXRoaXMuZ3JhcGgudmlldy5nZXRTdGF0ZShlKSxjPXRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0ZWQoYSk7bnVsbCE9ZCYmKGIuaXNWZXJ0ZXgoZSl8fGIuaXNFZGdlKGUpKTspe3ZhciBmPXRoaXMuZ3JhcGguaXNDZWxsU2VsZWN0ZWQoZSksYz1jfHxmO2lmKGZ8fCFjJiYodGhpcy5ncmFwaC5pc1RhYmxlQ2VsbChhKXx8dGhpcy5ncmFwaC5pc1RhYmxlUm93KGEpKSlhPWU7ZT1iLmdldFBhcmVudChlKX1yZXR1cm4gYX19KSgpO0VkaXRvclVpPWZ1bmN0aW9uKGEsYyxmKXtteEV2ZW50U291cmNlLmNhbGwodGhpcyk7dGhpcy5kZXN0cm95RnVuY3Rpb25zPVtdO3RoaXMuZWRpdG9yPWF8fG5ldyBFZGl0b3I7dGhpcy5jb250YWluZXI9Y3x8ZG9jdW1lbnQuYm9keTt2YXIgZD10aGlzLmVkaXRvci5ncmFwaDtkLmxpZ2h0Ym94PWY7ZC51c2VDc3NUcmFuc2Zvcm1zJiYodGhpcy5sYXp5Wm9vbURlbGF5PTApO214Q2xpZW50LklTX1NWRz9teFBvcHVwTWVudS5wcm90b3R5cGUuc3VibWVudUltYWdlPSJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhDUUFKQUlBQUFQLy8vek16TXlINUJBRUFBQUFBTEFBQUFBQUpBQWtBQUFJUGhJOFdlYkhzSG9wU09WZ2IyNkFBQURzPSI6KG5ldyBJbWFnZSkuc3JjPW14UG9wdXBNZW51LnByb3RvdHlwZS5zdWJtZW51SW1hZ2U7bXhDbGllbnQuSVNfU1ZHfHxudWxsPT1teENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jb25uZWN0SW1hZ2V8fCgobmV3IEltYWdlKS5zcmM9bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY29ubmVjdEltYWdlLnNyYyk7CnRoaXMuZWRpdG9yLmNocm9tZWxlc3MmJiF0aGlzLmVkaXRvci5lZGl0YWJsZSYmKHRoaXMuZm9vdGVySGVpZ2h0PTAsZC5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZC5wYW5uaW5nSGFuZGxlci5pc0ZvcmNlUGFubmluZ0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGEuZ2V0RXZlbnQoKSl9KTt0aGlzLmFjdGlvbnM9bmV3IEFjdGlvbnModGhpcyk7dGhpcy5tZW51cz10aGlzLmNyZWF0ZU1lbnVzKCk7aWYoIWQuc3RhbmRhbG9uZSl7dGhpcy5jcmVhdGVEaXZzKCk7dGhpcy5jcmVhdGVVaSgpO3RoaXMucmVmcmVzaCgpO3ZhciBrPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGw9PWEmJihhPXdpbmRvdy5ldmVudCk7cmV0dXJuIGQuaXNFZGl0aW5nKCl8fG51bGwhPWEmJnRoaXMuaXNTZWxlY3Rpb25BbGxvd2VkKGEpfSk7dGhpcy5jb250YWluZXI9PWRvY3VtZW50LmJvZHkmJih0aGlzLm1lbnViYXJDb250YWluZXIub25zZWxlY3RzdGFydD0Kayx0aGlzLm1lbnViYXJDb250YWluZXIub25tb3VzZWRvd249ayx0aGlzLnRvb2xiYXJDb250YWluZXIub25zZWxlY3RzdGFydD1rLHRoaXMudG9vbGJhckNvbnRhaW5lci5vbm1vdXNlZG93bj1rLHRoaXMuZGlhZ3JhbUNvbnRhaW5lci5vbnNlbGVjdHN0YXJ0PWssdGhpcy5kaWFncmFtQ29udGFpbmVyLm9ubW91c2Vkb3duPWssdGhpcy5zaWRlYmFyQ29udGFpbmVyLm9uc2VsZWN0c3RhcnQ9ayx0aGlzLnNpZGViYXJDb250YWluZXIub25tb3VzZWRvd249ayx0aGlzLmZvcm1hdENvbnRhaW5lci5vbnNlbGVjdHN0YXJ0PWssdGhpcy5mb3JtYXRDb250YWluZXIub25tb3VzZWRvd249ayx0aGlzLmZvb3RlckNvbnRhaW5lci5vbnNlbGVjdHN0YXJ0PWssdGhpcy5mb290ZXJDb250YWluZXIub25tb3VzZWRvd249ayxudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmKHRoaXMudGFiQ29udGFpbmVyLm9uc2VsZWN0c3RhcnQ9aykpOyF0aGlzLmVkaXRvci5jaHJvbWVsZXNzfHx0aGlzLmVkaXRvci5lZGl0YWJsZT8KKGM9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YSl7dmFyIGI9bXhFdmVudC5nZXRTb3VyY2UoYSk7aWYoIkEiPT1iLm5vZGVOYW1lKWZvcig7bnVsbCE9Yjspe2lmKCJnZUhpbnQiPT1iLmNsYXNzTmFtZSlyZXR1cm4hMDtiPWIucGFyZW50Tm9kZX19cmV0dXJuIGsoYSl9LG14Q2xpZW50LklTX0lFJiYoInVuZGVmaW5lZCI9PT10eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PmRvY3VtZW50LmRvY3VtZW50TW9kZSk/bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmRpYWdyYW1Db250YWluZXIsImNvbnRleHRtZW51IixjKTp0aGlzLmRpYWdyYW1Db250YWluZXIub25jb250ZXh0bWVudT1jKTpkLnBhbm5pbmdIYW5kbGVyLnVzZVBvcHVwVHJpZ2dlcj0hMTtkLmluaXQodGhpcy5kaWFncmFtQ29udGFpbmVyKTtteENsaWVudC5JU19TVkcmJm51bGwhPWQudmlldy5nZXREcmF3UGFuZSgpJiYoYz1kLnZpZXcuZ2V0RHJhd1BhbmUoKS5vd25lclNWR0VsZW1lbnQsbnVsbCE9YyYmKGMuc3R5bGUucG9zaXRpb249CiJhYnNvbHV0ZSIpKTt0aGlzLmhvdmVySWNvbnM9dGhpcy5jcmVhdGVIb3Zlckljb25zKCk7aWYobnVsbCE9ZC5ncmFwaEhhbmRsZXIpe3ZhciBtPWQuZ3JhcGhIYW5kbGVyLnN0YXJ0O2QuZ3JhcGhIYW5kbGVyLnN0YXJ0PWZ1bmN0aW9uKCl7bnVsbCE9eC5ob3Zlckljb25zJiZ4LmhvdmVySWNvbnMucmVzZXQoKTttLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmRpYWdyYW1Db250YWluZXIsIm1vdXNlbW92ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5nZXRPZmZzZXQodGhpcy5kaWFncmFtQ29udGFpbmVyKTswPG14RXZlbnQuZ2V0Q2xpZW50WChhKS1iLngtdGhpcy5kaWFncmFtQ29udGFpbmVyLmNsaWVudFdpZHRofHwwPG14RXZlbnQuZ2V0Q2xpZW50WShhKS1iLnktdGhpcy5kaWFncmFtQ29udGFpbmVyLmNsaWVudEhlaWdodD90aGlzLmRpYWdyYW1Db250YWluZXIuc2V0QXR0cmlidXRlKCJ0aXRsZSIsCm14UmVzb3VyY2VzLmdldCgicGFuVG9vbHRpcCIpKTp0aGlzLmRpYWdyYW1Db250YWluZXIucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpfSkpO3ZhciBxPSExLGI9dGhpcy5ob3Zlckljb25zLmlzUmVzZXRFdmVudDt0aGlzLmhvdmVySWNvbnMuaXNSZXNldEV2ZW50PWZ1bmN0aW9uKGEsZSl7cmV0dXJuIHF8fGIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt0aGlzLmtleWRvd25IYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezMyIT1hLndoaWNofHxkLmlzRWRpdGluZygpP214RXZlbnQuaXNDb25zdW1lZChhKXx8MjchPWEua2V5Q29kZXx8dGhpcy5oaWRlRGlhbG9nKG51bGwsITApOihxPSEwLHRoaXMuaG92ZXJJY29ucy5yZXNldCgpLGQuY29udGFpbmVyLnN0eWxlLmN1cnNvcj0ibW92ZSIsZC5pc0VkaXRpbmcoKXx8bXhFdmVudC5nZXRTb3VyY2UoYSkhPWQuY29udGFpbmVyfHxteEV2ZW50LmNvbnN1bWUoYSkpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwKImtleWRvd24iLHRoaXMua2V5ZG93bkhhbmRsZXIpO3RoaXMua2V5dXBIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2QuY29udGFpbmVyLnN0eWxlLmN1cnNvcj0iIjtxPSExfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwia2V5dXAiLHRoaXMua2V5dXBIYW5kbGVyKTt2YXIgZT1kLnBhbm5pbmdIYW5kbGVyLmlzRm9yY2VQYW5uaW5nRXZlbnQ7ZC5wYW5uaW5nSGFuZGxlci5pc0ZvcmNlUGFubmluZ0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8cXx8bXhFdmVudC5pc01vdXNlRXZlbnQoYS5nZXRFdmVudCgpKSYmKHRoaXMudXNlUG9wdXBUcmlnZ2VyfHwhbXhFdmVudC5pc1BvcHVwVHJpZ2dlcihhLmdldEV2ZW50KCkpKSYmKCFteEV2ZW50LmlzQ29udHJvbERvd24oYS5nZXRFdmVudCgpKSYmbXhFdmVudC5pc1JpZ2h0TW91c2VCdXR0b24oYS5nZXRFdmVudCgpKXx8bXhFdmVudC5pc01pZGRsZU1vdXNlQnV0dG9uKGEuZ2V0RXZlbnQoKSkpfTsKdmFyIGc9ZC5jZWxsRWRpdG9yLmlzU3RvcEVkaXRpbmdFdmVudDtkLmNlbGxFZGl0b3IuaXNTdG9wRWRpdGluZ0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBnLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MTM9PWEua2V5Q29kZSYmKCFteENsaWVudC5JU19TRiYmbXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfHxteENsaWVudC5JU19NQUMmJm14RXZlbnQuaXNNZXRhRG93bihhKXx8bXhDbGllbnQuSVNfU0YmJm14RXZlbnQuaXNTaGlmdERvd24oYSkpfTt2YXIgbj1kLmlzWm9vbVdoZWVsRXZlbnQ7ZC5pc1pvb21XaGVlbEV2ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHF8fG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgbD0hMSxwPW51bGwsdj1udWxsLHQ9bnVsbCx5PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy50b29sYmFyJiZsIT1kLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpKXtmb3IodmFyIGE9dGhpcy50b29sYmFyLmNvbnRhaW5lci5maXJzdENoaWxkLApiPVtdO251bGwhPWE7KXt2YXIgZT1hLm5leHRTaWJsaW5nOzA+bXhVdGlscy5pbmRleE9mKHRoaXMudG9vbGJhci5zdGF0aWNFbGVtZW50cyxhKSYmKGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSxiLnB1c2goYSkpO2E9ZX1hPXRoaXMudG9vbGJhci5mb250TWVudTtlPXRoaXMudG9vbGJhci5zaXplTWVudTtpZihudWxsPT10KXRoaXMudG9vbGJhci5jcmVhdGVUZXh0VG9vbGJhcigpO2Vsc2V7Zm9yKHZhciBjPTA7Yzx0Lmxlbmd0aDtjKyspdGhpcy50b29sYmFyLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0W2NdKTt0aGlzLnRvb2xiYXIuZm9udE1lbnU9cDt0aGlzLnRvb2xiYXIuc2l6ZU1lbnU9dn1sPWQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCk7cD1hO3Y9ZTt0PWJ9fSkseD10aGlzLEM9ZC5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZztkLmNlbGxFZGl0b3Iuc3RhcnRFZGl0aW5nPWZ1bmN0aW9uKCl7Qy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7eSgpO2lmKGQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkpe3ZhciBhPQohMSxiPWZ1bmN0aW9uKCl7YXx8KGE9ITAsd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtmb3IodmFyIGI9ZC5nZXRTZWxlY3RlZEVsZW1lbnQoKTtudWxsIT1iJiZiLm5vZGVUeXBlIT1teENvbnN0YW50cy5OT0RFVFlQRV9FTEVNRU5UOyliPWIucGFyZW50Tm9kZTtpZihudWxsIT1iJiYoYj1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShiKSxudWxsIT1iJiZudWxsIT14LnRvb2xiYXIpKXt2YXIgZT1iLmZvbnRGYW1pbHk7IiciPT1lLmNoYXJBdCgwKSYmKGU9ZS5zdWJzdHJpbmcoMSkpOyInIj09ZS5jaGFyQXQoZS5sZW5ndGgtMSkmJihlPWUuc3Vic3RyaW5nKDAsZS5sZW5ndGgtMSkpO3gudG9vbGJhci5zZXRGb250TmFtZShlKTt4LnRvb2xiYXIuc2V0Rm9udFNpemUocGFyc2VJbnQoYi5mb250U2l6ZSkpfWE9ITF9LDApKX07bXhFdmVudC5hZGRMaXN0ZW5lcihkLmNlbGxFZGl0b3IudGV4dGFyZWEsImlucHV0IixiKTtteEV2ZW50LmFkZExpc3RlbmVyKGQuY2VsbEVkaXRvci50ZXh0YXJlYSwKInRvdWNoZW5kIixiKTtteEV2ZW50LmFkZExpc3RlbmVyKGQuY2VsbEVkaXRvci50ZXh0YXJlYSwibW91c2V1cCIsYik7bXhFdmVudC5hZGRMaXN0ZW5lcihkLmNlbGxFZGl0b3IudGV4dGFyZWEsImtleXVwIixiKTtiKCl9fTt2YXIgQj1kLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmc7ZC5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nPWZ1bmN0aW9uKGEsYil7dHJ5e0IuYXBwbHkodGhpcyxhcmd1bWVudHMpLHkoKX1jYXRjaChBKXt4LmhhbmRsZUVycm9yKEEpfX07ZC5jb250YWluZXIuc2V0QXR0cmlidXRlKCJ0YWJpbmRleCIsIjAiKTtkLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9ImRlZmF1bHQiO2lmKHdpbmRvdy5zZWxmPT09d2luZG93LnRvcCYmbnVsbCE9ZC5jb250YWluZXIucGFyZW50Tm9kZSl0cnl7ZC5jb250YWluZXIuZm9jdXMoKX1jYXRjaCh1KXt9dmFyIEQ9ZC5maXJlTW91c2VFdmVudDtkLmZpcmVNb3VzZUV2ZW50PWZ1bmN0aW9uKGEsYixlKXthPT1teEV2ZW50Lk1PVVNFX0RPV04mJgp0aGlzLmNvbnRhaW5lci5mb2N1cygpO0QuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtkLnBvcHVwTWVudUhhbmRsZXIuYXV0b0V4cGFuZD0hMDtudWxsIT10aGlzLm1lbnVzJiYoZC5wb3B1cE1lbnVIYW5kbGVyLmZhY3RvcnlNZXRob2Q9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiLGUpe3RoaXMubWVudXMuY3JlYXRlUG9wdXBNZW51KGEsYixlKX0pKTtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ZC5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCl9KSk7dGhpcy5rZXlIYW5kbGVyPXRoaXMuY3JlYXRlS2V5SGFuZGxlcihhKTt0aGlzLmdldEtleUhhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4ga2V5SGFuZGxlcn07dmFyIHo9InJvdW5kZWQgc2hhZG93IGdsYXNzIGRhc2hlZCBkYXNoUGF0dGVybiBjb21pYyBsYWJlbEJhY2tncm91bmRDb2xvciIuc3BsaXQoIiAiKSxFPSJzaGFwZSBlZGdlU3R5bGUgY3VydmVkIHJvdW5kZWQgZWxib3cgY29taWMganVtcFN0eWxlIGp1bXBTaXplIi5zcGxpdCgiICIpOwp0aGlzLnNldERlZmF1bHRTdHlsZT1mdW5jdGlvbihhKXt0cnl7dmFyIGI9ZC52aWV3LmdldFN0YXRlKGEpO2lmKG51bGwhPWIpe3ZhciBlPWEuY2xvbmUoKTtlLnN0eWxlPSIiO3ZhciBjPWQuZ2V0Q2VsbFN0eWxlKGUpO2E9W107dmFyIGU9W10sZztmb3IoZyBpbiBiLnN0eWxlKWNbZ10hPWIuc3R5bGVbZ10mJihhLnB1c2goYi5zdHlsZVtnXSksZS5wdXNoKGcpKTtmb3IodmFyIGY9ZC5nZXRNb2RlbCgpLmdldFN0eWxlKGIuY2VsbCksbD1udWxsIT1mP2Yuc3BsaXQoIjsiKTpbXSxmPTA7ZjxsLmxlbmd0aDtmKyspe3ZhciBuPWxbZl0scD1uLmluZGV4T2YoIj0iKTtpZigwPD1wKXtnPW4uc3Vic3RyaW5nKDAscCk7dmFyIHU9bi5zdWJzdHJpbmcocCsxKTtudWxsIT1jW2ddJiYibm9uZSI9PXUmJihhLnB1c2godSksZS5wdXNoKGcpKX19ZC5nZXRNb2RlbCgpLmlzRWRnZShiLmNlbGwpP2QuY3VycmVudEVkZ2VTdHlsZT17fTpkLmN1cnJlbnRWZXJ0ZXhTdHlsZT17fTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwKImtleXMiLGUsInZhbHVlcyIsYSwiY2VsbHMiLFtiLmNlbGxdKSl9fWNhdGNoKGJhKXt0aGlzLmhhbmRsZUVycm9yKGJhKX19O3RoaXMuY2xlYXJEZWZhdWx0U3R5bGU9ZnVuY3Rpb24oKXtkLmN1cnJlbnRFZGdlU3R5bGU9bXhVdGlscy5jbG9uZShkLmRlZmF1bHRFZGdlU3R5bGUpO2QuY3VycmVudFZlcnRleFN0eWxlPW14VXRpbHMuY2xvbmUoZC5kZWZhdWx0VmVydGV4U3R5bGUpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzdHlsZUNoYW5nZWQiLCJrZXlzIixbXSwidmFsdWVzIixbXSwiY2VsbHMiLFtdKSl9O3ZhciBHPVsiZm9udEZhbWlseSIsImZvbnRTaXplIiwiZm9udENvbG9yIl0sRj0iZWRnZVN0eWxlIHN0YXJ0QXJyb3cgc3RhcnRGaWxsIHN0YXJ0U2l6ZSBlbmRBcnJvdyBlbmRGaWxsIGVuZFNpemUiLnNwbGl0KCIgIiksSD1bInN0YXJ0QXJyb3cgc3RhcnRGaWxsIHN0YXJ0U2l6ZSBzb3VyY2VQZXJpbWV0ZXJTcGFjaW5nIGVuZEFycm93IGVuZEZpbGwgZW5kU2l6ZSB0YXJnZXRQZXJpbWV0ZXJTcGFjaW5nIi5zcGxpdCgiICIpLApbInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiXSxbImZpbGxDb2xvciIsImdyYWRpZW50Q29sb3IiXSxHLFsib3BhY2l0eSJdLFsiYWxpZ24iXSxbImh0bWwiXV07Zm9yKGE9MDthPEgubGVuZ3RoO2ErKylmb3IoYz0wO2M8SFthXS5sZW5ndGg7YysrKXoucHVzaChIW2FdW2NdKTtmb3IoYT0wO2E8RS5sZW5ndGg7YSsrKTA+bXhVdGlscy5pbmRleE9mKHosRVthXSkmJnoucHVzaChFW2FdKTt2YXIgSj1mdW5jdGlvbihhLGIpe3ZhciBlPWQuZ2V0TW9kZWwoKTtlLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZz1hW2NdLGY7aWYoYilmPVsiZm9udFNpemUiLCJmb250RmFtaWx5IiwiZm9udENvbG9yIl07ZWxzZXt2YXIgbj1lLmdldFN0eWxlKGcpLGw9bnVsbCE9bj9uLnNwbGl0KCI7Iik6W107Zj16LnNsaWNlKCk7Zm9yKHZhciBwPTA7cDxsLmxlbmd0aDtwKyspe3ZhciB1PWxbcF0sdD11LmluZGV4T2YoIj0iKTtpZigwPD10KXt2YXIgSz0KdS5zdWJzdHJpbmcoMCx0KSx5PW14VXRpbHMuaW5kZXhPZihmLEspOzA8PXkmJmYuc3BsaWNlKHksMSk7Zm9yKHZhciBtPTA7bTxILmxlbmd0aDttKyspe3ZhciB2PUhbbV07aWYoMDw9bXhVdGlscy5pbmRleE9mKHYsSykpZm9yKHZhciBrPTA7azx2Lmxlbmd0aDtrKyspe3ZhciB4PW14VXRpbHMuaW5kZXhPZihmLHZba10pOzA8PXgmJmYuc3BsaWNlKHgsMSl9fX19fWZvcih2YXIgQz1lLmlzRWRnZShnKSxxPUM/ZC5jdXJyZW50RWRnZVN0eWxlOmQuY3VycmVudFZlcnRleFN0eWxlLEI9ZS5nZXRTdHlsZShnKSxwPTA7cDxmLmxlbmd0aDtwKyspe3ZhciBLPWZbcF0sRD1xW0tdO251bGw9PUR8fCJzaGFwZSI9PUsmJiFDfHxDJiYhKDA+bXhVdGlscy5pbmRleE9mKEUsSykpfHwoQj1teFV0aWxzLnNldFN0eWxlKEIsSyxEKSl9ZS5zZXRTdHlsZShnLEIpfX1maW5hbGx5e2UuZW5kVXBkYXRlKCl9fTtkLmFkZExpc3RlbmVyKCJjZWxsc0luc2VydGVkIixmdW5jdGlvbihhLGIpe0ooYi5nZXRQcm9wZXJ0eSgiY2VsbHMiKSl9KTsKZC5hZGRMaXN0ZW5lcigidGV4dEluc2VydGVkIixmdW5jdGlvbihhLGIpe0ooYi5nZXRQcm9wZXJ0eSgiY2VsbHMiKSwhMCl9KTtkLmNvbm5lY3Rpb25IYW5kbGVyLmFkZExpc3RlbmVyKG14RXZlbnQuQ09OTkVDVCxmdW5jdGlvbihhLGIpe3ZhciBlPVtiLmdldFByb3BlcnR5KCJjZWxsIildO2IuZ2V0UHJvcGVydHkoInRlcm1pbmFsSW5zZXJ0ZWQiKSYmZS5wdXNoKGIuZ2V0UHJvcGVydHkoInRlcm1pbmFsIikpO0ooZSl9KTt0aGlzLmFkZExpc3RlbmVyKCJzdHlsZUNoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dmFyIGU9Yi5nZXRQcm9wZXJ0eSgiY2VsbHMiKSxjPSExLGc9ITE7aWYoMDxlLmxlbmd0aClmb3IodmFyIGY9MDtmPGUubGVuZ3RoJiYoYz1kLmdldE1vZGVsKCkuaXNWZXJ0ZXgoZVtmXSl8fGMsIShnPWQuZ2V0TW9kZWwoKS5pc0VkZ2UoZVtmXSl8fGcpfHwhYyk7ZisrKTtlbHNlIGc9Yz0hMDtmb3IodmFyIGU9Yi5nZXRQcm9wZXJ0eSgia2V5cyIpLApuPWIuZ2V0UHJvcGVydHkoInZhbHVlcyIpLGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGw9MDw9bXhVdGlscy5pbmRleE9mKEcsZVtmXSk7aWYoInN0cm9rZUNvbG9yIiE9ZVtmXXx8bnVsbCE9bltmXSYmIm5vbmUiIT1uW2ZdKWlmKDA8PW14VXRpbHMuaW5kZXhPZihFLGVbZl0pKWd8fDA8PW14VXRpbHMuaW5kZXhPZihGLGVbZl0pP251bGw9PW5bZl0/ZGVsZXRlIGQuY3VycmVudEVkZ2VTdHlsZVtlW2ZdXTpkLmN1cnJlbnRFZGdlU3R5bGVbZVtmXV09bltmXTpjJiYwPD1teFV0aWxzLmluZGV4T2YoeixlW2ZdKSYmKG51bGw9PW5bZl0/ZGVsZXRlIGQuY3VycmVudFZlcnRleFN0eWxlW2VbZl1dOmQuY3VycmVudFZlcnRleFN0eWxlW2VbZl1dPW5bZl0pO2Vsc2UgaWYoMDw9bXhVdGlscy5pbmRleE9mKHosZVtmXSkpe2lmKGN8fGwpbnVsbD09bltmXT9kZWxldGUgZC5jdXJyZW50VmVydGV4U3R5bGVbZVtmXV06ZC5jdXJyZW50VmVydGV4U3R5bGVbZVtmXV09bltmXTtpZihnfHxsfHwKMDw9bXhVdGlscy5pbmRleE9mKEYsZVtmXSkpbnVsbD09bltmXT9kZWxldGUgZC5jdXJyZW50RWRnZVN0eWxlW2VbZl1dOmQuY3VycmVudEVkZ2VTdHlsZVtlW2ZdXT1uW2ZdfX1udWxsIT10aGlzLnRvb2xiYXImJih0aGlzLnRvb2xiYXIuc2V0Rm9udE5hbWUoZC5jdXJyZW50VmVydGV4U3R5bGUuZm9udEZhbWlseXx8TWVudXMucHJvdG90eXBlLmRlZmF1bHRGb250KSx0aGlzLnRvb2xiYXIuc2V0Rm9udFNpemUoZC5jdXJyZW50VmVydGV4U3R5bGUuZm9udFNpemV8fE1lbnVzLnByb3RvdHlwZS5kZWZhdWx0Rm9udFNpemUpLG51bGwhPXRoaXMudG9vbGJhci5lZGdlU3R5bGVNZW51JiYodGhpcy50b29sYmFyLmVkZ2VTdHlsZU1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpWzBdLmNsYXNzTmFtZT0ib3J0aG9nb25hbEVkZ2VTdHlsZSI9PWQuY3VycmVudEVkZ2VTdHlsZS5lZGdlU3R5bGUmJiIxIj09ZC5jdXJyZW50RWRnZVN0eWxlLmN1cnZlZD8iZ2VTcHJpdGUgZ2VTcHJpdGUtY3VydmVkIjoKInN0cmFpZ2h0Ij09ZC5jdXJyZW50RWRnZVN0eWxlLmVkZ2VTdHlsZXx8Im5vbmUiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlfHxudWxsPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlPyJnZVNwcml0ZSBnZVNwcml0ZS1zdHJhaWdodCI6ImVudGl0eVJlbGF0aW9uRWRnZVN0eWxlIj09ZC5jdXJyZW50RWRnZVN0eWxlLmVkZ2VTdHlsZT8iZ2VTcHJpdGUgZ2VTcHJpdGUtZW50aXR5IjoiZWxib3dFZGdlU3R5bGUiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlPyJnZVNwcml0ZSBnZVNwcml0ZS0iKygidmVydGljYWwiPT1kLmN1cnJlbnRFZGdlU3R5bGUuZWxib3c/InZlcnRpY2FsZWxib3ciOiJob3Jpem9udGFsZWxib3ciKToiaXNvbWV0cmljRWRnZVN0eWxlIj09ZC5jdXJyZW50RWRnZVN0eWxlLmVkZ2VTdHlsZT8iZ2VTcHJpdGUgZ2VTcHJpdGUtIisoInZlcnRpY2FsIj09ZC5jdXJyZW50RWRnZVN0eWxlLmVsYm93PyJ2ZXJ0aWNhbGlzb21ldHJpYyI6Imhvcml6b250YWxpc29tZXRyaWMiKToKImdlU3ByaXRlIGdlU3ByaXRlLW9ydGhvZ29uYWwiKSxudWxsIT10aGlzLnRvb2xiYXIuZWRnZVNoYXBlTWVudSYmKHRoaXMudG9vbGJhci5lZGdlU2hhcGVNZW51LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKVswXS5jbGFzc05hbWU9ImxpbmsiPT1kLmN1cnJlbnRFZGdlU3R5bGUuc2hhcGU/ImdlU3ByaXRlIGdlU3ByaXRlLWxpbmtlZGdlIjoiZmxleEFycm93Ij09ZC5jdXJyZW50RWRnZVN0eWxlLnNoYXBlPyJnZVNwcml0ZSBnZVNwcml0ZS1hcnJvdyI6ImFycm93Ij09ZC5jdXJyZW50RWRnZVN0eWxlLnNoYXBlPyJnZVNwcml0ZSBnZVNwcml0ZS1zaW1wbGVhcnJvdyI6ImdlU3ByaXRlIGdlU3ByaXRlLWNvbm5lY3Rpb24iKSxudWxsIT10aGlzLnRvb2xiYXIubGluZVN0YXJ0TWVudSYmKHRoaXMudG9vbGJhci5saW5lU3RhcnRNZW51LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKVswXS5jbGFzc05hbWU9dGhpcy5nZXRDc3NDbGFzc0Zvck1hcmtlcigic3RhcnQiLGQuY3VycmVudEVkZ2VTdHlsZS5zaGFwZSwKZC5jdXJyZW50RWRnZVN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUQVJST1ddLG14VXRpbHMuZ2V0VmFsdWUoZC5jdXJyZW50RWRnZVN0eWxlLCJzdGFydEZpbGwiLCIxIikpKSxudWxsIT10aGlzLnRvb2xiYXIubGluZUVuZE1lbnUmJih0aGlzLnRvb2xiYXIubGluZUVuZE1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpWzBdLmNsYXNzTmFtZT10aGlzLmdldENzc0NsYXNzRm9yTWFya2VyKCJlbmQiLGQuY3VycmVudEVkZ2VTdHlsZS5zaGFwZSxkLmN1cnJlbnRFZGdlU3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1ddLG14VXRpbHMuZ2V0VmFsdWUoZC5jdXJyZW50RWRnZVN0eWxlLCJlbmRGaWxsIiwiMSIpKSkpfSkpO251bGwhPXRoaXMudG9vbGJhciYmKGE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1kLmN1cnJlbnRWZXJ0ZXhTdHlsZS5mb250RmFtaWx5fHwiSGVsdmV0aWNhIixiPVN0cmluZyhkLmN1cnJlbnRWZXJ0ZXhTdHlsZS5mb250U2l6ZXx8CiIxMiIpLGU9ZC5nZXRWaWV3KCkuZ2V0U3RhdGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpO251bGwhPWUmJihhPWUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRk9OVEZBTUlMWV18fGEsYj1lLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0ZPTlRTSVpFXXx8YiwxMDxhLmxlbmd0aCYmKGE9YS5zdWJzdHJpbmcoMCw4KSsiLi4uIikpO3RoaXMudG9vbGJhci5zZXRGb250TmFtZShhKTt0aGlzLnRvb2xiYXIuc2V0Rm9udFNpemUoYil9KSxkLmdldFNlbGVjdGlvbk1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsYSksZC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLGEpKTtkLmFkZExpc3RlbmVyKG14RXZlbnQuQ0VMTFNfQURERUQsZnVuY3Rpb24oYSxiKXt2YXIgZT1iLmdldFByb3BlcnR5KCJjZWxscyIpLGM9Yi5nZXRQcm9wZXJ0eSgicGFyZW50Iik7ZC5nZXRNb2RlbCgpLmlzTGF5ZXIoYykmJiFkLmlzQ2VsbFZpc2libGUoYykmJm51bGwhPWUmJjA8ZS5sZW5ndGgmJgpkLmdldE1vZGVsKCkuc2V0VmlzaWJsZShjLCEwKX0pO3RoaXMuZ2VzdHVyZUhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5jdXJyZW50TWVudSYmbXhFdmVudC5nZXRTb3VyY2UoYSkhPXRoaXMuY3VycmVudE1lbnUuZGl2JiZ0aGlzLmhpZGVDdXJyZW50TWVudSgpfSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGRvY3VtZW50LHRoaXMuZ2VzdHVyZUhhbmRsZXIpO3RoaXMucmVzaXplSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3dpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5lZGl0b3IuZ3JhcGgmJnRoaXMucmVmcmVzaCgpfSksMCl9KTtteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIix0aGlzLnJlc2l6ZUhhbmRsZXIpO3RoaXMub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWZyZXNoKCl9KTsKbXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csIm9yaWVudGF0aW9uY2hhbmdlIix0aGlzLm9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlcik7bXhDbGllbnQuSVNfSU9TJiYhd2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lJiYodGhpcy5zY3JvbGxIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7d2luZG93LnNjcm9sbFRvKDAsMCl9KSxteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywic2Nyb2xsIix0aGlzLnNjcm9sbEhhbmRsZXIpKTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicmVzZXRHcmFwaFZpZXciLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZXNldFNjcm9sbGJhcnMoKX0pKTt0aGlzLmFkZExpc3RlbmVyKCJncmlkRW5hYmxlZENoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC52aWV3LnZhbGlkYXRlQmFja2dyb3VuZCgpfSkpO3RoaXMuYWRkTGlzdGVuZXIoImJhY2tncm91bmRDb2xvckNoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe2Qudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKX0pKTtkLmFkZExpc3RlbmVyKCJncmlkU2l6ZUNoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5pc0dyaWRFbmFibGVkKCkmJmQudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKX0pKTt0aGlzLmVkaXRvci5yZXNldEdyYXBoKCl9dGhpcy5pbml0KCk7ZC5zdGFuZGFsb25lfHx0aGlzLm9wZW4oKX07bXhVdGlscy5leHRlbmQoRWRpdG9yVWksbXhFdmVudFNvdXJjZSk7RWRpdG9yVWkuY29tcGFjdFVpPSEwO0VkaXRvclVpLnByb3RvdHlwZS5zcGxpdFNpemU9bXhDbGllbnQuSVNfVE9VQ0h8fG14Q2xpZW50LklTX1BPSU5URVI/MTI6ODtFZGl0b3JVaS5wcm90b3R5cGUubWVudWJhckhlaWdodD0zMDtFZGl0b3JVaS5wcm90b3R5cGUuZm9ybWF0RW5hYmxlZD0hMDtFZGl0b3JVaS5wcm90b3R5cGUuZm9ybWF0V2lkdGg9MjQwO0VkaXRvclVpLnByb3RvdHlwZS50b29sYmFySGVpZ2h0PTM4OwpFZGl0b3JVaS5wcm90b3R5cGUuZm9vdGVySGVpZ2h0PTI4O0VkaXRvclVpLnByb3RvdHlwZS5zaWRlYmFyRm9vdGVySGVpZ2h0PTM0O0VkaXRvclVpLnByb3RvdHlwZS5oc3BsaXRQb3NpdGlvbj02NDA+PXNjcmVlbi53aWR0aD8xMTg6ImxhcmdlIiE9dXJsUGFyYW1zWyJzaWRlYmFyLWVudHJpZXMiXT8yMTI6MjQwO0VkaXRvclVpLnByb3RvdHlwZS5hbGxvd0FuaW1hdGlvbj0hMDtFZGl0b3JVaS5wcm90b3R5cGUubGlnaHRib3hNYXhGaXRTY2FsZT0yO0VkaXRvclVpLnByb3RvdHlwZS5saWdodGJveFZlcnRpY2FsRGl2aWRlcj00O0VkaXRvclVpLnByb3RvdHlwZS5oc3BsaXRDbGlja0VuYWJsZWQ9ITE7CkVkaXRvclVpLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoIWEuc3RhbmRhbG9uZSl7bXhFdmVudC5hZGRMaXN0ZW5lcihhLmNvbnRhaW5lciwic2Nyb2xsIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2EudG9vbHRpcEhhbmRsZXIuaGlkZSgpO251bGwhPWEuY29ubmVjdGlvbkhhbmRsZXImJm51bGwhPWEuY29ubmVjdGlvbkhhbmRsZXIuY29uc3RyYWludEhhbmRsZXImJmEuY29ubmVjdGlvbkhhbmRsZXIuY29uc3RyYWludEhhbmRsZXIucmVzZXQoKX0pKTthLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YS50b29sdGlwSGFuZGxlci5oaWRlKCk7dmFyIGQ9YS5nZXRSdWJiZXJiYW5kKCk7bnVsbCE9ZCYmZC5jYW5jZWwoKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGEuY29udGFpbmVyLCJrZXlkb3duIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLm9uS2V5RG93bihhKX0pKTsKbXhFdmVudC5hZGRMaXN0ZW5lcihhLmNvbnRhaW5lciwia2V5cHJlc3MiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMub25LZXlQcmVzcyhhKX0pKTt0aGlzLmFkZFVuZG9MaXN0ZW5lcigpO3RoaXMuYWRkQmVmb3JlVW5sb2FkTGlzdGVuZXIoKTthLmdldFNlbGVjdGlvbk1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZUFjdGlvblN0YXRlcygpfSkpO2EuZ2V0TW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudXBkYXRlQWN0aW9uU3RhdGVzKCl9KSk7dmFyIGM9YS5zZXREZWZhdWx0UGFyZW50LGY9dGhpczt0aGlzLmVkaXRvci5ncmFwaC5zZXREZWZhdWx0UGFyZW50PWZ1bmN0aW9uKCl7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Zi51cGRhdGVBY3Rpb25TdGF0ZXMoKX07YS5lZGl0TGluaz1mLmFjdGlvbnMuZ2V0KCJlZGl0TGluayIpLmZ1bmN0Owp0aGlzLnVwZGF0ZUFjdGlvblN0YXRlcygpO3RoaXMuaW5pdENsaXBib2FyZCgpO3RoaXMuaW5pdENhbnZhcygpO251bGwhPXRoaXMuZm9ybWF0JiZ0aGlzLmZvcm1hdC5pbml0KCl9fTtFZGl0b3JVaS5wcm90b3R5cGUub25LZXlEb3duPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuZWRpdG9yLmdyYXBoOzkhPWEud2hpY2h8fCFjLmlzRW5hYmxlZCgpfHxteEV2ZW50LmlzQWx0RG93bihhKXx8Yy5pc0VkaXRpbmcoKSYmbXhFdmVudC5pc1NoaWZ0RG93bihhKXx8KGMuaXNFZGl0aW5nKCk/Yy5zdG9wRWRpdGluZyghMSk6Yy5zZWxlY3RDZWxsKCFteEV2ZW50LmlzU2hpZnREb3duKGEpKSxteEV2ZW50LmNvbnN1bWUoYSkpfTsKRWRpdG9yVWkucHJvdG90eXBlLm9uS2V5UHJlc3M9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5lZGl0b3IuZ3JhcGg7IXRoaXMuaXNJbW1lZGlhdGVFZGl0aW5nRXZlbnQoYSl8fGMuaXNFZGl0aW5nKCl8fGMuaXNTZWxlY3Rpb25FbXB0eSgpfHwwPT09YS53aGljaHx8Mjc9PT1hLndoaWNofHxteEV2ZW50LmlzQWx0RG93bihhKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfHxteEV2ZW50LmlzTWV0YURvd24oYSl8fChjLmVzY2FwZSgpLGMuc3RhcnRFZGl0aW5nKCksbXhDbGllbnQuSVNfRkYmJihjPWMuY2VsbEVkaXRvcixjLnRleHRhcmVhLmlubmVySFRNTD1TdHJpbmcuZnJvbUNoYXJDb2RlKGEud2hpY2gpLGE9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSxhLnNlbGVjdE5vZGVDb250ZW50cyhjLnRleHRhcmVhKSxhLmNvbGxhcHNlKCExKSxjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjLnJlbW92ZUFsbFJhbmdlcygpLGMuYWRkUmFuZ2UoYSkpKX07CkVkaXRvclVpLnByb3RvdHlwZS5pc0ltbWVkaWF0ZUVkaXRpbmdFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMH07CkVkaXRvclVpLnByb3RvdHlwZS5nZXRDc3NDbGFzc0Zvck1hcmtlcj1mdW5jdGlvbihhLGMsZixkKXtyZXR1cm4iZmxleEFycm93Ij09Yz9udWxsIT1mJiZmIT1teENvbnN0YW50cy5OT05FPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImJsb2NrdHJhbnMiOiJnZVNwcml0ZSBnZVNwcml0ZS1ub2Fycm93IjoiYm94Ij09Znx8ImhhbGZDaXJjbGUiPT1mPyJnZVNwcml0ZSBnZVN2Z1Nwcml0ZSBnZVNwcml0ZS0iK2YrKCJlbmQiPT1hPyIgZ2VGbGlwU3ByaXRlIjoiIik6Zj09bXhDb25zdGFudHMuQVJST1dfQ0xBU1NJQz8iMSI9PWQ/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiY2xhc3NpYyI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiY2xhc3NpY3RyYW5zIjpmPT1teENvbnN0YW50cy5BUlJPV19DTEFTU0lDX1RISU4/IjEiPT1kPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImNsYXNzaWN0aGluIjoiZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJjbGFzc2ljdGhpbnRyYW5zIjpmPT1teENvbnN0YW50cy5BUlJPV19PUEVOPwoiZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJvcGVuIjpmPT1teENvbnN0YW50cy5BUlJPV19PUEVOX1RISU4/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsib3BlbnRoaW4iOmY9PW14Q29uc3RhbnRzLkFSUk9XX0JMT0NLPyIxIj09ZD8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJibG9jayI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiYmxvY2t0cmFucyI6Zj09bXhDb25zdGFudHMuQVJST1dfQkxPQ0tfVEhJTj8iMSI9PWQ/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiYmxvY2t0aGluIjoiZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJibG9ja3RoaW50cmFucyI6Zj09bXhDb25zdGFudHMuQVJST1dfT1ZBTD8iMSI9PWQ/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsib3ZhbCI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsib3ZhbHRyYW5zIjpmPT1teENvbnN0YW50cy5BUlJPV19ESUFNT05EPyIxIj09ZD8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJkaWFtb25kIjoiZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJkaWFtb25kdHJhbnMiOgpmPT1teENvbnN0YW50cy5BUlJPV19ESUFNT05EX1RISU4/IjEiPT1kPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErInRoaW5kaWFtb25kIjoiZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJ0aGluZGlhbW9uZHRyYW5zIjoib3BlbkFzeW5jIj09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJvcGVuYXN5bmMiOiJkYXNoIj09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJkYXNoIjoiY3Jvc3MiPT1mPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImNyb3NzIjoiYXN5bmMiPT1mPyIxIj09ZD8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJhc3luYyI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiYXN5bmN0cmFucyI6ImNpcmNsZSI9PWZ8fCJjaXJjbGVQbHVzIj09Zj8iMSI9PWR8fCJjaXJjbGUiPT1mPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImNpcmNsZSI6ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiY2lyY2xlcGx1cyI6IkVSb25lIj09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJlcm9uZSI6IkVSbWFuZE9uZSI9PQpmPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImVyb25ldG9vbmUiOiJFUm1hbnkiPT1mPyJnZVNwcml0ZSBnZVNwcml0ZS0iK2ErImVybWFueSI6IkVSb25lVG9NYW55Ij09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJlcm9uZXRvbWFueSI6IkVSemVyb1RvT25lIj09Zj8iZ2VTcHJpdGUgZ2VTcHJpdGUtIithKyJlcm9uZW9wdCI6IkVSemVyb1RvTWFueSI9PWY/ImdlU3ByaXRlIGdlU3ByaXRlLSIrYSsiZXJtYW55b3B0IjoiZ2VTcHJpdGUgZ2VTcHJpdGUtbm9hcnJvdyJ9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVNZW51cz1mdW5jdGlvbigpe3JldHVybiBudWxsfTsKRWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZVBhc3RlQWN0aW9uU3RhdGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGgsYz10aGlzLmFjdGlvbnMuZ2V0KCJwYXN0ZSIpLGY9dGhpcy5hY3Rpb25zLmdldCgicGFzdGVIZXJlIik7Yy5zZXRFbmFibGVkKHRoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpfHwhbXhDbGlwYm9hcmQuaXNFbXB0eSgpJiZhLmlzRW5hYmxlZCgpJiYhYS5pc0NlbGxMb2NrZWQoYS5nZXREZWZhdWx0UGFyZW50KCkpKTtmLnNldEVuYWJsZWQoYy5pc0VuYWJsZWQoKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaW5pdENsaXBib2FyZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYz1teENsaXBib2FyZC5jdXQ7bXhDbGlwYm9hcmQuY3V0PWZ1bmN0aW9uKGQpe2QuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCk/ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImN1dCIsITEsbnVsbCk6Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS51cGRhdGVQYXN0ZUFjdGlvblN0YXRlcygpfTtteENsaXBib2FyZC5jb3B5PWZ1bmN0aW9uKGQpe3ZhciBjPW51bGw7aWYoZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSlkb2N1bWVudC5leGVjQ29tbWFuZCgiY29weSIsITEsbnVsbCk7ZWxzZXtmb3IodmFyIGM9Y3x8ZC5nZXRTZWxlY3Rpb25DZWxscygpLGM9ZC5nZXRFeHBvcnRhYmxlQ2VsbHMoZC5tb2RlbC5nZXRUb3Btb3N0Q2VsbHMoYykpLGI9e30sZT1kLmNyZWF0ZUNlbGxMb29rdXAoYyksZz1kLmNsb25lQ2VsbHMoYyxudWxsLGIpLGY9bmV3IG14R3JhcGhNb2RlbCxsPWYuZ2V0Q2hpbGRBdChmLmdldFJvb3QoKSwKMCkscD0wO3A8Zy5sZW5ndGg7cCsrKWYuYWRkKGwsZ1twXSk7ZC51cGRhdGVDdXN0b21MaW5rcyhkLmNyZWF0ZUNlbGxNYXBwaW5nKGIsZSksZyk7bXhDbGlwYm9hcmQuaW5zZXJ0Q291bnQ9MTtteENsaXBib2FyZC5zZXRDZWxscyhnKX1hLnVwZGF0ZVBhc3RlQWN0aW9uU3RhdGVzKCk7cmV0dXJuIGN9O3ZhciBmPW14Q2xpcGJvYXJkLnBhc3RlO214Q2xpcGJvYXJkLnBhc3RlPWZ1bmN0aW9uKGQpe3ZhciBjPW51bGw7ZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKT9kb2N1bWVudC5leGVjQ29tbWFuZCgicGFzdGUiLCExLG51bGwpOmM9Zi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS51cGRhdGVQYXN0ZUFjdGlvblN0YXRlcygpO3JldHVybiBjfTt2YXIgZD10aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZzt0aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZz1mdW5jdGlvbigpe2QuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EudXBkYXRlUGFzdGVBY3Rpb25TdGF0ZXMoKX07CnZhciBrPXRoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmc7dGhpcy5lZGl0b3IuZ3JhcGguY2VsbEVkaXRvci5zdG9wRWRpdGluZz1mdW5jdGlvbihkLGMpe2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2EudXBkYXRlUGFzdGVBY3Rpb25TdGF0ZXMoKX07dGhpcy51cGRhdGVQYXN0ZUFjdGlvblN0YXRlcygpfTtFZGl0b3JVaS5wcm90b3R5cGUubGF6eVpvb21EZWxheT0yMDtFZGl0b3JVaS5wcm90b3R5cGUud2hlZWxab29tRGVsYXk9NDAwO0VkaXRvclVpLnByb3RvdHlwZS5idXR0b25ab29tRGVsYXk9NjAwOwpFZGl0b3JVaS5wcm90b3R5cGUuaW5pdENhbnZhcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoO2EudGltZXJBdXRvU2Nyb2xsPSEwO2EuZ2V0UGFnZVBhZGRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG14UG9pbnQoTWF0aC5tYXgoMCxNYXRoLnJvdW5kKChhLmNvbnRhaW5lci5vZmZzZXRXaWR0aC0zNCkvYS52aWV3LnNjYWxlKSksTWF0aC5tYXgoMCxNYXRoLnJvdW5kKChhLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQtMzQpL2Eudmlldy5zY2FsZSkpKX07YS52aWV3LmdldEJhY2tncm91bmRQYWdlQm91bmRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncmFwaC5nZXRQYWdlTGF5b3V0KCksYj10aGlzLmdyYXBoLmdldFBhZ2VTaXplKCk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSh0aGlzLnNjYWxlKih0aGlzLnRyYW5zbGF0ZS54K2EueCpiLndpZHRoKSx0aGlzLnNjYWxlKih0aGlzLnRyYW5zbGF0ZS55K2EueSpiLmhlaWdodCksdGhpcy5zY2FsZSphLndpZHRoKmIud2lkdGgsCnRoaXMuc2NhbGUqYS5oZWlnaHQqYi5oZWlnaHQpfTthLmdldFByZWZlcnJlZFBhZ2VTaXplPWZ1bmN0aW9uKGEsYixlKXthPXRoaXMuZ2V0UGFnZUxheW91dCgpO2I9dGhpcy5nZXRQYWdlU2l6ZSgpO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLGEud2lkdGgqYi53aWR0aCxhLmhlaWdodCpiLmhlaWdodCl9O3ZhciBjPW51bGwsZj10aGlzO2lmKHRoaXMuZWRpdG9yLmlzQ2hyb21lbGVzc1ZpZXcoKSl7dGhpcy5jaHJvbWVsZXNzUmVzaXplPWM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixlLGQsYyl7aWYobnVsbCE9YS5jb250YWluZXImJiFhLmlzVmlld2VyKCkpe2Q9bnVsbCE9ZD9kOjA7Yz1udWxsIT1jP2M6MDt2YXIgZz1hLnBhZ2VWaXNpYmxlP2Eudmlldy5nZXRCYWNrZ3JvdW5kUGFnZUJvdW5kcygpOmEuZ2V0R3JhcGhCb3VuZHMoKSxmPW14VXRpbHMuaGFzU2Nyb2xsYmFycyhhLmNvbnRhaW5lciksbj1hLnZpZXcudHJhbnNsYXRlLGw9YS52aWV3LnNjYWxlLHA9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShnKTsKcC54PXAueC9sLW4ueDtwLnk9cC55L2wtbi55O3Aud2lkdGgvPWw7cC5oZWlnaHQvPWw7dmFyIG49YS5jb250YWluZXIuc2Nyb2xsVG9wLHQ9YS5jb250YWluZXIuc2Nyb2xsTGVmdCx1PW14Q2xpZW50LklTX1FVSVJLU3x8ODw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPzIwOjE0O2lmKDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKXUrPTM7dmFyIEE9YS5jb250YWluZXIub2Zmc2V0V2lkdGgtdSx1PWEuY29udGFpbmVyLm9mZnNldEhlaWdodC11O2I9Yj9NYXRoLm1heCguMyxNYXRoLm1pbihlfHwxLEEvcC53aWR0aCkpOmw7ZT0oQS1iKnAud2lkdGgpLzIvYjt2YXIgeT0wPT10aGlzLmxpZ2h0Ym94VmVydGljYWxEaXZpZGVyPzA6KHUtYipwLmhlaWdodCkvdGhpcy5saWdodGJveFZlcnRpY2FsRGl2aWRlci9iO2YmJihlPU1hdGgubWF4KGUsMCkseT1NYXRoLm1heCh5LDApKTtpZihmfHxnLndpZHRoPEF8fGcuaGVpZ2h0PHUpYS52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKGIsCk1hdGguZmxvb3IoZS1wLngpLE1hdGguZmxvb3IoeS1wLnkpKSxhLmNvbnRhaW5lci5zY3JvbGxUb3A9bipiL2wsYS5jb250YWluZXIuc2Nyb2xsTGVmdD10KmIvbDtlbHNlIGlmKDAhPWR8fDAhPWMpZz1hLnZpZXcudHJhbnNsYXRlLGEudmlldy5zZXRUcmFuc2xhdGUoTWF0aC5mbG9vcihnLngrZC9sKSxNYXRoLmZsb29yKGcueStjL2wpKX19KTt0aGlzLmNocm9tZWxlc3NXaW5kb3dSZXNpemU9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmNocm9tZWxlc3NSZXNpemUoITEpfSk7dmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmNocm9tZWxlc3NXaW5kb3dSZXNpemUoITEpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsZCk7dGhpcy5kZXN0cm95RnVuY3Rpb25zLnB1c2goZnVuY3Rpb24oKXtteEV2ZW50LnJlbW92ZUxpc3RlbmVyKHdpbmRvdywicmVzaXplIixkKX0pO3RoaXMuZWRpdG9yLmFkZExpc3RlbmVyKCJyZXNldEdyYXBoVmlldyIsCm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jaHJvbWVsZXNzUmVzaXplKCEwKX0pKTt0aGlzLmFjdGlvbnMuZ2V0KCJ6b29tSW4iKS5mdW5jdD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLnpvb21JbigpO3RoaXMuY2hyb21lbGVzc1Jlc2l6ZSghMSl9KTt0aGlzLmFjdGlvbnMuZ2V0KCJ6b29tT3V0IikuZnVuY3Q9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7YS56b29tT3V0KCk7dGhpcy5jaHJvbWVsZXNzUmVzaXplKCExKX0pO2lmKCIwIiE9dXJsUGFyYW1zLnRvb2xiYXIpe3ZhciBrPUpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHVybFBhcmFtc1sidG9vbGJhci1jb25maWciXXx8Int9IikpO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5wb3NpdGlvbj0iZml4ZWQiO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiI7CnRoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuYm94U2l6aW5nPSJib3JkZXItYm94Ijt0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7dGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiMwMDAwMDAiO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUucGFkZGluZz0iMTBweCAxMHB4IDhweCAxMHB4Ijt0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmxlZnQ9YS5pc1ZpZXdlcigpPyIwIjoiNTAlIjtteENsaWVudC5JU19WTUx8fChteFV0aWxzLnNldFByZWZpeGVkU3R5bGUodGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZSwiYm9yZGVyUmFkaXVzIiwiMjBweCIpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLCJ0cmFuc2l0aW9uIiwib3BhY2l0eSA2MDBtcyBlYXNlLWluLW91dCIpKTt2YXIgbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBiPQpteFV0aWxzLmdldEN1cnJlbnRTdHlsZShhLmNvbnRhaW5lcik7YS5pc1ZpZXdlcigpP3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUudG9wPSIwIjp0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmJvdHRvbT0obnVsbCE9Yj9wYXJzZUludChiWyJtYXJnaW4tYm90dG9tIl18fDApOjApKyhudWxsIT10aGlzLnRhYkNvbnRhaW5lcj8yMCtwYXJzZUludCh0aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5oZWlnaHQpOjIwKSsicHgifSk7dGhpcy5lZGl0b3IuYWRkTGlzdGVuZXIoInJlc2V0R3JhcGhWaWV3IixtKTttKCk7dmFyIHE9MCxtPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYixlKXtxKys7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO2Quc3R5bGUucGFkZGluZ0xlZnQ9IjhweCI7ZC5zdHlsZS5wYWRkaW5nUmlnaHQ9IjhweCI7ZC5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY2xpY2siLGEpO251bGwhPWUmJmQuc2V0QXR0cmlidXRlKCJ0aXRsZSIsCmUpO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7YS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTthLnNldEF0dHJpYnV0ZSgic3JjIixiKTtkLmFwcGVuZENoaWxkKGEpO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuYXBwZW5kQ2hpbGQoZCk7cmV0dXJuIGR9KTtudWxsIT1rLmJhY2tCdG4mJm0obXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7d2luZG93LmxvY2F0aW9uLmhyZWY9ay5iYWNrQnRuLnVybDtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3IuYmFja0xhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJiYWNrIixudWxsLCJCYWNrIikpO3ZhciBiPW0obXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5hY3Rpb25zLmdldCgicHJldmlvdXNQYWdlIikuZnVuY3QoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3IucHJldmlvdXNMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgicHJldmlvdXNQYWdlIikpLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CmUuc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIjtlLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7ZS5zdHlsZS5mb250RmFtaWx5PSJIZWx2ZXRpY2EsQXJpYWwiO2Uuc3R5bGUubWFyZ2luVG9wPSI4cHgiO2Uuc3R5bGUuZm9udFNpemU9IjE0cHgiO2Uuc3R5bGUuY29sb3I9IiNmZmZmZmYiO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuYXBwZW5kQ2hpbGQoZSk7dmFyIGc9bShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGlvbnMuZ2V0KCJuZXh0UGFnZSIpLmZ1bmN0KCk7bXhFdmVudC5jb25zdW1lKGEpfSksRWRpdG9yLm5leHRMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgibmV4dFBhZ2UiKSksbj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGgmJm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJihlLmlubmVySFRNTD0iIixteFV0aWxzLndyaXRlKGUsbXhVdGlscy5pbmRleE9mKHRoaXMucGFnZXMsCnRoaXMuY3VycmVudFBhZ2UpKzErIiAvICIrdGhpcy5wYWdlcy5sZW5ndGgpKX0pO2Iuc3R5bGUucGFkZGluZ0xlZnQ9IjBweCI7Yi5zdHlsZS5wYWRkaW5nUmlnaHQ9IjRweCI7Zy5zdHlsZS5wYWRkaW5nTGVmdD0iNHB4IjtnLnN0eWxlLnBhZGRpbmdSaWdodD0iMHB4Ijt2YXIgbD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGgmJm51bGwhPXRoaXMuY3VycmVudFBhZ2U/KGcuc3R5bGUuZGlzcGxheT0iIixiLnN0eWxlLmRpc3BsYXk9IiIsZS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siKTooZy5zdHlsZS5kaXNwbGF5PSJub25lIixiLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGUuc3R5bGUuZGlzcGxheT0ibm9uZSIpO24oKX0pO3RoaXMuZWRpdG9yLmFkZExpc3RlbmVyKCJyZXNldEdyYXBoVmlldyIsbCk7dGhpcy5lZGl0b3IuYWRkTGlzdGVuZXIoInBhZ2VTZWxlY3RlZCIsbik7bShteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7dGhpcy5hY3Rpb25zLmdldCgiem9vbU91dCIpLmZ1bmN0KCk7bXhFdmVudC5jb25zdW1lKGEpfSksRWRpdG9yLnpvb21PdXRMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgiem9vbU91dCIpKyIgKEFsdCtNb3VzZXdoZWVsKSIpO20obXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5hY3Rpb25zLmdldCgiem9vbUluIikuZnVuY3QoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3Iuem9vbUluTGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoInpvb21JbiIpKyIgKEFsdCtNb3VzZXdoZWVsKSIpO20obXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7YS5pc0xpZ2h0Ym94VmlldygpPygxPT1hLnZpZXcuc2NhbGU/dGhpcy5saWdodGJveEZpdCgpOmEuem9vbVRvKDEpLHRoaXMuY2hyb21lbGVzc1Jlc2l6ZSghMSkpOnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSghMCk7bXhFdmVudC5jb25zdW1lKGIpfSksRWRpdG9yLmFjdHVhbFNpemVMYXJnZUltYWdlLApteFJlc291cmNlcy5nZXQoImZpdCIpKTt2YXIgcD1udWxsLHY9bnVsbCx0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPXAmJih3aW5kb3cuY2xlYXJUaW1lb3V0KHApLGZhZGVUaGVhZD1udWxsKTtudWxsIT12JiYod2luZG93LmNsZWFyVGltZW91dCh2KSxmYWRlVGhlYWQyPW51bGwpO3A9d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtteFV0aWxzLnNldE9wYWNpdHkodGhpcy5jaHJvbWVsZXNzVG9vbGJhciwwKTtwPW51bGw7dj13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuZGlzcGxheT0ibm9uZSI7dj1udWxsfSksNjAwKX0pLGF8fDIwMCl9KSx5PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPXAmJih3aW5kb3cuY2xlYXJUaW1lb3V0KHApLGZhZGVUaGVhZD1udWxsKTtudWxsIT12JiYod2luZG93LmNsZWFyVGltZW91dCh2KSwKZmFkZVRoZWFkMj1udWxsKTt0aGlzLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmRpc3BsYXk9IiI7bXhVdGlscy5zZXRPcGFjaXR5KHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIsYXx8MzApfSk7aWYoIjEiPT11cmxQYXJhbXMubGF5ZXJzKXt0aGlzLmxheWVyc0RpYWxvZz1udWxsO3ZhciB4PW0obXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7aWYobnVsbCE9dGhpcy5sYXllcnNEaWFsb2cpdGhpcy5sYXllcnNEaWFsb2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmxheWVyc0RpYWxvZyksdGhpcy5sYXllcnNEaWFsb2c9bnVsbDtlbHNle3RoaXMubGF5ZXJzRGlhbG9nPWEuY3JlYXRlTGF5ZXJzRGlhbG9nKCk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmxheWVyc0RpYWxvZywibW91c2VsZWF2ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmxheWVyc0RpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubGF5ZXJzRGlhbG9nKTt0aGlzLmxheWVyc0RpYWxvZz0KbnVsbH0pKTt2YXIgZT14LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmxheWVyc0RpYWxvZy5zdHlsZSwiYm9yZGVyUmFkaXVzIiwiNXB4Iik7dGhpcy5sYXllcnNEaWFsb2cuc3R5bGUucG9zaXRpb249ImZpeGVkIjt0aGlzLmxheWVyc0RpYWxvZy5zdHlsZS5mb250RmFtaWx5PSJIZWx2ZXRpY2EsQXJpYWwiO3RoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIzAwMDAwMCI7dGhpcy5sYXllcnNEaWFsb2cuc3R5bGUud2lkdGg9IjE2MHB4Ijt0aGlzLmxheWVyc0RpYWxvZy5zdHlsZS5wYWRkaW5nPSI0cHggMnB4IDRweCAycHgiO3RoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLmNvbG9yPSIjZmZmZmZmIjtteFV0aWxzLnNldE9wYWNpdHkodGhpcy5sYXllcnNEaWFsb2csNzApO3RoaXMubGF5ZXJzRGlhbG9nLnN0eWxlLmxlZnQ9ZS5sZWZ0KyJweCI7dGhpcy5sYXllcnNEaWFsb2cuc3R5bGUuYm90dG9tPXBhcnNlSW50KHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuYm90dG9tKSsKdGhpcy5jaHJvbWVsZXNzVG9vbGJhci5vZmZzZXRIZWlnaHQrNCsicHgiO2U9bXhVdGlscy5nZXRDdXJyZW50U3R5bGUodGhpcy5lZGl0b3IuZ3JhcGguY29udGFpbmVyKTt0aGlzLmxheWVyc0RpYWxvZy5zdHlsZS56SW5kZXg9ZS56SW5kZXg7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmxheWVyc0RpYWxvZyl9bXhFdmVudC5jb25zdW1lKGIpfSksRWRpdG9yLmxheWVyc0xhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJsYXllcnMiKSksQz1hLmdldE1vZGVsKCk7Qy5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxmdW5jdGlvbigpe3guc3R5bGUuZGlzcGxheT0xPEMuZ2V0Q2hpbGRDb3VudChDLnJvb3QpPyIiOiJub25lIn0pfXRoaXMuYWRkQ2hyb21lbGVzc1Rvb2xiYXJJdGVtcyhtKTtudWxsPT10aGlzLmVkaXRvci5lZGl0QnV0dG9uTGluayYmbnVsbD09dGhpcy5lZGl0b3IuZWRpdEJ1dHRvbkZ1bmN8fG0obXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bnVsbCE9CnRoaXMuZWRpdG9yLmVkaXRCdXR0b25GdW5jP3RoaXMuZWRpdG9yLmVkaXRCdXR0b25GdW5jKCk6Il9ibGFuayI9PXRoaXMuZWRpdG9yLmVkaXRCdXR0b25MaW5rP3RoaXMuZWRpdG9yLmVkaXRBc05ldyh0aGlzLmdldEVkaXRCbGFua1htbCgpKTphLm9wZW5MaW5rKHRoaXMuZWRpdG9yLmVkaXRCdXR0b25MaW5rLCJlZGl0V2luZG93Iik7bXhFdmVudC5jb25zdW1lKGIpfSksRWRpdG9yLmVkaXRMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgiZWRpdCIpKTtpZihudWxsIT10aGlzLmxpZ2h0Ym94VG9vbGJhckFjdGlvbnMpZm9yKGw9MDtsPHRoaXMubGlnaHRib3hUb29sYmFyQWN0aW9ucy5sZW5ndGg7bCsrKXt2YXIgQj10aGlzLmxpZ2h0Ym94VG9vbGJhckFjdGlvbnNbbF07bShCLmZuLEIuaWNvbixCLnRvb2x0aXApfW51bGwhPWsucmVmcmVzaEJ0biYmbShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtrLnJlZnJlc2hCdG4udXJsP3dpbmRvdy5sb2NhdGlvbi5ocmVmPWsucmVmcmVzaEJ0bi51cmw6CndpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSxFZGl0b3IucmVmcmVzaExhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJyZWZyZXNoIixudWxsLCJSZWZyZXNoIikpO251bGwhPWsuZnVsbHNjcmVlbkJ0biYmd2luZG93LnNlbGYhPT13aW5kb3cudG9wJiZtKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2suZnVsbHNjcmVlbkJ0bi51cmw/YS5vcGVuTGluayhrLmZ1bGxzY3JlZW5CdG4udXJsKTphLm9wZW5MaW5rKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtteEV2ZW50LmNvbnN1bWUoYil9KSxFZGl0b3IuZnVsbHNjcmVlbkxhcmdlSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5OZXdXaW5kb3ciLG51bGwsIk9wZW4gaW4gTmV3IFdpbmRvdyIpKTsoay5jbG9zZUJ0biYmd2luZG93LnNlbGY9PT13aW5kb3cudG9wfHxhLmxpZ2h0Ym94JiYoIjEiPT11cmxQYXJhbXMuY2xvc2V8fHRoaXMuY29udGFpbmVyIT1kb2N1bWVudC5ib2R5KSkmJm0obXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEpeyIxIj09dXJsUGFyYW1zLmNsb3NlfHxrLmNsb3NlQnRuP3dpbmRvdy5jbG9zZSgpOih0aGlzLmRlc3Ryb3koKSxteEV2ZW50LmNvbnN1bWUoYSkpfSksRWRpdG9yLmNsb3NlTGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoImNsb3NlIikrIiAoRXNjYXBlKSIpO3RoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuZGlzcGxheT0ibm9uZSI7YS5pc1ZpZXdlcigpfHxteFV0aWxzLnNldFByZWZpeGVkU3R5bGUodGhpcy5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZSwidHJhbnNmb3JtIiwidHJhbnNsYXRlKC01MCUsMCkiKTthLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNocm9tZWxlc3NUb29sYmFyKTtteEV2ZW50LmFkZExpc3RlbmVyKGEuY29udGFpbmVyLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJtb3ZlIjoibW91c2Vtb3ZlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmlzVG91Y2hFdmVudChhKXx8KG14RXZlbnQuaXNTaGlmdERvd24oYSl8fAp5KDMwKSx0KCkpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5jaHJvbWVsZXNzVG9vbGJhcixteENsaWVudC5JU19QT0lOVEVSPyJwb2ludGVybW92ZSI6Im1vdXNlbW92ZSIsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmNocm9tZWxlc3NUb29sYmFyLCJtb3VzZWVudGVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmlzU2hpZnREb3duKGEpP3QoKTp5KDEwMCl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmNocm9tZWxlc3NUb29sYmFyLCJtb3VzZW1vdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNTaGlmdERvd24oYSk/dCgpOnkoMTAwKTtteEV2ZW50LmNvbnN1bWUoYSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcih0aGlzLmNocm9tZWxlc3NUb29sYmFyLCJtb3VzZWxlYXZlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmlzVG91Y2hFdmVudChhKXx8CnkoMzApfSkpO3ZhciBEPWEuZ2V0VG9sZXJhbmNlKCk7YS5hZGRNb3VzZUxpc3RlbmVyKHtzdGFydFg6MCxzdGFydFk6MCxzY3JvbGxMZWZ0OjAsc2Nyb2xsVG9wOjAsbW91c2VEb3duOmZ1bmN0aW9uKGIsZSl7dGhpcy5zdGFydFg9ZS5nZXRHcmFwaFgoKTt0aGlzLnN0YXJ0WT1lLmdldEdyYXBoWSgpO3RoaXMuc2Nyb2xsTGVmdD1hLmNvbnRhaW5lci5zY3JvbGxMZWZ0O3RoaXMuc2Nyb2xsVG9wPWEuY29udGFpbmVyLnNjcm9sbFRvcH0sbW91c2VNb3ZlOmZ1bmN0aW9uKGEsYil7fSxtb3VzZVVwOmZ1bmN0aW9uKGIsZSl7bXhFdmVudC5pc1RvdWNoRXZlbnQoZS5nZXRFdmVudCgpKSYmTWF0aC5hYnModGhpcy5zY3JvbGxMZWZ0LWEuY29udGFpbmVyLnNjcm9sbExlZnQpPEQmJk1hdGguYWJzKHRoaXMuc2Nyb2xsVG9wLWEuY29udGFpbmVyLnNjcm9sbFRvcCk8RCYmTWF0aC5hYnModGhpcy5zdGFydFgtZS5nZXRHcmFwaFgoKSk8RCYmTWF0aC5hYnModGhpcy5zdGFydFktZS5nZXRHcmFwaFkoKSk8CkQmJigwPHBhcnNlRmxvYXQoZi5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS5vcGFjaXR5fHwwKT90KCk6eSgzMCkpfX0pfXRoaXMuZWRpdG9yLmVkaXRhYmxlfHx0aGlzLmFkZENocm9tZWxlc3NDbGlja0hhbmRsZXIoKX1lbHNlIGlmKHRoaXMuZWRpdG9yLmV4dGVuZENhbnZhcyl7dmFyIHo9YS52aWV3LnZhbGlkYXRlO2Eudmlldy52YWxpZGF0ZT1mdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyJiZteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5ncmFwaC5jb250YWluZXIpKXt2YXIgYT10aGlzLmdyYXBoLmdldFBhZ2VQYWRkaW5nKCksYj10aGlzLmdyYXBoLmdldFBhZ2VTaXplKCk7dGhpcy50cmFuc2xhdGUueD1hLngtKHRoaXMueDB8fDApKmIud2lkdGg7dGhpcy50cmFuc2xhdGUueT1hLnktKHRoaXMueTB8fDApKmIuaGVpZ2h0fXouYXBwbHkodGhpcyxhcmd1bWVudHMpfTtpZighYS5pc1ZpZXdlcigpKXt2YXIgRT1hLnNpemVEaWRDaGFuZ2U7YS5zaXplRGlkQ2hhbmdlPQpmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMuY29udGFpbmVyJiZteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5jb250YWluZXIpKXt2YXIgYj10aGlzLmdldFBhZ2VMYXlvdXQoKSxlPXRoaXMuZ2V0UGFnZVBhZGRpbmcoKSxkPXRoaXMuZ2V0UGFnZVNpemUoKSxjPU1hdGguY2VpbCgyKmUueCtiLndpZHRoKmQud2lkdGgpLGc9TWF0aC5jZWlsKDIqZS55K2IuaGVpZ2h0KmQuaGVpZ2h0KSxmPWEubWluaW11bUdyYXBoU2l6ZTtpZihudWxsPT1mfHxmLndpZHRoIT1jfHxmLmhlaWdodCE9ZylhLm1pbmltdW1HcmFwaFNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCxjLGcpO2M9ZS54LWIueCpkLndpZHRoO2U9ZS55LWIueSpkLmhlaWdodDt0aGlzLmF1dG9UcmFuc2xhdGV8fHRoaXMudmlldy50cmFuc2xhdGUueD09YyYmdGhpcy52aWV3LnRyYW5zbGF0ZS55PT1lP0UuYXBwbHkodGhpcyxhcmd1bWVudHMpOih0aGlzLmF1dG9UcmFuc2xhdGU9ITAsdGhpcy52aWV3LngwPWIueCx0aGlzLnZpZXcueTA9CmIueSxiPWEudmlldy50cmFuc2xhdGUueCxkPWEudmlldy50cmFuc2xhdGUueSxhLnZpZXcuc2V0VHJhbnNsYXRlKGMsZSksYS5jb250YWluZXIuc2Nyb2xsTGVmdCs9TWF0aC5yb3VuZCgoYy1iKSphLnZpZXcuc2NhbGUpLGEuY29udGFpbmVyLnNjcm9sbFRvcCs9TWF0aC5yb3VuZCgoZS1kKSphLnZpZXcuc2NhbGUpLHRoaXMuYXV0b1RyYW5zbGF0ZT0hMSl9ZWxzZSB0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdChteEV2ZW50LlNJWkUsImJvdW5kcyIsdGhpcy5nZXRHcmFwaEJvdW5kcygpKSl9fX12YXIgRz1hLnZpZXcuZ2V0QmFja2dyb3VuZFBhbmUoKSxGPWEudmlldy5nZXREcmF3UGFuZSgpO2EuY3VtdWxhdGl2ZVpvb21GYWN0b3I9MTt2YXIgSD1udWxsLEo9bnVsbCx1PW51bGwsSz1udWxsLEE9ZnVuY3Rpb24oYil7bnVsbCE9SCYmd2luZG93LmNsZWFyVGltZW91dChIKTt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2EuaXNNb3VzZURvd258fChIPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe2EuaXNGYXN0Wm9vbUVuYWJsZWQoKSYmKG51bGwhPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlJiZudWxsIT1hLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlJiYobXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLm5vZGUuc3R5bGUsInRyYW5zZm9ybS1vcmlnaW4iLG51bGwpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShhLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLnN0eWxlLCJ0cmFuc2Zvcm0iLG51bGwpKSxGLnN0eWxlLnRyYW5zZm9ybU9yaWdpbj0iIixHLnN0eWxlLnRyYW5zZm9ybU9yaWdpbj0iIixteENsaWVudC5JU19TRj8oRi5zdHlsZS50cmFuc2Zvcm09InNjYWxlKDEpIixHLnN0eWxlLnRyYW5zZm9ybT0ic2NhbGUoMSkiLHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Ri5zdHlsZS50cmFuc2Zvcm09IiI7Ry5zdHlsZS50cmFuc2Zvcm09IiJ9LDApKTooRi5zdHlsZS50cmFuc2Zvcm09CiIiLEcuc3R5bGUudHJhbnNmb3JtPSIiKSxhLnZpZXcuZ2V0RGVjb3JhdG9yUGFuZSgpLnN0eWxlLm9wYWNpdHk9IiIsYS52aWV3LmdldE92ZXJsYXlQYW5lKCkuc3R5bGUub3BhY2l0eT0iIik7dmFyIGI9bmV3IG14UG9pbnQoYS5jb250YWluZXIuc2Nyb2xsTGVmdCxhLmNvbnRhaW5lci5zY3JvbGxUb3ApLGU9bXhVdGlscy5nZXRPZmZzZXQoYS5jb250YWluZXIpLGQ9YS52aWV3LnNjYWxlLGc9MCxsPTA7bnVsbCE9SiYmKGc9YS5jb250YWluZXIub2Zmc2V0V2lkdGgvMi1KLngrZS54LGw9YS5jb250YWluZXIub2Zmc2V0SGVpZ2h0LzItSi55K2UueSk7YS56b29tKGEuY3VtdWxhdGl2ZVpvb21GYWN0b3IpO2Eudmlldy5zY2FsZSE9ZCYmKG51bGwhPXUmJihnKz1iLngtdS54LGwrPWIueS11LnkpLG51bGwhPWMmJmYuY2hyb21lbGVzc1Jlc2l6ZSghMSxudWxsLGcqKGEuY3VtdWxhdGl2ZVpvb21GYWN0b3ItMSksbCooYS5jdW11bGF0aXZlWm9vbUZhY3Rvci0xKSksIW14VXRpbHMuaGFzU2Nyb2xsYmFycyhhLmNvbnRhaW5lcil8fAowPT1nJiYwPT1sfHwoYS5jb250YWluZXIuc2Nyb2xsTGVmdC09ZyooYS5jdW11bGF0aXZlWm9vbUZhY3Rvci0xKSxhLmNvbnRhaW5lci5zY3JvbGxUb3AtPWwqKGEuY3VtdWxhdGl2ZVpvb21GYWN0b3ItMSkpKTtudWxsIT1LJiZGLnNldEF0dHJpYnV0ZSgiZmlsdGVyIixLKTthLmN1bXVsYXRpdmVab29tRmFjdG9yPTE7Sz1KPXU9SD1udWxsfSksbnVsbCE9Yj9iOmEuaXNGYXN0Wm9vbUVuYWJsZWQoKT9mLndoZWVsWm9vbURlbGF5OmYubGF6eVpvb21EZWxheSkpfSwwKX07YS5sYXp5Wm9vbT1mdW5jdGlvbihiLGUsZCl7KGU9ZXx8IWEuc2Nyb2xsYmFycykmJihKPW5ldyBteFBvaW50KGEuY29udGFpbmVyLm9mZnNldExlZnQrYS5jb250YWluZXIuY2xpZW50V2lkdGgvMixhLmNvbnRhaW5lci5vZmZzZXRUb3ArYS5jb250YWluZXIuY2xpZW50SGVpZ2h0LzIpKTtiPy4xNT49dGhpcy52aWV3LnNjYWxlKnRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3I/dGhpcy5jdW11bGF0aXZlWm9vbUZhY3Rvcio9Cih0aGlzLnZpZXcuc2NhbGUrLjA1KS90aGlzLnZpZXcuc2NhbGU6KHRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IqPXRoaXMuem9vbUZhY3Rvcix0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yPU1hdGgucm91bmQodGhpcy52aWV3LnNjYWxlKnRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IqMjApLzIwL3RoaXMudmlldy5zY2FsZSk6LjE1Pj10aGlzLnZpZXcuc2NhbGUqdGhpcy5jdW11bGF0aXZlWm9vbUZhY3Rvcj90aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yKj0odGhpcy52aWV3LnNjYWxlLS4wNSkvdGhpcy52aWV3LnNjYWxlOih0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yLz10aGlzLnpvb21GYWN0b3IsdGhpcy5jdW11bGF0aXZlWm9vbUZhY3Rvcj1NYXRoLnJvdW5kKHRoaXMudmlldy5zY2FsZSp0aGlzLmN1bXVsYXRpdmVab29tRmFjdG9yKjIwKS8yMC90aGlzLnZpZXcuc2NhbGUpO3RoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3I9TWF0aC5tYXgoLjA1LE1hdGgubWluKHRoaXMudmlldy5zY2FsZSoKdGhpcy5jdW11bGF0aXZlWm9vbUZhY3RvciwxNjApKS90aGlzLnZpZXcuc2NhbGU7aWYoYS5pc0Zhc3Rab29tRW5hYmxlZCgpKXtudWxsPT1LJiYiIiE9Ri5nZXRBdHRyaWJ1dGUoImZpbHRlciIpJiYoSz1GLmdldEF0dHJpYnV0ZSgiZmlsdGVyIiksRi5yZW1vdmVBdHRyaWJ1dGUoImZpbHRlciIpKTt1PW5ldyBteFBvaW50KGEuY29udGFpbmVyLnNjcm9sbExlZnQsYS5jb250YWluZXIuc2Nyb2xsVG9wKTtiPWU/YS5jb250YWluZXIuc2Nyb2xsTGVmdCthLmNvbnRhaW5lci5jbGllbnRXaWR0aC8yOkoueCthLmNvbnRhaW5lci5zY3JvbGxMZWZ0LWEuY29udGFpbmVyLm9mZnNldExlZnQ7dmFyIGM9ZT9hLmNvbnRhaW5lci5zY3JvbGxUb3ArYS5jb250YWluZXIuY2xpZW50SGVpZ2h0LzI6Si55K2EuY29udGFpbmVyLnNjcm9sbFRvcC1hLmNvbnRhaW5lci5vZmZzZXRUb3A7Ri5zdHlsZS50cmFuc2Zvcm1PcmlnaW49YisicHggIitjKyJweCI7Ri5zdHlsZS50cmFuc2Zvcm09InNjYWxlKCIrCnRoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IrIikiO0cuc3R5bGUudHJhbnNmb3JtT3JpZ2luPWIrInB4ICIrYysicHgiO0cuc3R5bGUudHJhbnNmb3JtPSJzY2FsZSgiK3RoaXMuY3VtdWxhdGl2ZVpvb21GYWN0b3IrIikiO251bGwhPWEudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlJiZudWxsIT1hLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlJiYoYj1hLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZS5ub2RlLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShiLnN0eWxlLCJ0cmFuc2Zvcm0tb3JpZ2luIiwoZT9hLmNvbnRhaW5lci5jbGllbnRXaWR0aC8yK2EuY29udGFpbmVyLnNjcm9sbExlZnQtYi5vZmZzZXRMZWZ0KyJweCI6Si54K2EuY29udGFpbmVyLnNjcm9sbExlZnQtYi5vZmZzZXRMZWZ0LWEuY29udGFpbmVyLm9mZnNldExlZnQrInB4IikrIiAiKyhlP2EuY29udGFpbmVyLmNsaWVudEhlaWdodC8yK2EuY29udGFpbmVyLnNjcm9sbFRvcC1iLm9mZnNldFRvcCsicHgiOkoueSsKYS5jb250YWluZXIuc2Nyb2xsVG9wLWIub2Zmc2V0VG9wLWEuY29udGFpbmVyLm9mZnNldFRvcCsicHgiKSksbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGIuc3R5bGUsInRyYW5zZm9ybSIsInNjYWxlKCIrdGhpcy5jdW11bGF0aXZlWm9vbUZhY3RvcisiKSIpKTthLnZpZXcuZ2V0RGVjb3JhdG9yUGFuZSgpLnN0eWxlLm9wYWNpdHk9IjAiO2Eudmlldy5nZXRPdmVybGF5UGFuZSgpLnN0eWxlLm9wYWNpdHk9IjAiO251bGwhPWYuaG92ZXJJY29ucyYmZi5ob3Zlckljb25zLnJlc2V0KCl9QShkKX07bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGEuY29udGFpbmVyLGZ1bmN0aW9uKGEpe251bGwhPUgmJndpbmRvdy5jbGVhclRpbWVvdXQoSCl9LG51bGwsZnVuY3Rpb24oYil7MSE9YS5jdW11bGF0aXZlWm9vbUZhY3RvciYmQSgwKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYS5jb250YWluZXIsInNjcm9sbCIsZnVuY3Rpb24oKXtIJiYhYS5pc01vdXNlRG93biYmMSE9YS5jdW11bGF0aXZlWm9vbUZhY3RvciYmCkEoMCl9KTtteEV2ZW50LmFkZE1vdXNlV2hlZWxMaXN0ZW5lcihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGUsZCl7aWYobnVsbD09dGhpcy5kaWFsb2dzfHwwPT10aGlzLmRpYWxvZ3MubGVuZ3RoKWlmKCFhLnNjcm9sbGJhcnMmJmEuaXNTY3JvbGxXaGVlbEV2ZW50KGIpKXtkPWEudmlldy5nZXRUcmFuc2xhdGUoKTt2YXIgYz00MC9hLnZpZXcuc2NhbGU7bXhFdmVudC5pc1NoaWZ0RG93bihiKT9hLnZpZXcuc2V0VHJhbnNsYXRlKGQueCsoZT8tYzpjKSxkLnkpOmEudmlldy5zZXRUcmFuc2xhdGUoZC54LGQueSsoZT9jOi1jKSl9ZWxzZSBpZihkfHxhLmlzWm9vbVdoZWVsRXZlbnQoYikpZm9yKGQ9bXhFdmVudC5nZXRTb3VyY2UoYik7bnVsbCE9ZDspe2lmKGQ9PWEuY29udGFpbmVyKXJldHVybiBhLnRvb2x0aXBIYW5kbGVyLmhpZGVUb29sdGlwKCksSj1uZXcgbXhQb2ludChteEV2ZW50LmdldENsaWVudFgoYiksbXhFdmVudC5nZXRDbGllbnRZKGIpKSxhLmxhenlab29tKGUpLApteEV2ZW50LmNvbnN1bWUoYiksITE7ZD1kLnBhcmVudE5vZGV9fSksYS5jb250YWluZXIpO2EucGFubmluZ0hhbmRsZXIuem9vbUdyYXBoPWZ1bmN0aW9uKGIpe2EuY3VtdWxhdGl2ZVpvb21GYWN0b3I9Yi5zY2FsZTthLmxhenlab29tKDA8Yi5zY2FsZSwhMCk7bXhFdmVudC5jb25zdW1lKGIpfX07RWRpdG9yVWkucHJvdG90eXBlLmFkZENocm9tZWxlc3NUb29sYmFySXRlbXM9ZnVuY3Rpb24oYSl7YShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGlvbnMuZ2V0KCJwcmludCIpLmZ1bmN0KCk7bXhFdmVudC5jb25zdW1lKGEpfSksRWRpdG9yLnByaW50TGFyZ2VJbWFnZSxteFJlc291cmNlcy5nZXQoInByaW50IikpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVRlbXBvcmFyeUdyYXBoPWZ1bmN0aW9uKGEpe2E9bmV3IEdyYXBoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLG51bGwsbnVsbCxhKTthLnJlc2V0Vmlld09uUm9vdENoYW5nZT0hMTthLnNldENvbm5lY3RhYmxlKCExKTthLmdyaWRFbmFibGVkPSExO2EuYXV0b1Njcm9sbD0hMTthLnNldFRvb2x0aXBzKCExKTthLnNldEVuYWJsZWQoITEpO2EuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiI7YS5jb250YWluZXIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIjthLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjthLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9IjFweCI7YS5jb250YWluZXIuc3R5bGUud2lkdGg9IjFweCI7cmV0dXJuIGF9OwpFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ2hyb21lbGVzc0NsaWNrSGFuZGxlcj1mdW5jdGlvbigpe3ZhciBhPXVybFBhcmFtcy5oaWdobGlnaHQ7bnVsbCE9YSYmMDxhLmxlbmd0aCYmKGE9IiMiK2EpO3RoaXMuZWRpdG9yLmdyYXBoLmFkZENsaWNrSGFuZGxlcihhKX07RWRpdG9yVWkucHJvdG90eXBlLnRvZ2dsZUZvcm1hdFBhbmVsPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOjA9PXRoaXMuZm9ybWF0V2lkdGg7bnVsbCE9dGhpcy5mb3JtYXQmJih0aGlzLmZvcm1hdFdpZHRoPWE/MjQwOjAsdGhpcy5mb3JtYXRDb250YWluZXIuc3R5bGUuZGlzcGxheT1hPyIiOiJub25lIix0aGlzLnJlZnJlc2goKSx0aGlzLmZvcm1hdC5yZWZyZXNoKCksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImZvcm1hdFdpZHRoQ2hhbmdlZCIpKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUubGlnaHRib3hGaXQ9ZnVuY3Rpb24oYSl7aWYodGhpcy5pc0RpYWdyYW1FbXB0eSgpKXRoaXMuZWRpdG9yLmdyYXBoLnZpZXcuc2V0U2NhbGUoMSk7ZWxzZXt2YXIgYz11cmxQYXJhbXMuYm9yZGVyLGY9NjA7bnVsbCE9YyYmKGY9cGFyc2VJbnQoYykpO3RoaXMuZWRpdG9yLmdyYXBoLm1heEZpdFNjYWxlPXRoaXMubGlnaHRib3hNYXhGaXRTY2FsZTt0aGlzLmVkaXRvci5ncmFwaC5maXQoZixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsYSk7dGhpcy5lZGl0b3IuZ3JhcGgubWF4Rml0U2NhbGU9bnVsbH19O0VkaXRvclVpLnByb3RvdHlwZS5pc0RpYWdyYW1FbXB0eT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoLmdldE1vZGVsKCk7cmV0dXJuIDE9PWEuZ2V0Q2hpbGRDb3VudChhLnJvb3QpJiYwPT1hLmdldENoaWxkQ291bnQoYS5nZXRDaGlsZEF0KGEucm9vdCwwKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaXNTZWxlY3Rpb25BbGxvd2VkPWZ1bmN0aW9uKGEpe3JldHVybiJTRUxFQ1QiPT1teEV2ZW50LmdldFNvdXJjZShhKS5ub2RlTmFtZXx8IklOUFVUIj09bXhFdmVudC5nZXRTb3VyY2UoYSkubm9kZU5hbWUmJm14VXRpbHMuaXNBbmNlc3Rvck5vZGUodGhpcy5mb3JtYXRDb250YWluZXIsbXhFdmVudC5nZXRTb3VyY2UoYSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkQmVmb3JlVW5sb2FkTGlzdGVuZXI9ZnVuY3Rpb24oKXt3aW5kb3cub25iZWZvcmV1bmxvYWQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZighdGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpKXJldHVybiB0aGlzLm9uQmVmb3JlVW5sb2FkKCl9KX07RWRpdG9yVWkucHJvdG90eXBlLm9uQmVmb3JlVW5sb2FkPWZ1bmN0aW9uKCl7aWYodGhpcy5lZGl0b3IubW9kaWZpZWQpcmV0dXJuIG14UmVzb3VyY2VzLmdldCgiYWxsQ2hhbmdlc0xvc3QiKX07CkVkaXRvclVpLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKCl7dHJ5e251bGwhPXdpbmRvdy5vcGVuZXImJm51bGwhPXdpbmRvdy5vcGVuZXIub3BlbkZpbGUmJndpbmRvdy5vcGVuZXIub3BlbkZpbGUuc2V0Q29uc3VtZXIobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXt0cnl7dmFyIGY9bXhVdGlscy5wYXJzZVhtbChhKTt0aGlzLmVkaXRvci5zZXRHcmFwaFhtbChmLmRvY3VtZW50RWxlbWVudCk7dGhpcy5lZGl0b3Iuc2V0TW9kaWZpZWQoITEpO3RoaXMuZWRpdG9yLnVuZG9NYW5hZ2VyLmNsZWFyKCk7bnVsbCE9YyYmKHRoaXMuZWRpdG9yLnNldEZpbGVuYW1lKGMpLHRoaXMudXBkYXRlRG9jdW1lbnRUaXRsZSgpKX1jYXRjaChkKXtteFV0aWxzLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgiaW52YWxpZE9yTWlzc2luZ0ZpbGUiKSsiOiAiK2QubWVzc2FnZSl9fSkpfWNhdGNoKGEpe310aGlzLmVkaXRvci5ncmFwaC52aWV3LnZhbGlkYXRlKCk7dGhpcy5lZGl0b3IuZ3JhcGguc2l6ZURpZENoYW5nZSgpOwp0aGlzLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInJlc2V0R3JhcGhWaWV3IikpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2V0Q3VycmVudE1lbnU9ZnVuY3Rpb24oYSxjKXt0aGlzLmN1cnJlbnRNZW51RWx0PWM7dGhpcy5jdXJyZW50TWVudT1hfTtFZGl0b3JVaS5wcm90b3R5cGUucmVzZXRDdXJyZW50TWVudT1mdW5jdGlvbigpe3RoaXMuY3VycmVudE1lbnU9dGhpcy5jdXJyZW50TWVudUVsdD1udWxsfTtFZGl0b3JVaS5wcm90b3R5cGUuaGlkZUN1cnJlbnRNZW51PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jdXJyZW50TWVudSYmKHRoaXMuY3VycmVudE1lbnUuaGlkZU1lbnUoKSx0aGlzLnJlc2V0Q3VycmVudE1lbnUoKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnRUaXRsZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yLmdldE9yQ3JlYXRlRmlsZW5hbWUoKTtudWxsIT10aGlzLmVkaXRvci5hcHBOYW1lJiYoYSs9IiAtICIrdGhpcy5lZGl0b3IuYXBwTmFtZSk7ZG9jdW1lbnQudGl0bGU9YX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUhvdmVySWNvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEhvdmVySWNvbnModGhpcy5lZGl0b3IuZ3JhcGgpfTtFZGl0b3JVaS5wcm90b3R5cGUucmVkbz1mdW5jdGlvbigpe3RyeXt0aGlzLmVkaXRvci5ncmFwaC5pc0VkaXRpbmcoKT9kb2N1bWVudC5leGVjQ29tbWFuZCgicmVkbyIsITEsbnVsbCk6dGhpcy5lZGl0b3IudW5kb01hbmFnZXIucmVkbygpfWNhdGNoKGEpe319OwpFZGl0b3JVaS5wcm90b3R5cGUudW5kbz1mdW5jdGlvbigpe3RyeXt2YXIgYT10aGlzLmVkaXRvci5ncmFwaDtpZihhLmlzRWRpdGluZygpKXt2YXIgYz1hLmNlbGxFZGl0b3IudGV4dGFyZWEuaW5uZXJIVE1MO2RvY3VtZW50LmV4ZWNDb21tYW5kKCJ1bmRvIiwhMSxudWxsKTtjPT1hLmNlbGxFZGl0b3IudGV4dGFyZWEuaW5uZXJIVE1MJiYoYS5zdG9wRWRpdGluZyghMCksdGhpcy5lZGl0b3IudW5kb01hbmFnZXIudW5kbygpKX1lbHNlIHRoaXMuZWRpdG9yLnVuZG9NYW5hZ2VyLnVuZG8oKX1jYXRjaChmKXt9fTtFZGl0b3JVaS5wcm90b3R5cGUuY2FuUmVkbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVkaXRvci5ncmFwaC5pc0VkaXRpbmcoKXx8dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2FuUmVkbygpfTtFZGl0b3JVaS5wcm90b3R5cGUuY2FuVW5kbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVkaXRvci5ncmFwaC5pc0VkaXRpbmcoKXx8dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2FuVW5kbygpfTsKRWRpdG9yVWkucHJvdG90eXBlLmdldEVkaXRCbGFua1htbD1mdW5jdGlvbigpe3JldHVybiBteFV0aWxzLmdldFhtbCh0aGlzLmVkaXRvci5nZXRHcmFwaFhtbCgpKX07RWRpdG9yVWkucHJvdG90eXBlLmdldFVybD1mdW5jdGlvbihhKXthPW51bGwhPWE/YTp3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7dmFyIGM9MDxhLmluZGV4T2YoIj8iKT8xOjAsZjtmb3IoZiBpbiB1cmxQYXJhbXMpYT0wPT1jP2ErIj8iOmErIiYiLGErPWYrIj0iK3VybFBhcmFtc1tmXSxjKys7cmV0dXJuIGF9OwpFZGl0b3JVaS5wcm90b3R5cGUuc2V0U2Nyb2xsYmFycz1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaCxmPWMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93O2Muc2Nyb2xsYmFycz1hO3RoaXMuZWRpdG9yLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO2YhPWMuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93JiYoYy5jb250YWluZXIuc2Nyb2xsVG9wPTAsYy5jb250YWluZXIuc2Nyb2xsTGVmdD0wLGMudmlldy5zY2FsZUFuZFRyYW5zbGF0ZSgxLDAsMCksdGhpcy5yZXNldFNjcm9sbGJhcnMoKSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInNjcm9sbGJhcnNDaGFuZ2VkIikpfTtFZGl0b3JVaS5wcm90b3R5cGUuaGFzU2Nyb2xsYmFycz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVkaXRvci5ncmFwaC5zY3JvbGxiYXJzfTsKRWRpdG9yVWkucHJvdG90eXBlLnJlc2V0U2Nyb2xsYmFycz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoO2lmKCF0aGlzLmVkaXRvci5leHRlbmRDYW52YXMpYS5jb250YWluZXIuc2Nyb2xsVG9wPTAsYS5jb250YWluZXIuc2Nyb2xsTGVmdD0wLG14VXRpbHMuaGFzU2Nyb2xsYmFycyhhLmNvbnRhaW5lcil8fGEudmlldy5zZXRUcmFuc2xhdGUoMCwwKTtlbHNlIGlmKCF0aGlzLmVkaXRvci5pc0Nocm9tZWxlc3NWaWV3KCkpaWYobXhVdGlscy5oYXNTY3JvbGxiYXJzKGEuY29udGFpbmVyKSlpZihhLnBhZ2VWaXNpYmxlKXt2YXIgYz1hLmdldFBhZ2VQYWRkaW5nKCk7YS5jb250YWluZXIuc2Nyb2xsVG9wPU1hdGguZmxvb3IoYy55LXRoaXMuZWRpdG9yLmluaXRpYWxUb3BTcGFjaW5nKS0xO2EuY29udGFpbmVyLnNjcm9sbExlZnQ9TWF0aC5mbG9vcihNYXRoLm1pbihjLngsKGEuY29udGFpbmVyLnNjcm9sbFdpZHRoLWEuY29udGFpbmVyLmNsaWVudFdpZHRoKS8yKSktCjE7Yz1hLmdldEdyYXBoQm91bmRzKCk7MDxjLndpZHRoJiYwPGMuaGVpZ2h0JiYoYy54PmEuY29udGFpbmVyLnNjcm9sbExlZnQrLjkqYS5jb250YWluZXIuY2xpZW50V2lkdGgmJihhLmNvbnRhaW5lci5zY3JvbGxMZWZ0PU1hdGgubWluKGMueCtjLndpZHRoLWEuY29udGFpbmVyLmNsaWVudFdpZHRoLGMueC0xMCkpLGMueT5hLmNvbnRhaW5lci5zY3JvbGxUb3ArLjkqYS5jb250YWluZXIuY2xpZW50SGVpZ2h0JiYoYS5jb250YWluZXIuc2Nyb2xsVG9wPU1hdGgubWluKGMueStjLmhlaWdodC1hLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsYy55LTEwKSkpfWVsc2V7dmFyIGM9YS5nZXRHcmFwaEJvdW5kcygpLGY9TWF0aC5tYXgoYy53aWR0aCxhLnNjcm9sbFRpbGVTaXplLndpZHRoKmEudmlldy5zY2FsZSk7YS5jb250YWluZXIuc2Nyb2xsVG9wPU1hdGguZmxvb3IoTWF0aC5tYXgoMCxjLnktTWF0aC5tYXgoMjAsKGEuY29udGFpbmVyLmNsaWVudEhlaWdodC1NYXRoLm1heChjLmhlaWdodCwKYS5zY3JvbGxUaWxlU2l6ZS5oZWlnaHQqYS52aWV3LnNjYWxlKSkvNCkpKTthLmNvbnRhaW5lci5zY3JvbGxMZWZ0PU1hdGguZmxvb3IoTWF0aC5tYXgoMCxjLngtTWF0aC5tYXgoMCwoYS5jb250YWluZXIuY2xpZW50V2lkdGgtZikvMikpKX1lbHNle3ZhciBjPW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoYS5wYWdlVmlzaWJsZT9hLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHMoKTphLmdldEdyYXBoQm91bmRzKCkpLGY9YS52aWV3LnRyYW5zbGF0ZSxkPWEudmlldy5zY2FsZTtjLng9Yy54L2QtZi54O2MueT1jLnkvZC1mLnk7Yy53aWR0aC89ZDtjLmhlaWdodC89ZDthLnZpZXcuc2V0VHJhbnNsYXRlKE1hdGguZmxvb3IoTWF0aC5tYXgoMCwoYS5jb250YWluZXIuY2xpZW50V2lkdGgtYy53aWR0aCkvMiktYy54KzIpLE1hdGguZmxvb3IoKGEucGFnZVZpc2libGU/MDpNYXRoLm1heCgwLChhLmNvbnRhaW5lci5jbGllbnRIZWlnaHQtYy5oZWlnaHQpLzQpKS1jLnkrMSkpfX07CkVkaXRvclVpLnByb3RvdHlwZS5zZXRQYWdlVmlzaWJsZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaCxmPW14VXRpbHMuaGFzU2Nyb2xsYmFycyhjLmNvbnRhaW5lciksZD0wLGs9MDtmJiYoZD1jLnZpZXcudHJhbnNsYXRlLngqYy52aWV3LnNjYWxlLWMuY29udGFpbmVyLnNjcm9sbExlZnQsaz1jLnZpZXcudHJhbnNsYXRlLnkqYy52aWV3LnNjYWxlLWMuY29udGFpbmVyLnNjcm9sbFRvcCk7Yy5wYWdlVmlzaWJsZT1hO2MucGFnZUJyZWFrc1Zpc2libGU9YTtjLnByZWZlclBhZ2VTaXplPWE7Yy52aWV3LnZhbGlkYXRlQmFja2dyb3VuZCgpO2YmJihhPWMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxjLmNsZWFyU2VsZWN0aW9uKCksYy5zZXRTZWxlY3Rpb25DZWxscyhhKSk7Yy5zaXplRGlkQ2hhbmdlKCk7ZiYmKGMuY29udGFpbmVyLnNjcm9sbExlZnQ9Yy52aWV3LnRyYW5zbGF0ZS54KmMudmlldy5zY2FsZS1kLGMuY29udGFpbmVyLnNjcm9sbFRvcD1jLnZpZXcudHJhbnNsYXRlLnkqCmMudmlldy5zY2FsZS1rKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicGFnZVZpZXdDaGFuZ2VkIikpfTtmdW5jdGlvbiBDaGFuZ2VQYWdlU2V0dXAoYSxjLGYsZCxrKXt0aGlzLnVpPWE7dGhpcy5wcmV2aW91c0NvbG9yPXRoaXMuY29sb3I9Yzt0aGlzLnByZXZpb3VzSW1hZ2U9dGhpcy5pbWFnZT1mO3RoaXMucHJldmlvdXNGb3JtYXQ9dGhpcy5mb3JtYXQ9ZDt0aGlzLnByZXZpb3VzUGFnZVNjYWxlPXRoaXMucGFnZVNjYWxlPWs7dGhpcy5pZ25vcmVJbWFnZT10aGlzLmlnbm9yZUNvbG9yPSExfQpDaGFuZ2VQYWdlU2V0dXAucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnVpLmVkaXRvci5ncmFwaDtpZighdGhpcy5pZ25vcmVDb2xvcil7dGhpcy5jb2xvcj10aGlzLnByZXZpb3VzQ29sb3I7dmFyIGM9YS5iYWNrZ3JvdW5kO3RoaXMudWkuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMucHJldmlvdXNDb2xvcik7dGhpcy5wcmV2aW91c0NvbG9yPWN9dGhpcy5pZ25vcmVJbWFnZXx8KHRoaXMuaW1hZ2U9dGhpcy5wcmV2aW91c0ltYWdlLGM9YS5iYWNrZ3JvdW5kSW1hZ2UsdGhpcy51aS5zZXRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5wcmV2aW91c0ltYWdlKSx0aGlzLnByZXZpb3VzSW1hZ2U9Yyk7bnVsbCE9dGhpcy5wcmV2aW91c0Zvcm1hdCYmKHRoaXMuZm9ybWF0PXRoaXMucHJldmlvdXNGb3JtYXQsYz1hLnBhZ2VGb3JtYXQsdGhpcy5wcmV2aW91c0Zvcm1hdC53aWR0aCE9Yy53aWR0aHx8dGhpcy5wcmV2aW91c0Zvcm1hdC5oZWlnaHQhPWMuaGVpZ2h0KSYmKHRoaXMudWkuc2V0UGFnZUZvcm1hdCh0aGlzLnByZXZpb3VzRm9ybWF0KSwKdGhpcy5wcmV2aW91c0Zvcm1hdD1jKTtudWxsIT10aGlzLmZvbGRpbmdFbmFibGVkJiZ0aGlzLmZvbGRpbmdFbmFibGVkIT10aGlzLnVpLmVkaXRvci5ncmFwaC5mb2xkaW5nRW5hYmxlZCYmKHRoaXMudWkuc2V0Rm9sZGluZ0VuYWJsZWQodGhpcy5mb2xkaW5nRW5hYmxlZCksdGhpcy5mb2xkaW5nRW5hYmxlZD0hdGhpcy5mb2xkaW5nRW5hYmxlZCk7bnVsbCE9dGhpcy5wcmV2aW91c1BhZ2VTY2FsZSYmKGE9dGhpcy51aS5lZGl0b3IuZ3JhcGgucGFnZVNjYWxlLHRoaXMucHJldmlvdXNQYWdlU2NhbGUhPWEmJih0aGlzLnVpLnNldFBhZ2VTY2FsZSh0aGlzLnByZXZpb3VzUGFnZVNjYWxlKSx0aGlzLnByZXZpb3VzUGFnZVNjYWxlPWEpKX07CihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBDaGFuZ2VQYWdlU2V0dXAsWyJ1aSIsInByZXZpb3VzQ29sb3IiLCJwcmV2aW91c0ltYWdlIiwicHJldmlvdXNGb3JtYXQiLCJwcmV2aW91c1BhZ2VTY2FsZSJdKTthLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsZixkKXtkLnByZXZpb3VzQ29sb3I9ZC5jb2xvcjtkLnByZXZpb3VzSW1hZ2U9ZC5pbWFnZTtkLnByZXZpb3VzRm9ybWF0PWQuZm9ybWF0O2QucHJldmlvdXNQYWdlU2NhbGU9ZC5wYWdlU2NhbGU7bnVsbCE9ZC5mb2xkaW5nRW5hYmxlZCYmKGQuZm9sZGluZ0VuYWJsZWQ9IWQuZm9sZGluZ0VuYWJsZWQpO3JldHVybiBkfTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoYSl9KSgpO0VkaXRvclVpLnByb3RvdHlwZS5zZXRCYWNrZ3JvdW5kQ29sb3I9ZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3IuZ3JhcGguYmFja2dyb3VuZD1hO3RoaXMuZWRpdG9yLmdyYXBoLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kKCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImJhY2tncm91bmRDb2xvckNoYW5nZWQiKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuc2V0Rm9sZGluZ0VuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3IuZ3JhcGguZm9sZGluZ0VuYWJsZWQ9YTt0aGlzLmVkaXRvci5ncmFwaC52aWV3LnJldmFsaWRhdGUoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZm9sZGluZ0VuYWJsZWRDaGFuZ2VkIikpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2V0UGFnZUZvcm1hdD1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5wYWdlRm9ybWF0PWE7dGhpcy5lZGl0b3IuZ3JhcGgucGFnZVZpc2libGU/KHRoaXMuZWRpdG9yLmdyYXBoLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kKCksdGhpcy5lZGl0b3IuZ3JhcGguc2l6ZURpZENoYW5nZSgpKTp0aGlzLmFjdGlvbnMuZ2V0KCJwYWdlVmlldyIpLmZ1bmN0KCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VGb3JtYXRDaGFuZ2VkIikpfTsKRWRpdG9yVWkucHJvdG90eXBlLnNldFBhZ2VTY2FsZT1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5wYWdlU2NhbGU9YTt0aGlzLmVkaXRvci5ncmFwaC5wYWdlVmlzaWJsZT8odGhpcy5lZGl0b3IuZ3JhcGgudmlldy52YWxpZGF0ZUJhY2tncm91bmQoKSx0aGlzLmVkaXRvci5ncmFwaC5zaXplRGlkQ2hhbmdlKCkpOnRoaXMuYWN0aW9ucy5nZXQoInBhZ2VWaWV3IikuZnVuY3QoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicGFnZVNjYWxlQ2hhbmdlZCIpKX07RWRpdG9yVWkucHJvdG90eXBlLnNldEdyaWRDb2xvcj1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC52aWV3LmdyaWRDb2xvcj1hO3RoaXMuZWRpdG9yLmdyYXBoLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kKCk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImdyaWRDb2xvckNoYW5nZWQiKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuYWRkVW5kb0xpc3RlbmVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5hY3Rpb25zLmdldCgidW5kbyIpLGM9dGhpcy5hY3Rpb25zLmdldCgicmVkbyIpLGY9dGhpcy5lZGl0b3IudW5kb01hbmFnZXIsZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Euc2V0RW5hYmxlZCh0aGlzLmNhblVuZG8oKSk7Yy5zZXRFbmFibGVkKHRoaXMuY2FuUmVkbygpKX0pO2YuYWRkTGlzdGVuZXIobXhFdmVudC5BREQsZCk7Zi5hZGRMaXN0ZW5lcihteEV2ZW50LlVORE8sZCk7Zi5hZGRMaXN0ZW5lcihteEV2ZW50LlJFRE8sZCk7Zi5hZGRMaXN0ZW5lcihteEV2ZW50LkNMRUFSLGQpO3ZhciBrPXRoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RhcnRFZGl0aW5nO3RoaXMuZWRpdG9yLmdyYXBoLmNlbGxFZGl0b3Iuc3RhcnRFZGl0aW5nPWZ1bmN0aW9uKCl7ay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZCgpfTt2YXIgbT10aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nOwp0aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nPWZ1bmN0aW9uKGEsYil7bS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZCgpfTtkKCl9OwpFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQWN0aW9uU3RhdGVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGgsYz0hYS5pc1NlbGVjdGlvbkVtcHR5KCksZj0hMSxkPSExLGs9YS5nZXRTZWxlY3Rpb25DZWxscygpO2lmKG51bGwhPWspZm9yKHZhciBtPTA7bTxrLmxlbmd0aDttKyspe3ZhciBxPWtbbV07YS5nZXRNb2RlbCgpLmlzRWRnZShxKSYmKGQ9ITApO2EuZ2V0TW9kZWwoKS5pc1ZlcnRleChxKSYmKGY9ITApO2lmKGQmJmYpYnJlYWt9az0iY3V0IGNvcHkgYm9sZCBpdGFsaWMgdW5kZXJsaW5lIGRlbGV0ZSBkdXBsaWNhdGUgZWRpdFN0eWxlIGVkaXRUb29sdGlwIGVkaXRMaW5rIGJhY2tncm91bmRDb2xvciBib3JkZXJDb2xvciBlZGl0IHRvRnJvbnQgdG9CYWNrIGxvY2tVbmxvY2sgc29saWQgZGFzaGVkIHBhc3RlU2l6ZSBkb3R0ZWQgZmlsbENvbG9yIGdyYWRpZW50Q29sb3Igc2hhZG93IGZvbnRDb2xvciBmb3JtYXR0ZWRUZXh0IHJvdW5kZWQgdG9nZ2xlUm91bmRlZCBzaGFycCBzdHJva2VDb2xvciIuc3BsaXQoIiAiKTtmb3IobT0KMDttPGsubGVuZ3RoO20rKyl0aGlzLmFjdGlvbnMuZ2V0KGtbbV0pLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgic2V0QXNEZWZhdWx0U3R5bGUiKS5zZXRFbmFibGVkKDE9PWEuZ2V0U2VsZWN0aW9uQ291bnQoKSk7dGhpcy5hY3Rpb25zLmdldCgiY2xlYXJXYXlwb2ludHMiKS5zZXRFbmFibGVkKCFhLmlzU2VsZWN0aW9uRW1wdHkoKSk7dGhpcy5hY3Rpb25zLmdldCgiY29weVNpemUiKS5zZXRFbmFibGVkKDE9PWEuZ2V0U2VsZWN0aW9uQ291bnQoKSk7dGhpcy5hY3Rpb25zLmdldCgidHVybiIpLnNldEVuYWJsZWQoIWEuaXNTZWxlY3Rpb25FbXB0eSgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJjdXJ2ZWQiKS5zZXRFbmFibGVkKGQpO3RoaXMuYWN0aW9ucy5nZXQoInJvdGF0aW9uIikuc2V0RW5hYmxlZChmKTt0aGlzLmFjdGlvbnMuZ2V0KCJ3b3JkV3JhcCIpLnNldEVuYWJsZWQoZik7dGhpcy5hY3Rpb25zLmdldCgiYXV0b3NpemUiKS5zZXRFbmFibGVkKGYpO2Q9ZiYmMT09CmEuZ2V0U2VsZWN0aW9uQ291bnQoKTt0aGlzLmFjdGlvbnMuZ2V0KCJncm91cCIpLnNldEVuYWJsZWQoMTxhLmdldFNlbGVjdGlvbkNvdW50KCl8fGQmJiFhLmlzQ29udGFpbmVyKGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKSk7dGhpcy5hY3Rpb25zLmdldCgidW5ncm91cCIpLnNldEVuYWJsZWQoMT09YS5nZXRTZWxlY3Rpb25Db3VudCgpJiYoMDxhLmdldE1vZGVsKCkuZ2V0Q2hpbGRDb3VudChhLmdldFNlbGVjdGlvbkNlbGwoKSl8fGQmJmEuaXNDb250YWluZXIoYS5nZXRTZWxlY3Rpb25DZWxsKCkpKSk7dGhpcy5hY3Rpb25zLmdldCgicmVtb3ZlRnJvbUdyb3VwIikuc2V0RW5hYmxlZChkJiZhLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYS5nZXRNb2RlbCgpLmdldFBhcmVudChhLmdldFNlbGVjdGlvbkNlbGwoKSkpKTthLnZpZXcuZ2V0U3RhdGUoYS5nZXRTZWxlY3Rpb25DZWxsKCkpO3RoaXMubWVudXMuZ2V0KCJuYXZpZ2F0aW9uIikuc2V0RW5hYmxlZChjfHxudWxsIT1hLnZpZXcuY3VycmVudFJvb3QpOwp0aGlzLmFjdGlvbnMuZ2V0KCJjb2xsYXBzaWJsZSIpLnNldEVuYWJsZWQoZiYmKGEuaXNDb250YWluZXIoYS5nZXRTZWxlY3Rpb25DZWxsKCkpfHwwPGEubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmdldFNlbGVjdGlvbkNlbGwoKSkpKTt0aGlzLmFjdGlvbnMuZ2V0KCJob21lIikuc2V0RW5hYmxlZChudWxsIT1hLnZpZXcuY3VycmVudFJvb3QpO3RoaXMuYWN0aW9ucy5nZXQoImV4aXRHcm91cCIpLnNldEVuYWJsZWQobnVsbCE9YS52aWV3LmN1cnJlbnRSb290KTt0aGlzLmFjdGlvbnMuZ2V0KCJlbnRlckdyb3VwIikuc2V0RW5hYmxlZCgxPT1hLmdldFNlbGVjdGlvbkNvdW50KCkmJmEuaXNWYWxpZFJvb3QoYS5nZXRTZWxlY3Rpb25DZWxsKCkpKTtjPTE9PWEuZ2V0U2VsZWN0aW9uQ291bnQoKSYmYS5pc0NlbGxGb2xkYWJsZShhLmdldFNlbGVjdGlvbkNlbGwoKSk7dGhpcy5hY3Rpb25zLmdldCgiZXhwYW5kIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJjb2xsYXBzZSIpLnNldEVuYWJsZWQoYyk7CnRoaXMuYWN0aW9ucy5nZXQoImVkaXRMaW5rIikuc2V0RW5hYmxlZCgxPT1hLmdldFNlbGVjdGlvbkNvdW50KCkpO3RoaXMuYWN0aW9ucy5nZXQoIm9wZW5MaW5rIikuc2V0RW5hYmxlZCgxPT1hLmdldFNlbGVjdGlvbkNvdW50KCkmJm51bGwhPWEuZ2V0TGlua0ZvckNlbGwoYS5nZXRTZWxlY3Rpb25DZWxsKCkpKTt0aGlzLmFjdGlvbnMuZ2V0KCJndWlkZXMiKS5zZXRFbmFibGVkKGEuaXNFbmFibGVkKCkpO3RoaXMuYWN0aW9ucy5nZXQoImdyaWQiKS5zZXRFbmFibGVkKCF0aGlzLmVkaXRvci5jaHJvbWVsZXNzfHx0aGlzLmVkaXRvci5lZGl0YWJsZSk7Yz1hLmlzRW5hYmxlZCgpJiYhYS5pc0NlbGxMb2NrZWQoYS5nZXREZWZhdWx0UGFyZW50KCkpO3RoaXMubWVudXMuZ2V0KCJsYXlvdXQiKS5zZXRFbmFibGVkKGMpO3RoaXMubWVudXMuZ2V0KCJpbnNlcnQiKS5zZXRFbmFibGVkKGMpO3RoaXMubWVudXMuZ2V0KCJkaXJlY3Rpb24iKS5zZXRFbmFibGVkKGMmJmYpO3RoaXMubWVudXMuZ2V0KCJhbGlnbiIpLnNldEVuYWJsZWQoYyYmCmYmJjE8YS5nZXRTZWxlY3Rpb25Db3VudCgpKTt0aGlzLm1lbnVzLmdldCgiZGlzdHJpYnV0ZSIpLnNldEVuYWJsZWQoYyYmZiYmMTxhLmdldFNlbGVjdGlvbkNvdW50KCkpO3RoaXMuYWN0aW9ucy5nZXQoInNlbGVjdFZlcnRpY2VzIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJzZWxlY3RFZGdlcyIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgic2VsZWN0QWxsIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJzZWxlY3ROb25lIikuc2V0RW5hYmxlZChjKTt0aGlzLnVwZGF0ZVBhc3RlQWN0aW9uU3RhdGVzKCl9O0VkaXRvclVpLnByb3RvdHlwZS56ZXJvT2Zmc2V0PW5ldyBteFBvaW50KDAsMCk7RWRpdG9yVWkucHJvdG90eXBlLmdldERpYWdyYW1Db250YWluZXJPZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy56ZXJvT2Zmc2V0fTsKRWRpdG9yVWkucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oYSl7YT1udWxsIT1hP2E6ITA7dmFyIGM9bXhDbGllbnQuSVNfSUUmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDU9PWRvY3VtZW50LmRvY3VtZW50TW9kZSksZj10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCxkPXRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodDt0aGlzLmNvbnRhaW5lcj09ZG9jdW1lbnQuYm9keSYmKGY9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLGQ9Yz9kb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTt2YXIgaz0wO214Q2xpZW50LklTX0lPUyYmIXdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSYmd2luZG93LmlubmVySGVpZ2h0IT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0JiYKKGs9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodC13aW5kb3cuaW5uZXJIZWlnaHQsd2luZG93LnNjcm9sbFRvKDAsMCkpO3ZhciBtPU1hdGgubWF4KDAsTWF0aC5taW4odGhpcy5oc3BsaXRQb3NpdGlvbixmLXRoaXMuc3BsaXRTaXplLTIwKSkscT0wO251bGwhPXRoaXMubWVudWJhciYmKHRoaXMubWVudWJhckNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9dGhpcy5tZW51YmFySGVpZ2h0KyJweCIscSs9dGhpcy5tZW51YmFySGVpZ2h0KTtudWxsIT10aGlzLnRvb2xiYXImJih0aGlzLnRvb2xiYXJDb250YWluZXIuc3R5bGUudG9wPXRoaXMubWVudWJhckhlaWdodCsicHgiLHRoaXMudG9vbGJhckNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9dGhpcy50b29sYmFySGVpZ2h0KyJweCIscSs9dGhpcy50b29sYmFySGVpZ2h0KTswPHEmJiFteENsaWVudC5JU19RVUlSS1MmJihxKz0xKTt2YXIgYj0wO2lmKG51bGwhPXRoaXMuc2lkZWJhckZvb3RlckNvbnRhaW5lcil7dmFyIGU9CnRoaXMuZm9vdGVySGVpZ2h0K2ssYj1NYXRoLm1heCgwLE1hdGgubWluKGQtcS1lLHRoaXMuc2lkZWJhckZvb3RlckhlaWdodCkpO3RoaXMuc2lkZWJhckZvb3RlckNvbnRhaW5lci5zdHlsZS53aWR0aD1tKyJweCI7dGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyLnN0eWxlLmhlaWdodD1iKyJweCI7dGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyLnN0eWxlLmJvdHRvbT1lKyJweCJ9ZT1udWxsIT10aGlzLmZvcm1hdD90aGlzLmZvcm1hdFdpZHRoOjA7dGhpcy5zaWRlYmFyQ29udGFpbmVyLnN0eWxlLnRvcD1xKyJweCI7dGhpcy5zaWRlYmFyQ29udGFpbmVyLnN0eWxlLndpZHRoPW0rInB4Ijt0aGlzLmZvcm1hdENvbnRhaW5lci5zdHlsZS50b3A9cSsicHgiO3RoaXMuZm9ybWF0Q29udGFpbmVyLnN0eWxlLndpZHRoPWUrInB4Ijt0aGlzLmZvcm1hdENvbnRhaW5lci5zdHlsZS5kaXNwbGF5PW51bGwhPXRoaXMuZm9ybWF0PyIiOiJub25lIjt2YXIgZz10aGlzLmdldERpYWdyYW1Db250YWluZXJPZmZzZXQoKSwKbj1udWxsIT10aGlzLmhzcGxpdC5wYXJlbnROb2RlP20rdGhpcy5zcGxpdFNpemU6MDt0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUubGVmdD1uK2cueCsicHgiO3RoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS50b3A9cStnLnkrInB4Ijt0aGlzLmZvb3RlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9dGhpcy5mb290ZXJIZWlnaHQrInB4Ijt0aGlzLmhzcGxpdC5zdHlsZS50b3A9dGhpcy5zaWRlYmFyQ29udGFpbmVyLnN0eWxlLnRvcDt0aGlzLmhzcGxpdC5zdHlsZS5ib3R0b209dGhpcy5mb290ZXJIZWlnaHQraysicHgiO3RoaXMuaHNwbGl0LnN0eWxlLmxlZnQ9bSsicHgiO3RoaXMuZm9vdGVyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXk9MD09dGhpcy5mb290ZXJIZWlnaHQ/Im5vbmUiOiIiO251bGwhPXRoaXMudGFiQ29udGFpbmVyJiYodGhpcy50YWJDb250YWluZXIuc3R5bGUubGVmdD1uKyJweCIpO2M/KHRoaXMubWVudWJhckNvbnRhaW5lci5zdHlsZS53aWR0aD1mKyJweCIsCnRoaXMudG9vbGJhckNvbnRhaW5lci5zdHlsZS53aWR0aD10aGlzLm1lbnViYXJDb250YWluZXIuc3R5bGUud2lkdGgsYz1NYXRoLm1heCgwLGQtdGhpcy5mb290ZXJIZWlnaHQtdGhpcy5tZW51YmFySGVpZ2h0LXRoaXMudG9vbGJhckhlaWdodCksdGhpcy5zaWRlYmFyQ29udGFpbmVyLnN0eWxlLmhlaWdodD1jLWIrInB4Iix0aGlzLmZvcm1hdENvbnRhaW5lci5zdHlsZS5oZWlnaHQ9YysicHgiLHRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS53aWR0aD1udWxsIT10aGlzLmhzcGxpdC5wYXJlbnROb2RlP01hdGgubWF4KDAsZi1tLXRoaXMuc3BsaXRTaXplLWUpKyJweCI6ZisicHgiLHRoaXMuZm9vdGVyQ29udGFpbmVyLnN0eWxlLndpZHRoPXRoaXMubWVudWJhckNvbnRhaW5lci5zdHlsZS53aWR0aCxiPU1hdGgubWF4KDAsZC10aGlzLmZvb3RlckhlaWdodC10aGlzLm1lbnViYXJIZWlnaHQtdGhpcy50b29sYmFySGVpZ2h0KSxudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmKHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLndpZHRoPQp0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUud2lkdGgsdGhpcy50YWJDb250YWluZXIuc3R5bGUuYm90dG9tPXRoaXMuZm9vdGVySGVpZ2h0K2srInB4IixiLT10aGlzLnRhYkNvbnRhaW5lci5jbGllbnRIZWlnaHQpLHRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9YisicHgiLHRoaXMuaHNwbGl0LnN0eWxlLmhlaWdodD1iKyJweCIpOigwPHRoaXMuZm9vdGVySGVpZ2h0JiYodGhpcy5mb290ZXJDb250YWluZXIuc3R5bGUuYm90dG9tPWsrInB4IiksdGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnJpZ2h0PWUrInB4IixmPTAsbnVsbCE9dGhpcy50YWJDb250YWluZXImJih0aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5ib3R0b209dGhpcy5mb290ZXJIZWlnaHQraysicHgiLHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLnJpZ2h0PXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS5yaWdodCxmPXRoaXMudGFiQ29udGFpbmVyLmNsaWVudEhlaWdodCksdGhpcy5zaWRlYmFyQ29udGFpbmVyLnN0eWxlLmJvdHRvbT0KdGhpcy5mb290ZXJIZWlnaHQrYitrKyJweCIsdGhpcy5mb3JtYXRDb250YWluZXIuc3R5bGUuYm90dG9tPXRoaXMuZm9vdGVySGVpZ2h0K2srInB4Iix0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUuYm90dG9tPXRoaXMuZm9vdGVySGVpZ2h0K2srZisicHgiKTthJiZ0aGlzLmVkaXRvci5ncmFwaC5zaXplRGlkQ2hhbmdlKCl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVUYWJDb250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVEaXZzPWZ1bmN0aW9uKCl7dGhpcy5tZW51YmFyQ29udGFpbmVyPXRoaXMuY3JlYXRlRGl2KCJnZU1lbnViYXJDb250YWluZXIiKTt0aGlzLnRvb2xiYXJDb250YWluZXI9dGhpcy5jcmVhdGVEaXYoImdlVG9vbGJhckNvbnRhaW5lciIpO3RoaXMuc2lkZWJhckNvbnRhaW5lcj10aGlzLmNyZWF0ZURpdigiZ2VTaWRlYmFyQ29udGFpbmVyIik7dGhpcy5mb3JtYXRDb250YWluZXI9dGhpcy5jcmVhdGVEaXYoImdlU2lkZWJhckNvbnRhaW5lciBnZUZvcm1hdENvbnRhaW5lciIpO3RoaXMuZGlhZ3JhbUNvbnRhaW5lcj10aGlzLmNyZWF0ZURpdigiZ2VEaWFncmFtQ29udGFpbmVyIik7dGhpcy5mb290ZXJDb250YWluZXI9dGhpcy5jcmVhdGVEaXYoImdlRm9vdGVyQ29udGFpbmVyIik7dGhpcy5oc3BsaXQ9dGhpcy5jcmVhdGVEaXYoImdlSHNwbGl0Iik7dGhpcy5oc3BsaXQuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjb2xsYXBzZUV4cGFuZCIpKTsKdGhpcy5tZW51YmFyQ29udGFpbmVyLnN0eWxlLnRvcD0iMHB4Ijt0aGlzLm1lbnViYXJDb250YWluZXIuc3R5bGUubGVmdD0iMHB4Ijt0aGlzLm1lbnViYXJDb250YWluZXIuc3R5bGUucmlnaHQ9IjBweCI7dGhpcy50b29sYmFyQ29udGFpbmVyLnN0eWxlLmxlZnQ9IjBweCI7dGhpcy50b29sYmFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0PSIwcHgiO3RoaXMuc2lkZWJhckNvbnRhaW5lci5zdHlsZS5sZWZ0PSIwcHgiO3RoaXMuZm9ybWF0Q29udGFpbmVyLnN0eWxlLnJpZ2h0PSIwcHgiO3RoaXMuZm9ybWF0Q29udGFpbmVyLnN0eWxlLnpJbmRleD0iMSI7dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnJpZ2h0PShudWxsIT10aGlzLmZvcm1hdD90aGlzLmZvcm1hdFdpZHRoOjApKyJweCI7dGhpcy5mb290ZXJDb250YWluZXIuc3R5bGUubGVmdD0iMHB4Ijt0aGlzLmZvb3RlckNvbnRhaW5lci5zdHlsZS5yaWdodD0iMHB4Ijt0aGlzLmZvb3RlckNvbnRhaW5lci5zdHlsZS5ib3R0b209CiIwcHgiO3RoaXMuZm9vdGVyQ29udGFpbmVyLnN0eWxlLnpJbmRleD1teFBvcHVwTWVudS5wcm90b3R5cGUuekluZGV4LTI7dGhpcy5oc3BsaXQuc3R5bGUud2lkdGg9dGhpcy5zcGxpdFNpemUrInB4IjtpZih0aGlzLnNpZGViYXJGb290ZXJDb250YWluZXI9dGhpcy5jcmVhdGVTaWRlYmFyRm9vdGVyQ29udGFpbmVyKCkpdGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyLnN0eWxlLmxlZnQ9IjBweCI7dGhpcy5lZGl0b3IuY2hyb21lbGVzcz90aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUuYm9yZGVyPSJub25lIjp0aGlzLnRhYkNvbnRhaW5lcj10aGlzLmNyZWF0ZVRhYkNvbnRhaW5lcigpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlU2lkZWJhckZvb3RlckNvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiBudWxsfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVVpPWZ1bmN0aW9uKCl7dGhpcy5tZW51YmFyPXRoaXMuZWRpdG9yLmNocm9tZWxlc3M/bnVsbDp0aGlzLm1lbnVzLmNyZWF0ZU1lbnViYXIodGhpcy5jcmVhdGVEaXYoImdlTWVudWJhciIpKTtudWxsIT10aGlzLm1lbnViYXImJnRoaXMubWVudWJhckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1lbnViYXIuY29udGFpbmVyKTtudWxsIT10aGlzLm1lbnViYXImJih0aGlzLnN0YXR1c0NvbnRhaW5lcj10aGlzLmNyZWF0ZVN0YXR1c0NvbnRhaW5lcigpLHRoaXMuZWRpdG9yLmFkZExpc3RlbmVyKCJzdGF0dXNDaGFuZ2VkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2V0U3RhdHVzVGV4dCh0aGlzLmVkaXRvci5nZXRTdGF0dXMoKSl9KSksdGhpcy5zZXRTdGF0dXNUZXh0KHRoaXMuZWRpdG9yLmdldFN0YXR1cygpKSx0aGlzLm1lbnViYXIuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc3RhdHVzQ29udGFpbmVyKSx0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1lbnViYXJDb250YWluZXIpKTsKdGhpcy5zaWRlYmFyPXRoaXMuZWRpdG9yLmNocm9tZWxlc3M/bnVsbDp0aGlzLmNyZWF0ZVNpZGViYXIodGhpcy5zaWRlYmFyQ29udGFpbmVyKTtudWxsIT10aGlzLnNpZGViYXImJnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2lkZWJhckNvbnRhaW5lcik7dGhpcy5mb3JtYXQ9dGhpcy5lZGl0b3IuY2hyb21lbGVzc3x8IXRoaXMuZm9ybWF0RW5hYmxlZD9udWxsOnRoaXMuY3JlYXRlRm9ybWF0KHRoaXMuZm9ybWF0Q29udGFpbmVyKTtudWxsIT10aGlzLmZvcm1hdCYmdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mb3JtYXRDb250YWluZXIpO3ZhciBhPXRoaXMuZWRpdG9yLmNocm9tZWxlc3M/bnVsbDp0aGlzLmNyZWF0ZUZvb3RlcigpO251bGwhPWEmJih0aGlzLmZvb3RlckNvbnRhaW5lci5hcHBlbmRDaGlsZChhKSx0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZvb3RlckNvbnRhaW5lcikpO251bGwhPXRoaXMuc2lkZWJhciYmdGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyJiYKdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zaWRlYmFyRm9vdGVyQ29udGFpbmVyKTt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRpYWdyYW1Db250YWluZXIpO251bGwhPXRoaXMuY29udGFpbmVyJiZudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50YWJDb250YWluZXIpO3RoaXMudG9vbGJhcj10aGlzLmVkaXRvci5jaHJvbWVsZXNzP251bGw6dGhpcy5jcmVhdGVUb29sYmFyKHRoaXMuY3JlYXRlRGl2KCJnZVRvb2xiYXIiKSk7bnVsbCE9dGhpcy50b29sYmFyJiYodGhpcy50b29sYmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudG9vbGJhci5jb250YWluZXIpLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudG9vbGJhckNvbnRhaW5lcikpO251bGwhPXRoaXMuc2lkZWJhciYmKHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaHNwbGl0KSx0aGlzLmFkZFNwbGl0SGFuZGxlcih0aGlzLmhzcGxpdCwKITAsMCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhzcGxpdFBvc2l0aW9uPWE7dGhpcy5yZWZyZXNoKCl9KSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlU3RhdHVzQ29udGFpbmVyPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpO2EuY2xhc3NOYW1lPSJnZUl0ZW0gZ2VTdGF0dXMiOzQyMD5zY3JlZW4ud2lkdGgmJihhLnN0eWxlLm1heFdpZHRoPU1hdGgubWF4KDIwLHNjcmVlbi53aWR0aC0zMjApKyJweCIsYS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIik7cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRTdGF0dXNUZXh0PWZ1bmN0aW9uKGEpe3RoaXMuc3RhdHVzQ29udGFpbmVyLmlubmVySFRNTD1hfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVG9vbGJhcj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFRvb2xiYXIodGhpcyxhKX07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVTaWRlYmFyPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgU2lkZWJhcih0aGlzLGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlRm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgRm9ybWF0KHRoaXMsYSl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVGb290ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVEaXYoImdlRm9vdGVyIil9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVEaXY9ZnVuY3Rpb24oYSl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5jbGFzc05hbWU9YTtyZXR1cm4gY307CkVkaXRvclVpLnByb3RvdHlwZS5hZGRTcGxpdEhhbmRsZXI9ZnVuY3Rpb24oYSxjLGYsZCl7ZnVuY3Rpb24gayhhKXtpZihudWxsIT1xKXt2YXIgbD1uZXcgbXhQb2ludChteEV2ZW50LmdldENsaWVudFgoYSksbXhFdmVudC5nZXRDbGllbnRZKGEpKTtkKE1hdGgubWF4KDAsYisoYz9sLngtcS54OnEueS1sLnkpLWYpKTtteEV2ZW50LmNvbnN1bWUoYSk7YiE9bigpJiYoZT0hMCxnPW51bGwpfX1mdW5jdGlvbiBtKGEpe2soYSk7cT1iPW51bGx9dmFyIHE9bnVsbCxiPW51bGwsZT0hMCxnPW51bGw7bXhDbGllbnQuSVNfUE9JTlRFUiYmKGEuc3R5bGUudG91Y2hBY3Rpb249Im5vbmUiKTt2YXIgbj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBiPXBhcnNlSW50KGM/YS5zdHlsZS5sZWZ0OmEuc3R5bGUuYm90dG9tKTtjfHwoYj1iK2YtdGhpcy5mb290ZXJIZWlnaHQpO3JldHVybiBifSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGEsZnVuY3Rpb24oYSl7cT1uZXcgbXhQb2ludChteEV2ZW50LmdldENsaWVudFgoYSksCm14RXZlbnQuZ2V0Q2xpZW50WShhKSk7Yj1uKCk7ZT0hMTtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZighZSYmdGhpcy5oc3BsaXRDbGlja0VuYWJsZWQpe3ZhciBiPW51bGwhPWc/Zy1mOjA7Zz1uKCk7ZChiKTtteEV2ZW50LmNvbnN1bWUoYSl9fSkpO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCxudWxsLGssbSk7dGhpcy5kZXN0cm95RnVuY3Rpb25zLnB1c2goZnVuY3Rpb24oKXtteEV2ZW50LnJlbW92ZUdlc3R1cmVMaXN0ZW5lcnMoZG9jdW1lbnQsbnVsbCxrLG0pfSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaGFuZGxlRXJyb3I9ZnVuY3Rpb24oYSxjLGYsZCxrKXthPW51bGwhPWEmJm51bGwhPWEuZXJyb3I/YS5lcnJvcjphO2lmKG51bGwhPWF8fG51bGwhPWMpe2s9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ1bmtub3duRXJyb3IiKSk7dmFyIG09bXhSZXNvdXJjZXMuZ2V0KCJvayIpO2M9bnVsbCE9Yz9jOm14UmVzb3VyY2VzLmdldCgiZXJyb3IiKTtudWxsIT1hJiZudWxsIT1hLm1lc3NhZ2UmJihrPW14VXRpbHMuaHRtbEVudGl0aWVzKGEubWVzc2FnZSkpO3RoaXMuc2hvd0Vycm9yKGMsayxtLGYsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLGQ/ZjpudWxsKX1lbHNlIG51bGwhPWYmJmYoKX07CkVkaXRvclVpLnByb3RvdHlwZS5zaG93RXJyb3I9ZnVuY3Rpb24oYSxjLGYsZCxrLG0scSxiLGUsZyxuLGwscCl7YT1uZXcgRXJyb3JEaWFsb2codGhpcyxhLGMsZnx8bXhSZXNvdXJjZXMuZ2V0KCJvayIpLGQsayxtLHEsbCxiLGUpO2M9TWF0aC5jZWlsKG51bGwhPWM/Yy5sZW5ndGgvNTA6MSk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLGd8fDM0MCxufHwxMDArMjAqYywhMCwhMSxwKTthLmluaXQoKX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dEaWFsb2c9ZnVuY3Rpb24oYSxjLGYsZCxrLG0scSxiLGUsZyl7dGhpcy5lZGl0b3IuZ3JhcGgudG9vbHRpcEhhbmRsZXIuaGlkZVRvb2x0aXAoKTtudWxsPT10aGlzLmRpYWxvZ3MmJih0aGlzLmRpYWxvZ3M9W10pO3RoaXMuZGlhbG9nPW5ldyBEaWFsb2codGhpcyxhLGMsZixkLGssbSxxLGIsZSxnKTt0aGlzLmRpYWxvZ3MucHVzaCh0aGlzLmRpYWxvZyl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaGlkZURpYWxvZz1mdW5jdGlvbihhLGMpe2lmKG51bGwhPXRoaXMuZGlhbG9ncyYmMDx0aGlzLmRpYWxvZ3MubGVuZ3RoKXt2YXIgZj10aGlzLmRpYWxvZ3MucG9wKCk7MD09Zi5jbG9zZShhLGMpP3RoaXMuZGlhbG9ncy5wdXNoKGYpOih0aGlzLmRpYWxvZz0wPHRoaXMuZGlhbG9ncy5sZW5ndGg/dGhpcy5kaWFsb2dzW3RoaXMuZGlhbG9ncy5sZW5ndGgtMV06bnVsbCx0aGlzLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImhpZGVEaWFsb2ciKSksbnVsbD09dGhpcy5kaWFsb2cmJiJoaWRkZW4iIT10aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSYmd2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmVkaXRvci5ncmFwaC5pc0VkaXRpbmcoKSYmbnVsbCE9dGhpcy5lZGl0b3IuZ3JhcGguY2VsbEVkaXRvci50ZXh0YXJlYT90aGlzLmVkaXRvci5ncmFwaC5jZWxsRWRpdG9yLnRleHRhcmVhLmZvY3VzKCk6CihteFV0aWxzLmNsZWFyU2VsZWN0aW9uKCksdGhpcy5lZGl0b3IuZ3JhcGguY29udGFpbmVyLmZvY3VzKCkpfSksMCkpfX07RWRpdG9yVWkucHJvdG90eXBlLmN0cmxFbnRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoO2lmKGEuaXNFbmFibGVkKCkpdHJ5e2Zvcih2YXIgYz1hLmdldFNlbGVjdGlvbkNlbGxzKCksZj1uZXcgbXhEaWN0aW9uYXJ5LGQ9W10saz0wO2s8Yy5sZW5ndGg7aysrKXt2YXIgbT1hLmlzVGFibGVDZWxsKGNba10pP2EubW9kZWwuZ2V0UGFyZW50KGNba10pOmNba107bnVsbD09bXx8Zi5nZXQobSl8fChmLnB1dChtLCEwKSxkLnB1c2gobSkpfWEuc2V0U2VsZWN0aW9uQ2VsbHMoYS5kdXBsaWNhdGVDZWxscyhkLCExKSl9Y2F0Y2gocSl7dGhpcy5oYW5kbGVFcnJvcihxKX19OwpFZGl0b3JVaS5wcm90b3R5cGUucGlja0NvbG9yPWZ1bmN0aW9uKGEsYyl7dmFyIGY9dGhpcy5lZGl0b3IuZ3JhcGgsZD1mLmNlbGxFZGl0b3Iuc2F2ZVNlbGVjdGlvbigpLGs9MjI2KzE3KihNYXRoLmNlaWwoQ29sb3JEaWFsb2cucHJvdG90eXBlLnByZXNldENvbG9ycy5sZW5ndGgvMTIpK01hdGguY2VpbChDb2xvckRpYWxvZy5wcm90b3R5cGUuZGVmYXVsdENvbG9ycy5sZW5ndGgvMTIpKSxtPW5ldyBDb2xvckRpYWxvZyh0aGlzLGF8fCJub25lIixmdW5jdGlvbihhKXtmLmNlbGxFZGl0b3IucmVzdG9yZVNlbGVjdGlvbihkKTtjKGEpfSxmdW5jdGlvbigpe2YuY2VsbEVkaXRvci5yZXN0b3JlU2VsZWN0aW9uKGQpfSk7dGhpcy5zaG93RGlhbG9nKG0uY29udGFpbmVyLDIzMCxrLCEwLCExKTttLmluaXQoKX07CkVkaXRvclVpLnByb3RvdHlwZS5vcGVuRmlsZT1mdW5jdGlvbigpe3dpbmRvdy5vcGVuRmlsZT1uZXcgT3BlbkZpbGUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oaWRlRGlhbG9nKGEpfSkpO3RoaXMuc2hvd0RpYWxvZygobmV3IE9wZW5EaWFsb2codGhpcykpLmNvbnRhaW5lcixFZGl0b3IudXNlTG9jYWxTdG9yYWdlPzY0MDozMjAsRWRpdG9yLnVzZUxvY2FsU3RvcmFnZT80ODA6MjIwLCEwLCEwLGZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW51bGx9KX07CkVkaXRvclVpLnByb3RvdHlwZS5leHRyYWN0R3JhcGhNb2RlbEZyb21IdG1sPWZ1bmN0aW9uKGEpe3ZhciBjPW51bGw7dHJ5e3ZhciBmPWEuaW5kZXhPZigiJmx0O214R3JhcGhNb2RlbCAiKTtpZigwPD1mKXt2YXIgZD1hLmxhc3RJbmRleE9mKCImbHQ7L214R3JhcGhNb2RlbCZndDsiKTtkPmYmJihjPWEuc3Vic3RyaW5nKGYsZCsyMSkucmVwbGFjZSgvJmd0Oy9nLCI+IikucmVwbGFjZSgvJmx0Oy9nLCI8IikucmVwbGFjZSgvXFwmcXVvdDsvZywnIicpLnJlcGxhY2UoL1xuL2csIiIpKX19Y2F0Y2goayl7fXJldHVybiBjfTsKRWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBjPW51bGwsZj1udWxsO251bGwhPWEmJihhPW51bGwhPWEuZGF0YVRyYW5zZmVyP2EuZGF0YVRyYW5zZmVyOmEuY2xpcGJvYXJkRGF0YSxudWxsIT1hJiYoMTA9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8MTE9PWRvY3VtZW50LmRvY3VtZW50TW9kZT9mPWEuZ2V0RGF0YSgiVGV4dCIpOihmPTA8PW14VXRpbHMuaW5kZXhPZihhLnR5cGVzLCJ0ZXh0L2h0bWwiKT9hLmdldERhdGEoInRleHQvaHRtbCIpOm51bGwsbXhVdGlscy5pbmRleE9mKGEudHlwZXMsbnVsbD09Znx8MD09Zi5sZW5ndGgpJiYoZj1hLmdldERhdGEoInRleHQvcGxhaW4iKSkpLG51bGwhPWYmJihmPUdyYXBoLnphcEdyZW1saW5zKG14VXRpbHMudHJpbShmKSksYT10aGlzLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUh0bWwoZiksbnVsbCE9YSYmKGY9YSkpKSk7bnVsbCE9ZiYmdGhpcy5pc0NvbXBhdGlibGVTdHJpbmcoZikmJgooYz1mKTtyZXR1cm4gY307RWRpdG9yVWkucHJvdG90eXBlLmlzQ29tcGF0aWJsZVN0cmluZz1mdW5jdGlvbihhKXtyZXR1cm4hMX07RWRpdG9yVWkucHJvdG90eXBlLnNhdmVGaWxlPWZ1bmN0aW9uKGEpe2F8fG51bGw9PXRoaXMuZWRpdG9yLmZpbGVuYW1lPyhhPW5ldyBGaWxlbmFtZURpYWxvZyh0aGlzLHRoaXMuZWRpdG9yLmdldE9yQ3JlYXRlRmlsZW5hbWUoKSxteFJlc291cmNlcy5nZXQoInNhdmUiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNhdmUoYSl9KSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpcmV0dXJuITA7bXhVdGlscy5jb25maXJtKG14UmVzb3VyY2VzLmdldCgiaW52YWxpZE5hbWUiKSk7cmV0dXJuITF9KSksdGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDMwMCwxMDAsITAsITApLGEuaW5pdCgpKTp0aGlzLnNhdmUodGhpcy5lZGl0b3IuZ2V0T3JDcmVhdGVGaWxlbmFtZSgpKX07CkVkaXRvclVpLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3RoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpJiZ0aGlzLmVkaXRvci5ncmFwaC5zdG9wRWRpdGluZygpO3ZhciBjPW14VXRpbHMuZ2V0WG1sKHRoaXMuZWRpdG9yLmdldEdyYXBoWG1sKCkpO3RyeXtpZihFZGl0b3IudXNlTG9jYWxTdG9yYWdlKXtpZihudWxsIT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhKSYmIW14VXRpbHMuY29uZmlybShteFJlc291cmNlcy5nZXQoInJlcGxhY2VJdCIsW2FdKSkpcmV0dXJuO2xvY2FsU3RvcmFnZS5zZXRJdGVtKGEsYyk7dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgic2F2ZWQiKSkrIiAiK25ldyBEYXRlKX1lbHNlIGlmKGMubGVuZ3RoPE1BWF9SRVFVRVNUX1NJWkUpKG5ldyBteFhtbFJlcXVlc3QoU0FWRV9VUkwsImZpbGVuYW1lPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpKyImeG1sPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKSkuc2ltdWxhdGUoZG9jdW1lbnQsCiJfYmxhbmsiKTtlbHNle214VXRpbHMuYWxlcnQobXhSZXNvdXJjZXMuZ2V0KCJkcmF3aW5nVG9vTGFyZ2UiKSk7bXhVdGlscy5wb3B1cChjKTtyZXR1cm59dGhpcy5lZGl0b3Iuc2V0TW9kaWZpZWQoITEpO3RoaXMuZWRpdG9yLnNldEZpbGVuYW1lKGEpO3RoaXMudXBkYXRlRG9jdW1lbnRUaXRsZSgpfWNhdGNoKGYpe3RoaXMuZWRpdG9yLnNldFN0YXR1cyhteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImVycm9yU2F2aW5nRmlsZSIpKSl9fX07CkVkaXRvclVpLnByb3RvdHlwZS5leGVjdXRlTGF5b3V0PWZ1bmN0aW9uKGEsYyxmKXt2YXIgZD10aGlzLmVkaXRvci5ncmFwaDtpZihkLmlzRW5hYmxlZCgpKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7YSgpfWNhdGNoKGspe3Rocm93IGs7fWZpbmFsbHl7dGhpcy5hbGxvd0FuaW1hdGlvbiYmYyYmKG51bGw9PW5hdmlnYXRvci51c2VyQWdlbnR8fDA+bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJDYW1pbm8iKSk/KGE9bmV3IG14TW9ycGhpbmcoZCksYS5hZGRMaXN0ZW5lcihteEV2ZW50LkRPTkUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCk7bnVsbCE9ZiYmZigpfSkpLGEuc3RhcnRBbmltYXRpb24oKSk6KGQuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKSxudWxsIT1mJiZmKCkpfX19OwpFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0ltYWdlRGlhbG9nPWZ1bmN0aW9uKGEsYyxmLGQpe2Q9dGhpcy5lZGl0b3IuZ3JhcGguY2VsbEVkaXRvcjt2YXIgaz1kLnNhdmVTZWxlY3Rpb24oKSxtPW14VXRpbHMucHJvbXB0KGEsYyk7ZC5yZXN0b3JlU2VsZWN0aW9uKGspO2lmKG51bGwhPW0mJjA8bS5sZW5ndGgpe3ZhciBxPW5ldyBJbWFnZTtxLm9ubG9hZD1mdW5jdGlvbigpe2YobSxxLndpZHRoLHEuaGVpZ2h0KX07cS5vbmVycm9yPWZ1bmN0aW9uKCl7ZihudWxsKTtteFV0aWxzLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgiZmlsZU5vdEZvdW5kIikpfTtxLnNyYz1tfWVsc2UgZihudWxsKX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dMaW5rRGlhbG9nPWZ1bmN0aW9uKGEsYyxmKXthPW5ldyBMaW5rRGlhbG9nKHRoaXMsYSxjLGYpO3RoaXMuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciw0MjAsOTAsITAsITApO2EuaW5pdCgpfTsKRWRpdG9yVWkucHJvdG90eXBlLnNob3dEYXRhRGlhbG9nPWZ1bmN0aW9uKGEpe251bGwhPWEmJihhPW5ldyBFZGl0RGF0YURpYWxvZyh0aGlzLGEpLHRoaXMuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciw0ODAsNDIwLCEwLCExLG51bGwsITEpLGEuaW5pdCgpKX07CkVkaXRvclVpLnByb3RvdHlwZS5zaG93QmFja2dyb3VuZEltYWdlRGlhbG9nPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2E9bmV3IENoYW5nZVBhZ2VTZXR1cCh0aGlzLG51bGwsYSk7YS5pZ25vcmVDb2xvcj0hMDt0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5leGVjdXRlKGEpfSk7dmFyIGM9bXhVdGlscy5wcm9tcHQobXhSZXNvdXJjZXMuZ2V0KCJiYWNrZ3JvdW5kSW1hZ2UiKSwiIik7aWYobnVsbCE9YyYmMDxjLmxlbmd0aCl7dmFyIGY9bmV3IEltYWdlO2Yub25sb2FkPWZ1bmN0aW9uKCl7YShuZXcgbXhJbWFnZShjLGYud2lkdGgsZi5oZWlnaHQpKX07Zi5vbmVycm9yPWZ1bmN0aW9uKCl7YShudWxsKTtteFV0aWxzLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgiZmlsZU5vdEZvdW5kIikpfTtmLnNyYz1jfWVsc2UgYShudWxsKX07CkVkaXRvclVpLnByb3RvdHlwZS5zZXRCYWNrZ3JvdW5kSW1hZ2U9ZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3IuZ3JhcGguc2V0QmFja2dyb3VuZEltYWdlKGEpO3RoaXMuZWRpdG9yLmdyYXBoLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kSW1hZ2UoKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiYmFja2dyb3VuZEltYWdlQ2hhbmdlZCIpKX07RWRpdG9yVWkucHJvdG90eXBlLmNvbmZpcm09ZnVuY3Rpb24oYSxjLGYpe214VXRpbHMuY29uZmlybShhKT9udWxsIT1jJiZjKCk6bnVsbCE9ZiYmZigpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZU91dGxpbmU9ZnVuY3Rpb24oYSl7dmFyIGM9bmV3IG14T3V0bGluZSh0aGlzLmVkaXRvci5ncmFwaCk7Yy5ib3JkZXI9MjA7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsZnVuY3Rpb24oKXtjLnVwZGF0ZSgpfSk7dGhpcy5hZGRMaXN0ZW5lcigicGFnZUZvcm1hdENoYW5nZWQiLGZ1bmN0aW9uKCl7Yy51cGRhdGUoKX0pO3JldHVybiBjfTtFZGl0b3JVaS5wcm90b3R5cGUuYWx0U2hpZnRBY3Rpb25zPXs2NzoiY2xlYXJXYXlwb2ludHMiLDY1OiJjb25uZWN0aW9uQXJyb3dzIiw3NjoiZWRpdExpbmsiLDgwOiJjb25uZWN0aW9uUG9pbnRzIiw4NDoiZWRpdFRvb2x0aXAiLDg2OiJwYXN0ZVNpemUiLDg4OiJjb3B5U2l6ZSJ9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlS2V5SGFuZGxlcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBjKGEsZSxjKXtxLnB1c2goZnVuY3Rpb24oKXtpZighZC5pc1NlbGVjdGlvbkVtcHR5KCkmJmQuaXNFbmFibGVkKCkpaWYoZT1udWxsIT1lP2U6MSxjKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBiPWQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxnPTA7ZzxiLmxlbmd0aDtnKyspaWYoZC5nZXRNb2RlbCgpLmlzVmVydGV4KGJbZ10pJiZkLmlzQ2VsbFJlc2l6YWJsZShiW2ddKSl7dmFyIGY9ZC5nZXRDZWxsR2VvbWV0cnkoYltnXSk7bnVsbCE9ZiYmKGY9Zi5jbG9uZSgpLDM3PT1hP2Yud2lkdGg9TWF0aC5tYXgoMCxmLndpZHRoLWUpOjM4PT1hP2YuaGVpZ2h0PU1hdGgubWF4KDAsZi5oZWlnaHQtZSk6Mzk9PWE/Zi53aWR0aCs9ZTo0MD09YSYmKGYuaGVpZ2h0Kz1lKSxkLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkoYltnXSxmKSl9fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX1lbHNle3ZhciBuPQpkLmdldFNlbGVjdGlvbkNlbGwoKSxmPWQubW9kZWwuZ2V0UGFyZW50KG4pLGI9bnVsbDsxPT1kLmdldFNlbGVjdGlvbkNvdW50KCkmJmQubW9kZWwuaXNWZXJ0ZXgobikmJm51bGwhPWQubGF5b3V0TWFuYWdlciYmIWQuaXNDZWxsTG9ja2VkKG4pJiYoYj1kLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0KGYpKTtpZihudWxsIT1iJiZiLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0KWI9Zi5nZXRJbmRleChuKSwzNz09YXx8Mzg9PWE/ZC5tb2RlbC5hZGQoZixuLE1hdGgubWF4KDAsYi0xKSk6MzkhPWEmJjQwIT1hfHxkLm1vZGVsLmFkZChmLG4sTWF0aC5taW4oZC5tb2RlbC5nZXRDaGlsZENvdW50KGYpLGIrMSkpO2Vsc2V7Yj1kLmdldE1vdmFibGVDZWxscyhkLmdldFNlbGVjdGlvbkNlbGxzKCkpO249W107Zm9yKGc9MDtnPGIubGVuZ3RoO2crKylmPWQuZ2V0Q3VycmVudENlbGxTdHlsZShiW2ddKSwiMSI9PW14VXRpbHMuZ2V0VmFsdWUoZiwicGFydCIsIjAiKT8oZj1kLm1vZGVsLmdldFBhcmVudChiW2ddKSwKZC5tb2RlbC5pc1ZlcnRleChmKSYmMD5teFV0aWxzLmluZGV4T2YoYixmKSYmbi5wdXNoKGYpKTpuLnB1c2goYltnXSk7MDxuLmxlbmd0aCYmKGI9Zj0wLDM3PT1hP2Y9LWU6Mzg9PWE/Yj0tZTozOT09YT9mPWU6NDA9PWEmJihiPWUpLGQubW92ZUNlbGxzKG4sZixiKSl9fX0pO251bGwhPWImJndpbmRvdy5jbGVhclRpbWVvdXQoYik7Yj13aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2lmKDA8cS5sZW5ndGgpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGE9MDthPHEubGVuZ3RoO2ErKylxW2FdKCk7cT1bXX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19fSwyMDApfXZhciBmPXRoaXMsZD10aGlzLmVkaXRvci5ncmFwaCxrPW5ldyBteEtleUhhbmRsZXIoZCksbT1rLmlzRXZlbnRJZ25vcmVkO2suaXNFdmVudElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIShteEV2ZW50LmlzU2hpZnREb3duKGEpJiY5PT1hLmtleUNvZGUpJiYoIXRoaXMuaXNDb250cm9sRG93bihhKXx8Cm14RXZlbnQuaXNTaGlmdERvd24oYSl8fDkwIT1hLmtleUNvZGUmJjg5IT1hLmtleUNvZGUmJjE4OCE9YS5rZXlDb2RlJiYxOTAhPWEua2V5Q29kZSYmODUhPWEua2V5Q29kZSkmJig2NiE9YS5rZXlDb2RlJiY3MyE9YS5rZXlDb2RlfHwhdGhpcy5pc0NvbnRyb2xEb3duKGEpfHx0aGlzLmdyYXBoLmNlbGxFZGl0b3IuaXNDb250ZW50RWRpdGluZygpJiYhbXhDbGllbnQuSVNfRkYmJiFteENsaWVudC5JU19TRikmJm0uYXBwbHkodGhpcyxhcmd1bWVudHMpfTtrLmlzRW5hYmxlZEZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzQ29uc3VtZWQoYSkmJnRoaXMuaXNHcmFwaEV2ZW50KGEpJiZ0aGlzLmlzRW5hYmxlZCgpJiYobnVsbD09Zi5kaWFsb2dzfHwwPT1mLmRpYWxvZ3MubGVuZ3RoKX07ay5pc0NvbnRyb2xEb3duPWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzQ29udHJvbERvd24oYSl8fG14Q2xpZW50LklTX01BQyYmYS5tZXRhS2V5fTt2YXIgcT1bXSxiPQpudWxsLGU9ezM3Om14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNULDM4Om14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCwzOTpteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCw0MDpteENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh9LGc9ay5nZXRGdW5jdGlvbjtteEtleUhhbmRsZXIucHJvdG90eXBlLmdldEZ1bmN0aW9uPWZ1bmN0aW9uKGEpe2lmKGQuaXNFbmFibGVkKCkpe2lmKG14RXZlbnQuaXNTaGlmdERvd24oYSkmJm14RXZlbnQuaXNBbHREb3duKGEpKXt2YXIgYj1mLmFjdGlvbnMuZ2V0KGYuYWx0U2hpZnRBY3Rpb25zW2Eua2V5Q29kZV0pO2lmKG51bGwhPWIpcmV0dXJuIGIuZnVuY3R9aWYoOT09YS5rZXlDb2RlJiZteEV2ZW50LmlzQWx0RG93bihhKSlyZXR1cm4gZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKT9mdW5jdGlvbigpe2RvY3VtZW50LmV4ZWNDb21tYW5kKCJvdXRkZW50IiwhMSxudWxsKX06bXhFdmVudC5pc1NoaWZ0RG93bihhKT9mdW5jdGlvbigpe2Quc2VsZWN0UGFyZW50Q2VsbCgpfToKZnVuY3Rpb24oKXtkLnNlbGVjdENoaWxkQ2VsbCgpfTtpZihudWxsIT1lW2Eua2V5Q29kZV0mJiFkLmlzU2VsZWN0aW9uRW1wdHkoKSlpZighdGhpcy5pc0NvbnRyb2xEb3duKGEpJiZteEV2ZW50LmlzU2hpZnREb3duKGEpJiZteEV2ZW50LmlzQWx0RG93bihhKSl7aWYoZC5tb2RlbC5pc1ZlcnRleChkLmdldFNlbGVjdGlvbkNlbGwoKSkpcmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGI9ZC5jb25uZWN0VmVydGV4KGQuZ2V0U2VsZWN0aW9uQ2VsbCgpLGVbYS5rZXlDb2RlXSxkLmRlZmF1bHRFZGdlTGVuZ3RoLGEsITApO251bGwhPWImJjA8Yi5sZW5ndGgmJigxPT1iLmxlbmd0aCYmZC5tb2RlbC5pc0VkZ2UoYlswXSk/ZC5zZXRTZWxlY3Rpb25DZWxsKGQubW9kZWwuZ2V0VGVybWluYWwoYlswXSwhMSkpOmQuc2V0U2VsZWN0aW9uQ2VsbChiW2IubGVuZ3RoLTFdKSxkLnNjcm9sbENlbGxUb1Zpc2libGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpLG51bGwhPWYuaG92ZXJJY29ucyYmZi5ob3Zlckljb25zLnVwZGF0ZShkLnZpZXcuZ2V0U3RhdGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpKSl9fWVsc2UgcmV0dXJuIHRoaXMuaXNDb250cm9sRG93bihhKT8KZnVuY3Rpb24oKXtjKGEua2V5Q29kZSxteEV2ZW50LmlzU2hpZnREb3duKGEpP2QuZ3JpZFNpemU6bnVsbCwhMCl9OmZ1bmN0aW9uKCl7YyhhLmtleUNvZGUsbXhFdmVudC5pc1NoaWZ0RG93bihhKT9kLmdyaWRTaXplOm51bGwpfX1yZXR1cm4gZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2suYmluZEFjdGlvbj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIsZSxkKXt2YXIgYz10aGlzLmFjdGlvbnMuZ2V0KGUpO251bGwhPWMmJihlPWZ1bmN0aW9uKCl7Yy5pc0VuYWJsZWQoKSYmYy5mdW5jdCgpfSxiP2Q/ay5iaW5kQ29udHJvbFNoaWZ0S2V5KGEsZSk6ay5iaW5kQ29udHJvbEtleShhLGUpOmQ/ay5iaW5kU2hpZnRLZXkoYSxlKTprLmJpbmRLZXkoYSxlKSl9KTt2YXIgbj10aGlzLGw9ay5lc2NhcGU7ay5lc2NhcGU9ZnVuY3Rpb24oYSl7bC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2suZW50ZXI9ZnVuY3Rpb24oKXt9O2suYmluZENvbnRyb2xTaGlmdEtleSgzNixmdW5jdGlvbigpe2QuZXhpdEdyb3VwKCl9KTsKay5iaW5kQ29udHJvbFNoaWZ0S2V5KDM1LGZ1bmN0aW9uKCl7ZC5lbnRlckdyb3VwKCl9KTtrLmJpbmRTaGlmdEtleSgzNixmdW5jdGlvbigpe2QuaG9tZSgpfSk7ay5iaW5kS2V5KDM1LGZ1bmN0aW9uKCl7ZC5yZWZyZXNoKCl9KTtrLmJpbmRBY3Rpb24oMTA3LCEwLCJ6b29tSW4iKTtrLmJpbmRBY3Rpb24oMTA5LCEwLCJ6b29tT3V0Iik7ay5iaW5kQWN0aW9uKDgwLCEwLCJwcmludCIpO2suYmluZEFjdGlvbig3OSwhMCwib3V0bGluZSIsITApO2lmKCF0aGlzLmVkaXRvci5jaHJvbWVsZXNzfHx0aGlzLmVkaXRvci5lZGl0YWJsZSlrLmJpbmRDb250cm9sS2V5KDM2LGZ1bmN0aW9uKCl7ZC5pc0VuYWJsZWQoKSYmZC5mb2xkQ2VsbHMoITApfSksay5iaW5kQ29udHJvbEtleSgzNSxmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJmQuZm9sZENlbGxzKCExKX0pLGsuYmluZENvbnRyb2xLZXkoMTMsZnVuY3Rpb24oKXtuLmN0cmxFbnRlcigpfSksay5iaW5kQWN0aW9uKDgsITEsImRlbGV0ZSIpLAprLmJpbmRBY3Rpb24oOCwhMCwiZGVsZXRlQWxsIiksay5iaW5kQWN0aW9uKDQ2LCExLCJkZWxldGUiKSxrLmJpbmRBY3Rpb24oNDYsITAsImRlbGV0ZUFsbCIpLGsuYmluZEFjdGlvbigzNiwhMSwicmVzZXRWaWV3Iiksay5iaW5kQWN0aW9uKDcyLCEwLCJmaXRXaW5kb3ciLCEwKSxrLmJpbmRBY3Rpb24oNzQsITAsImZpdFBhZ2UiKSxrLmJpbmRBY3Rpb24oNzQsITAsImZpdFR3b1BhZ2VzIiwhMCksay5iaW5kQWN0aW9uKDQ4LCEwLCJjdXN0b21ab29tIiksay5iaW5kQWN0aW9uKDgyLCEwLCJ0dXJuIiksay5iaW5kQWN0aW9uKDgyLCEwLCJjbGVhckRlZmF1bHRTdHlsZSIsITApLGsuYmluZEFjdGlvbig4MywhMCwic2F2ZSIpLGsuYmluZEFjdGlvbig4MywhMCwic2F2ZUFzIiwhMCksay5iaW5kQWN0aW9uKDY1LCEwLCJzZWxlY3RBbGwiKSxrLmJpbmRBY3Rpb24oNjUsITAsInNlbGVjdE5vbmUiLCEwKSxrLmJpbmRBY3Rpb24oNzMsITAsInNlbGVjdFZlcnRpY2VzIiwhMCksay5iaW5kQWN0aW9uKDY5LAohMCwic2VsZWN0RWRnZXMiLCEwKSxrLmJpbmRBY3Rpb24oNjksITAsImVkaXRTdHlsZSIpLGsuYmluZEFjdGlvbig2NiwhMCwiYm9sZCIpLGsuYmluZEFjdGlvbig2NiwhMCwidG9CYWNrIiwhMCksay5iaW5kQWN0aW9uKDcwLCEwLCJ0b0Zyb250IiwhMCksay5iaW5kQWN0aW9uKDY4LCEwLCJkdXBsaWNhdGUiKSxrLmJpbmRBY3Rpb24oNjgsITAsInNldEFzRGVmYXVsdFN0eWxlIiwhMCksay5iaW5kQWN0aW9uKDkwLCEwLCJ1bmRvIiksay5iaW5kQWN0aW9uKDg5LCEwLCJhdXRvc2l6ZSIsITApLGsuYmluZEFjdGlvbig4OCwhMCwiY3V0Iiksay5iaW5kQWN0aW9uKDY3LCEwLCJjb3B5Iiksay5iaW5kQWN0aW9uKDg2LCEwLCJwYXN0ZSIpLGsuYmluZEFjdGlvbig3MSwhMCwiZ3JvdXAiKSxrLmJpbmRBY3Rpb24oNzcsITAsImVkaXREYXRhIiksay5iaW5kQWN0aW9uKDcxLCEwLCJncmlkIiwhMCksay5iaW5kQWN0aW9uKDczLCEwLCJpdGFsaWMiKSxrLmJpbmRBY3Rpb24oNzYsITAsImxvY2tVbmxvY2siKSwKay5iaW5kQWN0aW9uKDc2LCEwLCJsYXllcnMiLCEwKSxrLmJpbmRBY3Rpb24oODAsITAsImZvcm1hdFBhbmVsIiwhMCksay5iaW5kQWN0aW9uKDg1LCEwLCJ1bmRlcmxpbmUiKSxrLmJpbmRBY3Rpb24oODUsITAsInVuZ3JvdXAiLCEwKSxrLmJpbmRBY3Rpb24oMTkwLCEwLCJzdXBlcnNjcmlwdCIpLGsuYmluZEFjdGlvbigxODgsITAsInN1YnNjcmlwdCIpLGsuYmluZEFjdGlvbig5LCExLCJpbmRlbnQiLCEwKSxrLmJpbmRLZXkoMTMsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiZkLnN0YXJ0RWRpdGluZ0F0Q2VsbCgpfSksay5iaW5kS2V5KDExMyxmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJmQuc3RhcnRFZGl0aW5nQXRDZWxsKCl9KTtteENsaWVudC5JU19XSU4/ay5iaW5kQWN0aW9uKDg5LCEwLCJyZWRvIik6ay5iaW5kQWN0aW9uKDkwLCEwLCJyZWRvIiwhMCk7cmV0dXJuIGt9OwpFZGl0b3JVaS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe251bGwhPXRoaXMuZWRpdG9yJiYodGhpcy5lZGl0b3IuZGVzdHJveSgpLHRoaXMuZWRpdG9yPW51bGwpO251bGwhPXRoaXMubWVudWJhciYmKHRoaXMubWVudWJhci5kZXN0cm95KCksdGhpcy5tZW51YmFyPW51bGwpO251bGwhPXRoaXMudG9vbGJhciYmKHRoaXMudG9vbGJhci5kZXN0cm95KCksdGhpcy50b29sYmFyPW51bGwpO251bGwhPXRoaXMuc2lkZWJhciYmKHRoaXMuc2lkZWJhci5kZXN0cm95KCksdGhpcy5zaWRlYmFyPW51bGwpO251bGwhPXRoaXMua2V5SGFuZGxlciYmKHRoaXMua2V5SGFuZGxlci5kZXN0cm95KCksdGhpcy5rZXlIYW5kbGVyPW51bGwpO251bGwhPXRoaXMua2V5ZG93bkhhbmRsZXImJihteEV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCJrZXlkb3duIix0aGlzLmtleWRvd25IYW5kbGVyKSx0aGlzLmtleWRvd25IYW5kbGVyPW51bGwpO251bGwhPXRoaXMua2V5dXBIYW5kbGVyJiYKKG14RXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsImtleXVwIix0aGlzLmtleXVwSGFuZGxlciksdGhpcy5rZXl1cEhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5yZXNpemVIYW5kbGVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsdGhpcy5yZXNpemVIYW5kbGVyKSx0aGlzLnJlc2l6ZUhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5nZXN0dXJlSGFuZGxlciYmKG14RXZlbnQucmVtb3ZlR2VzdHVyZUxpc3RlbmVycyhkb2N1bWVudCx0aGlzLmdlc3R1cmVIYW5kbGVyKSx0aGlzLmdlc3R1cmVIYW5kbGVyPW51bGwpO251bGwhPXRoaXMub3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcih3aW5kb3csIm9yaWVudGF0aW9uY2hhbmdlIix0aGlzLm9yaWVudGF0aW9uQ2hhbmdlSGFuZGxlciksdGhpcy5vcmllbnRhdGlvbkNoYW5nZUhhbmRsZXI9bnVsbCk7bnVsbCE9dGhpcy5zY3JvbGxIYW5kbGVyJiYobXhFdmVudC5yZW1vdmVMaXN0ZW5lcih3aW5kb3csCiJzY3JvbGwiLHRoaXMuc2Nyb2xsSGFuZGxlciksdGhpcy5zY3JvbGxIYW5kbGVyPW51bGwpO2lmKG51bGwhPXRoaXMuZGVzdHJveUZ1bmN0aW9ucyl7Zm9yKHZhciBhPTA7YTx0aGlzLmRlc3Ryb3lGdW5jdGlvbnMubGVuZ3RoO2ErKyl0aGlzLmRlc3Ryb3lGdW5jdGlvbnNbYV0oKTt0aGlzLmRlc3Ryb3lGdW5jdGlvbnM9bnVsbH1mb3IodmFyIGM9W3RoaXMubWVudWJhckNvbnRhaW5lcix0aGlzLnRvb2xiYXJDb250YWluZXIsdGhpcy5zaWRlYmFyQ29udGFpbmVyLHRoaXMuZm9ybWF0Q29udGFpbmVyLHRoaXMuZGlhZ3JhbUNvbnRhaW5lcix0aGlzLmZvb3RlckNvbnRhaW5lcix0aGlzLmNocm9tZWxlc3NUb29sYmFyLHRoaXMuaHNwbGl0LHRoaXMuc2lkZWJhckZvb3RlckNvbnRhaW5lcix0aGlzLmxheWVyc0RpYWxvZ10sYT0wO2E8Yy5sZW5ndGg7YSsrKW51bGwhPWNbYV0mJm51bGwhPWNbYV0ucGFyZW50Tm9kZSYmY1thXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNbYV0pfTsidW5kZWZpbmVkIiE9PXR5cGVvZiBodG1sNCYmKGh0bWw0LkFUVFJJQlNbImE6OnRhcmdldCJdPTAsaHRtbDQuQVRUUklCU1sic291cmNlOjpzcmMiXT0wLGh0bWw0LkFUVFJJQlNbInZpZGVvOjpzcmMiXT0wKTsoZnVuY3Rpb24oKXt2YXIgYT1bWyJuYnNwIiwiMTYwIl0sWyJzaHkiLCIxNzMiXV0sYz1teFV0aWxzLnBhcnNlWG1sO214VXRpbHMucGFyc2VYbWw9ZnVuY3Rpb24oZil7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspZj1mLnJlcGxhY2UobmV3IFJlZ0V4cCgiJiIrYVtkXVswXSsiOyIsImciKSwiJiMiK2FbZF1bMV0rIjsiKTtyZXR1cm4gYyhmKX19KSgpOwpEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZ3x8ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2E9U3RyaW5nKGEpOzE9PT1hLmxlbmd0aCYmKGE9IjAiK2EpO3JldHVybiBhfURhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSsiLSIrYSh0aGlzLmdldFVUQ01vbnRoKCkrMSkrIi0iK2EodGhpcy5nZXRVVENEYXRlKCkpKyJUIithKHRoaXMuZ2V0VVRDSG91cnMoKSkrIjoiK2EodGhpcy5nZXRVVENNaW51dGVzKCkpKyI6IithKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSsiLiIrU3RyaW5nKCh0aGlzLmdldFVUQ01pbGxpc2Vjb25kcygpLzFFMykudG9GaXhlZCgzKSkuc2xpY2UoMiw1KSsiWiJ9fSgpO0RhdGUubm93fHwoRGF0ZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX0pO214Q29uc3RhbnRzLlBPSU5UUz0xO214Q29uc3RhbnRzLk1JTExJTUVURVJTPTI7bXhDb25zdGFudHMuSU5DSEVTPTM7Cm14Q29uc3RhbnRzLlBJWEVMU19QRVJfTU09My45Mzc7bXhDb25zdGFudHMuUElYRUxTX1BFUl9JTkNIPTEwMDtteENvbnN0YW50cy5TSEFET1dfT1BBQ0lUWT0uMjU7bXhDb25zdGFudHMuU0hBRE9XQ09MT1I9IiMwMDAwMDAiO214Q29uc3RhbnRzLlZNTF9TSEFET1dDT0xPUj0iI2QwZDBkMCI7bXhHcmFwaC5wcm90b3R5cGUucGFnZUJyZWFrQ29sb3I9IiNjMGMwYzAiO214R3JhcGgucHJvdG90eXBlLnBhZ2VTY2FsZT0xOyhmdW5jdGlvbigpe3RyeXtpZihudWxsIT1uYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvci5sYW5ndWFnZSl7dmFyIGE9bmF2aWdhdG9yLmxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7bXhHcmFwaC5wcm90b3R5cGUucGFnZUZvcm1hdD0iZW4tdXMiPT09YXx8ImVuLWNhIj09PWF8fCJlcy1teCI9PT1hP214Q29uc3RhbnRzLlBBR0VfRk9STUFUX0xFVFRFUl9QT1JUUkFJVDpteENvbnN0YW50cy5QQUdFX0ZPUk1BVF9BNF9QT1JUUkFJVH19Y2F0Y2goYyl7fX0pKCk7Cm14VGV4dC5wcm90b3R5cGUuYmFzZVNwYWNpbmdUb3A9NTtteFRleHQucHJvdG90eXBlLmJhc2VTcGFjaW5nQm90dG9tPTE7bXhHcmFwaE1vZGVsLnByb3RvdHlwZS5pZ25vcmVSZWxhdGl2ZUVkZ2VQYXJlbnQ9ITE7bXhHcmFwaFZpZXcucHJvdG90eXBlLmdyaWRJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaENnQUtBSkVBQUFBQUFQLy8vOHpNelAvLy95SDVCQUVBQUFNQUxBQUFBQUFLQUFvQUFBSUoxSTZweSswUG8yd0ZBRHM9IjpJTUFHRV9QQVRIKyIvZ3JpZC5naWYiO214R3JhcGhWaWV3LnByb3RvdHlwZS5ncmlkU3RlcHM9NDtteEdyYXBoVmlldy5wcm90b3R5cGUubWluR3JpZFNpemU9NDtteEdyYXBoVmlldy5wcm90b3R5cGUuZGVmYXVsdEdyaWRDb2xvcj0iI2QwZDBkMCI7bXhHcmFwaFZpZXcucHJvdG90eXBlLmdyaWRDb2xvcj1teEdyYXBoVmlldy5wcm90b3R5cGUuZGVmYXVsdEdyaWRDb2xvcjsKbXhHcmFwaFZpZXcucHJvdG90eXBlLnVuaXQ9bXhDb25zdGFudHMuUE9JTlRTO214R3JhcGhWaWV3LnByb3RvdHlwZS5zZXRVbml0PWZ1bmN0aW9uKGEpe3RoaXMudW5pdCE9YSYmKHRoaXMudW5pdD1hLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJ1bml0Q2hhbmdlZCIsInVuaXQiLGEpKSl9O214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvQWx0VGV4dD0iW05vdCBzdXBwb3J0ZWQgYnkgdmlld2VyXSI7bXhTaGFwZS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxjLGYpe3JldHVybiBudWxsfTsKR3JhcGg9ZnVuY3Rpb24oYSxjLGYsZCxrLG0pe214R3JhcGguY2FsbCh0aGlzLGEsYyxmLGQpO3RoaXMudGhlbWVzPWt8fHRoaXMuZGVmYXVsdFRoZW1lczt0aGlzLmN1cnJlbnRFZGdlU3R5bGU9bXhVdGlscy5jbG9uZSh0aGlzLmRlZmF1bHRFZGdlU3R5bGUpO3RoaXMuY3VycmVudFZlcnRleFN0eWxlPW14VXRpbHMuY2xvbmUodGhpcy5kZWZhdWx0VmVydGV4U3R5bGUpO3RoaXMuc3RhbmRhbG9uZT1udWxsIT1tP206ITE7YT10aGlzLmJhc2VVcmw7Yz1hLmluZGV4T2YoIi8vIik7dGhpcy5kb21haW5QYXRoVXJsPXRoaXMuZG9tYWluVXJsPSIiOzA8YyYmKGM9YS5pbmRleE9mKCIvIixjKzIpLDA8YyYmKHRoaXMuZG9tYWluVXJsPWEuc3Vic3RyaW5nKDAsYykpLGM9YS5sYXN0SW5kZXhPZigiLyIpLDA8YyYmKHRoaXMuZG9tYWluUGF0aFVybD1hLnN1YnN0cmluZygwLGMrMSkpKTt0aGlzLmlzSHRtbExhYmVsPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpOwpyZXR1cm4gbnVsbCE9YT8iMSI9PWEuaHRtbHx8IndyYXAiPT1hW214Q29uc3RhbnRzLlNUWUxFX1dISVRFX1NQQUNFXTohMX07aWYodGhpcy5lZGdlTW9kZSl7dmFyIHE9bnVsbCxiPW51bGwsZT1udWxsLGc9bnVsbCxuPSExO3RoaXMuYWRkTGlzdGVuZXIobXhFdmVudC5GSVJFX01PVVNFX0VWRU5ULG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZCl7aWYoIm1vdXNlRG93biI9PWQuZ2V0UHJvcGVydHkoImV2ZW50TmFtZSIpJiZ0aGlzLmlzRW5hYmxlZCgpKXt2YXIgYz1kLmdldFByb3BlcnR5KCJldmVudCIpLGY9Yy5nZXRTdGF0ZSgpO2lmKCFteEV2ZW50LmlzQWx0RG93bihjLmdldEV2ZW50KCkpJiZudWxsIT1mKWlmKHRoaXMubW9kZWwuaXNFZGdlKGYuY2VsbCkpaWYocT1uZXcgbXhQb2ludChjLmdldEdyYXBoWCgpLGMuZ2V0R3JhcGhZKCkpLG49dGhpcy5pc0NlbGxTZWxlY3RlZChmLmNlbGwpLGU9ZixiPWMsbnVsbCE9Zi50ZXh0JiZudWxsIT1mLnRleHQuYm91bmRpbmdCb3gmJgpteFV0aWxzLmNvbnRhaW5zKGYudGV4dC5ib3VuZGluZ0JveCxjLmdldEdyYXBoWCgpLGMuZ2V0R3JhcGhZKCkpKWc9bXhFdmVudC5MQUJFTF9IQU5ETEU7ZWxzZXt2YXIgbD10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKGYuY2VsbCk7bnVsbCE9bCYmbnVsbCE9bC5iZW5kcyYmMDxsLmJlbmRzLmxlbmd0aCYmKGc9bC5nZXRIYW5kbGVGb3JFdmVudChjKSl9ZWxzZSBpZighdGhpcy5wYW5uaW5nSGFuZGxlci5pc0FjdGl2ZSgpJiYobD10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKGYuY2VsbCksbnVsbD09bHx8bnVsbD09bC5nZXRIYW5kbGVGb3JFdmVudChjKSkpe3ZhciBwPW5ldyBteFJlY3RhbmdsZShjLmdldEdyYXBoWCgpLGMuZ2V0R3JhcGhZKCkpO3AuZ3JvdyhteFNoYXBlLnByb3RvdHlwZS5zdmdTdHJva2VUb2xlcmFuY2UtMSk7aWYodGhpcy5pc1RhYmxlQ2VsbChmLmNlbGwpKXt2YXIgbD10aGlzLm1vZGVsLmdldFBhcmVudChmLmNlbGwpLAp1PXRoaXMubW9kZWwuZ2V0UGFyZW50KGwpO2lmKG14VXRpbHMuaW50ZXJzZWN0cyhwLG5ldyBteFJlY3RhbmdsZShmLngsZi55LTEsZi53aWR0aCwxKSkmJnRoaXMubW9kZWwuZ2V0Q2hpbGRBdCh1LDApIT1sfHxteFV0aWxzLmludGVyc2VjdHMocCxuZXcgbXhSZWN0YW5nbGUoZi54LGYueStmLmhlaWdodC0xLGYud2lkdGgsMSkpfHxteFV0aWxzLmludGVyc2VjdHMocCxuZXcgbXhSZWN0YW5nbGUoZi54LTEsZi55LDEsZi5oZWlnaHQpKSYmdGhpcy5tb2RlbC5nZXRDaGlsZEF0KGwsMCkhPWYuY2VsbHx8bXhVdGlscy5pbnRlcnNlY3RzKHAsbmV3IG14UmVjdGFuZ2xlKGYueCtmLndpZHRoLTEsZi55LDEsZi5oZWlnaHQpKSl0aGlzLnNlbGVjdENlbGxGb3JFdmVudCh1LGMuZ2V0RXZlbnQoKSksbD10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKHUpLG51bGwhPWwmJih1PWwuZ2V0SGFuZGxlRm9yRXZlbnQoYyksbnVsbCE9dSYmKGwuc3RhcnQoYy5nZXRHcmFwaFgoKSwKYy5nZXRHcmFwaFkoKSx1KSxjLmNvbnN1bWUoKSkpfWZvcig7IWMuaXNDb25zdW1lZCgpJiZudWxsIT1mJiYodGhpcy5pc1RhYmxlQ2VsbChmLmNlbGwpfHx0aGlzLmlzVGFibGVSb3coZi5jZWxsKXx8dGhpcy5pc1RhYmxlKGYuY2VsbCkpOyl0aGlzLmlzU3dpbWxhbmUoZi5jZWxsKSYmKGw9dGhpcy5nZXRBY3R1YWxTdGFydFNpemUoZi5jZWxsKSwoMDxsLnh8fDA8bC53aWR0aCkmJm14VXRpbHMuaW50ZXJzZWN0cyhwLG5ldyBteFJlY3RhbmdsZShmLngrbC54LWwud2lkdGgtMSsoMD09bC54P2Yud2lkdGg6MCksZi55LDEsZi5oZWlnaHQpKXx8KDA8bC55fHwwPGwuaGVpZ2h0KSYmbXhVdGlscy5pbnRlcnNlY3RzKHAsbmV3IG14UmVjdGFuZ2xlKGYueCxmLnkrbC55LWwuaGVpZ2h0LTErKDA9PWwueT9mLmhlaWdodDowKSxmLndpZHRoLDEpKSkmJih0aGlzLnNlbGVjdENlbGxGb3JFdmVudChmLmNlbGwsYy5nZXRFdmVudCgpKSxsPXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmdldEhhbmRsZXIoZi5jZWxsKSwKbnVsbCE9bCYmKHU9bXhFdmVudC5DVVNUT01fSEFORExFLWwuY3VzdG9tSGFuZGxlcy5sZW5ndGgrMSxsLnN0YXJ0KGMuZ2V0R3JhcGhYKCksYy5nZXRHcmFwaFkoKSx1KSxjLmNvbnN1bWUoKSkpLGY9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGYuY2VsbCkpfX19KSk7dGhpcy5hZGRNb3VzZUxpc3RlbmVyKHttb3VzZURvd246ZnVuY3Rpb24oYSxiKXt9LG1vdXNlTW92ZTpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe3ZhciBjPXRoaXMuc2VsZWN0aW9uQ2VsbHNIYW5kbGVyLmhhbmRsZXJzLm1hcCxmO2ZvcihmIGluIGMpaWYobnVsbCE9Y1tmXS5pbmRleClyZXR1cm47aWYodGhpcy5pc0VuYWJsZWQoKSYmIXRoaXMucGFubmluZ0hhbmRsZXIuaXNBY3RpdmUoKSYmIW14RXZlbnQuaXNBbHREb3duKGQuZ2V0RXZlbnQoKSkpaWYoZj10aGlzLnRvbGVyYW5jZSxudWxsIT1xJiZudWxsIT1lJiZudWxsIT1iKXtpZihjPWUsTWF0aC5hYnMocS54LWQuZ2V0R3JhcGhYKCkpPgpmfHxNYXRoLmFicyhxLnktZC5nZXRHcmFwaFkoKSk+Zil7dGhpcy5pc0NlbGxTZWxlY3RlZChjLmNlbGwpfHx0aGlzLnNlbGVjdENlbGxGb3JFdmVudChjLmNlbGwsZC5nZXRFdmVudCgpKTt2YXIgbD10aGlzLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKGMuY2VsbCk7aWYobnVsbCE9bCYmbnVsbCE9bC5iZW5kcyYmMDxsLmJlbmRzLmxlbmd0aCl7Zj1sLmdldEhhbmRsZUZvckV2ZW50KGIpO3ZhciBwPXRoaXMudmlldy5nZXRFZGdlU3R5bGUoYyksdT1wPT1teEVkZ2VTdHlsZS5FbnRpdHlSZWxhdGlvbjtufHxnIT1teEV2ZW50LkxBQkVMX0hBTkRMRXx8KGY9Zyk7aWYodSYmMCE9ZiYmZiE9bC5iZW5kcy5sZW5ndGgtMSYmZiE9bXhFdmVudC5MQUJFTF9IQU5ETEUpIXV8fG51bGw9PWMudmlzaWJsZVNvdXJjZVN0YXRlJiZudWxsPT1jLnZpc2libGVUYXJnZXRTdGF0ZXx8KHRoaXMuZ3JhcGhIYW5kbGVyLnJlc2V0KCksZC5jb25zdW1lKCkpO2Vsc2UgaWYoZj09bXhFdmVudC5MQUJFTF9IQU5ETEV8fAowPT1mfHxudWxsIT1jLnZpc2libGVTb3VyY2VTdGF0ZXx8Zj09bC5iZW5kcy5sZW5ndGgtMXx8bnVsbCE9Yy52aXNpYmxlVGFyZ2V0U3RhdGUpdXx8Zj09bXhFdmVudC5MQUJFTF9IQU5ETEV8fCh1PWMuYWJzb2x1dGVQb2ludHMsbnVsbCE9dSYmKG51bGw9PXAmJm51bGw9PWZ8fHA9PW14RWRnZVN0eWxlLk9ydGhDb25uZWN0b3IpJiYoZj1nLG51bGw9PWYmJihmPW5ldyBteFJlY3RhbmdsZShxLngscS55KSxmLmdyb3cobXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2Uud2lkdGgvMiksbXhVdGlscy5jb250YWlucyhmLHVbMF0ueCx1WzBdLnkpP2Y9MDpteFV0aWxzLmNvbnRhaW5zKGYsdVt1Lmxlbmd0aC0xXS54LHVbdS5sZW5ndGgtMV0ueSk/Zj1sLmJlbmRzLmxlbmd0aC0xOm51bGwhPXAmJigyPT11Lmxlbmd0aHx8Mz09dS5sZW5ndGgmJigwPT1NYXRoLnJvdW5kKHVbMF0ueC11WzFdLngpJiYwPT1NYXRoLnJvdW5kKHVbMV0ueC11WzJdLngpfHwwPT1NYXRoLnJvdW5kKHVbMF0ueS0KdVsxXS55KSYmMD09TWF0aC5yb3VuZCh1WzFdLnktdVsyXS55KSkpP2Y9MjooZj1teFV0aWxzLmZpbmROZWFyZXN0U2VnbWVudChjLHEueCxxLnkpLGY9bnVsbD09cD9teEV2ZW50LlZJUlRVQUxfSEFORExFLWY6ZisxKSkpLG51bGw9PWYmJihmPW14RXZlbnQuVklSVFVBTF9IQU5ETEUpKSxsLnN0YXJ0KGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFgoKSxmKSxnPXE9Yj1lPW51bGwsbj0hMSxkLmNvbnN1bWUoKSx0aGlzLmdyYXBoSGFuZGxlci5yZXNldCgpfX19ZWxzZSBpZihjPWQuZ2V0U3RhdGUoKSxudWxsIT1jKXtsPW51bGw7aWYodGhpcy5tb2RlbC5pc0VkZ2UoYy5jZWxsKSl7aWYoZj1uZXcgbXhSZWN0YW5nbGUoZC5nZXRHcmFwaFgoKSxkLmdldEdyYXBoWSgpKSxmLmdyb3cobXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2Uud2lkdGgvMiksdT1jLmFic29sdXRlUG9pbnRzLG51bGwhPXUpaWYobnVsbCE9Yy50ZXh0JiZudWxsIT1jLnRleHQuYm91bmRpbmdCb3gmJgpteFV0aWxzLmNvbnRhaW5zKGMudGV4dC5ib3VuZGluZ0JveCxkLmdldEdyYXBoWCgpLGQuZ2V0R3JhcGhZKCkpKWw9Im1vdmUiO2Vsc2UgaWYobXhVdGlscy5jb250YWlucyhmLHVbMF0ueCx1WzBdLnkpfHxteFV0aWxzLmNvbnRhaW5zKGYsdVt1Lmxlbmd0aC0xXS54LHVbdS5sZW5ndGgtMV0ueSkpbD0icG9pbnRlciI7ZWxzZSBpZihudWxsIT1jLnZpc2libGVTb3VyY2VTdGF0ZXx8bnVsbCE9Yy52aXNpYmxlVGFyZ2V0U3RhdGUpZj10aGlzLnZpZXcuZ2V0RWRnZVN0eWxlKGMpLGw9ImNyb3NzaGFpciIsZiE9bXhFZGdlU3R5bGUuRW50aXR5UmVsYXRpb24mJnRoaXMuaXNPcnRob2dvbmFsKGMpJiYoZj1teFV0aWxzLmZpbmROZWFyZXN0U2VnbWVudChjLGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFkoKSksZjx1Lmxlbmd0aC0xJiYwPD1mJiYobD0wPT1NYXRoLnJvdW5kKHVbZl0ueC11W2YrMV0ueCk/ImNvbC1yZXNpemUiOiJyb3ctcmVzaXplIikpfWVsc2V7Zj1uZXcgbXhSZWN0YW5nbGUoZC5nZXRHcmFwaFgoKSwKZC5nZXRHcmFwaFkoKSk7Zi5ncm93KG14U2hhcGUucHJvdG90eXBlLnN2Z1N0cm9rZVRvbGVyYW5jZS0xKTtpZih0aGlzLmlzVGFibGVDZWxsKGMuY2VsbCkpaWYodT10aGlzLm1vZGVsLmdldFBhcmVudChjLmNlbGwpLHA9dGhpcy5tb2RlbC5nZXRQYXJlbnQodSksbXhVdGlscy5pbnRlcnNlY3RzKGYsbmV3IG14UmVjdGFuZ2xlKGMueC0xLGMueSwxLGMuaGVpZ2h0KSkmJnRoaXMubW9kZWwuZ2V0Q2hpbGRBdCh1LDApIT1jLmNlbGx8fG14VXRpbHMuaW50ZXJzZWN0cyhmLG5ldyBteFJlY3RhbmdsZShjLngrYy53aWR0aC0xLGMueSwxLGMuaGVpZ2h0KSkpbD0iY29sLXJlc2l6ZSI7ZWxzZSBpZihteFV0aWxzLmludGVyc2VjdHMoZixuZXcgbXhSZWN0YW5nbGUoYy54LGMueS0xLGMud2lkdGgsMSkpJiZ0aGlzLm1vZGVsLmdldENoaWxkQXQocCwwKSE9dXx8bXhVdGlscy5pbnRlcnNlY3RzKGYsbmV3IG14UmVjdGFuZ2xlKGMueCxjLnkrYy5oZWlnaHQtMSxjLndpZHRoLDEpKSlsPSJyb3ctcmVzaXplIjsKZm9yKHU9YztudWxsPT1sJiZudWxsIT11JiYodGhpcy5pc1RhYmxlQ2VsbCh1LmNlbGwpfHx0aGlzLmlzVGFibGVSb3codS5jZWxsKXx8dGhpcy5pc1RhYmxlKHUuY2VsbCkpOyl0aGlzLmlzU3dpbWxhbmUodS5jZWxsKSYmKHA9dGhpcy5nZXRBY3R1YWxTdGFydFNpemUodS5jZWxsKSwoMDxwLnh8fDA8cC53aWR0aCkmJm14VXRpbHMuaW50ZXJzZWN0cyhmLG5ldyBteFJlY3RhbmdsZSh1LngrcC54LXAud2lkdGgtMSsoMD09cC54P3Uud2lkdGg6MCksdS55LDEsdS5oZWlnaHQpKT9sPSJjb2wtcmVzaXplIjooMDxwLnl8fDA8cC5oZWlnaHQpJiZteFV0aWxzLmludGVyc2VjdHMoZixuZXcgbXhSZWN0YW5nbGUodS54LHUueStwLnktcC5oZWlnaHQtMSsoMD09cC55P3UuaGVpZ2h0OjApLHUud2lkdGgsMSkpJiYobD0icm93LXJlc2l6ZSIpKSx1PXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLm1vZGVsLmdldFBhcmVudCh1LmNlbGwpKX1udWxsIT1sJiZjLnNldEN1cnNvcihsKX19KSxtb3VzZVVwOm14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhLGQpe2c9cT1iPWU9bnVsbH0pfSl9dGhpcy5jZWxsUmVuZGVyZXIuZ2V0TGFiZWxWYWx1ZT1mdW5jdGlvbihhKXt2YXIgYj1teENlbGxSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFiZWxWYWx1ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS52aWV3LmdyYXBoLmlzSHRtbExhYmVsKGEuY2VsbCkmJihiPTEhPWEuc3R5bGUuaHRtbD9teFV0aWxzLmh0bWxFbnRpdGllcyhiLCExKTphLnZpZXcuZ3JhcGguc2FuaXRpemVIdG1sKGIpKTtyZXR1cm4gYn07aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgbXhWZXJ0ZXhIYW5kbGVyKXt0aGlzLnNldENvbm5lY3RhYmxlKCEwKTt0aGlzLnNldERyb3BFbmFibGVkKCEwKTt0aGlzLnNldFBhbm5pbmcoITApO3RoaXMuc2V0VG9vbHRpcHMoITApO3RoaXMuc2V0QWxsb3dMb29wcyghMCk7dGhpcy5hbGxvd0F1dG9QYW5uaW5nPSEwO3RoaXMuY29uc3RyYWluQ2hpbGRyZW49dGhpcy5yZXNldEVkZ2VzT25Db25uZWN0PSExO3RoaXMuY29uc3RyYWluUmVsYXRpdmVDaGlsZHJlbj0KITA7dGhpcy5ncmFwaEhhbmRsZXIuc2Nyb2xsT25Nb3ZlPSExO3RoaXMuZ3JhcGhIYW5kbGVyLnNjYWxlR3JpZD0hMDt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLnNldENyZWF0ZVRhcmdldCghMSk7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pbnNlcnRCZWZvcmVTb3VyY2U9ITA7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc1ZhbGlkU291cmNlPWZ1bmN0aW9uKGEsYil7cmV0dXJuITF9O3RoaXMuYWx0ZXJuYXRlRWRnZVN0eWxlPSJ2ZXJ0aWNhbCI7bnVsbD09ZCYmdGhpcy5sb2FkU3R5bGVzaGVldCgpO3ZhciBsPXRoaXMuZ3JhcGhIYW5kbGVyLmdldEd1aWRlU3RhdGVzO3RoaXMuZ3JhcGhIYW5kbGVyLmdldEd1aWRlU3RhdGVzPWZ1bmN0aW9uKCl7dmFyIGE9bC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYodGhpcy5ncmFwaC5wYWdlVmlzaWJsZSl7Zm9yKHZhciBiPVtdLGU9dGhpcy5ncmFwaC5wYWdlRm9ybWF0LGQ9dGhpcy5ncmFwaC5wYWdlU2NhbGUsYz1lLndpZHRoKmQsZT1lLmhlaWdodCoKZCxkPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZj10aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz10aGlzLmdyYXBoLmdldFBhZ2VMYXlvdXQoKSxuPTA7bjxnLndpZHRoO24rKyliLnB1c2gobmV3IG14UmVjdGFuZ2xlKCgoZy54K24pKmMrZC54KSpmLChnLnkqZStkLnkpKmYsYypmLGUqZikpO2ZvcihuPTE7bjxnLmhlaWdodDtuKyspYi5wdXNoKG5ldyBteFJlY3RhbmdsZSgoZy54KmMrZC54KSpmLCgoZy55K24pKmUrZC55KSpmLGMqZixlKmYpKTthPWIuY29uY2F0KGEpfXJldHVybiBhfTtteERyYWdTb3VyY2UucHJvdG90eXBlLmRyYWdFbGVtZW50WkluZGV4PW14UG9wdXBNZW51LnByb3RvdHlwZS56SW5kZXg7bXhHdWlkZS5wcm90b3R5cGUuZ2V0R3VpZGVDb2xvcj1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1hLmNlbGw/IiNmZmE1MDAiOm14Q29uc3RhbnRzLkdVSURFX0NPTE9SfTt0aGlzLmdyYXBoSGFuZGxlci5jcmVhdGVQcmV2aWV3U2hhcGU9ZnVuY3Rpb24oYSl7dGhpcy5wcmV2aWV3Q29sb3I9CiIjMDAwMDAwIj09dGhpcy5ncmFwaC5iYWNrZ3JvdW5kPyIjZmZmZmZmIjpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucHJldmlld0NvbG9yO3JldHVybiBteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlUHJldmlld1NoYXBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIHA9dGhpcy5ncmFwaEhhbmRsZXIuZ2V0Q2VsbHM7dGhpcy5ncmFwaEhhbmRsZXIuZ2V0Q2VsbHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXAuYXBwbHkodGhpcyxhcmd1bWVudHMpLGU9bmV3IG14RGljdGlvbmFyeSxkPVtdLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGY9dGhpcy5ncmFwaC5pc1RhYmxlUm93KGJbY10pJiZ0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGJbY10pP2JbY106dGhpcy5ncmFwaC5nZXRDb21wb3NpdGVQYXJlbnQoYltjXSk7bnVsbD09Znx8ZS5nZXQoZil8fChlLnB1dChmLCEwKSxkLnB1c2goZikpfXJldHVybiBkfTt2YXIgdj10aGlzLmdyYXBoSGFuZGxlci5zdGFydDt0aGlzLmdyYXBoSGFuZGxlci5zdGFydD0KZnVuY3Rpb24oYSxiLGUsZCl7YT10aGlzLmdyYXBoLmdldENvbXBvc2l0ZVBhcmVudChhKTt2LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dGhpcy5jb25uZWN0aW9uSGFuZGxlci5jcmVhdGVUYXJnZXRWZXJ0ZXg9ZnVuY3Rpb24oYSxiKXtiPXRoaXMuZ3JhcGguZ2V0Q29tcG9zaXRlUGFyZW50KGIpO3JldHVybiBteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVUYXJnZXRWZXJ0ZXguYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgdD1uZXcgbXhSdWJiZXJiYW5kKHRoaXMpO3RoaXMuZ2V0UnViYmVyYmFuZD1mdW5jdGlvbigpe3JldHVybiB0fTt2YXIgeT0obmV3IERhdGUpLmdldFRpbWUoKSx4PTAsQz10aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1vdXNlTW92ZTt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLm1vdXNlTW92ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3VycmVudFN0YXRlO0MuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EhPXRoaXMuY3VycmVudFN0YXRlPyh5PShuZXcgRGF0ZSkuZ2V0VGltZSgpLAp4PTApOng9KG5ldyBEYXRlKS5nZXRUaW1lKCkteX07dmFyIEI9dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc091dGxpbmVDb25uZWN0RXZlbnQ7dGhpcy5jb25uZWN0aW9uSGFuZGxlci5pc091dGxpbmVDb25uZWN0RXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudFN0YXRlJiZhLmdldFN0YXRlKCk9PXRoaXMuY3VycmVudFN0YXRlJiYyRTM8eHx8KG51bGw9PXRoaXMuY3VycmVudFN0YXRlfHwiMCIhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5jdXJyZW50U3RhdGUuc3R5bGUsIm91dGxpbmVDb25uZWN0IiwiMSIpKSYmQi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBEPXRoaXMuaXNUb2dnbGVFdmVudDt0aGlzLmlzVG9nZ2xlRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIEQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHwhbXhDbGllbnQuSVNfQ0hST01FT1MmJm14RXZlbnQuaXNTaGlmdERvd24oYSl9O3ZhciB6PXQuaXNGb3JjZVJ1YmJlcmJhbmRFdmVudDt0LmlzRm9yY2VSdWJiZXJiYW5kRXZlbnQ9CmZ1bmN0aW9uKGEpe3JldHVybiB6LmFwcGx5KHRoaXMsYXJndW1lbnRzKSYmIW14RXZlbnQuaXNTaGlmdERvd24oYS5nZXRFdmVudCgpKSYmIW14RXZlbnQuaXNDb250cm9sRG93bihhLmdldEV2ZW50KCkpfHxteENsaWVudC5JU19DSFJPTUVPUyYmbXhFdmVudC5pc1NoaWZ0RG93bihhLmdldEV2ZW50KCkpfHxteFV0aWxzLmhhc1Njcm9sbGJhcnModGhpcy5ncmFwaC5jb250YWluZXIpJiZteENsaWVudC5JU19GRiYmbXhDbGllbnQuSVNfV0lOJiZudWxsPT1hLmdldFN0YXRlKCkmJm14RXZlbnQuaXNUb3VjaEV2ZW50KGEuZ2V0RXZlbnQoKSl9O3ZhciBFPW51bGw7dGhpcy5wYW5uaW5nSGFuZGxlci5hZGRMaXN0ZW5lcihteEV2ZW50LlBBTl9TVEFSVCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaXNFbmFibGVkKCkmJihFPXRoaXMuY29udGFpbmVyLnN0eWxlLmN1cnNvcix0aGlzLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9Im1vdmUiKX0pKTt0aGlzLnBhbm5pbmdIYW5kbGVyLmFkZExpc3RlbmVyKG14RXZlbnQuUEFOX0VORCwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmlzRW5hYmxlZCgpJiYodGhpcy5jb250YWluZXIuc3R5bGUuY3Vyc29yPUUpfSkpO3RoaXMucG9wdXBNZW51SGFuZGxlci5hdXRvRXhwYW5kPSEwO3RoaXMucG9wdXBNZW51SGFuZGxlci5pc1NlbGVjdE9uUG9wdXA9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNNb3VzZUV2ZW50KGEuZ2V0RXZlbnQoKSl9O3ZhciBHPXRoaXMuY2xpY2s7dGhpcy5jbGljaz1mdW5jdGlvbihhKXt2YXIgYj1udWxsPT1hLnN0YXRlJiZudWxsIT1hLnNvdXJjZVN0YXRlJiZ0aGlzLmlzQ2VsbExvY2tlZChhLnNvdXJjZVN0YXRlLmNlbGwpO2lmKHRoaXMuaXNFbmFibGVkKCkmJiFifHxhLmlzQ29uc3VtZWQoKSlyZXR1cm4gRy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGU9Yj9hLnNvdXJjZVN0YXRlLmNlbGw6YS5nZXRDZWxsKCk7bnVsbCE9ZSYmKGU9dGhpcy5nZXRDbGlja2FibGVMaW5rRm9yQ2VsbChlKSxudWxsIT1lJiYodGhpcy5pc0N1c3RvbUxpbmsoZSk/CnRoaXMuY3VzdG9tTGlua0NsaWNrZWQoZSk6dGhpcy5vcGVuTGluayhlKSkpO3RoaXMuaXNFbmFibGVkKCkmJmImJnRoaXMuY2xlYXJTZWxlY3Rpb24oKX07dGhpcy50b29sdGlwSGFuZGxlci5nZXRTdGF0ZUZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBhLnNvdXJjZVN0YXRlfTt0aGlzLmdldEN1cnNvckZvck1vdXNlRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbD09YS5zdGF0ZSYmbnVsbCE9YS5zb3VyY2VTdGF0ZSYmdGhpcy5pc0NlbGxMb2NrZWQoYS5zb3VyY2VTdGF0ZS5jZWxsKTtyZXR1cm4gdGhpcy5nZXRDdXJzb3JGb3JDZWxsKGI/YS5zb3VyY2VTdGF0ZS5jZWxsOmEuZ2V0Q2VsbCgpKX07dmFyIEY9dGhpcy5nZXRDdXJzb3JGb3JDZWxsO3RoaXMuZ2V0Q3Vyc29yRm9yQ2VsbD1mdW5jdGlvbihhKXtpZighdGhpcy5pc0VuYWJsZWQoKXx8dGhpcy5pc0NlbGxMb2NrZWQoYSkpe2lmKG51bGwhPXRoaXMuZ2V0Q2xpY2thYmxlTGlua0ZvckNlbGwoYSkpcmV0dXJuInBvaW50ZXIiOwppZih0aGlzLmlzQ2VsbExvY2tlZChhKSlyZXR1cm4iZGVmYXVsdCJ9cmV0dXJuIEYuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt0aGlzLnNlbGVjdFJlZ2lvbj1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0QWxsQ2VsbHMoYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0KTt0aGlzLnNlbGVjdENlbGxzRm9yRXZlbnQoZSxiKTtyZXR1cm4gZX07dGhpcy5nZXRBbGxDZWxscz1mdW5jdGlvbihhLGIsZSxkLGMsZil7Zj1udWxsIT1mP2Y6W107aWYoMDxlfHwwPGQpe3ZhciBnPXRoaXMuZ2V0TW9kZWwoKSxsPWErZSxuPWIrZDtudWxsPT1jJiYoYz10aGlzLmdldEN1cnJlbnRSb290KCksbnVsbD09YyYmKGM9Zy5nZXRSb290KCkpKTtpZihudWxsIT1jKWZvcih2YXIgcD1nLmdldENoaWxkQ291bnQoYyksdT0wO3U8cDt1Kyspe3ZhciB0PWcuZ2V0Q2hpbGRBdChjLHUpLEE9dGhpcy52aWV3LmdldFN0YXRlKHQpO2lmKG51bGwhPUEmJnRoaXMuaXNDZWxsVmlzaWJsZSh0KSYmIjEiIT1teFV0aWxzLmdldFZhbHVlKEEuc3R5bGUsCiJsb2NrZWQiLCIwIikpe3ZhciBtPW14VXRpbHMuZ2V0VmFsdWUoQS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTil8fDA7MCE9bSYmKEE9bXhVdGlscy5nZXRCb3VuZGluZ0JveChBLG0pKTsoZy5pc0VkZ2UodCl8fGcuaXNWZXJ0ZXgodCkpJiZBLng+PWEmJkEueStBLmhlaWdodDw9biYmQS55Pj1iJiZBLngrQS53aWR0aDw9bCYmZi5wdXNoKHQpO3RoaXMuZ2V0QWxsQ2VsbHMoYSxiLGUsZCx0LGYpfX19cmV0dXJuIGZ9O3ZhciBIPXRoaXMuZ3JhcGhIYW5kbGVyLnNob3VsZFJlbW92ZUNlbGxzRnJvbVBhcmVudDt0aGlzLmdyYXBoSGFuZGxlci5zaG91bGRSZW1vdmVDZWxsc0Zyb21QYXJlbnQ9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiB0aGlzLmdyYXBoLmlzQ2VsbFNlbGVjdGVkKGEpPyExOkguYXBwbHkodGhpcyxhcmd1bWVudHMpfTt0aGlzLmlzQ2VsbExvY2tlZD1mdW5jdGlvbihhKXtmb3IoYT10aGlzLnZpZXcuZ2V0U3RhdGUoYSk7bnVsbCE9YTspe2lmKCIxIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLAoibG9ja2VkIiwiMCIpKXJldHVybiEwO2E9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGEuY2VsbCkpfXJldHVybiExfTt2YXIgSj1udWxsO3RoaXMuYWRkTGlzdGVuZXIobXhFdmVudC5GSVJFX01PVVNFX0VWRU5ULG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7aWYoIm1vdXNlRG93biI9PWIuZ2V0UHJvcGVydHkoImV2ZW50TmFtZSIpKXt2YXIgZT1iLmdldFByb3BlcnR5KCJldmVudCIpLmdldFN0YXRlKCk7Sj1udWxsPT1lfHx0aGlzLmlzU2VsZWN0aW9uRW1wdHkoKXx8dGhpcy5pc0NlbGxTZWxlY3RlZChlLmNlbGwpP251bGw6dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpfX0pKTt0aGlzLmFkZExpc3RlbmVyKG14RXZlbnQuVEFQX0FORF9IT0xELG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7aWYoIW14RXZlbnQuaXNNdWx0aVRvdWNoRXZlbnQoYikpe3ZhciBlPWIuZ2V0UHJvcGVydHkoImV2ZW50IiksZD1iLmdldFByb3BlcnR5KCJjZWxsIik7Cm51bGw9PWQ/KGU9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGUpLG14RXZlbnQuZ2V0Q2xpZW50WShlKSksdC5zdGFydChlLngsZS55KSk6bnVsbCE9Sj90aGlzLmFkZFNlbGVjdGlvbkNlbGxzKEopOjE8dGhpcy5nZXRTZWxlY3Rpb25Db3VudCgpJiZ0aGlzLmlzQ2VsbFNlbGVjdGVkKGQpJiZ0aGlzLnJlbW92ZVNlbGVjdGlvbkNlbGwoZCk7Sj1udWxsO2IuY29uc3VtZSgpfX0pKTt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLnNlbGVjdENlbGxzPWZ1bmN0aW9uKGEsYil7dGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKGJ8fGEpfTt0aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmNvbnN0cmFpbnRIYW5kbGVyLmlzU3RhdGVJZ25vcmVkPWZ1bmN0aW9uKGEsYil7dmFyIGU9YS52aWV3LmdyYXBoO3JldHVybiBiJiYoZS5pc0NlbGxTZWxlY3RlZChhLmNlbGwpfHxlLmlzVGFibGVSb3coYS5jZWxsKSYmZS5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuaXNIYW5kbGVkKGUubW9kZWwuZ2V0UGFyZW50KGEuY2VsbCkpKX07CnRoaXMuc2VsZWN0aW9uTW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbm5lY3Rpb25IYW5kbGVyLmNvbnN0cmFpbnRIYW5kbGVyO251bGwhPWEuY3VycmVudEZvY3VzJiZhLmlzU3RhdGVJZ25vcmVkKGEuY3VycmVudEZvY3VzLCEwKSYmKGEuY3VycmVudEZvY3VzPW51bGwsYS5jb25zdHJhaW50cz1udWxsLGEuZGVzdHJveUljb25zKCkpO2EuZGVzdHJveUZvY3VzSGlnaGxpZ2h0KCl9KSk7R3JhcGgudG91Y2hTdHlsZSYmdGhpcy5pbml0VG91Y2goKTt2YXIgdT10aGlzLnVwZGF0ZU1vdXNlRXZlbnQ7dGhpcy51cGRhdGVNb3VzZUV2ZW50PWZ1bmN0aW9uKGEpe2E9dS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9YS5zdGF0ZSYmdGhpcy5pc0NlbGxMb2NrZWQoYS5nZXRDZWxsKCkpJiYoYS5zdGF0ZT1udWxsKTtyZXR1cm4gYX19dGhpcy5jdXJyZW50VHJhbnNsYXRlPW5ldyBteFBvaW50KDAsMCl9OwpHcmFwaC50b3VjaFN0eWxlPW14Q2xpZW50LklTX1RPVUNIfHxteENsaWVudC5JU19GRiYmbXhDbGllbnQuSVNfV0lOfHwwPG5hdmlnYXRvci5tYXhUb3VjaFBvaW50c3x8MDxuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50c3x8bnVsbD09d2luZG93LnVybFBhcmFtc3x8IjEiPT11cmxQYXJhbXMudG91Y2g7R3JhcGguZmlsZVN1cHBvcnQ9bnVsbCE9d2luZG93LkZpbGUmJm51bGwhPXdpbmRvdy5GaWxlUmVhZGVyJiZudWxsIT13aW5kb3cuRmlsZUxpc3QmJihudWxsPT13aW5kb3cudXJsUGFyYW1zfHwiMCIhPXVybFBhcmFtcy5maWxlc3VwcG9ydCk7R3JhcGgubGluZUp1bXBzRW5hYmxlZD0hMDtHcmFwaC5kZWZhdWx0SnVtcFNpemU9NjtHcmFwaC5taW5UYWJsZUNvbHVtbldpZHRoPTIwO0dyYXBoLm1pblRhYmxlUm93SGVpZ2h0PTIwO0dyYXBoLmZvcmVpZ25PYmplY3RXYXJuaW5nVGV4dD0iVmlld2VyIGRvZXMgbm90IHN1cHBvcnQgZnVsbCBTVkcgMS4xIjsKR3JhcGguZm9yZWlnbk9iamVjdFdhcm5pbmdMaW5rPSJodHRwczovL2Rlc2suZHJhdy5pby9zdXBwb3J0L3NvbHV0aW9ucy9hcnRpY2xlcy8xNjAwMDA0MjQ4NyI7CkdyYXBoLmNyZWF0ZVN2Z0ltYWdlPWZ1bmN0aW9uKGEsYyxmLGQsayl7Zj11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoJzwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iJythKydweCIgaGVpZ2h0PSInK2MrJ3B4IiAnKyhudWxsIT1kJiZudWxsIT1rPyd2aWV3Qm94PSIwIDAgJytkKyIgIitrKyciICc6IiIpKyd2ZXJzaW9uPSIxLjEiPicrZisiPC9zdmc+IikpO3JldHVybiBuZXcgbXhJbWFnZSgiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwiKyh3aW5kb3cuYnRvYT9idG9hKGYpOkJhc2U2NC5lbmNvZGUoZiwhMCkpLGEsYyl9OwpHcmFwaC56YXBHcmVtbGlucz1mdW5jdGlvbihhKXtmb3IodmFyIGM9W10sZj0wO2Y8YS5sZW5ndGg7ZisrKXt2YXIgZD1hLmNoYXJDb2RlQXQoZik7KDMyPD1kfHw5PT1kfHwxMD09ZHx8MTM9PWQpJiY2NTUzNSE9ZCYmNjU1MzQhPWQmJmMucHVzaChhLmNoYXJBdChmKSl9cmV0dXJuIGMuam9pbigiIil9O0dyYXBoLnN0cmluZ1RvQnl0ZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPUFycmF5KGEubGVuZ3RoKSxmPTA7ZjxhLmxlbmd0aDtmKyspY1tmXT1hLmNoYXJDb2RlQXQoZik7cmV0dXJuIGN9O0dyYXBoLmJ5dGVzVG9TdHJpbmc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPUFycmF5KGEubGVuZ3RoKSxmPTA7ZjxhLmxlbmd0aDtmKyspY1tmXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGFbZl0pO3JldHVybiBjLmpvaW4oIiIpfTtHcmFwaC5jb21wcmVzc05vZGU9ZnVuY3Rpb24oYSxjKXt2YXIgZj1teFV0aWxzLmdldFhtbChhKTtyZXR1cm4gR3JhcGguY29tcHJlc3MoYz9mOkdyYXBoLnphcEdyZW1saW5zKGYpKX07CkdyYXBoLmNvbXByZXNzPWZ1bmN0aW9uKGEsYyl7aWYobnVsbD09YXx8MD09YS5sZW5ndGh8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHBha28pcmV0dXJuIGE7dmFyIGY9Yz9wYWtvLmRlZmxhdGUoZW5jb2RlVVJJQ29tcG9uZW50KGEpLHt0bzoic3RyaW5nIn0pOnBha28uZGVmbGF0ZVJhdyhlbmNvZGVVUklDb21wb25lbnQoYSkse3RvOiJzdHJpbmcifSk7cmV0dXJuIHdpbmRvdy5idG9hP2J0b2EoZik6QmFzZTY0LmVuY29kZShmLCEwKX07R3JhcGguZGVjb21wcmVzcz1mdW5jdGlvbihhLGMsZil7aWYobnVsbD09YXx8MD09YS5sZW5ndGh8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHBha28pcmV0dXJuIGE7YT13aW5kb3cuYXRvYj9hdG9iKGEpOkJhc2U2NC5kZWNvZGUoYSwhMCk7Yz1kZWNvZGVVUklDb21wb25lbnQoYz9wYWtvLmluZmxhdGUoYSx7dG86InN0cmluZyJ9KTpwYWtvLmluZmxhdGVSYXcoYSx7dG86InN0cmluZyJ9KSk7cmV0dXJuIGY/YzpHcmFwaC56YXBHcmVtbGlucyhjKX07CkdyYXBoLnJlbW92ZVBhc3RlRm9ybWF0dGluZz1mdW5jdGlvbihhKXtmb3IoO251bGwhPWE7KW51bGwhPWEuZmlyc3RDaGlsZCYmR3JhcGgucmVtb3ZlUGFzdGVGb3JtYXR0aW5nKGEuZmlyc3RDaGlsZCksYS5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmbnVsbCE9YS5zdHlsZSYmKGEuc3R5bGUud2hpdGVTcGFjZT0iIiwiIzAwMDAwMCI9PWEuc3R5bGUuY29sb3ImJihhLnN0eWxlLmNvbG9yPSIiKSksYT1hLm5leHRTaWJsaW5nfTtHcmFwaC5pc0xpbms9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJkdyYXBoLmxpbmtQYXR0ZXJuLnRlc3QoYSl9O0dyYXBoLmxpbmtQYXR0ZXJuPS9eKGh0dHBzPzpcL1wvKT8oKChbYS16XGRdKFthLXpcZC1dKlthLXpcZF0pKilcLikrW2Etel17Mix9fCgoXGR7MSwzfVwuKXszfVxkezEsM30pKShcOlxkKyk/KFwvWy1hLXpcZCVfLn4rXSopKihcP1s7JmEtelxkJV8ufis9LV0qKT8oXCNbLWEtelxkX10qKT8kL2k7Cm14VXRpbHMuZXh0ZW5kKEdyYXBoLG14R3JhcGgpO0dyYXBoLnByb3RvdHlwZS5taW5GaXRTY2FsZT1udWxsO0dyYXBoLnByb3RvdHlwZS5tYXhGaXRTY2FsZT1udWxsO0dyYXBoLnByb3RvdHlwZS5saW5rUG9saWN5PSJmcmFtZSI9PXVybFBhcmFtcy50YXJnZXQ/ImJsYW5rIjp1cmxQYXJhbXMudGFyZ2V0fHwiYXV0byI7R3JhcGgucHJvdG90eXBlLmxpbmtUYXJnZXQ9ImZyYW1lIj09dXJsUGFyYW1zLnRhcmdldD8iX3NlbGYiOiJfYmxhbmsiO0dyYXBoLnByb3RvdHlwZS5saW5rUmVsYXRpb249Im5vZm9sbG93IG5vb3BlbmVyIG5vcmVmZXJyZXIiO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0U2Nyb2xsYmFycz0hbXhDbGllbnQuSVNfSU9TO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFnZVZpc2libGU9ITA7R3JhcGgucHJvdG90eXBlLmxpZ2h0Ym94PSExO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFnZUJhY2tncm91bmRDb2xvcj0iI2ZmZmZmZiI7CkdyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFnZUJvcmRlckNvbG9yPSIjZmZmZmZmIjtHcmFwaC5wcm90b3R5cGUuc2Nyb2xsVGlsZVNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCw0MDAsNDAwKTtHcmFwaC5wcm90b3R5cGUudHJhbnNwYXJlbnRCYWNrZ3JvdW5kPSEwO0dyYXBoLnByb3RvdHlwZS5zZWxlY3RQYXJlbnRBZnRlckRlbGV0ZT0hMTtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VMZW5ndGg9ODA7R3JhcGgucHJvdG90eXBlLmVkZ2VNb2RlPSExO0dyYXBoLnByb3RvdHlwZS5jb25uZWN0aW9uQXJyb3dzRW5hYmxlZD0hMDtHcmFwaC5wcm90b3R5cGUucGxhY2Vob2xkZXJQYXR0ZXJuPVJlZ0V4cCgiJShkYXRley4qfXxbXiVee159XSspJSIsImciKTtHcmFwaC5wcm90b3R5cGUuYWJzb2x1dGVVcmxQYXR0ZXJuPS9eKD86W2Etel0rOik/XC9cLy9pO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0VGhlbWVOYW1lPSJkZWZhdWx0IjsKR3JhcGgucHJvdG90eXBlLmRlZmF1bHRUaGVtZXM9e307R3JhcGgucHJvdG90eXBlLmJhc2VVcmw9bnVsbCE9dXJsUGFyYW1zLmJhc2U/ZGVjb2RlVVJJQ29tcG9uZW50KHVybFBhcmFtcy5iYXNlKTood2luZG93IT13aW5kb3cudG9wP2RvY3VtZW50LnJlZmVycmVyOmRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpLnNwbGl0KCIjIilbMF07R3JhcGgucHJvdG90eXBlLmVkaXRBZnRlckluc2VydD0hMTtHcmFwaC5wcm90b3R5cGUuYnVpbHRJblByb3BlcnRpZXM9WyJsYWJlbCIsInRvb2x0aXAiLCJwbGFjZWhvbGRlcnMiLCJwbGFjZWhvbGRlciJdO0dyYXBoLnByb3RvdHlwZS5zdGFuZGFsb25lPSExOwpHcmFwaC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhKXtteEdyYXBoLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmNlbGxSZW5kZXJlci5pbml0aWFsaXplTGFiZWw9ZnVuY3Rpb24oYSxmKXtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZUxhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgZD1hLnZpZXcuZ3JhcGgudG9sZXJhbmNlLGM9ITAsbT1udWxsLHE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yz0hMDttPW5ldyBteFBvaW50KG14RXZlbnQuZ2V0Q2xpZW50WChhKSxteEV2ZW50LmdldENsaWVudFkoYSkpfSksYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjPWMmJm51bGwhPW0mJk1hdGguYWJzKG0ueC1teEV2ZW50LmdldENsaWVudFgoYSkpPGQmJk1hdGguYWJzKG0ueS1teEV2ZW50LmdldENsaWVudFkoYSkpPGR9KSxlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2lmKGMpZm9yKHZhciBlPW14RXZlbnQuZ2V0U291cmNlKGIpO251bGwhPQplJiZlIT1mLm5vZGU7KXtpZigiYSI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7YS52aWV3LmdyYXBoLmxhYmVsTGlua0NsaWNrZWQoYSxlLGIpO2JyZWFrfWU9ZS5wYXJlbnROb2RlfX0pO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhmLm5vZGUscSxiLGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZi5ub2RlLCJjbGljayIsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpfSl9O3RoaXMuaW5pdExheW91dE1hbmFnZXIoKX07CihmdW5jdGlvbigpe0dyYXBoLnByb3RvdHlwZS51c2VDc3NUcmFuc2Zvcm1zPSExO0dyYXBoLnByb3RvdHlwZS5jdXJyZW50U2NhbGU9MTtHcmFwaC5wcm90b3R5cGUuY3VycmVudFRyYW5zbGF0ZT1uZXcgbXhQb2ludCgwLDApO0dyYXBoLnByb3RvdHlwZS5pc0Zhc3Rab29tRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiJub2NzcyIhPXVybFBhcmFtcy56b29tJiYhbXhDbGllbnQuTk9fRk8mJiFteENsaWVudC5JU19FREdFJiYhdGhpcy51c2VDc3NUcmFuc2Zvcm1zJiZ0aGlzLmlzQ3NzVHJhbnNmb3Jtc1N1cHBvcnRlZCgpfTtHcmFwaC5wcm90b3R5cGUuaXNDc3NUcmFuc2Zvcm1zU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlhbGVjdD09bXhDb25zdGFudHMuRElBTEVDVF9TVkcmJiFteENsaWVudC5OT19GTyYmKCF0aGlzLmxpZ2h0Ym94fHwhbXhDbGllbnQuSVNfU0YpfTtHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbEF0PWZ1bmN0aW9uKGEsYyxmLHEsYixlKXt0aGlzLnVzZUNzc1RyYW5zZm9ybXMmJgooYT1hL3RoaXMuY3VycmVudFNjYWxlLXRoaXMuY3VycmVudFRyYW5zbGF0ZS54LGM9Yy90aGlzLmN1cnJlbnRTY2FsZS10aGlzLmN1cnJlbnRUcmFuc2xhdGUueSk7cmV0dXJuIHRoaXMuZ2V0U2NhbGVkQ2VsbEF0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLmdldFNjYWxlZENlbGxBdD1mdW5jdGlvbihhLGMsZixxLGIsZSl7cT1udWxsIT1xP3E6ITA7Yj1udWxsIT1iP2I6ITA7bnVsbD09ZiYmKGY9dGhpcy5nZXRDdXJyZW50Um9vdCgpLG51bGw9PWYmJihmPXRoaXMuZ2V0TW9kZWwoKS5nZXRSb290KCkpKTtpZihudWxsIT1mKWZvcih2YXIgZD10aGlzLm1vZGVsLmdldENoaWxkQ291bnQoZiktMTswPD1kO2QtLSl7dmFyIG49dGhpcy5tb2RlbC5nZXRDaGlsZEF0KGYsZCksbD10aGlzLmdldFNjYWxlZENlbGxBdChhLGMsbixxLGIsZSk7aWYobnVsbCE9bClyZXR1cm4gbDtpZih0aGlzLmlzQ2VsbFZpc2libGUobikmJihiJiZ0aGlzLm1vZGVsLmlzRWRnZShuKXx8CnEmJnRoaXMubW9kZWwuaXNWZXJ0ZXgobikpJiYobD10aGlzLnZpZXcuZ2V0U3RhdGUobiksbnVsbCE9bCYmKG51bGw9PWV8fCFlKGwsYSxjKSkmJnRoaXMuaW50ZXJzZWN0cyhsLGEsYykpKXJldHVybiBufXJldHVybiBudWxsfTtHcmFwaC5wcm90b3R5cGUuaXNSZWN1cnNpdmVWZXJ0ZXhSZXNpemU9ZnVuY3Rpb24oYSl7cmV0dXJuIXRoaXMuaXNTd2ltbGFuZShhLmNlbGwpJiYwPHRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmNlbGwpJiYhdGhpcy5pc0NlbGxDb2xsYXBzZWQoYS5jZWxsKSYmIjEiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsInJlY3Vyc2l2ZVJlc2l6ZSIsIjEiKSYmbnVsbD09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJjaGlsZExheW91dCIsbnVsbCl9O0dyYXBoLnByb3RvdHlwZS5pc1BhcnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKSwicGFydCIsIjAiKXx8dGhpcy5pc1RhYmxlQ2VsbChhKXx8CnRoaXMuaXNUYWJsZVJvdyhhKX07R3JhcGgucHJvdG90eXBlLmdldENvbXBvc2l0ZVBhcmVudD1mdW5jdGlvbihhKXtmb3IoO3RoaXMuaXNQYXJ0KGEpOyl7dmFyIGM9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7aWYoIXRoaXMubW9kZWwuaXNWZXJ0ZXgoYykpYnJlYWs7YT1jfXJldHVybiBhfTtteENlbGxIaWdobGlnaHQucHJvdG90eXBlLmdldFN0cm9rZVdpZHRoPWZ1bmN0aW9uKGEpe2E9dGhpcy5zdHJva2VXaWR0aDt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXMmJihhLz10aGlzLmdyYXBoLmN1cnJlbnRTY2FsZSk7cmV0dXJuIGF9O214R3JhcGhWaWV3LnByb3RvdHlwZS5nZXRHcmFwaEJvdW5kcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JhcGhCb3VuZHM7aWYodGhpcy5ncmFwaC51c2VDc3NUcmFuc2Zvcm1zKXZhciBjPXRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZSxmPXRoaXMuZ3JhcGguY3VycmVudFNjYWxlLGE9bmV3IG14UmVjdGFuZ2xlKChhLngrYy54KSpmLChhLnkrCmMueSkqZixhLndpZHRoKmYsYS5oZWlnaHQqZik7cmV0dXJuIGF9O214R3JhcGhWaWV3LnByb3RvdHlwZS52aWV3U3RhdGVDaGFuZ2VkPWZ1bmN0aW9uKCl7dGhpcy5ncmFwaC51c2VDc3NUcmFuc2Zvcm1zP3RoaXMudmFsaWRhdGUoKTp0aGlzLnJldmFsaWRhdGUoKTt0aGlzLmdyYXBoLnNpemVEaWRDaGFuZ2UoKX07dmFyIGE9bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlO214R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbihjKXt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXMmJih0aGlzLmdyYXBoLmN1cnJlbnRTY2FsZT10aGlzLnNjYWxlLHRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZS54PXRoaXMudHJhbnNsYXRlLngsdGhpcy5ncmFwaC5jdXJyZW50VHJhbnNsYXRlLnk9dGhpcy50cmFuc2xhdGUueSx0aGlzLnNjYWxlPTEsdGhpcy50cmFuc2xhdGUueD0wLHRoaXMudHJhbnNsYXRlLnk9MCk7YS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5ncmFwaC51c2VDc3NUcmFuc2Zvcm1zJiYKKHRoaXMuZ3JhcGgudXBkYXRlQ3NzVHJhbnNmb3JtKCksdGhpcy5zY2FsZT10aGlzLmdyYXBoLmN1cnJlbnRTY2FsZSx0aGlzLnRyYW5zbGF0ZS54PXRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZS54LHRoaXMudHJhbnNsYXRlLnk9dGhpcy5ncmFwaC5jdXJyZW50VHJhbnNsYXRlLnkpfTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3NzVHJhbnNmb3JtPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy52aWV3LmdldERyYXdQYW5lKCk7aWYobnVsbCE9YSlpZihhPWEucGFyZW50Tm9kZSx0aGlzLnVzZUNzc1RyYW5zZm9ybXMpe3ZhciBjPWEuZ2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iKTthLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtT3JpZ2luIiwiMCAwIik7dmFyIGY9TWF0aC5yb3VuZCgxMDAqdGhpcy5jdXJyZW50U2NhbGUpLzEwMDthLnNldEF0dHJpYnV0ZSgidHJhbnNmb3JtIiwic2NhbGUoIitmKyIsIitmKyIpdHJhbnNsYXRlKCIrTWF0aC5yb3VuZCgxMDAqdGhpcy5jdXJyZW50VHJhbnNsYXRlLngpLwoxMDArIiwiK01hdGgucm91bmQoMTAwKnRoaXMuY3VycmVudFRyYW5zbGF0ZS55KS8xMDArIikiKTtpZihjIT1hLmdldEF0dHJpYnV0ZSgidHJhbnNmb3JtIikpdHJ5e2lmKG14Q2xpZW50LklTX0VER0Upe3ZhciBxPWEuc3R5bGUuZGlzcGxheTthLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2EuZ2V0QkJveCgpO2Euc3R5bGUuZGlzcGxheT1xfX1jYXRjaChiKXt9fWVsc2UgYS5yZW1vdmVBdHRyaWJ1dGUoInRyYW5zZm9ybU9yaWdpbiIpLGEucmVtb3ZlQXR0cmlidXRlKCJ0cmFuc2Zvcm0iKX07dmFyIGM9bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U7bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQmFja2dyb3VuZFBhZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXMsZj10aGlzLnNjYWxlLG09dGhpcy50cmFuc2xhdGU7YSYmKHRoaXMuc2NhbGU9dGhpcy5ncmFwaC5jdXJyZW50U2NhbGUsdGhpcy50cmFuc2xhdGU9CnRoaXMuZ3JhcGguY3VycmVudFRyYW5zbGF0ZSk7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YSYmKHRoaXMuc2NhbGU9Zix0aGlzLnRyYW5zbGF0ZT1tKX07dmFyIGY9bXhHcmFwaC5wcm90b3R5cGUudXBkYXRlUGFnZUJyZWFrcztteEdyYXBoLnByb3RvdHlwZS51cGRhdGVQYWdlQnJlYWtzPWZ1bmN0aW9uKGEsYyxtKXt2YXIgZD10aGlzLnVzZUNzc1RyYW5zZm9ybXMsYj10aGlzLnZpZXcuc2NhbGUsZT10aGlzLnZpZXcudHJhbnNsYXRlO2QmJih0aGlzLnZpZXcuc2NhbGU9MSx0aGlzLnZpZXcudHJhbnNsYXRlPW5ldyBteFBvaW50KDAsMCksdGhpcy51c2VDc3NUcmFuc2Zvcm1zPSExKTtmLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkJiYodGhpcy52aWV3LnNjYWxlPWIsdGhpcy52aWV3LnRyYW5zbGF0ZT1lLHRoaXMudXNlQ3NzVHJhbnNmb3Jtcz0hMCl9fSkoKTtHcmFwaC5wcm90b3R5cGUuaXNMaWdodGJveFZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saWdodGJveH07CkdyYXBoLnByb3RvdHlwZS5pc1ZpZXdlcj1mdW5jdGlvbigpe3JldHVybiExfTtHcmFwaC5wcm90b3R5cGUubGFiZWxMaW5rQ2xpY2tlZD1mdW5jdGlvbihhLGMsZil7Yz1jLmdldEF0dHJpYnV0ZSgiaHJlZiIpO2lmKG51bGwhPWMmJiF0aGlzLmlzQ3VzdG9tTGluayhjKSYmbXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihmKSYmIW14RXZlbnQuaXNQb3B1cFRyaWdnZXIoZil8fG14RXZlbnQuaXNUb3VjaEV2ZW50KGYpKXtpZighdGhpcy5pc0VuYWJsZWQoKXx8dGhpcy5pc0NlbGxMb2NrZWQoYS5jZWxsKSlhPXRoaXMuaXNCbGFua0xpbmsoYyk/dGhpcy5saW5rVGFyZ2V0OiJfdG9wIix0aGlzLm9wZW5MaW5rKHRoaXMuZ2V0QWJzb2x1dGVVcmwoYyksYSk7bXhFdmVudC5jb25zdW1lKGYpfX07CkdyYXBoLnByb3RvdHlwZS5vcGVuTGluaz1mdW5jdGlvbihhLGMsZil7dmFyIGQ9d2luZG93O3RyeXtpZigiX3NlbGYiPT1jJiZ3aW5kb3chPXdpbmRvdy50b3Apd2luZG93LmxvY2F0aW9uLmhyZWY9YTtlbHNlIGlmKGEuc3Vic3RyaW5nKDAsdGhpcy5iYXNlVXJsLmxlbmd0aCk9PXRoaXMuYmFzZVVybCYmIiMiPT1hLmNoYXJBdCh0aGlzLmJhc2VVcmwubGVuZ3RoKSYmIl90b3AiPT1jJiZ3aW5kb3c9PXdpbmRvdy50b3Ape3ZhciBrPWEuc3BsaXQoIiMiKVsxXTt3aW5kb3cubG9jYXRpb24uaGFzaD09IiMiK2smJih3aW5kb3cubG9jYXRpb24uaGFzaD0iIik7d2luZG93LmxvY2F0aW9uLmhhc2g9a31lbHNlIGQ9d2luZG93Lm9wZW4oYSxudWxsIT1jP2M6Il9ibGFuayIpLG51bGw9PWR8fGZ8fChkLm9wZW5lcj1udWxsKX1jYXRjaChtKXt9cmV0dXJuIGR9OwpHcmFwaC5wcm90b3R5cGUuZ2V0TGlua1RpdGxlPWZ1bmN0aW9uKGEpe3JldHVybiBhLnN1YnN0cmluZyhhLmxhc3RJbmRleE9mKCIvIikrMSl9O0dyYXBoLnByb3RvdHlwZS5pc0N1c3RvbUxpbms9ZnVuY3Rpb24oYSl7cmV0dXJuImRhdGE6Ij09YS5zdWJzdHJpbmcoMCw1KX07R3JhcGgucHJvdG90eXBlLmN1c3RvbUxpbmtDbGlja2VkPWZ1bmN0aW9uKGEpe3JldHVybiExfTtHcmFwaC5wcm90b3R5cGUuaXNFeHRlcm5hbFByb3RvY29sPWZ1bmN0aW9uKGEpe3JldHVybiJtYWlsdG86Ij09PWEuc3Vic3RyaW5nKDAsNyl9O0dyYXBoLnByb3RvdHlwZS5pc0JsYW5rTGluaz1mdW5jdGlvbihhKXtyZXR1cm4hdGhpcy5pc0V4dGVybmFsUHJvdG9jb2woYSkmJigiYmxhbmsiPT09dGhpcy5saW5rUG9saWN5fHwic2VsZiIhPT10aGlzLmxpbmtQb2xpY3kmJiF0aGlzLmlzUmVsYXRpdmVVcmwoYSkmJmEuc3Vic3RyaW5nKDAsdGhpcy5kb21haW5VcmwubGVuZ3RoKSE9PXRoaXMuZG9tYWluVXJsKX07CkdyYXBoLnByb3RvdHlwZS5pc1JlbGF0aXZlVXJsPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYhdGhpcy5hYnNvbHV0ZVVybFBhdHRlcm4udGVzdChhKSYmImRhdGE6IiE9PWEuc3Vic3RyaW5nKDAsNSkmJiF0aGlzLmlzRXh0ZXJuYWxQcm90b2NvbChhKX07R3JhcGgucHJvdG90eXBlLmdldEFic29sdXRlVXJsPWZ1bmN0aW9uKGEpe251bGwhPWEmJnRoaXMuaXNSZWxhdGl2ZVVybChhKSYmKGE9IiMiPT1hLmNoYXJBdCgwKT90aGlzLmJhc2VVcmwrYToiLyI9PWEuY2hhckF0KDApP3RoaXMuZG9tYWluVXJsK2E6dGhpcy5kb21haW5QYXRoVXJsK2EpO3JldHVybiBhfTsKR3JhcGgucHJvdG90eXBlLmluaXRMYXlvdXRNYW5hZ2VyPWZ1bmN0aW9uKCl7dGhpcy5sYXlvdXRNYW5hZ2VyPW5ldyBteExheW91dE1hbmFnZXIodGhpcyk7dGhpcy5sYXlvdXRNYW5hZ2VyLmhhc0xheW91dD1mdW5jdGlvbihhLGMpe3JldHVybiBudWxsIT10aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKS5jaGlsZExheW91dH07dGhpcy5sYXlvdXRNYW5hZ2VyLmdldExheW91dD1mdW5jdGlvbihhLGMpe2lmKGMhPW14RXZlbnQuQkVHSU5fVVBEQVRFKXt2YXIgZj10aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKTtpZigic3RhY2tMYXlvdXQiPT1mLmNoaWxkTGF5b3V0KXt2YXIgZD1uZXcgbXhTdGFja0xheW91dCh0aGlzLmdyYXBoLCEwKTtkLnJlc2l6ZVBhcmVudE1heD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoZiwicmVzaXplUGFyZW50TWF4IiwiMSIpO2QuaG9yaXpvbnRhbD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoZiwiaG9yaXpvbnRhbFN0YWNrIiwiMSIpO2QucmVzaXplUGFyZW50PQoiMSI9PW14VXRpbHMuZ2V0VmFsdWUoZiwicmVzaXplUGFyZW50IiwiMSIpO2QucmVzaXplTGFzdD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoZiwicmVzaXplTGFzdCIsIjAiKTtkLnNwYWNpbmc9Zi5zdGFja1NwYWNpbmd8fGQuc3BhY2luZztkLmJvcmRlcj1mLnN0YWNrQm9yZGVyfHxkLmJvcmRlcjtkLm1hcmdpbkxlZnQ9Zi5tYXJnaW5MZWZ0fHwwO2QubWFyZ2luUmlnaHQ9Zi5tYXJnaW5SaWdodHx8MDtkLm1hcmdpblRvcD1mLm1hcmdpblRvcHx8MDtkLm1hcmdpbkJvdHRvbT1mLm1hcmdpbkJvdHRvbXx8MDtkLmZpbGw9ITA7cmV0dXJuIGR9aWYoInRyZWVMYXlvdXQiPT1mLmNoaWxkTGF5b3V0KXJldHVybiBkPW5ldyBteENvbXBhY3RUcmVlTGF5b3V0KHRoaXMuZ3JhcGgpLGQuaG9yaXpvbnRhbD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoZiwiaG9yaXpvbnRhbFRyZWUiLCIxIiksZC5yZXNpemVQYXJlbnQ9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsInJlc2l6ZVBhcmVudCIsIjEiKSwKZC5ncm91cFBhZGRpbmc9bXhVdGlscy5nZXRWYWx1ZShmLCJwYXJlbnRQYWRkaW5nIiwyMCksZC5sZXZlbERpc3RhbmNlPW14VXRpbHMuZ2V0VmFsdWUoZiwidHJlZUxldmVsRGlzdGFuY2UiLDMwKSxkLm1haW50YWluUGFyZW50TG9jYXRpb249ITAsZC5lZGdlUm91dGluZz0hMSxkLnJlc2V0RWRnZXM9ITEsZDtpZigiZmxvd0xheW91dCI9PWYuY2hpbGRMYXlvdXQpcmV0dXJuIGQ9bmV3IG14SGllcmFyY2hpY2FsTGF5b3V0KHRoaXMuZ3JhcGgsbXhVdGlscy5nZXRWYWx1ZShmLCJmbG93T3JpZW50YXRpb24iLG14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUKSksZC5yZXNpemVQYXJlbnQ9IjEiPT1teFV0aWxzLmdldFZhbHVlKGYsInJlc2l6ZVBhcmVudCIsIjEiKSxkLnBhcmVudEJvcmRlcj1teFV0aWxzLmdldFZhbHVlKGYsInBhcmVudFBhZGRpbmciLDIwKSxkLm1haW50YWluUGFyZW50TG9jYXRpb249ITAsZC5pbnRyYUNlbGxTcGFjaW5nPW14VXRpbHMuZ2V0VmFsdWUoZiwiaW50cmFDZWxsU3BhY2luZyIsCm14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5pbnRyYUNlbGxTcGFjaW5nKSxkLmludGVyUmFua0NlbGxTcGFjaW5nPW14VXRpbHMuZ2V0VmFsdWUoZiwiaW50ZXJSYW5rQ2VsbFNwYWNpbmciLG14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5pbnRlclJhbmtDZWxsU3BhY2luZyksZC5pbnRlckhpZXJhcmNoeVNwYWNpbmc9bXhVdGlscy5nZXRWYWx1ZShmLCJpbnRlckhpZXJhcmNoeVNwYWNpbmciLG14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5pbnRlckhpZXJhcmNoeVNwYWNpbmcpLGQucGFyYWxsZWxFZGdlU3BhY2luZz1teFV0aWxzLmdldFZhbHVlKGYsInBhcmFsbGVsRWRnZVNwYWNpbmciLG14SGllcmFyY2hpY2FsTGF5b3V0LnByb3RvdHlwZS5wYXJhbGxlbEVkZ2VTcGFjaW5nKSxkO2lmKCJjaXJjbGVMYXlvdXQiPT1mLmNoaWxkTGF5b3V0KXJldHVybiBuZXcgbXhDaXJjbGVMYXlvdXQodGhpcy5ncmFwaCk7aWYoIm9yZ2FuaWNMYXlvdXQiPT1mLmNoaWxkTGF5b3V0KXJldHVybiBuZXcgbXhGYXN0T3JnYW5pY0xheW91dCh0aGlzLmdyYXBoKTsKaWYoInRhYmxlTGF5b3V0Ij09Zi5jaGlsZExheW91dClyZXR1cm4gbmV3IFRhYmxlTGF5b3V0KHRoaXMuZ3JhcGgpfXJldHVybiBudWxsfX07R3JhcGgucHJvdG90eXBlLmdldFBhZ2VTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZVZpc2libGU/bmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLnBhZ2VGb3JtYXQud2lkdGgqdGhpcy5wYWdlU2NhbGUsdGhpcy5wYWdlRm9ybWF0LmhlaWdodCp0aGlzLnBhZ2VTY2FsZSk6dGhpcy5zY3JvbGxUaWxlU2l6ZX07CkdyYXBoLnByb3RvdHlwZS5nZXRQYWdlTGF5b3V0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRQYWdlU2l6ZSgpLGM9dGhpcy5nZXRHcmFwaEJvdW5kcygpO2lmKDA9PWMud2lkdGh8fDA9PWMuaGVpZ2h0KXJldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLDEsMSk7dmFyIGY9TWF0aC5mbG9vcihNYXRoLmNlaWwoYy54L3RoaXMudmlldy5zY2FsZS10aGlzLnZpZXcudHJhbnNsYXRlLngpL2Eud2lkdGgpLGQ9TWF0aC5mbG9vcihNYXRoLmNlaWwoYy55L3RoaXMudmlldy5zY2FsZS10aGlzLnZpZXcudHJhbnNsYXRlLnkpL2EuaGVpZ2h0KTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKGYsZCxNYXRoLmNlaWwoKE1hdGguZmxvb3IoKGMueCtjLndpZHRoKS90aGlzLnZpZXcuc2NhbGUpLXRoaXMudmlldy50cmFuc2xhdGUueCkvYS53aWR0aCktZixNYXRoLmNlaWwoKE1hdGguZmxvb3IoKGMueStjLmhlaWdodCkvdGhpcy52aWV3LnNjYWxlKS10aGlzLnZpZXcudHJhbnNsYXRlLnkpL2EuaGVpZ2h0KS0KZCl9O0dyYXBoLnByb3RvdHlwZS5zYW5pdGl6ZUh0bWw9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gaHRtbF9zYW5pdGl6ZShhLGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYiamF2YXNjcmlwdDoiIT09YS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsMTEpP2E6bnVsbH0sZnVuY3Rpb24oYSl7cmV0dXJuIGF9KX07R3JhcGgucHJvdG90eXBlLnVwZGF0ZVBsYWNlaG9sZGVycz1mdW5jdGlvbigpe3ZhciBhPSExLGM7Zm9yKGMgaW4gdGhpcy5tb2RlbC5jZWxscyl7dmFyIGY9dGhpcy5tb2RlbC5jZWxsc1tjXTt0aGlzLmlzUmVwbGFjZVBsYWNlaG9sZGVycyhmKSYmKHRoaXMudmlldy5pbnZhbGlkYXRlKGYsITEsITEpLGE9ITApfWEmJnRoaXMudmlldy52YWxpZGF0ZSgpfTtHcmFwaC5wcm90b3R5cGUuaXNSZXBsYWNlUGxhY2Vob2xkZXJzPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnZhbHVlJiYib2JqZWN0Ij09dHlwZW9mIGEudmFsdWUmJiIxIj09YS52YWx1ZS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVycyIpfTsKR3JhcGgucHJvdG90eXBlLmlzWm9vbVdoZWVsRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNBbHREb3duKGEpfHxteEV2ZW50LmlzTWV0YURvd24oYSkmJm14Q2xpZW50LklTX01BQ3x8bXhFdmVudC5pc0NvbnRyb2xEb3duKGEpfTtHcmFwaC5wcm90b3R5cGUuaXNTY3JvbGxXaGVlbEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiF0aGlzLmlzWm9vbVdoZWVsRXZlbnQoYSl9O0dyYXBoLnByb3RvdHlwZS5pc1RyYW5zcGFyZW50Q2xpY2tFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5pc0FsdERvd24oYSl8fG14Q2xpZW50LklTX0NIUk9NRU9TJiZteEV2ZW50LmlzU2hpZnREb3duKGEpfTtHcmFwaC5wcm90b3R5cGUuaXNJZ25vcmVUZXJtaW5hbEV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzU2hpZnREb3duKGEpJiZteEV2ZW50LmlzQ29udHJvbERvd24oYSl9OwpHcmFwaC5wcm90b3R5cGUuaXNTcGxpdFRhcmdldD1mdW5jdGlvbihhLGMsZil7cmV0dXJuIXRoaXMubW9kZWwuaXNFZGdlKGNbMF0pJiYhbXhFdmVudC5pc0FsdERvd24oZikmJiFteEV2ZW50LmlzU2hpZnREb3duKGYpJiZteEdyYXBoLnByb3RvdHlwZS5pc1NwbGl0VGFyZ2V0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLmdldExhYmVsPWZ1bmN0aW9uKGEpe3ZhciBjPW14R3JhcGgucHJvdG90eXBlLmdldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT1jJiZ0aGlzLmlzUmVwbGFjZVBsYWNlaG9sZGVycyhhKSYmbnVsbD09YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVyIikmJihjPXRoaXMucmVwbGFjZVBsYWNlaG9sZGVycyhhLGMpKTtyZXR1cm4gY307CkdyYXBoLnByb3RvdHlwZS5pc0xhYmVsTW92YWJsZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIXRoaXMuaXNDZWxsTG9ja2VkKGEpJiYodGhpcy5tb2RlbC5pc0VkZ2UoYSkmJnRoaXMuZWRnZUxhYmVsc01vdmFibGV8fHRoaXMubW9kZWwuaXNWZXJ0ZXgoYSkmJih0aGlzLnZlcnRleExhYmVsc01vdmFibGV8fCIxIj09bXhVdGlscy5nZXRWYWx1ZShjLCJsYWJlbE1vdmFibGUiLCIwIikpKX07R3JhcGgucHJvdG90eXBlLnNldEdyaWRTaXplPWZ1bmN0aW9uKGEpe3RoaXMuZ3JpZFNpemU9YTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZ3JpZFNpemVDaGFuZ2VkIikpfTsKR3JhcGgucHJvdG90eXBlLmdldENsaWNrYWJsZUxpbmtGb3JDZWxsPWZ1bmN0aW9uKGEpe2Rve3ZhciBjPXRoaXMuZ2V0TGlua0ZvckNlbGwoYSk7aWYobnVsbCE9YylyZXR1cm4gYzthPXRoaXMubW9kZWwuZ2V0UGFyZW50KGEpfXdoaWxlKG51bGwhPWEpO3JldHVybiBudWxsfTtHcmFwaC5wcm90b3R5cGUuZ2V0R2xvYmFsVmFyaWFibGU9ZnVuY3Rpb24oYSl7dmFyIGM9bnVsbDsiZGF0ZSI9PWE/Yz0obmV3IERhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpOiJ0aW1lIj09YT9jPShuZXcgRGF0ZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCk6InRpbWVzdGFtcCI9PWE/Yz0obmV3IERhdGUpLnRvTG9jYWxlU3RyaW5nKCk6ImRhdGV7Ij09YS5zdWJzdHJpbmcoMCw1KSYmKGE9YS5zdWJzdHJpbmcoNSxhLmxlbmd0aC0xKSxjPXRoaXMuZm9ybWF0RGF0ZShuZXcgRGF0ZSxhKSk7cmV0dXJuIGN9OwpHcmFwaC5wcm90b3R5cGUuZm9ybWF0RGF0ZT1mdW5jdGlvbihhLGMsZil7bnVsbD09dGhpcy5kYXRlRm9ybWF0Q2FjaGUmJih0aGlzLmRhdGVGb3JtYXRDYWNoZT17aTE4bjp7ZGF5TmFtZXM6IlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdCBTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheSIuc3BsaXQoIiAiKSxtb250aE5hbWVzOiJKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlYyBKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyIi5zcGxpdCgiICIpfSxtYXNrczp7ImRlZmF1bHQiOiJkZGQgbW1tIGRkIHl5eXkgSEg6TU06c3MiLHNob3J0RGF0ZToibS9kL3l5IixtZWRpdW1EYXRlOiJtbW0gZCwgeXl5eSIsbG9uZ0RhdGU6Im1tbW0gZCwgeXl5eSIsZnVsbERhdGU6ImRkZGQsIG1tbW0gZCwgeXl5eSIsCnNob3J0VGltZToiaDpNTSBUVCIsbWVkaXVtVGltZToiaDpNTTpzcyBUVCIsbG9uZ1RpbWU6Img6TU06c3MgVFQgWiIsaXNvRGF0ZToieXl5eS1tbS1kZCIsaXNvVGltZToiSEg6TU06c3MiLGlzb0RhdGVUaW1lOiJ5eXl5LW1tLWRkJ1QnSEg6TU06c3MiLGlzb1V0Y0RhdGVUaW1lOiJVVEM6eXl5eS1tbS1kZCdUJ0hIOk1NOnNzJ1onIn19KTt2YXIgZD10aGlzLmRhdGVGb3JtYXRDYWNoZSxrPS9cYig/OltQTUNFQV1bU0RQXVR8KD86UGFjaWZpY3xNb3VudGFpbnxDZW50cmFsfEVhc3Rlcm58QXRsYW50aWMpICg/OlN0YW5kYXJkfERheWxpZ2h0fFByZXZhaWxpbmcpIFRpbWV8KD86R01UfFVUQykoPzpbLStdXGR7NH0pPylcYi9nLG09L1teLStcZEEtWl0vZyxxPWZ1bmN0aW9uKGEsYil7YT1TdHJpbmcoYSk7Zm9yKGI9Ynx8MjthLmxlbmd0aDxiOylhPSIwIithO3JldHVybiBhfTsxIT1hcmd1bWVudHMubGVuZ3RofHwiW29iamVjdCBTdHJpbmddIiE9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfHwKL1xkLy50ZXN0KGEpfHwoYz1hLGE9dm9pZCAwKTthPWE/bmV3IERhdGUoYSk6bmV3IERhdGU7aWYoaXNOYU4oYSkpdGhyb3cgU3ludGF4RXJyb3IoImludmFsaWQgZGF0ZSIpO2M9U3RyaW5nKGQubWFza3NbY118fGN8fGQubWFza3NbImRlZmF1bHQiXSk7IlVUQzoiPT1jLnNsaWNlKDAsNCkmJihjPWMuc2xpY2UoNCksZj0hMCk7dmFyIGI9Zj8iZ2V0VVRDIjoiZ2V0IixlPWFbYisiRGF0ZSJdKCksZz1hW2IrIkRheSJdKCksbj1hW2IrIk1vbnRoIl0oKSxsPWFbYisiRnVsbFllYXIiXSgpLHA9YVtiKyJIb3VycyJdKCksdj1hW2IrIk1pbnV0ZXMiXSgpLHQ9YVtiKyJTZWNvbmRzIl0oKSxiPWFbYisiTWlsbGlzZWNvbmRzIl0oKSx5PWY/MDphLmdldFRpbWV6b25lT2Zmc2V0KCkseD17ZDplLGRkOnEoZSksZGRkOmQuaTE4bi5kYXlOYW1lc1tnXSxkZGRkOmQuaTE4bi5kYXlOYW1lc1tnKzddLG06bisxLG1tOnEobisxKSxtbW06ZC5pMThuLm1vbnRoTmFtZXNbbl0sbW1tbTpkLmkxOG4ubW9udGhOYW1lc1tuKwoxMl0seXk6U3RyaW5nKGwpLnNsaWNlKDIpLHl5eXk6bCxoOnAlMTJ8fDEyLGhoOnEocCUxMnx8MTIpLEg6cCxISDpxKHApLE06dixNTTpxKHYpLHM6dCxzczpxKHQpLGw6cShiLDMpLEw6cSg5OTxiP01hdGgucm91bmQoYi8xMCk6YiksdDoxMj5wPyJhIjoicCIsdHQ6MTI+cD8iYW0iOiJwbSIsVDoxMj5wPyJBIjoiUCIsVFQ6MTI+cD8iQU0iOiJQTSIsWjpmPyJVVEMiOihTdHJpbmcoYSkubWF0Y2goayl8fFsiIl0pLnBvcCgpLnJlcGxhY2UobSwiIiksbzooMDx5PyItIjoiKyIpK3EoMTAwKk1hdGguZmxvb3IoTWF0aC5hYnMoeSkvNjApK01hdGguYWJzKHkpJTYwLDQpLFM6WyJ0aCIsInN0IiwibmQiLCJyZCJdWzM8ZSUxMD8wOigxMCE9ZSUxMDAtZSUxMCkqZSUxMF19O3JldHVybiBjLnJlcGxhY2UoL2R7MSw0fXxtezEsNH18eXkoPzp5eSk/fChbSGhNc1R0XSlcMT98W0xsb1NaXXwiW14iXSoifCdbXiddKicvZyxmdW5jdGlvbihhKXtyZXR1cm4gYSBpbiB4P3hbYV06YS5zbGljZSgxLAphLmxlbmd0aC0xKX0pfTsKR3JhcGgucHJvdG90eXBlLmNyZWF0ZUxheWVyc0RpYWxvZz1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtmb3IodmFyIGM9dGhpcy5nZXRNb2RlbCgpLGY9Yy5nZXRDaGlsZENvdW50KGMucm9vdCksZD0wO2Q8ZjtkKyspbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZCl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zi5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtmLnN0eWxlLnRleHRPdmVyZmxvdz0iZWxsaXBzaXMiO2Yuc3R5bGUucGFkZGluZz0iMnB4IjtmLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7dmFyIGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtrLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayI7ay5zZXRBdHRyaWJ1dGUoInR5cGUiLCJjaGVja2JveCIpO2MuaXNWaXNpYmxlKGQpJiYoay5zZXRBdHRyaWJ1dGUoImNoZWNrZWQiLCJjaGVja2VkIiksCmsuZGVmYXVsdENoZWNrZWQ9ITApO2YuYXBwZW5kQ2hpbGQoayk7dmFyIGI9dGhpcy5jb252ZXJ0VmFsdWVUb1N0cmluZyhkKXx8bXhSZXNvdXJjZXMuZ2V0KCJiYWNrZ3JvdW5kIil8fCJCYWNrZ3JvdW5kIjtmLnNldEF0dHJpYnV0ZSgidGl0bGUiLGIpO214VXRpbHMud3JpdGUoZixiKTthLmFwcGVuZENoaWxkKGYpO214RXZlbnQuYWRkTGlzdGVuZXIoaywiY2xpY2siLGZ1bmN0aW9uKCl7bnVsbCE9ay5nZXRBdHRyaWJ1dGUoImNoZWNrZWQiKT9rLnJlbW92ZUF0dHJpYnV0ZSgiY2hlY2tlZCIpOmsuc2V0QXR0cmlidXRlKCJjaGVja2VkIiwiY2hlY2tlZCIpO2Muc2V0VmlzaWJsZShkLGsuY2hlY2tlZCl9KX0pKGMuZ2V0Q2hpbGRBdChjLnJvb3QsZCkpO3JldHVybiBhfTsKR3JhcGgucHJvdG90eXBlLnJlcGxhY2VQbGFjZWhvbGRlcnM9ZnVuY3Rpb24oYSxjKXt2YXIgZj1bXTtpZihudWxsIT1jKXtmb3IodmFyIGQ9MDttYXRjaD10aGlzLnBsYWNlaG9sZGVyUGF0dGVybi5leGVjKGMpOyl7dmFyIGs9bWF0Y2hbMF07aWYoMjxrLmxlbmd0aCYmIiVsYWJlbCUiIT1rJiYiJXRvb2x0aXAlIiE9ayl7dmFyIG09bnVsbDtpZihtYXRjaC5pbmRleD5kJiYiJSI9PWMuY2hhckF0KG1hdGNoLmluZGV4LTEpKW09ay5zdWJzdHJpbmcoMSk7ZWxzZXt2YXIgcT1rLnN1YnN0cmluZygxLGsubGVuZ3RoLTEpO2lmKCJpZCI9PXEpbT1hLmlkO2Vsc2UgaWYoMD5xLmluZGV4T2YoInsiKSlmb3IodmFyIGI9YTtudWxsPT1tJiZudWxsIT1iOyludWxsIT1iLnZhbHVlJiYib2JqZWN0Ij09dHlwZW9mIGIudmFsdWUmJihtPWIuaGFzQXR0cmlidXRlKHEpP251bGwhPWIuZ2V0QXR0cmlidXRlKHEpP2IuZ2V0QXR0cmlidXRlKHEpOiIiOm51bGwpLGI9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYik7Cm51bGw9PW0mJihtPXRoaXMuZ2V0R2xvYmFsVmFyaWFibGUocSkpfWYucHVzaChjLnN1YnN0cmluZyhkLG1hdGNoLmluZGV4KSsobnVsbCE9bT9tOmspKTtkPW1hdGNoLmluZGV4K2subGVuZ3RofX1mLnB1c2goYy5zdWJzdHJpbmcoZCkpfXJldHVybiBmLmpvaW4oIiIpfTtHcmFwaC5wcm90b3R5cGUucmVzdG9yZVNlbGVjdGlvbj1mdW5jdGlvbihhKXtpZihudWxsIT1hJiYwPGEubGVuZ3RoKXtmb3IodmFyIGM9W10sZj0wO2Y8YS5sZW5ndGg7ZisrKXt2YXIgZD10aGlzLm1vZGVsLmdldENlbGwoYVtmXS5pZCk7bnVsbCE9ZCYmYy5wdXNoKGQpfXRoaXMuc2V0U2VsZWN0aW9uQ2VsbHMoYyl9ZWxzZSB0aGlzLmNsZWFyU2VsZWN0aW9uKCl9OwpHcmFwaC5wcm90b3R5cGUuc2VsZWN0Q2VsbHNGb3JDb25uZWN0VmVydGV4PWZ1bmN0aW9uKGEsYyxmKXsyPT1hLmxlbmd0aCYmdGhpcy5tb2RlbC5pc1ZlcnRleChhWzFdKT8odGhpcy5zZXRTZWxlY3Rpb25DZWxsKGFbMV0pLHRoaXMuc2Nyb2xsQ2VsbFRvVmlzaWJsZShhWzFdKSxudWxsIT1mJiYobXhFdmVudC5pc1RvdWNoRXZlbnQoYyk/Zi51cGRhdGUoZi5nZXRTdGF0ZSh0aGlzLnZpZXcuZ2V0U3RhdGUoYVsxXSkpKTpmLnJlc2V0KCkpKTp0aGlzLnNldFNlbGVjdGlvbkNlbGxzKGEpfTsKR3JhcGgucHJvdG90eXBlLmNvbm5lY3RWZXJ0ZXg9ZnVuY3Rpb24oYSxjLGYsZCxrLG0pe2lmKGEuZ2VvbWV0cnkucmVsYXRpdmUmJnRoaXMubW9kZWwuaXNFZGdlKGEucGFyZW50KSlyZXR1cm5bXTttPW0/bTohMTt2YXIgcT10aGlzLmdldENvbXBvc2l0ZVBhcmVudChhKSxiPWEuZ2VvbWV0cnkucmVsYXRpdmUmJm51bGwhPWEucGFyZW50Lmdlb21ldHJ5P25ldyBteFBvaW50KGEucGFyZW50Lmdlb21ldHJ5LndpZHRoKmEuZ2VvbWV0cnkueCxhLnBhcmVudC5nZW9tZXRyeS5oZWlnaHQqYS5nZW9tZXRyeS55KTpuZXcgbXhQb2ludChxLmdlb21ldHJ5LngscS5nZW9tZXRyeS55KTtjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/KGIueCs9cS5nZW9tZXRyeS53aWR0aC8yLGIueS09Zik6Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIPyhiLngrPXEuZ2VvbWV0cnkud2lkdGgvMixiLnkrPXEuZ2VvbWV0cnkuaGVpZ2h0K2YpOihiLng9Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/CmIueC1mOmIueCsocS5nZW9tZXRyeS53aWR0aCtmKSxiLnkrPXEuZ2VvbWV0cnkuaGVpZ2h0LzIpO2Y9dGhpcy52aWV3LmdldFN0YXRlKHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpKTt2YXIgcT10aGlzLnZpZXcuc2NhbGUsZT10aGlzLnZpZXcudHJhbnNsYXRlLGc9ZS54KnEsZT1lLnkqcTtudWxsIT1mJiZ0aGlzLm1vZGVsLmlzVmVydGV4KGYuY2VsbCkmJihnPWYueCxlPWYueSk7dGhpcy5tb2RlbC5pc1ZlcnRleChhLnBhcmVudCkmJmEuZ2VvbWV0cnkucmVsYXRpdmUmJihiLngrPWEucGFyZW50Lmdlb21ldHJ5LngsYi55Kz1hLnBhcmVudC5nZW9tZXRyeS55KTttPW18fG14RXZlbnQuaXNDb250cm9sRG93bihkKSYmIWs/bnVsbDp0aGlzLmdldENlbGxBdChnK2IueCpxLGUrYi55KnEpO3RoaXMubW9kZWwuaXNBbmNlc3RvcihtLGEpJiYobT1udWxsKTtmb3IoZj1tO251bGwhPWY7KXtpZih0aGlzLmlzQ2VsbExvY2tlZChmKSl7bT1udWxsO2JyZWFrfWY9dGhpcy5tb2RlbC5nZXRQYXJlbnQoZil9bnVsbCE9Cm0mJihmPXRoaXMudmlldy5nZXRTdGF0ZShhKSxxPXRoaXMudmlldy5nZXRTdGF0ZShtKSxudWxsIT1mJiZudWxsIT1xJiZteFV0aWxzLmludGVyc2VjdHMoZixxKSYmKG09bnVsbCkpO2lmKGs9IW14RXZlbnQuaXNTaGlmdERvd24oZCl8fGspYz09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIP2IueS09YS5nZW9tZXRyeS5oZWlnaHQvMjpjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/Yi55Kz1hLmdlb21ldHJ5LmhlaWdodC8yOmIueD1jPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD9iLngtYS5nZW9tZXRyeS53aWR0aC8yOmIueCthLmdlb21ldHJ5LndpZHRoLzI7bnVsbD09bXx8dGhpcy5pc0NlbGxDb25uZWN0YWJsZShtKXx8dGhpcy5pc1N3aW1sYW5lKG0pfHwoZj10aGlzLmdldE1vZGVsKCkuZ2V0UGFyZW50KG0pLHRoaXMuZ2V0TW9kZWwoKS5pc1ZlcnRleChmKSYmdGhpcy5pc0NlbGxDb25uZWN0YWJsZShmKSYmKG09ZikpO2lmKG09PWF8fHRoaXMubW9kZWwuaXNFZGdlKG0pfHwKIXRoaXMuaXNDZWxsQ29ubmVjdGFibGUobSkmJiF0aGlzLmlzU3dpbWxhbmUobSkpbT1udWxsO2Y9W107dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgbj1udWxsIT1tJiZ0aGlzLmlzU3dpbWxhbmUobSkscT1uP251bGw6bTtpZihudWxsPT1xJiZrKXtmb3IodmFyIGc9YSxsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGEpO251bGwhPWwmJmwucmVsYXRpdmU7KWc9dGhpcy5nZXRNb2RlbCgpLmdldFBhcmVudChnKSxsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGcpO2c9dGhpcy5nZXRDb21wb3NpdGVQYXJlbnQoZyk7cT10aGlzLmR1cGxpY2F0ZUNlbGxzKFtnXSwhMSlbMF07bD10aGlzLmdldENlbGxHZW9tZXRyeShxKTtudWxsIT1sJiYobC54PWIueC1sLndpZHRoLzIsbC55PWIueS1sLmhlaWdodC8yKTtuJiYodGhpcy5hZGRDZWxscyhbcV0sbSxudWxsLG51bGwsbnVsbCwhMCksbT1udWxsKX1uPW51bGw7bnVsbCE9dGhpcy5sYXlvdXRNYW5hZ2VyJiYobj10aGlzLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0KHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpKSk7CnZhciBwPW14RXZlbnQuaXNDb250cm9sRG93bihkKSYma3x8bnVsbD09bSYmbnVsbCE9biYmbi5jb25zdHJ1Y3Rvcj09bXhTdGFja0xheW91dD9udWxsOnRoaXMuaW5zZXJ0RWRnZSh0aGlzLm1vZGVsLmdldFBhcmVudChhKSxudWxsLCIiLGEscSx0aGlzLmNyZWF0ZUN1cnJlbnRFZGdlU3R5bGUoKSk7aWYobnVsbCE9cCYmdGhpcy5jb25uZWN0aW9uSGFuZGxlci5pbnNlcnRCZWZvcmVTb3VyY2Upe3ZhciB2PW51bGw7Zm9yKGQ9YTtudWxsIT1kLnBhcmVudCYmbnVsbCE9ZC5nZW9tZXRyeSYmZC5nZW9tZXRyeS5yZWxhdGl2ZSYmZC5wYXJlbnQhPXAucGFyZW50OylkPXRoaXMubW9kZWwuZ2V0UGFyZW50KGQpO251bGwhPWQmJm51bGwhPWQucGFyZW50JiZkLnBhcmVudD09cC5wYXJlbnQmJih2PWQucGFyZW50LmdldEluZGV4KGQpLHRoaXMubW9kZWwuYWRkKGQucGFyZW50LHAsdikpfW51bGw9PW0mJm51bGwhPXEmJm51bGwhPW4mJm51bGwhPWEucGFyZW50JiZuLmNvbnN0cnVjdG9yPT0KbXhTdGFja0xheW91dCYmYz09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QmJih2PWEucGFyZW50LmdldEluZGV4KGEpLHRoaXMubW9kZWwuYWRkKGEucGFyZW50LHEsdikpO251bGwhPXAmJmYucHVzaChwKTtudWxsPT1tJiZudWxsIT1xJiZmLnB1c2gocSk7bnVsbD09cSYmbnVsbCE9cCYmcC5nZW9tZXRyeS5zZXRUZXJtaW5hbFBvaW50KGIsITEpO251bGwhPXAmJnRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJjZWxsc0luc2VydGVkIiwiY2VsbHMiLFtwXSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gZn07CkdyYXBoLnByb3RvdHlwZS5nZXRJbmRleGFibGVUZXh0PWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksYz1bXSxmLGQ7Zm9yKGQgaW4gdGhpcy5tb2RlbC5jZWxscylpZihmPXRoaXMubW9kZWwuY2VsbHNbZF0sdGhpcy5tb2RlbC5pc1ZlcnRleChmKXx8dGhpcy5tb2RlbC5pc0VkZ2UoZikpdGhpcy5pc0h0bWxMYWJlbChmKT8oYS5pbm5lckhUTUw9dGhpcy5nZXRMYWJlbChmKSxmPW14VXRpbHMuZXh0cmFjdFRleHRXaXRoV2hpdGVzcGFjZShbYV0pKTpmPXRoaXMuZ2V0TGFiZWwoZiksZj1teFV0aWxzLnRyaW0oZi5yZXBsYWNlKC9bXHgwMC1ceDFGXHg3Ri1ceDlGXXxccysvZywiICIpKSwwPGYubGVuZ3RoJiZjLnB1c2goZik7cmV0dXJuIGMuam9pbigiICIpfTsKR3JhcGgucHJvdG90eXBlLmNvbnZlcnRWYWx1ZVRvU3RyaW5nPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMubW9kZWwuZ2V0VmFsdWUoYSk7aWYobnVsbCE9YyYmIm9iamVjdCI9PXR5cGVvZiBjKXtpZih0aGlzLmlzUmVwbGFjZVBsYWNlaG9sZGVycyhhKSYmbnVsbCE9YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVyIikpe2Zvcih2YXIgYz1hLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXIiKSxmPWEsZD1udWxsO251bGw9PWQmJm51bGwhPWY7KW51bGwhPWYudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgZi52YWx1ZSYmKGQ9Zi5oYXNBdHRyaWJ1dGUoYyk/bnVsbCE9Zi5nZXRBdHRyaWJ1dGUoYyk/Zi5nZXRBdHRyaWJ1dGUoYyk6IiI6bnVsbCksZj10aGlzLm1vZGVsLmdldFBhcmVudChmKTtyZXR1cm4gZHx8IiJ9cmV0dXJuIGMuZ2V0QXR0cmlidXRlKCJsYWJlbCIpfHwiIn1yZXR1cm4gbXhHcmFwaC5wcm90b3R5cGUuY29udmVydFZhbHVlVG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTsKR3JhcGgucHJvdG90eXBlLmdldExpbmtzRm9yU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJm51bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0Lm5vZGU/YS50ZXh0Lm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKTpudWxsfTtHcmFwaC5wcm90b3R5cGUuZ2V0TGlua0ZvckNlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYS52YWx1ZT8oYT1hLnZhbHVlLmdldEF0dHJpYnV0ZSgibGluayIpLG51bGwhPWEmJiJqYXZhc2NyaXB0OiI9PT1hLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsMTEpJiYoYT1hLnN1YnN0cmluZygxMSkpLGEpOm51bGx9OwpHcmFwaC5wcm90b3R5cGUuZ2V0Q2VsbFN0eWxlPWZ1bmN0aW9uKGEpe3ZhciBjPW14R3JhcGgucHJvdG90eXBlLmdldENlbGxTdHlsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9YSYmbnVsbCE9dGhpcy5sYXlvdXRNYW5hZ2VyKXt2YXIgZj10aGlzLm1vZGVsLmdldFBhcmVudChhKTt0aGlzLm1vZGVsLmlzVmVydGV4KGYpJiZ0aGlzLmlzQ2VsbENvbGxhcHNlZChhKSYmKGY9dGhpcy5sYXlvdXRNYW5hZ2VyLmdldExheW91dChmKSxudWxsIT1mJiZmLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0JiYoY1tteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMXT0hZi5ob3Jpem9udGFsKSl9cmV0dXJuIGN9OwpHcmFwaC5wcm90b3R5cGUudXBkYXRlQWx0ZXJuYXRlQm91bmRzPWZ1bmN0aW9uKGEsYyxmKXtpZihudWxsIT1hJiZudWxsIT1jJiZudWxsIT10aGlzLmxheW91dE1hbmFnZXImJm51bGwhPWMuYWx0ZXJuYXRlQm91bmRzKXt2YXIgZD10aGlzLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0KHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpKTtudWxsIT1kJiZkLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0JiYoZC5ob3Jpem9udGFsP2MuYWx0ZXJuYXRlQm91bmRzLmhlaWdodD0wOmMuYWx0ZXJuYXRlQm91bmRzLndpZHRoPTApfW14R3JhcGgucHJvdG90eXBlLnVwZGF0ZUFsdGVybmF0ZUJvdW5kcy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0dyYXBoLnByb3RvdHlwZS5pc01vdmVDZWxsc0V2ZW50PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG14RXZlbnQuaXNTaGlmdERvd24oYSl8fCIxIj09bXhVdGlscy5nZXRWYWx1ZShjLnN0eWxlLCJtb3ZlQ2VsbHMiLCIwIil9OwpHcmFwaC5wcm90b3R5cGUuZm9sZENlbGxzPWZ1bmN0aW9uKGEsYyxmLGQsayl7Yz1udWxsIT1jP2M6ITE7bnVsbD09ZiYmKGY9dGhpcy5nZXRGb2xkYWJsZUNlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxhKSk7aWYobnVsbCE9Zil7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtpZihteEdyYXBoLnByb3RvdHlwZS5mb2xkQ2VsbHMuYXBwbHkodGhpcyxhcmd1bWVudHMpLG51bGwhPXRoaXMubGF5b3V0TWFuYWdlcilmb3IodmFyIG09MDttPGYubGVuZ3RoO20rKyl7dmFyIHE9dGhpcy52aWV3LmdldFN0YXRlKGZbbV0pLGI9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZlttXSk7aWYobnVsbCE9cSYmbnVsbCE9Yil7dmFyIGU9TWF0aC5yb3VuZChiLndpZHRoLXEud2lkdGgvdGhpcy52aWV3LnNjYWxlKSxnPU1hdGgucm91bmQoYi5oZWlnaHQtcS5oZWlnaHQvdGhpcy52aWV3LnNjYWxlKTtpZigwIT1nfHwwIT1lKXt2YXIgbj10aGlzLm1vZGVsLmdldFBhcmVudChmW21dKSxsPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQobik7Cm51bGw9PWw/bnVsbCE9ayYmdGhpcy5pc01vdmVDZWxsc0V2ZW50KGsscSkmJnRoaXMubW92ZVNpYmxpbmdzKHEsbixlLGcpOm51bGwhPWsmJm14RXZlbnQuaXNBbHREb3duKGspfHxsLmNvbnN0cnVjdG9yIT1teFN0YWNrTGF5b3V0fHxsLnJlc2l6ZUxhc3R8fHRoaXMucmVzaXplUGFyZW50U3RhY2tzKG4sbCxlLGcpfX19fWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX10aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLnNldFNlbGVjdGlvbkNlbGxzKGYpfX07CkdyYXBoLnByb3RvdHlwZS5tb3ZlU2libGluZ3M9ZnVuY3Rpb24oYSxjLGYsZCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgaz10aGlzLmdldENlbGxzQmV5b25kKGEueCxhLnksYywhMCwhMCk7Zm9yKGM9MDtjPGsubGVuZ3RoO2MrKylpZihrW2NdIT1hLmNlbGwpe3ZhciBtPXRoaXMudmlldy5nZXRTdGF0ZShrW2NdKSxxPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGtbY10pO251bGwhPW0mJm51bGwhPXEmJihxPXEuY2xvbmUoKSxxLnRyYW5zbGF0ZShNYXRoLnJvdW5kKGYqTWF0aC5tYXgoMCxNYXRoLm1pbigxLChtLngtYS54KS9hLndpZHRoKSkpLE1hdGgucm91bmQoZCpNYXRoLm1heCgwLE1hdGgubWluKDEsKG0ueS1hLnkpL2EuaGVpZ2h0KSkpKSx0aGlzLm1vZGVsLnNldEdlb21ldHJ5KGtbY10scSkpfX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9fTsKR3JhcGgucHJvdG90eXBlLnJlc2l6ZVBhcmVudFN0YWNrcz1mdW5jdGlvbihhLGMsZixkKXtpZihudWxsIT10aGlzLmxheW91dE1hbmFnZXImJm51bGwhPWMmJmMuY29uc3RydWN0b3I9PW14U3RhY2tMYXlvdXQmJiFjLnJlc2l6ZUxhc3Qpe3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBrPWMuaG9yaXpvbnRhbDtudWxsIT1hJiZudWxsIT1jJiZjLmNvbnN0cnVjdG9yPT1teFN0YWNrTGF5b3V0JiZjLmhvcml6b250YWw9PWsmJiFjLnJlc2l6ZUxhc3Q7KXt2YXIgbT10aGlzLmdldENlbGxHZW9tZXRyeShhKSxxPXRoaXMudmlldy5nZXRTdGF0ZShhKTtudWxsIT1xJiZudWxsIT1tJiYobT1tLmNsb25lKCksYy5ob3Jpem9udGFsP20ud2lkdGgrPWYrTWF0aC5taW4oMCxxLndpZHRoL3RoaXMudmlldy5zY2FsZS1tLndpZHRoKTptLmhlaWdodCs9ZCtNYXRoLm1pbigwLHEuaGVpZ2h0L3RoaXMudmlldy5zY2FsZS1tLmhlaWdodCksdGhpcy5tb2RlbC5zZXRHZW9tZXRyeShhLAptKSk7YT10aGlzLm1vZGVsLmdldFBhcmVudChhKTtjPXRoaXMubGF5b3V0TWFuYWdlci5nZXRMYXlvdXQoYSl9fWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19fTtHcmFwaC5wcm90b3R5cGUuaXNDb250YWluZXI9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiB0aGlzLmlzU3dpbWxhbmUoYSk/IjAiIT1jLmNvbnRhaW5lcjoiMSI9PWMuY29udGFpbmVyfTtHcmFwaC5wcm90b3R5cGUuaXNFeHRlbmRQYXJlbnQ9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSk7cmV0dXJuIG51bGwhPWMmJihjPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShjKSxudWxsIT1jLmV4cGFuZCk/IjAiIT1jLmV4cGFuZDpteEdyYXBoLnByb3RvdHlwZS5pc0V4dGVuZFBhcmVudC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9OwpHcmFwaC5wcm90b3R5cGUuaXNDZWxsQ29ubmVjdGFibGU9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpO3JldHVybiBudWxsIT1jLmNvbm5lY3RhYmxlPyIwIiE9Yy5jb25uZWN0YWJsZTpteEdyYXBoLnByb3RvdHlwZS5pc0NlbGxDb25uZWN0YWJsZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0dyYXBoLnByb3RvdHlwZS5pc0xhYmVsTW92YWJsZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIG51bGwhPWMubW92YWJsZUxhYmVsPyIwIiE9Yy5tb3ZhYmxlTGFiZWw6bXhHcmFwaC5wcm90b3R5cGUuaXNMYWJlbE1vdmFibGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtHcmFwaC5wcm90b3R5cGUuc2VsZWN0QWxsPWZ1bmN0aW9uKGEpe2E9YXx8dGhpcy5nZXREZWZhdWx0UGFyZW50KCk7dGhpcy5pc0NlbGxMb2NrZWQoYSl8fG14R3JhcGgucHJvdG90eXBlLnNlbGVjdEFsbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9OwpHcmFwaC5wcm90b3R5cGUuc2VsZWN0Q2VsbHM9ZnVuY3Rpb24oYSxjLGYpe2Y9Znx8dGhpcy5nZXREZWZhdWx0UGFyZW50KCk7dGhpcy5pc0NlbGxMb2NrZWQoZil8fG14R3JhcGgucHJvdG90eXBlLnNlbGVjdENlbGxzLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLmdldFN3aW1sYW5lQXQ9ZnVuY3Rpb24oYSxjLGYpe3ZhciBkPW14R3JhcGgucHJvdG90eXBlLmdldFN3aW1sYW5lQXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuaXNDZWxsTG9ja2VkKGQpJiYoZD1udWxsKTtyZXR1cm4gZH07CkdyYXBoLnByb3RvdHlwZS5pc0NlbGxGb2xkYWJsZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmdldEN1cnJlbnRDZWxsU3R5bGUoYSk7cmV0dXJuIHRoaXMuZm9sZGluZ0VuYWJsZWQmJigiMSI9PWMudHJlZUZvbGRpbmd8fCF0aGlzLmlzQ2VsbExvY2tlZChhKSYmKHRoaXMuaXNDb250YWluZXIoYSkmJiIwIiE9Yy5jb2xsYXBzaWJsZXx8IXRoaXMuaXNDb250YWluZXIoYSkmJiIxIj09Yy5jb2xsYXBzaWJsZSkpfTtHcmFwaC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmlzRWRpdGluZygpJiZ0aGlzLnN0b3BFZGl0aW5nKCEwKTt0aGlzLmVzY2FwZSgpO3RoaXMuaXNTZWxlY3Rpb25FbXB0eSgpfHx0aGlzLmNsZWFyU2VsZWN0aW9uKCl9OwpHcmFwaC5wcm90b3R5cGUuem9vbT1mdW5jdGlvbihhLGMpe2E9TWF0aC5tYXgoLjAxLE1hdGgubWluKHRoaXMudmlldy5zY2FsZSphLDE2MCkpL3RoaXMudmlldy5zY2FsZTtteEdyYXBoLnByb3RvdHlwZS56b29tLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07R3JhcGgucHJvdG90eXBlLnpvb21Jbj1mdW5jdGlvbigpey4xNT50aGlzLnZpZXcuc2NhbGU/dGhpcy56b29tKCh0aGlzLnZpZXcuc2NhbGUrLjAxKS90aGlzLnZpZXcuc2NhbGUpOnRoaXMuem9vbShNYXRoLnJvdW5kKHRoaXMudmlldy5zY2FsZSp0aGlzLnpvb21GYWN0b3IqMjApLzIwL3RoaXMudmlldy5zY2FsZSl9O0dyYXBoLnByb3RvdHlwZS56b29tT3V0PWZ1bmN0aW9uKCl7LjE1Pj10aGlzLnZpZXcuc2NhbGU/dGhpcy56b29tKCh0aGlzLnZpZXcuc2NhbGUtLjAxKS90aGlzLnZpZXcuc2NhbGUpOnRoaXMuem9vbShNYXRoLnJvdW5kKDEvdGhpcy56b29tRmFjdG9yKnRoaXMudmlldy5zY2FsZSoyMCkvMjAvdGhpcy52aWV3LnNjYWxlKX07CkdyYXBoLnByb3RvdHlwZS5nZXRUb29sdGlwRm9yQ2VsbD1mdW5jdGlvbihhKXt2YXIgYz0iIjtpZihteFV0aWxzLmlzTm9kZShhLnZhbHVlKSl7dmFyIGY9YS52YWx1ZS5nZXRBdHRyaWJ1dGUoInRvb2x0aXAiKTtpZihudWxsIT1mKW51bGwhPWYmJnRoaXMuaXNSZXBsYWNlUGxhY2Vob2xkZXJzKGEpJiYoZj10aGlzLnJlcGxhY2VQbGFjZWhvbGRlcnMoYSxmKSksYz10aGlzLnNhbml0aXplSHRtbChmKTtlbHNle2Y9dGhpcy5idWlsdEluUHJvcGVydGllczthPWEudmFsdWUuYXR0cmlidXRlczt2YXIgZD1bXTt0aGlzLmlzRW5hYmxlZCgpJiZmLnB1c2goImxpbmsiKTtmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKykwPm14VXRpbHMuaW5kZXhPZihmLGFba10ubm9kZU5hbWUpJiYwPGFba10ubm9kZVZhbHVlLmxlbmd0aCYmZC5wdXNoKHtuYW1lOmFba10ubm9kZU5hbWUsdmFsdWU6YVtrXS5ub2RlVmFsdWV9KTtkLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYS5uYW1lPGMubmFtZT8KLTE6YS5uYW1lPmMubmFtZT8xOjB9KTtmb3Ioaz0wO2s8ZC5sZW5ndGg7aysrKSJsaW5rIj09ZFtrXS5uYW1lJiZ0aGlzLmlzQ3VzdG9tTGluayhkW2tdLnZhbHVlKXx8KGMrPSgibGluayIhPWRba10ubmFtZT8iPGI+IitkW2tdLm5hbWUrIjo8L2I+ICI6IiIpK214VXRpbHMuaHRtbEVudGl0aWVzKGRba10udmFsdWUpKyJcbiIpOzA8Yy5sZW5ndGgmJihjPWMuc3Vic3RyaW5nKDAsYy5sZW5ndGgtMSksbXhDbGllbnQuSVNfU1ZHJiYoYz0nPGRpdiBzdHlsZT0ibWF4LXdpZHRoOjM2MHB4OyI+JytjKyI8L2Rpdj4iKSl9fXJldHVybiBjfTtHcmFwaC5wcm90b3R5cGUuc3RyaW5nVG9CeXRlcz1mdW5jdGlvbihhKXtyZXR1cm4gR3JhcGguc3RyaW5nVG9CeXRlcyhhKX07R3JhcGgucHJvdG90eXBlLmJ5dGVzVG9TdHJpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuIEdyYXBoLmJ5dGVzVG9TdHJpbmcoYSl9O0dyYXBoLnByb3RvdHlwZS5jb21wcmVzc05vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIEdyYXBoLmNvbXByZXNzTm9kZShhKX07CkdyYXBoLnByb3RvdHlwZS5jb21wcmVzcz1mdW5jdGlvbihhLGMpe3JldHVybiBHcmFwaC5jb21wcmVzcyhhLGMpfTtHcmFwaC5wcm90b3R5cGUuZGVjb21wcmVzcz1mdW5jdGlvbihhLGMpe3JldHVybiBHcmFwaC5kZWNvbXByZXNzKGEsYyl9O0dyYXBoLnByb3RvdHlwZS56YXBHcmVtbGlucz1mdW5jdGlvbihhKXtyZXR1cm4gR3JhcGguemFwR3JlbWxpbnMoYSl9O0hvdmVySWNvbnM9ZnVuY3Rpb24oYSl7dGhpcy5ncmFwaD1hO3RoaXMuaW5pdCgpfTtIb3Zlckljb25zLnByb3RvdHlwZS5hcnJvd1NwYWNpbmc9MjtIb3Zlckljb25zLnByb3RvdHlwZS51cGRhdGVEZWxheT01MDA7SG92ZXJJY29ucy5wcm90b3R5cGUuYWN0aXZhdGlvbkRlbGF5PTE0MDtIb3Zlckljb25zLnByb3RvdHlwZS5jdXJyZW50U3RhdGU9bnVsbDtIb3Zlckljb25zLnByb3RvdHlwZS5hY3RpdmVBcnJvdz1udWxsO0hvdmVySWNvbnMucHJvdG90eXBlLmluYWN0aXZlT3BhY2l0eT0xNTsKSG92ZXJJY29ucy5wcm90b3R5cGUuY3NzQ3Vyc29yPSJjb3B5IjtIb3Zlckljb25zLnByb3RvdHlwZS5jaGVja0NvbGxpc2lvbnM9ITA7SG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsPSIjMjliNmYyIjtIb3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVVwPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgxOCwyOCwnPHBhdGggZD0ibSA2IDI2IEwgMTIgMjYgTCAxMiAxMiBMIDE4IDEyIEwgOSAxIEwgMSAxMiBMIDYgMTIgeiIgc3Ryb2tlPSIjZmZmIiBmaWxsPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIi8+Jyk6bmV3IG14SW1hZ2UoSU1BR0VfUEFUSCsiL3RyaWFuZ2xlLXVwLnBuZyIsMjYsMTQpOwpIb3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVJpZ2h0PW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgyNiwxOCwnPHBhdGggZD0ibSAxIDYgTCAxNCA2IEwgMTQgMSBMIDI2IDkgTCAxNCAxOCBMIDE0IDEyIEwgMSAxMiB6IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvdHJpYW5nbGUtcmlnaHQucG5nIiwxNCwyNik7SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVEb3duPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgxOCwyNiwnPHBhdGggZD0ibSA2IDEgTCA2IDE0IEwgMSAxNCBMIDkgMjYgTCAxOCAxNCBMIDEyIDE0IEwgMTIgMSB6IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvdHJpYW5nbGUtZG93bi5wbmciLDI2LDE0KTsKSG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVMZWZ0PW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgyOCwxOCwnPHBhdGggZD0ibSAxIDkgTCAxMiAxIEwgMTIgNiBMIDI2IDYgTCAyNiAxMiBMIDEyIDEyIEwgMTIgMTggeiIgc3Ryb2tlPSIjZmZmIiBmaWxsPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIi8+Jyk6bmV3IG14SW1hZ2UoSU1BR0VfUEFUSCsiL3RyaWFuZ2xlLWxlZnQucG5nIiwxNCwyNik7SG92ZXJJY29ucy5wcm90b3R5cGUucm91bmREcm9wPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgyNiwyNiwnPGNpcmNsZSBjeD0iMTMiIGN5PSIxMyIgcj0iMTIiIHN0cm9rZT0iI2ZmZiIgZmlsbD0iJytIb3Zlckljb25zLnByb3RvdHlwZS5hcnJvd0ZpbGwrJyIvPicpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9yb3VuZC1kcm9wLnBuZyIsMjYsMjYpOwpIb3Zlckljb25zLnByb3RvdHlwZS5yZWZyZXNoVGFyZ2V0PW5ldyBteEltYWdlKG14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2QybGtkR2c5SWpNMmNIZ2lJR2hsYVdkb2REMGlNelp3ZUNJK1BHVnNiR2x3YzJVZ1ptbHNiRDBpSXpJNVlqWm1NaUlnWTNnOUlqRXlJaUJqZVQwaU1USWlJSEo0UFNJeE1pSWdjbms5SWpFeUlpOCtQSEJoZEdnZ2RISmhibk5tYjNKdFBTSnpZMkZzWlNnd0xqZ3BJSFJ5WVc1emJHRjBaU2d5TGpRc0lESXVOQ2tpSUhOMGNtOXJaVDBpSTJabVppSWdabWxzYkQwaUkyWm1aaUlnWkQwaVRURXlJRFoyTTJ3MExUUXROQzAwZGpOakxUUXVORElnTUMwNElETXVOVGd0T0NBNElEQWdNUzQxTnk0ME5pQXpMakF6SURFdU1qUWdOQzR5Tmt3MkxqY2dNVFF1T0dNdExqUTFMUzQ0TXkwdU55MHhMamM1TFM0M0xUSXVPQ0F3TFRNdU16RWdNaTQyT1MwMklEWXRObnB0Tmk0M05pQXhMamMwVERFM0xqTWdPUzR5WXk0ME5DNDROQzQzSURFdU56a3VOeUF5TGpnZ01DQXpMak14TFRJdU5qa2dOaTAySURaMkxUTnNMVFFnTkNBMElEUjJMVE5qTkM0ME1pQXdJRGd0TXk0MU9DQTRMVGdnTUMweExqVTNMUzQwTmkwekxqQXpMVEV1TWpRdE5DNHlObm9pTHo0OGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K1BDOXpkbWMrQ2c9PSI6CklNQUdFX1BBVEgrIi9yZWZyZXNoLnBuZyIsMzgsMzgpO0hvdmVySWNvbnMucHJvdG90eXBlLnRvbGVyYW5jZT1teENsaWVudC5JU19UT1VDSD82OjA7CkhvdmVySWNvbnMucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmFycm93VXA9dGhpcy5jcmVhdGVBcnJvdyh0aGlzLnRyaWFuZ2xlVXAsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKTt0aGlzLmFycm93UmlnaHQ9dGhpcy5jcmVhdGVBcnJvdyh0aGlzLnRyaWFuZ2xlUmlnaHQsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKTt0aGlzLmFycm93RG93bj10aGlzLmNyZWF0ZUFycm93KHRoaXMudHJpYW5nbGVEb3duLG14UmVzb3VyY2VzLmdldCgicGx1c1Rvb2x0aXAiKSk7dGhpcy5hcnJvd0xlZnQ9dGhpcy5jcmVhdGVBcnJvdyh0aGlzLnRyaWFuZ2xlTGVmdCxteFJlc291cmNlcy5nZXQoInBsdXNUb29sdGlwIikpO3RoaXMuZWx0cz1bdGhpcy5hcnJvd1VwLHRoaXMuYXJyb3dSaWdodCx0aGlzLmFycm93RG93bix0aGlzLmFycm93TGVmdF07dGhpcy5yZXNldEhhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlc2V0KCl9KTt0aGlzLnJlcGFpbnRIYW5kbGVyPQpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucmVwYWludCgpfSk7dGhpcy5ncmFwaC5zZWxlY3Rpb25Nb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLnJlc2V0SGFuZGxlcik7dGhpcy5ncmFwaC5tb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRV9BTkRfVFJBTlNMQVRFLHRoaXMucmVwYWludEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlRSQU5TTEFURSx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5TQ0FMRSx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5ET1dOLHRoaXMucmVwYWludEhhbmRsZXIpO3RoaXMuZ3JhcGgudmlldy5hZGRMaXN0ZW5lcihteEV2ZW50LlVQLHRoaXMucmVwYWludEhhbmRsZXIpOwp0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuUk9PVCx0aGlzLnJlcGFpbnRIYW5kbGVyKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLHRoaXMucmVzZXRIYW5kbGVyKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZ3JhcGguY29udGFpbmVyLCJzY3JvbGwiLHRoaXMucmVzZXRIYW5kbGVyKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRVNDQVBFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5tb3VzZURvd25Qb2ludD1udWxsfSkpO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5ncmFwaC5jb250YWluZXIsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWEucmVsYXRlZFRhcmdldCYmbXhFdmVudC5nZXRTb3VyY2UoYSk9PXRoaXMuZ3JhcGguY29udGFpbmVyJiZ0aGlzLnNldERpc3BsYXkoIm5vbmUiKX0pKTt0aGlzLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuU1RBUlRfRURJVElORywKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5yZXNldCgpfSkpO3ZhciBhPXRoaXMuZ3JhcGguY2xpY2s7dGhpcy5ncmFwaC5jbGljaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXthLmFwcGx5KHRoaXMuZ3JhcGgsYXJndW1lbnRzKTtudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8dGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZCh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKXx8IW14RXZlbnQuaXNUb3VjaEV2ZW50KGMuZ2V0RXZlbnQoKSl8fHRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYy5nZXRDZWxsKCkpfHx0aGlzLnJlc2V0KCl9KTt2YXIgYz0hMTt0aGlzLmdyYXBoLmFkZE1vdXNlTGlzdGVuZXIoe21vdXNlRG93bjpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe2M9ITE7dmFyIGY9ZC5nZXRFdmVudCgpO2lmKHRoaXMuaXNSZXNldEV2ZW50KGYpKXRoaXMucmVzZXQoKTtlbHNlIGlmKCF0aGlzLmlzQWN0aXZlKCkpe3ZhciBtPXRoaXMuZ2V0U3RhdGUoZC5nZXRTdGF0ZSgpKTsKbnVsbD09bSYmbXhFdmVudC5pc1RvdWNoRXZlbnQoZil8fHRoaXMudXBkYXRlKG0pfXRoaXMuc2V0RGlzcGxheSgibm9uZSIpfSksbW91c2VNb3ZlOm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZCl7dmFyIGY9ZC5nZXRFdmVudCgpO3RoaXMuaXNSZXNldEV2ZW50KGYpP3RoaXMucmVzZXQoKTp0aGlzLmdyYXBoLmlzTW91c2VEb3dufHxteEV2ZW50LmlzVG91Y2hFdmVudChmKXx8dGhpcy51cGRhdGUodGhpcy5nZXRTdGF0ZShkLmdldFN0YXRlKCkpLGQuZ2V0R3JhcGhYKCksZC5nZXRHcmFwaFkoKSk7bnVsbCE9dGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlciYmbnVsbCE9dGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5zaGFwZSYmKGM9ITApfSksbW91c2VVcDpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGQpe3ZhciBmPWQuZ2V0RXZlbnQoKTtteFV0aWxzLmNvbnZlcnRQb2ludCh0aGlzLmdyYXBoLmNvbnRhaW5lcixteEV2ZW50LmdldENsaWVudFgoZiksbXhFdmVudC5nZXRDbGllbnRZKGYpKTsKdGhpcy5pc1Jlc2V0RXZlbnQoZik/dGhpcy5yZXNldCgpOnRoaXMuaXNBY3RpdmUoKSYmIWMmJm51bGwhPXRoaXMubW91c2VEb3duUG9pbnQ/dGhpcy5jbGljayh0aGlzLmN1cnJlbnRTdGF0ZSx0aGlzLmdldERpcmVjdGlvbigpLGQpOnRoaXMuaXNBY3RpdmUoKT8xPT10aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCkmJnRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbCgpKT90aGlzLnJlc2V0KCk6dGhpcy51cGRhdGUodGhpcy5nZXRTdGF0ZSh0aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUodGhpcy5ncmFwaC5nZXRDZWxsQXQoZC5nZXRHcmFwaFgoKSxkLmdldEdyYXBoWSgpKSkpKTpteEV2ZW50LmlzVG91Y2hFdmVudChmKXx8bnVsbCE9dGhpcy5iYm94JiZteFV0aWxzLmNvbnRhaW5zKHRoaXMuYmJveCxkLmdldEdyYXBoWCgpLGQuZ2V0R3JhcGhZKCkpPyh0aGlzLnNldERpc3BsYXkoIiIpLHRoaXMucmVwYWludCgpKTpteEV2ZW50LmlzVG91Y2hFdmVudChmKXx8CnRoaXMucmVzZXQoKTtjPSExO3RoaXMucmVzZXRBY3RpdmVBcnJvdygpfSl9KX07SG92ZXJJY29ucy5wcm90b3R5cGUuaXNSZXNldEV2ZW50PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG14RXZlbnQuaXNBbHREb3duKGEpfHxudWxsPT10aGlzLmFjdGl2ZUFycm93JiZteEV2ZW50LmlzU2hpZnREb3duKGEpfHxteEV2ZW50LmlzTWV0YURvd24oYSl8fG14RXZlbnQuaXNQb3B1cFRyaWdnZXIoYSkmJiFteEV2ZW50LmlzQ29udHJvbERvd24oYSl9OwpIb3Zlckljb25zLnByb3RvdHlwZS5jcmVhdGVBcnJvdz1mdW5jdGlvbihhLGMpe3ZhciBmPW51bGw7bXhDbGllbnQuSVNfSUUmJiFteENsaWVudC5JU19TVkc/KG14Q2xpZW50LklTX0lFNiYmIkNTUzFDb21wYXQiIT1kb2N1bWVudC5jb21wYXRNb2RlPyhmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobXhDbGllbnQuVk1MX1BSRUZJWCsiOmltYWdlIiksZi5zZXRBdHRyaWJ1dGUoInNyYyIsYS5zcmMpLGYuc3R5bGUuYm9yZGVyU3R5bGU9Im5vbmUiKTooZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxmLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrYS5zcmMrIikiLGYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJjZW50ZXIiLGYuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IiksZi5zdHlsZS53aWR0aD1hLndpZHRoKzQrInB4IixmLnN0eWxlLmhlaWdodD1hLmhlaWdodCs0KyJweCIsZi5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoKImlubGluZS1ibG9jayIpOihmPW14VXRpbHMuY3JlYXRlSW1hZ2UoYS5zcmMpLGYuc3R5bGUud2lkdGg9YS53aWR0aCsicHgiLGYuc3R5bGUuaGVpZ2h0PWEuaGVpZ2h0KyJweCIsZi5zdHlsZS5wYWRkaW5nPXRoaXMudG9sZXJhbmNlKyJweCIpO251bGwhPWMmJmYuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYyk7Zi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Yuc3R5bGUuY3Vyc29yPXRoaXMuY3NzQ3Vyc29yO214RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhmLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGw9PXRoaXMuY3VycmVudFN0YXRlfHx0aGlzLmlzUmVzZXRFdmVudChhKXx8KHRoaXMubW91c2VEb3duUG9pbnQ9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5ncmFwaC5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSksdGhpcy5kcmFnKGEsdGhpcy5tb3VzZURvd25Qb2ludC54LHRoaXMubW91c2VEb3duUG9pbnQueSksCnRoaXMuYWN0aXZlQXJyb3c9Zix0aGlzLnNldERpc3BsYXkoIm5vbmUiKSxteEV2ZW50LmNvbnN1bWUoYSkpfSkpO214RXZlbnQucmVkaXJlY3RNb3VzZUV2ZW50cyhmLHRoaXMuZ3JhcGgsdGhpcy5jdXJyZW50U3RhdGUpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwibW91c2VlbnRlciIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5pc01vdXNlRXZlbnQoYSkmJihudWxsIT10aGlzLmFjdGl2ZUFycm93JiZ0aGlzLmFjdGl2ZUFycm93IT1mJiZteFV0aWxzLnNldE9wYWNpdHkodGhpcy5hY3RpdmVBcnJvdyx0aGlzLmluYWN0aXZlT3BhY2l0eSksdGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpLG14VXRpbHMuc2V0T3BhY2l0eShmLDEwMCksdGhpcy5hY3RpdmVBcnJvdz1mKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZ3JhcGguaXNNb3VzZURvd258fAp0aGlzLnJlc2V0QWN0aXZlQXJyb3coKX0pKTtyZXR1cm4gZn07SG92ZXJJY29ucy5wcm90b3R5cGUucmVzZXRBY3RpdmVBcnJvdz1mdW5jdGlvbigpe251bGwhPXRoaXMuYWN0aXZlQXJyb3cmJihteFV0aWxzLnNldE9wYWNpdHkodGhpcy5hY3RpdmVBcnJvdyx0aGlzLmluYWN0aXZlT3BhY2l0eSksdGhpcy5hY3RpdmVBcnJvdz1udWxsKX07SG92ZXJJY29ucy5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q7dGhpcy5hY3RpdmVBcnJvdz09dGhpcy5hcnJvd1VwP2E9bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIOnRoaXMuYWN0aXZlQXJyb3c9PXRoaXMuYXJyb3dEb3duP2E9bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIOnRoaXMuYWN0aXZlQXJyb3c9PXRoaXMuYXJyb3dMZWZ0JiYoYT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCk7cmV0dXJuIGF9OwpIb3Zlckljb25zLnByb3RvdHlwZS52aXNpdE5vZGVzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz0wO2M8dGhpcy5lbHRzLmxlbmd0aDtjKyspbnVsbCE9dGhpcy5lbHRzW2NdJiZhKHRoaXMuZWx0c1tjXSl9O0hvdmVySWNvbnMucHJvdG90eXBlLnJlbW92ZU5vZGVzPWZ1bmN0aW9uKCl7dGhpcy52aXNpdE5vZGVzKGZ1bmN0aW9uKGEpe251bGwhPWEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfSl9O0hvdmVySWNvbnMucHJvdG90eXBlLnNldERpc3BsYXk9ZnVuY3Rpb24oYSl7dGhpcy52aXNpdE5vZGVzKGZ1bmN0aW9uKGMpe2Muc3R5bGUuZGlzcGxheT1hfSl9O0hvdmVySWNvbnMucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuYWN0aXZlQXJyb3cmJm51bGwhPXRoaXMuY3VycmVudFN0YXRlfTsKSG92ZXJJY29ucy5wcm90b3R5cGUuZHJhZz1mdW5jdGlvbihhLGMsZil7dGhpcy5ncmFwaC5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCk7dGhpcy5ncmFwaC5zdG9wRWRpdGluZyghMSk7bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJih0aGlzLmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLnN0YXJ0KHRoaXMuY3VycmVudFN0YXRlLGMsZiksdGhpcy5ncmFwaC5pc01vdXNlVHJpZ2dlcj1teEV2ZW50LmlzTW91c2VFdmVudChhKSx0aGlzLmdyYXBoLmlzTW91c2VEb3duPSEwLGM9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcih0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSxudWxsIT1jJiZjLnNldEhhbmRsZXNWaXNpYmxlKCExKSxjPXRoaXMuZ3JhcGguY29ubmVjdGlvbkhhbmRsZXIuZWRnZVN0YXRlLG51bGwhPWEmJm14RXZlbnQuaXNTaGlmdERvd24oYSkmJm14RXZlbnQuaXNDb250cm9sRG93bihhKSYmbnVsbCE9YyYmIm9ydGhvZ29uYWxFZGdlU3R5bGUiPT09Cm14VXRpbHMuZ2V0VmFsdWUoYy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FREdFLG51bGwpJiYoYT10aGlzLmdldERpcmVjdGlvbigpLGMuY2VsbC5zdHlsZT1teFV0aWxzLnNldFN0eWxlKGMuY2VsbC5zdHlsZSwic291cmNlUG9ydENvbnN0cmFpbnQiLGEpLGMuc3R5bGUuc291cmNlUG9ydENvbnN0cmFpbnQ9YSkpfTtIb3Zlckljb25zLnByb3RvdHlwZS5nZXRTdGF0ZUF0PWZ1bmN0aW9uKGEsYyxmKXtyZXR1cm4gdGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZ3JhcGguZ2V0Q2VsbEF0KGMsZikpfTsKSG92ZXJJY29ucy5wcm90b3R5cGUuY2xpY2s9ZnVuY3Rpb24oYSxjLGYpe3ZhciBkPWYuZ2V0RXZlbnQoKSxrPWYuZ2V0R3JhcGhYKCksbT1mLmdldEdyYXBoWSgpLGs9dGhpcy5nZXRTdGF0ZUF0KGEsayxtKTtudWxsPT1rfHwhdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2Uoay5jZWxsKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGQpfHxrLmdldFZpc2libGVUZXJtaW5hbFN0YXRlKCEwKSE9YSYmay5nZXRWaXNpYmxlVGVybWluYWxTdGF0ZSghMSkhPWE/bnVsbCE9YSYmdGhpcy5ncmFwaC5zZWxlY3RDZWxsc0ZvckNvbm5lY3RWZXJ0ZXgodGhpcy5ncmFwaC5jb25uZWN0VmVydGV4KGEuY2VsbCxjLHRoaXMuZ3JhcGguZGVmYXVsdEVkZ2VMZW5ndGgsZCksZCx0aGlzKToodGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKGsuY2VsbCksdGhpcy5yZXNldCgpKTtmLmNvbnN1bWUoKX07CkhvdmVySWNvbnMucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKGEpe251bGwhPWEmJiFhfHxudWxsPT10aGlzLnVwZGF0ZVRocmVhZHx8d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnVwZGF0ZVRocmVhZCk7dGhpcy5hY3RpdmVBcnJvdz10aGlzLmN1cnJlbnRTdGF0ZT10aGlzLm1vdXNlRG93blBvaW50PW51bGw7dGhpcy5yZW1vdmVOb2RlcygpO3RoaXMuYmJveD1udWxsfTsKSG92ZXJJY29ucy5wcm90b3R5cGUucmVwYWludD1mdW5jdGlvbigpe3RoaXMuYmJveD1udWxsO2lmKG51bGwhPXRoaXMuY3VycmVudFN0YXRlKXt0aGlzLmN1cnJlbnRTdGF0ZT10aGlzLmdldFN0YXRlKHRoaXMuY3VycmVudFN0YXRlKTtpZihudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmdGhpcy5ncmFwaC5tb2RlbC5pc1ZlcnRleCh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSYmdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZSh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSl7dmFyIGE9bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZSh0aGlzLmN1cnJlbnRTdGF0ZSk7bnVsbCE9dGhpcy5jdXJyZW50U3RhdGUuc2hhcGUmJm51bGwhPXRoaXMuY3VycmVudFN0YXRlLnNoYXBlLmJvdW5kaW5nQm94JiYoYT1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKHRoaXMuY3VycmVudFN0YXRlLnNoYXBlLmJvdW5kaW5nQm94KSk7YS5ncm93KHRoaXMuZ3JhcGgudG9sZXJhbmNlKTthLmdyb3codGhpcy5hcnJvd1NwYWNpbmcpOwp2YXIgYz10aGlzLmdyYXBoLnNlbGVjdGlvbkNlbGxzSGFuZGxlci5nZXRIYW5kbGVyKHRoaXMuY3VycmVudFN0YXRlLmNlbGwpO3RoaXMuZ3JhcGguaXNUYWJsZVJvdyh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSYmKGM9dGhpcy5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcih0aGlzLmdyYXBoLm1vZGVsLmdldFBhcmVudCh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKSkpO3ZhciBmPW51bGw7bnVsbCE9YyYmKGEueC09Yy5ob3Jpem9udGFsT2Zmc2V0LzIsYS55LT1jLnZlcnRpY2FsT2Zmc2V0LzIsYS53aWR0aCs9Yy5ob3Jpem9udGFsT2Zmc2V0LGEuaGVpZ2h0Kz1jLnZlcnRpY2FsT2Zmc2V0LG51bGwhPWMucm90YXRpb25TaGFwZSYmbnVsbCE9Yy5yb3RhdGlvblNoYXBlLm5vZGUmJiJoaWRkZW4iIT1jLnJvdGF0aW9uU2hhcGUubm9kZS5zdHlsZS52aXNpYmlsaXR5JiYibm9uZSIhPWMucm90YXRpb25TaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXkmJm51bGwhPWMucm90YXRpb25TaGFwZS5ib3VuZGluZ0JveCYmCihmPWMucm90YXRpb25TaGFwZS5ib3VuZGluZ0JveCkpO2M9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxlLGMpe2lmKG51bGwhPWYpe3ZhciBiPW5ldyBteFJlY3RhbmdsZShlLGMsYS5jbGllbnRXaWR0aCxhLmNsaWVudEhlaWdodCk7bXhVdGlscy5pbnRlcnNlY3RzKGIsZikmJihhPT10aGlzLmFycm93VXA/Yy09Yi55K2IuaGVpZ2h0LWYueTphPT10aGlzLmFycm93UmlnaHQ/ZSs9Zi54K2Yud2lkdGgtYi54OmE9PXRoaXMuYXJyb3dEb3duP2MrPWYueStmLmhlaWdodC1iLnk6YT09dGhpcy5hcnJvd0xlZnQmJihlLT1iLngrYi53aWR0aC1mLngpKX1hLnN0eWxlLmxlZnQ9ZSsicHgiO2Euc3R5bGUudG9wPWMrInB4IjtteFV0aWxzLnNldE9wYWNpdHkoYSx0aGlzLmluYWN0aXZlT3BhY2l0eSl9KTtjKHRoaXMuYXJyb3dVcCxNYXRoLnJvdW5kKHRoaXMuY3VycmVudFN0YXRlLmdldENlbnRlclgoKS10aGlzLnRyaWFuZ2xlVXAud2lkdGgvMi10aGlzLnRvbGVyYW5jZSksTWF0aC5yb3VuZChhLnktCnRoaXMudHJpYW5nbGVVcC5oZWlnaHQtdGhpcy50b2xlcmFuY2UpKTtjKHRoaXMuYXJyb3dSaWdodCxNYXRoLnJvdW5kKGEueCthLndpZHRoLXRoaXMudG9sZXJhbmNlKSxNYXRoLnJvdW5kKHRoaXMuY3VycmVudFN0YXRlLmdldENlbnRlclkoKS10aGlzLnRyaWFuZ2xlUmlnaHQuaGVpZ2h0LzItdGhpcy50b2xlcmFuY2UpKTtjKHRoaXMuYXJyb3dEb3duLHBhcnNlSW50KHRoaXMuYXJyb3dVcC5zdHlsZS5sZWZ0KSxNYXRoLnJvdW5kKGEueSthLmhlaWdodC10aGlzLnRvbGVyYW5jZSkpO2ModGhpcy5hcnJvd0xlZnQsTWF0aC5yb3VuZChhLngtdGhpcy50cmlhbmdsZUxlZnQud2lkdGgtdGhpcy50b2xlcmFuY2UpLHBhcnNlSW50KHRoaXMuYXJyb3dSaWdodC5zdHlsZS50b3ApKTtpZih0aGlzLmNoZWNrQ29sbGlzaW9ucyl7dmFyIGM9dGhpcy5ncmFwaC5nZXRDZWxsQXQoYS54K2Eud2lkdGgrdGhpcy50cmlhbmdsZVJpZ2h0LndpZHRoLzIsdGhpcy5jdXJyZW50U3RhdGUuZ2V0Q2VudGVyWSgpKSwKZD10aGlzLmdyYXBoLmdldENlbGxBdChhLngtdGhpcy50cmlhbmdsZUxlZnQud2lkdGgvMix0aGlzLmN1cnJlbnRTdGF0ZS5nZXRDZW50ZXJZKCkpLGs9dGhpcy5ncmFwaC5nZXRDZWxsQXQodGhpcy5jdXJyZW50U3RhdGUuZ2V0Q2VudGVyWCgpLGEueS10aGlzLnRyaWFuZ2xlVXAuaGVpZ2h0LzIpLGE9dGhpcy5ncmFwaC5nZXRDZWxsQXQodGhpcy5jdXJyZW50U3RhdGUuZ2V0Q2VudGVyWCgpLGEueSthLmhlaWdodCt0aGlzLnRyaWFuZ2xlRG93bi5oZWlnaHQvMik7bnVsbCE9YyYmYz09ZCYmZD09ayYmaz09YSYmKGE9az1kPWM9bnVsbCk7dmFyIG09dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkodGhpcy5jdXJyZW50U3RhdGUuY2VsbCkscT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGUpe3ZhciBiPXRoaXMuZ3JhcGgubW9kZWwuaXNWZXJ0ZXgoYSkmJnRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEpO251bGw9PWF8fHRoaXMuZ3JhcGgubW9kZWwuaXNBbmNlc3RvcihhLAp0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKXx8dGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEpfHwhKG51bGw9PWJ8fG51bGw9PW18fGIuaGVpZ2h0PDMqbS5oZWlnaHQmJmIud2lkdGg8MyptLndpZHRoKT9lLnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiOmUuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIn0pO3EoYyx0aGlzLmFycm93UmlnaHQpO3EoZCx0aGlzLmFycm93TGVmdCk7cShrLHRoaXMuYXJyb3dVcCk7cShhLHRoaXMuYXJyb3dEb3duKX1lbHNlIHRoaXMuYXJyb3dMZWZ0LnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiLHRoaXMuYXJyb3dSaWdodC5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIix0aGlzLmFycm93VXAuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSIsdGhpcy5hcnJvd0Rvd24uc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSI7dGhpcy5ncmFwaC50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKT8odGhpcy5hcnJvd0xlZnQuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKSwKdGhpcy5hcnJvd1JpZ2h0LnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicGx1c1Rvb2x0aXAiKSksdGhpcy5hcnJvd1VwLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicGx1c1Rvb2x0aXAiKSksdGhpcy5hcnJvd0Rvd24uc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJwbHVzVG9vbHRpcCIpKSk6KHRoaXMuYXJyb3dMZWZ0LnJlbW92ZUF0dHJpYnV0ZSgidGl0bGUiKSx0aGlzLmFycm93UmlnaHQucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpLHRoaXMuYXJyb3dVcC5yZW1vdmVBdHRyaWJ1dGUoInRpdGxlIiksdGhpcy5hcnJvd0Rvd24ucmVtb3ZlQXR0cmlidXRlKCJ0aXRsZSIpKX1lbHNlIHRoaXMucmVzZXQoKTtudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmKHRoaXMuYmJveD10aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLG51bGwhPXRoaXMuYmJveCYmdGhpcy5iYm94Lmdyb3coMTApKX19OwpIb3Zlckljb25zLnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdCb3g9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLm1vZGVsLmlzRWRnZSh0aGlzLmN1cnJlbnRTdGF0ZS5jZWxsKT9udWxsOm14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUodGhpcy5jdXJyZW50U3RhdGUpO3RoaXMudmlzaXROb2RlcyhmdW5jdGlvbihjKXtudWxsIT1jLnBhcmVudE5vZGUmJihjPW5ldyBteFJlY3RhbmdsZShjLm9mZnNldExlZnQsYy5vZmZzZXRUb3AsYy5vZmZzZXRXaWR0aCxjLm9mZnNldEhlaWdodCksbnVsbD09YT9hPWM6YS5hZGQoYykpfSk7cmV0dXJuIGF9OwpIb3Zlckljb25zLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhKXtpZihudWxsIT1hKWlmKGE9YS5jZWxsLHRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5jb250YWlucyhhKSl7aWYodGhpcy5ncmFwaC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYhdGhpcy5ncmFwaC5pc0NlbGxDb25uZWN0YWJsZShhKSl7dmFyIGM9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmdldFBhcmVudChhKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYykmJnRoaXMuZ3JhcGguaXNDZWxsQ29ubmVjdGFibGUoYykmJihhPWMpfWlmKHRoaXMuZ3JhcGguaXNDZWxsTG9ja2VkKGEpfHx0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZShhKSlhPW51bGw7YT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYSk7bnVsbCE9YSYmbnVsbD09YS5zdHlsZSYmKGE9bnVsbCl9ZWxzZSBhPW51bGw7cmV0dXJuIGF9OwpIb3Zlckljb25zLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxjLGYpe2lmKCF0aGlzLmdyYXBoLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkfHxudWxsIT1hJiYiMCI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwiYWxsb3dBcnJvd3MiLCIxIikpdGhpcy5yZXNldCgpO2Vsc2V7bnVsbCE9YSYmbnVsbCE9YS5jZWxsLmdlb21ldHJ5JiZhLmNlbGwuZ2VvbWV0cnkucmVsYXRpdmUmJnRoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGEuY2VsbC5wYXJlbnQpJiYoYT1udWxsKTt2YXIgZD1udWxsO3RoaXMucHJldiE9YXx8dGhpcy5pc0FjdGl2ZSgpPyh0aGlzLnN0YXJ0VGltZT0obmV3IERhdGUpLmdldFRpbWUoKSx0aGlzLnByZXY9YSxkPTAsbnVsbCE9dGhpcy51cGRhdGVUaHJlYWQmJndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy51cGRhdGVUaHJlYWQpLG51bGwhPWEmJih0aGlzLnVwZGF0ZVRocmVhZD13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaXNBY3RpdmUoKXx8CnRoaXMuZ3JhcGguaXNNb3VzZURvd258fHRoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIuaXNBY3RpdmUoKXx8KHRoaXMucHJldj1hLHRoaXMudXBkYXRlKGEsYyxmKSl9KSx0aGlzLnVwZGF0ZURlbGF5KzEwKSkpOm51bGwhPXRoaXMuc3RhcnRUaW1lJiYoZD0obmV3IERhdGUpLmdldFRpbWUoKS10aGlzLnN0YXJ0VGltZSk7dGhpcy5zZXREaXNwbGF5KCIiKTtudWxsIT10aGlzLmN1cnJlbnRTdGF0ZSYmdGhpcy5jdXJyZW50U3RhdGUhPWEmJmQ8dGhpcy5hY3RpdmF0aW9uRGVsYXkmJm51bGwhPXRoaXMuYmJveCYmIW14VXRpbHMuY29udGFpbnModGhpcy5iYm94LGMsZik/dGhpcy5yZXNldCghMSk6KG51bGwhPXRoaXMuY3VycmVudFN0YXRlfHxkPnRoaXMuYWN0aXZhdGlvbkRlbGF5KSYmdGhpcy5jdXJyZW50U3RhdGUhPWEmJihkPnRoaXMudXBkYXRlRGVsYXkmJm51bGwhPWF8fG51bGw9PXRoaXMuYmJveHx8bnVsbD09Y3x8bnVsbD09Znx8IW14VXRpbHMuY29udGFpbnModGhpcy5iYm94LApjLGYpKSYmKG51bGwhPWEmJnRoaXMuZ3JhcGguaXNFbmFibGVkKCk/KHRoaXMucmVtb3ZlTm9kZXMoKSx0aGlzLnNldEN1cnJlbnRTdGF0ZShhKSx0aGlzLnJlcGFpbnQoKSx0aGlzLmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cyE9YSYmdGhpcy5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5jb25zdHJhaW50SGFuZGxlci5yZXNldCgpKTp0aGlzLnJlc2V0KCkpfX07CkhvdmVySWNvbnMucHJvdG90eXBlLnNldEN1cnJlbnRTdGF0ZT1mdW5jdGlvbihhKXsiZWFzdHdlc3QiIT1hLnN0eWxlLnBvcnRDb25zdHJhaW50JiYodGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd1VwKSx0aGlzLmdyYXBoLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmFycm93RG93bikpO3RoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuYXJyb3dSaWdodCk7dGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0xlZnQpO3RoaXMuY3VycmVudFN0YXRlPWF9O0dyYXBoLnByb3RvdHlwZS5jcmVhdGVQYXJlbnQ9ZnVuY3Rpb24oYSxjLGYsZCxrKXthPXRoaXMuY2xvbmVDZWxsKGEpO2Zvcih2YXIgbT0wO208ZjttKyspe3ZhciBxPXRoaXMuY2xvbmVDZWxsKGMpLGI9dGhpcy5nZXRDZWxsR2VvbWV0cnkocSk7bnVsbCE9YiYmKGIueCs9bSpkLGIueSs9bSprKTthLmluc2VydChxKX1yZXR1cm4gYX07CkdyYXBoLnByb3RvdHlwZS5jcmVhdGVUYWJsZT1mdW5jdGlvbihhLGMsZixkLGssbSl7Zj1udWxsIT1mP2Y6NjA7ZD1udWxsIT1kP2Q6NDA7bT1udWxsIT1tP206MzA7cmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50KHRoaXMuY3JlYXRlVmVydGV4KG51bGwsbnVsbCxudWxsIT1rP2s6IiIsMCwwLGMqZixhKmQrKG51bGwhPWs/bTowKSwobnVsbCE9az8ic3dpbWxhbmU7c3RhcnRTaXplPSIrbSsiOyI6IiIpKyJodG1sPTE7d2hpdGVTcGFjZT13cmFwO2NvbnRhaW5lcj0xO2NvbGxhcHNpYmxlPTA7Y2hpbGRMYXlvdXQ9dGFibGVMYXlvdXQ7IiksdGhpcy5jcmVhdGVQYXJlbnQodGhpcy5jcmVhdGVWZXJ0ZXgobnVsbCxudWxsLCIiLDAsMCxjKmYsZCwiaHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb2xsYXBzaWJsZT0wO2Ryb3BUYXJnZXQ9MDtwb2ludGVyRXZlbnRzPTA7ZmlsbENvbG9yPW5vbmU7c3Ryb2tlQ29sb3I9bm9uZTtwb2ludHM9W1swLDAuNV0sWzEsMC41XV07cG9ydENvbnN0cmFpbnQ9ZWFzdHdlc3Q7IiksCnRoaXMuY3JlYXRlVmVydGV4KG51bGwsbnVsbCwiIiwwLDAsZixkLCJzaGFwZT1wYXJ0aWFsUmVjdGFuZ2xlO2h0bWw9MTt3aGl0ZVNwYWNlPXdyYXA7Y29ubmVjdGFibGU9MDtmaWxsQ29sb3I9bm9uZTsiKSxjLGYsMCksYSwwLGQpfTsKR3JhcGgucHJvdG90eXBlLmNyZWF0ZUNyb3NzRnVuY3Rpb25hbFN3aW1sYW5lPWZ1bmN0aW9uKGEsYyxmLGQsayl7Zj1udWxsIT1mP2Y6MTIwO2Q9bnVsbCE9ZD9kOjEyMDtrPW51bGwhPWs/azo0MDt2YXIgbT10aGlzLmNyZWF0ZVZlcnRleChudWxsLG51bGwsIiIsMCwwLGMqZixhKmQsInN3aW1sYW5lO2h0bWw9MTt3aGl0ZVNwYWNlPXdyYXA7Y29sbGFwc2libGU9MDtyZWN1cnNpdmVSZXNpemU9MDtleHBhbmQ9MDtwb2ludGVyRXZlbnRzPTA7Y2hpbGRMYXlvdXQ9dGFibGVMYXlvdXQ7c3RhcnRTaXplPSIraysiOyIpLHE9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLmdldENlbGxTdHlsZShtKSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9TVEFSVFNJWkUpO20uZ2VvbWV0cnkud2lkdGgrPXE7bS5nZW9tZXRyeS5oZWlnaHQrPXE7az10aGlzLmNyZWF0ZVZlcnRleChudWxsLG51bGwsIiIsMCxxLGMqZitxLGQsInN3aW1sYW5lO2h0bWw9MTt3aGl0ZVNwYWNlPXdyYXA7Y29sbGFwc2libGU9MDtyZWN1cnNpdmVSZXNpemU9MDtleHBhbmQ9MDtwb2ludGVyRXZlbnRzPTA7aG9yaXpvbnRhbD0wO3BvaW50cz1bWzAsMC41XSxbMSwwLjVdXTtwb3J0Q29uc3RyYWludD1lYXN0d2VzdDtzdGFydFNpemU9IisKaysiOyIpO20uaW5zZXJ0KHRoaXMuY3JlYXRlUGFyZW50KGssdGhpcy5jcmVhdGVWZXJ0ZXgobnVsbCxudWxsLCIiLHEsMCxmLGQsInN3aW1sYW5lO2h0bWw9MTt3aGl0ZVNwYWNlPXdyYXA7Y29sbGFwc2libGU9MDtyZWN1cnNpdmVSZXNpemU9MDtleHBhbmQ9MDtwb2ludGVyRXZlbnRzPTA7Y29ubmVjdGFibGU9MDtzdGFydFNpemU9NDA7IiksYyxmLDApKTtyZXR1cm4gMTxhPyhrLmdlb21ldHJ5Lnk9ZCtxLHRoaXMuY3JlYXRlUGFyZW50KG0sdGhpcy5jcmVhdGVQYXJlbnQoayx0aGlzLmNyZWF0ZVZlcnRleChudWxsLG51bGwsIiIscSwwLGYsZCwic3dpbWxhbmU7aHRtbD0xO3doaXRlU3BhY2U9d3JhcDtjb2xsYXBzaWJsZT0wO3JlY3Vyc2l2ZVJlc2l6ZT0wO2V4cGFuZD0wO3BvaW50ZXJFdmVudHM9MDtjb25uZWN0YWJsZT0wO3N0YXJ0U2l6ZT0wOyIpLGMsZiwwKSxhLTEsMCxkKSk6bX07CkdyYXBoLnByb3RvdHlwZS5pc1RhYmxlQ2VsbD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tb2RlbC5pc1ZlcnRleChhKSYmdGhpcy5pc1RhYmxlUm93KHRoaXMubW9kZWwuZ2V0UGFyZW50KGEpKX07R3JhcGgucHJvdG90eXBlLmlzVGFibGVSb3c9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubW9kZWwuaXNWZXJ0ZXgoYSkmJnRoaXMuaXNUYWJsZSh0aGlzLm1vZGVsLmdldFBhcmVudChhKSl9O0dyYXBoLnByb3RvdHlwZS5pc1RhYmxlPWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRDZWxsU3R5bGUoYSk7cmV0dXJuIG51bGwhPWEmJiJ0YWJsZUxheW91dCI9PWEuY2hpbGRMYXlvdXR9OwpHcmFwaC5wcm90b3R5cGUuc2V0VGFibGVSb3dIZWlnaHQ9ZnVuY3Rpb24oYSxjKXt2YXIgZj10aGlzLmdldE1vZGVsKCk7Zi5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD10aGlzLmdldENlbGxHZW9tZXRyeShhKTtpZihudWxsIT1kKXtkPWQuY2xvbmUoKTtkLmhlaWdodCs9YztmLnNldEdlb21ldHJ5KGEsZCk7dmFyIGs9Zi5nZXRQYXJlbnQoYSksbT10aGlzLmdldENlbGxHZW9tZXRyeShrKTtudWxsIT1tJiYobT1tLmNsb25lKCksbS5oZWlnaHQrPWMsZi5zZXRHZW9tZXRyeShrLG0pKX19ZmluYWxseXtmLmVuZFVwZGF0ZSgpfX07CkdyYXBoLnByb3RvdHlwZS5zZXRUYWJsZUNvbHVtbldpZHRoPWZ1bmN0aW9uKGEsYyl7dmFyIGY9dGhpcy5nZXRNb2RlbCgpLGQ9Zi5nZXRQYXJlbnQoYSksaz1mLmdldFBhcmVudChkKSxtPWYuZ2V0Q2hpbGRDZWxscyhkLCEwKSxxPW14VXRpbHMuaW5kZXhPZihtLGEpLGI9cT09bS5sZW5ndGgtMTtmLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZT1mLmdldENoaWxkQ2VsbHMoaywhMCksZz0wO2c8ZS5sZW5ndGg7ZysrKXt2YXIgZD1lW2ddLG09Zi5nZXRDaGlsZENlbGxzKGQsITApLG49bVtxXSxsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KG4pO251bGwhPWwmJihsPWwuY2xvbmUoKSxsLndpZHRoKz1jLGYuc2V0R2VvbWV0cnkobixsKSk7cTxtLmxlbmd0aC0xJiYobj1tW3ErMV0sbD10aGlzLmdldENlbGxHZW9tZXRyeShuKSxudWxsIT1sJiYobD1sLmNsb25lKCksbC54Kz1jLGwud2lkdGgtPWMsZi5zZXRHZW9tZXRyeShuLGwpKSl9aWYoYil7dmFyIHA9dGhpcy5nZXRDZWxsR2VvbWV0cnkoayk7Cm51bGwhPXAmJihwPXAuY2xvbmUoKSxwLndpZHRoKz1jLGYuc2V0R2VvbWV0cnkoayxwKSl9fWZpbmFsbHl7Zi5lbmRVcGRhdGUoKX19O2Z1bmN0aW9uIFRhYmxlTGF5b3V0KGEpe214R3JhcGhMYXlvdXQuY2FsbCh0aGlzLGEpfVRhYmxlTGF5b3V0LnByb3RvdHlwZT1uZXcgbXhTdGFja0xheW91dDtUYWJsZUxheW91dC5wcm90b3R5cGUuY29uc3RydWN0b3I9VGFibGVMYXlvdXQ7VGFibGVMYXlvdXQucHJvdG90eXBlLmlzSG9yaXpvbnRhbD1mdW5jdGlvbigpe3JldHVybiExfTtUYWJsZUxheW91dC5wcm90b3R5cGUuZ2V0U2l6ZT1mdW5jdGlvbihhLGMpe2Zvcih2YXIgZj0wLGQ9MDtkPGEubGVuZ3RoO2QrKylpZighdGhpcy5pc1ZlcnRleElnbm9yZWQoYVtkXSkpe3ZhciBrPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGFbZF0pO251bGwhPWsmJihmKz1jP2sud2lkdGg6ay5oZWlnaHQpfXJldHVybiBmfTsKVGFibGVMYXlvdXQucHJvdG90eXBlLmdldFJvd0xheW91dD1mdW5jdGlvbihhLGMpe2Zvcih2YXIgZj10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ2VsbHMoYSwhMCksZD10aGlzLmdyYXBoLmdldEFjdHVhbFN0YXJ0U2l6ZShhLCEwKSxrPXRoaXMuZ2V0U2l6ZShmLCEwKSxtPWMtZC54LWQud2lkdGgscT1bXSxkPWQueCxiPTA7YjxmLmxlbmd0aDtiKyspe3ZhciBlPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGZbYl0pO251bGwhPWUmJihkKz1lLndpZHRoKm0vayxxLnB1c2goTWF0aC5yb3VuZChkKSkpfXJldHVybiBxfTsKVGFibGVMYXlvdXQucHJvdG90eXBlLmxheW91dFJvdz1mdW5jdGlvbihhLGMsZil7dmFyIGQ9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGs9ZC5nZXRDaGlsZENlbGxzKGEsITApLG09dGhpcy5ncmFwaC5nZXRBY3R1YWxTdGFydFNpemUoYSwhMCkscT0wO251bGwhPWMmJihjPWMuc2xpY2UoKSxjLnNwbGljZSgwLDAsbS54KSk7Zm9yKHZhciBiPTA7YjxrLmxlbmd0aDtiKyspe3ZhciBlPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGtbYl0pO2lmKG51bGwhPWUpe2U9ZS5jbG9uZSgpO2UueT0wO2UuaGVpZ2h0PWY7aWYobnVsbCE9YyllLng9Y1tiXSxlLndpZHRoPWNbYisxXS1lLng7ZWxzZSBpZihiPT1rLmxlbmd0aC0xKXt2YXIgZz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKTtudWxsIT1nJiYoZS53aWR0aD1nLndpZHRoLW0ueC1tLndpZHRoLXEpfWVsc2UgcSs9ZS53aWR0aDtkLnNldEdlb21ldHJ5KGtbYl0sZSl9fX07ClRhYmxlTGF5b3V0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBjPXRoaXMuZ3JhcGguZ2V0QWN0dWFsU3RhcnRTaXplKGEsITApLGY9dGhpcy5ncmFwaC5nZXRDZWxsR2VvbWV0cnkoYSksZD10aGlzLmdyYXBoLmdldENlbGxTdHlsZShhKSxrPSIxIj09bXhVdGlscy5nZXRWYWx1ZShkLCJyZXNpemVMYXN0Um93IiwiMCIpLG09IjEiPT1teFV0aWxzLmdldFZhbHVlKGQsInJlc2l6ZUxhc3QiLCIwIiksZD10aGlzLmdyYXBoLmdldE1vZGVsKCk7ZC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgcT1mLmhlaWdodC1jLnktYy5oZWlnaHQsYj1mLndpZHRoLWMueC1jLndpZHRoLGU9ZC5nZXRDaGlsZENlbGxzKGEsITApLGc9dGhpcy5nZXRTaXplKGUsITEpO2lmKDA8cSYmMDxiJiYwPGUubGVuZ3RoJiYwPGcpe2lmKGspe3ZhciBuPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGVbZS5sZW5ndGgtMV0pO251bGwhPW4mJihuPW4uY2xvbmUoKSxuLmhlaWdodD0KcS1nK24uaGVpZ2h0LGQuc2V0R2VvbWV0cnkoZVtlLmxlbmd0aC0xXSxuKSl9dmFyIGw9bT9udWxsOnRoaXMuZ2V0Um93TGF5b3V0KGVbMF0sYikscD1jLnk7Zm9yKGE9MDthPGUubGVuZ3RoO2ErKyluPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGVbYV0pLG51bGwhPW4mJihuPW4uY2xvbmUoKSxuLng9Yy54LG4ud2lkdGg9YixuLnk9TWF0aC5yb3VuZChwKSxwPWs/cCtuLmhlaWdodDpwK24uaGVpZ2h0L2cqcSxuLmhlaWdodD1NYXRoLnJvdW5kKHApLW4ueSxkLnNldEdlb21ldHJ5KGVbYV0sbikpLHRoaXMubGF5b3V0Um93KGVbYV0sbCxuLmhlaWdodCl9fWZpbmFsbHl7ZC5lbmRVcGRhdGUoKX19fTsKKGZ1bmN0aW9uKCl7dmFyIGE9bXhHcmFwaFZpZXcucHJvdG90eXBlLnJlc2V0VmFsaWRhdGlvblN0YXRlO214R3JhcGhWaWV3LnByb3RvdHlwZS5yZXNldFZhbGlkYXRpb25TdGF0ZT1mdW5jdGlvbigpe2EuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMudmFsaWRFZGdlcz1bXX07dmFyIGM9bXhHcmFwaFZpZXcucHJvdG90eXBlLnZhbGlkYXRlQ2VsbFN0YXRlO214R3JhcGhWaWV3LnByb3RvdHlwZS52YWxpZGF0ZUNlbGxTdGF0ZT1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj9iOiEwO3ZhciBlPXRoaXMuZ2V0U3RhdGUoYSk7bnVsbCE9ZSYmYiYmdGhpcy5ncmFwaC5tb2RlbC5pc0VkZ2UoZS5jZWxsKSYmbnVsbCE9ZS5zdHlsZSYmMSE9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9DVVJWRURdJiYhZS5pbnZhbGlkJiZ0aGlzLnVwZGF0ZUxpbmVKdW1wcyhlKSYmdGhpcy5ncmFwaC5jZWxsUmVuZGVyZXIucmVkcmF3KGUsITEsdGhpcy5pc1JlbmRlcmluZygpKTtlPWMuYXBwbHkodGhpcywKYXJndW1lbnRzKTtudWxsIT1lJiZiJiZ0aGlzLmdyYXBoLm1vZGVsLmlzRWRnZShlLmNlbGwpJiZudWxsIT1lLnN0eWxlJiYxIT1lLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0NVUlZFRF0mJnRoaXMudmFsaWRFZGdlcy5wdXNoKGUpO3JldHVybiBlfTt2YXIgZj1teENlbGxSZW5kZXJlci5wcm90b3R5cGUuaXNTaGFwZUludmFsaWQ7bXhDZWxsUmVuZGVyZXIucHJvdG90eXBlLmlzU2hhcGVJbnZhbGlkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGYuYXBwbHkodGhpcyxhcmd1bWVudHMpfHxudWxsIT1hLnJvdXRlZFBvaW50cyYmbnVsbCE9Yi5yb3V0ZWRQb2ludHMmJiFteFV0aWxzLmVxdWFsUG9pbnRzKGIucm91dGVkUG9pbnRzLGEucm91dGVkUG9pbnRzKX07dmFyIGQ9bXhHcmFwaFZpZXcucHJvdG90eXBlLnVwZGF0ZUNlbGxTdGF0ZTtteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlQ2VsbFN0YXRlPWZ1bmN0aW9uKGEpe2QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZ3JhcGgubW9kZWwuaXNFZGdlKGEuY2VsbCkmJgoxIT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0NVUlZFRF0mJnRoaXMudXBkYXRlTGluZUp1bXBzKGEpfTtteEdyYXBoVmlldy5wcm90b3R5cGUudXBkYXRlTGluZUp1bXBzPWZ1bmN0aW9uKGEpe3ZhciBiPWEuYWJzb2x1dGVQb2ludHM7aWYoR3JhcGgubGluZUp1bXBzRW5hYmxlZCl7dmFyIGU9bnVsbCE9YS5yb3V0ZWRQb2ludHMsYz1udWxsO2lmKG51bGwhPWImJm51bGwhPXRoaXMudmFsaWRFZGdlcyYmIm5vbmUiIT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJqdW1wU3R5bGUiLCJub25lIikpe2Zvcih2YXIgZD1mdW5jdGlvbihiLGUsZCl7dmFyIGY9bmV3IG14UG9pbnQoZSxkKTtmLnR5cGU9YjtjLnB1c2goZik7Zj1udWxsIT1hLnJvdXRlZFBvaW50cz9hLnJvdXRlZFBvaW50c1tjLmxlbmd0aC0xXTpudWxsO3JldHVybiBudWxsPT1mfHxmLnR5cGUhPWJ8fGYueCE9ZXx8Zi55IT1kfSxmPS41KnRoaXMuc2NhbGUsZT0hMSxjPVtdLHQ9MDt0PGIubGVuZ3RoLTE7dCsrKXtmb3IodmFyIHk9CmJbdCsxXSxtPWJbdF0saz1bXSxxPWJbdCsyXTt0PGIubGVuZ3RoLTImJm14VXRpbHMucHRTZWdEaXN0U3EobS54LG0ueSxxLngscS55LHkueCx5LnkpPDEqdGhpcy5zY2FsZSp0aGlzLnNjYWxlOyl5PXEsdCsrLHE9Ylt0KzJdO2Zvcih2YXIgZT1kKDAsbS54LG0ueSl8fGUsRD0wO0Q8dGhpcy52YWxpZEVkZ2VzLmxlbmd0aDtEKyspe3ZhciB6PXRoaXMudmFsaWRFZGdlc1tEXSxFPXouYWJzb2x1dGVQb2ludHM7aWYobnVsbCE9RSYmbXhVdGlscy5pbnRlcnNlY3RzKGEseikmJiIxIiE9ei5zdHlsZS5ub0p1bXApZm9yKHo9MDt6PEUubGVuZ3RoLTE7eisrKXtmb3IodmFyIEc9RVt6KzFdLEY9RVt6XSxxPUVbeisyXTt6PEUubGVuZ3RoLTImJm14VXRpbHMucHRTZWdEaXN0U3EoRi54LEYueSxxLngscS55LEcueCxHLnkpPDEqdGhpcy5zY2FsZSp0aGlzLnNjYWxlOylHPXEseisrLHE9RVt6KzJdO3E9bXhVdGlscy5pbnRlcnNlY3Rpb24obS54LG0ueSx5LngseS55LEYueCxGLnksRy54LApHLnkpO2lmKG51bGwhPXEmJihNYXRoLmFicyhxLngtbS54KT5mfHxNYXRoLmFicyhxLnktbS55KT5mKSYmKE1hdGguYWJzKHEueC15LngpPmZ8fE1hdGguYWJzKHEueS15LnkpPmYpJiYoTWF0aC5hYnMocS54LUYueCk+Znx8TWF0aC5hYnMocS55LUYueSk+ZikmJihNYXRoLmFicyhxLngtRy54KT5mfHxNYXRoLmFicyhxLnktRy55KT5mKSl7Rz1xLngtbS54O0Y9cS55LW0ueTtxPXtkaXN0U3E6RypHK0YqRix4OnEueCx5OnEueX07Zm9yKEc9MDtHPGsubGVuZ3RoO0crKylpZihrW0ddLmRpc3RTcT5xLmRpc3RTcSl7ay5zcGxpY2UoRywwLHEpO3E9bnVsbDticmVha31udWxsPT1xfHwwIT1rLmxlbmd0aCYma1trLmxlbmd0aC0xXS54PT09cS54JiZrW2subGVuZ3RoLTFdLnk9PT1xLnl8fGsucHVzaChxKX19fWZvcih6PTA7ejxrLmxlbmd0aDt6KyspZT1kKDEsa1t6XS54LGtbel0ueSl8fGV9cT1iW2IubGVuZ3RoLTFdO2U9ZCgwLHEueCxxLnkpfHxlfWEucm91dGVkUG9pbnRzPWM7cmV0dXJuIGV9cmV0dXJuITF9Owp2YXIgaz1teENvbm5lY3Rvci5wcm90b3R5cGUucGFpbnRMaW5lO214Q29ubmVjdG9yLnByb3RvdHlwZS5wYWludExpbmU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMucm91dGVkUG9pbnRzPW51bGwhPXRoaXMuc3RhdGU/dGhpcy5zdGF0ZS5yb3V0ZWRQb2ludHM6bnVsbDtpZih0aGlzLm91dGxpbmV8fG51bGw9PXRoaXMuc3RhdGV8fG51bGw9PXRoaXMuc3R5bGV8fG51bGw9PXRoaXMuc3RhdGUucm91dGVkUG9pbnRzfHwwPT10aGlzLnN0YXRlLnJvdXRlZFBvaW50cy5sZW5ndGgpay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZWxzZXt2YXIgZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzIsZD0ocGFyc2VJbnQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJqdW1wU2l6ZSIsR3JhcGguZGVmYXVsdEp1bXBTaXplKSktMikvMit0aGlzLnN0cm9rZXdpZHRoLGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoianVtcFN0eWxlIiwibm9uZSIpLGc9ITAsbj1udWxsLG09bnVsbCxxPVtdLEI9bnVsbDthLmJlZ2luKCk7Zm9yKHZhciBEPTA7RDx0aGlzLnN0YXRlLnJvdXRlZFBvaW50cy5sZW5ndGg7RCsrKXt2YXIgej10aGlzLnN0YXRlLnJvdXRlZFBvaW50c1tEXSxFPW5ldyBteFBvaW50KHoueC90aGlzLnNjYWxlLHoueS90aGlzLnNjYWxlKTswPT1EP0U9YlswXTpEPT10aGlzLnN0YXRlLnJvdXRlZFBvaW50cy5sZW5ndGgtMSYmKEU9YltiLmxlbmd0aC0xXSk7dmFyIEc9ITE7aWYobnVsbCE9biYmMT09ei50eXBlKXt2YXIgRj10aGlzLnN0YXRlLnJvdXRlZFBvaW50c1tEKzFdLHo9Ri54L3RoaXMuc2NhbGUtRS54LEY9Ri55L3RoaXMuc2NhbGUtRS55LHo9eip6K0YqRjtudWxsPT1CJiYoQj1uZXcgbXhQb2ludChFLngtbi54LEUueS1uLnkpLG09TWF0aC5zcXJ0KEIueCpCLngrQi55KkIueSksMDxtPyhCLng9Qi54KmQvbSxCLnk9Qi55KmQvbSk6Qj1udWxsKTt6PmQqZCYmMDxtJiYoej1uLngtCkUueCxGPW4ueS1FLnksej16KnorRipGLHo+ZCpkJiYoRz1uZXcgbXhQb2ludChFLngtQi54LEUueS1CLnkpLHo9bmV3IG14UG9pbnQoRS54K0IueCxFLnkrQi55KSxxLnB1c2goRyksdGhpcy5hZGRQb2ludHMoYSxxLGMsZSwhMSxudWxsLGcpLHE9MD5NYXRoLnJvdW5kKEIueCl8fDA9PU1hdGgucm91bmQoQi54KSYmMD49TWF0aC5yb3VuZChCLnkpPzE6LTEsZz0hMSwic2hhcnAiPT1mPyhhLmxpbmVUbyhHLngtQi55KnEsRy55K0IueCpxKSxhLmxpbmVUbyh6LngtQi55KnEsei55K0IueCpxKSxhLmxpbmVUbyh6Lngsei55KSk6ImFyYyI9PWY/KHEqPTEuMyxhLmN1cnZlVG8oRy54LUIueSpxLEcueStCLngqcSx6LngtQi55KnEsei55K0IueCpxLHoueCx6LnkpKTooYS5tb3ZlVG8oei54LHoueSksZz0hMCkscT1bel0sRz0hMCkpfWVsc2UgQj1udWxsO0d8fChxLnB1c2goRSksbj1FKX10aGlzLmFkZFBvaW50cyhhLHEsYyxlLCExLG51bGwsZyk7YS5zdHJva2UoKX19O3ZhciBtPW14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnQ7Cm14R3JhcGhWaWV3LnByb3RvdHlwZS51cGRhdGVGbG9hdGluZ1Rlcm1pbmFsUG9pbnQ9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbD09Ynx8bnVsbD09YXx8IjEiIT1iLnN0eWxlLnNuYXBUb1BvaW50JiYiMSIhPWEuc3R5bGUuc25hcFRvUG9pbnQpbS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZWxzZXtiPXRoaXMuZ2V0VGVybWluYWxQb3J0KGEsYixkKTt2YXIgZT10aGlzLmdldE5leHRQb2ludChhLGMsZCksZj10aGlzLmdyYXBoLmlzT3J0aG9nb25hbChhKSxnPW14VXRpbHMudG9SYWRpYW5zKE51bWJlcihiLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKSksbD1uZXcgbXhQb2ludChiLmdldENlbnRlclgoKSxiLmdldENlbnRlclkoKSk7aWYoMCE9Zyl2YXIgbj1NYXRoLmNvcygtZyksaz1NYXRoLnNpbigtZyksZT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChlLG4sayxsKTtuPXBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9QRVJJTUVURVJfU1BBQ0lOR118fAowKTtuKz1wYXJzZUZsb2F0KGEuc3R5bGVbZD9teENvbnN0YW50cy5TVFlMRV9TT1VSQ0VfUEVSSU1FVEVSX1NQQUNJTkc6bXhDb25zdGFudHMuU1RZTEVfVEFSR0VUX1BFUklNRVRFUl9TUEFDSU5HXXx8MCk7ZT10aGlzLmdldFBlcmltZXRlclBvaW50KGIsZSwwPT1nJiZmLG4pOzAhPWcmJihuPU1hdGguY29zKGcpLGs9TWF0aC5zaW4oZyksZT1teFV0aWxzLmdldFJvdGF0ZWRQb2ludChlLG4sayxsKSk7YS5zZXRBYnNvbHV0ZVRlcm1pbmFsUG9pbnQodGhpcy5zbmFwVG9BbmNob3JQb2ludChhLGIsYyxkLGUpLGQpfX07bXhHcmFwaFZpZXcucHJvdG90eXBlLnNuYXBUb0FuY2hvclBvaW50PWZ1bmN0aW9uKGEsYixjLGQsZil7aWYobnVsbCE9YiYmbnVsbCE9YSl7YT10aGlzLmdyYXBoLmdldEFsbENvbm5lY3Rpb25Db25zdHJhaW50cyhiKTtkPWM9bnVsbDtpZihudWxsIT1hKWZvcih2YXIgZT0wO2U8YS5sZW5ndGg7ZSsrKXt2YXIgZz10aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Qb2ludChiLAphW2VdKTtpZihudWxsIT1nKXt2YXIgbD0oZy54LWYueCkqKGcueC1mLngpKyhnLnktZi55KSooZy55LWYueSk7aWYobnVsbD09ZHx8bDxkKWM9ZyxkPWx9fW51bGwhPWMmJihmPWMpfXJldHVybiBmfTt2YXIgcT1teFN0ZW5jaWwucHJvdG90eXBlLmV2YWx1YXRlVGV4dEF0dHJpYnV0ZTtteFN0ZW5jaWwucHJvdG90eXBlLmV2YWx1YXRlVGV4dEF0dHJpYnV0ZT1mdW5jdGlvbihhLGIsYyl7dmFyIGU9cS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IjEiPT1hLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXJzIikmJm51bGwhPWMuc3RhdGUmJihlPWMuc3RhdGUudmlldy5ncmFwaC5yZXBsYWNlUGxhY2Vob2xkZXJzKGMuc3RhdGUuY2VsbCxlKSk7cmV0dXJuIGV9O3ZhciBiPW14Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlU2hhcGU9ZnVuY3Rpb24oYSl7aWYobnVsbCE9YS5zdHlsZSYmInVuZGVmaW5lZCIhPT10eXBlb2YgcGFrbyl7dmFyIGU9Cm14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TSEFQRSxudWxsKTtpZihudWxsIT1lJiYic3RyaW5nIj09PXR5cGVvZiBlJiYic3RlbmNpbCgiPT1lLnN1YnN0cmluZygwLDgpKXRyeXt2YXIgYz1lLnN1YnN0cmluZyg4LGUubGVuZ3RoLTEpLGQ9bXhVdGlscy5wYXJzZVhtbChHcmFwaC5kZWNvbXByZXNzKGMpKTtyZXR1cm4gbmV3IG14U2hhcGUobmV3IG14U3RlbmNpbChkLmRvY3VtZW50RWxlbWVudCkpfWNhdGNoKHApe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiRXJyb3IgaW4gc2hhcGU6ICIrcCl9fXJldHVybiBiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KSgpO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcz17fTtteFN0ZW5jaWxSZWdpc3RyeS5keW5hbWljTG9hZGluZz0hMDtteFN0ZW5jaWxSZWdpc3RyeS5hbGxvd0V2YWw9ITA7bXhTdGVuY2lsUmVnaXN0cnkucGFja2FnZXM9W107Cm14U3RlbmNpbFJlZ2lzdHJ5LmdldFN0ZW5jaWw9ZnVuY3Rpb24oYSl7dmFyIGM9bXhTdGVuY2lsUmVnaXN0cnkuc3RlbmNpbHNbYV07aWYobnVsbD09YyYmbnVsbD09bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlc1thXSYmbXhTdGVuY2lsUmVnaXN0cnkuZHluYW1pY0xvYWRpbmcpe3ZhciBmPW14U3RlbmNpbFJlZ2lzdHJ5LmdldEJhc2VuYW1lRm9yU3RlbmNpbChhKTtpZihudWxsIT1mKXtjPW14U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1tmXTtpZihudWxsIT1jKXtpZihudWxsPT1teFN0ZW5jaWxSZWdpc3RyeS5wYWNrYWdlc1tmXSl7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBrPWNbZF07aWYoIi54bWwiPT1rLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKGsubGVuZ3RoLTQsay5sZW5ndGgpKW14U3RlbmNpbFJlZ2lzdHJ5LmxvYWRTdGVuY2lsU2V0KGssbnVsbCk7ZWxzZSBpZigiLmpzIj09ay50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZyhrLmxlbmd0aC0zLGsubGVuZ3RoKSl0cnl7aWYobXhTdGVuY2lsUmVnaXN0cnkuYWxsb3dFdmFsKXt2YXIgbT0KbXhVdGlscy5sb2FkKGspO251bGwhPW0mJjIwMDw9bS5nZXRTdGF0dXMoKSYmMjk5Pj1tLmdldFN0YXR1cygpJiZldmFsLmNhbGwod2luZG93LG0uZ2V0VGV4dCgpKX19Y2F0Y2gocSl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJlcnJvciBpbiBnZXRTdGVuY2lsOiIsayxxKX19bXhTdGVuY2lsUmVnaXN0cnkucGFja2FnZXNbZl09MX19ZWxzZSBmPWYucmVwbGFjZSgiXy1fIiwiXyIpLG14U3RlbmNpbFJlZ2lzdHJ5LmxvYWRTdGVuY2lsU2V0KFNURU5DSUxfUEFUSCsiLyIrZisiLnhtbCIsbnVsbCk7Yz1teFN0ZW5jaWxSZWdpc3RyeS5zdGVuY2lsc1thXX19cmV0dXJuIGN9OwpteFN0ZW5jaWxSZWdpc3RyeS5nZXRCYXNlbmFtZUZvclN0ZW5jaWw9ZnVuY3Rpb24oYSl7dmFyIGM9bnVsbDtpZihudWxsIT1hJiYic3RyaW5nIj09PXR5cGVvZiBhJiYoYT1hLnNwbGl0KCIuIiksMDxhLmxlbmd0aCYmIm14Z3JhcGgiPT1hWzBdKSlmb3IodmFyIGM9YVsxXSxmPTI7ZjxhLmxlbmd0aC0xO2YrKyljKz0iLyIrYVtmXTtyZXR1cm4gY307Cm14U3RlbmNpbFJlZ2lzdHJ5LmxvYWRTdGVuY2lsU2V0PWZ1bmN0aW9uKGEsYyxmLGQpe3ZhciBrPW14U3RlbmNpbFJlZ2lzdHJ5LnBhY2thZ2VzW2FdO2lmKG51bGwhPWYmJmZ8fG51bGw9PWspe3ZhciBtPSExO2lmKG51bGw9PWspdHJ5e2lmKGQpe214U3RlbmNpbFJlZ2lzdHJ5LmxvYWRTdGVuY2lsKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZCl7bnVsbCE9ZCYmbnVsbCE9ZC5kb2N1bWVudEVsZW1lbnQmJihteFN0ZW5jaWxSZWdpc3RyeS5wYWNrYWdlc1thXT1kLG09ITAsbXhTdGVuY2lsUmVnaXN0cnkucGFyc2VTdGVuY2lsU2V0KGQuZG9jdW1lbnRFbGVtZW50LGMsbSkpfSkpO3JldHVybn1rPW14U3RlbmNpbFJlZ2lzdHJ5LmxvYWRTdGVuY2lsKGEpO214U3RlbmNpbFJlZ2lzdHJ5LnBhY2thZ2VzW2FdPWs7bT0hMH1jYXRjaChxKXtudWxsIT13aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2coImVycm9yIGluIGxvYWRTdGVuY2lsU2V0OiIsYSxxKX1udWxsIT1rJiZudWxsIT0Kay5kb2N1bWVudEVsZW1lbnQmJm14U3RlbmNpbFJlZ2lzdHJ5LnBhcnNlU3RlbmNpbFNldChrLmRvY3VtZW50RWxlbWVudCxjLG0pfX07bXhTdGVuY2lsUmVnaXN0cnkubG9hZFN0ZW5jaWw9ZnVuY3Rpb24oYSxjKXtpZihudWxsIT1jKW14VXRpbHMuZ2V0KGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YygyMDA8PWEuZ2V0U3RhdHVzKCkmJjI5OT49YS5nZXRTdGF0dXMoKT9hLmdldFhtbCgpOm51bGwpfSkpO2Vsc2UgcmV0dXJuIG14VXRpbHMubG9hZChhKS5nZXRYbWwoKX07bXhTdGVuY2lsUmVnaXN0cnkucGFyc2VTdGVuY2lsU2V0cz1mdW5jdGlvbihhKXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylteFN0ZW5jaWxSZWdpc3RyeS5wYXJzZVN0ZW5jaWxTZXQobXhVdGlscy5wYXJzZVhtbChhW2NdKS5kb2N1bWVudEVsZW1lbnQpfTsKbXhTdGVuY2lsUmVnaXN0cnkucGFyc2VTdGVuY2lsU2V0PWZ1bmN0aW9uKGEsYyxmKXtpZigic3RlbmNpbHMiPT1hLm5vZGVOYW1lKWZvcih2YXIgZD1hLmZpcnN0Q2hpbGQ7bnVsbCE9ZDspInNoYXBlcyI9PWQubm9kZU5hbWUmJm14U3RlbmNpbFJlZ2lzdHJ5LnBhcnNlU3RlbmNpbFNldChkLGMsZiksZD1kLm5leHRTaWJsaW5nO2Vsc2V7Zj1udWxsIT1mP2Y6ITA7dmFyIGQ9YS5maXJzdENoaWxkLGs9IiI7YT1hLmdldEF0dHJpYnV0ZSgibmFtZSIpO2ZvcihudWxsIT1hJiYoaz1hKyIuIik7bnVsbCE9ZDspe2lmKGQubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQmJihhPWQuZ2V0QXR0cmlidXRlKCJuYW1lIiksbnVsbCE9YSkpe3ZhciBrPWsudG9Mb3dlckNhc2UoKSxtPWEucmVwbGFjZSgvIC9nLCJfIik7ZiYmbXhTdGVuY2lsUmVnaXN0cnkuYWRkU3RlbmNpbChrK20udG9Mb3dlckNhc2UoKSxuZXcgbXhTdGVuY2lsKGQpKTtpZihudWxsIT1jKXt2YXIgcT1kLmdldEF0dHJpYnV0ZSgidyIpLApiPWQuZ2V0QXR0cmlidXRlKCJoIikscT1udWxsPT1xPzgwOnBhcnNlSW50KHEsMTApLGI9bnVsbD09Yj84MDpwYXJzZUludChiLDEwKTtjKGssbSxhLHEsYil9fWQ9ZC5uZXh0U2libGluZ319fTsKInVuZGVmaW5lZCIhPXR5cGVvZiBteFZlcnRleEhhbmRsZXImJmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2EuY2xhc3NOYW1lPSJnZUhpbnQiO2Euc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7cmV0dXJuIGF9ZnVuY3Rpb24gYyhhLGIpe3N3aXRjaChiKXtjYXNlIG14Q29uc3RhbnRzLlBPSU5UUzpyZXR1cm4gYTtjYXNlIG14Q29uc3RhbnRzLk1JTExJTUVURVJTOnJldHVybihhL214Q29uc3RhbnRzLlBJWEVMU19QRVJfTU0pLnRvRml4ZWQoMSk7Y2FzZSBteENvbnN0YW50cy5JTkNIRVM6cmV0dXJuKGEvbXhDb25zdGFudHMuUElYRUxTX1BFUl9JTkNIKS50b0ZpeGVkKDIpfX1teENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SPSIjMjliNmYyIjtteENvbnN0YW50cy5IQU5ETEVfU1RST0tFQ09MT1I9IiMwMDg4Y2YiO214Q29uc3RhbnRzLlZFUlRFWF9TRUxFQ1RJT05fQ09MT1I9CiIjMDBhOGZmIjtteENvbnN0YW50cy5PVVRMSU5FX0NPTE9SPSIjMDBhOGZmIjtteENvbnN0YW50cy5PVVRMSU5FX0hBTkRMRV9GSUxMQ09MT1I9IiM5OWNjZmYiO214Q29uc3RhbnRzLk9VVExJTkVfSEFORExFX1NUUk9LRUNPTE9SPSIjMDBhOGZmIjtteENvbnN0YW50cy5DT05ORUNUX0hBTkRMRV9GSUxMQ09MT1I9IiNjZWU3ZmYiO214Q29uc3RhbnRzLkVER0VfU0VMRUNUSU9OX0NPTE9SPSIjMDBhOGZmIjtteENvbnN0YW50cy5ERUZBVUxUX1ZBTElEX0NPTE9SPSIjMDBhOGZmIjtteENvbnN0YW50cy5MQUJFTF9IQU5ETEVfRklMTENPTE9SPSIjY2VlN2ZmIjtteENvbnN0YW50cy5HVUlERV9DT0xPUj0iIzAwODhjZiI7bXhDb25zdGFudHMuSElHSExJR0hUX09QQUNJVFk9MzA7bXhDb25zdGFudHMuSElHSExJR0hUX1NJWkU9NTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9UZXJtaW5hbHM9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmd1aWRlc0VuYWJsZWQ9ITA7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUVtcHR5UGFyZW50cz0KITA7bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5mYWRlT3V0PSEwO214R3VpZGUucHJvdG90eXBlLmlzRW5hYmxlZEZvckV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzQWx0RG93bihhKX07dmFyIGY9bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNDcmVhdGVUYXJnZXQ7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuaXNDcmVhdGVUYXJnZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG14RXZlbnQuaXNDb250cm9sRG93bihhKXx8Zi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUhpZ2hsaWdodFNoYXBlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14RWxsaXBzZShudWxsLHRoaXMuaGlnaGxpZ2h0Q29sb3IsdGhpcy5oaWdobGlnaHRDb2xvciwwKTthLm9wYWNpdHk9bXhDb25zdGFudHMuSElHSExJR0hUX09QQUNJVFk7cmV0dXJuIGF9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmxpdmVQcmV2aWV3PQohMDtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jdXJzb3I9ImNyb3NzaGFpciI7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWRnZVN0YXRlPWZ1bmN0aW9uKGEpe2E9dGhpcy5ncmFwaC5jcmVhdGVDdXJyZW50RWRnZVN0eWxlKCk7YT10aGlzLmdyYXBoLmNyZWF0ZUVkZ2UobnVsbCxudWxsLG51bGwsbnVsbCxudWxsLGEpO2E9bmV3IG14Q2VsbFN0YXRlKHRoaXMuZ3JhcGgudmlldyxhLHRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGEpKTtmb3IodmFyIGIgaW4gdGhpcy5ncmFwaC5jdXJyZW50RWRnZVN0eWxlKWEuc3R5bGVbYl09dGhpcy5ncmFwaC5jdXJyZW50RWRnZVN0eWxlW2JdO3JldHVybiBhfTt2YXIgZD1teENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZTtteENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZT1mdW5jdGlvbigpe3ZhciBhPWQuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuaXNEYXNoZWQ9IjEiPT0KdGhpcy5ncmFwaC5jdXJyZW50RWRnZVN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0RBU0hFRF07cmV0dXJuIGF9O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVByZXZpZXc9ZnVuY3Rpb24oYSl7fTt2YXIgaz1teENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVNYXJrZXI7bXhDb25uZWN0aW9uSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlTWFya2VyPWZ1bmN0aW9uKCl7dmFyIGE9ay5hcHBseSh0aGlzLGFyZ3VtZW50cyksYj1hLmdldENlbGw7YS5nZXRDZWxsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBlPWIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZXJyb3I9bnVsbDtyZXR1cm4gZX0pO3JldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFZlcnRleFN0eWxlPXt9O0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0RWRnZVN0eWxlPXtlZGdlU3R5bGU6Im9ydGhvZ29uYWxFZGdlU3R5bGUiLHJvdW5kZWQ6IjAiLGpldHR5U2l6ZToiYXV0byIsCm9ydGhvZ29uYWxMb29wOiIxIn07R3JhcGgucHJvdG90eXBlLmNyZWF0ZUN1cnJlbnRFZGdlU3R5bGU9ZnVuY3Rpb24oKXt2YXIgYT0iZWRnZVN0eWxlPSIrKHRoaXMuY3VycmVudEVkZ2VTdHlsZS5lZGdlU3R5bGV8fCJub25lIikrIjsiO251bGwhPXRoaXMuY3VycmVudEVkZ2VTdHlsZS5zaGFwZSYmKGErPSJzaGFwZT0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5zaGFwZSsiOyIpO251bGwhPXRoaXMuY3VycmVudEVkZ2VTdHlsZS5jdXJ2ZWQmJihhKz0iY3VydmVkPSIrdGhpcy5jdXJyZW50RWRnZVN0eWxlLmN1cnZlZCsiOyIpO251bGwhPXRoaXMuY3VycmVudEVkZ2VTdHlsZS5yb3VuZGVkJiYoYSs9InJvdW5kZWQ9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUucm91bmRlZCsiOyIpO251bGwhPXRoaXMuY3VycmVudEVkZ2VTdHlsZS5jb21pYyYmKGErPSJjb21pYz0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5jb21pYysiOyIpO251bGwhPXRoaXMuY3VycmVudEVkZ2VTdHlsZS5qdW1wU3R5bGUmJgooYSs9Imp1bXBTdHlsZT0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5qdW1wU3R5bGUrIjsiKTtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuanVtcFNpemUmJihhKz0ianVtcFNpemU9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUuanVtcFNpemUrIjsiKTtudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUub3J0aG9nb25hbExvb3A/YSs9Im9ydGhvZ29uYWxMb29wPSIrdGhpcy5jdXJyZW50RWRnZVN0eWxlLm9ydGhvZ29uYWxMb29wKyI7IjpudWxsIT1HcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VTdHlsZS5vcnRob2dvbmFsTG9vcCYmKGErPSJvcnRob2dvbmFsTG9vcD0iK0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0RWRnZVN0eWxlLm9ydGhvZ29uYWxMb29wKyI7Iik7bnVsbCE9dGhpcy5jdXJyZW50RWRnZVN0eWxlLmpldHR5U2l6ZT9hKz0iamV0dHlTaXplPSIrdGhpcy5jdXJyZW50RWRnZVN0eWxlLmpldHR5U2l6ZSsiOyI6bnVsbCE9R3JhcGgucHJvdG90eXBlLmRlZmF1bHRFZGdlU3R5bGUuamV0dHlTaXplJiYKKGErPSJqZXR0eVNpemU9IitHcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VTdHlsZS5qZXR0eVNpemUrIjsiKTsiZWxib3dFZGdlU3R5bGUiPT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuZWRnZVN0eWxlJiZudWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuZWxib3cmJihhKz0iZWxib3c9Iit0aGlzLmN1cnJlbnRFZGdlU3R5bGUuZWxib3crIjsiKTtyZXR1cm4gYT1udWxsIT10aGlzLmN1cnJlbnRFZGdlU3R5bGUuaHRtbD9hKygiaHRtbD0iK3RoaXMuY3VycmVudEVkZ2VTdHlsZS5odG1sKyI7Iik6YSsiaHRtbD0xOyJ9O0dyYXBoLnByb3RvdHlwZS5nZXRQYWdlUGFkZGluZz1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhQb2ludCgwLDApfTtHcmFwaC5wcm90b3R5cGUubG9hZFN0eWxlc2hlZXQ9ZnVuY3Rpb24oKXt2YXIgYT1udWxsIT10aGlzLnRoZW1lcz90aGlzLnRoZW1lc1t0aGlzLmRlZmF1bHRUaGVtZU5hbWVdOm14U3R5bGVSZWdpc3RyeS5keW5hbWljTG9hZGluZz9teFV0aWxzLmxvYWQoU1RZTEVfUEFUSCsKIi9kZWZhdWx0LnhtbCIpLmdldERvY3VtZW50RWxlbWVudCgpOm51bGw7bnVsbCE9YSYmKG5ldyBteENvZGVjKGEub3duZXJEb2N1bWVudCkpLmRlY29kZShhLHRoaXMuZ2V0U3R5bGVzaGVldCgpKX07R3JhcGgucHJvdG90eXBlLmNyZWF0ZUNlbGxMb29rdXA9ZnVuY3Rpb24oYSxiKXtiPW51bGwhPWI/Yjp7fTtmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGM9YVtlXTtiW214T2JqZWN0SWRlbnRpdHkuZ2V0KGMpXT1jLmdldElkKCk7Zm9yKHZhciBkPXRoaXMubW9kZWwuZ2V0Q2hpbGRDb3VudChjKSxmPTA7ZjxkO2YrKyl0aGlzLmNyZWF0ZUNlbGxMb29rdXAoW3RoaXMubW9kZWwuZ2V0Q2hpbGRBdChjLGYpXSxiKX1yZXR1cm4gYn07R3JhcGgucHJvdG90eXBlLmNyZWF0ZUNlbGxNYXBwaW5nPWZ1bmN0aW9uKGEsYixlKXtlPW51bGwhPWU/ZTp7fTtmb3IodmFyIGMgaW4gYSl7dmFyIGQ9YltjXTtudWxsPT1lW2RdJiYoZVtkXT1hW2NdLmdldElkKCl8fCIiKX1yZXR1cm4gZX07CkdyYXBoLnByb3RvdHlwZS5pbXBvcnRHcmFwaE1vZGVsPWZ1bmN0aW9uKGEsYixlLGMpe2I9bnVsbCE9Yj9iOjA7ZT1udWxsIT1lP2U6MDt2YXIgZD1uZXcgbXhDb2RlYyhhLm93bmVyRG9jdW1lbnQpLGY9bmV3IG14R3JhcGhNb2RlbDtkLmRlY29kZShhLGYpO2E9W107dmFyIGQ9e30sZz17fSxsPWYuZ2V0Q2hpbGRyZW4odGhpcy5jbG9uZUNlbGwoZi5yb290LHRoaXMuaXNDbG9uZUludmFsaWRFZGdlcygpLGQpKTtpZihudWxsIT1sKXt2YXIgbj10aGlzLmNyZWF0ZUNlbGxMb29rdXAoW2Yucm9vdF0pLGw9bC5zbGljZSgpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7aWYoMSE9bC5sZW5ndGh8fHRoaXMuaXNDZWxsTG9ja2VkKHRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpKSlmb3IoZj0wO2Y8bC5sZW5ndGg7ZisrKXt2YXIgdT10aGlzLm1vZGVsLmdldENoaWxkcmVuKHRoaXMubW92ZUNlbGxzKFtsW2ZdXSxiLGUsITEsdGhpcy5tb2RlbC5nZXRSb290KCkpWzBdKTtudWxsIT11JiYKKGE9YS5jb25jYXQodSkpfWVsc2UgYT10aGlzLm1vdmVDZWxscyhmLmdldENoaWxkcmVuKGxbMF0pLGIsZSwhMSx0aGlzLmdldERlZmF1bHRQYXJlbnQoKSksZ1tmLmdldENoaWxkQXQoZi5yb290LDApLmdldElkKCldPXRoaXMuZ2V0RGVmYXVsdFBhcmVudCgpLmdldElkKCk7aWYobnVsbCE9YSYmKHRoaXMuY3JlYXRlQ2VsbE1hcHBpbmcoZCxuLGcpLHRoaXMudXBkYXRlQ3VzdG9tTGlua3MoZyxhKSxjKSl7dGhpcy5pc0dyaWRFbmFibGVkKCkmJihiPXRoaXMuc25hcChiKSxlPXRoaXMuc25hcChlKSk7dmFyIHA9dGhpcy5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShhLCEwKTtudWxsIT1wJiZ0aGlzLm1vdmVDZWxscyhhLGItcC54LGUtcC55KX19ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX1yZXR1cm4gYX07R3JhcGgucHJvdG90eXBlLmVuY29kZUNlbGxzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj17fSxlPXRoaXMuY2xvbmVDZWxscyhhLG51bGwsYiksYz1uZXcgbXhEaWN0aW9uYXJ5LApkPTA7ZDxhLmxlbmd0aDtkKyspYy5wdXQoYVtkXSwhMCk7Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl7dmFyIGY9dGhpcy52aWV3LmdldFN0YXRlKGFbZF0pO2lmKG51bGwhPWYpe3ZhciBnPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGVbZF0pO251bGw9PWd8fCFnLnJlbGF0aXZlfHx0aGlzLm1vZGVsLmlzRWRnZShhW2RdKXx8Yy5nZXQodGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtkXSkpfHwoZy5yZWxhdGl2ZT0hMSxnLng9Zi54L2Yudmlldy5zY2FsZS1mLnZpZXcudHJhbnNsYXRlLngsZy55PWYueS9mLnZpZXcuc2NhbGUtZi52aWV3LnRyYW5zbGF0ZS55KX19Yz1uZXcgbXhDb2RlYztmPW5ldyBteEdyYXBoTW9kZWw7Zz1mLmdldENoaWxkQXQoZi5nZXRSb290KCksMCk7Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKylmLmFkZChnLGVbZF0pO3RoaXMudXBkYXRlQ3VzdG9tTGlua3ModGhpcy5jcmVhdGVDZWxsTWFwcGluZyhiLHRoaXMuY3JlYXRlQ2VsbExvb2t1cChhKSksZSk7cmV0dXJuIGMuZW5jb2RlKGYpfTsKdmFyIG09R3JhcGgucHJvdG90eXBlLnNwbGl0RWRnZTtHcmFwaC5wcm90b3R5cGUuc3BsaXRFZGdlPWZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCl7bnVsbD09bCYmKGw9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYSksdGhpcy5pc1RhYmxlKGwpfHx0aGlzLmlzVGFibGVSb3cobCkpJiYobD10aGlzLmdldENlbGxBdChmLGcsbnVsbCwhMCwhMSkpO20uYXBwbHkodGhpcyxbYSxiLGUsYyxkLGYsZyxsXSl9O3ZhciBxPUdyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsO0dyYXBoLnByb3RvdHlwZS5zZWxlY3RDZWxsPWZ1bmN0aW9uKGEsYixlKXtpZihifHxlKXEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7dmFyIGM9dGhpcy5nZXRTZWxlY3Rpb25DZWxsKCksZD1udWxsLGY9W10sZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZihudWxsIT10aGlzLnZpZXcuZ2V0U3RhdGUoYikmJih0aGlzLm1vZGVsLmlzVmVydGV4KGIpfHx0aGlzLm1vZGVsLmlzRWRnZShiKSkpaWYoZi5wdXNoKGIpLApiPT1jKWQ9Zi5sZW5ndGgtMTtlbHNlIGlmKGEmJm51bGw9PWMmJjA8Zi5sZW5ndGh8fG51bGwhPWQmJmEmJmYubGVuZ3RoPmR8fCFhJiYwPGQpcmV0dXJuO2Zvcih2YXIgZT0wO2U8dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGIpO2UrKylnKHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChiLGUpKX0pO2codGhpcy5tb2RlbC5yb290KTswPGYubGVuZ3RoJiYoZD1udWxsIT1kP214VXRpbHMubW9kKGQrKGE/MTotMSksZi5sZW5ndGgpOjAsdGhpcy5zZXRTZWxlY3Rpb25DZWxsKGZbZF0pKX19O3ZhciBiPUdyYXBoLnByb3RvdHlwZS5tb3ZlQ2VsbHM7R3JhcGgucHJvdG90eXBlLm1vdmVDZWxscz1mdW5jdGlvbihhLGUsYyxkLGYsZyxsKXtsPW51bGwhPWw/bDp7fTt2YXIgbj1iLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtkJiZ0aGlzLnVwZGF0ZUN1c3RvbUxpbmtzKHRoaXMuY3JlYXRlQ2VsbE1hcHBpbmcobCx0aGlzLmNyZWF0ZUNlbGxMb29rdXAoYSkpLG4pO3JldHVybiBufTt2YXIgZT1HcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbHM7CkdyYXBoLnByb3RvdHlwZS5yZW1vdmVDZWxscz1mdW5jdGlvbihhLGIpe3ZhciBjPVtdO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspdGhpcy5pc1RhYmxlQ2VsbChhW2RdKT90aGlzLmxhYmVsQ2hhbmdlZChhW2RdLCIiKTpjLnB1c2goYVtkXSk7Yz1lLmFwcGx5KHRoaXMsW2MsYl0pfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1yZXR1cm4gY307R3JhcGgucHJvdG90eXBlLnVwZGF0ZUN1c3RvbUxpbmtzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspbnVsbCE9YltlXSYmdGhpcy51cGRhdGVDdXN0b21MaW5rc0ZvckNlbGwoYSxiW2VdKX07R3JhcGgucHJvdG90eXBlLnVwZGF0ZUN1c3RvbUxpbmtzRm9yQ2VsbD1mdW5jdGlvbihhLGIpe307R3JhcGgucHJvdG90eXBlLmdldEFsbENvbm5lY3Rpb25Db25zdHJhaW50cz1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe3ZhciBlPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwKInBvaW50cyIsbnVsbCk7aWYobnVsbCE9ZSl7dmFyIGM9W107dHJ5e2Zvcih2YXIgZD1KU09OLnBhcnNlKGUpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9ZFtlXTtjLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoZlswXSxmWzFdKSwyPGYubGVuZ3RoPyIwIiE9ZlsyXTohMCxudWxsLDM8Zi5sZW5ndGg/ZlszXTowLDQ8Zi5sZW5ndGg/Zls0XTowKSl9fWNhdGNoKG5hKXt9cmV0dXJuIGN9aWYobnVsbCE9YS5zaGFwZSYmbnVsbCE9YS5zaGFwZS5ib3VuZHMpe2Y9YS5zaGFwZS5kaXJlY3Rpb247ZD1hLnNoYXBlLmJvdW5kcztlPWEuc2hhcGUuc2NhbGU7Yz1kLndpZHRoL2U7ZD1kLmhlaWdodC9lO2lmKGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSHx8Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIKWY9YyxjPWQsZD1mO2U9YS5zaGFwZS5nZXRDb25zdHJhaW50cyhhLnN0eWxlLGMsZCk7aWYobnVsbCE9ZSlyZXR1cm4gZTtpZihudWxsIT0KYS5zaGFwZS5zdGVuY2lsJiZudWxsIT1hLnNoYXBlLnN0ZW5jaWwuY29uc3RyYWludHMpcmV0dXJuIGEuc2hhcGUuc3RlbmNpbC5jb25zdHJhaW50cztpZihudWxsIT1hLnNoYXBlLmNvbnN0cmFpbnRzKXJldHVybiBhLnNoYXBlLmNvbnN0cmFpbnRzfX1yZXR1cm4gbnVsbH07R3JhcGgucHJvdG90eXBlLmZsaXBFZGdlPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEpe3ZhciBiPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKSxiPW14VXRpbHMuZ2V0VmFsdWUoYixteENvbnN0YW50cy5TVFlMRV9FTEJPVyxteENvbnN0YW50cy5FTEJPV19IT1JJWk9OVEFMKT09bXhDb25zdGFudHMuRUxCT1dfSE9SSVpPTlRBTD9teENvbnN0YW50cy5FTEJPV19WRVJUSUNBTDpteENvbnN0YW50cy5FTEJPV19IT1JJWk9OVEFMO3RoaXMuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9FTEJPVyxiLFthXSl9fTtHcmFwaC5wcm90b3R5cGUuaXNWYWxpZFJvb3Q9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPQp0aGlzLm1vZGVsLmdldENoaWxkQ291bnQoYSksZT0wLGM9MDtjPGI7YysrKXt2YXIgZD10aGlzLm1vZGVsLmdldENoaWxkQXQoYSxjKTt0aGlzLm1vZGVsLmlzVmVydGV4KGQpJiYoZD10aGlzLmdldENlbGxHZW9tZXRyeShkKSxudWxsPT1kfHxkLnJlbGF0aXZlfHxlKyspfXJldHVybiAwPGV8fHRoaXMuaXNDb250YWluZXIoYSl9O0dyYXBoLnByb3RvdHlwZS5pc1ZhbGlkRHJvcFRhcmdldD1mdW5jdGlvbihhLGIsZSl7Zm9yKHZhciBjPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKSxkPSEwLGY9MDtmPGIubGVuZ3RoJiZkO2YrKylkPWQmJnRoaXMuaXNUYWJsZVJvdyhiW2ZdKTtyZXR1cm4oIjEiIT1teFV0aWxzLmdldFZhbHVlKGMsInBhcnQiLCIwIil8fHRoaXMuaXNDb250YWluZXIoYSkpJiYiMCIhPW14VXRpbHMuZ2V0VmFsdWUoYywiZHJvcFRhcmdldCIsIjEiKSYmKG14R3JhcGgucHJvdG90eXBlLmlzVmFsaWREcm9wVGFyZ2V0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcy5pc0NvbnRhaW5lcihhKSkmJgohdGhpcy5pc1RhYmxlUm93KGEpJiYoIXRoaXMuaXNUYWJsZShhKXx8ZCl9O0dyYXBoLnByb3RvdHlwZS5jcmVhdGVHcm91cENlbGw9ZnVuY3Rpb24oKXt2YXIgYT1teEdyYXBoLnByb3RvdHlwZS5jcmVhdGVHcm91cENlbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Euc2V0U3R5bGUoImdyb3VwIik7cmV0dXJuIGF9O0dyYXBoLnByb3RvdHlwZS5pc0V4dGVuZFBhcmVudHNPbkFkZD1mdW5jdGlvbihhKXt2YXIgYj1teEdyYXBoLnByb3RvdHlwZS5pc0V4dGVuZFBhcmVudHNPbkFkZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoYiYmbnVsbCE9YSYmbnVsbCE9dGhpcy5sYXlvdXRNYW5hZ2VyKXt2YXIgZT10aGlzLm1vZGVsLmdldFBhcmVudChhKTtudWxsIT1lJiYoZT10aGlzLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0KGUpLG51bGwhPWUmJmUuY29uc3RydWN0b3I9PW14U3RhY2tMYXlvdXQmJihiPSExKSl9cmV0dXJuIGJ9O0dyYXBoLnByb3RvdHlwZS5nZXRQcmVmZXJyZWRTaXplRm9yQ2VsbD0KZnVuY3Rpb24oYSl7dmFyIGI9bXhHcmFwaC5wcm90b3R5cGUuZ2V0UHJlZmVycmVkU2l6ZUZvckNlbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPWImJihiLndpZHRoKz0xMCxiLmhlaWdodCs9NCx0aGlzLmdyaWRFbmFibGVkJiYoYi53aWR0aD10aGlzLnNuYXAoYi53aWR0aCksYi5oZWlnaHQ9dGhpcy5zbmFwKGIuaGVpZ2h0KSkpO3JldHVybiBifTtHcmFwaC5wcm90b3R5cGUudHVyblNoYXBlcz1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0TW9kZWwoKSxjPVtdO2UuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBmPWFbZF07aWYoZS5pc0VkZ2UoZikpe3ZhciBnPWUuZ2V0VGVybWluYWwoZiwhMCksbD1lLmdldFRlcm1pbmFsKGYsITEpO2Uuc2V0VGVybWluYWwoZixsLCEwKTtlLnNldFRlcm1pbmFsKGYsZywhMSk7dmFyIG49ZS5nZXRHZW9tZXRyeShmKTtpZihudWxsIT1uKXtuPW4uY2xvbmUoKTtudWxsIT1uLnBvaW50cyYmCm4ucG9pbnRzLnJldmVyc2UoKTt2YXIgdT1uLmdldFRlcm1pbmFsUG9pbnQoITApLHA9bi5nZXRUZXJtaW5hbFBvaW50KCExKTtuLnNldFRlcm1pbmFsUG9pbnQodSwhMSk7bi5zZXRUZXJtaW5hbFBvaW50KHAsITApO2Uuc2V0R2VvbWV0cnkoZixuKTt2YXIgdD10aGlzLnZpZXcuZ2V0U3RhdGUoZiksQT10aGlzLnZpZXcuZ2V0U3RhdGUoZyksbT10aGlzLnZpZXcuZ2V0U3RhdGUobCk7aWYobnVsbCE9dCl7dmFyIGs9bnVsbCE9QT90aGlzLmdldENvbm5lY3Rpb25Db25zdHJhaW50KHQsQSwhMCk6bnVsbCxTPW51bGwhPW0/dGhpcy5nZXRDb25uZWN0aW9uQ29uc3RyYWludCh0LG0sITEpOm51bGw7dGhpcy5zZXRDb25uZWN0aW9uQ29uc3RyYWludChmLGcsITAsUyk7dGhpcy5zZXRDb25uZWN0aW9uQ29uc3RyYWludChmLGwsITEsayl9Yy5wdXNoKGYpfX1lbHNlIGlmKGUuaXNWZXJ0ZXgoZikmJihuPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGYpLG51bGwhPW4pKXtuPW4uY2xvbmUoKTtuLngrPQpuLndpZHRoLzItbi5oZWlnaHQvMjtuLnkrPW4uaGVpZ2h0LzItbi53aWR0aC8yO3ZhciB5PW4ud2lkdGg7bi53aWR0aD1uLmhlaWdodDtuLmhlaWdodD15O2Uuc2V0R2VvbWV0cnkoZixuKTt2YXIgdj10aGlzLnZpZXcuZ2V0U3RhdGUoZik7aWYobnVsbCE9dil7dmFyIEs9W214Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNULG14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSCxteENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVCxteENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEhdLHg9bXhVdGlscy5nZXRWYWx1ZSh2LnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCk7dGhpcy5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixLW214VXRpbHMubW9kKG14VXRpbHMuaW5kZXhPZihLLHgpKyhiPy0xOjEpLEsubGVuZ3RoKV0sW2ZdKX1jLnB1c2goZil9fX1maW5hbGx5e2UuZW5kVXBkYXRlKCl9cmV0dXJuIGN9O0dyYXBoLnByb3RvdHlwZS5zdGVuY2lsSGFzUGxhY2Vob2xkZXJzPQpmdW5jdGlvbihhKXtpZihudWxsIT1hJiZudWxsIT1hLmZnTm9kZSlmb3IoYT1hLmZnTm9kZS5maXJzdENoaWxkO251bGwhPWE7KXtpZigidGV4dCI9PWEubm9kZU5hbWUmJiIxIj09YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVycyIpKXJldHVybiEwO2E9YS5uZXh0U2libGluZ31yZXR1cm4hMX07R3JhcGgucHJvdG90eXBlLnByb2Nlc3NDaGFuZ2U9ZnVuY3Rpb24oYSl7bXhHcmFwaC5wcm90b3R5cGUucHJvY2Vzc0NoYW5nZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YSBpbnN0YW5jZW9mIG14VmFsdWVDaGFuZ2UmJm51bGwhPWEuY2VsbCYmbnVsbCE9YS5jZWxsLnZhbHVlJiYib2JqZWN0Ij09dHlwZW9mIGEuY2VsbC52YWx1ZSYmdGhpcy5pbnZhbGlkYXRlRGVzY2VuZGFudHNXaXRoUGxhY2Vob2xkZXJzKGEuY2VsbCl9O0dyYXBoLnByb3RvdHlwZS5pbnZhbGlkYXRlRGVzY2VuZGFudHNXaXRoUGxhY2Vob2xkZXJzPWZ1bmN0aW9uKGEpe2E9dGhpcy5tb2RlbC5nZXREZXNjZW5kYW50cyhhKTsKaWYoMDxhLmxlbmd0aClmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGU9dGhpcy52aWV3LmdldFN0YXRlKGFbYl0pO251bGwhPWUmJm51bGwhPWUuc2hhcGUmJm51bGwhPWUuc2hhcGUuc3RlbmNpbCYmdGhpcy5zdGVuY2lsSGFzUGxhY2Vob2xkZXJzKGUuc2hhcGUuc3RlbmNpbCk/dGhpcy5yZW1vdmVTdGF0ZUZvckNlbGwoYVtiXSk6dGhpcy5pc1JlcGxhY2VQbGFjZWhvbGRlcnMoYVtiXSkmJnRoaXMudmlldy5pbnZhbGlkYXRlKGFbYl0sITEsITEpfX07R3JhcGgucHJvdG90eXBlLnJlcGxhY2VFbGVtZW50PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBlPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG51bGwhPWI/Yjoic3BhbiIpLGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYS5hdHRyaWJ1dGVzKTthdHRyPWMucG9wKCk7KWUuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsYXR0ci5ub2RlVmFsdWUpO2UuaW5uZXJIVE1MPWEuaW5uZXJIVE1MO2EucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZSwKYSl9O0dyYXBoLnByb3RvdHlwZS5wcm9jZXNzRWxlbWVudHM9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKWZvcih2YXIgZT1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCIqIiksYz0wO2M8ZS5sZW5ndGg7YysrKWIoZVtjXSl9O0dyYXBoLnByb3RvdHlwZS51cGRhdGVMYWJlbEVsZW1lbnRzPWZ1bmN0aW9uKGEsYixlKXthPW51bGwhPWE/YTp0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7Zm9yKHZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQ9MDtkPGEubGVuZ3RoO2QrKylpZih0aGlzLmlzSHRtbExhYmVsKGFbZF0pKXt2YXIgZj10aGlzLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKGFbZF0pO2lmKG51bGwhPWYmJjA8Zi5sZW5ndGgpe2MuaW5uZXJIVE1MPWY7Zm9yKHZhciBnPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobnVsbCE9ZT9lOiIqIiksbD0wO2w8Zy5sZW5ndGg7bCsrKWIoZ1tsXSk7Yy5pbm5lckhUTUwhPWYmJnRoaXMuY2VsbExhYmVsQ2hhbmdlZChhW2RdLGMuaW5uZXJIVE1MKX19fTsKR3JhcGgucHJvdG90eXBlLmNlbGxMYWJlbENoYW5nZWQ9ZnVuY3Rpb24oYSxiLGUpe2I9R3JhcGguemFwR3JlbWxpbnMoYik7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtpZihudWxsIT1hLnZhbHVlJiYib2JqZWN0Ij09dHlwZW9mIGEudmFsdWUpe2lmKHRoaXMuaXNSZXBsYWNlUGxhY2Vob2xkZXJzKGEpJiZudWxsIT1hLmdldEF0dHJpYnV0ZSgicGxhY2Vob2xkZXIiKSlmb3IodmFyIGM9YS5nZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVyIiksZD1hO251bGwhPWQ7KXtpZihkPT10aGlzLm1vZGVsLmdldFJvb3QoKXx8bnVsbCE9ZC52YWx1ZSYmIm9iamVjdCI9PXR5cGVvZiBkLnZhbHVlJiZkLmhhc0F0dHJpYnV0ZShjKSl7dGhpcy5zZXRBdHRyaWJ1dGVGb3JDZWxsKGQsYyxiKTticmVha31kPXRoaXMubW9kZWwuZ2V0UGFyZW50KGQpfXZhciBmPWEudmFsdWUuY2xvbmVOb2RlKCEwKTtmLnNldEF0dHJpYnV0ZSgibGFiZWwiLGIpO2I9Zn1teEdyYXBoLnByb3RvdHlwZS5jZWxsTGFiZWxDaGFuZ2VkLmFwcGx5KHRoaXMsCmFyZ3VtZW50cyl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmNlbGxzUmVtb3ZlZD1mdW5jdGlvbihhKXtpZihudWxsIT1hKXtmb3IodmFyIGI9bmV3IG14RGljdGlvbmFyeSxlPTA7ZTxhLmxlbmd0aDtlKyspYi5wdXQoYVtlXSwhMCk7Zm9yKHZhciBjPVtdLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtlXSk7bnVsbD09ZHx8Yi5nZXQoZCl8fChiLnB1dChkLCEwKSxjLnB1c2goZCkpfWZvcihlPTA7ZTxjLmxlbmd0aDtlKyspaWYoZD10aGlzLnZpZXcuZ2V0U3RhdGUoY1tlXSksbnVsbCE9ZCYmKHRoaXMubW9kZWwuaXNFZGdlKGQuY2VsbCl8fHRoaXMubW9kZWwuaXNWZXJ0ZXgoZC5jZWxsKSkmJnRoaXMuaXNDZWxsRGVsZXRhYmxlKGQuY2VsbCkmJnRoaXMuaXNUcmFuc3BhcmVudFN0YXRlKGQpKXtmb3IodmFyIGY9ITAsZz0wO2c8dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KGQuY2VsbCkmJmY7ZysrKWIuZ2V0KHRoaXMubW9kZWwuZ2V0Q2hpbGRBdChkLmNlbGwsCmcpKXx8KGY9ITEpO2YmJmEucHVzaChkLmNlbGwpfX1teEdyYXBoLnByb3RvdHlwZS5jZWxsc1JlbW92ZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtHcmFwaC5wcm90b3R5cGUucmVtb3ZlQ2VsbHNBZnRlclVuZ3JvdXA9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGU9MDtlPGEubGVuZ3RoO2UrKyl0aGlzLmlzQ2VsbERlbGV0YWJsZShhW2VdKSYmdGhpcy5pc1RyYW5zcGFyZW50U3RhdGUodGhpcy52aWV3LmdldFN0YXRlKGFbZV0pKSYmYi5wdXNoKGFbZV0pO2E9YjtteEdyYXBoLnByb3RvdHlwZS5yZW1vdmVDZWxsc0FmdGVyVW5ncm91cC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0dyYXBoLnByb3RvdHlwZS5zZXRMaW5rRm9yQ2VsbD1mdW5jdGlvbihhLGIpe3RoaXMuc2V0QXR0cmlidXRlRm9yQ2VsbChhLCJsaW5rIixiKX07R3JhcGgucHJvdG90eXBlLnNldFRvb2x0aXBGb3JDZWxsPWZ1bmN0aW9uKGEsYil7dGhpcy5zZXRBdHRyaWJ1dGVGb3JDZWxsKGEsInRvb2x0aXAiLGIpfTsKR3JhcGgucHJvdG90eXBlLmdldEF0dHJpYnV0ZUZvckNlbGw9ZnVuY3Rpb24oYSxiLGUpe2E9bnVsbCE9YS52YWx1ZSYmIm9iamVjdCI9PT10eXBlb2YgYS52YWx1ZT9hLnZhbHVlLmdldEF0dHJpYnV0ZShiKTpudWxsO3JldHVybiBudWxsIT1hP2E6ZX07R3JhcGgucHJvdG90eXBlLnNldEF0dHJpYnV0ZUZvckNlbGw9ZnVuY3Rpb24oYSxiLGUpe3ZhciBjO251bGwhPWEudmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYS52YWx1ZT9jPWEudmFsdWUuY2xvbmVOb2RlKCEwKTooYz1teFV0aWxzLmNyZWF0ZVhtbERvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgiVXNlck9iamVjdCIpLGMuc2V0QXR0cmlidXRlKCJsYWJlbCIsYS52YWx1ZXx8IiIpKTtudWxsIT1lP2Muc2V0QXR0cmlidXRlKGIsZSk6Yy5yZW1vdmVBdHRyaWJ1dGUoYik7dGhpcy5tb2RlbC5zZXRWYWx1ZShhLGMpfTt2YXIgZz1HcmFwaC5wcm90b3R5cGUuaXNFeHRlbmRQYXJlbnQ7R3JhcGgucHJvdG90eXBlLmlzRXh0ZW5kUGFyZW50PQpmdW5jdGlvbihhKXtyZXR1cm4gZy5hcHBseSh0aGlzLGFyZ3VtZW50cykmJiF0aGlzLmlzVGFibGUoYSl9O3ZhciBuPUdyYXBoLnByb3RvdHlwZS5nZXREcm9wVGFyZ2V0O0dyYXBoLnByb3RvdHlwZS5nZXREcm9wVGFyZ2V0PWZ1bmN0aW9uKGEsYixlLGMpe3RoaXMuZ2V0TW9kZWwoKTtpZihteEV2ZW50LmlzQWx0RG93bihiKSlyZXR1cm4gbnVsbDtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZih0aGlzLm1vZGVsLmlzRWRnZSh0aGlzLm1vZGVsLmdldFBhcmVudChhW2RdKSkpcmV0dXJuIG51bGw7Zm9yKHZhciBmPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpLGc9ITAsZD0wO2Q8YS5sZW5ndGgmJmc7ZCsrKWc9ZyYmdGhpcy5pc1RhYmxlUm93KGFbZF0pO2cmJih0aGlzLmlzVGFibGVDZWxsKGYpJiYoZj10aGlzLm1vZGVsLmdldFBhcmVudChmKSksdGhpcy5pc1RhYmxlUm93KGYpJiYoZj10aGlzLm1vZGVsLmdldFBhcmVudChmKSksdGhpcy5pc1RhYmxlKGYpfHwoZj1udWxsKSk7CnJldHVybiBmfTtHcmFwaC5wcm90b3R5cGUuY2xpY2s9ZnVuY3Rpb24oYSl7bXhHcmFwaC5wcm90b3R5cGUuY2xpY2suY2FsbCh0aGlzLGEpO3RoaXMuZmlyc3RDbGlja1N0YXRlPWEuZ2V0U3RhdGUoKTt0aGlzLmZpcnN0Q2xpY2tTb3VyY2U9YS5nZXRTb3VyY2UoKX07R3JhcGgucHJvdG90eXBlLmRibENsaWNrPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5pc0VuYWJsZWQoKSl7dmFyIGU9bXhVdGlscy5jb252ZXJ0UG9pbnQodGhpcy5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSk7aWYobnVsbCE9YSYmIXRoaXMubW9kZWwuaXNWZXJ0ZXgoYikpe3ZhciBjPXRoaXMubW9kZWwuaXNFZGdlKGIpP3RoaXMudmlldy5nZXRTdGF0ZShiKTpudWxsLGQ9bXhFdmVudC5nZXRTb3VyY2UoYSk7dGhpcy5maXJzdENsaWNrU3RhdGUhPWN8fHRoaXMuZmlyc3RDbGlja1NvdXJjZSE9ZHx8bnVsbCE9YyYmbnVsbCE9Yy50ZXh0JiZudWxsIT1jLnRleHQubm9kZSYmCm51bGwhPWMudGV4dC5ib3VuZGluZ0JveCYmKG14VXRpbHMuY29udGFpbnMoYy50ZXh0LmJvdW5kaW5nQm94LGUueCxlLnkpfHxteFV0aWxzLmlzQW5jZXN0b3JOb2RlKGMudGV4dC5ub2RlLG14RXZlbnQuZ2V0U291cmNlKGEpKSl8fChudWxsIT1jfHx0aGlzLmlzQ2VsbExvY2tlZCh0aGlzLmdldERlZmF1bHRQYXJlbnQoKSkpJiYobnVsbD09Y3x8dGhpcy5pc0NlbGxMb2NrZWQoYy5jZWxsKSl8fCEobnVsbCE9Y3x8bXhDbGllbnQuSVNfVk1MJiZkPT10aGlzLnZpZXcuZ2V0Q2FudmFzKCl8fG14Q2xpZW50LklTX1NWRyYmZD09dGhpcy52aWV3LmdldENhbnZhcygpLm93bmVyU1ZHRWxlbWVudCl8fChudWxsPT1jJiYoYz10aGlzLnZpZXcuZ2V0U3RhdGUodGhpcy5nZXRDZWxsQXQoZS54LGUueSkpKSxiPXRoaXMuYWRkVGV4dChlLngsZS55LGMpKX1teEdyYXBoLnByb3RvdHlwZS5kYmxDbGljay5jYWxsKHRoaXMsYSxiKX19O0dyYXBoLnByb3RvdHlwZS5nZXRJbnNlcnRQb2ludD1mdW5jdGlvbigpe3ZhciBhPQp0aGlzLmdldEdyaWRTaXplKCksYj10aGlzLmNvbnRhaW5lci5zY3JvbGxMZWZ0L3RoaXMudmlldy5zY2FsZS10aGlzLnZpZXcudHJhbnNsYXRlLngsZT10aGlzLmNvbnRhaW5lci5zY3JvbGxUb3AvdGhpcy52aWV3LnNjYWxlLXRoaXMudmlldy50cmFuc2xhdGUueTtpZih0aGlzLnBhZ2VWaXNpYmxlKXZhciBjPXRoaXMuZ2V0UGFnZUxheW91dCgpLGQ9dGhpcy5nZXRQYWdlU2l6ZSgpLGI9TWF0aC5tYXgoYixjLngqZC53aWR0aCksZT1NYXRoLm1heChlLGMueSpkLmhlaWdodCk7cmV0dXJuIG5ldyBteFBvaW50KHRoaXMuc25hcChiK2EpLHRoaXMuc25hcChlK2EpKX07R3JhcGgucHJvdG90eXBlLmdldEZyZWVJbnNlcnRQb2ludD1mdW5jdGlvbigpe3ZhciBhPXRoaXMudmlldyxiPXRoaXMuZ2V0R3JhcGhCb3VuZHMoKSxlPXRoaXMuZ2V0SW5zZXJ0UG9pbnQoKSxjPXRoaXMuc25hcChNYXRoLnJvdW5kKE1hdGgubWF4KGUueCxiLngvYS5zY2FsZS1hLnRyYW5zbGF0ZS54KygwPT1iLndpZHRoPwoyKnRoaXMuZ3JpZFNpemU6MCkpKSksYT10aGlzLnNuYXAoTWF0aC5yb3VuZChNYXRoLm1heChlLnksKGIueStiLmhlaWdodCkvYS5zY2FsZS1hLnRyYW5zbGF0ZS55KzIqdGhpcy5ncmlkU2l6ZSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYyxhKX07R3JhcGgucHJvdG90eXBlLmdldENlbnRlckluc2VydFBvaW50PWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOm5ldyBteFJlY3RhbmdsZTtyZXR1cm4gbXhVdGlscy5oYXNTY3JvbGxiYXJzKHRoaXMuY29udGFpbmVyKT9uZXcgbXhQb2ludCh0aGlzLnNuYXAoKHRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQrdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgvMikvdGhpcy52aWV3LnNjYWxlLXRoaXMudmlldy50cmFuc2xhdGUueC1hLndpZHRoLzIpLHRoaXMuc25hcCgodGhpcy5jb250YWluZXIuc2Nyb2xsVG9wK3RoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodC8yKS90aGlzLnZpZXcuc2NhbGUtdGhpcy52aWV3LnRyYW5zbGF0ZS55LWEuaGVpZ2h0LwoyKSk6bmV3IG14UG9pbnQodGhpcy5zbmFwKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLzIvdGhpcy52aWV3LnNjYWxlLXRoaXMudmlldy50cmFuc2xhdGUueC1hLndpZHRoLzIpLHRoaXMuc25hcCh0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQvMi90aGlzLnZpZXcuc2NhbGUtdGhpcy52aWV3LnRyYW5zbGF0ZS55LWEuaGVpZ2h0LzIpKX07R3JhcGgucHJvdG90eXBlLmlzTW91c2VJbnNlcnRQb2ludD1mdW5jdGlvbigpe3JldHVybiExfTtHcmFwaC5wcm90b3R5cGUuYWRkVGV4dD1mdW5jdGlvbihhLGIsZSl7dmFyIGM9bmV3IG14Q2VsbDtjLnZhbHVlPSJUZXh0IjtjLmdlb21ldHJ5PW5ldyBteEdlb21ldHJ5KDAsMCwwLDApO2MudmVydGV4PSEwO2lmKG51bGwhPWUmJnRoaXMubW9kZWwuaXNFZGdlKGUuY2VsbCkpe2Muc3R5bGU9ImVkZ2VMYWJlbDtodG1sPTE7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3Jlc2l6YWJsZT0wO3BvaW50cz1bXTsiO2MuZ2VvbWV0cnkucmVsYXRpdmU9CiEwO2MuY29ubmVjdGFibGU9ITE7dmFyIGQ9dGhpcy52aWV3LmdldFJlbGF0aXZlUG9pbnQoZSxhLGIpO2MuZ2VvbWV0cnkueD1NYXRoLnJvdW5kKDFFNCpkLngpLzFFNDtjLmdlb21ldHJ5Lnk9TWF0aC5yb3VuZChkLnkpO2MuZ2VvbWV0cnkub2Zmc2V0PW5ldyBteFBvaW50KDAsMCk7dmFyIGQ9dGhpcy52aWV3LmdldFBvaW50KGUsYy5nZW9tZXRyeSksZj10aGlzLnZpZXcuc2NhbGU7Yy5nZW9tZXRyeS5vZmZzZXQ9bmV3IG14UG9pbnQoTWF0aC5yb3VuZCgoYS1kLngpL2YpLE1hdGgucm91bmQoKGItZC55KS9mKSl9ZWxzZSBkPXRoaXMudmlldy50cmFuc2xhdGUsYy5zdHlsZT0idGV4dDtodG1sPTE7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3Jlc2l6YWJsZT0wO3BvaW50cz1bXTsiLGMuZ2VvbWV0cnkud2lkdGg9NDAsYy5nZW9tZXRyeS5oZWlnaHQ9MjAsYy5nZW9tZXRyeS54PU1hdGgucm91bmQoYS90aGlzLnZpZXcuc2NhbGUpLWQueC0obnVsbCE9ZT9lLm9yaWdpbi54OgowKSxjLmdlb21ldHJ5Lnk9TWF0aC5yb3VuZChiL3RoaXMudmlldy5zY2FsZSktZC55LShudWxsIT1lP2Uub3JpZ2luLnk6MCksYy5zdHlsZSs9ImF1dG9zaXplPTE7Ijt0aGlzLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dGhpcy5hZGRDZWxscyhbY10sbnVsbCE9ZT9lLmNlbGw6bnVsbCksdGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInRleHRJbnNlcnRlZCIsImNlbGxzIixbY10pKSx0aGlzLmF1dG9TaXplQ2VsbChjKX1maW5hbGx5e3RoaXMuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX1yZXR1cm4gY307R3JhcGgucHJvdG90eXBlLmFkZENsaWNrSGFuZGxlcj1mdW5jdGlvbihhLGIsZSl7dmFyIGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpO2lmKG51bGwhPWEpZm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBjPXRoaXMuZ2V0QWJzb2x1dGVVcmwoYVtlXS5nZXRBdHRyaWJ1dGUoImhyZWYiKSk7Cm51bGwhPWMmJihhW2VdLnNldEF0dHJpYnV0ZSgicmVsIix0aGlzLmxpbmtSZWxhdGlvbiksYVtlXS5zZXRBdHRyaWJ1dGUoImhyZWYiLGMpLG51bGwhPWImJm14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhhW2VdLG51bGwsbnVsbCxiKSl9fSk7dGhpcy5tb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxjKTtjKCk7dmFyIGQ9dGhpcy5jb250YWluZXIuc3R5bGUuY3Vyc29yLGY9dGhpcy5nZXRUb2xlcmFuY2UoKSxnPXRoaXMsbD17Y3VycmVudFN0YXRlOm51bGwsY3VycmVudExpbms6bnVsbCxoaWdobGlnaHQ6bnVsbCE9YSYmIiIhPWEmJmEhPW14Q29uc3RhbnRzLk5PTkU/bmV3IG14Q2VsbEhpZ2hsaWdodChnLGEsNCk6bnVsbCxzdGFydFg6MCxzdGFydFk6MCxzY3JvbGxMZWZ0OjAsc2Nyb2xsVG9wOjAsdXBkYXRlQ3VycmVudFN0YXRlOmZ1bmN0aW9uKGEpe3ZhciBiPWEuc291cmNlU3RhdGU7aWYobnVsbD09Ynx8bnVsbD09Zy5nZXRMaW5rRm9yQ2VsbChiLmNlbGwpKWE9CmcuZ2V0Q2VsbEF0KGEuZ2V0R3JhcGhYKCksYS5nZXRHcmFwaFkoKSxudWxsLG51bGwsbnVsbCxmdW5jdGlvbihhLGIsZSl7cmV0dXJuIG51bGw9PWcuZ2V0TGlua0ZvckNlbGwoYS5jZWxsKX0pLGI9Zy52aWV3LmdldFN0YXRlKGEpO2IhPXRoaXMuY3VycmVudFN0YXRlJiYobnVsbCE9dGhpcy5jdXJyZW50U3RhdGUmJnRoaXMuY2xlYXIoKSx0aGlzLmN1cnJlbnRTdGF0ZT1iLG51bGwhPXRoaXMuY3VycmVudFN0YXRlJiZ0aGlzLmFjdGl2YXRlKHRoaXMuY3VycmVudFN0YXRlKSl9LG1vdXNlRG93bjpmdW5jdGlvbihhLGIpe3RoaXMuc3RhcnRYPWIuZ2V0R3JhcGhYKCk7dGhpcy5zdGFydFk9Yi5nZXRHcmFwaFkoKTt0aGlzLnNjcm9sbExlZnQ9Zy5jb250YWluZXIuc2Nyb2xsTGVmdDt0aGlzLnNjcm9sbFRvcD1nLmNvbnRhaW5lci5zY3JvbGxUb3A7bnVsbD09dGhpcy5jdXJyZW50TGluayYmImF1dG8iPT1nLmNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyYmKGcuY29udGFpbmVyLnN0eWxlLmN1cnNvcj0KIm1vdmUiKTt0aGlzLnVwZGF0ZUN1cnJlbnRTdGF0ZShiKX0sbW91c2VNb3ZlOmZ1bmN0aW9uKGEsYil7aWYoZy5pc01vdXNlRG93bil7aWYobnVsbCE9dGhpcy5jdXJyZW50TGluayl7dmFyIGU9TWF0aC5hYnModGhpcy5zdGFydFgtYi5nZXRHcmFwaFgoKSksYz1NYXRoLmFicyh0aGlzLnN0YXJ0WS1iLmdldEdyYXBoWSgpKTsoZT5mfHxjPmYpJiZ0aGlzLmNsZWFyKCl9fWVsc2V7Zm9yKGU9Yi5nZXRTb3VyY2UoKTtudWxsIT1lJiYiYSIhPWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTspZT1lLnBhcmVudE5vZGU7bnVsbCE9ZT90aGlzLmNsZWFyKCk6KG51bGwhPWcudG9vbHRpcEhhbmRsZXImJm51bGwhPXRoaXMuY3VycmVudExpbmsmJm51bGwhPXRoaXMuY3VycmVudFN0YXRlJiZnLnRvb2x0aXBIYW5kbGVyLnJlc2V0KGIsITAsdGhpcy5jdXJyZW50U3RhdGUpLChudWxsPT10aGlzLmN1cnJlbnRTdGF0ZXx8Yi5nZXRTdGF0ZSgpIT10aGlzLmN1cnJlbnRTdGF0ZSYmbnVsbCE9Yi5zb3VyY2VTdGF0ZXx8CiFnLmludGVyc2VjdHModGhpcy5jdXJyZW50U3RhdGUsYi5nZXRHcmFwaFgoKSxiLmdldEdyYXBoWSgpKSkmJnRoaXMudXBkYXRlQ3VycmVudFN0YXRlKGIpKX19LG1vdXNlVXA6ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGQ9Yy5nZXRTb3VyY2UoKSxsPWMuZ2V0RXZlbnQoKTtudWxsIT1kJiYiYSIhPWQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTspZD1kLnBhcmVudE5vZGU7bnVsbD09ZCYmTWF0aC5hYnModGhpcy5zY3JvbGxMZWZ0LWcuY29udGFpbmVyLnNjcm9sbExlZnQpPGYmJk1hdGguYWJzKHRoaXMuc2Nyb2xsVG9wLWcuY29udGFpbmVyLnNjcm9sbFRvcCk8ZiYmKG51bGw9PWMuc291cmNlU3RhdGV8fCFjLmlzU291cmNlKGMuc291cmNlU3RhdGUuY29udHJvbCkpJiYoKG14RXZlbnQuaXNMZWZ0TW91c2VCdXR0b24obCl8fG14RXZlbnQuaXNNaWRkbGVNb3VzZUJ1dHRvbihsKSkmJiFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGwpfHxteEV2ZW50LmlzVG91Y2hFdmVudChsKSkmJihudWxsIT0KdGhpcy5jdXJyZW50TGluaz8oZD1nLmlzQmxhbmtMaW5rKHRoaXMuY3VycmVudExpbmspLCJkYXRhOiIhPT10aGlzLmN1cnJlbnRMaW5rLnN1YnN0cmluZygwLDUpJiZkfHxudWxsPT1ifHxiKGwsdGhpcy5jdXJyZW50TGluayksbXhFdmVudC5pc0NvbnN1bWVkKGwpfHwobD1teEV2ZW50LmlzTWlkZGxlTW91c2VCdXR0b24obCk/Il9ibGFuayI6ZD9nLmxpbmtUYXJnZXQ6Il90b3AiLGcub3BlbkxpbmsodGhpcy5jdXJyZW50TGluayxsKSxjLmNvbnN1bWUoKSkpOm51bGwhPWUmJiFjLmlzQ29uc3VtZWQoKSYmTWF0aC5hYnModGhpcy5zY3JvbGxMZWZ0LWcuY29udGFpbmVyLnNjcm9sbExlZnQpPGYmJk1hdGguYWJzKHRoaXMuc2Nyb2xsVG9wLWcuY29udGFpbmVyLnNjcm9sbFRvcCk8ZiYmTWF0aC5hYnModGhpcy5zdGFydFgtYy5nZXRHcmFwaFgoKSk8ZiYmTWF0aC5hYnModGhpcy5zdGFydFktYy5nZXRHcmFwaFkoKSk8ZiYmZShjLmdldEV2ZW50KCkpKTt0aGlzLmNsZWFyKCl9LGFjdGl2YXRlOmZ1bmN0aW9uKGEpe3RoaXMuY3VycmVudExpbms9CmcuZ2V0QWJzb2x1dGVVcmwoZy5nZXRMaW5rRm9yQ2VsbChhLmNlbGwpKTtudWxsIT10aGlzLmN1cnJlbnRMaW5rJiYoZy5jb250YWluZXIuc3R5bGUuY3Vyc29yPSJwb2ludGVyIixudWxsIT10aGlzLmhpZ2hsaWdodCYmdGhpcy5oaWdobGlnaHQuaGlnaGxpZ2h0KGEpKX0sY2xlYXI6ZnVuY3Rpb24oKXtudWxsIT1nLmNvbnRhaW5lciYmKGcuY29udGFpbmVyLnN0eWxlLmN1cnNvcj1kKTt0aGlzLmN1cnJlbnRMaW5rPXRoaXMuY3VycmVudFN0YXRlPW51bGw7bnVsbCE9dGhpcy5oaWdobGlnaHQmJnRoaXMuaGlnaGxpZ2h0LmhpZGUoKTtudWxsIT1nLnRvb2x0aXBIYW5kbGVyJiZnLnRvb2x0aXBIYW5kbGVyLmhpZGUoKX19O2cuY2xpY2s9ZnVuY3Rpb24oYSl7fTtnLmFkZE1vdXNlTGlzdGVuZXIobCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2VsZWF2ZSIsZnVuY3Rpb24oYSl7bC5jbGVhcigpfSl9O0dyYXBoLnByb3RvdHlwZS5kdXBsaWNhdGVDZWxscz1mdW5jdGlvbihhLApiKXthPW51bGwhPWE/YTp0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCk7Yj1udWxsIT1iP2I6ITA7YT10aGlzLm1vZGVsLmdldFRvcG1vc3RDZWxscyhhKTt2YXIgZT10aGlzLmdldE1vZGVsKCksYz10aGlzLmdyaWRTaXplLGQ9W107ZS5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGY9dGhpcy5jbG9uZUNlbGxzKGEsITEsbnVsbCwhMCksZz0wO2c8YS5sZW5ndGg7ZysrKXt2YXIgbD1lLmdldFBhcmVudChhW2ddKSxuPXRoaXMubW92ZUNlbGxzKFtmW2ddXSxjLGMsITEpWzBdO2QucHVzaChuKTtpZihiKWUuYWRkKGwsZltnXSk7ZWxzZXt2YXIgdT1sLmdldEluZGV4KGFbZ10pO2UuYWRkKGwsZltnXSx1KzEpfWlmKHRoaXMuaXNUYWJsZShsKSl7dmFyIHA9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZltnXSksdD10aGlzLmdldENlbGxHZW9tZXRyeShsKTtudWxsIT1wJiZudWxsIT10JiYodD10LmNsb25lKCksdC5oZWlnaHQrPXAuaGVpZ2h0LGUuc2V0R2VvbWV0cnkobCx0KSl9fX1maW5hbGx5e2UuZW5kVXBkYXRlKCl9cmV0dXJuIGR9OwpHcmFwaC5wcm90b3R5cGUuaW5zZXJ0SW1hZ2U9ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGwhPWEmJm51bGwhPXRoaXMuY2VsbEVkaXRvci50ZXh0YXJlYSl7Zm9yKHZhciBjPXRoaXMuY2VsbEVkaXRvci50ZXh0YXJlYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaW1nIiksZD1bXSxmPTA7ZjxjLmxlbmd0aDtmKyspZC5wdXNoKGNbZl0pO2RvY3VtZW50LmV4ZWNDb21tYW5kKCJpbnNlcnRpbWFnZSIsITEsYSk7YT10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImltZyIpO2lmKGEubGVuZ3RoPT1kLmxlbmd0aCsxKWZvcihmPWEubGVuZ3RoLTE7MDw9ZjtmLS0paWYoMD09Znx8YVtmXSE9ZFtmLTFdKXthW2ZdLnNldEF0dHJpYnV0ZSgid2lkdGgiLGIpO2FbZl0uc2V0QXR0cmlidXRlKCJoZWlnaHQiLGUpO2JyZWFrfX19O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRMaW5rPWZ1bmN0aW9uKGEpe2lmKG51bGwhPXRoaXMuY2VsbEVkaXRvci50ZXh0YXJlYSlpZigwPT0KYS5sZW5ndGgpZG9jdW1lbnQuZXhlY0NvbW1hbmQoInVubGluayIsITEpO2Vsc2UgaWYobXhDbGllbnQuSVNfRkYpe2Zvcih2YXIgYj10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKSxlPVtdLGM9MDtjPGIubGVuZ3RoO2MrKyllLnB1c2goYltjXSk7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImNyZWF0ZWxpbmsiLCExLG14VXRpbHMudHJpbShhKSk7Yj10aGlzLmNlbGxFZGl0b3IudGV4dGFyZWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKTtpZihiLmxlbmd0aD09ZS5sZW5ndGgrMSlmb3IoYz1iLmxlbmd0aC0xOzA8PWM7Yy0tKWlmKGJbY10hPWVbYy0xXSl7Zm9yKGI9YltjXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpOzA8Yi5sZW5ndGg7KXtmb3IoZT1iWzBdLnBhcmVudE5vZGU7bnVsbCE9YlswXS5maXJzdENoaWxkOyllLmluc2VydEJlZm9yZShiWzBdLmZpcnN0Q2hpbGQsYlswXSk7ZS5yZW1vdmVDaGlsZChiWzBdKX1icmVha319ZWxzZSBkb2N1bWVudC5leGVjQ29tbWFuZCgiY3JlYXRlbGluayIsCiExLG14VXRpbHMudHJpbShhKSl9O0dyYXBoLnByb3RvdHlwZS5pc0NlbGxSZXNpemFibGU9ZnVuY3Rpb24oYSl7dmFyIGI9bXhHcmFwaC5wcm90b3R5cGUuaXNDZWxsUmVzaXphYmxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxlPXRoaXMuZ2V0Q3VycmVudENlbGxTdHlsZShhKTtyZXR1cm4hdGhpcy5pc1RhYmxlQ2VsbChhKSYmIXRoaXMuaXNUYWJsZVJvdyhhKSYmKGJ8fCIwIiE9bXhVdGlscy5nZXRWYWx1ZShlLG14Q29uc3RhbnRzLlNUWUxFX1JFU0laQUJMRSwiMSIpJiYid3JhcCI9PWVbbXhDb25zdGFudHMuU1RZTEVfV0hJVEVfU1BBQ0VdKX07R3JhcGgucHJvdG90eXBlLmRpc3RyaWJ1dGVDZWxscz1mdW5jdGlvbihhLGIpe251bGw9PWImJihiPXRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7aWYobnVsbCE9YiYmMTxiLmxlbmd0aCl7Zm9yKHZhciBlPVtdLGM9bnVsbCxkPW51bGwsZj0wO2Y8Yi5sZW5ndGg7ZisrKWlmKHRoaXMuZ2V0TW9kZWwoKS5pc1ZlcnRleChiW2ZdKSl7dmFyIGc9CnRoaXMudmlldy5nZXRTdGF0ZShiW2ZdKTtpZihudWxsIT1nKXt2YXIgbD1hP2cuZ2V0Q2VudGVyWCgpOmcuZ2V0Q2VudGVyWSgpLGM9bnVsbCE9Yz9NYXRoLm1heChjLGwpOmwsZD1udWxsIT1kP01hdGgubWluKGQsbCk6bDtlLnB1c2goZyl9fWlmKDI8ZS5sZW5ndGgpe2Uuc29ydChmdW5jdGlvbihiLGUpe3JldHVybiBhP2IueC1lLng6Yi55LWUueX0pO2c9dGhpcy52aWV3LnRyYW5zbGF0ZTtsPXRoaXMudmlldy5zY2FsZTtkPWQvbC0oYT9nLng6Zy55KTtjPWMvbC0oYT9nLng6Zy55KTt0aGlzLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBuPShjLWQpLyhlLmxlbmd0aC0xKSxjPWQsZj0xO2Y8ZS5sZW5ndGgtMTtmKyspe3ZhciB1PXRoaXMudmlldy5nZXRTdGF0ZSh0aGlzLm1vZGVsLmdldFBhcmVudChlW2ZdLmNlbGwpKSxwPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGVbZl0uY2VsbCksYz1jK247bnVsbCE9cCYmbnVsbCE9dSYmKHA9cC5jbG9uZSgpLGE/cC54PQpNYXRoLnJvdW5kKGMtcC53aWR0aC8yKS11Lm9yaWdpbi54OnAueT1NYXRoLnJvdW5kKGMtcC5oZWlnaHQvMiktdS5vcmlnaW4ueSx0aGlzLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkoZVtmXS5jZWxsLHApKX19ZmluYWxseXt0aGlzLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX1yZXR1cm4gYn07R3JhcGgucHJvdG90eXBlLmlzQ2xvbmVFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbXhDbGllbnQuSVNfTUFDJiZteEV2ZW50LmlzTWV0YURvd24oYSl8fG14RXZlbnQuaXNDb250cm9sRG93bihhKX07R3JhcGgucHJvdG90eXBlLmNyZWF0ZVN2Z0ltYWdlRXhwb3J0PWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14SW1hZ2VFeHBvcnQ7YS5nZXRMaW5rRm9yQ2VsbFN0YXRlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ2V0TGlua0ZvckNlbGwoYS5jZWxsKX0pO3JldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZ2V0U3ZnPWZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCwKbixwKXt2YXIgdT10aGlzLnVzZUNzc1RyYW5zZm9ybXM7dSYmKHRoaXMudXNlQ3NzVHJhbnNmb3Jtcz0hMSx0aGlzLnZpZXcucmV2YWxpZGF0ZSgpLHRoaXMuc2l6ZURpZENoYW5nZSgpKTt0cnl7Yj1udWxsIT1iP2I6MTtlPW51bGwhPWU/ZTowO2Q9bnVsbCE9ZD9kOiEwO2Y9bnVsbCE9Zj9mOiEwO2c9bnVsbCE9Zz9nOiEwO3ZhciB0PWZ8fGM/dGhpcy5nZXRHcmFwaEJvdW5kcygpOnRoaXMuZ2V0Qm91bmRpbmdCb3godGhpcy5nZXRTZWxlY3Rpb25DZWxscygpKTtpZihudWxsPT10KXRocm93IEVycm9yKG14UmVzb3VyY2VzLmdldCgiZHJhd2luZ0VtcHR5IikpO3ZhciBBPXRoaXMudmlldy5zY2FsZSxtPW14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKSxrPW51bGwhPW0uY3JlYXRlRWxlbWVudE5TP20uY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywic3ZnIik6bS5jcmVhdGVFbGVtZW50KCJzdmciKTtudWxsIT1hJiYobnVsbCE9ay5zdHlsZT9rLnN0eWxlLmJhY2tncm91bmRDb2xvcj0KYTprLnNldEF0dHJpYnV0ZSgic3R5bGUiLCJiYWNrZ3JvdW5kLWNvbG9yOiIrYSkpO251bGw9PW0uY3JlYXRlRWxlbWVudE5TPyhrLnNldEF0dHJpYnV0ZSgieG1sbnMiLG14Q29uc3RhbnRzLk5TX1NWRyksay5zZXRBdHRyaWJ1dGUoInhtbG5zOnhsaW5rIixteENvbnN0YW50cy5OU19YTElOSykpOmsuc2V0QXR0cmlidXRlTlMoImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvIiwieG1sbnM6eGxpbmsiLG14Q29uc3RhbnRzLk5TX1hMSU5LKTthPWIvQTt2YXIgeT1NYXRoLm1heCgxLE1hdGguY2VpbCh0LndpZHRoKmEpKzIqZSkrKHA/NTowKSx2PU1hdGgubWF4KDEsTWF0aC5jZWlsKHQuaGVpZ2h0KmEpKzIqZSkrKHA/NTowKTtrLnNldEF0dHJpYnV0ZSgidmVyc2lvbiIsIjEuMSIpO2suc2V0QXR0cmlidXRlKCJ3aWR0aCIseSsicHgiKTtrLnNldEF0dHJpYnV0ZSgiaGVpZ2h0Iix2KyJweCIpO2suc2V0QXR0cmlidXRlKCJ2aWV3Qm94IiwoZD8iLTAuNSAtMC41IjoiMCAwIikrCiIgIit5KyIgIit2KTttLmFwcGVuZENoaWxkKGspO3ZhciBLPW51bGwhPW0uY3JlYXRlRWxlbWVudE5TP20uY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZyIpOm0uY3JlYXRlRWxlbWVudCgiZyIpO2suYXBwZW5kQ2hpbGQoSyk7dmFyIHg9dGhpcy5jcmVhdGVTdmdDYW52YXMoSyk7eC5mb09mZnNldD1kPy0uNTowO3gudGV4dE9mZnNldD1kPy0uNTowO3guaW1hZ2VPZmZzZXQ9ZD8tLjU6MDt4LnRyYW5zbGF0ZShNYXRoLmZsb29yKChlL2ItdC54KS9BKSxNYXRoLmZsb29yKChlL2ItdC55KS9BKSk7dmFyIHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksUz14LmdldEFsdGVybmF0ZVRleHQ7eC5nZXRBbHRlcm5hdGVUZXh0PWZ1bmN0aW9uKGEsYixlLGMsZCxmLGcsbCxuLHAsa2EsdSx0KXtpZihudWxsIT1mJiYwPHRoaXMuc3RhdGUuZm9udFNpemUpdHJ5e214VXRpbHMuaXNOb2RlKGYpP2Y9Zi5pbm5lclRleHQ6KHEuaW5uZXJIVE1MPWYsZj1teFV0aWxzLmV4dHJhY3RUZXh0V2l0aFdoaXRlc3BhY2UocS5jaGlsZE5vZGVzKSk7CmZvcih2YXIgTWE9TWF0aC5jZWlsKDIqYy90aGlzLnN0YXRlLmZvbnRTaXplKSxBPVtdLGs9MCxtPTA7KDA9PU1hfHxrPE1hKSYmbTxmLmxlbmd0aDspe3ZhciB5PWYuY2hhckNvZGVBdChtKTtpZigxMD09eXx8MTM9PXkpe2lmKDA8aylicmVha31lbHNlIEEucHVzaChmLmNoYXJBdChtKSksMjU1PnkmJmsrKzttKyt9QS5sZW5ndGg8Zi5sZW5ndGgmJjE8Zi5sZW5ndGgtQS5sZW5ndGgmJihmPW14VXRpbHMudHJpbShBLmpvaW4oIiIpKSsiLi4uIik7cmV0dXJuIGZ9Y2F0Y2goVGEpe3JldHVybiBTLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lbHNlIHJldHVybiBTLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIHo9dGhpcy5iYWNrZ3JvdW5kSW1hZ2U7aWYobnVsbCE9eil7Yj1BL2I7dmFyIE09dGhpcy52aWV3LnRyYW5zbGF0ZSxJPW5ldyBteFJlY3RhbmdsZShNLngqYixNLnkqYix6LndpZHRoKmIsei5oZWlnaHQqYik7bXhVdGlscy5pbnRlcnNlY3RzKHQsSSkmJnguaW1hZ2UoTS54LApNLnksei53aWR0aCx6LmhlaWdodCx6LnNyYywhMCl9eC5zY2FsZShhKTt4LnRleHRFbmFibGVkPWc7bD1udWxsIT1sP2w6dGhpcy5jcmVhdGVTdmdJbWFnZUV4cG9ydCgpO3ZhciBRPWwuZHJhd0NlbGxTdGF0ZSxDPWwuZ2V0TGlua0ZvckNlbGxTdGF0ZTtsLmdldExpbmtGb3JDZWxsU3RhdGU9ZnVuY3Rpb24oYSxiKXt2YXIgZT1DLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gbnVsbD09ZXx8YS52aWV3LmdyYXBoLmlzQ3VzdG9tTGluayhlKT9udWxsOmV9O2wuZHJhd0NlbGxTdGF0ZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgZT1hLnZpZXcuZ3JhcGgsYz1lLmlzQ2VsbFNlbGVjdGVkKGEuY2VsbCksZD1lLm1vZGVsLmdldFBhcmVudChhLmNlbGwpOyFmJiYhYyYmbnVsbCE9ZDspYz1lLmlzQ2VsbFNlbGVjdGVkKGQpLGQ9ZS5tb2RlbC5nZXRQYXJlbnQoZCk7KGZ8fGMpJiZRLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bC5kcmF3U3RhdGUodGhpcy5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5tb2RlbC5yb290KSwKeCk7dGhpcy51cGRhdGVTdmdMaW5rcyhrLG4sITApO3RoaXMuYWRkRm9yZWlnbk9iamVjdFdhcm5pbmcoeCxrKTtyZXR1cm4ga31maW5hbGx5e3UmJih0aGlzLnVzZUNzc1RyYW5zZm9ybXM9ITAsdGhpcy52aWV3LnJldmFsaWRhdGUoKSx0aGlzLnNpemVEaWRDaGFuZ2UoKSl9fTtHcmFwaC5wcm90b3R5cGUuYWRkRm9yZWlnbk9iamVjdFdhcm5pbmc9ZnVuY3Rpb24oYSxiKXtpZigwPGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImZvcmVpZ25PYmplY3QiKS5sZW5ndGgpe3ZhciBlPWEuY3JlYXRlRWxlbWVudCgic3dpdGNoIiksYz1hLmNyZWF0ZUVsZW1lbnQoImciKTtjLnNldEF0dHJpYnV0ZSgicmVxdWlyZWRGZWF0dXJlcyIsImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSIpO3ZhciBkPWEuY3JlYXRlRWxlbWVudCgiYSIpO2Quc2V0QXR0cmlidXRlKCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoMCwtNSkiKTtudWxsPT1kLnNldEF0dHJpYnV0ZU5TfHwKYi5vd25lckRvY3VtZW50IT1kb2N1bWVudCYmbnVsbD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPyhkLnNldEF0dHJpYnV0ZSgieGxpbms6aHJlZiIsR3JhcGguZm9yZWlnbk9iamVjdFdhcm5pbmdMaW5rKSxkLnNldEF0dHJpYnV0ZSgidGFyZ2V0IiwiX2JsYW5rIikpOihkLnNldEF0dHJpYnV0ZU5TKG14Q29uc3RhbnRzLk5TX1hMSU5LLCJ4bGluazpocmVmIixHcmFwaC5mb3JlaWduT2JqZWN0V2FybmluZ0xpbmspLGQuc2V0QXR0cmlidXRlTlMobXhDb25zdGFudHMuTlNfWExJTkssInRhcmdldCIsIl9ibGFuayIpKTt2YXIgZj1hLmNyZWF0ZUVsZW1lbnQoInRleHQiKTtmLnNldEF0dHJpYnV0ZSgidGV4dC1hbmNob3IiLCJtaWRkbGUiKTtmLnNldEF0dHJpYnV0ZSgiZm9udC1zaXplIiwiMTBweCIpO2Yuc2V0QXR0cmlidXRlKCJ4IiwiNTAlIik7Zi5zZXRBdHRyaWJ1dGUoInkiLCIxMDAlIik7bXhVdGlscy53cml0ZShmLEdyYXBoLmZvcmVpZ25PYmplY3RXYXJuaW5nVGV4dCk7ZS5hcHBlbmRDaGlsZChjKTsKZC5hcHBlbmRDaGlsZChmKTtlLmFwcGVuZENoaWxkKGQpO2IuYXBwZW5kQ2hpbGQoZSl9fTtHcmFwaC5wcm90b3R5cGUudXBkYXRlU3ZnTGlua3M9ZnVuY3Rpb24oYSxiLGUpe2E9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLmdldEF0dHJpYnV0ZSgiaHJlZiIpO251bGw9PWQmJihkPWFbY10uZ2V0QXR0cmlidXRlKCJ4bGluazpocmVmIikpO251bGwhPWQmJihudWxsIT1iJiYvXmh0dHBzPzpcL1wvLy50ZXN0KGQpP2FbY10uc2V0QXR0cmlidXRlKCJ0YXJnZXQiLGIpOmUmJnRoaXMuaXNDdXN0b21MaW5rKGQpJiZhW2NdLnNldEF0dHJpYnV0ZSgiaHJlZiIsImphdmFzY3JpcHQ6dm9pZCgwKTsiKSl9fTtHcmFwaC5wcm90b3R5cGUuY3JlYXRlU3ZnQ2FudmFzPWZ1bmN0aW9uKGEpe2E9bmV3IG14U3ZnQ2FudmFzMkQoYSk7YS5wb2ludGVyRXZlbnRzPSEwO3JldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFbGVtZW50PQpmdW5jdGlvbigpe3ZhciBhPW51bGw7aWYod2luZG93LmdldFNlbGVjdGlvbil7dmFyIGI9d2luZG93LmdldFNlbGVjdGlvbigpO2IuZ2V0UmFuZ2VBdCYmYi5yYW5nZUNvdW50JiYoYT1iLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXIpfWVsc2UgZG9jdW1lbnQuc2VsZWN0aW9uJiYoYT1kb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5wYXJlbnRFbGVtZW50KCkpO3JldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50QnlOYW1lPWZ1bmN0aW9uKGEsYixlKXtmb3IoO251bGwhPWEmJmEubm9kZU5hbWUhPWI7KXtpZihhPT1lKXJldHVybiBudWxsO2E9YS5wYXJlbnROb2RlfXJldHVybiBhfTtHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50QnlOYW1lcz1mdW5jdGlvbihhLGIsZSl7Zm9yKDtudWxsIT1hJiYhKDA8PW14VXRpbHMuaW5kZXhPZihiLGEubm9kZU5hbWUpKTspe2lmKGE9PWUpcmV0dXJuIG51bGw7YT1hLnBhcmVudE5vZGV9cmV0dXJuIGF9OwpHcmFwaC5wcm90b3R5cGUuc2VsZWN0Tm9kZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO2lmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2lmKGI9d2luZG93LmdldFNlbGVjdGlvbigpLGIuZ2V0UmFuZ2VBdCYmYi5yYW5nZUNvdW50KXt2YXIgZT1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2Uuc2VsZWN0Tm9kZShhKTtiLnJlbW92ZUFsbFJhbmdlcygpO2IuYWRkUmFuZ2UoZSl9fWVsc2UoYj1kb2N1bWVudC5zZWxlY3Rpb24pJiYiQ29udHJvbCIhPWIudHlwZSYmKGE9Yi5jcmVhdGVSYW5nZSgpLGEuY29sbGFwc2UoITApLGU9Yi5jcmVhdGVSYW5nZSgpLGUuc2V0RW5kUG9pbnQoIlN0YXJ0VG9TdGFydCIsYSksZS5zZWxlY3QoKSl9O0dyYXBoLnByb3RvdHlwZS5kZWxldGVDZWxscz1mdW5jdGlvbihhLGIpe3ZhciBlPW51bGw7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5tb2RlbC5nZXRQYXJlbnQoYVtjXSk7CmlmKHRoaXMuaXNUYWJsZShkKSl7dmFyIGY9dGhpcy5nZXRDZWxsR2VvbWV0cnkoYVtjXSksZz10aGlzLmdldENlbGxHZW9tZXRyeShkKTtudWxsIT1mJiZudWxsIT1nJiYoZz1nLmNsb25lKCksZy5oZWlnaHQtPWYuaGVpZ2h0LHRoaXMubW9kZWwuc2V0R2VvbWV0cnkoZCxnKSl9fXZhciBsPXRoaXMuc2VsZWN0UGFyZW50QWZ0ZXJEZWxldGU/dGhpcy5tb2RlbC5nZXRQYXJlbnRzKGEpOm51bGw7dGhpcy5yZW1vdmVDZWxscyhhLGIpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX1pZihudWxsIT1sKWZvcihlPVtdLGM9MDtjPGwubGVuZ3RoO2MrKyl0aGlzLm1vZGVsLmNvbnRhaW5zKGxbY10pJiYodGhpcy5tb2RlbC5pc1ZlcnRleChsW2NdKXx8dGhpcy5tb2RlbC5pc0VkZ2UobFtjXSkpJiZlLnB1c2gobFtjXSl9cmV0dXJuIGV9O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRUYWJsZUNvbHVtbj1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0TW9kZWwoKTtlLmJlZ2luVXBkYXRlKCk7CnRyeXt2YXIgYz1hLGQ9MDtpZih0aGlzLmlzVGFibGVDZWxsKGEpKXZhciBmPWUuZ2V0UGFyZW50KGEpLGM9ZS5nZXRQYXJlbnQoZiksZD1teFV0aWxzLmluZGV4T2YoZS5nZXRDaGlsZENlbGxzKGYsITApLGEpO2Vsc2UgdGhpcy5pc1RhYmxlUm93KGEpP2M9ZS5nZXRQYXJlbnQoYSk6YT1lLmdldENoaWxkQ2VsbHMoYywhMClbMF0sYnx8KGQ9ZS5nZXRDaGlsZENlbGxzKGEsITApLmxlbmd0aC0xKTtmb3IodmFyIGc9ZS5nZXRDaGlsZENlbGxzKGMsITApLGw9R3JhcGgubWluVGFibGVDb2x1bW5XaWR0aCxmPTA7ZjxnLmxlbmd0aDtmKyspe3ZhciBuPWUuZ2V0Q2hpbGRDZWxscyhnW2ZdLCEwKVtkXSxwPWUuY2xvbmVDZWxsKG4sITEpLHU9dGhpcy5nZXRDZWxsR2VvbWV0cnkocCk7cC52YWx1ZT1udWxsO2lmKG51bGwhPXUpe3ZhciBsPXUud2lkdGgsdD10aGlzLmdldENlbGxHZW9tZXRyeShnW2ZdKTtudWxsIT10JiYodS5oZWlnaHQ9dC5oZWlnaHQpfWUuYWRkKGdbZl0scCxkKyhiPwowOjEpKX12YXIgQT10aGlzLmdldENlbGxHZW9tZXRyeShjKTtudWxsIT1BJiYoQT1BLmNsb25lKCksQS53aWR0aCs9bCxlLnNldEdlb21ldHJ5KGMsQSkpfWZpbmFsbHl7ZS5lbmRVcGRhdGUoKX19O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRUYWJsZVJvdz1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXMuZ2V0TW9kZWwoKTtlLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBjPWEsZD1hO2lmKHRoaXMuaXNUYWJsZUNlbGwoYSkpZD1lLmdldFBhcmVudChhKSxjPWUuZ2V0UGFyZW50KGQpO2Vsc2UgaWYodGhpcy5pc1RhYmxlUm93KGEpKWM9ZS5nZXRQYXJlbnQoYSk7ZWxzZSB2YXIgZj1lLmdldENoaWxkQ2VsbHMoYywhMCksZD1mW2I/MDpmLmxlbmd0aC0xXTt2YXIgZz1lLmdldENoaWxkQ2VsbHMoZCwhMCksbD1jLmdldEluZGV4KGQpLGQ9ZS5jbG9uZUNlbGwoZCwhMSk7ZC52YWx1ZT1udWxsO3ZhciBuPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGQpO2lmKG51bGwhPW4pe2ZvcihmPTA7ZjxnLmxlbmd0aDtmKyspe2E9CmUuY2xvbmVDZWxsKGdbZl0sITEpO2QuaW5zZXJ0KGEpO2EudmFsdWU9bnVsbDt2YXIgcD10aGlzLmdldENlbGxHZW9tZXRyeShhKTtudWxsIT1wJiYocC5oZWlnaHQ9bi5oZWlnaHQpfWUuYWRkKGMsZCxsKyhiPzA6MSkpO3ZhciB1PXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGMpO251bGwhPXUmJih1PXUuY2xvbmUoKSx1LmhlaWdodCs9bi5oZWlnaHQsZS5zZXRHZW9tZXRyeShjLHUpKX19ZmluYWxseXtlLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmRlbGV0ZVRhYmxlQ29sdW1uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0TW9kZWwoKTtiLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBlPWEsYz1udWxsLGQ9MDtpZih0aGlzLmlzVGFibGVDZWxsKGEpKXZhciBmPWIuZ2V0UGFyZW50KGEpLGU9Yi5nZXRQYXJlbnQoZiksZD1teFV0aWxzLmluZGV4T2YoYi5nZXRDaGlsZENlbGxzKGYsITApLGEpO2Vsc2UgdGhpcy5pc1RhYmxlUm93KGEpPyhlPWIuZ2V0UGFyZW50KGEpLGQ9Yi5nZXRDaGlsZENlbGxzKGEsCiEwKS5sZW5ndGgtMSk6dGhpcy5pc1RhYmxlKGEpJiYoYz1iLmdldENoaWxkQ2VsbHMoYSwhMCksZD1iLmdldENoaWxkQ2VsbHMoY1swXSwhMCkubGVuZ3RoLTEpO2E9MDtjPW51bGwhPWM/YzpiLmdldENoaWxkQ2VsbHMoZSwhMCk7Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGc9Yi5nZXRDaGlsZENlbGxzKGNbZl0sITApW2RdO2IucmVtb3ZlKGcpO3ZhciBsPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGcpO251bGwhPWwmJihhPU1hdGgubWF4KGEsbC53aWR0aCkpfXZhciBuPXRoaXMuZ2V0Q2VsbEdlb21ldHJ5KGUpO251bGwhPW4mJihuPW4uY2xvbmUoKSxuLndpZHRoLT1hLGIuc2V0R2VvbWV0cnkoZSxuKSl9ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmRlbGV0ZVRhYmxlUm93PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0TW9kZWwoKTtiLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBlPWE7aWYodGhpcy5pc1RhYmxlQ2VsbChhKSllPWIuZ2V0UGFyZW50KGEpOwplbHNlIGlmKHRoaXMuaXNUYWJsZShhKSl2YXIgYz1iLmdldENoaWxkQ2VsbHMoYSwhMCksZT1jW2MubGVuZ3RoLTFdO3ZhciBkPWIuZ2V0UGFyZW50KGUpO2IucmVtb3ZlKGUpO2E9MDt2YXIgZj10aGlzLmdldENlbGxHZW9tZXRyeShlKTtudWxsIT1mJiYoYT1mLmhlaWdodCk7dmFyIGc9dGhpcy5nZXRDZWxsR2VvbWV0cnkoZCk7bnVsbCE9ZyYmKGc9Zy5jbG9uZSgpLGcuaGVpZ2h0LT1hLGIuc2V0R2VvbWV0cnkoZCxnKSl9ZmluYWxseXtiLmVuZFVwZGF0ZSgpfX07R3JhcGgucHJvdG90eXBlLmluc2VydFJvdz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgZT1hLnRCb2RpZXNbMF0sYz1lLnJvd3NbMF0uY2VsbHMsZD0wLGY9MDtmPGMubGVuZ3RoO2YrKyl2YXIgZz1jW2ZdLmdldEF0dHJpYnV0ZSgiY29sc3BhbiIpLGQ9ZCsobnVsbCE9Zz9wYXJzZUludChnKToxKTtlPWUuaW5zZXJ0Um93KGIpO2ZvcihmPTA7ZjxkO2YrKylteFV0aWxzLmJyKGUuaW5zZXJ0Q2VsbCgtMSkpO3JldHVybiBlLmNlbGxzWzBdfTsKR3JhcGgucHJvdG90eXBlLmRlbGV0ZVJvdz1mdW5jdGlvbihhLGIpe2EudEJvZGllc1swXS5kZWxldGVSb3coYil9O0dyYXBoLnByb3RvdHlwZS5pbnNlcnRDb2x1bW49ZnVuY3Rpb24oYSxiKXt2YXIgZT1hLnRIZWFkO2lmKG51bGwhPWUpZm9yKHZhciBjPTA7YzxlLnJvd3MubGVuZ3RoO2MrKyl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGgiKTtlLnJvd3NbY10uYXBwZW5kQ2hpbGQoZCk7bXhVdGlscy5icihkKX1lPWEudEJvZGllc1swXTtmb3IoYz0wO2M8ZS5yb3dzLmxlbmd0aDtjKyspZD1lLnJvd3NbY10uaW5zZXJ0Q2VsbChiKSxteFV0aWxzLmJyKGQpO3JldHVybiBlLnJvd3NbMF0uY2VsbHNbMDw9Yj9iOmUucm93c1swXS5jZWxscy5sZW5ndGgtMV19O0dyYXBoLnByb3RvdHlwZS5kZWxldGVDb2x1bW49ZnVuY3Rpb24oYSxiKXtpZigwPD1iKWZvcih2YXIgZT1hLnRCb2RpZXNbMF0ucm93cyxjPTA7YzxlLmxlbmd0aDtjKyspZVtjXS5jZWxscy5sZW5ndGg+YiYmCmVbY10uZGVsZXRlQ2VsbChiKX07R3JhcGgucHJvdG90eXBlLnBhc3RlSHRtbEF0Q2FyZXQ9ZnVuY3Rpb24oYSl7dmFyIGI7aWYod2luZG93LmdldFNlbGVjdGlvbil7aWYoYj13aW5kb3cuZ2V0U2VsZWN0aW9uKCksYi5nZXRSYW5nZUF0JiZiLnJhbmdlQ291bnQpe2I9Yi5nZXRSYW5nZUF0KDApO2IuZGVsZXRlQ29udGVudHMoKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtlLmlubmVySFRNTD1hO2E9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2Zvcih2YXIgYztjPWUuZmlyc3RDaGlsZDspbGFzdE5vZGU9YS5hcHBlbmRDaGlsZChjKTtiLmluc2VydE5vZGUoYSl9fWVsc2UoYj1kb2N1bWVudC5zZWxlY3Rpb24pJiYiQ29udHJvbCIhPWIudHlwZSYmYi5jcmVhdGVSYW5nZSgpLnBhc3RlSFRNTChhKX07R3JhcGgucHJvdG90eXBlLmNyZWF0ZUxpbmtGb3JIaW50PWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gZShhLGIpe2EubGVuZ3RoPmImJihhPWEuc3Vic3RyaW5nKDAsCk1hdGgucm91bmQoYi8yKSkrIi4uLiIrYS5zdWJzdHJpbmcoYS5sZW5ndGgtTWF0aC5yb3VuZChiLzQpKSk7cmV0dXJuIGF9YT1udWxsIT1hP2E6ImphdmFzY3JpcHQ6dm9pZCgwKTsiO2lmKG51bGw9PWJ8fDA9PWIubGVuZ3RoKWI9dGhpcy5pc0N1c3RvbUxpbmsoYSk/dGhpcy5nZXRMaW5rVGl0bGUoYSk6YTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7Yy5zZXRBdHRyaWJ1dGUoInJlbCIsdGhpcy5saW5rUmVsYXRpb24pO2Muc2V0QXR0cmlidXRlKCJocmVmIix0aGlzLmdldEFic29sdXRlVXJsKGEpKTtjLnNldEF0dHJpYnV0ZSgidGl0bGUiLGUodGhpcy5pc0N1c3RvbUxpbmsoYSk/dGhpcy5nZXRMaW5rVGl0bGUoYSk6YSw4MCkpO251bGwhPXRoaXMubGlua1RhcmdldCYmYy5zZXRBdHRyaWJ1dGUoInRhcmdldCIsdGhpcy5saW5rVGFyZ2V0KTtteFV0aWxzLndyaXRlKGMsZShiLDQwKSk7dGhpcy5pc0N1c3RvbUxpbmsoYSkmJm14RXZlbnQuYWRkTGlzdGVuZXIoYywKImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLmN1c3RvbUxpbmtDbGlja2VkKGEpO214RXZlbnQuY29uc3VtZShiKX0pKTtyZXR1cm4gY307R3JhcGgucHJvdG90eXBlLmluaXRUb3VjaD1mdW5jdGlvbigpe3RoaXMuY29ubmVjdGlvbkhhbmRsZXIubWFya2VyLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLmZpcnN0fTt0aGlzLmFkZExpc3RlbmVyKG14RXZlbnQuU1RBUlRfRURJVElORyxmdW5jdGlvbihhLGIpe3RoaXMucG9wdXBNZW51SGFuZGxlci5oaWRlTWVudSgpfSk7dmFyIGE9dGhpcy51cGRhdGVNb3VzZUV2ZW50O3RoaXMudXBkYXRlTW91c2VFdmVudD1mdW5jdGlvbihiKXtiPWEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKG14RXZlbnQuaXNUb3VjaEV2ZW50KGIuZ2V0RXZlbnQoKSkmJm51bGw9PWIuZ2V0U3RhdGUoKSl7dmFyIGU9dGhpcy5nZXRDZWxsQXQoYi5ncmFwaFgsYi5ncmFwaFkpOwpudWxsIT1lJiZ0aGlzLmlzU3dpbWxhbmUoZSkmJnRoaXMuaGl0c1N3aW1sYW5lQ29udGVudChlLGIuZ3JhcGhYLGIuZ3JhcGhZKXx8KGIuc3RhdGU9dGhpcy52aWV3LmdldFN0YXRlKGUpLG51bGwhPWIuc3RhdGUmJm51bGwhPWIuc3RhdGUuc2hhcGUmJih0aGlzLmNvbnRhaW5lci5zdHlsZS5jdXJzb3I9Yi5zdGF0ZS5zaGFwZS5ub2RlLnN0eWxlLmN1cnNvcikpfW51bGw9PWIuZ2V0U3RhdGUoKSYmdGhpcy5pc0VuYWJsZWQoKSYmKHRoaXMuY29udGFpbmVyLnN0eWxlLmN1cnNvcj0iZGVmYXVsdCIpO3JldHVybiBifTt2YXIgYj0hMSxlPSExLGM9ITEsZD10aGlzLmZpcmVNb3VzZUV2ZW50O3RoaXMuZmlyZU1vdXNlRXZlbnQ9ZnVuY3Rpb24oYSxmLGcpe2E9PW14RXZlbnQuTU9VU0VfRE9XTiYmKGY9dGhpcy51cGRhdGVNb3VzZUV2ZW50KGYpLGI9dGhpcy5pc0NlbGxTZWxlY3RlZChmLmdldENlbGwoKSksZT10aGlzLmlzU2VsZWN0aW9uRW1wdHkoKSxjPXRoaXMucG9wdXBNZW51SGFuZGxlci5pc01lbnVTaG93aW5nKCkpOwpkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dGhpcy5wb3B1cE1lbnVIYW5kbGVyLm1vdXNlVXA9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxkKXt0aGlzLnBvcHVwTWVudUhhbmRsZXIucG9wdXBUcmlnZ2VyPSF0aGlzLmlzRWRpdGluZygpJiZ0aGlzLmlzRW5hYmxlZCgpJiYobnVsbD09ZC5nZXRTdGF0ZSgpfHwhZC5pc1NvdXJjZShkLmdldFN0YXRlKCkuY29udHJvbCkpJiYodGhpcy5wb3B1cE1lbnVIYW5kbGVyLnBvcHVwVHJpZ2dlcnx8IWMmJiFteEV2ZW50LmlzTW91c2VFdmVudChkLmdldEV2ZW50KCkpJiYoZSYmbnVsbD09ZC5nZXRDZWxsKCkmJnRoaXMuaXNTZWxlY3Rpb25FbXB0eSgpfHxiJiZ0aGlzLmlzQ2VsbFNlbGVjdGVkKGQuZ2V0Q2VsbCgpKSkpO214UG9wdXBNZW51SGFuZGxlci5wcm90b3R5cGUubW91c2VVcC5hcHBseSh0aGlzLnBvcHVwTWVudUhhbmRsZXIsYXJndW1lbnRzKX0pfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmlzQ29udGVudEVkaXRpbmc9ZnVuY3Rpb24oKXt2YXIgYT0KdGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZWRpdGluZ0NlbGwpO3JldHVybiBudWxsIT1hJiYxPT1hLnN0eWxlLmh0bWx9O214Q2VsbEVkaXRvci5wcm90b3R5cGUuaXNUYWJsZVNlbGVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZ3JhcGguZ2V0UGFyZW50QnlOYW1lKHRoaXMuZ3JhcGguZ2V0U2VsZWN0ZWRFbGVtZW50KCksIlRBQkxFIix0aGlzLnRleHRhcmVhKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5hbGlnblRleHQ9ZnVuY3Rpb24oYSxiKXt2YXIgZT1udWxsIT1iJiZteEV2ZW50LmlzU2hpZnREb3duKGIpO2lmKGV8fG51bGwhPXdpbmRvdy5nZXRTZWxlY3Rpb24mJm51bGwhPXdpbmRvdy5nZXRTZWxlY3Rpb24oKS5jb250YWluc05vZGUpe3ZhciBjPSEwO3RoaXMuZ3JhcGgucHJvY2Vzc0VsZW1lbnRzKHRoaXMudGV4dGFyZWEsZnVuY3Rpb24oYSl7ZXx8d2luZG93LmdldFNlbGVjdGlvbigpLmNvbnRhaW5zTm9kZShhLCEwKT8oYS5yZW1vdmVBdHRyaWJ1dGUoImFsaWduIiksCmEuc3R5bGUudGV4dEFsaWduPW51bGwpOmM9ITF9KTtjJiZ0aGlzLmdyYXBoLmNlbGxFZGl0b3Iuc2V0QWxpZ24oYSl9ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImp1c3RpZnkiK2EudG9Mb3dlckNhc2UoKSwhMSxudWxsKX07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5zYXZlU2VsZWN0aW9uPWZ1bmN0aW9uKCl7aWYod2luZG93LmdldFNlbGVjdGlvbil7dmFyIGE9d2luZG93LmdldFNlbGVjdGlvbigpO2lmKGEuZ2V0UmFuZ2VBdCYmYS5yYW5nZUNvdW50KXtmb3IodmFyIGI9W10sZT0wLGM9YS5yYW5nZUNvdW50O2U8YzsrK2UpYi5wdXNoKGEuZ2V0UmFuZ2VBdChlKSk7cmV0dXJuIGJ9fWVsc2UgaWYoZG9jdW1lbnQuc2VsZWN0aW9uJiZkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UpcmV0dXJuIGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO3JldHVybiBudWxsfTtteENlbGxFZGl0b3IucHJvdG90eXBlLnJlc3RvcmVTZWxlY3Rpb249ZnVuY3Rpb24oYSl7dHJ5e2lmKGEpaWYod2luZG93LmdldFNlbGVjdGlvbil7c2VsPQp3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7c2VsLnJlbW92ZUFsbFJhbmdlcygpO2Zvcih2YXIgYj0wLGU9YS5sZW5ndGg7YjxlOysrYilzZWwuYWRkUmFuZ2UoYVtiXSl9ZWxzZSBkb2N1bWVudC5zZWxlY3Rpb24mJmEuc2VsZWN0JiZhLnNlbGVjdCgpfWNhdGNoKHJhKXt9fTt2YXIgbD1teENlbGxSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZUxhYmVsO214Q2VsbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplTGFiZWw9ZnVuY3Rpb24oYSl7bnVsbCE9YS50ZXh0JiYoYS50ZXh0LnJlcGxhY2VMaW5lZmVlZHM9IjAiIT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsIm5sMkJyIiwiMSIpKTtsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIHA9bXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUudXBkYXRlO214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe3RoaXMuaXNLZWVwRm9jdXNFdmVudChhKXx8IW14RXZlbnQuaXNBbHREb3duKGEuZ2V0RXZlbnQoKSk/CnAuYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXMucmVzZXQoKX07bXhHdWlkZS5wcm90b3R5cGUuY3JlYXRlR3VpZGVTaGFwZT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IG14UG9seWxpbmUoW10sbXhDb25zdGFudHMuR1VJREVfQ09MT1IsbXhDb25zdGFudHMuR1VJREVfU1RST0tFV0lEVEgpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmVzY2FwZUNhbmNlbHNFZGl0aW5nPSExO3ZhciB2PW14Q2VsbEVkaXRvci5wcm90b3R5cGUuc3RhcnRFZGl0aW5nO214Q2VsbEVkaXRvci5wcm90b3R5cGUuc3RhcnRFZGl0aW5nPWZ1bmN0aW9uKGEsYil7dGhpcy5ncmFwaC5pc1RhYmxlKGEpJiYhdGhpcy5ncmFwaC5pc1N3aW1sYW5lKGEpJiYwPHRoaXMuZ3JhcGgubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSYmKGE9dGhpcy5ncmFwaC5tb2RlbC5nZXRDaGlsZEF0KGEsMCkpO3RoaXMuZ3JhcGguaXNUYWJsZVJvdyhhKSYmIXRoaXMuZ3JhcGguaXNTd2ltbGFuZShhKSYmMDx0aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoYSkmJgooYT10aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQXQoYSwwKSk7di5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGU9dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEpO3RoaXMudGV4dGFyZWEuY2xhc3NOYW1lPW51bGwhPWUmJjE9PWUuc3R5bGUuaHRtbD8ibXhDZWxsRWRpdG9yIGdlQ29udGVudEVkaXRhYmxlIjoibXhDZWxsRWRpdG9yIG14UGxhaW5UZXh0RWRpdG9yIjt0aGlzLmNvZGVWaWV3TW9kZT0hMTt0aGlzLnN3aXRjaFNlbGVjdGlvblN0YXRlPW51bGw7dGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKGEpO3ZhciBlPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYSksYz10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShhKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNFZGdlKGUpJiZudWxsIT1jJiZjLnJlbGF0aXZlfHx0aGlzLmdyYXBoLmdldE1vZGVsKCkuaXNFZGdlKGEpP214Q2xpZW50LklTX1FVSVJLUz90aGlzLnRleHRhcmVhLnN0eWxlLmJvcmRlcj0iZ3JheSBkb3R0ZWQgMXB4IjoKdGhpcy50ZXh0YXJlYS5zdHlsZS5vdXRsaW5lPW14Q2xpZW50LklTX0lFfHxteENsaWVudC5JU19JRTExfHxteENsaWVudC5JU19GRiYmbXhDbGllbnQuSVNfV0lOPyJncmF5IGRvdHRlZCAxcHgiOiIiOm14Q2xpZW50LklTX1FVSVJLUyYmKHRoaXMudGV4dGFyZWEuc3R5bGUub3V0bGluZT0ibm9uZSIsdGhpcy50ZXh0YXJlYS5zdHlsZS5ib3JkZXI9IiIpfTt2YXIgdD1teENlbGxFZGl0b3IucHJvdG90eXBlLmluc3RhbGxMaXN0ZW5lcnM7bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5pbnN0YWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxlKXtlLm9yaWdpbmFsTm9kZT1hO2E9YS5maXJzdENoaWxkO2Zvcih2YXIgYz1lLmZpcnN0Q2hpbGQ7bnVsbCE9YSYmbnVsbCE9YzspYihhLGMpLGE9YS5uZXh0U2libGluZyxjPWMubmV4dFNpYmxpbmc7cmV0dXJuIGV9ZnVuY3Rpb24gZShhLGIpe2lmKG51bGwhPWEpaWYoYi5vcmlnaW5hbE5vZGUhPWEpYyhhKTtlbHNlIGZvcihhPQphLmZpcnN0Q2hpbGQsYj1iLmZpcnN0Q2hpbGQ7bnVsbCE9YTspe3ZhciBkPWEubmV4dFNpYmxpbmc7bnVsbD09Yj9jKGEpOihlKGEsYiksYj1iLm5leHRTaWJsaW5nKTthPWR9fWZ1bmN0aW9uIGMoYSl7Zm9yKHZhciBiPWEuZmlyc3RDaGlsZDtudWxsIT1iOyl7dmFyIGU9Yi5uZXh0U2libGluZztjKGIpO2I9ZX0xPT1hLm5vZGVUeXBlJiYoIkJSIj09PWEubm9kZU5hbWV8fG51bGwhPWEuZmlyc3RDaGlsZCl8fDM9PWEubm9kZVR5cGUmJjAhPW14VXRpbHMudHJpbShteFV0aWxzLmdldFRleHRDb250ZW50KGEpKS5sZW5ndGg/KDM9PWEubm9kZVR5cGUmJm14VXRpbHMuc2V0VGV4dENvbnRlbnQoYSxteFV0aWxzLmdldFRleHRDb250ZW50KGEpLnJlcGxhY2UoL1xufFxyL2csIiIpKSwxPT1hLm5vZGVUeXBlJiYoYS5yZW1vdmVBdHRyaWJ1dGUoInN0eWxlIiksYS5yZW1vdmVBdHRyaWJ1dGUoImNsYXNzIiksYS5yZW1vdmVBdHRyaWJ1dGUoIndpZHRoIiksYS5yZW1vdmVBdHRyaWJ1dGUoImNlbGxwYWRkaW5nIiksCmEucmVtb3ZlQXR0cmlidXRlKCJjZWxsc3BhY2luZyIpLGEucmVtb3ZlQXR0cmlidXRlKCJib3JkZXIiKSkpOmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteENsaWVudC5JU19RVUlSS1N8fDc9PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDg9PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fG14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy50ZXh0YXJlYSwicGFzdGUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBjPWIodGhpcy50ZXh0YXJlYSx0aGlzLnRleHRhcmVhLmNsb25lTm9kZSghMCkpO3dpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy50ZXh0YXJlYSYmKDA8PXRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLmluZGV4T2YoIjxvOk9mZmljZURvY3VtZW50U2V0dGluZ3M+Iil8fDA8PXRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLmluZGV4T2YoIlx4M2MhLS1baWYgIW1zb10+Iik/CmUodGhpcy50ZXh0YXJlYSxjKTpHcmFwaC5yZW1vdmVQYXN0ZUZvcm1hdHRpbmcodGhpcy50ZXh0YXJlYSkpfSksMCl9KSl9O214Q2VsbEVkaXRvci5wcm90b3R5cGUudG9nZ2xlVmlld01vZGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUodGhpcy5lZGl0aW5nQ2VsbCk7aWYobnVsbCE9YSl7dmFyIGI9bnVsbCE9YSYmIjAiIT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsIm5sMkJyIiwiMSIpLGU9dGhpcy5zYXZlU2VsZWN0aW9uKCk7aWYodGhpcy5jb2RlVmlld01vZGUpe249bXhVdGlscy5leHRyYWN0VGV4dFdpdGhXaGl0ZXNwYWNlKHRoaXMudGV4dGFyZWEuY2hpbGROb2Rlcyk7MDxuLmxlbmd0aCYmIlxuIj09bi5jaGFyQXQobi5sZW5ndGgtMSkmJihuPW4uc3Vic3RyaW5nKDAsbi5sZW5ndGgtMSkpO249dGhpcy5ncmFwaC5zYW5pdGl6ZUh0bWwoYj9uLnJlcGxhY2UoL1xuL2csIjxici8+Iik6biwhMCk7dGhpcy50ZXh0YXJlYS5jbGFzc05hbWU9Im14Q2VsbEVkaXRvciBnZUNvbnRlbnRFZGl0YWJsZSI7CnZhciBjPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU0laRSxteENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFKSxiPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05URkFNSUxZLG14Q29uc3RhbnRzLkRFRkFVTFRfRk9OVEZBTUlMWSksZD1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQUxJR04sbXhDb25zdGFudHMuQUxJR05fTEVGVCksZj0obXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwwKSZteENvbnN0YW50cy5GT05UX0JPTEQpPT1teENvbnN0YW50cy5GT05UX0JPTEQsZz0obXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSwwKSZteENvbnN0YW50cy5GT05UX0lUQUxJQyk9PW14Q29uc3RhbnRzLkZPTlRfSVRBTElDLGw9W107KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsCjApJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJmwucHVzaCgidW5kZXJsaW5lIik7KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GT05UU1RZTEUsMCkmbXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIKT09bXhDb25zdGFudHMuRk9OVF9TVFJJS0VUSFJPVUdIJiZsLnB1c2goImxpbmUtdGhyb3VnaCIpO3RoaXMudGV4dGFyZWEuc3R5bGUubGluZUhlaWdodD1teENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD9NYXRoLnJvdW5kKGMqbXhDb25zdGFudHMuTElORV9IRUlHSFQpKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQ7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250U2l6ZT1NYXRoLnJvdW5kKGMpKyJweCI7dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0RGVjb3JhdGlvbj1sLmpvaW4oIiAiKTt0aGlzLnRleHRhcmVhLnN0eWxlLmZvbnRXZWlnaHQ9Zj8iYm9sZCI6Im5vcm1hbCI7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250U3R5bGU9Cmc/Iml0YWxpYyI6IiI7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250RmFtaWx5PWI7dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0QWxpZ249ZDt0aGlzLnRleHRhcmVhLnN0eWxlLnBhZGRpbmc9IjBweCI7dGhpcy50ZXh0YXJlYS5pbm5lckhUTUwhPW4mJih0aGlzLnRleHRhcmVhLmlubmVySFRNTD1uLDA9PXRoaXMudGV4dGFyZWEuaW5uZXJIVE1MLmxlbmd0aCYmKHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKSx0aGlzLmNsZWFyT25DaGFuZ2U9MDx0aGlzLnRleHRhcmVhLmlubmVySFRNTC5sZW5ndGgpKTt0aGlzLmNvZGVWaWV3TW9kZT0hMX1lbHNle3RoaXMuY2xlYXJPbkNoYW5nZSYmdGhpcy50ZXh0YXJlYS5pbm5lckhUTUw9PXRoaXMuZ2V0RW1wdHlMYWJlbFRleHQoKSYmKHRoaXMuY2xlYXJPbkNoYW5nZT0hMSx0aGlzLnRleHRhcmVhLmlubmVySFRNTD0iIik7dmFyIG49bXhVdGlscy5odG1sRW50aXRpZXModGhpcy50ZXh0YXJlYS5pbm5lckhUTUwpOwpteENsaWVudC5JU19RVUlSS1N8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8KG49bXhVdGlscy5yZXBsYWNlVHJhaWxpbmdOZXdsaW5lcyhuLCI8ZGl2Pjxicj48L2Rpdj4iKSk7bj10aGlzLmdyYXBoLnNhbml0aXplSHRtbChiP24ucmVwbGFjZSgvXG4vZywiIikucmVwbGFjZSgvJmx0O2JyXHMqLj8mZ3Q7L2csIjxicj4iKTpuLCEwKTt0aGlzLnRleHRhcmVhLmNsYXNzTmFtZT0ibXhDZWxsRWRpdG9yIG14UGxhaW5UZXh0RWRpdG9yIjt2YXIgYz1teENvbnN0YW50cy5ERUZBVUxUX0ZPTlRTSVpFO3RoaXMudGV4dGFyZWEuc3R5bGUubGluZUhlaWdodD1teENvbnN0YW50cy5BQlNPTFVURV9MSU5FX0hFSUdIVD9NYXRoLnJvdW5kKGMqbXhDb25zdGFudHMuTElORV9IRUlHSFQpKyJweCI6bXhDb25zdGFudHMuTElORV9IRUlHSFQ7dGhpcy50ZXh0YXJlYS5zdHlsZS5mb250U2l6ZT1NYXRoLnJvdW5kKGMpKyJweCI7dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0RGVjb3JhdGlvbj0iIjsKdGhpcy50ZXh0YXJlYS5zdHlsZS5mb250V2VpZ2h0PSJub3JtYWwiO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udFN0eWxlPSIiO3RoaXMudGV4dGFyZWEuc3R5bGUuZm9udEZhbWlseT1teENvbnN0YW50cy5ERUZBVUxUX0ZPTlRGQU1JTFk7dGhpcy50ZXh0YXJlYS5zdHlsZS50ZXh0QWxpZ249ImxlZnQiO3RoaXMudGV4dGFyZWEuc3R5bGUucGFkZGluZz0iMnB4Ijt0aGlzLnRleHRhcmVhLmlubmVySFRNTCE9biYmKHRoaXMudGV4dGFyZWEuaW5uZXJIVE1MPW4pO3RoaXMuY29kZVZpZXdNb2RlPSEwfXRoaXMudGV4dGFyZWEuZm9jdXMoKTtudWxsIT10aGlzLnN3aXRjaFNlbGVjdGlvblN0YXRlJiZ0aGlzLnJlc3RvcmVTZWxlY3Rpb24odGhpcy5zd2l0Y2hTZWxlY3Rpb25TdGF0ZSk7dGhpcy5zd2l0Y2hTZWxlY3Rpb25TdGF0ZT1lO3RoaXMucmVzaXplKCl9fTt2YXIgeT1teENlbGxFZGl0b3IucHJvdG90eXBlLnJlc2l6ZTtteENlbGxFZGl0b3IucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbihhLApiKXtpZihudWxsIT10aGlzLnRleHRhcmVhKWlmKGE9dGhpcy5ncmFwaC5nZXRWaWV3KCkuZ2V0U3RhdGUodGhpcy5lZGl0aW5nQ2VsbCksdGhpcy5jb2RlVmlld01vZGUmJm51bGwhPWEpe3ZhciBlPWEudmlldy5zY2FsZTt0aGlzLmJvdW5kcz1teFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGEpO2lmKDA9PXRoaXMuYm91bmRzLndpZHRoJiYwPT10aGlzLmJvdW5kcy5oZWlnaHQpe3RoaXMuYm91bmRzLndpZHRoPTE2MCplO3RoaXMuYm91bmRzLmhlaWdodD02MCplO3ZhciBjPW51bGwhPWEudGV4dD9hLnRleHQubWFyZ2luOm51bGw7bnVsbD09YyYmKGM9bXhVdGlscy5nZXRBbGlnbm1lbnRBc1BvaW50KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BTElHTixteENvbnN0YW50cy5BTElHTl9DRU5URVIpLG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9WRVJUSUNBTF9BTElHTixteENvbnN0YW50cy5BTElHTl9NSURETEUpKSk7CnRoaXMuYm91bmRzLngrPWMueCp0aGlzLmJvdW5kcy53aWR0aDt0aGlzLmJvdW5kcy55Kz1jLnkqdGhpcy5ib3VuZHMuaGVpZ2h0fXRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGg9TWF0aC5yb3VuZCgodGhpcy5ib3VuZHMud2lkdGgtNCkvZSkrInB4Ijt0aGlzLnRleHRhcmVhLnN0eWxlLmhlaWdodD1NYXRoLnJvdW5kKCh0aGlzLmJvdW5kcy5oZWlnaHQtNCkvZSkrInB4Ijt0aGlzLnRleHRhcmVhLnN0eWxlLm92ZXJmbG93PSJhdXRvIjt0aGlzLnRleHRhcmVhLmNsaWVudEhlaWdodDx0aGlzLnRleHRhcmVhLm9mZnNldEhlaWdodCYmKHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5ib3VuZHMuaGVpZ2h0L2UpKyh0aGlzLnRleHRhcmVhLm9mZnNldEhlaWdodC10aGlzLnRleHRhcmVhLmNsaWVudEhlaWdodCkrInB4Iix0aGlzLmJvdW5kcy5oZWlnaHQ9cGFyc2VJbnQodGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQpKmUpO3RoaXMudGV4dGFyZWEuY2xpZW50V2lkdGg8CnRoaXMudGV4dGFyZWEub2Zmc2V0V2lkdGgmJih0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoPU1hdGgucm91bmQodGhpcy5ib3VuZHMud2lkdGgvZSkrKHRoaXMudGV4dGFyZWEub2Zmc2V0V2lkdGgtdGhpcy50ZXh0YXJlYS5jbGllbnRXaWR0aCkrInB4Iix0aGlzLmJvdW5kcy53aWR0aD1wYXJzZUludCh0aGlzLnRleHRhcmVhLnN0eWxlLndpZHRoKSplKTt0aGlzLnRleHRhcmVhLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZCh0aGlzLmJvdW5kcy54KSsicHgiO3RoaXMudGV4dGFyZWEuc3R5bGUudG9wPU1hdGgucm91bmQodGhpcy5ib3VuZHMueSkrInB4IjtteENsaWVudC5JU19WTUw/dGhpcy50ZXh0YXJlYS5zdHlsZS56b29tPWU6bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKHRoaXMudGV4dGFyZWEuc3R5bGUsInRyYW5zZm9ybSIsInNjYWxlKCIrZSsiLCIrZSsiKSIpfWVsc2UgdGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9IiIsdGhpcy50ZXh0YXJlYS5zdHlsZS5vdmVyZmxvdz0iIiwKeS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214Q2VsbEVkaXRvckdldEluaXRpYWxWYWx1ZT1teENlbGxFZGl0b3IucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZT1mdW5jdGlvbihhLGIpe2lmKCIwIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJodG1sIiwiMCIpKXJldHVybiBteENlbGxFZGl0b3JHZXRJbml0aWFsVmFsdWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBlPXRoaXMuZ3JhcGguZ2V0RWRpdGluZ1ZhbHVlKGEuY2VsbCxiKTsiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwibmwyQnIiLCIxIikmJihlPWUucmVwbGFjZSgvXG4vZywiPGJyLz4iKSk7cmV0dXJuIGU9dGhpcy5ncmFwaC5zYW5pdGl6ZUh0bWwoZSwhMCl9O214Q2VsbEVkaXRvckdldEN1cnJlbnRWYWx1ZT1teENlbGxFZGl0b3IucHJvdG90eXBlLmdldEN1cnJlbnRWYWx1ZTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEN1cnJlbnRWYWx1ZT0KZnVuY3Rpb24oYSl7aWYoIjAiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsImh0bWwiLCIwIikpcmV0dXJuIG14Q2VsbEVkaXRvckdldEN1cnJlbnRWYWx1ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGI9dGhpcy5ncmFwaC5zYW5pdGl6ZUh0bWwodGhpcy50ZXh0YXJlYS5pbm5lckhUTUwsITApO3JldHVybiBiPSIxIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJubDJCciIsIjEiKT9iLnJlcGxhY2UoL1xyXG4vZywiPGJyLz4iKS5yZXBsYWNlKC9cbi9nLCI8YnIvPiIpOmIucmVwbGFjZSgvXHJcbi9nLCIiKS5yZXBsYWNlKC9cbi9nLCIiKX07dmFyIHg9bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5zdG9wRWRpdGluZztteENlbGxFZGl0b3IucHJvdG90eXBlLnN0b3BFZGl0aW5nPWZ1bmN0aW9uKGEpe3RoaXMuY29kZVZpZXdNb2RlJiZ0aGlzLnRvZ2dsZVZpZXdNb2RlKCk7eC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5mb2N1c0NvbnRhaW5lcigpfTtteENlbGxFZGl0b3IucHJvdG90eXBlLmZvY3VzQ29udGFpbmVyPQpmdW5jdGlvbigpe3RyeXt0aGlzLmdyYXBoLmNvbnRhaW5lci5mb2N1cygpfWNhdGNoKFMpe319O3ZhciBDPW14Q2VsbEVkaXRvci5wcm90b3R5cGUuYXBwbHlWYWx1ZTtteENlbGxFZGl0b3IucHJvdG90eXBlLmFwcGx5VmFsdWU9ZnVuY3Rpb24oYSxiKXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Qy5hcHBseSh0aGlzLGFyZ3VtZW50cyksIiI9PWImJnRoaXMuZ3JhcGguaXNDZWxsRGVsZXRhYmxlKGEuY2VsbCkmJjA9PXRoaXMuZ3JhcGgubW9kZWwuZ2V0Q2hpbGRDb3VudChhLmNlbGwpJiZ0aGlzLmdyYXBoLmlzVHJhbnNwYXJlbnRTdGF0ZShhKSYmdGhpcy5ncmFwaC5yZW1vdmVDZWxscyhbYS5jZWxsXSwhMSl9ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fTtteENlbGxFZGl0b3IucHJvdG90eXBlLmdldEJhY2tncm91bmRDb2xvcj1mdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfTEFCRUxfQkFDS0dST1VORENPTE9SLApudWxsKTtudWxsIT1iJiZiIT1teENvbnN0YW50cy5OT05FfHwhKG51bGwhPWEuY2VsbC5nZW9tZXRyeSYmMDxhLmNlbGwuZ2VvbWV0cnkud2lkdGgpfHwwPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT04sMCkmJjAhPW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLDEpfHwoYj1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLG51bGwpKTtiPT1teENvbnN0YW50cy5OT05FJiYoYj1udWxsKTtyZXR1cm4gYn07bXhDZWxsRWRpdG9yLnByb3RvdHlwZS5nZXRNaW5pbXVtU2l6ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldFZpZXcoKS5zY2FsZTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCxudWxsPT1hLnRleHQ/MzA6YS50ZXh0LnNpemUqYisyMCwzMCl9O214R3JhcGhIYW5kbGVySXNWYWxpZERyb3BUYXJnZXQ9bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmlzVmFsaWREcm9wVGFyZ2V0OwpteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuaXNWYWxpZERyb3BUYXJnZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbXhHcmFwaEhhbmRsZXJJc1ZhbGlkRHJvcFRhcmdldC5hcHBseSh0aGlzLGFyZ3VtZW50cykmJiFteEV2ZW50LmlzQWx0RG93bihiLmdldEV2ZW50KX07bXhHcmFwaFZpZXcucHJvdG90eXBlLmZvcm1hdFVuaXRUZXh0PWZ1bmN0aW9uKGEpe3JldHVybiBhP2MoYSx0aGlzLnVuaXQpOmF9O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVIaW50PWZ1bmN0aW9uKGIpe2lmKG51bGwhPXRoaXMucEJvdW5kcyYmKG51bGwhPXRoaXMuc2hhcGV8fHRoaXMubGl2ZVByZXZpZXdBY3RpdmUpKXtudWxsPT10aGlzLmhpbnQmJih0aGlzLmhpbnQ9YSgpLHRoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaGludCkpO3ZhciBlPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZD10aGlzLmdyYXBoLnZpZXcuc2NhbGU7Yj10aGlzLnJvdW5kTGVuZ3RoKCh0aGlzLmJvdW5kcy54Kwp0aGlzLmN1cnJlbnREeCkvZC1lLngpO2U9dGhpcy5yb3VuZExlbmd0aCgodGhpcy5ib3VuZHMueSt0aGlzLmN1cnJlbnREeSkvZC1lLnkpO2Q9dGhpcy5ncmFwaC52aWV3LnVuaXQ7dGhpcy5oaW50LmlubmVySFRNTD1jKGIsZCkrIiwgIitjKGUsZCk7dGhpcy5oaW50LnN0eWxlLmxlZnQ9dGhpcy5wQm91bmRzLngrdGhpcy5jdXJyZW50RHgrTWF0aC5yb3VuZCgodGhpcy5wQm91bmRzLndpZHRoLXRoaXMuaGludC5jbGllbnRXaWR0aCkvMikrInB4Ijt0aGlzLmhpbnQuc3R5bGUudG9wPXRoaXMucEJvdW5kcy55K3RoaXMuY3VycmVudER5K3RoaXMucEJvdW5kcy5oZWlnaHQrRWRpdG9yLmhpbnRPZmZzZXQrInB4In19O214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVIaW50PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5oaW50JiYodGhpcy5oaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaW50KSx0aGlzLmhpbnQ9bnVsbCl9O3ZhciBCPW14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVkU2VsZWN0aW9uQ2VsbHM7Cm14U2VsZWN0aW9uQ2VsbHNIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVkU2VsZWN0aW9uQ2VsbHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2UuZ2V0KGEpfHwoZS5wdXQoYSwhMCksZC5wdXNoKGEpKX1mb3IodmFyIGI9Qi5hcHBseSh0aGlzLGFyZ3VtZW50cyksZT1uZXcgbXhEaWN0aW9uYXJ5LGM9dGhpcy5ncmFwaC5tb2RlbCxkPVtdLGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGc9YltmXTt0aGlzLmdyYXBoLmlzVGFibGVDZWxsKGcpP2EoYy5nZXRQYXJlbnQoYy5nZXRQYXJlbnQoZykpKTp0aGlzLmdyYXBoLmlzVGFibGVSb3coZykmJmEoYy5nZXRQYXJlbnQoZykpO2EoZyl9cmV0dXJuIGR9O3ZhciBEPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNNb3ZlQ3VzdG9tSGFuZGxlUHJldmlld1RvRnJvbnQ7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc01vdmVDdXN0b21IYW5kbGVQcmV2aWV3VG9Gcm9udD1mdW5jdGlvbihhKXtyZXR1cm4gRC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fAp0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKSYmKG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuTk9ORSk9PW14Q29uc3RhbnRzLk5PTkV8fHRoaXMuZ3JhcGguaXNTd2ltbGFuZSh0aGlzLnN0YXRlLmNlbGwpJiZteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1dJTUxBTkVfRklMTENPTE9SLG14Q29uc3RhbnRzLk5PTkUpPT1teENvbnN0YW50cy5OT05FKX07dmFyIHo9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVBhcmVudEhpZ2hsaWdodFNoYXBlPWZ1bmN0aW9uKGEpe3ZhciBiPXouYXBwbHkodGhpcyxhcmd1bWVudHMpO2Iuc3Ryb2tlPSIjQzBDMEMwIjtiLnN0cm9rZXdpZHRoPTE7cmV0dXJuIGJ9O3ZhciBFPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVBhcmVudEhpZ2hsaWdodFNoYXBlOwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRIaWdobGlnaHRTaGFwZT1mdW5jdGlvbihhKXt2YXIgYj1FLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtiLnN0cm9rZT0iI0MwQzBDMCI7Yi5zdHJva2V3aWR0aD0xO3JldHVybiBifTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0aW9uSGFuZGxlVlNwYWNpbmc9LTEyO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0Um90YXRpb25IYW5kbGVQb3NpdGlvbj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0SGFuZGxlUGFkZGluZygpO3JldHVybiBuZXcgbXhQb2ludCh0aGlzLmJvdW5kcy54K3RoaXMuYm91bmRzLndpZHRoLXRoaXMucm90YXRpb25IYW5kbGVWU3BhY2luZythLngvMix0aGlzLmJvdW5kcy55K3RoaXMucm90YXRpb25IYW5kbGVWU3BhY2luZy1hLnkvMil9O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNSZWN1cnNpdmVSZXNpemU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5ncmFwaC5pc1JlY3Vyc2l2ZVZlcnRleFJlc2l6ZShhKSYmCiFteEV2ZW50LmlzQ29udHJvbERvd24oYi5nZXRFdmVudCgpKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc0NlbnRlcmVkRXZlbnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hKCF0aGlzLmdyYXBoLmlzU3dpbWxhbmUoYS5jZWxsKSYmMDx0aGlzLmdyYXBoLm1vZGVsLmdldENoaWxkQ291bnQoYS5jZWxsKSYmIXRoaXMuZ3JhcGguaXNDZWxsQ29sbGFwc2VkKGEuY2VsbCkmJiIxIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJyZWN1cnNpdmVSZXNpemUiLCIxIikmJm51bGw9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSwiY2hpbGRMYXlvdXQiLG51bGwpKSYmbXhFdmVudC5pc0NvbnRyb2xEb3duKGIuZ2V0RXZlbnQoKSl8fG14RXZlbnQuaXNNZXRhRG93bihiLmdldEV2ZW50KCkpfTt2YXIgRz1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmlzUm90YXRpb25IYW5kbGVWaXNpYmxlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNSb3RhdGlvbkhhbmRsZVZpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gRy5hcHBseSh0aGlzLAphcmd1bWVudHMpJiYhdGhpcy5ncmFwaC5pc1RhYmxlQ2VsbCh0aGlzLnN0YXRlLmNlbGwpJiYhdGhpcy5ncmFwaC5pc1RhYmxlUm93KHRoaXMuc3RhdGUuY2VsbCkmJiF0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTaXplckJvdW5kcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLmlzVGFibGVDZWxsKHRoaXMuc3RhdGUuY2VsbCk/dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KHRoaXMuZ3JhcGgubW9kZWwuZ2V0UGFyZW50KHRoaXMuc3RhdGUuY2VsbCkpKTp0aGlzLmJvdW5kc307dmFyIEY9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1BhcmVudEhpZ2hsaWdodFZpc2libGU7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pc1BhcmVudEhpZ2hsaWdodFZpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gRi5hcHBseSh0aGlzLGFyZ3VtZW50cykmJiF0aGlzLmdyYXBoLmlzVGFibGVDZWxsKHRoaXMuc3RhdGUuY2VsbCkmJgohdGhpcy5ncmFwaC5pc1RhYmxlUm93KHRoaXMuc3RhdGUuY2VsbCl9O3ZhciBIPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNDdXN0b21IYW5kbGVWaXNpYmxlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaXNDdXN0b21IYW5kbGVWaXNpYmxlPWZ1bmN0aW9uKGEpe3JldHVybiBhLnRhYmxlSGFuZGxlfHxILmFwcGx5KHRoaXMsYXJndW1lbnRzKSYmKCF0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKXx8dGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZCh0aGlzLnN0YXRlLmNlbGwpKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25Cb3JkZXJJbnNldD1mdW5jdGlvbigpe3ZhciBhPTA7dGhpcy5ncmFwaC5pc1RhYmxlUm93KHRoaXMuc3RhdGUuY2VsbCk/YT0xOnRoaXMuZ3JhcGguaXNUYWJsZUNlbGwodGhpcy5zdGF0ZS5jZWxsKSYmKGE9Mik7cmV0dXJuIGF9O3ZhciBKPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQm9yZGVyQm91bmRzOwpteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbkJvcmRlckJvdW5kcz1mdW5jdGlvbigpe3JldHVybiBKLmFwcGx5KHRoaXMsYXJndW1lbnRzKS5ncm93KC10aGlzLmdldFNlbGVjdGlvbkJvcmRlckluc2V0KCkpfTt2YXIgdT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUhhbmRsZXM7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVDdXN0b21IYW5kbGVzPWZ1bmN0aW9uKCl7dmFyIGE9dS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYodGhpcy5ncmFwaC5pc1RhYmxlKHRoaXMuc3RhdGUuY2VsbCkpe3ZhciBiPXRoaXMuZ3JhcGgsZT1iLm1vZGVsLGM9dGhpcy5zdGF0ZSxkPXRoaXMuc2VsZWN0aW9uQm9yZGVyO251bGw9PWEmJihhPVtdKTtmb3IodmFyIGY9W10sZz0wO2c8ZS5nZXRDaGlsZENvdW50KHRoaXMuc3RhdGUuY2VsbCk7ZysrKXt2YXIgbD10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoZS5nZXRDaGlsZEF0KHRoaXMuc3RhdGUuY2VsbCwKZykpO251bGwhPWwmJmUuaXNWZXJ0ZXgobC5jZWxsKSYmZi5wdXNoKGwpfWZvcih2YXIgbj1bXSxnPTA7ZzxlLmdldENoaWxkQ291bnQoZlswXS5jZWxsKTtnKyspbD10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoZS5nZXRDaGlsZEF0KGZbMF0uY2VsbCxnKSksbnVsbCE9bCYmZS5pc1ZlcnRleChsLmNlbGwpJiZuLnB1c2gobCk7Zm9yKGc9MDtnPG4ubGVuZ3RoO2crKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihlKXt2YXIgZj1uW2VdLGc9ZTxuLmxlbmd0aC0xP25bZSsxXTpudWxsLGw9bmV3IG14TGluZShuZXcgbXhSZWN0YW5nbGUsbXhDb25zdGFudHMuTk9ORSwxLCEwKTtsLmlzRGFzaGVkPWQuaXNEYXNoZWQ7bD1uZXcgbXhIYW5kbGUoZiwiY29sLXJlc2l6ZSIsbnVsbCxsKTtsLnRhYmxlSGFuZGxlPSEwO3ZhciB1PTA7bC5zaGFwZS5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGwuc2hhcGUubm9kZSxsLnNoYXBlLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKTtsLnJlZHJhdz0KZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnNoYXBlJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlKXt2YXIgYT1iLmdldEFjdHVhbFN0YXJ0U2l6ZShjLmNlbGwpO3RoaXMuc2hhcGUuc3Ryb2tlPTA9PXU/bXhDb25zdGFudHMuTk9ORTpkLnN0cm9rZTt0aGlzLnNoYXBlLmJvdW5kcy54PXRoaXMuc3RhdGUueCt0aGlzLnN0YXRlLndpZHRoK3UqdGhpcy5ncmFwaC52aWV3LnNjYWxlO3RoaXMuc2hhcGUuYm91bmRzLndpZHRoPTE7dGhpcy5zaGFwZS5ib3VuZHMueT1jLnkrKGU9PW4ubGVuZ3RoLTE/MDphLnkqdGhpcy5ncmFwaC52aWV3LnNjYWxlKTt0aGlzLnNoYXBlLmJvdW5kcy5oZWlnaHQ9Yy5oZWlnaHQtKGU9PW4ubGVuZ3RoLTE/MDooYS5oZWlnaHQrYS55KSp0aGlzLmdyYXBoLnZpZXcuc2NhbGUpO3RoaXMuc2hhcGUucmVkcmF3KCl9fTtsLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGEsYixlKXt1PU1hdGgubWF4KEdyYXBoLm1pblRhYmxlQ29sdW1uV2lkdGgtYS53aWR0aCxiLngtYS54LQphLndpZHRoKTtudWxsIT1nJiYodT1NYXRoLm1pbihnLngrZy53aWR0aC1mLngtZi53aWR0aC1HcmFwaC5taW5UYWJsZUNvbHVtbldpZHRoLHUpKX07bC5leGVjdXRlPWZ1bmN0aW9uKCl7MCE9dSYmYi5zZXRUYWJsZUNvbHVtbldpZHRoKHRoaXMuc3RhdGUuY2VsbCx1KTt1PTB9O2wucmVzZXQ9ZnVuY3Rpb24oKXt1PTB9O2EucHVzaChsKX0pKGcpO2ZvcihnPTA7ZzxmLmxlbmd0aDtnKyspbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7ZT1mW2VdO3ZhciBjPW5ldyBteExpbmUobmV3IG14UmVjdGFuZ2xlLG14Q29uc3RhbnRzLk5PTkUsMSk7Yy5pc0Rhc2hlZD1kLmlzRGFzaGVkO2U9bmV3IG14SGFuZGxlKGUsInJvdy1yZXNpemUiLG51bGwsYyk7ZS50YWJsZUhhbmRsZT0hMDt2YXIgZz0wO2Uuc2hhcGUubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLnNoYXBlLm5vZGUsZS5zaGFwZS5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7ZS5yZWRyYXc9ZnVuY3Rpb24oKXtudWxsIT0KdGhpcy5zaGFwZSYmbnVsbCE9dGhpcy5zdGF0ZS5zaGFwZSYmKHRoaXMuc2hhcGUuc3Ryb2tlPTA9PWc/bXhDb25zdGFudHMuTk9ORTpkLnN0cm9rZSx0aGlzLnNoYXBlLmJvdW5kcy54PXRoaXMuc3RhdGUueCx0aGlzLnNoYXBlLmJvdW5kcy53aWR0aD10aGlzLnN0YXRlLndpZHRoLHRoaXMuc2hhcGUuYm91bmRzLnk9dGhpcy5zdGF0ZS55K3RoaXMuc3RhdGUuaGVpZ2h0K2cqdGhpcy5ncmFwaC52aWV3LnNjYWxlLHRoaXMuc2hhcGUuYm91bmRzLmhlaWdodD0xLHRoaXMuc2hhcGUucmVkcmF3KCkpfTtlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGEsYixlKXtnPU1hdGgubWF4KEdyYXBoLm1pblRhYmxlUm93SGVpZ2h0LWEuaGVpZ2h0LGIueS1hLnktYS5oZWlnaHQpfTtlLmV4ZWN1dGU9ZnVuY3Rpb24oKXswIT1nJiZiLnNldFRhYmxlUm93SGVpZ2h0KHRoaXMuc3RhdGUuY2VsbCxnKTtnPTB9O2UucmVzZXQ9ZnVuY3Rpb24oKXtnPTB9O2EucHVzaChlKX0pKGcpfXJldHVybiBudWxsIT1hPwphLnJldmVyc2UoKTpudWxsfTt2YXIgSz1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuc2V0SGFuZGxlc1Zpc2libGU9ZnVuY3Rpb24oYSl7Sy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbCE9dGhpcy5tb3ZlSGFuZGxlcylmb3IodmFyIGI9MDtiPHRoaXMubW92ZUhhbmRsZXMubGVuZ3RoO2IrKyl0aGlzLm1vdmVIYW5kbGVzW2JdLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIjtpZihudWxsIT10aGlzLmNvcm5lckhhbmRsZXMpZm9yKGI9MDtiPHRoaXMuY29ybmVySGFuZGxlcy5sZW5ndGg7YisrKXRoaXMuY29ybmVySGFuZGxlc1tiXS5ub2RlLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIn07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZWZyZXNoTW92ZUhhbmRsZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLm1vZGVsO2lmKG51bGwhPXRoaXMubW92ZUhhbmRsZXMpe2Zvcih2YXIgYj0KMDtiPHRoaXMubW92ZUhhbmRsZXMubGVuZ3RoO2IrKyl0aGlzLm1vdmVIYW5kbGVzW2JdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tb3ZlSGFuZGxlc1tiXSk7dGhpcy5tb3ZlSGFuZGxlcz1udWxsfXRoaXMubW92ZUhhbmRsZXM9W107Zm9yKGI9MDtiPGEuZ2V0Q2hpbGRDb3VudCh0aGlzLnN0YXRlLmNlbGwpO2IrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZihudWxsIT1iJiZhLmlzVmVydGV4KGIuY2VsbCkpe3ZhciBlPW14VXRpbHMuY3JlYXRlSW1hZ2UoRWRpdG9yLnJvd01vdmVJbWFnZSk7ZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Uuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtlLnN0eWxlLndpZHRoPSI3cHgiO2Uuc3R5bGUuaGVpZ2h0PSI0cHgiO2Uucm93U3RhdGU9YjtteEV2ZW50LmFkZEdlc3R1cmVMaXN0ZW5lcnMoZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLnN0b3BFZGl0aW5nKCExKTt0aGlzLmdyYXBoLnNlbGVjdENlbGxGb3JFdmVudChiLmNlbGwsCmEpO3RoaXMuZ3JhcGguZ3JhcGhIYW5kbGVyLnN0YXJ0KHRoaXMuc3RhdGUuY2VsbCxteEV2ZW50LmdldENsaWVudFgoYSksbXhFdmVudC5nZXRDbGllbnRZKGEpLHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuY2VsbFdhc0NsaWNrZWQ9ITA7dGhpcy5ncmFwaC5pc01vdXNlVHJpZ2dlcj1teEV2ZW50LmlzTW91c2VFdmVudChhKTt0aGlzLmdyYXBoLmlzTW91c2VEb3duPSEwO214RXZlbnQuY29uc3VtZShhKX0pKTt0aGlzLm1vdmVIYW5kbGVzLnB1c2goZSk7dGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSl9fSkodGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKGEuZ2V0Q2hpbGRBdCh0aGlzLnN0YXRlLmNlbGwsYikpKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5jdXN0b21IYW5kbGVzKXtmb3IodmFyIGE9MDthPHRoaXMuY3VzdG9tSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMuY3VzdG9tSGFuZGxlc1thXS5kZXN0cm95KCk7CnRoaXMuY3VzdG9tSGFuZGxlcz10aGlzLmNyZWF0ZUN1c3RvbUhhbmRsZXMoKX10aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKSYmdGhpcy5yZWZyZXNoTW92ZUhhbmRsZXMoKX07dmFyIEE9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5nZXRIYW5kbGVQYWRkaW5nO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZ2V0SGFuZGxlUGFkZGluZz1mdW5jdGlvbigpe3ZhciBhPW5ldyBteFBvaW50KDAsMCksYj10aGlzLnRvbGVyYW5jZSxlPXRoaXMuc3RhdGUuc3R5bGUuc2hhcGU7bnVsbD09bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlc1tlXSYmbXhTdGVuY2lsUmVnaXN0cnkuZ2V0U3RlbmNpbChlKTtlPXRoaXMuZ3JhcGguaXNUYWJsZSh0aGlzLnN0YXRlLmNlbGwpfHx0aGlzLmdyYXBoLmNlbGxFZGl0b3IuZ2V0RWRpdGluZ0NlbGwoKT09dGhpcy5zdGF0ZS5jZWxsO2lmKCFlJiZudWxsIT10aGlzLmN1c3RvbUhhbmRsZXMpZm9yKHZhciBjPTA7Yzx0aGlzLmN1c3RvbUhhbmRsZXMubGVuZ3RoO2MrKylpZihudWxsIT0KdGhpcy5jdXN0b21IYW5kbGVzW2NdLnNoYXBlJiZudWxsIT10aGlzLmN1c3RvbUhhbmRsZXNbY10uc2hhcGUuYm91bmRzKXt2YXIgZD10aGlzLmN1c3RvbUhhbmRsZXNbY10uc2hhcGUuYm91bmRzLGY9ZC5nZXRDZW50ZXJYKCksZz1kLmdldENlbnRlclkoKTtpZihNYXRoLmFicyh0aGlzLnN0YXRlLngtZik8ZC53aWR0aC8yfHxNYXRoLmFicyh0aGlzLnN0YXRlLnktZyk8ZC5oZWlnaHQvMnx8TWF0aC5hYnModGhpcy5zdGF0ZS54K3RoaXMuc3RhdGUud2lkdGgtZik8ZC53aWR0aC8yfHxNYXRoLmFicyh0aGlzLnN0YXRlLnkrdGhpcy5zdGF0ZS5oZWlnaHQtZyk8ZC5oZWlnaHQvMil7ZT0hMDticmVha319ZSYmbnVsbCE9dGhpcy5zaXplcnMmJjA8dGhpcy5zaXplcnMubGVuZ3RoJiZudWxsIT10aGlzLnNpemVyc1swXT8oYi89Mix0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKSYmKGIrPTcpLGEueD10aGlzLnNpemVyc1swXS5ib3VuZHMud2lkdGgrYixhLnk9dGhpcy5zaXplcnNbMF0uYm91bmRzLmhlaWdodCsKYik6YT1BLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gYX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVIaW50PWZ1bmN0aW9uKGIpe2lmKHRoaXMuaW5kZXghPW14RXZlbnQuTEFCRUxfSEFORExFKXtudWxsPT10aGlzLmhpbnQmJih0aGlzLmhpbnQ9YSgpLHRoaXMuc3RhdGUudmlldy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oaW50KSk7aWYodGhpcy5pbmRleD09bXhFdmVudC5ST1RBVElPTl9IQU5ETEUpdGhpcy5oaW50LmlubmVySFRNTD10aGlzLmN1cnJlbnRBbHBoYSsiJmRlZzsiO2Vsc2V7Yj10aGlzLnN0YXRlLnZpZXcuc2NhbGU7dmFyIGU9dGhpcy5zdGF0ZS52aWV3LnVuaXQ7dGhpcy5oaW50LmlubmVySFRNTD1jKHRoaXMucm91bmRMZW5ndGgodGhpcy5ib3VuZHMud2lkdGgvYiksZSkrIiB4ICIrYyh0aGlzLnJvdW5kTGVuZ3RoKHRoaXMuYm91bmRzLmhlaWdodC9iKSxlKX1iPW14VXRpbHMuZ2V0Qm91bmRpbmdCb3godGhpcy5ib3VuZHMsCm51bGwhPXRoaXMuY3VycmVudEFscGhhP3RoaXMuY3VycmVudEFscGhhOnRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIpO251bGw9PWImJihiPXRoaXMuYm91bmRzKTt0aGlzLmhpbnQuc3R5bGUubGVmdD1iLngrTWF0aC5yb3VuZCgoYi53aWR0aC10aGlzLmhpbnQuY2xpZW50V2lkdGgpLzIpKyJweCI7dGhpcy5oaW50LnN0eWxlLnRvcD1iLnkrYi5oZWlnaHQrRWRpdG9yLmhpbnRPZmZzZXQrInB4IjtudWxsIT10aGlzLmxpbmtIaW50JiYodGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5PSJub25lIil9fTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ9ZnVuY3Rpb24oKXtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheT0iIil9O3ZhciBNPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLm1vdXNlTW92ZTsKbXhFZGdlSGFuZGxlci5wcm90b3R5cGUubW91c2VNb3ZlPWZ1bmN0aW9uKGEsYil7TS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXImJm51bGwhPXRoaXMuZ3JhcGguZ3JhcGhIYW5kbGVyLmZpcnN0JiZudWxsIT10aGlzLmxpbmtIaW50JiYibm9uZSIhPXRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheSYmKHRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheT0ibm9uZSIpfTt2YXIgUT1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLm1vdXNlVXA9ZnVuY3Rpb24oYSxiKXtRLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT10aGlzLmxpbmtIaW50JiYibm9uZSI9PXRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheSYmKHRoaXMubGlua0hpbnQuc3R5bGUuZGlzcGxheT0iIil9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUhpbnQ9ZnVuY3Rpb24oYixlKXtudWxsPT10aGlzLmhpbnQmJgoodGhpcy5oaW50PWEoKSx0aGlzLnN0YXRlLnZpZXcuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaGludCkpO3ZhciBkPXRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUsZj10aGlzLmdyYXBoLnZpZXcuc2NhbGUsZz10aGlzLnJvdW5kTGVuZ3RoKGUueC9mLWQueCksZD10aGlzLnJvdW5kTGVuZ3RoKGUueS9mLWQueSksZj10aGlzLmdyYXBoLnZpZXcudW5pdDt0aGlzLmhpbnQuaW5uZXJIVE1MPWMoZyxmKSsiLCAiK2MoZCxmKTt0aGlzLmhpbnQuc3R5bGUudmlzaWJpbGl0eT0idmlzaWJsZSI7aWYodGhpcy5pc1NvdXJjZXx8dGhpcy5pc1RhcmdldCludWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50JiZudWxsIT10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRGb2N1cz8oZz10aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmN1cnJlbnRDb25zdHJhaW50LnBvaW50LHRoaXMuaGludC5pbm5lckhUTUw9IlsiK01hdGgucm91bmQoMTAwKmcueCkrCiIlLCAiK01hdGgucm91bmQoMTAwKmcueSkrIiVdIik6dGhpcy5tYXJrZXIuaGFzVmFsaWRTdGF0ZSgpJiYodGhpcy5oaW50LnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiIpO3RoaXMuaGludC5zdHlsZS5sZWZ0PU1hdGgucm91bmQoYi5nZXRHcmFwaFgoKS10aGlzLmhpbnQuY2xpZW50V2lkdGgvMikrInB4Ijt0aGlzLmhpbnQuc3R5bGUudG9wPU1hdGgubWF4KGIuZ2V0R3JhcGhZKCksZS55KStFZGl0b3IuaGludE9mZnNldCsicHgiO251bGwhPXRoaXMubGlua0hpbnQmJih0aGlzLmxpbmtIaW50LnN0eWxlLmRpc3BsYXk9Im5vbmUiKX07bXhFZGdlSGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSGludD1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUhpbnQ7SG92ZXJJY29ucy5wcm90b3R5cGUubWFpbkhhbmRsZT1teENsaWVudC5JU19TVkc/R3JhcGguY3JlYXRlU3ZnSW1hZ2UoMTgsMTgsJzxjaXJjbGUgY3g9IjkiIGN5PSI5IiByPSI1IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrCkhvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIiBzdHJva2Utd2lkdGg9IjEiLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvaGFuZGxlLW1haW4ucG5nIiwxNywxNyk7SG92ZXJJY29ucy5wcm90b3R5cGUuc2Vjb25kYXJ5SGFuZGxlPW14Q2xpZW50LklTX1NWRz9HcmFwaC5jcmVhdGVTdmdJbWFnZSgxNiwxNiwnPHBhdGggZD0ibSA4IDMgTCAxMyA4IEwgOCAxMyBMIDMgOCB6IiBzdHJva2U9IiNmZmYiIGZpbGw9IiNmY2EwMDAiLz4nKTpuZXcgbXhJbWFnZShJTUFHRV9QQVRIKyIvaGFuZGxlLXNlY29uZGFyeS5wbmciLDE3LDE3KTtIb3Zlckljb25zLnByb3RvdHlwZS5maXhlZEhhbmRsZT1teENsaWVudC5JU19TVkc/R3JhcGguY3JlYXRlU3ZnSW1hZ2UoMTgsMTgsJzxjaXJjbGUgY3g9IjkiIGN5PSI5IiByPSI1IiBzdHJva2U9IiNmZmYiIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciIHN0cm9rZS13aWR0aD0iMSIvPjxwYXRoIGQ9Im0gNyA3IEwgMTEgMTEgTSA3IDExIEwgMTEgNyIgc3Ryb2tlPSIjZmZmIi8+Jyk6Cm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9oYW5kbGUtZml4ZWQucG5nIiwxNywxNyk7SG92ZXJJY29ucy5wcm90b3R5cGUudGVybWluYWxIYW5kbGU9bXhDbGllbnQuSVNfU1ZHP0dyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE4LDE4LCc8Y2lyY2xlIGN4PSI5IiBjeT0iOSIgcj0iNSIgc3Ryb2tlPSIjZmZmIiBmaWxsPSInK0hvdmVySWNvbnMucHJvdG90eXBlLmFycm93RmlsbCsnIiBzdHJva2Utd2lkdGg9IjEiLz48Y2lyY2xlIGN4PSI5IiBjeT0iOSIgcj0iMiIgc3Ryb2tlPSIjZmZmIiBmaWxsPSJ0cmFuc3BhcmVudCIvPicpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9oYW5kbGUtdGVybWluYWwucG5nIiwxNywxNyk7SG92ZXJJY29ucy5wcm90b3R5cGUucm90YXRpb25IYW5kbGU9bXhDbGllbnQuSVNfU1ZHP0dyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE2LDE2LCc8cGF0aCBzdHJva2U9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKyciIGZpbGw9IicrSG92ZXJJY29ucy5wcm90b3R5cGUuYXJyb3dGaWxsKwonIiBkPSJNMTUuNTUgNS41NUwxMSAxdjMuMDdDNy4wNiA0LjU2IDQgNy45MiA0IDEyczMuMDUgNy40NCA3IDcuOTN2LTIuMDJjLTIuODQtLjQ4LTUtMi45NC01LTUuOTFzMi4xNi01LjQzIDUtNS45MVYxMGw0LjU1LTQuNDV6TTE5LjkzIDExYy0uMTctMS4zOS0uNzItMi43My0xLjYyLTMuODlsLTEuNDIgMS40MmMuNTQuNzUuODggMS42IDEuMDIgMi40N2gyLjAyek0xMyAxNy45djIuMDJjMS4zOS0uMTcgMi43NC0uNzEgMy45LTEuNjFsLTEuNDQtMS40NGMtLjc1LjU0LTEuNTkuODktMi40NiAxLjAzem0zLjg5LTIuNDJsMS40MiAxLjQxYy45LTEuMTYgMS40NS0yLjUgMS42Mi0zLjg5aC0yLjAyYy0uMTQuODctLjQ4IDEuNzItMS4wMiAyLjQ4eiIvPicsMjQsMjQpOm5ldyBteEltYWdlKElNQUdFX1BBVEgrIi9oYW5kbGUtcm90YXRlLnBuZyIsMTYsMTYpO214Q2xpZW50LklTX1NWRyYmKG14Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnBvaW50SW1hZ2U9R3JhcGguY3JlYXRlU3ZnSW1hZ2UoNSwKNSwnPHBhdGggZD0ibSAwIDAgTCA1IDUgTSAwIDUgTCA1IDAiIHN0cm9rZT0iJytIb3Zlckljb25zLnByb3RvdHlwZS5hcnJvd0ZpbGwrJyIvPicpKTtteFZlcnRleEhhbmRsZXIuVEFCTEVfSEFORExFX0NPTE9SPSIjZmNhMDAwIjtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUltYWdlPUhvdmVySWNvbnMucHJvdG90eXBlLm1haW5IYW5kbGU7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5zZWNvbmRhcnlIYW5kbGVJbWFnZT1Ib3Zlckljb25zLnByb3RvdHlwZS5zZWNvbmRhcnlIYW5kbGU7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2U9SG92ZXJJY29ucy5wcm90b3R5cGUubWFpbkhhbmRsZTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS50ZXJtaW5hbEhhbmRsZUltYWdlPUhvdmVySWNvbnMucHJvdG90eXBlLnRlcm1pbmFsSGFuZGxlO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmZpeGVkSGFuZGxlSW1hZ2U9SG92ZXJJY29ucy5wcm90b3R5cGUuZml4ZWRIYW5kbGU7Cm14RWRnZUhhbmRsZXIucHJvdG90eXBlLmxhYmVsSGFuZGxlSW1hZ2U9SG92ZXJJY29ucy5wcm90b3R5cGUuc2Vjb25kYXJ5SGFuZGxlO214T3V0bGluZS5wcm90b3R5cGUuc2l6ZXJJbWFnZT1Ib3Zlckljb25zLnByb3RvdHlwZS5tYWluSGFuZGxlO251bGwhPXdpbmRvdy5TaWRlYmFyJiYoU2lkZWJhci5wcm90b3R5cGUudHJpYW5nbGVVcD1Ib3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVVwLFNpZGViYXIucHJvdG90eXBlLnRyaWFuZ2xlUmlnaHQ9SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVSaWdodCxTaWRlYmFyLnByb3RvdHlwZS50cmlhbmdsZURvd249SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVEb3duLFNpZGViYXIucHJvdG90eXBlLnRyaWFuZ2xlTGVmdD1Ib3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZUxlZnQsU2lkZWJhci5wcm90b3R5cGUucmVmcmVzaFRhcmdldD1Ib3Zlckljb25zLnByb3RvdHlwZS5yZWZyZXNoVGFyZ2V0LFNpZGViYXIucHJvdG90eXBlLnJvdW5kRHJvcD0KSG92ZXJJY29ucy5wcm90b3R5cGUucm91bmREcm9wKTtteENsaWVudC5JU19TVkd8fCgobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUubWFpbkhhbmRsZS5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLmZpeGVkSGFuZGxlLnNyYywobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUudGVybWluYWxIYW5kbGUuc3JjLChuZXcgSW1hZ2UpLnNyYz1Ib3Zlckljb25zLnByb3RvdHlwZS5zZWNvbmRhcnlIYW5kbGUuc3JjLChuZXcgSW1hZ2UpLnNyYz1Ib3Zlckljb25zLnByb3RvdHlwZS5yb3RhdGlvbkhhbmRsZS5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLnRyaWFuZ2xlVXAuc3JjLChuZXcgSW1hZ2UpLnNyYz1Ib3Zlckljb25zLnByb3RvdHlwZS50cmlhbmdsZVJpZ2h0LnNyYywobmV3IEltYWdlKS5zcmM9SG92ZXJJY29ucy5wcm90b3R5cGUudHJpYW5nbGVEb3duLnNyYywobmV3IEltYWdlKS5zcmM9CkhvdmVySWNvbnMucHJvdG90eXBlLnRyaWFuZ2xlTGVmdC5zcmMsKG5ldyBJbWFnZSkuc3JjPUhvdmVySWNvbnMucHJvdG90eXBlLnJlZnJlc2hUYXJnZXQuc3JjLChuZXcgSW1hZ2UpLnNyYz1Ib3Zlckljb25zLnByb3RvdHlwZS5yb3VuZERyb3Auc3JjKTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJvdGF0aW9uRW5hYmxlZD0hMDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLm1hbmFnZVNpemVycz0hMDtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmxpdmVQcmV2aWV3PSEwO214R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5tYXhMaXZlUHJldmlldz0xNjtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmRlZmF1bHRPcGFjaXR5PTMwO214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLm91dGxpbmVDb25uZWN0PSEwO214Q2VsbEhpZ2hsaWdodC5wcm90b3R5cGUua2VlcE9uVG9wPSEwO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUucGFyZW50SGlnaGxpZ2h0RW5hYmxlZD0hMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5wYXJlbnRIaWdobGlnaHRFbmFibGVkPQohMDtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5kYmxDbGlja1JlbW92ZUVuYWJsZWQ9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuc3RyYWlnaHRSZW1vdmVFbmFibGVkPSEwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnZpcnR1YWxCZW5kc0VuYWJsZWQ9ITA7bXhFZGdlSGFuZGxlci5wcm90b3R5cGUubWVyZ2VSZW1vdmVFbmFibGVkPSEwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLm1hbmFnZUxhYmVsSGFuZGxlPSEwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLm91dGxpbmVDb25uZWN0PSEwO214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzQWRkVmlydHVhbEJlbmRFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hbXhFdmVudC5pc1NoaWZ0RG93bihhLmdldEV2ZW50KCkpfTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pc0N1c3RvbUhhbmRsZUV2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl9O2lmKEdyYXBoLnRvdWNoU3R5bGUpe2lmKG14Q2xpZW50LklTX1RPVUNIfHwKMDxuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHN8fDA8bmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMpbXhTaGFwZS5wcm90b3R5cGUuc3ZnU3Ryb2tlVG9sZXJhbmNlPTE4LG14VmVydGV4SGFuZGxlci5wcm90b3R5cGUudG9sZXJhbmNlPTEyLG14RWRnZUhhbmRsZXIucHJvdG90eXBlLnRvbGVyYW5jZT0xMixHcmFwaC5wcm90b3R5cGUudG9sZXJhbmNlPTEyLG14VmVydGV4SGFuZGxlci5wcm90b3R5cGUucm90YXRpb25IYW5kbGVWU3BhY2luZz0tMTYsbXhDb25zdHJhaW50SGFuZGxlci5wcm90b3R5cGUuZ2V0VG9sZXJhbmNlPWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmlzTW91c2VFdmVudChhLmdldEV2ZW50KCkpPzQ6dGhpcy5ncmFwaC5nZXRUb2xlcmFuY2UoKX07bXhQYW5uaW5nSGFuZGxlci5wcm90b3R5cGUuaXNQYW5uaW5nVHJpZ2dlcj1mdW5jdGlvbihhKXt2YXIgYj1hLmdldEV2ZW50KCk7cmV0dXJuIG51bGw9PWEuZ2V0U3RhdGUoKSYmIW14RXZlbnQuaXNNb3VzZUV2ZW50KGIpfHwKbXhFdmVudC5pc1BvcHVwVHJpZ2dlcihiKSYmKG51bGw9PWEuZ2V0U3RhdGUoKXx8bXhFdmVudC5pc0NvbnRyb2xEb3duKGIpfHxteEV2ZW50LmlzU2hpZnREb3duKGIpKX07dmFyIEk9bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLm1vdXNlRG93bjtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEsYil7SS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bXhFdmVudC5pc1RvdWNoRXZlbnQoYi5nZXRFdmVudCgpKSYmdGhpcy5ncmFwaC5pc0NlbGxTZWxlY3RlZChiLmdldENlbGwoKSkmJjE8dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpJiYodGhpcy5kZWxheWVkU2VsZWN0aW9uPSExKX19ZWxzZSBteFBhbm5pbmdIYW5kbGVyLnByb3RvdHlwZS5pc1Bhbm5pbmdUcmlnZ2VyPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0RXZlbnQoKTtyZXR1cm4gbXhFdmVudC5pc0xlZnRNb3VzZUJ1dHRvbihiKSYmKHRoaXMudXNlTGVmdEJ1dHRvbkZvclBhbm5pbmcmJm51bGw9PQphLmdldFN0YXRlKCl8fG14RXZlbnQuaXNDb250cm9sRG93bihiKSYmIW14RXZlbnQuaXNTaGlmdERvd24oYikpfHx0aGlzLnVzZVBvcHVwVHJpZ2dlciYmbXhFdmVudC5pc1BvcHVwVHJpZ2dlcihiKX07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5pc1NwYWNlRXZlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ3JhcGguaXNFbmFibGVkKCkmJiF0aGlzLmdyYXBoLmlzQ2VsbExvY2tlZCh0aGlzLmdyYXBoLmdldERlZmF1bHRQYXJlbnQoKSkmJm14RXZlbnQuaXNDb250cm9sRG93bihhLmdldEV2ZW50KCkpJiZteEV2ZW50LmlzU2hpZnREb3duKGEuZ2V0RXZlbnQoKSl9O214UnViYmVyYmFuZC5wcm90b3R5cGUuY2FuY2VsbGVkPSExO214UnViYmVyYmFuZC5wcm90b3R5cGUuY2FuY2VsPWZ1bmN0aW9uKCl7dGhpcy5pc0FjdGl2ZSgpJiYodGhpcy5jYW5jZWxsZWQ9ITAsdGhpcy5yZXNldCgpKX07bXhSdWJiZXJiYW5kLnByb3RvdHlwZS5tb3VzZVVwPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5jYW5jZWxsZWQpdGhpcy5jYW5jZWxsZWQ9CiExLGIuY29uc3VtZSgpO2Vsc2V7dmFyIGU9bnVsbCE9dGhpcy5kaXYmJiJub25lIiE9dGhpcy5kaXYuc3R5bGUuZGlzcGxheSxjPW51bGwsZD1udWxsLGY9bnVsbCxnPW51bGw7bnVsbCE9dGhpcy5maXJzdCYmbnVsbCE9dGhpcy5jdXJyZW50WCYmbnVsbCE9dGhpcy5jdXJyZW50WSYmKGM9dGhpcy5maXJzdC54LGQ9dGhpcy5maXJzdC55LGY9KHRoaXMuY3VycmVudFgtYykvdGhpcy5ncmFwaC52aWV3LnNjYWxlLGc9KHRoaXMuY3VycmVudFktZCkvdGhpcy5ncmFwaC52aWV3LnNjYWxlLG14RXZlbnQuaXNBbHREb3duKGIuZ2V0RXZlbnQoKSl8fChmPXRoaXMuZ3JhcGguc25hcChmKSxnPXRoaXMuZ3JhcGguc25hcChnKSx0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWQoKXx8KE1hdGguYWJzKGYpPHRoaXMuZ3JhcGgudG9sZXJhbmNlJiYoZj0wKSxNYXRoLmFicyhnKTx0aGlzLmdyYXBoLnRvbGVyYW5jZSYmKGc9MCkpKSk7dGhpcy5yZXNldCgpO2lmKGUpe2lmKG14RXZlbnQuaXNBbHREb3duKGIuZ2V0RXZlbnQoKSkmJgp0aGlzLmdyYXBoLmlzVG9nZ2xlRXZlbnQoYi5nZXRFdmVudCgpKSl7dmFyIGY9bmV3IG14UmVjdGFuZ2xlKHRoaXMueCx0aGlzLnksdGhpcy53aWR0aCx0aGlzLmhlaWdodCksbD10aGlzLmdyYXBoLmdldENlbGxzKGYueCxmLnksZi53aWR0aCxmLmhlaWdodCk7dGhpcy5ncmFwaC5yZW1vdmVTZWxlY3Rpb25DZWxscyhsKX1lbHNlIGlmKHRoaXMuaXNTcGFjZUV2ZW50KGIpKXt0aGlzLmdyYXBoLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2ZvcihsPXRoaXMuZ3JhcGguZ2V0Q2VsbHNCZXlvbmQoYyxkLHRoaXMuZ3JhcGguZ2V0RGVmYXVsdFBhcmVudCgpLCEwLCEwKSxlPTA7ZTxsLmxlbmd0aDtlKyspaWYodGhpcy5ncmFwaC5pc0NlbGxNb3ZhYmxlKGxbZV0pKXt2YXIgbj10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUobFtlXSksdT10aGlzLmdyYXBoLmdldENlbGxHZW9tZXRyeShsW2VdKTtudWxsIT1uJiZudWxsIT11JiYodT11LmNsb25lKCksdS50cmFuc2xhdGUoZixnKSx0aGlzLmdyYXBoLm1vZGVsLnNldEdlb21ldHJ5KGxbZV0sCnUpKX19ZmluYWxseXt0aGlzLmdyYXBoLm1vZGVsLmVuZFVwZGF0ZSgpfX1lbHNlIGY9bmV3IG14UmVjdGFuZ2xlKHRoaXMueCx0aGlzLnksdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5ncmFwaC5zZWxlY3RSZWdpb24oZixiLmdldEV2ZW50KCkpO2IuY29uc3VtZSgpfX19O214UnViYmVyYmFuZC5wcm90b3R5cGUubW91c2VNb3ZlPWZ1bmN0aW9uKGEsYil7aWYoIWIuaXNDb25zdW1lZCgpJiZudWxsIT10aGlzLmZpcnN0KXt2YXIgZT1teFV0aWxzLmdldFNjcm9sbE9yaWdpbih0aGlzLmdyYXBoLmNvbnRhaW5lciksYz1teFV0aWxzLmdldE9mZnNldCh0aGlzLmdyYXBoLmNvbnRhaW5lcik7ZS54LT1jLng7ZS55LT1jLnk7dmFyIGM9Yi5nZXRYKCkrZS54LGU9Yi5nZXRZKCkrZS55LGQ9dGhpcy5maXJzdC54LWMsZj10aGlzLmZpcnN0LnktZSxnPXRoaXMuZ3JhcGgudG9sZXJhbmNlO2lmKG51bGwhPXRoaXMuZGl2fHxNYXRoLmFicyhkKT5nfHxNYXRoLmFicyhmKT5nKW51bGw9PQp0aGlzLmRpdiYmKHRoaXMuZGl2PXRoaXMuY3JlYXRlU2hhcGUoKSksbXhVdGlscy5jbGVhclNlbGVjdGlvbigpLHRoaXMudXBkYXRlKGMsZSksdGhpcy5pc1NwYWNlRXZlbnQoYik/KGM9dGhpcy54K3RoaXMud2lkdGgsZT10aGlzLnkrdGhpcy5oZWlnaHQsZD10aGlzLmdyYXBoLnZpZXcuc2NhbGUsbXhFdmVudC5pc0FsdERvd24oYi5nZXRFdmVudCgpKXx8KHRoaXMud2lkdGg9dGhpcy5ncmFwaC5zbmFwKHRoaXMud2lkdGgvZCkqZCx0aGlzLmhlaWdodD10aGlzLmdyYXBoLnNuYXAodGhpcy5oZWlnaHQvZCkqZCx0aGlzLmdyYXBoLmlzR3JpZEVuYWJsZWQoKXx8KHRoaXMud2lkdGg8dGhpcy5ncmFwaC50b2xlcmFuY2UmJih0aGlzLndpZHRoPTApLHRoaXMuaGVpZ2h0PHRoaXMuZ3JhcGgudG9sZXJhbmNlJiYodGhpcy5oZWlnaHQ9MCkpLHRoaXMueDx0aGlzLmZpcnN0LngmJih0aGlzLng9Yy10aGlzLndpZHRoKSx0aGlzLnk8dGhpcy5maXJzdC55JiYodGhpcy55PWUtdGhpcy5oZWlnaHQpKSwKdGhpcy5kaXYuc3R5bGUuYm9yZGVyU3R5bGU9ImRhc2hlZCIsdGhpcy5kaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yPSJ3aGl0ZSIsdGhpcy5kaXYuc3R5bGUubGVmdD10aGlzLngrInB4Iix0aGlzLmRpdi5zdHlsZS50b3A9dGhpcy55KyJweCIsdGhpcy5kaXYuc3R5bGUud2lkdGg9TWF0aC5tYXgoMCx0aGlzLndpZHRoKSsicHgiLHRoaXMuZGl2LnN0eWxlLmhlaWdodD10aGlzLmdyYXBoLmNvbnRhaW5lci5jbGllbnRIZWlnaHQrInB4Iix0aGlzLmRpdi5zdHlsZS5ib3JkZXJXaWR0aD0wPj10aGlzLndpZHRoPyIwcHggMXB4IDBweCAwcHgiOiIwcHggMXB4IDBweCAxcHgiLG51bGw9PXRoaXMuc2Vjb25kRGl2JiYodGhpcy5zZWNvbmREaXY9dGhpcy5kaXYuY2xvbmVOb2RlKCEwKSx0aGlzLmRpdi5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuc2Vjb25kRGl2KSksdGhpcy5zZWNvbmREaXYuc3R5bGUubGVmdD10aGlzLngrInB4Iix0aGlzLnNlY29uZERpdi5zdHlsZS50b3A9dGhpcy55KwoicHgiLHRoaXMuc2Vjb25kRGl2LnN0eWxlLndpZHRoPXRoaXMuZ3JhcGguY29udGFpbmVyLmNsaWVudFdpZHRoKyJweCIsdGhpcy5zZWNvbmREaXYuc3R5bGUuaGVpZ2h0PU1hdGgubWF4KDAsdGhpcy5oZWlnaHQpKyJweCIsdGhpcy5zZWNvbmREaXYuc3R5bGUuYm9yZGVyV2lkdGg9MD49dGhpcy5oZWlnaHQ/IjFweCAwcHggMHB4IDBweCI6IjFweCAwcHggMXB4IDBweCIpOih0aGlzLmRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiIsdGhpcy5kaXYuc3R5bGUuYm9yZGVyV2lkdGg9IiIsdGhpcy5kaXYuc3R5bGUuYm9yZGVyU3R5bGU9IiIsbnVsbCE9dGhpcy5zZWNvbmREaXYmJih0aGlzLnNlY29uZERpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2Vjb25kRGl2KSx0aGlzLnNlY29uZERpdj1udWxsKSksYi5jb25zdW1lKCl9fTt2YXIgUj1teFJ1YmJlcmJhbmQucHJvdG90eXBlLnJlc2V0O214UnViYmVyYmFuZC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtudWxsIT0KdGhpcy5zZWNvbmREaXYmJih0aGlzLnNlY29uZERpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2Vjb25kRGl2KSx0aGlzLnNlY29uZERpdj1udWxsKTtSLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIFo9KG5ldyBEYXRlKS5nZXRUaW1lKCksVz0wLGlhPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVByZXZpZXdTdGF0ZTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcmV2aWV3U3RhdGU9ZnVuY3Rpb24oYSxiLGUsYyl7aWEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2UhPXRoaXMuY3VycmVudFRlcm1pbmFsU3RhdGU/KFo9KG5ldyBEYXRlKS5nZXRUaW1lKCksVz0wKTpXPShuZXcgRGF0ZSkuZ2V0VGltZSgpLVo7dGhpcy5jdXJyZW50VGVybWluYWxTdGF0ZT1lfTt2YXIgYmE9bXhFZGdlSGFuZGxlci5wcm90b3R5cGUuaXNPdXRsaW5lQ29ubmVjdEV2ZW50O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmlzT3V0bGluZUNvbm5lY3RFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9CnRoaXMuY3VycmVudFRlcm1pbmFsU3RhdGUmJmEuZ2V0U3RhdGUoKT09dGhpcy5jdXJyZW50VGVybWluYWxTdGF0ZSYmMkUzPFd8fChudWxsPT10aGlzLmN1cnJlbnRUZXJtaW5hbFN0YXRlfHwiMCIhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5jdXJyZW50VGVybWluYWxTdGF0ZS5zdHlsZSwib3V0bGluZUNvbm5lY3QiLCIxIikpJiZiYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUhhbmRsZVNoYXBlPWZ1bmN0aW9uKGEsYil7dmFyIGU9bnVsbCE9YSYmMD09YSxjPXRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoZSksZD1udWxsIT1hJiYoMD09YXx8YT49dGhpcy5zdGF0ZS5hYnNvbHV0ZVBvaW50cy5sZW5ndGgtMXx8dGhpcy5jb25zdHJ1Y3Rvcj09bXhFbGJvd0VkZ2VIYW5kbGVyJiYyPT1hKT90aGlzLmdyYXBoLmdldENvbm5lY3Rpb25Db25zdHJhaW50KHRoaXMuc3RhdGUsYyxlKTpudWxsLGU9bnVsbCE9KG51bGwhPQpkP3RoaXMuZ3JhcGguZ2V0Q29ubmVjdGlvblBvaW50KHRoaXMuc3RhdGUuZ2V0VmlzaWJsZVRlcm1pbmFsU3RhdGUoZSksZCk6bnVsbCk/dGhpcy5maXhlZEhhbmRsZUltYWdlOm51bGwhPWQmJm51bGwhPWM/dGhpcy50ZXJtaW5hbEhhbmRsZUltYWdlOnRoaXMuaGFuZGxlSW1hZ2U7aWYobnVsbCE9ZSlyZXR1cm4gZT1uZXcgbXhJbWFnZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsZS53aWR0aCxlLmhlaWdodCksZS5zcmMpLGUucHJlc2VydmVJbWFnZUFzcGVjdD0hMSxlO2U9bXhDb25zdGFudHMuSEFORExFX1NJWkU7dGhpcy5wcmVmZXJIdG1sJiYtLWU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZVNoYXBlKG5ldyBteFJlY3RhbmdsZSgwLDAsZSxlKSxteENvbnN0YW50cy5IQU5ETEVfRklMTENPTE9SLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUil9O3ZhciBVPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlU2l6ZXJTaGFwZTtteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVNpemVyU2hhcGU9CmZ1bmN0aW9uKGEsYixlKXt0aGlzLmhhbmRsZUltYWdlPWI9PW14RXZlbnQuUk9UQVRJT05fSEFORExFP0hvdmVySWNvbnMucHJvdG90eXBlLnJvdGF0aW9uSGFuZGxlOmI9PW14RXZlbnQuTEFCRUxfSEFORExFP3RoaXMuc2Vjb25kYXJ5SGFuZGxlSW1hZ2U6dGhpcy5oYW5kbGVJbWFnZTtyZXR1cm4gVS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBjYT1teEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3g7bXhHcmFwaEhhbmRsZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94PWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJjE9PWEubGVuZ3RoKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1iLmdldFBhcmVudChhWzBdKSxjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGFbMF0pO2lmKGIuaXNFZGdlKGUpJiZudWxsIT1jJiZjLnJlbGF0aXZlJiYoYj10aGlzLmdyYXBoLnZpZXcuZ2V0U3RhdGUoYVswXSksbnVsbCE9YiYmMj5iLndpZHRoJiYyPmIuaGVpZ2h0JiYKbnVsbCE9Yi50ZXh0JiZudWxsIT1iLnRleHQuYm91bmRpbmdCb3gpKXJldHVybiBteFJlY3RhbmdsZS5mcm9tUmVjdGFuZ2xlKGIudGV4dC5ib3VuZGluZ0JveCl9cmV0dXJuIGNhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGRhPW14R3JhcGhIYW5kbGVyLnByb3RvdHlwZS5nZXRHdWlkZVN0YXRlcztteEdyYXBoSGFuZGxlci5wcm90b3R5cGUuZ2V0R3VpZGVTdGF0ZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9ZGEuYXBwbHkodGhpcyxhcmd1bWVudHMpLGI9W10sZT0wO2U8YS5sZW5ndGg7ZSsrKSIxIiE9bXhVdGlscy5nZXRWYWx1ZShhW2VdLnN0eWxlLCJwYXJ0IiwiMCIpJiZiLnB1c2goYVtlXSk7cmV0dXJuIGJ9O3ZhciBhYT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbkJvdW5kcztteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmdldFNlbGVjdGlvbkJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyYXBoLmdldE1vZGVsKCksZT1iLmdldFBhcmVudChhLmNlbGwpLApjPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEuY2VsbCk7cmV0dXJuIGIuaXNFZGdlKGUpJiZudWxsIT1jJiZjLnJlbGF0aXZlJiYyPmEud2lkdGgmJjI+YS5oZWlnaHQmJm51bGwhPWEudGV4dCYmbnVsbCE9YS50ZXh0LmJvdW5kaW5nQm94PyhiPWEudGV4dC51bnJvdGF0ZWRCb3VuZGluZ0JveHx8YS50ZXh0LmJvdW5kaW5nQm94LG5ldyBteFJlY3RhbmdsZShNYXRoLnJvdW5kKGIueCksTWF0aC5yb3VuZChiLnkpLE1hdGgucm91bmQoYi53aWR0aCksTWF0aC5yb3VuZChiLmhlaWdodCkpKTphYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBUPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUubW91c2VEb3duO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubW91c2VEb3duPWZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcy5ncmFwaC5nZXRNb2RlbCgpLGM9ZS5nZXRQYXJlbnQodGhpcy5zdGF0ZS5jZWxsKSxkPXRoaXMuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KHRoaXMuc3RhdGUuY2VsbCk7Cih0aGlzLmdldEhhbmRsZUZvckV2ZW50KGIpPT1teEV2ZW50LlJPVEFUSU9OX0hBTkRMRXx8IWUuaXNFZGdlKGMpfHxudWxsPT1kfHwhZC5yZWxhdGl2ZXx8bnVsbD09dGhpcy5zdGF0ZXx8Mjw9dGhpcy5zdGF0ZS53aWR0aHx8Mjw9dGhpcy5zdGF0ZS5oZWlnaHQpJiZULmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5yb3RhdGVDbGljaz1mdW5jdGlvbigpe3ZhciBhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUixteENvbnN0YW50cy5OT05FKSxiPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsbXhDb25zdGFudHMuTk9ORSk7dGhpcy5zdGF0ZS52aWV3LmdyYXBoLm1vZGVsLmlzVmVydGV4KHRoaXMuc3RhdGUuY2VsbCkmJmE9PW14Q29uc3RhbnRzLk5PTkUmJmI9PW14Q29uc3RhbnRzLk5PTkU/KGE9bXhVdGlscy5tb2QobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLApteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTiwwKSs5MCwzNjApLHRoaXMuc3RhdGUudmlldy5ncmFwaC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OLGEsW3RoaXMuc3RhdGUuY2VsbF0pKTp0aGlzLnN0YXRlLnZpZXcuZ3JhcGgudHVyblNoYXBlcyhbdGhpcy5zdGF0ZS5jZWxsXSl9O3ZhciBZPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUubW91c2VNb3ZlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubW91c2VNb3ZlPWZ1bmN0aW9uKGEsYil7WS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuZmlyc3QmJihudWxsIT10aGlzLnJvdGF0aW9uU2hhcGUmJm51bGwhPXRoaXMucm90YXRpb25TaGFwZS5ub2RlJiYodGhpcy5yb3RhdGlvblNoYXBlLm5vZGUuc3R5bGUuZGlzcGxheT0ibm9uZSIpLG51bGwhPXRoaXMubGlua0hpbnQmJiJub25lIiE9dGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5JiYodGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5PQoibm9uZSIpKX07dmFyIFA9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5tb3VzZVVwO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUubW91c2VVcD1mdW5jdGlvbihhLGIpe1AuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMucm90YXRpb25TaGFwZSYmbnVsbCE9dGhpcy5yb3RhdGlvblNoYXBlLm5vZGUmJih0aGlzLnJvdGF0aW9uU2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PTE9PXRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKT8iIjoibm9uZSIpO251bGwhPXRoaXMubGlua0hpbnQmJiJub25lIj09dGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5JiYodGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5PSIiKX07dmFyIEw9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pbml0O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe0wuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPSExO251bGwhPXRoaXMucm90YXRpb25TaGFwZSYmdGhpcy5yb3RhdGlvblNoYXBlLm5vZGUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsCm14UmVzb3VyY2VzLmdldCgicm90YXRlVG9vbHRpcCIpKTtpZih0aGlzLmdyYXBoLmlzVGFibGUodGhpcy5zdGF0ZS5jZWxsKSl0aGlzLnJlZnJlc2hNb3ZlSGFuZGxlcygpO2Vsc2UgaWYoMT09dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpJiYodGhpcy5ncmFwaC5pc1RhYmxlQ2VsbCh0aGlzLnN0YXRlLmNlbGwpfHx0aGlzLmdyYXBoLmlzVGFibGVSb3codGhpcy5zdGF0ZS5jZWxsKSkpe3RoaXMuY29ybmVySGFuZGxlcz1bXTtmb3IodmFyIGI9MDs0PmI7YisrKXt2YXIgZT1uZXcgbXhSZWN0YW5nbGVTaGFwZShuZXcgbXhSZWN0YW5nbGUoMCwwLDQsNCksIiNmZmZmZmYiLG14Q29uc3RhbnRzLkhBTkRMRV9TVFJPS0VDT0xPUik7ZS5kaWFsZWN0PXRoaXMuZ3JhcGguZGlhbGVjdCE9bXhDb25zdGFudHMuRElBTEVDVF9TVkc/bXhDb25zdGFudHMuRElBTEVDVF9WTUw6bXhDb25zdGFudHMuRElBTEVDVF9TVkc7ZS5pbml0KHRoaXMuZ3JhcGgudmlldy5nZXRPdmVybGF5UGFuZSgpKTsKdGhpcy5jb3JuZXJIYW5kbGVzLnB1c2goZSl9fXZhciBjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5zcGVjaWFsSGFuZGxlJiYodGhpcy5zcGVjaWFsSGFuZGxlLm5vZGUuc3R5bGUuZGlzcGxheT10aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiZ0aGlzLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCk8dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIubWF4Q2VsbHM/IiI6Im5vbmUiKTt0aGlzLnJlZHJhd0hhbmRsZXMoKX0pO3RoaXMuY2hhbmdlSGFuZGxlcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe3RoaXMudXBkYXRlTGlua0hpbnQodGhpcy5ncmFwaC5nZXRMaW5rRm9yQ2VsbCh0aGlzLnN0YXRlLmNlbGwpLHRoaXMuZ3JhcGguZ2V0TGlua3NGb3JTdGF0ZSh0aGlzLnN0YXRlKSk7YygpfSk7dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Nb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLHRoaXMuY2hhbmdlSGFuZGxlcik7dGhpcy5ncmFwaC5nZXRNb2RlbCgpLmFkZExpc3RlbmVyKG14RXZlbnQuQ0hBTkdFLAp0aGlzLmNoYW5nZUhhbmRsZXIpO3RoaXMuZWRpdGluZ0hhbmRsZXI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLnJlZHJhd0hhbmRsZXMoKX0pO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5FRElUSU5HX1NUT1BQRUQsdGhpcy5lZGl0aW5nSGFuZGxlcik7Yj10aGlzLmdyYXBoLmdldExpbmtGb3JDZWxsKHRoaXMuc3RhdGUuY2VsbCk7ZT10aGlzLmdyYXBoLmdldExpbmtzRm9yU3RhdGUodGhpcy5zdGF0ZSk7dGhpcy51cGRhdGVMaW5rSGludChiLGUpO2lmKG51bGwhPWJ8fG51bGwhPWUmJjA8ZS5sZW5ndGgpYT0hMDthJiZ0aGlzLnJlZHJhd0hhbmRsZXMoKX07bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVMaW5rSGludD1mdW5jdGlvbihiLGUpe3RyeXtpZihudWxsPT1iJiYobnVsbD09ZXx8MD09ZS5sZW5ndGgpfHwxPHRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKSludWxsIT10aGlzLmxpbmtIaW50JiYodGhpcy5saW5rSGludC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubGlua0hpbnQpLAp0aGlzLmxpbmtIaW50PW51bGwpO2Vsc2UgaWYobnVsbCE9Ynx8bnVsbCE9ZSYmMDxlLmxlbmd0aCl7bnVsbD09dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQ9YSgpLHRoaXMubGlua0hpbnQuc3R5bGUucGFkZGluZz0iNnB4IDhweCA2cHggOHB4Iix0aGlzLmxpbmtIaW50LnN0eWxlLm9wYWNpdHk9IjEiLHRoaXMubGlua0hpbnQuc3R5bGUuZmlsdGVyPSIiLHRoaXMuZ3JhcGguY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGlua0hpbnQpKTt0aGlzLmxpbmtIaW50LmlubmVySFRNTD0iIjtpZihudWxsIT1iJiYodGhpcy5saW5rSGludC5hcHBlbmRDaGlsZCh0aGlzLmdyYXBoLmNyZWF0ZUxpbmtGb3JIaW50KGIpKSx0aGlzLmdyYXBoLmlzRW5hYmxlZCgpJiYiZnVuY3Rpb24iPT09dHlwZW9mIHRoaXMuZ3JhcGguZWRpdExpbmspKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtjLnNldEF0dHJpYnV0ZSgic3JjIixFZGl0b3IuZWRpdEltYWdlKTtjLnNldEF0dHJpYnV0ZSgidGl0bGUiLApteFJlc291cmNlcy5nZXQoImVkaXRMaW5rIikpO2Muc2V0QXR0cmlidXRlKCJ3aWR0aCIsIjExIik7Yy5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIjExIik7Yy5zdHlsZS5tYXJnaW5MZWZ0PSIxMHB4IjtjLnN0eWxlLm1hcmdpbkJvdHRvbT0iLTFweCI7Yy5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO3RoaXMubGlua0hpbnQuYXBwZW5kQ2hpbGQoYyk7bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5zZXRTZWxlY3Rpb25DZWxsKHRoaXMuc3RhdGUuY2VsbCk7dGhpcy5ncmFwaC5lZGl0TGluaygpO214RXZlbnQuY29uc3VtZShhKX0pKTt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtkLnNldEF0dHJpYnV0ZSgic3JjIixEaWFsb2cucHJvdG90eXBlLmNsZWFySW1hZ2UpO2Quc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJyZW1vdmVJdCIsW214UmVzb3VyY2VzLmdldCgibGluayIpXSkpOwpkLnNldEF0dHJpYnV0ZSgid2lkdGgiLCIxMyIpO2Quc2V0QXR0cmlidXRlKCJoZWlnaHQiLCIxMCIpO2Quc3R5bGUubWFyZ2luTGVmdD0iNHB4IjtkLnN0eWxlLm1hcmdpbkJvdHRvbT0iLTFweCI7ZC5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO3RoaXMubGlua0hpbnQuYXBwZW5kQ2hpbGQoZCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5ncmFwaC5zZXRMaW5rRm9yQ2VsbCh0aGlzLnN0YXRlLmNlbGwsbnVsbCk7bXhFdmVudC5jb25zdW1lKGEpfSkpfWlmKG51bGwhPWUpZm9yKGM9MDtjPGUubGVuZ3RoO2MrKyl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zi5zdHlsZS5tYXJnaW5Ub3A9bnVsbCE9Ynx8MDxjPyI2cHgiOiIwcHgiO2YuYXBwZW5kQ2hpbGQodGhpcy5ncmFwaC5jcmVhdGVMaW5rRm9ySGludChlW2NdLmdldEF0dHJpYnV0ZSgiaHJlZiIpLG14VXRpbHMuZ2V0VGV4dENvbnRlbnQoZVtjXSkpKTsKdGhpcy5saW5rSGludC5hcHBlbmRDaGlsZChmKX19fWNhdGNoKHFhKXt9fTtteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVMaW5rSGludD1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZUxpbmtIaW50O3ZhciBlYT1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5pbml0O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXtlYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5jb25zdHJhaW50SGFuZGxlci5pc0VuYWJsZWQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS52aWV3LmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLmlzRW5hYmxlZCgpfSk7dmFyIGE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT10aGlzLmxpbmtIaW50JiYodGhpcy5saW5rSGludC5zdHlsZS5kaXNwbGF5PTE9PXRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKT8iIjoibm9uZSIpO251bGwhPXRoaXMubGFiZWxTaGFwZSYmCih0aGlzLmxhYmVsU2hhcGUubm9kZS5zdHlsZS5kaXNwbGF5PXRoaXMuZ3JhcGguaXNFbmFibGVkKCkmJnRoaXMuZ3JhcGguZ2V0U2VsZWN0aW9uQ291bnQoKTx0aGlzLmdyYXBoLmdyYXBoSGFuZGxlci5tYXhDZWxscz8iIjoibm9uZSIpfSk7dGhpcy5jaGFuZ2VIYW5kbGVyPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsZSl7dGhpcy51cGRhdGVMaW5rSGludCh0aGlzLmdyYXBoLmdldExpbmtGb3JDZWxsKHRoaXMuc3RhdGUuY2VsbCksdGhpcy5ncmFwaC5nZXRMaW5rc0ZvclN0YXRlKHRoaXMuc3RhdGUpKTthKCk7dGhpcy5yZWRyYXdIYW5kbGVzKCl9KTt0aGlzLmdyYXBoLmdldFNlbGVjdGlvbk1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5jaGFuZ2VIYW5kbGVyKTt0aGlzLmdyYXBoLmdldE1vZGVsKCkuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5jaGFuZ2VIYW5kbGVyKTt2YXIgYj10aGlzLmdyYXBoLmdldExpbmtGb3JDZWxsKHRoaXMuc3RhdGUuY2VsbCksCmU9dGhpcy5ncmFwaC5nZXRMaW5rc0ZvclN0YXRlKHRoaXMuc3RhdGUpO2lmKG51bGwhPWJ8fG51bGwhPWUmJjA8ZS5sZW5ndGgpdGhpcy51cGRhdGVMaW5rSGludChiLGUpLHRoaXMucmVkcmF3SGFuZGxlcygpfTt2YXIgTz1teENvbm5lY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5pbml0O214Q29ubmVjdGlvbkhhbmRsZXIucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXtPLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmNvbnN0cmFpbnRIYW5kbGVyLmlzRW5hYmxlZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBoLmNvbm5lY3Rpb25IYW5kbGVyLmlzRW5hYmxlZCgpfSl9O3ZhciBYPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUucmVkcmF3SGFuZGxlcztteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLm1vdmVIYW5kbGVzKWZvcih2YXIgYT0wO2E8dGhpcy5tb3ZlSGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMubW92ZUhhbmRsZXNbYV0uc3R5bGUubGVmdD0KdGhpcy5tb3ZlSGFuZGxlc1thXS5yb3dTdGF0ZS54K3RoaXMubW92ZUhhbmRsZXNbYV0ucm93U3RhdGUud2lkdGgtMysicHgiLHRoaXMubW92ZUhhbmRsZXNbYV0uc3R5bGUudG9wPXRoaXMubW92ZUhhbmRsZXNbYV0ucm93U3RhdGUueSt0aGlzLm1vdmVIYW5kbGVzW2FdLnJvd1N0YXRlLmhlaWdodC8yLTIrInB4IjtpZihudWxsIT10aGlzLmNvcm5lckhhbmRsZXMpe3ZhciBhPXRoaXMuZ2V0U2VsZWN0aW9uQm9yZGVySW5zZXQoKSxiPXRoaXMuY29ybmVySGFuZGxlcyxlPWJbMF0uYm91bmRzLmhlaWdodC8yO2JbMF0uYm91bmRzLng9dGhpcy5zdGF0ZS54LWJbMF0uYm91bmRzLndpZHRoLzIrYTtiWzBdLmJvdW5kcy55PXRoaXMuc3RhdGUueS1lK2E7YlswXS5yZWRyYXcoKTtiWzFdLmJvdW5kcy54PWJbMF0uYm91bmRzLngrdGhpcy5zdGF0ZS53aWR0aC0yKmE7YlsxXS5ib3VuZHMueT1iWzBdLmJvdW5kcy55O2JbMV0ucmVkcmF3KCk7YlsyXS5ib3VuZHMueD1iWzBdLmJvdW5kcy54OwpiWzJdLmJvdW5kcy55PXRoaXMuc3RhdGUueSt0aGlzLnN0YXRlLmhlaWdodC0yKmE7YlsyXS5yZWRyYXcoKTtiWzNdLmJvdW5kcy54PWJbMV0uYm91bmRzLng7YlszXS5ib3VuZHMueT1iWzJdLmJvdW5kcy55O2JbM10ucmVkcmF3KCl9bnVsbCE9dGhpcy5yb3RhdGlvblNoYXBlJiZudWxsIT10aGlzLnJvdGF0aW9uU2hhcGUubm9kZSYmKHRoaXMucm90YXRpb25TaGFwZS5ub2RlLnN0eWxlLmRpc3BsYXk9bnVsbCE9dGhpcy5tb3ZlSGFuZGxlc3x8MSE9dGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpfHxudWxsIT10aGlzLmluZGV4JiZ0aGlzLmluZGV4IT1teEV2ZW50LlJPVEFUSU9OX0hBTkRMRT8ibm9uZSI6IiIpO1guYXBwbHkodGhpcyk7bnVsbCE9dGhpcy5zdGF0ZSYmbnVsbCE9dGhpcy5saW5rSGludCYmKGE9bmV3IG14UG9pbnQodGhpcy5zdGF0ZS5nZXRDZW50ZXJYKCksdGhpcy5zdGF0ZS5nZXRDZW50ZXJZKCkpLGI9bmV3IG14UmVjdGFuZ2xlKHRoaXMuc3RhdGUueCwKdGhpcy5zdGF0ZS55LTIyLHRoaXMuc3RhdGUud2lkdGgrMjQsdGhpcy5zdGF0ZS5oZWlnaHQrMjIpLGU9bXhVdGlscy5nZXRCb3VuZGluZ0JveChiLHRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfUk9UQVRJT05dfHwiMCIsYSksYT1udWxsIT1lP214VXRpbHMuZ2V0Qm91bmRpbmdCb3godGhpcy5zdGF0ZSx0aGlzLnN0YXRlLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1JPVEFUSU9OXXx8IjAiKTp0aGlzLnN0YXRlLGI9bnVsbCE9dGhpcy5zdGF0ZS50ZXh0P3RoaXMuc3RhdGUudGV4dC5ib3VuZGluZ0JveDpudWxsLG51bGw9PWUmJihlPXRoaXMuc3RhdGUpLGU9ZS55K2UuaGVpZ2h0LG51bGwhPWImJihlPU1hdGgubWF4KGUsYi55K2IuaGVpZ2h0KSksdGhpcy5saW5rSGludC5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsTWF0aC5yb3VuZChhLngrKGEud2lkdGgtdGhpcy5saW5rSGludC5jbGllbnRXaWR0aCkvMikpKyJweCIsdGhpcy5saW5rSGludC5zdHlsZS50b3A9TWF0aC5yb3VuZChlKwp0aGlzLnZlcnRpY2FsT2Zmc2V0LzIrRWRpdG9yLmhpbnRPZmZzZXQpKyJweCIpfTt2YXIgZ2E9bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95O214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe2dhLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihudWxsIT10aGlzLm1vdmVIYW5kbGVzKXtmb3IodmFyIGE9MDthPHRoaXMubW92ZUhhbmRsZXMubGVuZ3RoO2ErKyl0aGlzLm1vdmVIYW5kbGVzW2FdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tb3ZlSGFuZGxlc1thXSk7dGhpcy5tb3ZlSGFuZGxlcz1udWxsfWlmKG51bGwhPXRoaXMuY29ybmVySGFuZGxlcyl7Zm9yKGE9MDthPHRoaXMuY29ybmVySGFuZGxlcy5sZW5ndGg7YSsrKXRoaXMuY29ybmVySGFuZGxlc1thXS5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb3JuZXJIYW5kbGVzW2FdLm5vZGUpO3RoaXMuY29ybmVySGFuZGxlcz1udWxsfW51bGwhPXRoaXMubGlua0hpbnQmJgoodGhpcy5saW5rSGludC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubGlua0hpbnQpLHRoaXMubGlua0hpbnQ9bnVsbCk7bnVsbCE9dGhpcy5jaGFuZ2VIYW5kbGVyJiYodGhpcy5ncmFwaC5nZXRTZWxlY3Rpb25Nb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMuY2hhbmdlSGFuZGxlciksdGhpcy5ncmFwaC5nZXRNb2RlbCgpLnJlbW92ZUxpc3RlbmVyKHRoaXMuY2hhbmdlSGFuZGxlciksdGhpcy5jaGFuZ2VIYW5kbGVyPW51bGwpO251bGwhPXRoaXMuZWRpdGluZ0hhbmRsZXImJih0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuZWRpdGluZ0hhbmRsZXIpLHRoaXMuZWRpdGluZ0hhbmRsZXI9bnVsbCl9O3ZhciB4YT1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5yZWRyYXdIYW5kbGVzO214RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLm1hcmtlciYmKHhhLmFwcGx5KHRoaXMpLG51bGwhPXRoaXMuc3RhdGUmJm51bGwhPQp0aGlzLmxpbmtIaW50KSl7dmFyIGE9dGhpcy5zdGF0ZTtudWxsIT10aGlzLnN0YXRlLnRleHQmJm51bGwhPXRoaXMuc3RhdGUudGV4dC5ib3VuZHMmJihhPW5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYS5oZWlnaHQpLGEuYWRkKHRoaXMuc3RhdGUudGV4dC5ib3VuZHMpKTt0aGlzLmxpbmtIaW50LnN0eWxlLmxlZnQ9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKGEueCsoYS53aWR0aC10aGlzLmxpbmtIaW50LmNsaWVudFdpZHRoKS8yKSkrInB4Ijt0aGlzLmxpbmtIaW50LnN0eWxlLnRvcD1NYXRoLnJvdW5kKGEueSthLmhlaWdodCtFZGl0b3IuaGludE9mZnNldCkrInB4In19O3ZhciBOPW14RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlc2V0O214RWRnZUhhbmRsZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7Ti5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5saW5rSGludCYmKHRoaXMubGlua0hpbnQuc3R5bGUudmlzaWJpbGl0eT0iIil9O3ZhciBoYT1teEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95OwpteEVkZ2VIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7aGEuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGwhPXRoaXMubGlua0hpbnQmJih0aGlzLmxpbmtIaW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5saW5rSGludCksdGhpcy5saW5rSGludD1udWxsKTtudWxsIT10aGlzLmNoYW5nZUhhbmRsZXImJih0aGlzLmdyYXBoLmdldE1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmdyYXBoLmdldFNlbGVjdGlvbk1vZGVsKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VIYW5kbGVyKSx0aGlzLmNoYW5nZUhhbmRsZXI9bnVsbCl9fSgpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gYygpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBmKCl7bXhDeWxpbmRlci5jYWxsKHRoaXMpfWZ1bmN0aW9uIGQoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gaygpe214Q3lsaW5kZXIuY2FsbCh0aGlzKX1mdW5jdGlvbiBtKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHEoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gYigpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBlKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIGcoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gbigpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBsKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHAoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gdigpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiB0KGEsYil7dGhpcy5jYW52YXM9CmE7dGhpcy5jYW52YXMuc2V0TGluZUpvaW4oInJvdW5kIik7dGhpcy5jYW52YXMuc2V0TGluZUNhcCgicm91bmQiKTt0aGlzLmRlZmF1bHRWYXJpYXRpb249Yjt0aGlzLm9yaWdpbmFsTGluZVRvPXRoaXMuY2FudmFzLmxpbmVUbzt0aGlzLmNhbnZhcy5saW5lVG89bXhVdGlscy5iaW5kKHRoaXMsdC5wcm90b3R5cGUubGluZVRvKTt0aGlzLm9yaWdpbmFsTW92ZVRvPXRoaXMuY2FudmFzLm1vdmVUbzt0aGlzLmNhbnZhcy5tb3ZlVG89bXhVdGlscy5iaW5kKHRoaXMsdC5wcm90b3R5cGUubW92ZVRvKTt0aGlzLm9yaWdpbmFsQ2xvc2U9dGhpcy5jYW52YXMuY2xvc2U7dGhpcy5jYW52YXMuY2xvc2U9bXhVdGlscy5iaW5kKHRoaXMsdC5wcm90b3R5cGUuY2xvc2UpO3RoaXMub3JpZ2luYWxRdWFkVG89dGhpcy5jYW52YXMucXVhZFRvO3RoaXMuY2FudmFzLnF1YWRUbz1teFV0aWxzLmJpbmQodGhpcyx0LnByb3RvdHlwZS5xdWFkVG8pO3RoaXMub3JpZ2luYWxDdXJ2ZVRvPXRoaXMuY2FudmFzLmN1cnZlVG87CnRoaXMuY2FudmFzLmN1cnZlVG89bXhVdGlscy5iaW5kKHRoaXMsdC5wcm90b3R5cGUuY3VydmVUbyk7dGhpcy5vcmlnaW5hbEFyY1RvPXRoaXMuY2FudmFzLmFyY1RvO3RoaXMuY2FudmFzLmFyY1RvPW14VXRpbHMuYmluZCh0aGlzLHQucHJvdG90eXBlLmFyY1RvKX1mdW5jdGlvbiB5KCl7bXhSZWN0YW5nbGVTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIHgoKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gQygpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBCKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIEQoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24geigpe214UmVjdGFuZ2xlU2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBFKCl7bXhSZWN0YW5nbGVTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEcoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gRigpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBIKCl7bXhTaGFwZS5jYWxsKHRoaXMpfQpmdW5jdGlvbiBKKCl7bXhFbGxpcHNlLmNhbGwodGhpcyl9ZnVuY3Rpb24gdSgpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBLKCl7bXhTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEEoKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gTSgpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBRKCl7bXhTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEkoKXtteFNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gUigpe214U2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBaKCl7bXhTaGFwZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIFcoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gaWEoKXtteEN5bGluZGVyLmNhbGwodGhpcyl9ZnVuY3Rpb24gYmEoKXtteFJlY3RhbmdsZVNoYXBlLmNhbGwodGhpcyl9ZnVuY3Rpb24gVSgpe214RG91YmxlRWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIGNhKCl7bXhEb3VibGVFbGxpcHNlLmNhbGwodGhpcyl9ZnVuY3Rpb24gZGEoKXtteEFycm93Q29ubmVjdG9yLmNhbGwodGhpcyk7CnRoaXMuc3BhY2luZz0wfWZ1bmN0aW9uIGFhKCl7bXhBcnJvd0Nvbm5lY3Rvci5jYWxsKHRoaXMpO3RoaXMuc3BhY2luZz0wfWZ1bmN0aW9uIFQoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gWSgpe214UmVjdGFuZ2xlU2hhcGUuY2FsbCh0aGlzKX1mdW5jdGlvbiBQKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIEwoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gZWEoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gTygpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBYKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIGdhKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHhhKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIE4oKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gaGEoKXtteEFjdG9yLmNhbGwodGhpcyl9ZnVuY3Rpb24gUygpe214QWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBmYSgpe214RWxsaXBzZS5jYWxsKHRoaXMpfQpmdW5jdGlvbiBwYSgpe214RWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIHJhKCl7bXhFbGxpcHNlLmNhbGwodGhpcyl9ZnVuY3Rpb24gbGEoKXtteFJob21idXMuY2FsbCh0aGlzKX1mdW5jdGlvbiBxYSgpe214RWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIG5hKCl7bXhFbGxpcHNlLmNhbGwodGhpcyl9ZnVuY3Rpb24gQWEoKXtteEVsbGlwc2UuY2FsbCh0aGlzKX1mdW5jdGlvbiB5YSgpe214RWxsaXBzZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIG9hKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHNhKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIHVhKCl7bXhBY3Rvci5jYWxsKHRoaXMpfWZ1bmN0aW9uIGphKCl7bXhDb25uZWN0b3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBEYShhLGIsZSxjLGQsZixnLGwsbix1KXtnKz1uO3ZhciBrYT1jLmNsb25lKCk7Yy54LT1kKigyKmcrbik7Yy55LT1mKigyKmcrbik7ZCo9ZytuO2YqPWcrbjtyZXR1cm4gZnVuY3Rpb24oKXthLmVsbGlwc2Uoa2EueC0KZC1nLGthLnktZi1nLDIqZywyKmcpO3U/YS5maWxsQW5kU3Ryb2tlKCk6YS5zdHJva2UoKX19bXhVdGlscy5leHRlbmQoYSxteEN5bGluZGVyKTthLnByb3RvdHlwZS5zaXplPTIwO2EucHJvdG90eXBlLmRhcmtPcGFjaXR5PTA7YS5wcm90b3R5cGUuZGFya09wYWNpdHkyPTA7YS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWF4KDAsTWF0aC5taW4oYyxNYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpKSxnPU1hdGgubWF4KC0xLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImRhcmtPcGFjaXR5Iix0aGlzLmRhcmtPcGFjaXR5KSkpKSxrYT1NYXRoLm1heCgtMSxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkYXJrT3BhY2l0eTIiLHRoaXMuZGFya09wYWNpdHkyKSkpKTsKYS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCwwKTthLmxpbmVUbyhjLWYsMCk7YS5saW5lVG8oYyxmKTthLmxpbmVUbyhjLGQpO2EubGluZVRvKGYsZCk7YS5saW5lVG8oMCxkLWYpO2EubGluZVRvKDAsMCk7YS5jbG9zZSgpO2EuZW5kKCk7YS5maWxsQW5kU3Ryb2tlKCk7dGhpcy5vdXRsaW5lfHwoYS5zZXRTaGFkb3coITEpLDAhPWcmJihhLnNldEZpbGxBbHBoYShNYXRoLmFicyhnKSksYS5zZXRGaWxsQ29sb3IoMD5nPyIjRkZGRkZGIjoiIzAwMDAwMCIpLGEuYmVnaW4oKSxhLm1vdmVUbygwLDApLGEubGluZVRvKGMtZiwwKSxhLmxpbmVUbyhjLGYpLGEubGluZVRvKGYsZiksYS5jbG9zZSgpLGEuZmlsbCgpKSwwIT1rYSYmKGEuc2V0RmlsbEFscGhhKE1hdGguYWJzKGthKSksYS5zZXRGaWxsQ29sb3IoMD5rYT8iI0ZGRkZGRiI6IiMwMDAwMDAiKSxhLmJlZ2luKCksYS5tb3ZlVG8oMCwwKSxhLmxpbmVUbyhmLGYpLGEubGluZVRvKGYsZCksYS5saW5lVG8oMCxkLQpmKSxhLmNsb3NlKCksYS5maWxsKCkpLGEuYmVnaW4oKSxhLm1vdmVUbyhmLGQpLGEubGluZVRvKGYsZiksYS5saW5lVG8oMCwwKSxhLm1vdmVUbyhmLGYpLGEubGluZVRvKGMsZiksYS5lbmQoKSxhLnN0cm9rZSgpKX07YS5wcm90b3R5cGUuZ2V0TGFiZWxNYXJnaW5zPWZ1bmN0aW9uKGEpe3JldHVybiBteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImJvdW5kZWRMYmwiLCExKT8oYT1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkqdGhpcy5zY2FsZSxuZXcgbXhSZWN0YW5nbGUoYSxhLDAsMCkpOm51bGx9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImN1YmUiLGEpO3ZhciB2YT1NYXRoLnRhbihteFV0aWxzLnRvUmFkaWFucygzMCkpLG1hPSguNS12YSkvMjtteFV0aWxzLmV4dGVuZChjLG14QWN0b3IpO2MucHJvdG90eXBlLnNpemU9MjA7Yy5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9Ck1hdGgubWluKGMsZC92YSk7YS50cmFuc2xhdGUoKGMtYikvMiwoZC1iKS8yK2IvNCk7YS5tb3ZlVG8oMCwuMjUqYik7YS5saW5lVG8oLjUqYixiKm1hKTthLmxpbmVUbyhiLC4yNSpiKTthLmxpbmVUbyguNSpiLCguNS1tYSkqYik7YS5saW5lVG8oMCwuMjUqYik7YS5jbG9zZSgpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImlzb1JlY3RhbmdsZSIsYyk7bXhVdGlscy5leHRlbmQoZixteEN5bGluZGVyKTtmLnByb3RvdHlwZS5zaXplPTIwO2YucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkLGYpe2I9TWF0aC5taW4oYyxkLyguNSt2YSkpO2Y/KGEubW92ZVRvKDAsLjI1KmIpLGEubGluZVRvKC41KmIsKC41LW1hKSpiKSxhLmxpbmVUbyhiLC4yNSpiKSxhLm1vdmVUbyguNSpiLCguNS1tYSkqYiksYS5saW5lVG8oLjUqYiwoMS1tYSkqYikpOihhLnRyYW5zbGF0ZSgoYy1iKS8yLChkLWIpLzIpLGEubW92ZVRvKDAsLjI1KmIpLGEubGluZVRvKC41KgpiLGIqbWEpLGEubGluZVRvKGIsLjI1KmIpLGEubGluZVRvKGIsLjc1KmIpLGEubGluZVRvKC41KmIsKDEtbWEpKmIpLGEubGluZVRvKDAsLjc1KmIpLGEuY2xvc2UoKSk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiaXNvQ3ViZSIsZik7bXhVdGlscy5leHRlbmQoZCxteEN5bGluZGVyKTtkLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCxmKXtiPU1hdGgubWluKGQvMixNYXRoLnJvdW5kKGQvOCkrdGhpcy5zdHJva2V3aWR0aC0xKTtpZihmJiZudWxsIT10aGlzLmZpbGx8fCFmJiZudWxsPT10aGlzLmZpbGwpYS5tb3ZlVG8oMCxiKSxhLmN1cnZlVG8oMCwyKmIsYywyKmIsYyxiKSxmfHwoYS5zdHJva2UoKSxhLmJlZ2luKCkpLGEudHJhbnNsYXRlKDAsYi8yKSxhLm1vdmVUbygwLGIpLGEuY3VydmVUbygwLDIqYixjLDIqYixjLGIpLGZ8fChhLnN0cm9rZSgpLGEuYmVnaW4oKSksYS50cmFuc2xhdGUoMCxiLzIpLGEubW92ZVRvKDAsYiksCmEuY3VydmVUbygwLDIqYixjLDIqYixjLGIpLGZ8fChhLnN0cm9rZSgpLGEuYmVnaW4oKSksYS50cmFuc2xhdGUoMCwtYik7Znx8KGEubW92ZVRvKDAsYiksYS5jdXJ2ZVRvKDAsLWIvMyxjLC1iLzMsYyxiKSxhLmxpbmVUbyhjLGQtYiksYS5jdXJ2ZVRvKGMsZCtiLzMsMCxkK2IvMywwLGQtYiksYS5jbG9zZSgpKX07ZC5wcm90b3R5cGUuZ2V0TGFiZWxNYXJnaW5zPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwyLjUqTWF0aC5taW4oYS5oZWlnaHQvMixNYXRoLnJvdW5kKGEuaGVpZ2h0LzgpK3RoaXMuc3Ryb2tld2lkdGgtMSksMCwwKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZGF0YXN0b3JlIixkKTtteFV0aWxzLmV4dGVuZChrLG14Q3lsaW5kZXIpO2sucHJvdG90eXBlLnNpemU9MzA7ay5wcm90b3R5cGUuZGFya09wYWNpdHk9MDtrLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9TWF0aC5tYXgoMCwKTWF0aC5taW4oYyxNYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpKSxnPU1hdGgubWF4KC0xLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImRhcmtPcGFjaXR5Iix0aGlzLmRhcmtPcGFjaXR5KSkpKTthLnRyYW5zbGF0ZShiLGUpO2EuYmVnaW4oKTthLm1vdmVUbygwLDApO2EubGluZVRvKGMtZiwwKTthLmxpbmVUbyhjLGYpO2EubGluZVRvKGMsZCk7YS5saW5lVG8oMCxkKTthLmxpbmVUbygwLDApO2EuY2xvc2UoKTthLmVuZCgpO2EuZmlsbEFuZFN0cm9rZSgpO3RoaXMub3V0bGluZXx8KGEuc2V0U2hhZG93KCExKSwwIT1nJiYoYS5zZXRGaWxsQWxwaGEoTWF0aC5hYnMoZykpLGEuc2V0RmlsbENvbG9yKDA+Zz8iI0ZGRkZGRiI6IiMwMDAwMDAiKSxhLmJlZ2luKCksYS5tb3ZlVG8oYy1mLDApLGEubGluZVRvKGMtZixmKSxhLmxpbmVUbyhjLGYpLGEuY2xvc2UoKSwKYS5maWxsKCkpLGEuYmVnaW4oKSxhLm1vdmVUbyhjLWYsMCksYS5saW5lVG8oYy1mLGYpLGEubGluZVRvKGMsZiksYS5lbmQoKSxhLnN0cm9rZSgpKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgibm90ZSIsayk7bXhVdGlscy5leHRlbmQobSxteEFjdG9yKTttLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5tb3ZlVG8oMCwwKTthLnF1YWRUbyhjLzIsLjUqZCxjLDApO2EucXVhZFRvKC41KmMsZC8yLGMsZCk7YS5xdWFkVG8oYy8yLC41KmQsMCxkKTthLnF1YWRUbyguNSpjLGQvMiwwLDApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInN3aXRjaCIsbSk7bXhVdGlscy5leHRlbmQocSxteEN5bGluZGVyKTtxLnByb3RvdHlwZS50YWJXaWR0aD02MDtxLnByb3RvdHlwZS50YWJIZWlnaHQ9MjA7cS5wcm90b3R5cGUudGFiUG9zaXRpb249InJpZ2h0IjtxLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsCmQsZil7Yj1NYXRoLm1heCgwLE1hdGgubWluKGMscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInRhYldpZHRoIix0aGlzLnRhYldpZHRoKSkpKTtlPU1hdGgubWF4KDAsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwidGFiSGVpZ2h0Iix0aGlzLnRhYkhlaWdodCkpKSk7dmFyIGc9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJ0YWJQb3NpdGlvbiIsdGhpcy50YWJQb3NpdGlvbik7Zj8ibGVmdCI9PWc/KGEubW92ZVRvKDAsZSksYS5saW5lVG8oYixlKSk6KGEubW92ZVRvKGMtYixlKSxhLmxpbmVUbyhjLGUpKTooImxlZnQiPT1nPyhhLm1vdmVUbygwLDApLGEubGluZVRvKGIsMCksYS5saW5lVG8oYixlKSxhLmxpbmVUbyhjLGUpKTooYS5tb3ZlVG8oMCxlKSxhLmxpbmVUbyhjLWIsZSksYS5saW5lVG8oYy1iLDApLGEubGluZVRvKGMsMCkpLGEubGluZVRvKGMsZCksYS5saW5lVG8oMCxkKSxhLmxpbmVUbygwLAplKSxhLmNsb3NlKCkpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImZvbGRlciIscSk7bXhVdGlscy5leHRlbmQoYixteEFjdG9yKTtiLnByb3RvdHlwZS5zaXplPTMwO2IucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2IucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPU1hdGgubWF4KDAsTWF0aC5taW4oYyxNYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGMsMCksbmV3IG14UG9pbnQoYyxkKSxuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KDAsYildLHRoaXMuaXNSb3VuZGVkLGUsITApOwphLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJjYXJkIixiKTtteFV0aWxzLmV4dGVuZChlLG14QWN0b3IpO2UucHJvdG90eXBlLnNpemU9LjQ7ZS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9ZCpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7YS5tb3ZlVG8oMCxiLzIpO2EucXVhZFRvKGMvNCwxLjQqYixjLzIsYi8yKTthLnF1YWRUbygzKmMvNCxiKigxLTEuNCksYyxiLzIpO2EubGluZVRvKGMsZC1iLzIpO2EucXVhZFRvKDMqYy80LGQtMS40KmIsYy8yLGQtYi8yKTthLnF1YWRUbyhjLzQsZC1iKigxLTEuNCksMCxkLWIvMik7YS5saW5lVG8oMCxiLzIpO2EuY2xvc2UoKTthLmVuZCgpfTtlLnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz1mdW5jdGlvbihhKXtpZihteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImJvdW5kZWRMYmwiLAohMSkpe3ZhciBiPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSxlPWEud2lkdGgsYz1hLmhlaWdodDtpZihudWxsPT10aGlzLmRpcmVjdGlvbnx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUfHx0aGlzLmRpcmVjdGlvbj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpcmV0dXJuIGIqPWMsbmV3IG14UmVjdGFuZ2xlKGEueCxhLnkrYixlLGMtMipiKTtiKj1lO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYS54K2IsYS55LGUtMipiLGMpfXJldHVybiBhfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ0YXBlIixlKTtteFV0aWxzLmV4dGVuZChnLG14QWN0b3IpO2cucHJvdG90eXBlLnNpemU9LjM7Zy5wcm90b3R5cGUuZ2V0TGFiZWxNYXJnaW5zPWZ1bmN0aW9uKGEpe3JldHVybiBteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImJvdW5kZWRMYmwiLCExKT9uZXcgbXhSZWN0YW5nbGUoMCwwLDAscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCiJzaXplIix0aGlzLnNpemUpKSphLmhlaWdodCk6bnVsbH07Zy5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9ZCpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7YS5tb3ZlVG8oMCwwKTthLmxpbmVUbyhjLDApO2EubGluZVRvKGMsZC1iLzIpO2EucXVhZFRvKDMqYy80LGQtMS40KmIsYy8yLGQtYi8yKTthLnF1YWRUbyhjLzQsZC1iKigxLTEuNCksMCxkLWIvMik7YS5saW5lVG8oMCxiLzIpO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJkb2N1bWVudCIsZyk7dmFyIHphPW14Q3lsaW5kZXIucHJvdG90eXBlLmdldEN5bGluZGVyU2l6ZTtteEN5bGluZGVyLnByb3RvdHlwZS5nZXRDeWxpbmRlclNpemU9ZnVuY3Rpb24oYSxiLGUsYyl7dmFyIGQ9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIik7cmV0dXJuIG51bGwhPQpkP2MqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKTp6YS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214Q3lsaW5kZXIucHJvdG90eXBlLmdldExhYmVsTWFyZ2lucz1mdW5jdGlvbihhKXtpZihteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImJvdW5kZWRMYmwiLCExKSl7dmFyIGI9MipteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLC4xNSk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLE1hdGgubWluKHRoaXMubWF4SGVpZ2h0KnRoaXMuc2NhbGUsYS5oZWlnaHQqYiksMCwwKX1yZXR1cm4gbnVsbH07bXhVdGlscy5leHRlbmQobixteEFjdG9yKTtuLnByb3RvdHlwZS5zaXplPS4yO24ucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O24ucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpOwplPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KGIsMCksbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChjLWIsZCldLHRoaXMuaXNSb3VuZGVkLGUsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInBhcmFsbGVsb2dyYW0iLG4pO214VXRpbHMuZXh0ZW5kKGwsbXhBY3Rvcik7bC5wcm90b3R5cGUuc2l6ZT0uMjtsLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtsLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oLjUscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsZCksbmV3IG14UG9pbnQoYiwwKSxuZXcgbXhQb2ludChjLWIsMCksbmV3IG14UG9pbnQoYyxkKV0sdGhpcy5pc1JvdW5kZWQsZSwhMCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInRyYXBlem9pZCIsbCk7bXhVdGlscy5leHRlbmQocCxteEFjdG9yKTtwLnByb3RvdHlwZS5zaXplPS41O3AucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnNldEZpbGxDb2xvcihudWxsKTtiPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2U9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsCltuZXcgbXhQb2ludChjLDApLG5ldyBteFBvaW50KGIsMCksbmV3IG14UG9pbnQoYixkLzIpLG5ldyBteFBvaW50KDAsZC8yKSxuZXcgbXhQb2ludChiLGQvMiksbmV3IG14UG9pbnQoYixkKSxuZXcgbXhQb2ludChjLGQpXSx0aGlzLmlzUm91bmRlZCxlLCExKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJjdXJseUJyYWNrZXQiLHApO214VXRpbHMuZXh0ZW5kKHYsbXhBY3Rvcik7di5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2Euc2V0U3Ryb2tlV2lkdGgoMSk7YS5zZXRGaWxsQ29sb3IodGhpcy5zdHJva2UpO2I9Yy81O2EucmVjdCgwLDAsYixkKTthLmZpbGxBbmRTdHJva2UoKTthLnJlY3QoMipiLDAsYixkKTthLmZpbGxBbmRTdHJva2UoKTthLnJlY3QoNCpiLDAsYixkKTthLmZpbGxBbmRTdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicGFyYWxsZWxNYXJrZXIiLHYpO3QucHJvdG90eXBlLm1vdmVUbz0KZnVuY3Rpb24oYSxiKXt0aGlzLm9yaWdpbmFsTW92ZVRvLmFwcGx5KHRoaXMuY2FudmFzLGFyZ3VtZW50cyk7dGhpcy5sYXN0WD1hO3RoaXMubGFzdFk9Yjt0aGlzLmZpcnN0WD1hO3RoaXMuZmlyc3RZPWJ9O3QucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5maXJzdFgmJm51bGwhPXRoaXMuZmlyc3RZJiYodGhpcy5saW5lVG8odGhpcy5maXJzdFgsdGhpcy5maXJzdFkpLHRoaXMub3JpZ2luYWxDbG9zZS5hcHBseSh0aGlzLmNhbnZhcyxhcmd1bWVudHMpKTt0aGlzLm9yaWdpbmFsQ2xvc2UuYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKX07dC5wcm90b3R5cGUucXVhZFRvPWZ1bmN0aW9uKGEsYixlLGMpe3RoaXMub3JpZ2luYWxRdWFkVG8uYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKTt0aGlzLmxhc3RYPWU7dGhpcy5sYXN0WT1jfTt0LnByb3RvdHlwZS5jdXJ2ZVRvPWZ1bmN0aW9uKGEsYixlLGMsZCxmKXt0aGlzLm9yaWdpbmFsQ3VydmVUby5hcHBseSh0aGlzLmNhbnZhcywKYXJndW1lbnRzKTt0aGlzLmxhc3RYPWQ7dGhpcy5sYXN0WT1mfTt0LnByb3RvdHlwZS5hcmNUbz1mdW5jdGlvbihhLGIsZSxjLGQsZixnKXt0aGlzLm9yaWdpbmFsQXJjVG8uYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKTt0aGlzLmxhc3RYPWY7dGhpcy5sYXN0WT1nfTt0LnByb3RvdHlwZS5saW5lVG89ZnVuY3Rpb24oYSxiKXtpZihudWxsIT10aGlzLmxhc3RYJiZudWxsIT10aGlzLmxhc3RZKXt2YXIgZT1mdW5jdGlvbihhKXtyZXR1cm4ibnVtYmVyIj09PXR5cGVvZiBhP2E/MD5hPy0xOjE6YT09PWE/MDpOYU46TmFOfSxjPU1hdGguYWJzKGEtdGhpcy5sYXN0WCksZD1NYXRoLmFicyhiLXRoaXMubGFzdFkpLGY9TWF0aC5zcXJ0KGMqYytkKmQpO2lmKDI+Zil7dGhpcy5vcmlnaW5hbExpbmVUby5hcHBseSh0aGlzLmNhbnZhcyxhcmd1bWVudHMpO3RoaXMubGFzdFg9YTt0aGlzLmxhc3RZPWI7cmV0dXJufXZhciBnPU1hdGgucm91bmQoZi8xMCksa2E9dGhpcy5kZWZhdWx0VmFyaWF0aW9uOwo1PmcmJihnPTUsa2EvPTMpO2Zvcih2YXIgbD1lKGEtdGhpcy5sYXN0WCkqYy9nLGU9ZShiLXRoaXMubGFzdFkpKmQvZyxjPWMvZixkPWQvZixmPTA7ZjxnO2YrKyl7dmFyIG49KE1hdGgucmFuZG9tKCktLjUpKmthO3RoaXMub3JpZ2luYWxMaW5lVG8uY2FsbCh0aGlzLmNhbnZhcyxsKmYrdGhpcy5sYXN0WC1uKmQsZSpmK3RoaXMubGFzdFktbipjKX10aGlzLm9yaWdpbmFsTGluZVRvLmNhbGwodGhpcy5jYW52YXMsYSxiKX1lbHNlIHRoaXMub3JpZ2luYWxMaW5lVG8uYXBwbHkodGhpcy5jYW52YXMsYXJndW1lbnRzKTt0aGlzLmxhc3RYPWE7dGhpcy5sYXN0WT1ifTt0LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5jYW52YXMubGluZVRvPXRoaXMub3JpZ2luYWxMaW5lVG87dGhpcy5jYW52YXMubW92ZVRvPXRoaXMub3JpZ2luYWxNb3ZlVG87dGhpcy5jYW52YXMuY2xvc2U9dGhpcy5vcmlnaW5hbENsb3NlO3RoaXMuY2FudmFzLnF1YWRUbz10aGlzLm9yaWdpbmFsUXVhZFRvOwp0aGlzLmNhbnZhcy5jdXJ2ZVRvPXRoaXMub3JpZ2luYWxDdXJ2ZVRvO3RoaXMuY2FudmFzLmFyY1RvPXRoaXMub3JpZ2luYWxBcmNUb307dmFyIElhPW14U2hhcGUucHJvdG90eXBlLnBhaW50O214U2hhcGUucHJvdG90eXBlLmRlZmF1bHRKaWdnbGU9MS41O214U2hhcGUucHJvdG90eXBlLnBhaW50PWZ1bmN0aW9uKGEpe251bGwhPXRoaXMuc3R5bGUmJiIwIiE9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJjb21pYyIsIjAiKSYmbnVsbD09YS5oYW5kSGlnZ2xlJiYoYS5oYW5kSmlnZ2xlPW5ldyB0KGEsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJqaWdnbGUiLHRoaXMuZGVmYXVsdEppZ2dsZSkpKTtJYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9YS5oYW5kSmlnZ2xlJiYoYS5oYW5kSmlnZ2xlLmRlc3Ryb3koKSxkZWxldGUgYS5oYW5kSmlnZ2xlKX07bXhSaG9tYnVzLnByb3RvdHlwZS5kZWZhdWx0SmlnZ2xlPTI7dmFyIEphPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ7Cm14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4obnVsbD09dGhpcy5zdHlsZXx8IjAiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImNvbWljIiwiMCIpKSYmSmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgUGE9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe2lmKG51bGw9PWEuaGFuZEppZ2dsZSlQYS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZWxzZXt2YXIgZj0hMDtudWxsIT10aGlzLnN0eWxlJiYoZj0iMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9QT0lOVEVSX0VWRU5UUywiMSIpKTtpZihmfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORXx8bnVsbCE9dGhpcy5zdHJva2UmJnRoaXMuc3Ryb2tlIT0KbXhDb25zdGFudHMuTk9ORSlmfHxudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORXx8KGEucG9pbnRlckV2ZW50cz0hMSksYS5iZWdpbigpLHRoaXMuaXNSb3VuZGVkPygiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BQlNPTFVURV9BUkNTSVpFLDApP2Y9TWF0aC5taW4oYy8yLE1hdGgubWluKGQvMixteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzIpKTooZj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwxMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUikvMTAwLGY9TWF0aC5taW4oYypmLGQqZikpLGEubW92ZVRvKGIrZixlKSxhLmxpbmVUbyhiK2MtZixlKSxhLnF1YWRUbyhiK2MsZSxiK2MsZStmKSxhLmxpbmVUbyhiK2MsZStkLWYpLGEucXVhZFRvKGIrCmMsZStkLGIrYy1mLGUrZCksYS5saW5lVG8oYitmLGUrZCksYS5xdWFkVG8oYixlK2QsYixlK2QtZiksYS5saW5lVG8oYixlK2YpLGEucXVhZFRvKGIsZSxiK2YsZSkpOihhLm1vdmVUbyhiLGUpLGEubGluZVRvKGIrYyxlKSxhLmxpbmVUbyhiK2MsZStkKSxhLmxpbmVUbyhiLGUrZCksYS5saW5lVG8oYixlKSksYS5jbG9zZSgpLGEuZW5kKCksYS5maWxsQW5kU3Ryb2tlKCl9fTt2YXIgUWE9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe251bGw9PWEuaGFuZEppZ2dsZSYmUWEuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteFV0aWxzLmV4dGVuZCh5LG14UmVjdGFuZ2xlU2hhcGUpO3kucHJvdG90eXBlLnNpemU9LjE7eS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiExfTt5LnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz0KZnVuY3Rpb24oYSl7aWYobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApPT0obnVsbD09dGhpcy5kaXJlY3Rpb258fHRoaXMuZGlyZWN0aW9uPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVHx8dGhpcy5kaXJlY3Rpb249PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUKSl7dmFyIGI9YS53aWR0aCxlPWEuaGVpZ2h0O2E9bmV3IG14UmVjdGFuZ2xlKGEueCxhLnksYixlKTt2YXIgYz1iKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtpZih0aGlzLmlzUm91bmRlZCl2YXIgZD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSwxMDAqbXhDb25zdGFudHMuUkVDVEFOR0xFX1JPVU5ESU5HX0ZBQ1RPUikvMTAwLGM9TWF0aC5tYXgoYyxNYXRoLm1pbihiKmQsZSpkKSk7YS54Kz0KTWF0aC5yb3VuZChjKTthLndpZHRoLT1NYXRoLnJvdW5kKDIqYyl9cmV0dXJuIGF9O3kucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2lmKHRoaXMuaXNSb3VuZGVkKXZhciBnPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLDEwMCpteENvbnN0YW50cy5SRUNUQU5HTEVfUk9VTkRJTkdfRkFDVE9SKS8xMDAsZj1NYXRoLm1heChmLE1hdGgubWluKGMqZyxkKmcpKTtmPU1hdGgucm91bmQoZik7YS5iZWdpbigpO2EubW92ZVRvKGIrZixlKTthLmxpbmVUbyhiK2YsZStkKTthLm1vdmVUbyhiK2MtZixlKTthLmxpbmVUbyhiK2MtZixlK2QpO2EuZW5kKCk7YS5zdHJva2UoKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuYXBwbHkodGhpcywKYXJndW1lbnRzKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicHJvY2VzcyIseSk7bXhVdGlscy5leHRlbmQoeCxteFJlY3RhbmdsZVNoYXBlKTt4LnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnNldEZpbGxDb2xvcihteENvbnN0YW50cy5OT05FKTthLnJlY3QoYixlLGMsZCk7YS5maWxsKCl9O3gucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe307bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidHJhbnNwYXJlbnQiLHgpO214VXRpbHMuZXh0ZW5kKEMsbXhIZXhhZ29uKTtDLnByb3RvdHlwZS5zaXplPTMwO0MucHJvdG90eXBlLnBvc2l0aW9uPS41O0MucHJvdG90eXBlLnBvc2l0aW9uMj0uNTtDLnByb3RvdHlwZS5iYXNlPTIwO0MucHJvdG90eXBlLmdldExhYmVsTWFyZ2lucz1mdW5jdGlvbigpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLDAscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCiJzaXplIix0aGlzLnNpemUpKSp0aGlzLnNjYWxlKX07Qy5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Qy5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO2U9TWF0aC5tYXgoMCxNYXRoLm1pbihkLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO3ZhciBmPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJwb3NpdGlvbiIsdGhpcy5wb3NpdGlvbikpKSksZz1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwicG9zaXRpb24yIix0aGlzLnBvc2l0aW9uMikpKSksbD1NYXRoLm1heCgwLE1hdGgubWluKGMsCnBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJiYXNlIix0aGlzLmJhc2UpKSkpO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsMCksbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChjLGQtZSksbmV3IG14UG9pbnQoTWF0aC5taW4oYyxmK2wpLGQtZSksbmV3IG14UG9pbnQoZyxkKSxuZXcgbXhQb2ludChNYXRoLm1heCgwLGYpLGQtZSksbmV3IG14UG9pbnQoMCxkLWUpXSx0aGlzLmlzUm91bmRlZCxiLCEwLFs0XSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImNhbGxvdXQiLEMpO214VXRpbHMuZXh0ZW5kKEIsbXhBY3Rvcik7Qi5wcm90b3R5cGUuc2l6ZT0uMjtCLnByb3RvdHlwZS5maXhlZFNpemU9MjA7Qi5wcm90b3R5cGUuaXNSb3VuZGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07Qi5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9IjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImZpeGVkU2l6ZSIsCiIwIik/TWF0aC5tYXgoMCxNYXRoLm1pbihjLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLmZpeGVkU2l6ZSkpKSk6YypNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCwwKSxuZXcgbXhQb2ludChjLWIsMCksbmV3IG14UG9pbnQoYyxkLzIpLG5ldyBteFBvaW50KGMtYixkKSxuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KGIsZC8yKV0sdGhpcy5pc1JvdW5kZWQsZSwhMCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgic3RlcCIsQik7bXhVdGlscy5leHRlbmQoRCxteEhleGFnb24pO0QucHJvdG90eXBlLnNpemU9Ci4yNTtELnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtELnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGMtYiwwKSxuZXcgbXhQb2ludChjLC41KmQpLG5ldyBteFBvaW50KGMtYixkKSxuZXcgbXhQb2ludChiLGQpLG5ldyBteFBvaW50KDAsLjUqZCldLHRoaXMuaXNSb3VuZGVkLGUsITApfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJoZXhhZ29uIixEKTtteFV0aWxzLmV4dGVuZCh6LG14UmVjdGFuZ2xlU2hhcGUpO3oucHJvdG90eXBlLmlzSHRtbEFsbG93ZWQ9CmZ1bmN0aW9uKCl7cmV0dXJuITF9O3oucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWluKGMvNSxkLzUpKzE7YS5iZWdpbigpO2EubW92ZVRvKGIrYy8yLGUrZik7YS5saW5lVG8oYitjLzIsZStkLWYpO2EubW92ZVRvKGIrZixlK2QvMik7YS5saW5lVG8oYitjLWYsZStkLzIpO2EuZW5kKCk7YS5zdHJva2UoKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJwbHVzIix6KTt2YXIgTmE9bXhSaG9tYnVzLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlO214UmhvbWJ1cy5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7aWYoMT09dGhpcy5zdHlsZVsiZG91YmxlIl0pe3ZhciBiPSgyKk1hdGgubWF4KDIsdGhpcy5zdHJva2V3aWR0aCsxKStwYXJzZUZsb2F0KHRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOXXx8CjApKSp0aGlzLnNjYWxlO3JldHVybiBuZXcgbXhSZWN0YW5nbGUoYS54K2IsYS55K2IsYS53aWR0aC0yKmIsYS5oZWlnaHQtMipiKX1yZXR1cm4gYX07bXhSaG9tYnVzLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7TmEuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKCF0aGlzLm91dGxpbmUmJjE9PXRoaXMuc3R5bGVbImRvdWJsZSJdKXt2YXIgZj0yKk1hdGgubWF4KDIsdGhpcy5zdHJva2V3aWR0aCsxKStwYXJzZUZsb2F0KHRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOXXx8MCk7Yis9ZjtlKz1mO2MtPTIqZjtkLT0yKmY7MDxjJiYwPGQmJihhLnNldFNoYWRvdyghMSksTmEuYXBwbHkodGhpcyxbYSxiLGUsYyxkXSkpfX07bXhVdGlscy5leHRlbmQoRSxteFJlY3RhbmdsZVNoYXBlKTtFLnByb3RvdHlwZS5pc0h0bWxBbGxvd2VkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0UucHJvdG90eXBlLmdldExhYmVsQm91bmRzPWZ1bmN0aW9uKGEpe2lmKDE9PQp0aGlzLnN0eWxlWyJkb3VibGUiXSl7dmFyIGI9KE1hdGgubWF4KDIsdGhpcy5zdHJva2V3aWR0aCsxKStwYXJzZUZsb2F0KHRoaXMuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfTUFSR0lOXXx8MCkpKnRoaXMuc2NhbGU7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngrYixhLnkrYixhLndpZHRoLTIqYixhLmhlaWdodC0yKmIpfXJldHVybiBhfTtFLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXtpZihudWxsIT10aGlzLnN0eWxlKXtpZighdGhpcy5vdXRsaW5lJiYxPT10aGlzLnN0eWxlWyJkb3VibGUiXSl7dmFyIGY9TWF0aC5tYXgoMix0aGlzLnN0cm9rZXdpZHRoKzEpK3BhcnNlRmxvYXQodGhpcy5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9NQVJHSU5dfHwwKTtiKz1mO2UrPWY7Yy09MipmO2QtPTIqZjswPGMmJjA8ZCYmbXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hLnNldERhc2hlZCghMSk7CnZhciBmPTAsZztkb3tnPW14Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXNbdGhpcy5zdHlsZVsic3ltYm9sIitmXV07aWYobnVsbCE9Zyl7dmFyIGw9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJBbGlnbiJdLG49dGhpcy5zdHlsZVsic3ltYm9sIitmKyJWZXJ0aWNhbEFsaWduIl0sa2E9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJXaWR0aCJdLHU9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJIZWlnaHQiXSxwPXRoaXMuc3R5bGVbInN5bWJvbCIrZisiU3BhY2luZyJdfHwwLHQ9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJWU3BhY2luZyJdfHxwLEE9dGhpcy5zdHlsZVsic3ltYm9sIitmKyJBcmNTcGFjaW5nIl07bnVsbCE9QSYmKEEqPXRoaXMuZ2V0QXJjU2l6ZShjK3RoaXMuc3Ryb2tld2lkdGgsZCt0aGlzLnN0cm9rZXdpZHRoKSxwKz1BLHQrPUEpO3ZhciBBPWIsaz1lLEE9bD09bXhDb25zdGFudHMuQUxJR05fQ0VOVEVSP0ErKGMta2EpLzI6bD09bXhDb25zdGFudHMuQUxJR05fUklHSFQ/QSsKKGMta2EtcCk6QStwLGs9bj09bXhDb25zdGFudHMuQUxJR05fTUlERExFP2srKGQtdSkvMjpuPT1teENvbnN0YW50cy5BTElHTl9CT1RUT00/aysoZC11LXQpOmsrdDthLnNhdmUoKTtsPW5ldyBnO2wuc3R5bGU9dGhpcy5zdHlsZTtnLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmNhbGwobCxhLEEsayxrYSx1KTthLnJlc3RvcmUoKX1mKyt9d2hpbGUobnVsbCE9Zyl9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZXh0IixFKTtteFV0aWxzLmV4dGVuZChHLG14Q3lsaW5kZXIpO0cucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkLGYpe2Y/KGEubW92ZVRvKDAsMCksYS5saW5lVG8oYy8yLGQvMiksYS5saW5lVG8oYywwKSxhLmVuZCgpKTooYS5tb3ZlVG8oMCwwKSxhLmxpbmVUbyhjLDApLGEubGluZVRvKGMsZCksYS5saW5lVG8oMCxkKSwKYS5jbG9zZSgpKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgibWVzc2FnZSIsRyk7bXhVdGlscy5leHRlbmQoRixteFNoYXBlKTtGLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnRyYW5zbGF0ZShiLGUpO2EuZWxsaXBzZShjLzQsMCxjLzIsZC80KTthLmZpbGxBbmRTdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oYy8yLGQvNCk7YS5saW5lVG8oYy8yLDIqZC8zKTthLm1vdmVUbyhjLzIsZC8zKTthLmxpbmVUbygwLGQvMyk7YS5tb3ZlVG8oYy8yLGQvMyk7YS5saW5lVG8oYyxkLzMpO2EubW92ZVRvKGMvMiwyKmQvMyk7YS5saW5lVG8oMCxkKTthLm1vdmVUbyhjLzIsMipkLzMpO2EubGluZVRvKGMsZCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ1bWxBY3RvciIsRik7bXhVdGlscy5leHRlbmQoSCxteFNoYXBlKTtILnByb3RvdHlwZS5nZXRMYWJlbE1hcmdpbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLndpZHRoLwo2LDAsMCwwKX07SC5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCxkLzQpO2EubGluZVRvKDAsMypkLzQpO2EuZW5kKCk7YS5zdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oMCxkLzIpO2EubGluZVRvKGMvNixkLzIpO2EuZW5kKCk7YS5zdHJva2UoKTthLmVsbGlwc2UoYy82LDAsNSpjLzYsZCk7YS5maWxsQW5kU3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbEJvdW5kYXJ5IixIKTtteFV0aWxzLmV4dGVuZChKLG14RWxsaXBzZSk7Si5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe214RWxsaXBzZS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YS5iZWdpbigpO2EubW92ZVRvKGIrYy84LGUrZCk7YS5saW5lVG8oYis3KmMvOCxlK2QpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidW1sRW50aXR5IiwKSik7bXhVdGlscy5leHRlbmQodSxteFNoYXBlKTt1LnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oYywwKTthLmxpbmVUbygwLGQpO2EubW92ZVRvKDAsMCk7YS5saW5lVG8oYyxkKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbERlc3Ryb3kiLHUpO214VXRpbHMuZXh0ZW5kKEssbXhTaGFwZSk7Sy5wcm90b3R5cGUuZ2V0TGFiZWxCb3VuZHM9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngsYS55K2EuaGVpZ2h0LzgsYS53aWR0aCw3KmEuaGVpZ2h0LzgpfTtLLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLnRyYW5zbGF0ZShiLGUpO2EuYmVnaW4oKTthLm1vdmVUbygzKmMvOCxkLzgqMS4xKTthLmxpbmVUbyg1KmMvOCwwKTthLmVuZCgpO2Euc3Ryb2tlKCk7YS5lbGxpcHNlKDAsCmQvOCxjLDcqZC84KTthLmZpbGxBbmRTdHJva2UoKX07Sy5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5iZWdpbigpO2EubW92ZVRvKDMqYy84LGQvOCoxLjEpO2EubGluZVRvKDUqYy84LGQvNCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ1bWxDb250cm9sIixLKTtteFV0aWxzLmV4dGVuZChBLG14UmVjdGFuZ2xlU2hhcGUpO0EucHJvdG90eXBlLnNpemU9NDA7QS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiExfTtBLnByb3RvdHlwZS5nZXRMYWJlbEJvdW5kcz1mdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSp0aGlzLnNjYWxlKSk7cmV0dXJuIG5ldyBteFJlY3RhbmdsZShhLngsYS55LGEud2lkdGgsYil9O0EucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD0KZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1NYXRoLm1heCgwLE1hdGgubWluKGQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSksZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInBhcnRpY2lwYW50Iik7bnVsbD09Z3x8bnVsbD09dGhpcy5zdGF0ZT9teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQuY2FsbCh0aGlzLGEsYixlLGMsZik6KGc9dGhpcy5zdGF0ZS52aWV3LmdyYXBoLmNlbGxSZW5kZXJlci5nZXRTaGFwZShnKSxudWxsIT1nJiZnIT1BJiYoZz1uZXcgZyxnLmFwcGx5KHRoaXMuc3RhdGUpLGEuc2F2ZSgpLGcucGFpbnRWZXJ0ZXhTaGFwZShhLGIsZSxjLGYpLGEucmVzdG9yZSgpKSk7ZjxkJiYoYS5zZXREYXNoZWQoITApLGEuYmVnaW4oKSxhLm1vdmVUbyhiK2MvMixlK2YpLGEubGluZVRvKGIrYy8yLGUrZCksYS5lbmQoKSxhLnN0cm9rZSgpKX07QS5wcm90b3R5cGUucGFpbnRGb3JlZ3JvdW5kPQpmdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPU1hdGgubWF4KDAsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKTtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuY2FsbCh0aGlzLGEsYixlLGMsTWF0aC5taW4oZCxmKSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbExpZmVsaW5lIixBKTtteFV0aWxzLmV4dGVuZChNLG14U2hhcGUpO00ucHJvdG90eXBlLndpZHRoPTYwO00ucHJvdG90eXBlLmhlaWdodD0zMDtNLnByb3RvdHlwZS5jb3JuZXI9MTA7TS5wcm90b3R5cGUuZ2V0TGFiZWxNYXJnaW5zPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbXhSZWN0YW5nbGUoMCwwLGEud2lkdGgtcGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsIndpZHRoIix0aGlzLndpZHRoKSp0aGlzLnNjYWxlKSxhLmhlaWdodC1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKImhlaWdodCIsdGhpcy5oZWlnaHQpKnRoaXMuc2NhbGUpKX07TS5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9dGhpcy5jb3JuZXIsZz1NYXRoLm1pbihjLE1hdGgubWF4KGYscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsIndpZHRoIix0aGlzLndpZHRoKSkpKSxsPU1hdGgubWluKGQsTWF0aC5tYXgoMS41KmYscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImhlaWdodCIsdGhpcy5oZWlnaHQpKSkpLG49bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1NXSU1MQU5FX0ZJTExDT0xPUixteENvbnN0YW50cy5OT05FKTtuIT1teENvbnN0YW50cy5OT05FJiYoYS5zZXRGaWxsQ29sb3IobiksYS5yZWN0KGIsZSxjLGQpLGEuZmlsbCgpKTtudWxsIT10aGlzLmZpbGwmJnRoaXMuZmlsbCE9bXhDb25zdGFudHMuTk9ORSYmdGhpcy5ncmFkaWVudCYmdGhpcy5ncmFkaWVudCE9Cm14Q29uc3RhbnRzLk5PTkU/KHRoaXMuZ2V0R3JhZGllbnRCb3VuZHMoYSxiLGUsYyxkKSxhLnNldEdyYWRpZW50KHRoaXMuZmlsbCx0aGlzLmdyYWRpZW50LGIsZSxjLGQsdGhpcy5ncmFkaWVudERpcmVjdGlvbikpOmEuc2V0RmlsbENvbG9yKHRoaXMuZmlsbCk7YS5iZWdpbigpO2EubW92ZVRvKGIsZSk7YS5saW5lVG8oYitnLGUpO2EubGluZVRvKGIrZyxlK01hdGgubWF4KDAsbC0xLjUqZikpO2EubGluZVRvKGIrTWF0aC5tYXgoMCxnLWYpLGUrbCk7YS5saW5lVG8oYixlK2wpO2EuY2xvc2UoKTthLmZpbGxBbmRTdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oYitnLGUpO2EubGluZVRvKGIrYyxlKTthLmxpbmVUbyhiK2MsZStkKTthLmxpbmVUbyhiLGUrZCk7YS5saW5lVG8oYixlK2wpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInVtbEZyYW1lIixNKTtteFBlcmltZXRlci5MaWZlbGluZVBlcmltZXRlcj1mdW5jdGlvbihhLGIsZSxjKXtjPUEucHJvdG90eXBlLnNpemU7Cm51bGwhPWImJihjPW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSwic2l6ZSIsYykqYi52aWV3LnNjYWxlKTtiPXBhcnNlRmxvYXQoYi5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVFJPS0VXSURUSF18fDEpKmIudmlldy5zY2FsZS8yLTE7ZS54PGEuZ2V0Q2VudGVyWCgpJiYoYj0tMSooYisxKSk7cmV0dXJuIG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpK2IsTWF0aC5taW4oYS55K2EuaGVpZ2h0LE1hdGgubWF4KGEueStjLGUueSkpKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJsaWZlbGluZVBlcmltZXRlciIsbXhQZXJpbWV0ZXIuTGlmZWxpbmVQZXJpbWV0ZXIpO214UGVyaW1ldGVyLk9ydGhvZ29uYWxQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7Yz0hMDtyZXR1cm4gbXhQZXJpbWV0ZXIuUmVjdGFuZ2xlUGVyaW1ldGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJvcnRob2dvbmFsUGVyaW1ldGVyIixteFBlcmltZXRlci5PcnRob2dvbmFsUGVyaW1ldGVyKTsKbXhQZXJpbWV0ZXIuQmFja2JvbmVQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7Yz1wYXJzZUZsb2F0KGIuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RST0tFV0lEVEhdfHwxKSpiLnZpZXcuc2NhbGUvMi0xO251bGwhPWIuc3R5bGUuYmFja2JvbmVTaXplJiYoYys9cGFyc2VGbG9hdChiLnN0eWxlLmJhY2tib25lU2l6ZSkqYi52aWV3LnNjYWxlLzItMSk7aWYoInNvdXRoIj09Yi5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT05dfHwibm9ydGgiPT1iLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTl0pcmV0dXJuIGUueDxhLmdldENlbnRlclgoKSYmKGM9LTEqKGMrMSkpLG5ldyBteFBvaW50KGEuZ2V0Q2VudGVyWCgpK2MsTWF0aC5taW4oYS55K2EuaGVpZ2h0LE1hdGgubWF4KGEueSxlLnkpKSk7ZS55PGEuZ2V0Q2VudGVyWSgpJiYoYz0tMSooYysxKSk7cmV0dXJuIG5ldyBteFBvaW50KE1hdGgubWluKGEueCthLndpZHRoLE1hdGgubWF4KGEueCxlLngpKSwKYS5nZXRDZW50ZXJZKCkrYyl9O214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZSgiYmFja2JvbmVQZXJpbWV0ZXIiLG14UGVyaW1ldGVyLkJhY2tib25lUGVyaW1ldGVyKTtteFBlcmltZXRlci5DYWxsb3V0UGVyaW1ldGVyPWZ1bmN0aW9uKGEsYixlLGMpe3JldHVybiBteFBlcmltZXRlci5SZWN0YW5nbGVQZXJpbWV0ZXIobXhVdGlscy5nZXREaXJlY3RlZEJvdW5kcyhhLG5ldyBteFJlY3RhbmdsZSgwLDAsMCxNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLCJzaXplIixDLnByb3RvdHlwZS5zaXplKSkqYi52aWV3LnNjYWxlKSkpLGIuc3R5bGUpLGIsZSxjKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJjYWxsb3V0UGVyaW1ldGVyIixteFBlcmltZXRlci5DYWxsb3V0UGVyaW1ldGVyKTtteFBlcmltZXRlci5QYXJhbGxlbG9ncmFtUGVyaW1ldGVyPWZ1bmN0aW9uKGEsYixlLGMpe3ZhciBkPW4ucHJvdG90eXBlLnNpemU7Cm51bGwhPWImJihkPW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSwic2l6ZSIsZCkpO3ZhciBmPWEueCxnPWEueSxsPWEud2lkdGgsdT1hLmhlaWdodDtiPW51bGwhPWI/bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0RJUkVDVElPTixteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCk6bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1Q7Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIfHxiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KGQ9dSpNYXRoLm1heCgwLE1hdGgubWluKDEsZCkpLGc9W25ldyBteFBvaW50KGYsZyksbmV3IG14UG9pbnQoZitsLGcrZCksbmV3IG14UG9pbnQoZitsLGcrdSksbmV3IG14UG9pbnQoZixnK3UtZCksbmV3IG14UG9pbnQoZixnKV0pOihkPWwqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKSxnPVtuZXcgbXhQb2ludChmK2QsZyksbmV3IG14UG9pbnQoZitsLGcpLG5ldyBteFBvaW50KGYrbC1kLGcrdSksbmV3IG14UG9pbnQoZiwKZyt1KSxuZXcgbXhQb2ludChmK2QsZyldKTt1PWEuZ2V0Q2VudGVyWCgpO2E9YS5nZXRDZW50ZXJZKCk7YT1uZXcgbXhQb2ludCh1LGEpO2MmJihlLng8Znx8ZS54PmYrbD9hLnk9ZS55OmEueD1lLngpO3JldHVybiBteFV0aWxzLmdldFBlcmltZXRlclBvaW50KGcsYSxlKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJwYXJhbGxlbG9ncmFtUGVyaW1ldGVyIixteFBlcmltZXRlci5QYXJhbGxlbG9ncmFtUGVyaW1ldGVyKTtteFBlcmltZXRlci5UcmFwZXpvaWRQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7dmFyIGQ9bC5wcm90b3R5cGUuc2l6ZTtudWxsIT1iJiYoZD1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsInNpemUiLGQpKTt2YXIgZj1hLngsZz1hLnksbj1hLndpZHRoLHU9YS5oZWlnaHQ7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpOm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUOwpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVD8oZD1uKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQoZitkLGcpLG5ldyBteFBvaW50KGYrbi1kLGcpLG5ldyBteFBvaW50KGYrbixnK3UpLG5ldyBteFBvaW50KGYsZyt1KSxuZXcgbXhQb2ludChmK2QsZyldKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8oZD1uKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQoZixnKSxuZXcgbXhQb2ludChmK24sZyksbmV3IG14UG9pbnQoZituLWQsZyt1KSxuZXcgbXhQb2ludChmK2QsZyt1KSxuZXcgbXhQb2ludChmLGcpXSk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhkPXUqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKSxnPVtuZXcgbXhQb2ludChmLGcrZCksbmV3IG14UG9pbnQoZituLGcpLG5ldyBteFBvaW50KGYrbixnK3UpLG5ldyBteFBvaW50KGYsZyt1LWQpLG5ldyBteFBvaW50KGYsZytkKV0pOihkPXUqTWF0aC5tYXgoMCwKTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQoZixnKSxuZXcgbXhQb2ludChmK24sZytkKSxuZXcgbXhQb2ludChmK24sZyt1LWQpLG5ldyBteFBvaW50KGYsZyt1KSxuZXcgbXhQb2ludChmLGcpXSk7dT1hLmdldENlbnRlclgoKTthPWEuZ2V0Q2VudGVyWSgpO2E9bmV3IG14UG9pbnQodSxhKTtjJiYoZS54PGZ8fGUueD5mK24/YS55PWUueTphLng9ZS54KTtyZXR1cm4gbXhVdGlscy5nZXRQZXJpbWV0ZXJQb2ludChnLGEsZSl9O214U3R5bGVSZWdpc3RyeS5wdXRWYWx1ZSgidHJhcGV6b2lkUGVyaW1ldGVyIixteFBlcmltZXRlci5UcmFwZXpvaWRQZXJpbWV0ZXIpO214UGVyaW1ldGVyLlN0ZXBQZXJpbWV0ZXI9ZnVuY3Rpb24oYSxiLGUsYyl7dmFyIGQ9IjAiIT1teFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsImZpeGVkU2l6ZSIsIjAiKSxmPWQ/Qi5wcm90b3R5cGUuZml4ZWRTaXplOkIucHJvdG90eXBlLnNpemU7bnVsbCE9YiYmKGY9bXhVdGlscy5nZXRWYWx1ZShiLnN0eWxlLAoic2l6ZSIsZikpO3ZhciBnPWEueCxsPWEueSxuPWEud2lkdGgsdT1hLmhlaWdodCxwPWEuZ2V0Q2VudGVyWCgpO2E9YS5nZXRDZW50ZXJZKCk7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sbXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1QpOm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUO2I9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUPyhkPWQ/TWF0aC5tYXgoMCxNYXRoLm1pbihuLGYpKTpuKk1hdGgubWF4KDAsTWF0aC5taW4oMSxmKSksbD1bbmV3IG14UG9pbnQoZyxsKSxuZXcgbXhQb2ludChnK24tZCxsKSxuZXcgbXhQb2ludChnK24sYSksbmV3IG14UG9pbnQoZytuLWQsbCt1KSxuZXcgbXhQb2ludChnLGwrdSksbmV3IG14UG9pbnQoZytkLGEpLG5ldyBteFBvaW50KGcsbCldKTpiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fV0VTVD8oZD1kP01hdGgubWF4KDAsTWF0aC5taW4obixmKSk6bipNYXRoLm1heCgwLApNYXRoLm1pbigxLGYpKSxsPVtuZXcgbXhQb2ludChnK2QsbCksbmV3IG14UG9pbnQoZytuLGwpLG5ldyBteFBvaW50KGcrbi1kLGEpLG5ldyBteFBvaW50KGcrbixsK3UpLG5ldyBteFBvaW50KGcrZCxsK3UpLG5ldyBteFBvaW50KGcsYSksbmV3IG14UG9pbnQoZytkLGwpXSk6Yj09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhkPWQ/TWF0aC5tYXgoMCxNYXRoLm1pbih1LGYpKTp1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxmKSksbD1bbmV3IG14UG9pbnQoZyxsK2QpLG5ldyBteFBvaW50KHAsbCksbmV3IG14UG9pbnQoZytuLGwrZCksbmV3IG14UG9pbnQoZytuLGwrdSksbmV3IG14UG9pbnQocCxsK3UtZCksbmV3IG14UG9pbnQoZyxsK3UpLG5ldyBteFBvaW50KGcsbCtkKV0pOihkPWQ/TWF0aC5tYXgoMCxNYXRoLm1pbih1LGYpKTp1Kk1hdGgubWF4KDAsTWF0aC5taW4oMSxmKSksbD1bbmV3IG14UG9pbnQoZyxsKSxuZXcgbXhQb2ludChwLGwrZCksbmV3IG14UG9pbnQoZysKbixsKSxuZXcgbXhQb2ludChnK24sbCt1LWQpLG5ldyBteFBvaW50KHAsbCt1KSxuZXcgbXhQb2ludChnLGwrdS1kKSxuZXcgbXhQb2ludChnLGwpXSk7cD1uZXcgbXhQb2ludChwLGEpO2MmJihlLng8Z3x8ZS54Pmcrbj9wLnk9ZS55OnAueD1lLngpO3JldHVybiBteFV0aWxzLmdldFBlcmltZXRlclBvaW50KGwscCxlKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJzdGVwUGVyaW1ldGVyIixteFBlcmltZXRlci5TdGVwUGVyaW1ldGVyKTtteFBlcmltZXRlci5IZXhhZ29uUGVyaW1ldGVyMj1mdW5jdGlvbihhLGIsZSxjKXt2YXIgZD1ELnByb3RvdHlwZS5zaXplO251bGwhPWImJihkPW14VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSwic2l6ZSIsZCkpO3ZhciBmPWEueCxnPWEueSxsPWEud2lkdGgsbj1hLmhlaWdodCx1PWEuZ2V0Q2VudGVyWCgpO2E9YS5nZXRDZW50ZXJZKCk7Yj1udWxsIT1iP214VXRpbHMuZ2V0VmFsdWUoYi5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ESVJFQ1RJT04sCm14Q29uc3RhbnRzLkRJUkVDVElPTl9FQVNUKTpteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVDtiPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGI9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD8oZD1uKk1hdGgubWF4KDAsTWF0aC5taW4oMSxkKSksZz1bbmV3IG14UG9pbnQodSxnKSxuZXcgbXhQb2ludChmK2wsZytkKSxuZXcgbXhQb2ludChmK2wsZytuLWQpLG5ldyBteFBvaW50KHUsZytuKSxuZXcgbXhQb2ludChmLGcrbi1kKSxuZXcgbXhQb2ludChmLGcrZCksbmV3IG14UG9pbnQodSxnKV0pOihkPWwqTWF0aC5tYXgoMCxNYXRoLm1pbigxLGQpKSxnPVtuZXcgbXhQb2ludChmK2QsZyksbmV3IG14UG9pbnQoZitsLWQsZyksbmV3IG14UG9pbnQoZitsLGEpLG5ldyBteFBvaW50KGYrbC1kLGcrbiksbmV3IG14UG9pbnQoZitkLGcrbiksbmV3IG14UG9pbnQoZixhKSxuZXcgbXhQb2ludChmK2QsZyldKTt1PW5ldyBteFBvaW50KHUsYSk7YyYmKGUueDxmfHxlLng+ZisKbD91Lnk9ZS55OnUueD1lLngpO3JldHVybiBteFV0aWxzLmdldFBlcmltZXRlclBvaW50KGcsdSxlKX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJoZXhhZ29uUGVyaW1ldGVyMiIsbXhQZXJpbWV0ZXIuSGV4YWdvblBlcmltZXRlcjIpO214VXRpbHMuZXh0ZW5kKFEsbXhTaGFwZSk7US5wcm90b3R5cGUuc2l6ZT0xMDtRLnByb3RvdHlwZS5wYWludEJhY2tncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSk7YS50cmFuc2xhdGUoYixlKTthLmVsbGlwc2UoKGMtZikvMiwwLGYsZik7YS5maWxsQW5kU3Ryb2tlKCk7YS5iZWdpbigpO2EubW92ZVRvKGMvMixmKTthLmxpbmVUbyhjLzIsZCk7YS5lbmQoKTthLnN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJsb2xsaXBvcCIsUSk7bXhVdGlscy5leHRlbmQoSSxteFNoYXBlKTtJLnByb3RvdHlwZS5zaXplPQoxMDtJLnByb3RvdHlwZS5pbnNldD0yO0kucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZD1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSxnPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJpbnNldCIsdGhpcy5pbnNldCkpK3RoaXMuc3Ryb2tld2lkdGg7YS50cmFuc2xhdGUoYixlKTthLmJlZ2luKCk7YS5tb3ZlVG8oYy8yLGYrZyk7YS5saW5lVG8oYy8yLGQpO2EuZW5kKCk7YS5zdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oKGMtZikvMi1nLGYvMik7YS5xdWFkVG8oKGMtZikvMi1nLGYrZyxjLzIsZitnKTthLnF1YWRUbygoYytmKS8yK2csZitnLChjK2YpLzIrZyxmLzIpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicmVxdWlyZXMiLEkpO214VXRpbHMuZXh0ZW5kKFIsbXhTaGFwZSk7Ui5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPQpmdW5jdGlvbihhLGIsZSxjLGQpe2EudHJhbnNsYXRlKGIsZSk7YS5iZWdpbigpO2EubW92ZVRvKDAsMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsMCxkKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInJlcXVpcmVkSW50ZXJmYWNlIixSKTtteFV0aWxzLmV4dGVuZChaLG14U2hhcGUpO1oucHJvdG90eXBlLmluc2V0PTI7Wi5wcm90b3R5cGUucGFpbnRCYWNrZ3JvdW5kPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImluc2V0Iix0aGlzLmluc2V0KSkrdGhpcy5zdHJva2V3aWR0aDthLnRyYW5zbGF0ZShiLGUpO2EuZWxsaXBzZSgwLGYsYy0yKmYsZC0yKmYpO2EuZmlsbEFuZFN0cm9rZSgpO2EuYmVnaW4oKTthLm1vdmVUbyhjLzIsMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsYy8yLGQpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicHJvdmlkZWRSZXF1aXJlZEludGVyZmFjZSIsClopO214VXRpbHMuZXh0ZW5kKFcsbXhDeWxpbmRlcik7Vy5wcm90b3R5cGUuamV0dHlXaWR0aD0yMDtXLnByb3RvdHlwZS5qZXR0eUhlaWdodD0xMDtXLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCxmKXt2YXIgZz1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiamV0dHlXaWR0aCIsdGhpcy5qZXR0eVdpZHRoKSk7Yj1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiamV0dHlIZWlnaHQiLHRoaXMuamV0dHlIZWlnaHQpKTtlPWcvMjt2YXIgZz1lK2cvMixsPU1hdGgubWluKGIsZC1iKSxuPU1hdGgubWluKGwrMipiLGQtYik7Zj8oYS5tb3ZlVG8oZSxsKSxhLmxpbmVUbyhnLGwpLGEubGluZVRvKGcsbCtiKSxhLmxpbmVUbyhlLGwrYiksYS5tb3ZlVG8oZSxuKSxhLmxpbmVUbyhnLG4pLGEubGluZVRvKGcsbitiKSxhLmxpbmVUbyhlLG4rYikpOihhLm1vdmVUbyhlLDApLGEubGluZVRvKGMsMCksYS5saW5lVG8oYywKZCksYS5saW5lVG8oZSxkKSxhLmxpbmVUbyhlLG4rYiksYS5saW5lVG8oMCxuK2IpLGEubGluZVRvKDAsbiksYS5saW5lVG8oZSxuKSxhLmxpbmVUbyhlLGwrYiksYS5saW5lVG8oMCxsK2IpLGEubGluZVRvKDAsbCksYS5saW5lVG8oZSxsKSxhLmNsb3NlKCkpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoIm1vZHVsZSIsVyk7bXhVdGlscy5leHRlbmQoaWEsbXhDeWxpbmRlcik7aWEucHJvdG90eXBlLmpldHR5V2lkdGg9MzI7aWEucHJvdG90eXBlLmpldHR5SGVpZ2h0PTEyO2lhLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCxmKXt2YXIgZz1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiamV0dHlXaWR0aCIsdGhpcy5qZXR0eVdpZHRoKSk7Yj1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiamV0dHlIZWlnaHQiLHRoaXMuamV0dHlIZWlnaHQpKTtlPWcvMjt2YXIgZz1lK2cvMixsPS4zKgpkLWIvMixuPS43KmQtYi8yO2Y/KGEubW92ZVRvKGUsbCksYS5saW5lVG8oZyxsKSxhLmxpbmVUbyhnLGwrYiksYS5saW5lVG8oZSxsK2IpLGEubW92ZVRvKGUsbiksYS5saW5lVG8oZyxuKSxhLmxpbmVUbyhnLG4rYiksYS5saW5lVG8oZSxuK2IpKTooYS5tb3ZlVG8oZSwwKSxhLmxpbmVUbyhjLDApLGEubGluZVRvKGMsZCksYS5saW5lVG8oZSxkKSxhLmxpbmVUbyhlLG4rYiksYS5saW5lVG8oMCxuK2IpLGEubGluZVRvKDAsbiksYS5saW5lVG8oZSxuKSxhLmxpbmVUbyhlLGwrYiksYS5saW5lVG8oMCxsK2IpLGEubGluZVRvKDAsbCksYS5saW5lVG8oZSxsKSxhLmNsb3NlKCkpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImNvbXBvbmVudCIsaWEpO214VXRpbHMuZXh0ZW5kKGJhLG14UmVjdGFuZ2xlU2hhcGUpO2JhLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1jLzIsZz1kLzIsbD1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO2EuYmVnaW4oKTt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludChiK2YsZSksbmV3IG14UG9pbnQoYitjLGUrZyksbmV3IG14UG9pbnQoYitmLGUrZCksbmV3IG14UG9pbnQoYixlK2cpXSx0aGlzLmlzUm91bmRlZCxsLCEwKTthLnN0cm9rZSgpO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50Rm9yZWdyb3VuZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImFzc29jaWF0aXZlRW50aXR5IixiYSk7bXhVdGlscy5leHRlbmQoVSxteERvdWJsZUVsbGlwc2UpO1UucHJvdG90eXBlLm91dGVyU3Ryb2tlPSEwO1UucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1NYXRoLm1pbig0LE1hdGgubWluKGMvNSxkLzUpKTswPGMmJjA8ZCYmKGEuZWxsaXBzZShiK2YsZStmLGMtMipmLGQtMipmKSwKYS5maWxsQW5kU3Ryb2tlKCkpO2Euc2V0U2hhZG93KCExKTt0aGlzLm91dGVyU3Ryb2tlJiYoYS5lbGxpcHNlKGIsZSxjLGQpLGEuc3Ryb2tlKCkpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJlbmRTdGF0ZSIsVSk7bXhVdGlscy5leHRlbmQoY2EsVSk7Y2EucHJvdG90eXBlLm91dGVyU3Ryb2tlPSExO214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInN0YXJ0U3RhdGUiLGNhKTtteFV0aWxzLmV4dGVuZChkYSxteEFycm93Q29ubmVjdG9yKTtkYS5wcm90b3R5cGUuZGVmYXVsdFdpZHRoPTQ7ZGEucHJvdG90eXBlLmlzT3BlbkVuZGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2RhLnByb3RvdHlwZS5nZXRFZGdlV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSwid2lkdGgiLHRoaXMuZGVmYXVsdFdpZHRoKStNYXRoLm1heCgwLHRoaXMuc3Ryb2tld2lkdGgtMSl9O2RhLnByb3RvdHlwZS5pc0Fycm93Um91bmRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUm91bmRlZH07Cm14Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImxpbmsiLGRhKTtteFV0aWxzLmV4dGVuZChhYSxteEFycm93Q29ubmVjdG9yKTthYS5wcm90b3R5cGUuZGVmYXVsdFdpZHRoPTEwO2FhLnByb3RvdHlwZS5kZWZhdWx0QXJyb3dXaWR0aD0yMDthYS5wcm90b3R5cGUuZ2V0U3RhcnRBcnJvd1dpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZVdpZHRoKCkrbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSwic3RhcnRXaWR0aCIsdGhpcy5kZWZhdWx0QXJyb3dXaWR0aCl9O2FhLnByb3RvdHlwZS5nZXRFbmRBcnJvd1dpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZVdpZHRoKCkrbXhVdGlscy5nZXROdW1iZXIodGhpcy5zdHlsZSwiZW5kV2lkdGgiLHRoaXMuZGVmYXVsdEFycm93V2lkdGgpfTthYS5wcm90b3R5cGUuZ2V0RWRnZVdpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIG14VXRpbHMuZ2V0TnVtYmVyKHRoaXMuc3R5bGUsIndpZHRoIix0aGlzLmRlZmF1bHRXaWR0aCkrCk1hdGgubWF4KDAsdGhpcy5zdHJva2V3aWR0aC0xKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiZmxleEFycm93IixhYSk7bXhVdGlscy5leHRlbmQoVCxteEFjdG9yKTtULnByb3RvdHlwZS5zaXplPTMwO1QucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O1QucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPU1hdGgubWluKGQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKTtlPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSkvMjt0aGlzLmFkZFBvaW50cyhhLFtuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KDAsYiksbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChjLGQpXSx0aGlzLmlzUm91bmRlZCxlLCEwKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJtYW51YWxJbnB1dCIsClQpO214VXRpbHMuZXh0ZW5kKFksbXhSZWN0YW5nbGVTaGFwZSk7WS5wcm90b3R5cGUuZHg9MjA7WS5wcm90b3R5cGUuZHk9MjA7WS5wcm90b3R5cGUuaXNIdG1sQWxsb3dlZD1mdW5jdGlvbigpe3JldHVybiExfTtZLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQ9ZnVuY3Rpb24oYSxiLGUsYyxkKXtteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5wYWludEZvcmVncm91bmQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBmPTA7aWYodGhpcy5pc1JvdW5kZWQpdmFyIGc9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsMTAwKm14Q29uc3RhbnRzLlJFQ1RBTkdMRV9ST1VORElOR19GQUNUT1IpLzEwMCxmPU1hdGgubWF4KGYsTWF0aC5taW4oYypnLGQqZykpO2c9TWF0aC5tYXgoZixNYXRoLm1pbihjLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkeCIsdGhpcy5keCkpKSk7Zj1NYXRoLm1heChmLE1hdGgubWluKGQsCnBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkeSIsdGhpcy5keSkpKSk7YS5iZWdpbigpO2EubW92ZVRvKGIsZStmKTthLmxpbmVUbyhiK2MsZStmKTthLmVuZCgpO2Euc3Ryb2tlKCk7YS5iZWdpbigpO2EubW92ZVRvKGIrZyxlKTthLmxpbmVUbyhiK2csZStkKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImludGVybmFsU3RvcmFnZSIsWSk7bXhVdGlscy5leHRlbmQoUCxteEFjdG9yKTtQLnByb3RvdHlwZS5keD0yMDtQLnByb3RvdHlwZS5keT0yMDtQLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1heCgwLE1hdGgubWluKGMscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR4Iix0aGlzLmR4KSkpKTtlPU1hdGgubWF4KDAsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZHkiLHRoaXMuZHkpKSkpO3BhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoic2l6ZSIsdGhpcy5zaXplKSk7dmFyIGY9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsMCksbmV3IG14UG9pbnQoYywwKSxuZXcgbXhQb2ludChjLGUpLG5ldyBteFBvaW50KGIsZSksbmV3IG14UG9pbnQoYixkKSxuZXcgbXhQb2ludCgwLGQpXSx0aGlzLmlzUm91bmRlZCxmLCEwKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJjb3JuZXIiLFApO214VXRpbHMuZXh0ZW5kKEwsbXhBY3Rvcik7TC5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2EubW92ZVRvKDAsMCk7YS5saW5lVG8oMCxkKTthLmVuZCgpO2EubW92ZVRvKGMsMCk7YS5saW5lVG8oYyxkKTthLmVuZCgpO2EubW92ZVRvKDAsZC8yKTthLmxpbmVUbyhjLGQvMik7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgiY3Jvc3NiYXIiLApMKTtteFV0aWxzLmV4dGVuZChlYSxteEFjdG9yKTtlYS5wcm90b3R5cGUuZHg9MjA7ZWEucHJvdG90eXBlLmR5PTIwO2VhLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1heCgwLE1hdGgubWluKGMscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR4Iix0aGlzLmR4KSkpKTtlPU1hdGgubWF4KDAsTWF0aC5taW4oZCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZHkiLHRoaXMuZHkpKSkpO3BhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKTt2YXIgZj1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCwwKSxuZXcgbXhQb2ludChjLDApLG5ldyBteFBvaW50KGMsZSksbmV3IG14UG9pbnQoKGMrCmIpLzIsZSksbmV3IG14UG9pbnQoKGMrYikvMixkKSxuZXcgbXhQb2ludCgoYy1iKS8yLGQpLG5ldyBteFBvaW50KChjLWIpLzIsZSksbmV3IG14UG9pbnQoMCxlKV0sdGhpcy5pc1JvdW5kZWQsZiwhMCk7YS5lbmQoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidGVlIixlYSk7bXhVdGlscy5leHRlbmQoTyxteEFjdG9yKTtPLnByb3RvdHlwZS5hcnJvd1dpZHRoPS4zO08ucHJvdG90eXBlLmFycm93U2l6ZT0uMjtPLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9ZCpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93V2lkdGgiLHRoaXMuYXJyb3dXaWR0aCkpKSk7Yj1jKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiYXJyb3dTaXplIix0aGlzLmFycm93U2l6ZSkpKSk7ZT0oZC1mKS8yO3ZhciBmPWUrZiwKZz1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoMCxlKSxuZXcgbXhQb2ludChjLWIsZSksbmV3IG14UG9pbnQoYy1iLDApLG5ldyBteFBvaW50KGMsZC8yKSxuZXcgbXhQb2ludChjLWIsZCksbmV3IG14UG9pbnQoYy1iLGYpLG5ldyBteFBvaW50KDAsZildLHRoaXMuaXNSb3VuZGVkLGcsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInNpbmdsZUFycm93IixPKTtteFV0aWxzLmV4dGVuZChYLG14QWN0b3IpO1gucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXt2YXIgZj1kKk1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiYXJyb3dXaWR0aCIsTy5wcm90b3R5cGUuYXJyb3dXaWR0aCkpKSk7Yj1jKk1hdGgubWF4KDAsCk1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93U2l6ZSIsTy5wcm90b3R5cGUuYXJyb3dTaXplKSkpKTtlPShkLWYpLzI7dmFyIGY9ZStmLGc9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsZC8yKSxuZXcgbXhQb2ludChiLDApLG5ldyBteFBvaW50KGIsZSksbmV3IG14UG9pbnQoYy1iLGUpLG5ldyBteFBvaW50KGMtYiwwKSxuZXcgbXhQb2ludChjLGQvMiksbmV3IG14UG9pbnQoYy1iLGQpLG5ldyBteFBvaW50KGMtYixmKSxuZXcgbXhQb2ludChiLGYpLG5ldyBteFBvaW50KGIsZCldLHRoaXMuaXNSb3VuZGVkLGcsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImRvdWJsZUFycm93IixYKTtteFV0aWxzLmV4dGVuZChnYSxteEFjdG9yKTtnYS5wcm90b3R5cGUuc2l6ZT0KLjE7Z2EucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPWMqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2EubW92ZVRvKGIsMCk7YS5saW5lVG8oYywwKTthLnF1YWRUbyhjLTIqYixkLzIsYyxkKTthLmxpbmVUbyhiLGQpO2EucXVhZFRvKGItMipiLGQvMixiLDApO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJkYXRhU3RvcmFnZSIsZ2EpO214VXRpbHMuZXh0ZW5kKHhhLG14QWN0b3IpO3hhLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7YS5tb3ZlVG8oMCwwKTthLnF1YWRUbyhjLDAsYyxkLzIpO2EucXVhZFRvKGMsZCwwLGQpO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJvciIseGEpO214VXRpbHMuZXh0ZW5kKE4sbXhBY3Rvcik7Ti5wcm90b3R5cGUucmVkcmF3UGF0aD0KZnVuY3Rpb24oYSxiLGUsYyxkKXthLm1vdmVUbygwLDApO2EucXVhZFRvKGMsMCxjLGQvMik7YS5xdWFkVG8oYyxkLDAsZCk7YS5xdWFkVG8oYy8yLGQvMiwwLDApO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJ4b3IiLE4pO214VXRpbHMuZXh0ZW5kKGhhLG14QWN0b3IpO2hhLnByb3RvdHlwZS5zaXplPTIwO2hhLnByb3RvdHlwZS5pc1JvdW5kYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtoYS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9TWF0aC5taW4oYy8yLE1hdGgubWluKGQscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7ZT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7dGhpcy5hZGRQb2ludHMoYSxbbmV3IG14UG9pbnQoYiwwKSxuZXcgbXhQb2ludChjLQpiLDApLG5ldyBteFBvaW50KGMsLjgqYiksbmV3IG14UG9pbnQoYyxkKSxuZXcgbXhQb2ludCgwLGQpLG5ldyBteFBvaW50KDAsLjgqYildLHRoaXMuaXNSb3VuZGVkLGUsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImxvb3BMaW1pdCIsaGEpO214VXRpbHMuZXh0ZW5kKFMsbXhBY3Rvcik7Uy5wcm90b3R5cGUuc2l6ZT0uMzc1O1MucHJvdG90eXBlLmlzUm91bmRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITB9O1MucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPWQqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO2U9bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsbXhDb25zdGFudHMuTElORV9BUkNTSVpFKS8yO3RoaXMuYWRkUG9pbnRzKGEsW25ldyBteFBvaW50KDAsMCksbmV3IG14UG9pbnQoYywKMCksbmV3IG14UG9pbnQoYyxkLWIpLG5ldyBteFBvaW50KGMvMixkKSxuZXcgbXhQb2ludCgwLGQtYildLHRoaXMuaXNSb3VuZGVkLGUsITApO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoIm9mZlBhZ2VDb25uZWN0b3IiLFMpO214VXRpbHMuZXh0ZW5kKGZhLG14RWxsaXBzZSk7ZmEucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXtteEVsbGlwc2UucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuYmVnaW4oKTthLm1vdmVUbyhiK2MvMixlK2QpO2EubGluZVRvKGIrYyxlK2QpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgidGFwZURhdGEiLGZhKTtteFV0aWxzLmV4dGVuZChwYSxteEVsbGlwc2UpO3BhLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7bXhFbGxpcHNlLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlLmFwcGx5KHRoaXMsCmFyZ3VtZW50cyk7YS5zZXRTaGFkb3coITEpO2EuYmVnaW4oKTthLm1vdmVUbyhiLGUrZC8yKTthLmxpbmVUbyhiK2MsZStkLzIpO2EuZW5kKCk7YS5zdHJva2UoKTthLmJlZ2luKCk7YS5tb3ZlVG8oYitjLzIsZSk7YS5saW5lVG8oYitjLzIsZStkKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoIm9yRWxsaXBzZSIscGEpO214VXRpbHMuZXh0ZW5kKHJhLG14RWxsaXBzZSk7cmEucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXtteEVsbGlwc2UucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Euc2V0U2hhZG93KCExKTthLmJlZ2luKCk7YS5tb3ZlVG8oYisuMTQ1KmMsZSsuMTQ1KmQpO2EubGluZVRvKGIrLjg1NSpjLGUrLjg1NSpkKTthLmVuZCgpO2Euc3Ryb2tlKCk7YS5iZWdpbigpO2EubW92ZVRvKGIrLjg1NSpjLGUrLjE0NSpkKTthLmxpbmVUbyhiKy4xNDUqYywKZSsuODU1KmQpO2EuZW5kKCk7YS5zdHJva2UoKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgic3VtRWxsaXBzZSIscmEpO214VXRpbHMuZXh0ZW5kKGxhLG14UmhvbWJ1cyk7bGEucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXtteFJob21idXMucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Euc2V0U2hhZG93KCExKTthLmJlZ2luKCk7YS5tb3ZlVG8oYixlK2QvMik7YS5saW5lVG8oYitjLGUrZC8yKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoInNvcnRTaGFwZSIsbGEpO214VXRpbHMuZXh0ZW5kKHFhLG14RWxsaXBzZSk7cWEucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXthLmJlZ2luKCk7YS5tb3ZlVG8oYixlKTthLmxpbmVUbyhiK2MsZSk7YS5saW5lVG8oYitjLzIsZStkLzIpO2EuY2xvc2UoKTthLmZpbGxBbmRTdHJva2UoKTsKYS5iZWdpbigpO2EubW92ZVRvKGIsZStkKTthLmxpbmVUbyhiK2MsZStkKTthLmxpbmVUbyhiK2MvMixlK2QvMik7YS5jbG9zZSgpO2EuZmlsbEFuZFN0cm9rZSgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJjb2xsYXRlIixxYSk7bXhVdGlscy5leHRlbmQobmEsbXhFbGxpcHNlKTtuYS5wcm90b3R5cGUucGFpbnRWZXJ0ZXhTaGFwZT1mdW5jdGlvbihhLGIsZSxjLGQpe3ZhciBmPWUrZC01O2EuYmVnaW4oKTthLm1vdmVUbyhiLGUpO2EubGluZVRvKGIsZStkKTthLm1vdmVUbyhiLGYpO2EubGluZVRvKGIrMTAsZi01KTthLm1vdmVUbyhiLGYpO2EubGluZVRvKGIrMTAsZis1KTthLm1vdmVUbyhiLGYpO2EubGluZVRvKGIrYyxmKTthLm1vdmVUbyhiK2MsZSk7YS5saW5lVG8oYitjLGUrZCk7YS5tb3ZlVG8oYitjLGYpO2EubGluZVRvKGIrYy0xMCxmLTUpO2EubW92ZVRvKGIrYyxmKTthLmxpbmVUbyhiK2MtMTAsZis1KTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImRpbWVuc2lvbiIsCm5hKTtteFV0aWxzLmV4dGVuZChBYSxteEVsbGlwc2UpO0FhLnByb3RvdHlwZS5wYWludFZlcnRleFNoYXBlPWZ1bmN0aW9uKGEsYixlLGMsZCl7dGhpcy5vdXRsaW5lfHxhLnNldFN0cm9rZUNvbG9yKG51bGwpO214UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLnBhaW50QmFja2dyb3VuZC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5zdHlsZSYmKGEuc2V0U3Ryb2tlQ29sb3IodGhpcy5zdHJva2UpLGEucmVjdChiLGUsYyxkKSxhLmZpbGwoKSxhLmJlZ2luKCksYS5tb3ZlVG8oYixlKSwiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwidG9wIiwiMSIpP2EubGluZVRvKGIrYyxlKTphLm1vdmVUbyhiK2MsZSksIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInJpZ2h0IiwiMSIpP2EubGluZVRvKGIrYyxlK2QpOmEubW92ZVRvKGIrYyxlK2QpLCIxIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJib3R0b20iLCIxIik/YS5saW5lVG8oYixlKwpkKTphLm1vdmVUbyhiLGUrZCksIjEiPT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImxlZnQiLCIxIikmJmEubGluZVRvKGIsZSksYS5lbmQoKSxhLnN0cm9rZSgpKX07bXhDZWxsUmVuZGVyZXIucmVnaXN0ZXJTaGFwZSgicGFydGlhbFJlY3RhbmdsZSIsQWEpO214VXRpbHMuZXh0ZW5kKHlhLG14RWxsaXBzZSk7eWEucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGU9ZnVuY3Rpb24oYSxiLGUsYyxkKXtteEVsbGlwc2UucHJvdG90eXBlLnBhaW50VmVydGV4U2hhcGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Euc2V0U2hhZG93KCExKTthLmJlZ2luKCk7InZlcnRpY2FsIj09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJsaW5lIik/KGEubW92ZVRvKGIrYy8yLGUpLGEubGluZVRvKGIrYy8yLGUrZCkpOihhLm1vdmVUbyhiLGUrZC8yKSxhLmxpbmVUbyhiK2MsZStkLzIpKTthLmVuZCgpO2Euc3Ryb2tlKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImxpbmVFbGxpcHNlIiwKeWEpO214VXRpbHMuZXh0ZW5kKG9hLG14QWN0b3IpO29hLnByb3RvdHlwZS5yZWRyYXdQYXRoPWZ1bmN0aW9uKGEsYixlLGMsZCl7Yj1NYXRoLm1pbihjLGQvMik7YS5tb3ZlVG8oMCwwKTthLmxpbmVUbyhjLWIsMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsYy1iLGQpO2EubGluZVRvKDAsZCk7YS5jbG9zZSgpO2EuZW5kKCl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImRlbGF5IixvYSk7bXhVdGlscy5leHRlbmQoc2EsbXhBY3Rvcik7c2EucHJvdG90eXBlLnNpemU9LjI7c2EucHJvdG90eXBlLnJlZHJhd1BhdGg9ZnVuY3Rpb24oYSxiLGUsYyxkKXtiPU1hdGgubWluKGQsYyk7dmFyIGY9TWF0aC5tYXgoMCxNYXRoLm1pbihiLGIqcGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSk7Yj0oZC1mKS8yO2U9YitmO3ZhciBnPShjLWYpLzIsZj1nK2Y7YS5tb3ZlVG8oMCxiKTthLmxpbmVUbyhnLGIpO2EubGluZVRvKGcsCjApO2EubGluZVRvKGYsMCk7YS5saW5lVG8oZixiKTthLmxpbmVUbyhjLGIpO2EubGluZVRvKGMsZSk7YS5saW5lVG8oZixlKTthLmxpbmVUbyhmLGQpO2EubGluZVRvKGcsZCk7YS5saW5lVG8oZyxlKTthLmxpbmVUbygwLGUpO2EuY2xvc2UoKTthLmVuZCgpfTtteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJjcm9zcyIsc2EpO214VXRpbHMuZXh0ZW5kKHVhLG14QWN0b3IpO3VhLnByb3RvdHlwZS5zaXplPS4yNTt1YS5wcm90b3R5cGUucmVkcmF3UGF0aD1mdW5jdGlvbihhLGIsZSxjLGQpe2I9TWF0aC5taW4oYyxkLzIpO2U9TWF0aC5taW4oYy1iLE1hdGgubWF4KDAscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSpjKTthLm1vdmVUbygwLGQvMik7YS5saW5lVG8oZSwwKTthLmxpbmVUbyhjLWIsMCk7YS5xdWFkVG8oYywwLGMsZC8yKTthLnF1YWRUbyhjLGQsYy1iLGQpO2EubGluZVRvKGUsZCk7YS5jbG9zZSgpO2EuZW5kKCl9OwpteENlbGxSZW5kZXJlci5yZWdpc3RlclNoYXBlKCJkaXNwbGF5Iix1YSk7bXhVdGlscy5leHRlbmQoamEsbXhDb25uZWN0b3IpO2phLnByb3RvdHlwZS5vcmlnUGFpbnRFZGdlU2hhcGU9amEucHJvdG90eXBlLnBhaW50RWRnZVNoYXBlO2phLnByb3RvdHlwZS5wYWludEVkZ2VTaGFwZT1mdW5jdGlvbihhLGIsZSl7Zm9yKHZhciBjPVtdLGQ9MDtkPGIubGVuZ3RoO2QrKyljLnB1c2gobXhVdGlscy5jbG9uZShiW2RdKSk7dmFyIGQ9YS5zdGF0ZS5kYXNoZWQsZj1hLnN0YXRlLmZpeERhc2g7amEucHJvdG90eXBlLm9yaWdQYWludEVkZ2VTaGFwZS5hcHBseSh0aGlzLFthLGMsZV0pOzM8PWEuc3RhdGUuc3Ryb2tlV2lkdGgmJihjPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZmlsbENvbG9yIixudWxsKSxudWxsIT1jJiYoYS5zZXRTdHJva2VDb2xvcihjKSxhLnNldFN0cm9rZVdpZHRoKGEuc3RhdGUuc3Ryb2tlV2lkdGgtMiksYS5zZXREYXNoZWQoZCxmKSxqYS5wcm90b3R5cGUub3JpZ1BhaW50RWRnZVNoYXBlLmFwcGx5KHRoaXMsClthLGIsZV0pKSl9O214Q2VsbFJlbmRlcmVyLnJlZ2lzdGVyU2hhcGUoImZpbGxlZEVkZ2UiLGphKTsidW5kZWZpbmVkIiE9PXR5cGVvZiBTdHlsZUZvcm1hdFBhbmVsJiZmdW5jdGlvbigpe3ZhciBhPVN0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmdldEN1c3RvbUNvbG9ycztTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5nZXRDdXN0b21Db2xvcnM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmZvcm1hdC5nZXRTZWxlY3Rpb25TdGF0ZSgpLGU9YS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7InVtbEZyYW1lIj09Yi5zdHlsZS5zaGFwZSYmZS5wdXNoKHt0aXRsZTpteFJlc291cmNlcy5nZXQoImxhbmVDb2xvciIpLGtleToic3dpbWxhbmVGaWxsQ29sb3IiLGRlZmF1bHRWYWx1ZToiI2ZmZmZmZiJ9KTtyZXR1cm4gZX19KCk7bXhNYXJrZXIuYWRkTWFya2VyKCJkYXNoIixmdW5jdGlvbihhLGIsZSxjLGQsZixnLGwsbix1KXt2YXIgcD1kKihnK24rMSksdD1mKihnK24rMSk7cmV0dXJuIGZ1bmN0aW9uKCl7YS5iZWdpbigpOwphLm1vdmVUbyhjLngtcC8yLXQvMixjLnktdC8yK3AvMik7YS5saW5lVG8oYy54K3QvMi0zKnAvMixjLnktMyp0LzItcC8yKTthLnN0cm9rZSgpfX0pO214TWFya2VyLmFkZE1hcmtlcigiYm94IixmdW5jdGlvbihhLGIsZSxjLGQsZixnLGwsbix1KXt2YXIgcD1kKihnK24rMSksdD1mKihnK24rMSksQT1jLngrcC8yLGs9Yy55K3QvMjtjLngtPXA7Yy55LT10O3JldHVybiBmdW5jdGlvbigpe2EuYmVnaW4oKTthLm1vdmVUbyhBLXAvMi10LzIsay10LzIrcC8yKTthLmxpbmVUbyhBLXAvMit0LzIsay10LzItcC8yKTthLmxpbmVUbyhBK3QvMi0zKnAvMixrLTMqdC8yLXAvMik7YS5saW5lVG8oQS10LzItMypwLzIsay0zKnQvMitwLzIpO2EuY2xvc2UoKTt1P2EuZmlsbEFuZFN0cm9rZSgpOmEuc3Ryb2tlKCl9fSk7bXhNYXJrZXIuYWRkTWFya2VyKCJjcm9zcyIsZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLG4sdSl7dmFyIHA9ZCooZytuKzEpLHQ9ZiooZytuKzEpO3JldHVybiBmdW5jdGlvbigpe2EuYmVnaW4oKTsKYS5tb3ZlVG8oYy54LXAvMi10LzIsYy55LXQvMitwLzIpO2EubGluZVRvKGMueCt0LzItMypwLzIsYy55LTMqdC8yLXAvMik7YS5tb3ZlVG8oYy54LXAvMit0LzIsYy55LXQvMi1wLzIpO2EubGluZVRvKGMueC10LzItMypwLzIsYy55LTMqdC8yK3AvMik7YS5zdHJva2UoKX19KTtteE1hcmtlci5hZGRNYXJrZXIoImNpcmNsZSIsRGEpO214TWFya2VyLmFkZE1hcmtlcigiY2lyY2xlUGx1cyIsZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLG4sdSl7dmFyIHA9Yy5jbG9uZSgpLHQ9RGEuYXBwbHkodGhpcyxhcmd1bWVudHMpLEE9ZCooZysyKm4pLGs9ZiooZysyKm4pO3JldHVybiBmdW5jdGlvbigpe3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EuYmVnaW4oKTthLm1vdmVUbyhwLngtZCpuLHAueS1mKm4pO2EubGluZVRvKHAueC0yKkErZCpuLHAueS0yKmsrZipuKTthLm1vdmVUbyhwLngtQS1rK2YqbixwLnktaytBLWQqbik7YS5saW5lVG8ocC54K2stQS1mKm4scC55LWstQStkKm4pO2Euc3Ryb2tlKCl9fSk7Cm14TWFya2VyLmFkZE1hcmtlcigiaGFsZkNpcmNsZSIsZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLG4sdSl7dmFyIHA9ZCooZytuKzEpLHQ9ZiooZytuKzEpLEE9Yy5jbG9uZSgpO2MueC09cDtjLnktPXQ7cmV0dXJuIGZ1bmN0aW9uKCl7YS5iZWdpbigpO2EubW92ZVRvKEEueC10LEEueStwKTthLnF1YWRUbyhjLngtdCxjLnkrcCxjLngsYy55KTthLnF1YWRUbyhjLngrdCxjLnktcCxBLngrdCxBLnktcCk7YS5zdHJva2UoKX19KTtteE1hcmtlci5hZGRNYXJrZXIoImFzeW5jIixmdW5jdGlvbihhLGIsZSxjLGQsZixnLGwsbix1KXtiPWQqbioxLjExODtlPWYqbioxLjExODtkKj1nK247Zio9ZytuO3ZhciBwPWMuY2xvbmUoKTtwLngtPWI7cC55LT1lO2MueCs9MSotZC1iO2MueSs9MSotZi1lO3JldHVybiBmdW5jdGlvbigpe2EuYmVnaW4oKTthLm1vdmVUbyhwLngscC55KTtsP2EubGluZVRvKHAueC1kLWYvMixwLnktZitkLzIpOmEubGluZVRvKHAueCtmLzItZCxwLnktZi1kLzIpOwphLmxpbmVUbyhwLngtZCxwLnktZik7YS5jbG9zZSgpO3U/YS5maWxsQW5kU3Ryb2tlKCk6YS5zdHJva2UoKX19KTtteE1hcmtlci5hZGRNYXJrZXIoIm9wZW5Bc3luYyIsZnVuY3Rpb24oYSl7YT1udWxsIT1hP2E6MjtyZXR1cm4gZnVuY3Rpb24oYixlLGMsZCxmLGcsbCxuLHUscCl7Zio9bCt1O2cqPWwrdTt2YXIgdD1kLmNsb25lKCk7cmV0dXJuIGZ1bmN0aW9uKCl7Yi5iZWdpbigpO2IubW92ZVRvKHQueCx0LnkpO24/Yi5saW5lVG8odC54LWYtZy9hLHQueS1nK2YvYSk6Yi5saW5lVG8odC54K2cvYS1mLHQueS1nLWYvYSk7Yi5zdHJva2UoKX19fSgyKSk7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgbXhWZXJ0ZXhIYW5kbGVyKXt2YXIgT2E9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiBDYShhLFsid2lkdGgiXSxiLGZ1bmN0aW9uKGIsYyxkLGYsZyl7Zz1hLnNoYXBlLmdldEVkZ2VXaWR0aCgpKmEudmlldy5zY2FsZStlO3JldHVybiBuZXcgbXhQb2ludChmLngrYypiLzQrZCpnLzIsZi55KwpkKmIvNC1jKmcvMil9LGZ1bmN0aW9uKGIsYyxkLGYsZyxsKXtiPU1hdGguc3FydChteFV0aWxzLnB0U2VnRGlzdFNxKGYueCxmLnksZy54LGcueSxsLngsbC55KSk7YS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKDIqYikvYS52aWV3LnNjYWxlLWV9KX0sQ2E9ZnVuY3Rpb24oYSxiLGUsYyxkKXtyZXR1cm4gVihhLGIsZnVuY3Rpb24oYil7dmFyIGQ9YS5hYnNvbHV0ZVBvaW50cyxmPWQubGVuZ3RoLTE7Yj1hLnZpZXcudHJhbnNsYXRlO3ZhciBnPWEudmlldy5zY2FsZSxsPWU/ZFswXTpkW2ZdLGQ9ZT9kWzFdOmRbZi0xXSxmPWQueC1sLngsbj1kLnktbC55LHU9TWF0aC5zcXJ0KGYqZituKm4pLGw9Yy5jYWxsKHRoaXMsdSxmL3Usbi91LGwsZCk7cmV0dXJuIG5ldyBteFBvaW50KGwueC9nLWIueCxsLnkvZy1iLnkpfSxmdW5jdGlvbihiLGMsZil7dmFyIGc9YS5hYnNvbHV0ZVBvaW50cyxsPWcubGVuZ3RoLTE7Yj1hLnZpZXcudHJhbnNsYXRlO3ZhciBuPWEudmlldy5zY2FsZSx1PWU/Z1swXToKZ1tsXSxnPWU/Z1sxXTpnW2wtMV0sbD1nLngtdS54LHA9Zy55LXUueSx0PU1hdGguc3FydChsKmwrcCpwKTtjLng9KGMueCtiLngpKm47Yy55PShjLnkrYi55KSpuO2QuY2FsbCh0aGlzLHQsbC90LHAvdCx1LGcsYyxmKX0pfSx3YT1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuW1YoYixbImFycm93V2lkdGgiLCJhcnJvd1NpemUiXSxmdW5jdGlvbihiKXt2YXIgZT1NYXRoLm1heCgwLE1hdGgubWluKDEsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJhcnJvd1dpZHRoIixPLnByb3RvdHlwZS5hcnJvd1dpZHRoKSkpLGM9TWF0aC5tYXgoMCxNYXRoLm1pbihhLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiYXJyb3dTaXplIixPLnByb3RvdHlwZS5hcnJvd1NpemUpKSk7cmV0dXJuIG5ldyBteFBvaW50KGIueCsoMS1jKSpiLndpZHRoLGIueSsoMS1lKSpiLmhlaWdodC8yKX0sZnVuY3Rpb24oYixlKXt0aGlzLnN0YXRlLnN0eWxlLmFycm93V2lkdGg9Ck1hdGgubWF4KDAsTWF0aC5taW4oMSxNYXRoLmFicyhiLnkrYi5oZWlnaHQvMi1lLnkpL2IuaGVpZ2h0KjIpKTt0aGlzLnN0YXRlLnN0eWxlLmFycm93U2l6ZT1NYXRoLm1heCgwLE1hdGgubWluKGEsKGIueCtiLndpZHRoLWUueCkvYi53aWR0aCkpfSldfX0sS2E9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiBmdW5jdGlvbihjKXt2YXIgZD1bVihjLFsic2l6ZSJdLGZ1bmN0aW9uKGUpe3ZhciBjPU1hdGgubWF4KDAsTWF0aC5taW4oZS53aWR0aCxNYXRoLm1pbihlLmhlaWdodCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsYikpKSkpKmE7cmV0dXJuIG5ldyBteFBvaW50KGUueCtjLGUueStjKX0sZnVuY3Rpb24oYixlKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKE1hdGgubWluKGIud2lkdGgsZS54LWIueCksTWF0aC5taW4oYi5oZWlnaHQsZS55LWIueSkpKS9hKX0sITEpXTtlJiZteFV0aWxzLmdldFZhbHVlKGMuc3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZkLnB1c2godGEoYykpO3JldHVybiBkfX0sRWE9ZnVuY3Rpb24oYSxiLGUsYyxkKXtlPW51bGwhPWU/ZToxO3JldHVybiBmdW5jdGlvbihmKXt2YXIgZz1bVihmLFsic2l6ZSJdLGZ1bmN0aW9uKGIpe3ZhciBlPW51bGwhPWQ/IjAiIT1teFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImZpeGVkU2l6ZSIsIjAiKTpudWxsLGM9cGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLGU/ZDphKSk7cmV0dXJuIG5ldyBteFBvaW50KGIueCtNYXRoLm1heCgwLE1hdGgubWluKGIud2lkdGgsYyooZT8xOmIud2lkdGgpKSksYi5nZXRDZW50ZXJZKCkpfSxmdW5jdGlvbihhLGIsYyl7YT1udWxsIT1kJiYiMCIhPW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiZml4ZWRTaXplIiwiMCIpP2IueC1hLng6TWF0aC5tYXgoMCxNYXRoLm1pbihlLChiLngtYS54KS9hLndpZHRoKSk7dGhpcy5zdGF0ZS5zdHlsZS5zaXplPQphfSwhMSxjKV07YiYmbXhVdGlscy5nZXRWYWx1ZShmLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZnLnB1c2godGEoZikpO3JldHVybiBnfX0sTGE9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBlPVtWKGIsWyJzaXplIl0sZnVuY3Rpb24oYil7dmFyIGU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixsLnByb3RvdHlwZS5zaXplKSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYi54K2UqYi53aWR0aCouNzUsYi55K2IuaGVpZ2h0LzQpfSxmdW5jdGlvbihiLGUpe3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT1NYXRoLm1heCgwLE1hdGgubWluKGEsKGUueC1iLngpLyguNzUqYi53aWR0aCkpKX0sITEsITApXTtteFV0aWxzLmdldFZhbHVlKGIuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwhMSkmJmUucHVzaCh0YShiKSk7cmV0dXJuIGV9fSxCYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihhKXt2YXIgYj0KW107bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZiLnB1c2godGEoYSkpO3JldHVybiBifX0sdGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVihhLFtteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFXSxmdW5jdGlvbihlKXt2YXIgYz1udWxsIT1iP2I6ZS5oZWlnaHQvODtpZigiMSI9PW14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BQlNPTFVURV9BUkNTSVpFLDApKXt2YXIgZD1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRSxteENvbnN0YW50cy5MSU5FX0FSQ1NJWkUpLzI7cmV0dXJuIG5ldyBteFBvaW50KGUueCtlLndpZHRoLU1hdGgubWluKGUud2lkdGgvMixkKSxlLnkrYyl9ZD1NYXRoLm1heCgwLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FSQ1NJWkUsMTAwKm14Q29uc3RhbnRzLlJFQ1RBTkdMRV9ST1VORElOR19GQUNUT1IpKSkvCjEwMDtyZXR1cm4gbmV3IG14UG9pbnQoZS54K2Uud2lkdGgtTWF0aC5taW4oTWF0aC5tYXgoZS53aWR0aC8yLGUuaGVpZ2h0LzIpLE1hdGgubWluKGUud2lkdGgsZS5oZWlnaHQpKmQpLGUueStjKX0sZnVuY3Rpb24oYixlLGMpeyIxIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0FCU09MVVRFX0FSQ1NJWkUsMCk/dGhpcy5zdGF0ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFXT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYi53aWR0aCwyKihiLngrYi53aWR0aC1lLngpKSkpOnRoaXMuc3RhdGUuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfQVJDU0laRV09TWF0aC5yb3VuZChNYXRoLm1pbig1MCxNYXRoLm1heCgwLDEwMCooYi53aWR0aC1lLngrYi54KS9NYXRoLm1pbihiLndpZHRoLGIuaGVpZ2h0KSkpKX0pfSxWPWZ1bmN0aW9uKGEsYixlLGMsZCxmLGcpe3ZhciBsPW5ldyBteEhhbmRsZShhLG51bGwsbXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5zZWNvbmRhcnlIYW5kbGVJbWFnZSk7CmwuZXhlY3V0ZT1mdW5jdGlvbihhKXtmb3IodmFyIGU9MDtlPGIubGVuZ3RoO2UrKyl0aGlzLmNvcHlTdHlsZShiW2VdKTtnJiZnKGEpfTtsLmdldFBvc2l0aW9uPWU7bC5zZXRQb3NpdGlvbj1jO2wuaWdub3JlR3JpZD1udWxsIT1kP2Q6ITA7aWYoZil7dmFyIG49bC5wb3NpdGlvbkNoYW5nZWQ7bC5wb3NpdGlvbkNoYW5nZWQ9ZnVuY3Rpb24oKXtuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLnZpZXcuaW52YWxpZGF0ZSh0aGlzLnN0YXRlLmNlbGwpO2Eudmlldy52YWxpZGF0ZSgpfX1yZXR1cm4gbH0sRmE9e2xpbms6ZnVuY3Rpb24oYSl7cmV0dXJuW09hKGEsITAsMTApLE9hKGEsITEsMTApXX0sZmxleEFycm93OmZ1bmN0aW9uKGEpe3ZhciBiPWEudmlldy5ncmFwaC5ncmlkU2l6ZS9hLnZpZXcuc2NhbGUsZT1bXTtteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RBUlRBUlJPVyxteENvbnN0YW50cy5OT05FKSE9bXhDb25zdGFudHMuTk9ORSYmKGUucHVzaChDYShhLApbIndpZHRoIixteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0sITAsZnVuY3Rpb24oYixlLGMsZCxmKXtiPShhLnNoYXBlLmdldEVkZ2VXaWR0aCgpLWEuc2hhcGUuc3Ryb2tld2lkdGgpKmEudmlldy5zY2FsZTtmPTMqbXhVdGlscy5nZXROdW1iZXIoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuQVJST1dfU0laRS81KSphLnZpZXcuc2NhbGU7cmV0dXJuIG5ldyBteFBvaW50KGQueCtlKihmK2Euc2hhcGUuc3Ryb2tld2lkdGgqYS52aWV3LnNjYWxlKStjKmIvMixkLnkrYyooZithLnNoYXBlLnN0cm9rZXdpZHRoKmEudmlldy5zY2FsZSktZSpiLzIpfSxmdW5jdGlvbihlLGMsZCxmLGcsbCxuKXtlPU1hdGguc3FydChteFV0aWxzLnB0U2VnRGlzdFNxKGYueCxmLnksZy54LGcueSxsLngsbC55KSk7Yz1teFV0aWxzLnB0TGluZURpc3QoZi54LGYueSxmLngrZCxmLnktYyxsLngsbC55KTthLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV09Ck1hdGgucm91bmQoMTAwKihjLWEuc2hhcGUuc3Ryb2tld2lkdGgpLzMpLzEwMC9hLnZpZXcuc2NhbGU7YS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKDIqZSkvYS52aWV3LnNjYWxlO214RXZlbnQuaXNDb250cm9sRG93bihuLmdldEV2ZW50KCkpJiYoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV0pO214RXZlbnQuaXNBbHREb3duKG4uZ2V0RXZlbnQoKSl8fE1hdGguYWJzKHBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdKS1wYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0pKTxiLzYmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSl9KSksZS5wdXNoKENhKGEsWyJzdGFydFdpZHRoIiwiZW5kV2lkdGgiLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSwKITAsZnVuY3Rpb24oYixlLGMsZCxmKXtiPShhLnNoYXBlLmdldFN0YXJ0QXJyb3dXaWR0aCgpLWEuc2hhcGUuc3Ryb2tld2lkdGgpKmEudmlldy5zY2FsZTtmPTMqbXhVdGlscy5nZXROdW1iZXIoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuQVJST1dfU0laRS81KSphLnZpZXcuc2NhbGU7cmV0dXJuIG5ldyBteFBvaW50KGQueCtlKihmK2Euc2hhcGUuc3Ryb2tld2lkdGgqYS52aWV3LnNjYWxlKStjKmIvMixkLnkrYyooZithLnNoYXBlLnN0cm9rZXdpZHRoKmEudmlldy5zY2FsZSktZSpiLzIpfSxmdW5jdGlvbihlLGMsZCxmLGcsbCxuKXtlPU1hdGguc3FydChteFV0aWxzLnB0U2VnRGlzdFNxKGYueCxmLnksZy54LGcueSxsLngsbC55KSk7Yz1teFV0aWxzLnB0TGluZURpc3QoZi54LGYueSxmLngrZCxmLnktYyxsLngsbC55KTthLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV09TWF0aC5yb3VuZCgxMDAqKGMtYS5zaGFwZS5zdHJva2V3aWR0aCkvCjMpLzEwMC9hLnZpZXcuc2NhbGU7YS5zdHlsZS5zdGFydFdpZHRoPU1hdGgubWF4KDAsTWF0aC5yb3VuZCgyKmUpLWEuc2hhcGUuZ2V0RWRnZVdpZHRoKCkpL2Eudmlldy5zY2FsZTtteEV2ZW50LmlzQ29udHJvbERvd24obi5nZXRFdmVudCgpKSYmKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdLGEuc3R5bGUuZW5kV2lkdGg9YS5zdHlsZS5zdGFydFdpZHRoKTtteEV2ZW50LmlzQWx0RG93bihuLmdldEV2ZW50KCkpfHwoTWF0aC5hYnMocGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV0pLXBhcnNlRmxvYXQoYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSkpPGIvNiYmKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdKSxNYXRoLmFicyhwYXJzZUZsb2F0KGEuc3R5bGUuc3RhcnRXaWR0aCktCnBhcnNlRmxvYXQoYS5zdHlsZS5lbmRXaWR0aCkpPGImJihhLnN0eWxlLnN0YXJ0V2lkdGg9YS5zdHlsZS5lbmRXaWR0aCkpfSkpKTtteFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRU5EQVJST1csbXhDb25zdGFudHMuTk9ORSkhPW14Q29uc3RhbnRzLk5PTkUmJihlLnB1c2goQ2EoYSxbIndpZHRoIixteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV0sITEsZnVuY3Rpb24oYixlLGMsZCxmKXtiPShhLnNoYXBlLmdldEVkZ2VXaWR0aCgpLWEuc2hhcGUuc3Ryb2tld2lkdGgpKmEudmlldy5zY2FsZTtmPTMqbXhVdGlscy5nZXROdW1iZXIoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFLG14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNSkqYS52aWV3LnNjYWxlO3JldHVybiBuZXcgbXhQb2ludChkLngrZSooZithLnNoYXBlLnN0cm9rZXdpZHRoKmEudmlldy5zY2FsZSktYypiLzIsZC55K2MqKGYrYS5zaGFwZS5zdHJva2V3aWR0aCoKYS52aWV3LnNjYWxlKStlKmIvMil9LGZ1bmN0aW9uKGUsYyxkLGYsZyxsLG4pe2U9TWF0aC5zcXJ0KG14VXRpbHMucHRTZWdEaXN0U3EoZi54LGYueSxnLngsZy55LGwueCxsLnkpKTtjPW14VXRpbHMucHRMaW5lRGlzdChmLngsZi55LGYueCtkLGYueS1jLGwueCxsLnkpO2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV09TWF0aC5yb3VuZCgxMDAqKGMtYS5zaGFwZS5zdHJva2V3aWR0aCkvMykvMTAwL2Eudmlldy5zY2FsZTthLnN0eWxlLndpZHRoPU1hdGgucm91bmQoMiplKS9hLnZpZXcuc2NhbGU7bXhFdmVudC5pc0NvbnRyb2xEb3duKG4uZ2V0RXZlbnQoKSkmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSk7bXhFdmVudC5pc0FsdERvd24obi5nZXRFdmVudCgpKXx8TWF0aC5hYnMocGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdKS1wYXJzZUZsb2F0KGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSkpPApiLzYmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSl9KSksZS5wdXNoKENhKGEsWyJzdGFydFdpZHRoIiwiZW5kV2lkdGgiLG14Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRSxteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFXSwhMSxmdW5jdGlvbihiLGUsYyxkLGYpe2I9KGEuc2hhcGUuZ2V0RW5kQXJyb3dXaWR0aCgpLWEuc2hhcGUuc3Ryb2tld2lkdGgpKmEudmlldy5zY2FsZTtmPTMqbXhVdGlscy5nZXROdW1iZXIoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9FTkRTSVpFLG14Q29uc3RhbnRzLkFSUk9XX1NJWkUvNSkqYS52aWV3LnNjYWxlO3JldHVybiBuZXcgbXhQb2ludChkLngrZSooZithLnNoYXBlLnN0cm9rZXdpZHRoKmEudmlldy5zY2FsZSktYypiLzIsZC55K2MqKGYrYS5zaGFwZS5zdHJva2V3aWR0aCphLnZpZXcuc2NhbGUpK2UqYi8yKX0sZnVuY3Rpb24oZSxjLGQsZixnLGwsbil7ZT0KTWF0aC5zcXJ0KG14VXRpbHMucHRTZWdEaXN0U3EoZi54LGYueSxnLngsZy55LGwueCxsLnkpKTtjPW14VXRpbHMucHRMaW5lRGlzdChmLngsZi55LGYueCtkLGYueS1jLGwueCxsLnkpO2Euc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfRU5EU0laRV09TWF0aC5yb3VuZCgxMDAqKGMtYS5zaGFwZS5zdHJva2V3aWR0aCkvMykvMTAwL2Eudmlldy5zY2FsZTthLnN0eWxlLmVuZFdpZHRoPU1hdGgubWF4KDAsTWF0aC5yb3VuZCgyKmUpLWEuc2hhcGUuZ2V0RWRnZVdpZHRoKCkpL2Eudmlldy5zY2FsZTtteEV2ZW50LmlzQ29udHJvbERvd24obi5nZXRFdmVudCgpKSYmKGEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXT1hLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdLGEuc3R5bGUuc3RhcnRXaWR0aD1hLnN0eWxlLmVuZFdpZHRoKTtteEV2ZW50LmlzQWx0RG93bihuLmdldEV2ZW50KCkpfHwoTWF0aC5hYnMocGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdKS0KcGFyc2VGbG9hdChhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX1NUQVJUU0laRV0pKTxiLzYmJihhLnN0eWxlW214Q29uc3RhbnRzLlNUWUxFX0VORFNJWkVdPWEuc3R5bGVbbXhDb25zdGFudHMuU1RZTEVfU1RBUlRTSVpFXSksTWF0aC5hYnMocGFyc2VGbG9hdChhLnN0eWxlLmVuZFdpZHRoKS1wYXJzZUZsb2F0KGEuc3R5bGUuc3RhcnRXaWR0aCkpPGImJihhLnN0eWxlLmVuZFdpZHRoPWEuc3R5bGUuc3RhcnRXaWR0aCkpfSkpKTtyZXR1cm4gZX0sc3dpbWxhbmU6ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYobXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQpKXt2YXIgZT1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9TVEFSVFNJWkUpKTtiLnB1c2godGEoYSxlLzIpKX1iLnB1c2goVihhLFtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdLApmdW5jdGlvbihiKXt2YXIgZT1wYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsbXhDb25zdGFudHMuREVGQVVMVF9TVEFSVFNJWkUpKTtyZXR1cm4gMT09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsMSk/bmV3IG14UG9pbnQoYi5nZXRDZW50ZXJYKCksYi55K01hdGgubWF4KDAsTWF0aC5taW4oYi5oZWlnaHQsZSkpKTpuZXcgbXhQb2ludChiLngrTWF0aC5tYXgoMCxNYXRoLm1pbihiLndpZHRoLGUpKSxiLmdldENlbnRlclkoKSl9LGZ1bmN0aW9uKGIsZSl7YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdPTE9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9IT1JJWk9OVEFMLDEpP01hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihiLmhlaWdodCxlLnktYi55KSkpOk1hdGgucm91bmQoTWF0aC5tYXgoMCwKTWF0aC5taW4oYi53aWR0aCxlLngtYi54KSkpfSwhMSxudWxsLGZ1bmN0aW9uKGIpe2lmKG14RXZlbnQuaXNTaGlmdERvd24oYi5nZXRFdmVudCgpKSYmKGI9YS52aWV3LmdyYXBoLGIuaXNUYWJsZVJvdyhhLmNlbGwpfHxiLmlzVGFibGVDZWxsKGEuY2VsbCkpKXtmb3IodmFyIGU9Yi5nZXRTd2ltbGFuZURpcmVjdGlvbihhLnN0eWxlKSxjPWIubW9kZWwuZ2V0UGFyZW50KGEuY2VsbCksYz1iLm1vZGVsLmdldENoaWxkQ2VsbHMoYywhMCksZD1bXSxmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXSE9YS5jZWxsJiZiLmlzU3dpbWxhbmUoY1tmXSkmJmIuZ2V0U3dpbWxhbmVEaXJlY3Rpb24oYi5nZXRDdXJyZW50Q2VsbFN0eWxlKGNbZl0pKT09ZSYmZC5wdXNoKGNbZl0pO2Iuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkUsYS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVFNJWkVdLGQpfX0pKTtyZXR1cm4gYn0sbGFiZWw6QmEoKSxleHQ6QmEoKSxyZWN0YW5nbGU6QmEoKSwKdHJpYW5nbGU6QmEoKSxyaG9tYnVzOkJhKCksdW1sTGlmZWxpbmU6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixBLnByb3RvdHlwZS5zaXplKSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS5nZXRDZW50ZXJYKCksYS55K2IpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsYi55LWEueSkpKX0sITEpXX0sdW1sRnJhbWU6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbIndpZHRoIiwiaGVpZ2h0Il0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoTS5wcm90b3R5cGUuY29ybmVyLE1hdGgubWluKGEud2lkdGgsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJ3aWR0aCIsTS5wcm90b3R5cGUud2lkdGgpKSksCmU9TWF0aC5tYXgoMS41Kk0ucHJvdG90eXBlLmNvcm5lcixNYXRoLm1pbihhLmhlaWdodCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImhlaWdodCIsTS5wcm90b3R5cGUuaGVpZ2h0KSkpO3JldHVybiBuZXcgbXhQb2ludChhLngrYixhLnkrZSl9LGZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zdHlsZS53aWR0aD1NYXRoLnJvdW5kKE1hdGgubWF4KE0ucHJvdG90eXBlLmNvcm5lcixNYXRoLm1pbihhLndpZHRoLGIueC1hLngpKSk7dGhpcy5zdGF0ZS5zdHlsZS5oZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCgxLjUqTS5wcm90b3R5cGUuY29ybmVyLE1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV19LHByb2Nlc3M6ZnVuY3Rpb24oYSl7dmFyIGI9W1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKC41LHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIix5LnByb3RvdHlwZS5zaXplKSkpKTsKcmV0dXJuIG5ldyBteFBvaW50KGEueCthLndpZHRoKmIsYS55K2EuaGVpZ2h0LzQpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT1NYXRoLm1heCgwLE1hdGgubWluKC41LChiLngtYS54KS9hLndpZHRoKSl9LCExKV07bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZiLnB1c2godGEoYSkpO3JldHVybiBifSxjcm9zczpmdW5jdGlvbihhKXtyZXR1cm5bVihhLFsic2l6ZSJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWluKGEud2lkdGgsYS5oZWlnaHQpLGI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsc2EucHJvdG90eXBlLnNpemUpKSkqYi8yO3JldHVybiBuZXcgbXhQb2ludChhLmdldENlbnRlclgoKS1iLGEuZ2V0Q2VudGVyWSgpLWIpfSxmdW5jdGlvbihhLGIpe3ZhciBlPU1hdGgubWluKGEud2lkdGgsYS5oZWlnaHQpO3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT0KTWF0aC5tYXgoMCxNYXRoLm1pbigxLE1hdGgubWluKE1hdGgubWF4KDAsYS5nZXRDZW50ZXJZKCktYi55KS9lKjIsTWF0aC5tYXgoMCxhLmdldENlbnRlclgoKS1iLngpL2UqMikpKX0pXX0sbm90ZTpmdW5jdGlvbihhKXtyZXR1cm5bVihhLFsic2l6ZSJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxNYXRoLm1pbihhLmhlaWdodCxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsay5wcm90b3R5cGUuc2l6ZSkpKSkpO3JldHVybiBuZXcgbXhQb2ludChhLngrYS53aWR0aC1iLGEueStiKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKE1hdGgubWluKGEud2lkdGgsYS54K2Eud2lkdGgtYi54KSxNYXRoLm1pbihhLmhlaWdodCxiLnktYS55KSkpKX0pXX0sbWFudWFsSW5wdXQ6ZnVuY3Rpb24oYSl7dmFyIGI9W1YoYSxbInNpemUiXSwKZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLFQucHJvdG90eXBlLnNpemUpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCthLndpZHRoLzQsYS55KzMqYi80KX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LDQqKGIueS1hLnkpLzMpKSl9LCExKV07bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZiLnB1c2godGEoYSkpO3JldHVybiBifSxkYXRhU3RvcmFnZTpmdW5jdGlvbihhKXtyZXR1cm5bVihhLFsic2l6ZSJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oMSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsZ2EucHJvdG90eXBlLnNpemUpKSkpO3JldHVybiBuZXcgbXhQb2ludChhLngrCigxLWIpKmEud2lkdGgsYS5nZXRDZW50ZXJZKCkpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuc2l6ZT1NYXRoLm1heCgwLE1hdGgubWluKDEsKGEueCthLndpZHRoLWIueCkvYS53aWR0aCkpfSwhMSldfSxjYWxsb3V0OmZ1bmN0aW9uKGEpe3ZhciBiPVtWKGEsWyJzaXplIiwicG9zaXRpb24iXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsQy5wcm90b3R5cGUuc2l6ZSkpKSxlPU1hdGgubWF4KDAsTWF0aC5taW4oMSxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInBvc2l0aW9uIixDLnByb3RvdHlwZS5wb3NpdGlvbikpKTtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImJhc2UiLEMucHJvdG90eXBlLmJhc2UpO3JldHVybiBuZXcgbXhQb2ludChhLngrZSphLndpZHRoLGEueSthLmhlaWdodC1iKX0sZnVuY3Rpb24oYSxiKXtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsCiJiYXNlIixDLnByb3RvdHlwZS5iYXNlKTt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGEueSthLmhlaWdodC1iLnkpKSk7dGhpcy5zdGF0ZS5zdHlsZS5wb3NpdGlvbj1NYXRoLnJvdW5kKDEwMCpNYXRoLm1heCgwLE1hdGgubWluKDEsKGIueC1hLngpL2Eud2lkdGgpKSkvMTAwfSwhMSksVihhLFsicG9zaXRpb24yIl0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwicG9zaXRpb24yIixDLnByb3RvdHlwZS5wb3NpdGlvbjIpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCtiKmEud2lkdGgsYS55K2EuaGVpZ2h0KX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnBvc2l0aW9uMj1NYXRoLnJvdW5kKDEwMCpNYXRoLm1heCgwLE1hdGgubWluKDEsKGIueC1hLngpL2Eud2lkdGgpKSkvMTAwfSwhMSksVihhLFsiYmFzZSJdLGZ1bmN0aW9uKGEpe3ZhciBiPQpNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwic2l6ZSIsQy5wcm90b3R5cGUuc2l6ZSkpKSxlPU1hdGgubWF4KDAsTWF0aC5taW4oMSxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInBvc2l0aW9uIixDLnByb3RvdHlwZS5wb3NpdGlvbikpKSxjPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImJhc2UiLEMucHJvdG90eXBlLmJhc2UpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCtNYXRoLm1pbihhLndpZHRoLGUqYS53aWR0aCtjKSxhLnkrYS5oZWlnaHQtYil9LGZ1bmN0aW9uKGEsYil7dmFyIGU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwicG9zaXRpb24iLEMucHJvdG90eXBlLnBvc2l0aW9uKSkpO3RoaXMuc3RhdGUuc3R5bGUuYmFzZT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCwKYi54LWEueC1lKmEud2lkdGgpKSl9LCExKV07bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsITEpJiZiLnB1c2godGEoYSkpO3JldHVybiBifSxpbnRlcm5hbFN0b3JhZ2U6ZnVuY3Rpb24oYSl7dmFyIGI9W1YoYSxbImR4IiwiZHkiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEud2lkdGgsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJkeCIsWS5wcm90b3R5cGUuZHgpKSksZT1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiZHkiLFkucHJvdG90eXBlLmR5KSkpO3JldHVybiBuZXcgbXhQb2ludChhLngrYixhLnkrZSl9LGZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zdHlsZS5keD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxiLngtYS54KSkpO3RoaXMuc3RhdGUuc3R5bGUuZHk9TWF0aC5yb3VuZChNYXRoLm1heCgwLApNYXRoLm1pbihhLmhlaWdodCxiLnktYS55KSkpfSwhMSldO214VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9ST1VOREVELCExKSYmYi5wdXNoKHRhKGEpKTtyZXR1cm4gYn0sbW9kdWxlOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJqZXR0eVdpZHRoIiwiamV0dHlIZWlnaHQiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKGEud2lkdGgsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJqZXR0eVdpZHRoIixXLnByb3RvdHlwZS5qZXR0eVdpZHRoKSkpLGU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImpldHR5SGVpZ2h0IixXLnByb3RvdHlwZS5qZXR0eUhlaWdodCkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54K2IvMixhLnkrMiplKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLmpldHR5V2lkdGg9TWF0aC5yb3VuZCgyKk1hdGgubWF4KDAsCk1hdGgubWluKGEud2lkdGgsYi54LWEueCkpKTt0aGlzLnN0YXRlLnN0eWxlLmpldHR5SGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihhLmhlaWdodCxiLnktYS55KSkvMil9KV19LGNvcm5lcjpmdW5jdGlvbihhKXtyZXR1cm5bVihhLFsiZHgiLCJkeSJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImR4IixQLnByb3RvdHlwZS5keCkpKSxlPU1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJkeSIsUC5wcm90b3R5cGUuZHkpKSk7cmV0dXJuIG5ldyBteFBvaW50KGEueCtiLGEueStlKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLmR4PU1hdGgucm91bmQoTWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLGIueC1hLngpKSk7dGhpcy5zdGF0ZS5zdHlsZS5keT1NYXRoLnJvdW5kKE1hdGgubWF4KDAsCk1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV19LHRlZTpmdW5jdGlvbihhKXtyZXR1cm5bVihhLFsiZHgiLCJkeSJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsImR4IixlYS5wcm90b3R5cGUuZHgpKSksZT1NYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdGF0ZS5zdHlsZSwiZHkiLGVhLnByb3RvdHlwZS5keSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54KyhhLndpZHRoK2IpLzIsYS55K2UpfSxmdW5jdGlvbihhLGIpe3RoaXMuc3RhdGUuc3R5bGUuZHg9TWF0aC5yb3VuZChNYXRoLm1heCgwLDIqTWF0aC5taW4oYS53aWR0aC8yLGIueC1hLngtYS53aWR0aC8yKSkpO3RoaXMuc3RhdGUuc3R5bGUuZHk9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV19LHNpbmdsZUFycm93OndhKDEpLApkb3VibGVBcnJvdzp3YSguNSksZm9sZGVyOmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJ0YWJXaWR0aCIsInRhYkhlaWdodCJdLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDAsTWF0aC5taW4oYS53aWR0aCxteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInRhYldpZHRoIixxLnByb3RvdHlwZS50YWJXaWR0aCkpKSxlPU1hdGgubWF4KDAsTWF0aC5taW4oYS5oZWlnaHQsbXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJ0YWJIZWlnaHQiLHEucHJvdG90eXBlLnRhYkhlaWdodCkpKTtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInRhYlBvc2l0aW9uIixxLnByb3RvdHlwZS50YWJQb3NpdGlvbik9PW14Q29uc3RhbnRzLkFMSUdOX1JJR0hUJiYoYj1hLndpZHRoLWIpO3JldHVybiBuZXcgbXhQb2ludChhLngrYixhLnkrZSl9LGZ1bmN0aW9uKGEsYil7dmFyIGU9TWF0aC5tYXgoMCxNYXRoLm1pbihhLndpZHRoLGIueC1hLngpKTtteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsCiJ0YWJQb3NpdGlvbiIscS5wcm90b3R5cGUudGFiUG9zaXRpb24pPT1teENvbnN0YW50cy5BTElHTl9SSUdIVCYmKGU9YS53aWR0aC1lKTt0aGlzLnN0YXRlLnN0eWxlLnRhYldpZHRoPU1hdGgucm91bmQoZSk7dGhpcy5zdGF0ZS5zdHlsZS50YWJIZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCgwLE1hdGgubWluKGEuaGVpZ2h0LGIueS1hLnkpKSl9LCExKV19LGRvY3VtZW50OmZ1bmN0aW9uKGEpe3JldHVybltWKGEsWyJzaXplIl0sZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0YXRlLnN0eWxlLCJzaXplIixnLnByb3RvdHlwZS5zaXplKSkpKTtyZXR1cm4gbmV3IG14UG9pbnQoYS54KzMqYS53aWR0aC80LGEueSsoMS1iKSphLmhlaWdodCl9LGZ1bmN0aW9uKGEsYil7dGhpcy5zdGF0ZS5zdHlsZS5zaXplPU1hdGgubWF4KDAsTWF0aC5taW4oMSwoYS55K2EuaGVpZ2h0LWIueSkvYS5oZWlnaHQpKX0sCiExKV19LHRhcGU6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLGUucHJvdG90eXBlLnNpemUpKSkpO3JldHVybiBuZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLnkrYiphLmhlaWdodC8yKX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLChiLnktYS55KS9hLmhlaWdodCoyKSl9LCExKV19LG9mZlBhZ2VDb25uZWN0b3I6ZnVuY3Rpb24oYSl7cmV0dXJuW1YoYSxbInNpemUiXSxmdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3RhdGUuc3R5bGUsInNpemUiLFMucHJvdG90eXBlLnNpemUpKSkpO3JldHVybiBuZXcgbXhQb2ludChhLmdldENlbnRlclgoKSxhLnkrKDEtYikqCmEuaGVpZ2h0KX0sZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXRlLnN0eWxlLnNpemU9TWF0aC5tYXgoMCxNYXRoLm1pbigxLChhLnkrYS5oZWlnaHQtYi55KS9hLmhlaWdodCkpfSwhMSldfSxzdGVwOkVhKEIucHJvdG90eXBlLnNpemUsITAsbnVsbCwhMCxCLnByb3RvdHlwZS5maXhlZFNpemUpLGhleGFnb246RWEoRC5wcm90b3R5cGUuc2l6ZSwhMCwuNSwhMCksY3VybHlCcmFja2V0OkVhKHAucHJvdG90eXBlLnNpemUsITEpLGRpc3BsYXk6RWEodWEucHJvdG90eXBlLnNpemUsITEpLGN1YmU6S2EoMSxhLnByb3RvdHlwZS5zaXplLCExKSxjYXJkOkthKC41LGIucHJvdG90eXBlLnNpemUsITApLGxvb3BMaW1pdDpLYSguNSxoYS5wcm90b3R5cGUuc2l6ZSwhMCksdHJhcGV6b2lkOkxhKC41KSxwYXJhbGxlbG9ncmFtOkxhKDEpfTtHcmFwaC5jcmVhdGVIYW5kbGU9VjtHcmFwaC5oYW5kbGVGYWN0b3J5PUZhO3ZhciBSYT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUhhbmRsZXM7Cm14VmVydGV4SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlQ3VzdG9tSGFuZGxlcz1mdW5jdGlvbigpe3ZhciBhPVJhLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZih0aGlzLmdyYXBoLmlzQ2VsbFJvdGF0YWJsZSh0aGlzLnN0YXRlLmNlbGwpKXt2YXIgYj10aGlzLnN0YXRlLnN0eWxlLnNoYXBlO251bGw9PW14Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXNbYl0mJm51bGw9PW14U3RlbmNpbFJlZ2lzdHJ5LmdldFN0ZW5jaWwoYikmJihiPW14Q29uc3RhbnRzLlNIQVBFX1JFQ1RBTkdMRSk7Yj1GYVtiXTtudWxsPT1iJiZudWxsIT10aGlzLnN0YXRlLnNoYXBlJiZ0aGlzLnN0YXRlLnNoYXBlLmlzUm91bmRhYmxlKCkmJihiPUZhW214Q29uc3RhbnRzLlNIQVBFX1JFQ1RBTkdMRV0pO251bGwhPWImJihiPWIodGhpcy5zdGF0ZSksbnVsbCE9YiYmKGE9bnVsbD09YT9iOmEuY29uY2F0KGIpKSl9cmV0dXJuIGF9O214RWRnZUhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUhhbmRsZXM9ZnVuY3Rpb24oKXt2YXIgYT0KdGhpcy5zdGF0ZS5zdHlsZS5zaGFwZTtudWxsPT1teENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzW2FdJiZudWxsPT1teFN0ZW5jaWxSZWdpc3RyeS5nZXRTdGVuY2lsKGEpJiYoYT1teENvbnN0YW50cy5TSEFQRV9DT05ORUNUT1IpO2E9RmFbYV07cmV0dXJuIG51bGwhPWE/YSh0aGlzLnN0YXRlKTpudWxsfX1lbHNlIEdyYXBoLmNyZWF0ZUhhbmRsZT1mdW5jdGlvbigpe30sR3JhcGguaGFuZGxlRmFjdG9yeT17fTt2YXIgR2E9bmV3IG14UG9pbnQoMSwwKSxIYT1uZXcgbXhQb2ludCgxLDApLHdhPW14VXRpbHMudG9SYWRpYW5zKC0zMCksR2E9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoR2EsTWF0aC5jb3Mod2EpLE1hdGguc2luKHdhKSksd2E9bXhVdGlscy50b1JhZGlhbnMoLTE1MCksSGE9bXhVdGlscy5nZXRSb3RhdGVkUG9pbnQoSGEsTWF0aC5jb3Mod2EpLE1hdGguc2luKHdhKSk7bXhFZGdlU3R5bGUuSXNvbWV0cmljQ29ubmVjdG9yPWZ1bmN0aW9uKGEsYixlLGMsZCl7dmFyIGY9CmEudmlldztjPW51bGwhPWMmJjA8Yy5sZW5ndGg/Y1swXTpudWxsO3ZhciBnPWEuYWJzb2x1dGVQb2ludHMsbD1nWzBdLGc9Z1tnLmxlbmd0aC0xXTtudWxsIT1jJiYoYz1mLnRyYW5zZm9ybUNvbnRyb2xQb2ludChhLGMpKTtudWxsPT1sJiZudWxsIT1iJiYobD1uZXcgbXhQb2ludChiLmdldENlbnRlclgoKSxiLmdldENlbnRlclkoKSkpO251bGw9PWcmJm51bGwhPWUmJihnPW5ldyBteFBvaW50KGUuZ2V0Q2VudGVyWCgpLGUuZ2V0Q2VudGVyWSgpKSk7dmFyIG49R2EueCx1PUdhLnkscD1IYS54LHQ9SGEueSxBPSJob3Jpem9udGFsIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJlbGJvdyIsImhvcml6b250YWwiKTtpZihudWxsIT1nJiZudWxsIT1sKXthPWZ1bmN0aW9uKGEsYixlKXthLT1rLng7dmFyIGM9Yi1rLnk7Yj0odCphLXAqYykvKG4qdC11KnApO2E9KHUqYS1uKmMpLyh1KnAtbip0KTtBPyhlJiYoaz1uZXcgbXhQb2ludChrLngrbipiLGsueSt1KmIpLGQucHVzaChrKSksCms9bmV3IG14UG9pbnQoay54K3AqYSxrLnkrdCphKSk6KGUmJihrPW5ldyBteFBvaW50KGsueCtwKmEsay55K3QqYSksZC5wdXNoKGspKSxrPW5ldyBteFBvaW50KGsueCtuKmIsay55K3UqYikpO2QucHVzaChrKX07dmFyIGs9bDtudWxsPT1jJiYoYz1uZXcgbXhQb2ludChsLngrKGcueC1sLngpLzIsbC55KyhnLnktbC55KS8yKSk7YShjLngsYy55LCEwKTthKGcueCxnLnksITEpfX07bXhTdHlsZVJlZ2lzdHJ5LnB1dFZhbHVlKCJpc29tZXRyaWNFZGdlU3R5bGUiLG14RWRnZVN0eWxlLklzb21ldHJpY0Nvbm5lY3Rvcik7dmFyIFNhPUdyYXBoLnByb3RvdHlwZS5jcmVhdGVFZGdlSGFuZGxlcjtHcmFwaC5wcm90b3R5cGUuY3JlYXRlRWRnZUhhbmRsZXI9ZnVuY3Rpb24oYSxiKXtpZihiPT1teEVkZ2VTdHlsZS5Jc29tZXRyaWNDb25uZWN0b3Ipe3ZhciBlPW5ldyBteEVsYm93RWRnZUhhbmRsZXIoYSk7ZS5zbmFwVG9UZXJtaW5hbHM9ITE7cmV0dXJuIGV9cmV0dXJuIFNhLmFwcGx5KHRoaXMsCmFyZ3VtZW50cyl9O2MucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtdO2YucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXthPVtdO3ZhciBjPU1hdGgudGFuKG14VXRpbHMudG9SYWRpYW5zKDMwKSksZD0oLjUtYykvMixjPU1hdGgubWluKGIsZS8oLjUrYykpO2I9KGItYykvMjtlPShlLWMpLzI7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLGUrLjI1KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIrLjUqYyxlK2MqZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYitjLGUrLjI1KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIrYyxlKy43NSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsYisuNSpjLGUrKDEtZCkqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixlKy43NSpjKSk7cmV0dXJuIGF9O0MucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXthPVtdO214VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9BUkNTSVpFLG14Q29uc3RhbnRzLkxJTkVfQVJDU0laRSk7dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihlLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpO3BhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJwb3NpdGlvbiIsdGhpcy5wb3NpdGlvbikpO3ZhciBkPWIqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJwb3NpdGlvbjIiLHRoaXMucG9zaXRpb24yKSkpKTtwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwKImJhc2UiLHRoaXMuYmFzZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSooZS1jKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixlLWMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLApkLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsZS1jKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLC41KihlLWMpKSk7Yj49MipjJiZhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpKTtyZXR1cm4gYX07bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwKITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsCjEpLCEwKV07bXhFbGxpcHNlLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSkpXTtteExhYmVsLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztteEltYWdlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzPQpteFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztteFN3aW1sYW5lLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50czt6LnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztrLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7YT1bXTt2YXIgYz1NYXRoLm1heCgwLE1hdGgubWluKGIsTWF0aC5taW4oZSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiLWMpLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwKITEsbnVsbCxiLWMsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi0uNSpjLC41KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSooZStjKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITEpKTtiPj0yKmMmJmEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwKMCksITEpKTtyZXR1cm4gYX07Yi5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihiLE1hdGgubWluKGUscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInNpemUiLHRoaXMuc2l6ZSkpKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYitjKSwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxjLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KmMsLjUqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsMCwuNSooZStjKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpKTtiPj0yKmMmJmEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMSkpO3JldHVybiBhfTthLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7YT1bXTt2YXIgYz1NYXRoLm1heCgwLE1hdGgubWluKGIsTWF0aC5taW4oZSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwic2l6ZSIsdGhpcy5zaXplKSkpKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYi1jKSwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWMsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYi0uNSpjLC41KmMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSooZStjKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYitjKSxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsYyxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSpjLGUtLjUqYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxlLWMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsLjUqKGUtYykpKTtyZXR1cm4gYX07cS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihiLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJ0YWJXaWR0aCIsdGhpcy50YWJXaWR0aCkpKSksZD1NYXRoLm1heCgwLE1hdGgubWluKGUscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsInRhYkhlaWdodCIsdGhpcy50YWJIZWlnaHQpKSkpOyJsZWZ0Ij09bXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoidGFiUG9zaXRpb24iLHRoaXMudGFiUG9zaXRpb24pPyhhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSkpLGEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqYywwKSksYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxjLDApKSxhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGMsZCkpLGEucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGIrYyksZCkpKTooYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITEpKSxhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGItLjUqYywwKSksYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsYi1jLDApKSxhLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGItYyxkKSksYS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYi1jKSxkKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLC4yNSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLC41KihlLWQpK2QpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsLjc1KihlLWQpK2QpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSwKbnVsbCxiLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCwuMjUqKGUtZCkrZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCwuNSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLC43NSooZS1kKStkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwKMSksITEpKTtyZXR1cm4gYX07WS5wcm90b3R5cGUuY29uc3RyYWludHM9bXhSZWN0YW5nbGVTaGFwZS5wcm90b3R5cGUuY29uc3RyYWludHM7Z2EucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO2ZhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO3BhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO3JhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO3lhLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO1QucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO29hLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50czt1YS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9CmZ1bmN0aW9uKGEsYixlKXthPVtdO3ZhciBjPU1hdGgubWluKGIsZS8yKSxkPU1hdGgubWluKGItYyxNYXRoLm1heCgwLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkqYik7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExLG51bGwpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGQrYi1jKSwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWMsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSxudWxsKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsYi1jLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihkK2ItYyksZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsZCxlKSk7cmV0dXJuIGF9O1cucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXtiPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZShhLCJqZXR0eVdpZHRoIixXLnByb3RvdHlwZS5qZXR0eVdpZHRoKSkvMjthPXBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZShhLCJqZXR0eUhlaWdodCIsVy5wcm90b3R5cGUuamV0dHlIZWlnaHQpKTt2YXIgYz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsCjApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwxKSwhMSxudWxsLGIpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwxKSwKITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLE1hdGgubWluKGUtLjUqYSwxLjUqYSkpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLE1hdGgubWluKGUtLjUqYSwzLjUqYSkpXTtlPjUqYSYmYy5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMSxudWxsLGIpKTtlPjgqYSYmYy5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExLG51bGwsYikpO2U+MTUqYSYmYy5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjI1KSwhMSxudWxsLGIpKTtyZXR1cm4gY307aGEucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzO1MucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14UmVjdGFuZ2xlU2hhcGUucHJvdG90eXBlLmNvbnN0cmFpbnRzOwpteEN5bGluZGVyLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjE1LC4wNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguODUsLjA1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMyksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMyksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC43KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjE1LAouOTUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjg1LC45NSksITEpXTtGLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC4xKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwuMSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMS8zKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwxKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwxLzMpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDEpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwKLjUpLCExKV07aWEucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjMpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LAoxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LDEpLCEwKV07bXhBY3Rvci5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsLjIpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LC4yNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC45LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LAoxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LDEpLCEwKV07bS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LC4yNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4yNSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LC43NSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsMSksITEpXTtlLnByb3RvdHlwZS5jb25zdHJhaW50cz0KW25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjM1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjY1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMzUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43NSwwKSwhMSldO0IucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LAowKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDEpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNzUpLCEwKV07Cm14TGluZS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMjUsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSldO1EucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMSksITEpXTtteERvdWJsZUVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzPW14RWxsaXBzZS5wcm90b3R5cGUuY29uc3RyYWludHM7bXhSaG9tYnVzLnByb3RvdHlwZS5jb25zdHJhaW50cz1teEVsbGlwc2UucHJvdG90eXBlLmNvbnN0cmFpbnRzO214VHJpYW5nbGUucHJvdG90eXBlLmNvbnN0cmFpbnRzPQpbbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuMjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNzUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKV07bXhIZXhhZ29uLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjM3NSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC42MjUsMCksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCi4yNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43NSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjI1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjc1KSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjM3NSwxKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC42MjUsMSksITApXTtteENsb3VkLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC4yNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC40LAouMSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4xNiwuNTUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMDcsLjQpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMzEsLjgpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguMTMsLjc3KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjgsLjgpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNTUsLjk1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjg3NSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC45NiwuNyksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC42MjUsLjIpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguODgsCi4yNSksITEpXTtuLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztsLnByb3RvdHlwZS5jb25zdHJhaW50cz1teFJlY3RhbmdsZVNoYXBlLnByb3RvdHlwZS5jb25zdHJhaW50cztnLnByb3RvdHlwZS5jb25zdHJhaW50cz1bbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNSwwKSwhMCksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjc1LDApLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC4yNSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC43NSksITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjI1KSwKITApLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCEwKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC43NSksITApXTtteEFycm93LnByb3RvdHlwZS5jb25zdHJhaW50cz1udWxsO2VhLnByb3RvdHlwZS5nZXRDb25zdHJhaW50cz1mdW5jdGlvbihhLGIsZSl7YT1bXTt2YXIgYz1NYXRoLm1heCgwLE1hdGgubWluKGIscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImR4Iix0aGlzLmR4KSkpKSxkPU1hdGgubWF4KDAsTWF0aC5taW4oZSxwYXJzZUZsb2F0KG14VXRpbHMuZ2V0VmFsdWUodGhpcy5zdHlsZSwiZHkiLHRoaXMuZHkpKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC41LDApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsCjApLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLC41KmQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjc1KmIrLjI1KmMsZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGIrYyksZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGIrYyksLjUqKGUrZCkpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiK2MpLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMSksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKMCksITEsbnVsbCwuNSooYi1jKSxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSooYi1jKSwuNSooZStkKSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGItYyksZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjI1KmItLjI1KmMsZCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLC41KmQpKTtyZXR1cm4gYX07UC5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihiLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLAoiZHgiLHRoaXMuZHgpKSkpLGQ9TWF0aC5tYXgoMCxNYXRoLm1pbihlLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJkeSIsdGhpcy5keSkpKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwwKSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYiwuNSpkKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiK2MpLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwKMCksITEsbnVsbCxjLGQpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGMsLjUqKGUrZCkpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGMsZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqYyxlKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMSksITEpKTtyZXR1cm4gYX07TC5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLAoxKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCguNzUsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLDApLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwxKSwhMSldO08ucHJvdG90eXBlLmdldENvbnN0cmFpbnRzPWZ1bmN0aW9uKGEsYixlKXthPVtdO3ZhciBjPWUqTWF0aC5tYXgoMCxNYXRoLm1pbigxLHBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJhcnJvd1dpZHRoIix0aGlzLmFycm93V2lkdGgpKSkpLGQ9YipNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsCiJhcnJvd1NpemUiLHRoaXMuYXJyb3dTaXplKSkpKSxjPShlLWMpLzI7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwwLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiLWQpLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGItZCwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWQsZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqKGItZCksZS1jKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsMCxlLWMpKTtyZXR1cm4gYX07WC5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9ZSpNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93V2lkdGgiLE8ucHJvdG90eXBlLmFycm93V2lkdGgpKSkpLGQ9YipNYXRoLm1heCgwLE1hdGgubWluKDEscGFyc2VGbG9hdChteFV0aWxzLmdldFZhbHVlKHRoaXMuc3R5bGUsImFycm93U2l6ZSIsTy5wcm90b3R5cGUuYXJyb3dTaXplKSkpKSxjPShlLWMpLzI7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KmIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLAowKSwhMSxudWxsLGItZCwwKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDEsLjUpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxiLWQsZSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsLjUqYixlLWMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsZSkpO3JldHVybiBhfTtzYS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludHM9ZnVuY3Rpb24oYSxiLGUpe2E9W107dmFyIGM9TWF0aC5taW4oZSxiKSxkPU1hdGgubWF4KDAsTWF0aC5taW4oYyxjKnBhcnNlRmxvYXQobXhVdGlscy5nZXRWYWx1ZSh0aGlzLnN0eWxlLCJzaXplIix0aGlzLnNpemUpKSkpLGM9KGUtZCkvMixmPWMrZCxnPShiLWQpLzIsZD1nK2Q7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsZywuNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxnLDApKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsMCksITEpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsMCkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsZCwuNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGcsZS0uNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxnLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjUsCjEpLCExKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGUpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGQsZS0uNSpjKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCxkLGYpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLC41KihiK2QpLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGIsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsYixmKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsCjApLCExLG51bGwsLjUqKGIrZCksZikpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsZyxmKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSpnLGMpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLDAsYykpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSkpO2EucHVzaChuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLDApLCExLG51bGwsMCxmKSk7YS5wdXNoKG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsMCksITEsbnVsbCwuNSpnLGYpKTthLnB1c2gobmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwwKSwhMSxudWxsLGcsYykpO3JldHVybiBhfTtBLnByb3RvdHlwZS5jb25zdHJhaW50cz0KbnVsbDt4YS5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjI1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMCwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjc1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43LC4xKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjcsLjkpLCExKV07Ti5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC4xNzUsLjI1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjI1LC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjE3NSwKLjc1KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpLG5ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KC43LC4xKSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoLjcsLjkpLCExKV07Ui5wcm90b3R5cGUuY29uc3RyYWludHM9W25ldyBteENvbm5lY3Rpb25Db25zdHJhaW50KG5ldyBteFBvaW50KDAsLjUpLCExKSxuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgxLC41KSwhMSldO1oucHJvdG90eXBlLmNvbnN0cmFpbnRzPVtuZXcgbXhDb25uZWN0aW9uQ29uc3RyYWludChuZXcgbXhQb2ludCgwLC41KSwhMSksbmV3IG14Q29ubmVjdGlvbkNvbnN0cmFpbnQobmV3IG14UG9pbnQoMSwuNSksITEpXX0pKCk7ZnVuY3Rpb24gQWN0aW9ucyhhKXt0aGlzLmVkaXRvclVpPWE7dGhpcy5hY3Rpb25zPXt9O3RoaXMuaW5pdCgpfQpBY3Rpb25zLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtkLmVzY2FwZSgpO2E9ZC5kZWxldGVDZWxscyhkLmdldERlbGV0YWJsZUNlbGxzKGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSksYSk7bnVsbCE9YSYmZC5zZXRTZWxlY3Rpb25DZWxscyhhKX12YXIgYz10aGlzLmVkaXRvclVpLGY9Yy5lZGl0b3IsZD1mLmdyYXBoLGs9ZnVuY3Rpb24oKXtyZXR1cm4gQWN0aW9uLnByb3RvdHlwZS5pc0VuYWJsZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpJiZkLmlzRW5hYmxlZCgpfTt0aGlzLmFkZEFjdGlvbigibmV3Li4uIixmdW5jdGlvbigpe2Qub3BlbkxpbmsoYy5nZXRVcmwoKSl9KTt0aGlzLmFkZEFjdGlvbigib3Blbi4uLiIsZnVuY3Rpb24oKXt3aW5kb3cub3Blbk5ldz0hMDt3aW5kb3cub3BlbktleT0ib3BlbiI7Yy5vcGVuRmlsZSgpfSk7dGhpcy5hZGRBY3Rpb24oImltcG9ydC4uLiIsZnVuY3Rpb24oKXt3aW5kb3cub3Blbk5ldz0hMTt3aW5kb3cub3BlbktleT0KImltcG9ydCI7d2luZG93Lm9wZW5GaWxlPW5ldyBPcGVuRmlsZShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2MuaGlkZURpYWxvZygpfSkpO3dpbmRvdy5vcGVuRmlsZS5zZXRDb25zdW1lcihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGUpe3RyeXt2YXIgYj1teFV0aWxzLnBhcnNlWG1sKGEpO2YuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbHMoZi5ncmFwaC5pbXBvcnRHcmFwaE1vZGVsKGIuZG9jdW1lbnRFbGVtZW50KSl9Y2F0Y2gobil7bXhVdGlscy5hbGVydChteFJlc291cmNlcy5nZXQoImludmFsaWRPck1pc3NpbmdGaWxlIikrIjogIituLm1lc3NhZ2UpfX0pKTtjLnNob3dEaWFsb2coKG5ldyBPcGVuRGlhbG9nKHRoaXMpKS5jb250YWluZXIsMzIwLDIyMCwhMCwhMCxmdW5jdGlvbigpe3dpbmRvdy5vcGVuRmlsZT1udWxsfSl9KS5pc0VuYWJsZWQ9azt0aGlzLmFkZEFjdGlvbigic2F2ZSIsZnVuY3Rpb24oKXtjLnNhdmVGaWxlKCExKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KwoiK1MiKS5pc0VuYWJsZWQ9azt0aGlzLmFkZEFjdGlvbigic2F2ZUFzLi4uIixmdW5jdGlvbigpe2Muc2F2ZUZpbGUoITApfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtTIikuaXNFbmFibGVkPWs7dGhpcy5hZGRBY3Rpb24oImV4cG9ydC4uLiIsZnVuY3Rpb24oKXtjLnNob3dEaWFsb2coKG5ldyBFeHBvcnREaWFsb2coYykpLmNvbnRhaW5lciwzMDAsMjk2LCEwLCEwKX0pO3RoaXMuYWRkQWN0aW9uKCJlZGl0RGlhZ3JhbS4uLiIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgRWRpdERpYWdyYW1EaWFsb2coYyk7Yy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDYyMCw0MjAsITAsITEpO2EuaW5pdCgpfSk7dGhpcy5hZGRBY3Rpb24oInBhZ2VTZXR1cC4uLiIsZnVuY3Rpb24oKXtjLnNob3dEaWFsb2coKG5ldyBQYWdlU2V0dXBEaWFsb2coYykpLmNvbnRhaW5lciwzMjAsMjIwLCEwLCEwKX0pLmlzRW5hYmxlZD1rO3RoaXMuYWRkQWN0aW9uKCJwcmludC4uLiIsZnVuY3Rpb24oKXtjLnNob3dEaWFsb2coKG5ldyBQcmludERpYWxvZyhjKSkuY29udGFpbmVyLAozMDAsMTgwLCEwLCEwKX0sbnVsbCwic3ByaXRlLXByaW50IixFZGl0b3IuY3RybEtleSsiK1AiKTt0aGlzLmFkZEFjdGlvbigicHJldmlldyIsZnVuY3Rpb24oKXtteFV0aWxzLnNob3coZCxudWxsLDEwLDEwKX0pO3RoaXMuYWRkQWN0aW9uKCJ1bmRvIixmdW5jdGlvbigpe2MudW5kbygpfSxudWxsLCJzcHJpdGUtdW5kbyIsRWRpdG9yLmN0cmxLZXkrIitaIik7dGhpcy5hZGRBY3Rpb24oInJlZG8iLGZ1bmN0aW9uKCl7Yy5yZWRvKCl9LG51bGwsInNwcml0ZS1yZWRvIixteENsaWVudC5JU19XSU4/RWRpdG9yLmN0cmxLZXkrIitZIjpFZGl0b3IuY3RybEtleSsiK1NoaWZ0K1oiKTt0aGlzLmFkZEFjdGlvbigiY3V0IixmdW5jdGlvbigpe214Q2xpcGJvYXJkLmN1dChkKX0sbnVsbCwic3ByaXRlLWN1dCIsRWRpdG9yLmN0cmxLZXkrIitYIik7dGhpcy5hZGRBY3Rpb24oImNvcHkiLGZ1bmN0aW9uKCl7dHJ5e214Q2xpcGJvYXJkLmNvcHkoZCl9Y2F0Y2goYil7Yy5oYW5kbGVFcnJvcihiKX19LApudWxsLCJzcHJpdGUtY29weSIsRWRpdG9yLmN0cmxLZXkrIitDIik7dGhpcy5hZGRBY3Rpb24oInBhc3RlIixmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJiFkLmlzQ2VsbExvY2tlZChkLmdldERlZmF1bHRQYXJlbnQoKSkmJm14Q2xpcGJvYXJkLnBhc3RlKGQpfSwhMSwic3ByaXRlLXBhc3RlIixFZGl0b3IuY3RybEtleSsiK1YiKTt0aGlzLmFkZEFjdGlvbigicGFzdGVIZXJlIixmdW5jdGlvbihhKXtpZihkLmlzRW5hYmxlZCgpJiYhZC5pc0NlbGxMb2NrZWQoZC5nZXREZWZhdWx0UGFyZW50KCkpKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGI9bXhDbGlwYm9hcmQucGFzdGUoZCk7aWYobnVsbCE9Yil7YT0hMDtmb3IodmFyIGM9MDtjPGIubGVuZ3RoJiZhO2MrKylhPWEmJmQubW9kZWwuaXNFZGdlKGJbY10pO3ZhciBmPWQudmlldy50cmFuc2xhdGUsbD1kLnZpZXcuc2NhbGUscD1mLngsaz1mLnksZj1udWxsO2lmKDE9PWIubGVuZ3RoJiZhKXt2YXIgdD1kLmdldENlbGxHZW9tZXRyeShiWzBdKTsKbnVsbCE9dCYmKGY9dC5nZXRUZXJtaW5hbFBvaW50KCEwKSl9Zj1udWxsIT1mP2Y6ZC5nZXRCb3VuZGluZ0JveEZyb21HZW9tZXRyeShiLGEpO2lmKG51bGwhPWYpe3ZhciBtPU1hdGgucm91bmQoZC5zbmFwKGQucG9wdXBNZW51SGFuZGxlci50cmlnZ2VyWC9sLXApKSx4PU1hdGgucm91bmQoZC5zbmFwKGQucG9wdXBNZW51SGFuZGxlci50cmlnZ2VyWS9sLWspKTtkLmNlbGxzTW92ZWQoYixtLWYueCx4LWYueSl9fX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19fSk7dGhpcy5hZGRBY3Rpb24oImNvcHlTaXplIixmdW5jdGlvbihhKXthPWQuZ2V0U2VsZWN0aW9uQ2VsbCgpO2QuaXNFbmFibGVkKCkmJm51bGwhPWEmJmQuZ2V0TW9kZWwoKS5pc1ZlcnRleChhKSYmKGE9ZC5nZXRDZWxsR2VvbWV0cnkoYSksbnVsbCE9YSYmKGMuY29waWVkU2l6ZT1uZXcgbXhSZWN0YW5nbGUoYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0KSkpfSxudWxsLG51bGwsIkFsdCtTaGlmdCtYIik7CnRoaXMuYWRkQWN0aW9uKCJwYXN0ZVNpemUiLGZ1bmN0aW9uKGEpe2lmKGQuaXNFbmFibGVkKCkmJiFkLmlzU2VsZWN0aW9uRW1wdHkoKSYmbnVsbCE9Yy5jb3BpZWRTaXplKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGI9ZC5nZXRTZWxlY3Rpb25DZWxscygpO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspaWYoZC5nZXRNb2RlbCgpLmlzVmVydGV4KGJbYV0pKXt2YXIgZj1kLmdldENlbGxHZW9tZXRyeShiW2FdKTtudWxsIT1mJiYoZj1mLmNsb25lKCksZi53aWR0aD1jLmNvcGllZFNpemUud2lkdGgsZi5oZWlnaHQ9Yy5jb3BpZWRTaXplLmhlaWdodCxkLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkoYlthXSxmKSl9fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1YiKTt0aGlzLmFkZEFjdGlvbigiZGVsZXRlIixmdW5jdGlvbihiKXthKG51bGwhPWImJm14RXZlbnQuaXNTaGlmdERvd24oYikpfSxudWxsLG51bGwsIkRlbGV0ZSIpOwp0aGlzLmFkZEFjdGlvbigiZGVsZXRlQWxsIixmdW5jdGlvbigpe2EoITApfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitEZWxldGUiKTt0aGlzLmFkZEFjdGlvbigiZHVwbGljYXRlIixmdW5jdGlvbigpe3RyeXtkLnNldFNlbGVjdGlvbkNlbGxzKGQuZHVwbGljYXRlQ2VsbHMoKSl9Y2F0Y2goYil7Yy5oYW5kbGVFcnJvcihiKX19LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0QiKTt0aGlzLnB1dCgidHVybiIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoInR1cm4iKSsiIC8gIitteFJlc291cmNlcy5nZXQoInJldmVyc2UiKSxmdW5jdGlvbihhKXtkLnR1cm5TaGFwZXMoZC5nZXRTZWxlY3Rpb25DZWxscygpLG51bGwhPWE/bXhFdmVudC5pc1NoaWZ0RG93bihhKTohMSl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1IiKSk7dGhpcy5hZGRBY3Rpb24oInNlbGVjdFZlcnRpY2VzIixmdW5jdGlvbigpe2Quc2VsZWN0VmVydGljZXMobnVsbCwhMCl9LG51bGwsbnVsbCwKRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtJIik7dGhpcy5hZGRBY3Rpb24oInNlbGVjdEVkZ2VzIixmdW5jdGlvbigpe2Quc2VsZWN0RWRnZXMoKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRSIpO3RoaXMuYWRkQWN0aW9uKCJzZWxlY3RBbGwiLGZ1bmN0aW9uKCl7ZC5zZWxlY3RBbGwobnVsbCwhMCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0EiKTt0aGlzLmFkZEFjdGlvbigic2VsZWN0Tm9uZSIsZnVuY3Rpb24oKXtkLmNsZWFyU2VsZWN0aW9uKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K0EiKTt0aGlzLmFkZEFjdGlvbigibG9ja1VubG9jayIsZnVuY3Rpb24oKXtpZighZC5pc1NlbGVjdGlvbkVtcHR5KCkpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYT1kLmlzQ2VsbE1vdmFibGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpPzE6MDtkLnRvZ2dsZUNlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfTU9WQUJMRSxhKTtkLnRvZ2dsZUNlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUkVTSVpBQkxFLAphKTtkLnRvZ2dsZUNlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUk9UQVRBQkxFLGEpO2QudG9nZ2xlQ2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9ERUxFVEFCTEUsYSk7ZC50b2dnbGVDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0VESVRBQkxFLGEpO2QudG9nZ2xlQ2VsbFN0eWxlcygiY29ubmVjdGFibGUiLGEpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0wiKTt0aGlzLmFkZEFjdGlvbigiaG9tZSIsZnVuY3Rpb24oKXtkLmhvbWUoKX0sbnVsbCxudWxsLCJTaGlmdCtIb21lIik7dGhpcy5hZGRBY3Rpb24oImV4aXRHcm91cCIsZnVuY3Rpb24oKXtkLmV4aXRHcm91cCgpfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtIb21lIik7dGhpcy5hZGRBY3Rpb24oImVudGVyR3JvdXAiLGZ1bmN0aW9uKCl7ZC5lbnRlckdyb3VwKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K0VuZCIpOwp0aGlzLmFkZEFjdGlvbigiY29sbGFwc2UiLGZ1bmN0aW9uKCl7ZC5mb2xkQ2VsbHMoITApfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitIb21lIik7dGhpcy5hZGRBY3Rpb24oImV4cGFuZCIsZnVuY3Rpb24oKXtkLmZvbGRDZWxscyghMSl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0VuZCIpO3RoaXMuYWRkQWN0aW9uKCJ0b0Zyb250IixmdW5jdGlvbigpe2Qub3JkZXJDZWxscyghMSl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K0YiKTt0aGlzLmFkZEFjdGlvbigidG9CYWNrIixmdW5jdGlvbigpe2Qub3JkZXJDZWxscyghMCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K0IiKTt0aGlzLmFkZEFjdGlvbigiZ3JvdXAiLGZ1bmN0aW9uKCl7MT09ZC5nZXRTZWxlY3Rpb25Db3VudCgpP2Quc2V0Q2VsbFN0eWxlcygiY29udGFpbmVyIiwiMSIpOmQuc2V0U2VsZWN0aW9uQ2VsbChkLmdyb3VwQ2VsbHMobnVsbCwwKSl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsKIitHIik7dGhpcy5hZGRBY3Rpb24oInVuZ3JvdXAiLGZ1bmN0aW9uKCl7MT09ZC5nZXRTZWxlY3Rpb25Db3VudCgpJiYwPT1kLmdldE1vZGVsKCkuZ2V0Q2hpbGRDb3VudChkLmdldFNlbGVjdGlvbkNlbGwoKSk/ZC5zZXRDZWxsU3R5bGVzKCJjb250YWluZXIiLCIwIik6ZC5zZXRTZWxlY3Rpb25DZWxscyhkLnVuZ3JvdXBDZWxscygpKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrVSIpO3RoaXMuYWRkQWN0aW9uKCJyZW1vdmVGcm9tR3JvdXAiLGZ1bmN0aW9uKCl7ZC5yZW1vdmVDZWxsc0Zyb21QYXJlbnQoKX0pO3RoaXMuYWRkQWN0aW9uKCJlZGl0IixmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJmQuc3RhcnRFZGl0aW5nQXRDZWxsKCl9LG51bGwsbnVsbCwiRjIvRW50ZXIiKTt0aGlzLmFkZEFjdGlvbigiZWRpdERhdGEuLi4iLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxsKCl8fGQuZ2V0TW9kZWwoKS5nZXRSb290KCk7Yy5zaG93RGF0YURpYWxvZyhhKX0sCm51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK00iKTt0aGlzLmFkZEFjdGlvbigiZWRpdFRvb2x0aXAuLi4iLGZ1bmN0aW9uKCl7dmFyIGE9Yy5lZGl0b3IuZ3JhcGg7aWYoYS5pc0VuYWJsZWQoKSYmIWEuaXNTZWxlY3Rpb25FbXB0eSgpKXt2YXIgZT1hLmdldFNlbGVjdGlvbkNlbGwoKSxkPSIiO2lmKG14VXRpbHMuaXNOb2RlKGUudmFsdWUpKXt2YXIgZj1lLnZhbHVlLmdldEF0dHJpYnV0ZSgidG9vbHRpcCIpO251bGwhPWYmJihkPWYpfWQ9bmV3IFRleHRhcmVhRGlhbG9nKGMsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0VG9vbHRpcCIpKyI6IixkLGZ1bmN0aW9uKGIpe2Euc2V0VG9vbHRpcEZvckNlbGwoZSxiKX0pO2Muc2hvd0RpYWxvZyhkLmNvbnRhaW5lciwzMjAsMjAwLCEwLCEwKTtkLmluaXQoKX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1QiKTt0aGlzLmFkZEFjdGlvbigib3BlbkxpbmsiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRMaW5rRm9yQ2VsbChkLmdldFNlbGVjdGlvbkNlbGwoKSk7Cm51bGwhPWEmJmQub3BlbkxpbmsoYSl9KTt0aGlzLmFkZEFjdGlvbigiZWRpdExpbmsuLi4iLGZ1bmN0aW9uKCl7dmFyIGE9Yy5lZGl0b3IuZ3JhcGg7aWYoYS5pc0VuYWJsZWQoKSYmIWEuaXNTZWxlY3Rpb25FbXB0eSgpKXt2YXIgZT1hLmdldFNlbGVjdGlvbkNlbGwoKSxkPWEuZ2V0TGlua0ZvckNlbGwoZSl8fCIiO2Muc2hvd0xpbmtEaWFsb2coZCxteFJlc291cmNlcy5nZXQoImFwcGx5IiksZnVuY3Rpb24oYil7Yj1teFV0aWxzLnRyaW0oYik7YS5zZXRMaW5rRm9yQ2VsbChlLDA8Yi5sZW5ndGg/YjpudWxsKX0pfX0sbnVsbCxudWxsLCJBbHQrU2hpZnQrTCIpO3RoaXMucHV0KCJpbnNlcnRJbWFnZSIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImltYWdlIikrIi4uLiIsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiYhZC5pc0NlbGxMb2NrZWQoZC5nZXREZWZhdWx0UGFyZW50KCkpJiYoZC5jbGVhclNlbGVjdGlvbigpLGMuYWN0aW9ucy5nZXQoImltYWdlIikuZnVuY3QoKSl9KSkuaXNFbmFibGVkPQprO3RoaXMucHV0KCJpbnNlcnRMaW5rIixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgibGluayIpKyIuLi4iLGZ1bmN0aW9uKCl7ZC5pc0VuYWJsZWQoKSYmIWQuaXNDZWxsTG9ja2VkKGQuZ2V0RGVmYXVsdFBhcmVudCgpKSYmYy5zaG93TGlua0RpYWxvZygiIixteFJlc291cmNlcy5nZXQoImluc2VydCIpLGZ1bmN0aW9uKGEsZSl7YT1teFV0aWxzLnRyaW0oYSk7aWYoMDxhLmxlbmd0aCl7dmFyIGI9bnVsbCxjPWQuZ2V0TGlua1RpdGxlKGEpO251bGwhPWUmJjA8ZS5sZW5ndGgmJihiPWVbMF0uaWNvblVybCxjPWVbMF0ubmFtZXx8ZVswXS50eXBlLGM9Yy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStjLnN1YnN0cmluZygxKSwzMDxjLmxlbmd0aCYmKGM9Yy5zdWJzdHJpbmcoMCwzMCkrIi4uLiIpKTt2YXIgZj1kLmdldEZyZWVJbnNlcnRQb2ludCgpLGI9bmV3IG14Q2VsbChjLG5ldyBteEdlb21ldHJ5KGYueCxmLnksMTAwLDQwKSwiZm9udENvbG9yPSMwMDAwRUU7Zm9udFN0eWxlPTQ7cm91bmRlZD0xO292ZXJmbG93PWhpZGRlbjsiKwoobnVsbCE9Yj8ic2hhcGU9bGFiZWw7aW1hZ2VXaWR0aD0xNjtpbWFnZUhlaWdodD0xNjtzcGFjaW5nTGVmdD0yNjthbGlnbj1sZWZ0O2ltYWdlPSIrYjoic3BhY2luZz0xMDsiKSk7Yi52ZXJ0ZXg9ITA7ZC5zZXRMaW5rRm9yQ2VsbChiLGEpO2QuY2VsbFNpemVVcGRhdGVkKGIsITApO2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtiPWQuYWRkQ2VsbChiKSxkLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY2VsbHNJbnNlcnRlZCIsImNlbGxzIixbYl0pKX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX1kLnNldFNlbGVjdGlvbkNlbGwoYik7ZC5zY3JvbGxDZWxsVG9WaXNpYmxlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKX19KX0pKS5pc0VuYWJsZWQ9azt0aGlzLmFkZEFjdGlvbigibGluay4uLiIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1jLmVkaXRvci5ncmFwaDtpZihhLmlzRW5hYmxlZCgpKWlmKGEuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkpe3ZhciBlPQphLmdldFNlbGVjdGVkRWxlbWVudCgpLGQ9YS5nZXRQYXJlbnRCeU5hbWUoZSwiQSIsYS5jZWxsRWRpdG9yLnRleHRhcmVhKSxmPSIiO2lmKG51bGw9PWQmJm51bGwhPWUmJm51bGwhPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUpZm9yKHZhciBsPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKSxwPTA7cDxsLmxlbmd0aCYmbnVsbD09ZDtwKyspbFtwXS50ZXh0Q29udGVudD09ZS50ZXh0Q29udGVudCYmKGQ9bFtwXSk7bnVsbCE9ZCYmIkEiPT1kLm5vZGVOYW1lJiYoZj1kLmdldEF0dHJpYnV0ZSgiaHJlZiIpfHwiIixhLnNlbGVjdE5vZGUoZCkpO3ZhciBrPWEuY2VsbEVkaXRvci5zYXZlU2VsZWN0aW9uKCk7Yy5zaG93TGlua0RpYWxvZyhmLG14UmVzb3VyY2VzLmdldCgiYXBwbHkiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXthLmNlbGxFZGl0b3IucmVzdG9yZVNlbGVjdGlvbihrKTtudWxsIT1iJiZhLmluc2VydExpbmsoYil9KSl9ZWxzZSBhLmlzU2VsZWN0aW9uRW1wdHkoKT8KdGhpcy5nZXQoImluc2VydExpbmsiKS5mdW5jdCgpOnRoaXMuZ2V0KCJlZGl0TGluayIpLmZ1bmN0KCl9KSkuaXNFbmFibGVkPWs7dGhpcy5hZGRBY3Rpb24oImF1dG9zaXplIixmdW5jdGlvbigpe3ZhciBhPWQuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtpZihudWxsIT1hKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspe3ZhciBjPWFbZV07aWYoZC5nZXRNb2RlbCgpLmdldENoaWxkQ291bnQoYykpZC51cGRhdGVHcm91cEJvdW5kcyhbY10sMjApO2Vsc2V7dmFyIGY9ZC52aWV3LmdldFN0YXRlKGMpLGw9ZC5nZXRDZWxsR2VvbWV0cnkoYyk7ZC5nZXRNb2RlbCgpLmlzVmVydGV4KGMpJiZudWxsIT1mJiZudWxsIT1mLnRleHQmJm51bGwhPWwmJmQuaXNXcmFwcGluZyhjKT8obD1sLmNsb25lKCksbC5oZWlnaHQ9Zi50ZXh0LmJvdW5kaW5nQm94LmhlaWdodC9kLnZpZXcuc2NhbGUsZC5nZXRNb2RlbCgpLnNldEdlb21ldHJ5KGMsbCkpOgpkLnVwZGF0ZUNlbGxTaXplKGMpfX19ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrWSIpO3RoaXMuYWRkQWN0aW9uKCJmb3JtYXR0ZWRUZXh0IixmdW5jdGlvbigpe3ZhciBhPWQuZ2V0VmlldygpLmdldFN0YXRlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKTtpZihudWxsIT1hKXtkLnN0b3BFZGl0aW5nKCk7YT0iMSI9PWEuc3R5bGUuaHRtbD9udWxsOiIxIjtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPWQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxmPTA7ZjxlLmxlbmd0aDtmKyspaWYoc3RhdGU9ZC5nZXRWaWV3KCkuZ2V0U3RhdGUoZVtmXSksbnVsbCE9c3RhdGUpe3ZhciBuPW14VXRpbHMuZ2V0VmFsdWUoc3RhdGUuc3R5bGUsImh0bWwiLCIwIik7aWYoIjEiPT1uJiZudWxsPT1hKXt2YXIgbD1kLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKHN0YXRlLmNlbGwpOyIwIiE9bXhVdGlscy5nZXRWYWx1ZShzdGF0ZS5zdHlsZSwKIm5sMkJyIiwiMSIpJiYobD1sLnJlcGxhY2UoL1xuL2csIiIpLnJlcGxhY2UoLzxiclxzKi4/Pi9nLCJcbiIpKTt2YXIgcD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtwLmlubmVySFRNTD1sO2w9bXhVdGlscy5leHRyYWN0VGV4dFdpdGhXaGl0ZXNwYWNlKHAuY2hpbGROb2Rlcyk7ZC5jZWxsTGFiZWxDaGFuZ2VkKHN0YXRlLmNlbGwsbCk7ZC5zZXRDZWxsU3R5bGVzKCJodG1sIixhLFtlW2ZdXSl9ZWxzZSIwIj09biYmIjEiPT1hJiYobD1teFV0aWxzLmh0bWxFbnRpdGllcyhkLmNvbnZlcnRWYWx1ZVRvU3RyaW5nKHN0YXRlLmNlbGwpLCExKSwiMCIhPW14VXRpbHMuZ2V0VmFsdWUoc3RhdGUuc3R5bGUsIm5sMkJyIiwiMSIpJiYobD1sLnJlcGxhY2UoL1xuL2csIjxici8+IikpLGQuY2VsbExhYmVsQ2hhbmdlZChzdGF0ZS5jZWxsLGQuc2FuaXRpemVIdG1sKGwpKSxkLnNldENlbGxTdHlsZXMoImh0bWwiLGEsW2VbZl1dKSl9Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsCiJrZXlzIixbImh0bWwiXSwidmFsdWVzIixbbnVsbCE9YT9hOiIwIl0sImNlbGxzIixlKSl9ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0pO3RoaXMuYWRkQWN0aW9uKCJ3b3JkV3JhcCIsZnVuY3Rpb24oKXt2YXIgYT1kLmdldFZpZXcoKS5nZXRTdGF0ZShkLmdldFNlbGVjdGlvbkNlbGwoKSksZT0id3JhcCI7ZC5zdG9wRWRpdGluZygpO251bGwhPWEmJiJ3cmFwIj09YS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9XSElURV9TUEFDRV0mJihlPW51bGwpO2Quc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9XSElURV9TUEFDRSxlKX0pO3RoaXMuYWRkQWN0aW9uKCJyb3RhdGlvbiIsZnVuY3Rpb24oKXt2YXIgYT0iMCIsZT1kLmdldFZpZXcoKS5nZXRTdGF0ZShkLmdldFNlbGVjdGlvbkNlbGwoKSk7bnVsbCE9ZSYmKGE9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTl18fGEpO2E9bmV3IEZpbGVuYW1lRGlhbG9nKGMsYSxteFJlc291cmNlcy5nZXQoImFwcGx5IiksCmZ1bmN0aW9uKGEpe251bGwhPWEmJjA8YS5sZW5ndGgmJmQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9ST1RBVElPTixhKX0sbXhSZXNvdXJjZXMuZ2V0KCJlbnRlclZhbHVlIikrIiAoIitteFJlc291cmNlcy5nZXQoInJvdGF0aW9uIikrIiAwLTM2MCkiKTtjLnNob3dEaWFsb2coYS5jb250YWluZXIsMzc1LDgwLCEwLCEwKTthLmluaXQoKX0pO3RoaXMuYWRkQWN0aW9uKCJyZXNldFZpZXciLGZ1bmN0aW9uKCl7ZC56b29tVG8oMSk7Yy5yZXNldFNjcm9sbGJhcnMoKX0sbnVsbCxudWxsLCJIb21lIik7dGhpcy5hZGRBY3Rpb24oInpvb21JbiIsZnVuY3Rpb24oYSl7ZC5pc0Zhc3Rab29tRW5hYmxlZCgpP2QubGF6eVpvb20oITAsITAsYy5idXR0b25ab29tRGVsYXkpOmQuem9vbUluKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiICsgKE51bXBhZCkgLyBBbHQrTW91c2V3aGVlbCIpO3RoaXMuYWRkQWN0aW9uKCJ6b29tT3V0IixmdW5jdGlvbihhKXtkLmlzRmFzdFpvb21FbmFibGVkKCk/CmQubGF6eVpvb20oITEsITAsYy5idXR0b25ab29tRGVsYXkpOmQuem9vbU91dCgpfSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIiAtIChOdW1wYWQpIC8gQWx0K01vdXNld2hlZWwiKTt0aGlzLmFkZEFjdGlvbigiZml0V2luZG93IixmdW5jdGlvbigpe3ZhciBhPWQuaXNTZWxlY3Rpb25FbXB0eSgpP2QuZ2V0R3JhcGhCb3VuZHMoKTpkLmdldEJvdW5kaW5nQm94KGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSksZT1kLnZpZXcudHJhbnNsYXRlLGM9ZC52aWV3LnNjYWxlO2Eud2lkdGgvPWM7YS5oZWlnaHQvPWM7YS54PWEueC9jLWUueDthLnk9YS55L2MtZS55O3ZhciBjPWQuY29udGFpbmVyLmNsaWVudFdpZHRoLTEwLGY9ZC5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwLGw9TWF0aC5mbG9vcigyMCpNYXRoLm1pbihjL2Eud2lkdGgsZi9hLmhlaWdodCkpLzIwO2Quem9vbVRvKGwpO214VXRpbHMuaGFzU2Nyb2xsYmFycyhkLmNvbnRhaW5lcikmJihkLmNvbnRhaW5lci5zY3JvbGxUb3A9KGEueSsKZS55KSpsLU1hdGgubWF4KChmLWEuaGVpZ2h0KmwpLzIrNSwwKSxkLmNvbnRhaW5lci5zY3JvbGxMZWZ0PShhLngrZS54KSpsLU1hdGgubWF4KChjLWEud2lkdGgqbCkvMis1LDApKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrSCIpO3RoaXMuYWRkQWN0aW9uKCJmaXRQYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2QucGFnZVZpc2libGV8fHRoaXMuZ2V0KCJwYWdlVmlldyIpLmZ1bmN0KCk7dmFyIGE9ZC5wYWdlRm9ybWF0LGU9ZC5wYWdlU2NhbGU7ZC56b29tVG8oTWF0aC5mbG9vcigyMCpNYXRoLm1pbigoZC5jb250YWluZXIuY2xpZW50V2lkdGgtMTApL2Eud2lkdGgvZSwoZC5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwKS9hLmhlaWdodC9lKSkvMjApO214VXRpbHMuaGFzU2Nyb2xsYmFycyhkLmNvbnRhaW5lcikmJihhPWQuZ2V0UGFnZVBhZGRpbmcoKSxkLmNvbnRhaW5lci5zY3JvbGxUb3A9YS55KmQudmlldy5zY2FsZS0xLGQuY29udGFpbmVyLnNjcm9sbExlZnQ9Ck1hdGgubWluKGEueCpkLnZpZXcuc2NhbGUsKGQuY29udGFpbmVyLnNjcm9sbFdpZHRoLWQuY29udGFpbmVyLmNsaWVudFdpZHRoKS8yKS0xKX0pLG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK0oiKTt0aGlzLmFkZEFjdGlvbigiZml0VHdvUGFnZXMiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5wYWdlVmlzaWJsZXx8dGhpcy5nZXQoInBhZ2VWaWV3IikuZnVuY3QoKTt2YXIgYT1kLnBhZ2VGb3JtYXQsZT1kLnBhZ2VTY2FsZTtkLnpvb21UbyhNYXRoLmZsb29yKDIwKk1hdGgubWluKChkLmNvbnRhaW5lci5jbGllbnRXaWR0aC0xMCkvKDIqYS53aWR0aCkvZSwoZC5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwKS9hLmhlaWdodC9lKSkvMjApO214VXRpbHMuaGFzU2Nyb2xsYmFycyhkLmNvbnRhaW5lcikmJihhPWQuZ2V0UGFnZVBhZGRpbmcoKSxkLmNvbnRhaW5lci5zY3JvbGxUb3A9TWF0aC5taW4oYS55LChkLmNvbnRhaW5lci5zY3JvbGxIZWlnaHQtZC5jb250YWluZXIuY2xpZW50SGVpZ2h0KS8KMiksZC5jb250YWluZXIuc2Nyb2xsTGVmdD1NYXRoLm1pbihhLngsKGQuY29udGFpbmVyLnNjcm9sbFdpZHRoLWQuY29udGFpbmVyLmNsaWVudFdpZHRoKS8yKSl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtKIik7dGhpcy5hZGRBY3Rpb24oImZpdFBhZ2VXaWR0aCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtkLnBhZ2VWaXNpYmxlfHx0aGlzLmdldCgicGFnZVZpZXciKS5mdW5jdCgpO2Quem9vbVRvKE1hdGguZmxvb3IoMjAqKGQuY29udGFpbmVyLmNsaWVudFdpZHRoLTEwKS9kLnBhZ2VGb3JtYXQud2lkdGgvZC5wYWdlU2NhbGUpLzIwKTtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoZC5jb250YWluZXIpKXt2YXIgYT1kLmdldFBhZ2VQYWRkaW5nKCk7ZC5jb250YWluZXIuc2Nyb2xsTGVmdD1NYXRoLm1pbihhLngqZC52aWV3LnNjYWxlLChkLmNvbnRhaW5lci5zY3JvbGxXaWR0aC1kLmNvbnRhaW5lci5jbGllbnRXaWR0aCkvMil9fSkpO3RoaXMucHV0KCJjdXN0b21ab29tIiwKbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImN1c3RvbSIpKyIuLi4iLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMuZWRpdG9yVWkscGFyc2VJbnQoMTAwKmQuZ2V0VmlldygpLmdldFNjYWxlKCkpLG14UmVzb3VyY2VzLmdldCgiYXBwbHkiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPXBhcnNlSW50KGEpOyFpc05hTihhKSYmMDxhJiZkLnpvb21UbyhhLzEwMCl9KSxteFJlc291cmNlcy5nZXQoInpvb20iKSsiICglKSIpO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzMDAsODAsITAsITApO2EuaW5pdCgpfSksbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrMCIpKTt0aGlzLmFkZEFjdGlvbigicGFnZVNjYWxlLi4uIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBhPW5ldyBGaWxlbmFtZURpYWxvZyh0aGlzLmVkaXRvclVpLHBhcnNlSW50KDEwMCpkLnBhZ2VTY2FsZSksCm14UmVzb3VyY2VzLmdldCgiYXBwbHkiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthPXBhcnNlSW50KGEpOyFpc05hTihhKSYmMDxhJiYoYT1uZXcgQ2hhbmdlUGFnZVNldHVwKGMsbnVsbCxudWxsLG51bGwsYS8xMDApLGEuaWdub3JlQ29sb3I9ITAsYS5pZ25vcmVJbWFnZT0hMCxkLm1vZGVsLmV4ZWN1dGUoYSkpfSksbXhSZXNvdXJjZXMuZ2V0KCJwYWdlU2NhbGUiKSsiICglKSIpO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzMDAsODAsITAsITApO2EuaW5pdCgpfSkpO3ZhciBtPW51bGwsbT10aGlzLmFkZEFjdGlvbigiZ3JpZCIsZnVuY3Rpb24oKXtkLnNldEdyaWRFbmFibGVkKCFkLmlzR3JpZEVuYWJsZWQoKSk7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImdyaWRFbmFibGVkQ2hhbmdlZCIpKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRyIpO20uc2V0VG9nZ2xlQWN0aW9uKCEwKTttLnNldFNlbGVjdGVkQ2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZC5pc0dyaWRFbmFibGVkKCl9KTsKbS5zZXRFbmFibGVkKCExKTttPXRoaXMuYWRkQWN0aW9uKCJndWlkZXMiLGZ1bmN0aW9uKCl7ZC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD0hZC5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZDtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZ3VpZGVzRW5hYmxlZENoYW5nZWQiKSl9KTttLnNldFRvZ2dsZUFjdGlvbighMCk7bS5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWR9KTttLnNldEVuYWJsZWQoITEpO209dGhpcy5hZGRBY3Rpb24oInRvb2x0aXBzIixmdW5jdGlvbigpe2QudG9vbHRpcEhhbmRsZXIuc2V0RW5hYmxlZCghZC50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKSl9KTttLnNldFRvZ2dsZUFjdGlvbighMCk7bS5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQudG9vbHRpcEhhbmRsZXIuaXNFbmFibGVkKCl9KTttPXRoaXMuYWRkQWN0aW9uKCJjb2xsYXBzZUV4cGFuZCIsCmZ1bmN0aW9uKCl7dmFyIGE9bmV3IENoYW5nZVBhZ2VTZXR1cChjKTthLmlnbm9yZUNvbG9yPSEwO2EuaWdub3JlSW1hZ2U9ITA7YS5mb2xkaW5nRW5hYmxlZD0hZC5mb2xkaW5nRW5hYmxlZDtkLm1vZGVsLmV4ZWN1dGUoYSl9KTttLnNldFRvZ2dsZUFjdGlvbighMCk7bS5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuZm9sZGluZ0VuYWJsZWR9KTttLmlzRW5hYmxlZD1rO209dGhpcy5hZGRBY3Rpb24oInNjcm9sbGJhcnMiLGZ1bmN0aW9uKCl7Yy5zZXRTY3JvbGxiYXJzKCFjLmhhc1Njcm9sbGJhcnMoKSl9KTttLnNldFRvZ2dsZUFjdGlvbighMCk7bS5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuc2Nyb2xsYmFyc30pO209dGhpcy5hZGRBY3Rpb24oInBhZ2VWaWV3IixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Muc2V0UGFnZVZpc2libGUoIWQucGFnZVZpc2libGUpfSkpO20uc2V0VG9nZ2xlQWN0aW9uKCEwKTttLnNldFNlbGVjdGVkQ2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZC5wYWdlVmlzaWJsZX0pOwptPXRoaXMuYWRkQWN0aW9uKCJjb25uZWN0aW9uQXJyb3dzIixmdW5jdGlvbigpe2QuY29ubmVjdGlvbkFycm93c0VuYWJsZWQ9IWQuY29ubmVjdGlvbkFycm93c0VuYWJsZWQ7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNvbm5lY3Rpb25BcnJvd3NDaGFuZ2VkIikpfSxudWxsLG51bGwsIkFsdCtTaGlmdCtBIik7bS5zZXRUb2dnbGVBY3Rpb24oITApO20uc2V0U2VsZWN0ZWRDYWxsYmFjayhmdW5jdGlvbigpe3JldHVybiBkLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkfSk7bT10aGlzLmFkZEFjdGlvbigiY29ubmVjdGlvblBvaW50cyIsZnVuY3Rpb24oKXtkLnNldENvbm5lY3RhYmxlKCFkLmNvbm5lY3Rpb25IYW5kbGVyLmlzRW5hYmxlZCgpKTtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY29ubmVjdGlvblBvaW50c0NoYW5nZWQiKSl9LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1AiKTttLnNldFRvZ2dsZUFjdGlvbighMCk7bS5zZXRTZWxlY3RlZENhbGxiYWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGQuY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCl9KTsKbT10aGlzLmFkZEFjdGlvbigiY29weUNvbm5lY3QiLGZ1bmN0aW9uKCl7ZC5jb25uZWN0aW9uSGFuZGxlci5zZXRDcmVhdGVUYXJnZXQoIWQuY29ubmVjdGlvbkhhbmRsZXIuaXNDcmVhdGVUYXJnZXQoKSk7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNvcHlDb25uZWN0Q2hhbmdlZCIpKX0pO20uc2V0VG9nZ2xlQWN0aW9uKCEwKTttLnNldFNlbGVjdGVkQ2FsbGJhY2soZnVuY3Rpb24oKXtyZXR1cm4gZC5jb25uZWN0aW9uSGFuZGxlci5pc0NyZWF0ZVRhcmdldCgpfSk7bS5pc0VuYWJsZWQ9azttPXRoaXMuYWRkQWN0aW9uKCJhdXRvc2F2ZSIsZnVuY3Rpb24oKXtjLmVkaXRvci5zZXRBdXRvc2F2ZSghYy5lZGl0b3IuYXV0b3NhdmUpfSk7bS5zZXRUb2dnbGVBY3Rpb24oITApO20uc2V0U2VsZWN0ZWRDYWxsYmFjayhmdW5jdGlvbigpe3JldHVybiBjLmVkaXRvci5hdXRvc2F2ZX0pO20uaXNFbmFibGVkPWs7bS52aXNpYmxlPSExO3RoaXMuYWRkQWN0aW9uKCJoZWxwIixmdW5jdGlvbigpe3ZhciBhPQoiIjtteFJlc291cmNlcy5pc0xhbmd1YWdlU3VwcG9ydGVkKG14Q2xpZW50Lmxhbmd1YWdlKSYmKGE9Il8iK214Q2xpZW50Lmxhbmd1YWdlKTtkLm9wZW5MaW5rKFJFU09VUkNFU19QQVRIKyIvaGVscCIrYSsiLmh0bWwiKX0pO3ZhciBxPSExO3RoaXMucHV0KCJhYm91dCIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImFib3V0IikrIiBHcmFwaCBFZGl0b3IuLi4iLGZ1bmN0aW9uKCl7cXx8KGMuc2hvd0RpYWxvZygobmV3IEFib3V0RGlhbG9nKGMpKS5jb250YWluZXIsMzIwLDI4MCwhMCwhMCxmdW5jdGlvbigpe3E9ITF9KSxxPSEwKX0pKTttPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsZSxjLGYpe3JldHVybiB0aGlzLmFkZEFjdGlvbihhLGZ1bmN0aW9uKCl7aWYobnVsbCE9YyYmZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSljKCk7ZWxzZXtkLnN0b3BFZGl0aW5nKCExKTtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpOwpkLnRvZ2dsZUNlbGxTdHlsZUZsYWdzKG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRTVFlMRSxlLGEpOyhlJm14Q29uc3RhbnRzLkZPTlRfQk9MRCk9PW14Q29uc3RhbnRzLkZPTlRfQk9MRD9kLnVwZGF0ZUxhYmVsRWxlbWVudHMoZC5nZXRTZWxlY3Rpb25DZWxscygpLGZ1bmN0aW9uKGEpe2Euc3R5bGUuZm9udFdlaWdodD1udWxsOyJCIj09YS5ub2RlTmFtZSYmZC5yZXBsYWNlRWxlbWVudChhKX0pOihlJm14Q29uc3RhbnRzLkZPTlRfSVRBTElDKT09bXhDb25zdGFudHMuRk9OVF9JVEFMSUM/ZC51cGRhdGVMYWJlbEVsZW1lbnRzKGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxmdW5jdGlvbihhKXthLnN0eWxlLmZvbnRTdHlsZT1udWxsOyJJIj09YS5ub2RlTmFtZSYmZC5yZXBsYWNlRWxlbWVudChhKX0pOihlJm14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FKT09bXhDb25zdGFudHMuRk9OVF9VTkRFUkxJTkUmJmQudXBkYXRlTGFiZWxFbGVtZW50cyhkLmdldFNlbGVjdGlvbkNlbGxzKCksZnVuY3Rpb24oYSl7YS5zdHlsZS50ZXh0RGVjb3JhdGlvbj0KbnVsbDsiVSI9PWEubm9kZU5hbWUmJmQucmVwbGFjZUVsZW1lbnQoYSl9KTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKykwPT1kLm1vZGVsLmdldENoaWxkQ291bnQoYVtiXSkmJmQuYXV0b1NpemVDZWxsKGFbYl0sITEpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19LG51bGwsbnVsbCxmKX0pO20oImJvbGQiLG14Q29uc3RhbnRzLkZPTlRfQk9MRCxmdW5jdGlvbigpe2RvY3VtZW50LmV4ZWNDb21tYW5kKCJib2xkIiwhMSxudWxsKX0sRWRpdG9yLmN0cmxLZXkrIitCIik7bSgiaXRhbGljIixteENvbnN0YW50cy5GT05UX0lUQUxJQyxmdW5jdGlvbigpe2RvY3VtZW50LmV4ZWNDb21tYW5kKCJpdGFsaWMiLCExLG51bGwpfSxFZGl0b3IuY3RybEtleSsiK0kiKTttKCJ1bmRlcmxpbmUiLG14Q29uc3RhbnRzLkZPTlRfVU5ERVJMSU5FLGZ1bmN0aW9uKCl7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoInVuZGVybGluZSIsITEsbnVsbCl9LEVkaXRvci5jdHJsS2V5KyIrVSIpOwp0aGlzLmFkZEFjdGlvbigiZm9udENvbG9yLi4uIixmdW5jdGlvbigpe2MubWVudXMucGlja0NvbG9yKG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUiwiZm9yZWNvbG9yIiwiMDAwMDAwIil9KTt0aGlzLmFkZEFjdGlvbigic3Ryb2tlQ29sb3IuLi4iLGZ1bmN0aW9uKCl7Yy5tZW51cy5waWNrQ29sb3IobXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IpfSk7dGhpcy5hZGRBY3Rpb24oImZpbGxDb2xvci4uLiIsZnVuY3Rpb24oKXtjLm1lbnVzLnBpY2tDb2xvcihteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IpfSk7dGhpcy5hZGRBY3Rpb24oImdyYWRpZW50Q29sb3IuLi4iLGZ1bmN0aW9uKCl7Yy5tZW51cy5waWNrQ29sb3IobXhDb25zdGFudHMuU1RZTEVfR1JBRElFTlRDT0xPUil9KTt0aGlzLmFkZEFjdGlvbigiYmFja2dyb3VuZENvbG9yLi4uIixmdW5jdGlvbigpe2MubWVudXMucGlja0NvbG9yKG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JBQ0tHUk9VTkRDT0xPUiwiYmFja2NvbG9yIil9KTsKdGhpcy5hZGRBY3Rpb24oImJvcmRlckNvbG9yLi4uIixmdW5jdGlvbigpe2MubWVudXMucGlja0NvbG9yKG14Q29uc3RhbnRzLlNUWUxFX0xBQkVMX0JPUkRFUkNPTE9SKX0pO3RoaXMuYWRkQWN0aW9uKCJ2ZXJ0aWNhbCIsZnVuY3Rpb24oKXtjLm1lbnVzLnRvZ2dsZVN0eWxlKG14Q29uc3RhbnRzLlNUWUxFX0hPUklaT05UQUwsITApfSk7dGhpcy5hZGRBY3Rpb24oInNoYWRvdyIsZnVuY3Rpb24oKXtjLm1lbnVzLnRvZ2dsZVN0eWxlKG14Q29uc3RhbnRzLlNUWUxFX1NIQURPVyl9KTt0aGlzLmFkZEFjdGlvbigic29saWQiLGZ1bmN0aW9uKCl7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Quc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsbnVsbCksZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0RBU0hfUEFUVEVSTixudWxsKSxjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX0RBU0hFRCwKbXhDb25zdGFudHMuU1RZTEVfREFTSF9QQVRURVJOXSwidmFsdWVzIixbbnVsbCxudWxsXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJkYXNoZWQiLGZ1bmN0aW9uKCl7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Quc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsIjEiKSxkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfREFTSF9QQVRURVJOLG51bGwpLGMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzdHlsZUNoYW5nZWQiLCJrZXlzIixbbXhDb25zdGFudHMuU1RZTEVfREFTSEVELG14Q29uc3RhbnRzLlNUWUxFX0RBU0hfUEFUVEVSTl0sInZhbHVlcyIsWyIxIixudWxsXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJkb3R0ZWQiLApmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfREFTSEVELCIxIiksZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0RBU0hfUEFUVEVSTiwiMSA0IiksYy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsImtleXMiLFtteENvbnN0YW50cy5TVFlMRV9EQVNIRUQsbXhDb25zdGFudHMuU1RZTEVfREFTSF9QQVRURVJOXSwidmFsdWVzIixbIjEiLCIxIDQiXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJzaGFycCIsZnVuY3Rpb24oKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7ZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsIjAiKSxkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfQ1VSVkVELCIwIiksYy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsCiJrZXlzIixbbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCxteENvbnN0YW50cy5TVFlMRV9DVVJWRURdLCJ2YWx1ZXMiLFsiMCIsIjAiXSwiY2VsbHMiLGQuZ2V0U2VsZWN0aW9uQ2VsbHMoKSkpfWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0pO3RoaXMuYWRkQWN0aW9uKCJyb3VuZGVkIixmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwiMSIpLGQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9DVVJWRUQsIjAiKSxjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSwidmFsdWVzIixbIjEiLCIwIl0sImNlbGxzIixkLmdldFNlbGVjdGlvbkNlbGxzKCkpKX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19KTt0aGlzLmFkZEFjdGlvbigidG9nZ2xlUm91bmRlZCIsCmZ1bmN0aW9uKCl7aWYoIWQuaXNTZWxlY3Rpb25FbXB0eSgpJiZkLmlzRW5hYmxlZCgpKXtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpLGU9ZC5nZXRDdXJyZW50Q2VsbFN0eWxlKGFbMF0pLGY9IjEiPT1teFV0aWxzLmdldFZhbHVlKGUsbXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwiMCIpPyIwIjoiMSI7ZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsZik7ZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX0NVUlZFRCxudWxsKTtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSwidmFsdWVzIixbZiwiMCJdLCJjZWxscyIsZC5nZXRTZWxlY3Rpb25DZWxscygpKSl9ZmluYWxseXtkLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fX0pO3RoaXMuYWRkQWN0aW9uKCJjdXJ2ZWQiLApmdW5jdGlvbigpe2QuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtkLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfUk9VTkRFRCwiMCIpLGQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9DVVJWRUQsIjEiKSxjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsW214Q29uc3RhbnRzLlNUWUxFX1JPVU5ERUQsbXhDb25zdGFudHMuU1RZTEVfQ1VSVkVEXSwidmFsdWVzIixbIjAiLCIxIl0sImNlbGxzIixkLmdldFNlbGVjdGlvbkNlbGxzKCkpKX1maW5hbGx5e2QuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19KTt0aGlzLmFkZEFjdGlvbigiY29sbGFwc2libGUiLGZ1bmN0aW9uKCl7dmFyIGE9ZC52aWV3LmdldFN0YXRlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSxlPSIxIjtudWxsIT1hJiZudWxsIT1kLmdldEZvbGRpbmdJbWFnZShhKSYmKGU9IjAiKTtkLnNldENlbGxTdHlsZXMoImNvbGxhcHNpYmxlIixlKTtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwKImtleXMiLFsiY29sbGFwc2libGUiXSwidmFsdWVzIixbZV0sImNlbGxzIixkLmdldFNlbGVjdGlvbkNlbGxzKCkpKX0pO3RoaXMuYWRkQWN0aW9uKCJlZGl0U3R5bGUuLi4iLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBlPWQuZ2V0TW9kZWwoKSxlPW5ldyBUZXh0YXJlYURpYWxvZyh0aGlzLmVkaXRvclVpLG14UmVzb3VyY2VzLmdldCgiZWRpdFN0eWxlIikrIjoiLGUuZ2V0U3R5bGUoYVswXSl8fCIiLGZ1bmN0aW9uKGIpe251bGwhPWImJmQuc2V0Q2VsbFN0eWxlKG14VXRpbHMudHJpbShiKSxhKX0sbnVsbCxudWxsLDQwMCwyMjApO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhlLmNvbnRhaW5lciw0MjAsMzAwLCEwLCEwKTtlLmluaXQoKX19KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitFIik7dGhpcy5hZGRBY3Rpb24oInNldEFzRGVmYXVsdFN0eWxlIixmdW5jdGlvbigpe2QuaXNFbmFibGVkKCkmJgohZC5pc1NlbGVjdGlvbkVtcHR5KCkmJmMuc2V0RGVmYXVsdFN0eWxlKGQuZ2V0U2VsZWN0aW9uQ2VsbCgpKX0sbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrRCIpO3RoaXMuYWRkQWN0aW9uKCJjbGVhckRlZmF1bHRTdHlsZSIsZnVuY3Rpb24oKXtkLmlzRW5hYmxlZCgpJiZjLmNsZWFyRGVmYXVsdFN0eWxlKCl9LG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K1IiKTt0aGlzLmFkZEFjdGlvbigiYWRkV2F5cG9pbnQiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxsKCk7aWYobnVsbCE9YSYmZC5nZXRNb2RlbCgpLmlzRWRnZShhKSl7dmFyIGU9Zi5ncmFwaC5zZWxlY3Rpb25DZWxsc0hhbmRsZXIuZ2V0SGFuZGxlcihhKTtpZihlIGluc3RhbmNlb2YgbXhFZGdlSGFuZGxlcil7Zm9yKHZhciBjPWQudmlldy50cmFuc2xhdGUsbj1kLnZpZXcuc2NhbGUsbD1jLngsYz1jLnksYT1kLmdldE1vZGVsKCkuZ2V0UGFyZW50KGEpLHA9ZC5nZXRDZWxsR2VvbWV0cnkoYSk7ZC5nZXRNb2RlbCgpLmlzVmVydGV4KGEpJiYKbnVsbCE9cDspbCs9cC54LGMrPXAueSxhPWQuZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYSkscD1kLmdldENlbGxHZW9tZXRyeShhKTtsPU1hdGgucm91bmQoZC5zbmFwKGQucG9wdXBNZW51SGFuZGxlci50cmlnZ2VyWC9uLWwpKTtuPU1hdGgucm91bmQoZC5zbmFwKGQucG9wdXBNZW51SGFuZGxlci50cmlnZ2VyWS9uLWMpKTtlLmFkZFBvaW50QXQoZS5zdGF0ZSxsLG4pfX19KTt0aGlzLmFkZEFjdGlvbigicmVtb3ZlV2F5cG9pbnQiLGZ1bmN0aW9uKCl7dmFyIGE9Yy5hY3Rpb25zLmdldCgicmVtb3ZlV2F5cG9pbnQiKTtudWxsIT1hLmhhbmRsZXImJmEuaGFuZGxlci5yZW1vdmVQb2ludChhLmhhbmRsZXIuc3RhdGUsYS5pbmRleCl9KTt0aGlzLmFkZEFjdGlvbigiY2xlYXJXYXlwb2ludHMiLGZ1bmN0aW9uKCl7dmFyIGE9ZC5nZXRTZWxlY3Rpb25DZWxscygpO2lmKG51bGwhPWEpe2E9ZC5hZGRBbGxFZGdlcyhhKTtkLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBlPQowO2U8YS5sZW5ndGg7ZSsrKXt2YXIgYz1hW2VdO2lmKGQuZ2V0TW9kZWwoKS5pc0VkZ2UoYykpe3ZhciBmPWQuZ2V0Q2VsbEdlb21ldHJ5KGMpO251bGwhPWYmJihmPWYuY2xvbmUoKSxmLnBvaW50cz1udWxsLGQuZ2V0TW9kZWwoKS5zZXRHZW9tZXRyeShjLGYpKX19fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K0MiKTttPXRoaXMuYWRkQWN0aW9uKCJzdWJzY3JpcHQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSYmZG9jdW1lbnQuZXhlY0NvbW1hbmQoInN1YnNjcmlwdCIsITEsbnVsbCl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIissIik7bT10aGlzLmFkZEFjdGlvbigic3VwZXJzY3JpcHQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSYmZG9jdW1lbnQuZXhlY0NvbW1hbmQoInN1cGVyc2NyaXB0IiwKITEsbnVsbCl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIisuIik7bT10aGlzLmFkZEFjdGlvbigiaW5kZW50IixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2QuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkmJmRvY3VtZW50LmV4ZWNDb21tYW5kKCJpbmRlbnQiLCExLG51bGwpfSksbnVsbCxudWxsLCJTaGlmdCtUYWIiKTt0aGlzLmFkZEFjdGlvbigiaW1hZ2UuLi4iLGZ1bmN0aW9uKCl7aWYoZC5pc0VuYWJsZWQoKSYmIWQuaXNDZWxsTG9ja2VkKGQuZ2V0RGVmYXVsdFBhcmVudCgpKSl7dmFyIGE9bXhSZXNvdXJjZXMuZ2V0KCJpbWFnZSIpKyIgKCIrbXhSZXNvdXJjZXMuZ2V0KCJ1cmwiKSsiKToiLGU9ZC5nZXRWaWV3KCkuZ2V0U3RhdGUoZC5nZXRTZWxlY3Rpb25DZWxsKCkpLGY9IiI7bnVsbCE9ZSYmKGY9ZS5zdHlsZVtteENvbnN0YW50cy5TVFlMRV9JTUFHRV18fGYpO3ZhciBuPWQuY2VsbEVkaXRvci5zYXZlU2VsZWN0aW9uKCk7Yy5zaG93SW1hZ2VEaWFsb2coYSwKZixmdW5jdGlvbihhLGIsZSl7aWYoZC5jZWxsRWRpdG9yLmlzQ29udGVudEVkaXRpbmcoKSlkLmNlbGxFZGl0b3IucmVzdG9yZVNlbGVjdGlvbihuKSxkLmluc2VydEltYWdlKGEsYixlKTtlbHNle3ZhciBjPWQuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtpZihudWxsIT1hJiYoMDxhLmxlbmd0aHx8MDxjLmxlbmd0aCkpe3ZhciBmPW51bGw7ZC5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKDA9PWMubGVuZ3RoKXt2YXIgZz1kLmdldEZyZWVJbnNlcnRQb2ludCgpLGY9Yz1bZC5pbnNlcnRWZXJ0ZXgoZC5nZXREZWZhdWx0UGFyZW50KCksbnVsbCwiIixnLngsZy55LGIsZSwic2hhcGU9aW1hZ2U7aW1hZ2VBc3BlY3Q9MDthc3BlY3Q9Zml4ZWQ7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTt2ZXJ0aWNhbEFsaWduPXRvcDsiKV07ZC5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImNlbGxzSW5zZXJ0ZWQiLCJjZWxscyIsZikpfWQuc2V0Q2VsbFN0eWxlcyhteENvbnN0YW50cy5TVFlMRV9JTUFHRSwKMDxhLmxlbmd0aD9hOm51bGwsYyk7dmFyIGw9ZC5nZXRDdXJyZW50Q2VsbFN0eWxlKGNbMF0pOyJpbWFnZSIhPWxbbXhDb25zdGFudHMuU1RZTEVfU0hBUEVdJiYibGFiZWwiIT1sW214Q29uc3RhbnRzLlNUWUxFX1NIQVBFXT9kLnNldENlbGxTdHlsZXMobXhDb25zdGFudHMuU1RZTEVfU0hBUEUsImltYWdlIixjKTowPT1hLmxlbmd0aCYmZC5zZXRDZWxsU3R5bGVzKG14Q29uc3RhbnRzLlNUWUxFX1NIQVBFLG51bGwsYyk7aWYoMT09ZC5nZXRTZWxlY3Rpb25Db3VudCgpJiZudWxsIT1iJiZudWxsIT1lKXt2YXIgcD1jWzBdLGs9ZC5nZXRNb2RlbCgpLmdldEdlb21ldHJ5KHApO251bGwhPWsmJihrPWsuY2xvbmUoKSxrLndpZHRoPWIsay5oZWlnaHQ9ZSxkLmdldE1vZGVsKCkuc2V0R2VvbWV0cnkocCxrKSl9fWZpbmFsbHl7ZC5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfW51bGwhPWYmJihkLnNldFNlbGVjdGlvbkNlbGxzKGYpLGQuc2Nyb2xsQ2VsbFRvVmlzaWJsZShmWzBdKSl9fX0sCmQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCksIWQuY2VsbEVkaXRvci5pc0NvbnRlbnRFZGl0aW5nKCkpfX0pLmlzRW5hYmxlZD1rO209dGhpcy5hZGRBY3Rpb24oImxheWVycyIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsPT10aGlzLmxheWVyc1dpbmRvdz8odGhpcy5sYXllcnNXaW5kb3c9bmV3IExheWVyc1dpbmRvdyhjLGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgtMjgwLDEyMCwyMjAsMTk2KSx0aGlzLmxheWVyc1dpbmRvdy53aW5kb3cuYWRkTGlzdGVuZXIoInNob3ciLGZ1bmN0aW9uKCl7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImxheWVycyIpKX0pLHRoaXMubGF5ZXJzV2luZG93LndpbmRvdy5hZGRMaXN0ZW5lcigiaGlkZSIsZnVuY3Rpb24oKXtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgibGF5ZXJzIikpfSksdGhpcy5sYXllcnNXaW5kb3cud2luZG93LnNldFZpc2libGUoITApLGMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJsYXllcnMiKSksCnRoaXMubGF5ZXJzV2luZG93LmluaXQoKSk6dGhpcy5sYXllcnNXaW5kb3cud2luZG93LnNldFZpc2libGUoIXRoaXMubGF5ZXJzV2luZG93LndpbmRvdy5pc1Zpc2libGUoKSl9KSxudWxsLG51bGwsRWRpdG9yLmN0cmxLZXkrIitTaGlmdCtMIik7bS5zZXRUb2dnbGVBY3Rpb24oITApO20uc2V0U2VsZWN0ZWRDYWxsYmFjayhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmxheWVyc1dpbmRvdyYmdGhpcy5sYXllcnNXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpfSkpO209dGhpcy5hZGRBY3Rpb24oImZvcm1hdFBhbmVsIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2MudG9nZ2xlRm9ybWF0UGFuZWwoKX0pLG51bGwsbnVsbCxFZGl0b3IuY3RybEtleSsiK1NoaWZ0K1AiKTttLnNldFRvZ2dsZUFjdGlvbighMCk7bS5zZXRTZWxlY3RlZENhbGxiYWNrKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIDA8Yy5mb3JtYXRXaWR0aH0pKTsKbT10aGlzLmFkZEFjdGlvbigib3V0bGluZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsPT10aGlzLm91dGxpbmVXaW5kb3c/KHRoaXMub3V0bGluZVdpbmRvdz1uZXcgT3V0bGluZVdpbmRvdyhjLGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgtMjYwLDEwMCwxODAsMTgwKSx0aGlzLm91dGxpbmVXaW5kb3cud2luZG93LmFkZExpc3RlbmVyKCJzaG93IixmdW5jdGlvbigpe2MuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJvdXRsaW5lIikpfSksdGhpcy5vdXRsaW5lV2luZG93LndpbmRvdy5hZGRMaXN0ZW5lcigiaGlkZSIsZnVuY3Rpb24oKXtjLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgib3V0bGluZSIpKX0pLHRoaXMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMCksYy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoIm91dGxpbmUiKSkpOnRoaXMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghdGhpcy5vdXRsaW5lV2luZG93LndpbmRvdy5pc1Zpc2libGUoKSl9KSwKbnVsbCxudWxsLEVkaXRvci5jdHJsS2V5KyIrU2hpZnQrTyIpO20uc2V0VG9nZ2xlQWN0aW9uKCEwKTttLnNldFNlbGVjdGVkQ2FsbGJhY2sobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5vdXRsaW5lV2luZG93JiZ0aGlzLm91dGxpbmVXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpfSkpfTtBY3Rpb25zLnByb3RvdHlwZS5hZGRBY3Rpb249ZnVuY3Rpb24oYSxjLGYsZCxrKXt2YXIgbTsiLi4uIj09YS5zdWJzdHJpbmcoYS5sZW5ndGgtMyk/KGE9YS5zdWJzdHJpbmcoMCxhLmxlbmd0aC0zKSxtPW14UmVzb3VyY2VzLmdldChhKSsiLi4uIik6bT1teFJlc291cmNlcy5nZXQoYSk7cmV0dXJuIHRoaXMucHV0KGEsbmV3IEFjdGlvbihtLGMsZixkLGspKX07QWN0aW9ucy5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIHRoaXMuYWN0aW9uc1thXT1jfTtBY3Rpb25zLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWN0aW9uc1thXX07CmZ1bmN0aW9uIEFjdGlvbihhLGMsZixkLGspe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTt0aGlzLmxhYmVsPWE7dGhpcy5mdW5jdD10aGlzLmNyZWF0ZUZ1bmN0aW9uKGMpO3RoaXMuZW5hYmxlZD1udWxsIT1mP2Y6ITA7dGhpcy5pY29uQ2xzPWQ7dGhpcy5zaG9ydGN1dD1rO3RoaXMudmlzaWJsZT0hMH1teFV0aWxzLmV4dGVuZChBY3Rpb24sbXhFdmVudFNvdXJjZSk7QWN0aW9uLnByb3RvdHlwZS5jcmVhdGVGdW5jdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gYX07QWN0aW9uLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuZW5hYmxlZCE9YSYmKHRoaXMuZW5hYmxlZD1hLHRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzdGF0ZUNoYW5nZWQiKSkpfTtBY3Rpb24ucHJvdG90eXBlLmlzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR9OwpBY3Rpb24ucHJvdG90eXBlLnNldFRvZ2dsZUFjdGlvbj1mdW5jdGlvbihhKXt0aGlzLnRvZ2dsZUFjdGlvbj1hfTtBY3Rpb24ucHJvdG90eXBlLnNldFNlbGVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RlZENhbGxiYWNrPWF9O0FjdGlvbi5wcm90b3R5cGUuaXNTZWxlY3RlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGVjdGVkQ2FsbGJhY2soKX07RHJhd2lvRmlsZT1mdW5jdGlvbihhLGMpe214RXZlbnRTb3VyY2UuY2FsbCh0aGlzKTt0aGlzLnVpPWE7dGhpcy5zaGFkb3dEYXRhPXRoaXMuZGF0YT1jfHwiIjt0aGlzLnNoYWRvd1BhZ2VzPW51bGw7dGhpcy5jcmVhdGVkPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuc3RhdHM9e29wZW5lZDowLG1lcmdlZDowLGZpbGVNZXJnZWQ6MCxmaWxlUmVsb2FkZWQ6MCxjb25mbGljdHM6MCx0aW1lb3V0czowLHNhdmVkOjAsY2xvc2VkOjAsZGVzdHJveWVkOjAsam9pbmVkOjAsY2hlY2tzdW1FcnJvcnM6MCxieXRlc1NlbnQ6MCxieXRlc1JlY2VpdmVkOjAsbXNnU2VudDowLG1zZ1JlY2VpdmVkOjAsY2FjaGVIaXRzOjAsY2FjaGVNaXNzOjAsY2FjaGVGYWlsOjB9fTtEcmF3aW9GaWxlLlNZTkM9dXJsUGFyYW1zLnN5bmN8fCJhdXRvIjtEcmF3aW9GaWxlLkxBU1RfV1JJVEVfV0lOUz0hMDtteFV0aWxzLmV4dGVuZChEcmF3aW9GaWxlLG14RXZlbnRTb3VyY2UpOwpEcmF3aW9GaWxlLnByb3RvdHlwZS5hbGxDaGFuZ2VzU2F2ZWRLZXk9ImFsbENoYW5nZXNTYXZlZCI7RHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmVEZWxheT0xNTAwO0RyYXdpb0ZpbGUucHJvdG90eXBlLm1heEF1dG9zYXZlRGVsYXk9M0U0O0RyYXdpb0ZpbGUucHJvdG90eXBlLmF1dG9zYXZlVGhyZWFkPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUubGFzdEF1dG9zYXZlPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUubGFzdFNhdmVkPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUubGFzdENoYW5nZWQ9bnVsbDtEcmF3aW9GaWxlLnByb3RvdHlwZS5vcGVuZWQ9bnVsbDtEcmF3aW9GaWxlLnByb3RvdHlwZS5tb2RpZmllZD0hMTtEcmF3aW9GaWxlLnByb3RvdHlwZS5kYXRhPW51bGw7RHJhd2lvRmlsZS5wcm90b3R5cGUuc2hhZG93RGF0YT1udWxsO0RyYXdpb0ZpbGUucHJvdG90eXBlLnNoYWRvd1BhZ2VzPW51bGw7CkRyYXdpb0ZpbGUucHJvdG90eXBlLmNoYW5nZUxpc3RlbmVyRW5hYmxlZD0hMDtEcmF3aW9GaWxlLnByb3RvdHlwZS5sYXN0QXV0b3NhdmVSZXZpc2lvbj1udWxsO0RyYXdpb0ZpbGUucHJvdG90eXBlLm1heEF1dG9zYXZlUmV2aXNpb25EZWxheT0zRTU7RHJhd2lvRmlsZS5wcm90b3R5cGUuaW5Db25mbGljdFN0YXRlPSExO0RyYXdpb0ZpbGUucHJvdG90eXBlLmludmFsaWRDaGVja3N1bT0hMTtEcmF3aW9GaWxlLnByb3RvdHlwZS5lcnJvclJlcG9ydHNFbmFibGVkPSExO0RyYXdpb0ZpbGUucHJvdG90eXBlLnJlcG9ydEVuYWJsZWQ9ITA7RHJhd2lvRmlsZS5wcm90b3R5cGUuYWdlU3RhcnQ9bnVsbDtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZGF0YT90aGlzLmRhdGEubGVuZ3RoOjB9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zeW5jaHJvbml6ZUZpbGU9ZnVuY3Rpb24oYSxjKXt0aGlzLnNhdmluZ0ZpbGU/bnVsbCE9YyYmYyh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImJ1c3kiKX0pOm51bGwhPXRoaXMuc3luYz90aGlzLnN5bmMuZmlsZUNoYW5nZWQoYSxjKTp0aGlzLnVwZGF0ZUZpbGUoYSxjKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnVwZGF0ZUZpbGU9ZnVuY3Rpb24oYSxjLGYsZCl7bnVsbCE9ZiYmZigpfHwodGhpcy51aS5nZXRDdXJyZW50RmlsZSgpIT10aGlzfHx0aGlzLmludmFsaWRDaGVja3N1bT9udWxsIT1jJiZjKCk6dGhpcy5nZXRMYXRlc3RWZXJzaW9uKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGspe3RyeXtudWxsIT1mJiZmKCl8fCh0aGlzLnVpLmdldEN1cnJlbnRGaWxlKCkhPXRoaXN8fHRoaXMuaW52YWxpZENoZWNrc3VtP251bGwhPWMmJmMoKTpudWxsIT1rP3RoaXMubWVyZ2VGaWxlKGssYSxjLGQpOnRoaXMucmVsb2FkRmlsZShhLGMpKX1jYXRjaChtKXtudWxsIT1jJiZjKG0pfX0pLGMpKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLm1lcmdlRmlsZT1mdW5jdGlvbihhLGMsZixkKXt2YXIgaz0hMDt0cnl7dGhpcy5zdGF0cy5maWxlTWVyZ2VkKys7dmFyIG09bnVsbCE9dGhpcy5zaGFkb3dQYWdlcz90aGlzLnNoYWRvd1BhZ2VzOnRoaXMudWkuZ2V0UGFnZXNGb3JOb2RlKG14VXRpbHMucGFyc2VYbWwodGhpcy5zaGFkb3dEYXRhKS5kb2N1bWVudEVsZW1lbnQpLHE9dGhpcy51aS5nZXRQYWdlc0Zvck5vZGUobXhVdGlscy5wYXJzZVhtbChhLmRhdGEpLmRvY3VtZW50RWxlbWVudCk7aWYobnVsbCE9cSYmMDxxLmxlbmd0aCl7dGhpcy5zaGFkb3dQYWdlcz1xO3RoaXMuYmFja3VwUGF0Y2g9dGhpcy5pc01vZGlmaWVkKCk/dGhpcy51aS5kaWZmUGFnZXMobSx0aGlzLnVpLnBhZ2VzKTpudWxsO3ZhciBiPVt0aGlzLnVpLmRpZmZQYWdlcyhudWxsIT1kP2Q6bSx0aGlzLnNoYWRvd1BhZ2VzKV07aWYoIXRoaXMuaWdub3JlUGF0Y2hlcyhiKSl7dmFyIGU9dGhpcy51aS5wYXRjaFBhZ2VzKG0sCmJbMF0pO2Q9e307dmFyIGc9dGhpcy51aS5nZXRIYXNoVmFsdWVGb3JQYWdlcyhlLGQpLG09e30sbj10aGlzLnVpLmdldEhhc2hWYWx1ZUZvclBhZ2VzKHRoaXMuc2hhZG93UGFnZXMsbSk7IjEiPT11cmxQYXJhbXMudGVzdCYmRWRpdG9yVWkuZGVidWcoIkZpbGUubWVyZ2VGaWxlIixbdGhpc10sImJhY2t1cCIsdGhpcy5iYWNrdXBQYXRjaCwicGF0Y2hlcyIsYiwiY2hlY2tzdW0iLG49PWcsZyk7aWYobnVsbCE9ZyYmZyE9bil7dmFyIGw9dGhpcy5jb21wcmVzc1JlcG9ydERhdGEodGhpcy5nZXRBbm9ueW1pemVkWG1sRm9yUGFnZXMocSkpLHA9dGhpcy5jb21wcmVzc1JlcG9ydERhdGEodGhpcy5nZXRBbm9ueW1pemVkWG1sRm9yUGFnZXMoZSkpLHY9dGhpcy51aS5oYXNoVmFsdWUoYS5nZXRDdXJyZW50RXRhZygpKSx0PXRoaXMudWkuaGFzaFZhbHVlKHRoaXMuZ2V0Q3VycmVudEV0YWcoKSk7dGhpcy5jaGVja3N1bUVycm9yKGYsYiwiU2hhZG93IERldGFpbHM6ICIrSlNPTi5zdHJpbmdpZnkoZCkrCiJcbkNoZWNrc3VtOiAiK2crIlxuQ3VycmVudDogIituKyJcbkN1cnJlbnQgRGV0YWlsczogIitKU09OLnN0cmluZ2lmeShtKSsiXG5Gcm9tOiAiK3YrIlxuVG86ICIrdCsiXG5cbkZpbGUgRGF0YTpcbiIrbCsiXG5QYXRjaGVkIFNoYWRvdzpcbiIrcCxudWxsLCJtZXJnZUZpbGUiKTtyZXR1cm59dGhpcy5wYXRjaChiLERyYXdpb0ZpbGUuTEFTVF9XUklURV9XSU5TP3RoaXMuYmFja3VwUGF0Y2g6bnVsbCl9fWVsc2UgdGhyb3cgaz0hMSxFcnJvcihteFJlc291cmNlcy5nZXQoIm5vdEFEaWFncmFtRmlsZSIpKTt0aGlzLmluQ29uZmxpY3RTdGF0ZT10aGlzLmludmFsaWRDaGVja3N1bT0hMTt0aGlzLnNldERlc2NyaXB0b3IoYS5nZXREZXNjcmlwdG9yKCkpO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTt0aGlzLmJhY2t1cFBhdGNoPW51bGw7bnVsbCE9YyYmYygpfWNhdGNoKEMpe3RoaXMuaW52YWxpZENoZWNrc3VtPXRoaXMuaW5Db25mbGljdFN0YXRlPSEwO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTsKbnVsbCE9ZiYmZihDKTt0cnl7aWYoaylpZih0aGlzLmVycm9yUmVwb3J0c0VuYWJsZWQpdGhpcy5zZW5kRXJyb3JSZXBvcnQoIkVycm9yIGluIG1lcmdlRmlsZSIsbnVsbCxDKTtlbHNle3ZhciB5PXRoaXMuZ2V0Q3VycmVudFVzZXIoKSx4PW51bGwhPXk/eS5pZDoidW5rbm93biI7RWRpdG9yVWkubG9nRXJyb3IoIkVycm9yIGluIG1lcmdlRmlsZSIsbnVsbCx0aGlzLmdldE1vZGUoKSsiLiIrdGhpcy5nZXRJZCgpLHgsQyl9fWNhdGNoKEIpe319fTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0QW5vbnltaXplZFhtbEZvclBhZ2VzPWZ1bmN0aW9uKGEpe3ZhciBjPW5ldyBteENvZGVjKG14VXRpbHMuY3JlYXRlWG1sRG9jdW1lbnQoKSksZj1jLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm14ZmlsZSIpO2lmKG51bGwhPWEpZm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBrPWMuZW5jb2RlKG5ldyBteEdyYXBoTW9kZWwoYVtkXS5yb290KSk7IjEiIT11cmxQYXJhbXMuZGV2JiYoaz10aGlzLnVpLmFub255bWl6ZU5vZGUoaywhMCkpO2suc2V0QXR0cmlidXRlKCJpZCIsYVtkXS5nZXRJZCgpKTthW2RdLnZpZXdTdGF0ZSYmdGhpcy51aS5lZGl0b3IuZ3JhcGguc2F2ZVZpZXdTdGF0ZShhW2RdLnZpZXdTdGF0ZSxrLCEwKTtmLmFwcGVuZENoaWxkKGspfXJldHVybiBteFV0aWxzLmdldFByZXR0eVhtbChmKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmNvbXByZXNzUmVwb3J0RGF0YT1mdW5jdGlvbihhLGMsZil7Yz1udWxsIT1jP2M6MUU0O251bGwhPWYmJm51bGwhPWEmJmEubGVuZ3RoPmY/YT1hLnN1YnN0cmluZygwLGYpKyJbLi4uXSI6bnVsbCE9YSYmYS5sZW5ndGg+YyYmKGE9R3JhcGguY29tcHJlc3MoYSkrIlxuIik7cmV0dXJuIGF9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5jaGVja3N1bUVycm9yPWZ1bmN0aW9uKGEsYyxmLGQsayl7dGhpcy5zdGF0cy5jaGVja3N1bUVycm9ycysrO3RoaXMuaW52YWxpZENoZWNrc3VtPXRoaXMuaW5Db25mbGljdFN0YXRlPSEwO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTtudWxsIT10aGlzLnN5bmMmJnRoaXMuc3luYy51cGRhdGVPbmxpbmVTdGF0ZSgpO251bGwhPWEmJmEoKTt0cnl7aWYodGhpcy5lcnJvclJlcG9ydHNFbmFibGVkKXtpZihudWxsIT1jKWZvcihhPTA7YTxjLmxlbmd0aDthKyspdGhpcy51aS5hbm9ueW1pemVQYXRjaChjW2FdKTt2YXIgbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNvbXByZXNzUmVwb3J0RGF0YShKU09OLnN0cmluZ2lmeShjLG51bGwsMikpO2E9bnVsbCE9YT90aGlzLmNvbXByZXNzUmVwb3J0RGF0YSh0aGlzLmdldEFub255bWl6ZWRYbWxGb3JQYWdlcyh0aGlzLnVpLmdldFBhZ2VzRm9yTm9kZShteFV0aWxzLnBhcnNlWG1sKGEuZGF0YSkuZG9jdW1lbnRFbGVtZW50KSksCjI1RTMpOiJuL2EiO3RoaXMuc2VuZEVycm9yUmVwb3J0KCJDaGVja3N1bSBFcnJvciBpbiAiK2srIiAiK3RoaXMuZ2V0SGFzaCgpLChudWxsIT1mP2Y6IiIpKyJcblxuUGF0Y2hlczpcbiIrYisobnVsbCE9YT8iXG5cblJlbW90ZTpcbiIrYToiIiksbnVsbCw3RTQpfSk7bnVsbD09ZD9tKG51bGwpOnRoaXMuZ2V0TGF0ZXN0VmVyc2lvbihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1hJiZhLmdldEN1cnJlbnRFdGFnKCk9PWQ/bShhKTptKG51bGwpfSksZnVuY3Rpb24oKXt9KX1lbHNle3ZhciBxPXRoaXMuZ2V0Q3VycmVudFVzZXIoKSxiPW51bGwhPXE/cS5pZDoidW5rbm93biI7RWRpdG9yVWkubG9nRXJyb3IoIkNoZWNrc3VtIEVycm9yIGluICIraysiICIrdGhpcy5nZXRJZCgpLG51bGwsdGhpcy5nZXRNb2RlKCkrIi4iK3RoaXMuZ2V0SWQoKSwidXNlcl8iK2IrKG51bGwhPXRoaXMuc3luYz8iLWNsaWVudF8iK3RoaXMuc3luYy5jbGllbnRJZDoiLW5vc3luYyIpKTsKdHJ5e0VkaXRvclVpLmxvZ0V2ZW50KHtjYXRlZ29yeToiQ0hFQ0tTVU0tRVJST1ItU1lOQy1GSUxFLSIrdGhpcy5nZXRIYXNoKCksYWN0aW9uOmssbGFiZWw6InVzZXJfIitiKyhudWxsIT10aGlzLnN5bmM/Ii1jbGllbnRfIit0aGlzLnN5bmMuY2xpZW50SWQ6Ii1ub3N5bmMiKX0pfWNhdGNoKGUpe319fWNhdGNoKGUpe319OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zZW5kRXJyb3JSZXBvcnQ9ZnVuY3Rpb24oYSxjLGYsZCl7dHJ5e3ZhciBrPXRoaXMuY29tcHJlc3NSZXBvcnREYXRhKHRoaXMuZ2V0QW5vbnltaXplZFhtbEZvclBhZ2VzKHRoaXMuc2hhZG93UGFnZXMpLDI1RTMpLG09dGhpcy5jb21wcmVzc1JlcG9ydERhdGEodGhpcy5nZXRBbm9ueW1pemVkWG1sRm9yUGFnZXModGhpcy51aS5wYWdlcyksMjVFMykscT10aGlzLmdldEN1cnJlbnRVc2VyKCksYj1udWxsIT1xP3RoaXMudWkuaGFzaFZhbHVlKHEuaWQpOiJ1bmtub3duIixlPW51bGwhPXRoaXMuc3luYz8iLWNsaWVudF8iK3RoaXMuc3luYy5jbGllbnRJZDoiLW5vc3luYyIsZz10aGlzLmdldFRpdGxlKCksbj1nLmxhc3RJbmRleE9mKCIuIikscT0ieG1sIjswPG4mJihxPWcuc3Vic3RyaW5nKG4pKTt2YXIgbD1udWxsIT1mP2Yuc3RhY2s6RXJyb3IoKS5zdGFjaztFZGl0b3JVaS5zZW5kUmVwb3J0KGErIiAiKyhuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSsKIjpcblxuQXBwVmVyc2lvbj0iK25hdmlnYXRvci5hcHBWZXJzaW9uKyJcbkZpbGU9Iit0aGlzLnVpLmhhc2hWYWx1ZSh0aGlzLmdldElkKCkpKyIgKCIrdGhpcy5nZXRNb2RlKCkrIikiKyh0aGlzLmlzTW9kaWZpZWQoKT8iIG1vZGlmaWVkIjoiIikrIlxuU2l6ZS9UeXBlPSIrdGhpcy5nZXRTaXplKCkrIiAoIitxKyIpXG5Vc2VyPSIrYitlKyJcblByZWZpeD0iK3RoaXMudWkuZWRpdG9yLmdyYXBoLm1vZGVsLnByZWZpeCsiXG5TeW5jPSIrRHJhd2lvRmlsZS5TWU5DKyhudWxsIT10aGlzLnN5bmM/KHRoaXMuc3luYy5lbmFibGVkPyIgZW5hYmxlZCI6IiIpKyh0aGlzLnN5bmMuaXNDb25uZWN0ZWQoKT8iIGNvbm5lY3RlZCI6IiIpOiIiKSsiXG5QbHVnaW5zPSIrKG51bGwhPW14U2V0dGluZ3Muc2V0dGluZ3M/bXhTZXR0aW5ncy5nZXRQbHVnaW5zKCk6Im51bGwiKSsiXG5cblN0YXRzOlxuIitKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzLG51bGwsMikrKG51bGwhPWM/IlxuXG4iK2M6CiIiKSsobnVsbCE9Zj8iXG5cbkVycm9yOiAiK2YubWVzc2FnZToiIikrIlxuXG5TdGFjazpcbiIrbCsiXG5cblNoYWRvdzpcbiIraysiXG5cbkRhdGE6XG4iK20sZCl9Y2F0Y2gocCl7fX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnJlbG9hZEZpbGU9ZnVuY3Rpb24oYSxjKXt0cnl7dGhpcy51aS5zcGlubmVyLnN0b3AoKTt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc3RhdHMuZmlsZVJlbG9hZGVkKys7dGhpcy5yZXBvcnRFbmFibGVkPSExO3ZhciBjPXRoaXMudWkuZWRpdG9yLmdyYXBoLmdldFZpZXdTdGF0ZSgpLGY9dGhpcy51aS5lZGl0b3IuZ3JhcGguZ2V0U2VsZWN0aW9uQ2VsbHMoKSxtPXRoaXMudWkuY3VycmVudFBhZ2U7dGhpcy51aS5sb2FkRmlsZSh0aGlzLmdldEhhc2goKSwhMCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy51aS5maWxlTG9hZGVkRXJyb3Ipe3RoaXMudWkucmVzdG9yZVZpZXdTdGF0ZShtLGMsZik7bnVsbCE9dGhpcy5iYWNrdXBQYXRjaCYmdGhpcy5wYXRjaChbdGhpcy5iYWNrdXBQYXRjaF0pO3ZhciBkPXRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1kJiYoZC5zdGF0cz0KdGhpcy5zdGF0cyk7bnVsbCE9YSYmYSgpfX0pLCEwKX0pO3RoaXMuaXNNb2RpZmllZCgpJiZudWxsPT10aGlzLmJhY2t1cFBhdGNoP3RoaXMudWkuY29uZmlybShteFJlc291cmNlcy5nZXQoImFsbENoYW5nZXNMb3N0IiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhhbmRsZUZpbGVTdWNjZXNzKCJtYW51YWwiPT1EcmF3aW9GaWxlLlNZTkMpfSksZixteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14UmVzb3VyY2VzLmdldCgiZGlzY2FyZENoYW5nZXMiKSk6ZigpfWNhdGNoKGQpe251bGwhPWMmJmMoZCl9fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5jb3B5RmlsZT1mdW5jdGlvbihhLGMpe3RoaXMudWkuZWRpdG9yLmVkaXRBc05ldyh0aGlzLnVpLmdldEZpbGVEYXRhKCEwKSx0aGlzLnVpLmdldENvcHlGaWxlbmFtZSh0aGlzKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5pZ25vcmVQYXRjaGVzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz0hMCxmPTA7ZjxhLmxlbmd0aCYmYztmKyspYz1jJiYwPT1PYmplY3Qua2V5cyhhW2ZdKS5sZW5ndGg7cmV0dXJuIGN9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5wYXRjaD1mdW5jdGlvbihhLGMpe3ZhciBmPXRoaXMudWkuZWRpdG9yLnVuZG9NYW5hZ2VyLGQ9Zi5oaXN0b3J5LnNsaWNlKCksaz1mLmluZGV4T2ZOZXh0QWRkLG09dGhpcy51aS5lZGl0b3IuZ3JhcGg7bS5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIjt2YXIgcT10aGlzLmNoYW5nZUxpc3RlbmVyRW5hYmxlZDt0aGlzLmNoYW5nZUxpc3RlbmVyRW5hYmxlZD0hMTt2YXIgYj1tLmZvbGRpbmdFbmFibGVkLGU9bS5tYXRoRW5hYmxlZCxnPW0uY2VsbFJlbmRlcmVyLnJlZHJhdzttLmNlbGxSZW5kZXJlci5yZWRyYXc9ZnVuY3Rpb24oYSl7YS52aWV3LmdyYXBoLmlzRWRpdGluZyhhLmNlbGwpJiYoYS52aWV3LmdyYXBoLnNjcm9sbENlbGxUb1Zpc2libGUoYS5jZWxsKSxhLnZpZXcuZ3JhcGguY2VsbEVkaXRvci5yZXNpemUoKSk7Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O20ubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBuPQowO248YS5sZW5ndGg7bisrKXRoaXMudWkucGFnZXM9dGhpcy51aS5wYXRjaFBhZ2VzKHRoaXMudWkucGFnZXMsYVtuXSwhMCxjLHRoaXMuaXNNb2RpZmllZCgpKTswPT10aGlzLnVpLnBhZ2VzLmxlbmd0aCYmdGhpcy51aS5wYWdlcy5wdXNoKHRoaXMudWkuY3JlYXRlUGFnZSgpKTswPm14VXRpbHMuaW5kZXhPZih0aGlzLnVpLnBhZ2VzLHRoaXMudWkuY3VycmVudFBhZ2UpJiZ0aGlzLnVpLnNlbGVjdFBhZ2UodGhpcy51aS5wYWdlc1swXSwhMCl9ZmluYWxseXttLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5PSIiO20ubW9kZWwuZW5kVXBkYXRlKCk7bS5jZWxsUmVuZGVyZXIucmVkcmF3PWc7dGhpcy5jaGFuZ2VMaXN0ZW5lckVuYWJsZWQ9cTtmLmhpc3Rvcnk9ZDtmLmluZGV4T2ZOZXh0QWRkPWs7Zi5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5DTEVBUikpO2lmKG51bGw9PXRoaXMudWkuY3VycmVudFBhZ2V8fHRoaXMudWkuY3VycmVudFBhZ2UubmVlZHNVcGRhdGUpZSE9Cm0ubWF0aEVuYWJsZWQ/KHRoaXMudWkuZWRpdG9yLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpLG0ucmVmcmVzaCgpKTooYiE9bS5mb2xkaW5nRW5hYmxlZD9tLnZpZXcucmV2YWxpZGF0ZSgpOm0udmlldy52YWxpZGF0ZSgpLG0uc2l6ZURpZENoYW5nZSgpKTt0aGlzLnVpLnVwZGF0ZVRhYkNvbnRhaW5lcigpfX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oYSxjLGYsZCxrLG0pe3RyeXtpZih0aGlzLmlzRWRpdGFibGUoKSlpZighayYmdGhpcy5pbnZhbGlkQ2hlY2tzdW0paWYobnVsbCE9ZilmKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiY2hlY2tzdW0iKX0pO2Vsc2UgdGhyb3cgRXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJjaGVja3N1bSIpKTtlbHNlIHRoaXMudXBkYXRlRmlsZURhdGEoKSx0aGlzLmNsZWFyQXV0b3NhdmUoKSxudWxsIT1jJiZjKCk7ZWxzZSBpZihudWxsIT1mKWYoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJyZWFkT25seSIpfSk7ZWxzZSB0aHJvdyBFcnJvcihteFJlc291cmNlcy5nZXQoInJlYWRPbmx5IikpO31jYXRjaChxKXtpZihudWxsIT1mKWYocSk7ZWxzZSB0aHJvdyBxO319OwpEcmF3aW9GaWxlLnByb3RvdHlwZS51cGRhdGVGaWxlRGF0YT1mdW5jdGlvbihhKXt0aGlzLnNldERhdGEodGhpcy51aS5nZXRGaWxlRGF0YShudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsdGhpcyxudWxsIT1hPyFhOiF0aGlzLmlzQ29tcHJlc3NlZCgpKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzQ29tcHJlc3NlZFN0b3JhZ2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH07RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNDb21wcmVzc2VkPWZ1bmN0aW9uKCl7dmFyIGE9bnVsbCE9dGhpcy51aS5maWxlTm9kZT90aGlzLnVpLmZpbGVOb2RlLmdldEF0dHJpYnV0ZSgiY29tcHJlc3NlZCIpOm51bGw7cmV0dXJuIG51bGwhPWE/ImZhbHNlIiE9YTp0aGlzLmlzQ29tcHJlc3NlZFN0b3JhZ2UoKSYmRWRpdG9yLmNvbXByZXNzWG1sfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZGVjb21wcmVzcz1mdW5jdGlvbigpe3RoaXMudXBkYXRlRmlsZURhdGEoITEpO251bGwhPXRoaXMudWkuZmlsZU5vZGUmJnRoaXMudWkuZmlsZU5vZGUuc2V0QXR0cmlidXRlKCJjb21wcmVzc2VkIiwiZmFsc2UiKTt0aGlzLmZpbGVDaGFuZ2VkKCl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmNvbXByZXNzPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVGaWxlRGF0YSghMCk7bnVsbCE9dGhpcy51aS5maWxlTm9kZSYmdGhpcy51aS5maWxlTm9kZS5zZXRBdHRyaWJ1dGUoImNvbXByZXNzZWQiLCJ0cnVlIik7dGhpcy5maWxlQ2hhbmdlZCgpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zYXZlQXM9ZnVuY3Rpb24oYSxjLGYpe307RHJhd2lvRmlsZS5wcm90b3R5cGUuc2F2ZUZpbGU9ZnVuY3Rpb24oYSxjLGYsZCl7fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRQdWJsaWNVcmw9ZnVuY3Rpb24oYSl7YShudWxsKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmlzUmVzdHJpY3RlZD1mdW5jdGlvbigpe3JldHVybiExfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc01vZGlmaWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kaWZpZWR9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnNldE1vZGlmaWVkPWZ1bmN0aW9uKGEpe3RoaXMubW9kaWZpZWQ9YX07RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNBdXRvc2F2ZU9wdGlvbmFsPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzQXV0b3NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pbkNvbmZsaWN0U3RhdGUmJnRoaXMudWkuZWRpdG9yLmF1dG9zYXZlfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc1JlbmFtYWJsZT1mdW5jdGlvbigpe3JldHVybiExfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5yZW5hbWU9ZnVuY3Rpb24oYSxjLGYpe307RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNNb3ZhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITF9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5pc1RyYXNoZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07RHJhd2lvRmlsZS5wcm90b3R5cGUubW92ZT1mdW5jdGlvbihhLGMsZil7fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRIYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIiJ9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldElkPWZ1bmN0aW9uKCl7cmV0dXJuIiJ9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzRWRpdGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51aS5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpfHx0aGlzLnVpLmVkaXRvci5lZGl0YWJsZX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0VWk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51aX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0VGl0bGU9ZnVuY3Rpb24oKXtyZXR1cm4iIn07RHJhd2lvRmlsZS5wcm90b3R5cGUuc2V0RGF0YT1mdW5jdGlvbihhKXt0aGlzLmRhdGE9YX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKCl7dGhpcy5zdGF0cy5vcGVuZWQrKzt2YXIgYT10aGlzLmdldERhdGEoKTtpZihudWxsIT1hKXt2YXIgYz1mdW5jdGlvbihhKXtmb3IodmFyIGM9MDtudWxsIT1hJiZjPGEubGVuZ3RoO2MrKyl7dmFyIGY9YVtjXTtudWxsIT1mLmlkJiYwPT1mLmlkLmluZGV4T2YoImV4dEZvbnRfIikmJmYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmKX19O2MoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgiaGVhZCA+IHN0eWxlW2lkXSIpKTtjKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoImhlYWQgPiBsaW5rW2lkXSIpKTt0aGlzLnVpLnNldEZpbGVEYXRhKGEpO3RoaXMuaXNNb2RpZmllZCgpfHwodGhpcy5zaGFkb3dEYXRhPW14VXRpbHMuZ2V0WG1sKHRoaXMudWkuZ2V0WG1sRmlsZURhdGEoKSksdGhpcy5zaGFkb3dQYWdlcz1udWxsKX10aGlzLmluc3RhbGxMaXN0ZW5lcnMoKTt0aGlzLmlzU3luY1N1cHBvcnRlZCgpJiZ0aGlzLnN0YXJ0U3luYygpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuaXNTeW5jU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmlzUmV2aXNpb25IaXN0b3J5U3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldFJldmlzaW9ucz1mdW5jdGlvbihhLGMpe2EobnVsbCl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmxvYWREZXNjcmlwdG9yPWZ1bmN0aW9uKGEsYyl7YShudWxsKX07RHJhd2lvRmlsZS5wcm90b3R5cGUubG9hZFBhdGNoRGVzY3JpcHRvcj1mdW5jdGlvbihhLGMpe3RoaXMubG9hZERlc2NyaXB0b3IobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7YShjKX0pLGMpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5wYXRjaERlc2NyaXB0b3I9ZnVuY3Rpb24oYSxjKXt0aGlzLnNldERlc2NyaXB0b3JFdGFnKGEsdGhpcy5nZXREZXNjcmlwdG9yRXRhZyhjKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zdGFydFN5bmM9ZnVuY3Rpb24oKXsiYXV0byIhPURyYXdpb0ZpbGUuU1lOQ3x8IjEiPT11cmxQYXJhbXMuc3RlYWx0aHx8IjEiIT11cmxQYXJhbXMucnQmJnRoaXMudWkuZWRpdG9yLmNocm9tZWxlc3MmJiF0aGlzLnVpLmVkaXRvci5lZGl0YWJsZXx8KG51bGw9PXRoaXMuc3luYyYmKHRoaXMuc3luYz1uZXcgRHJhd2lvRmlsZVN5bmModGhpcykpLHRoaXMuc3luYy5zdGFydCgpKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNDb25mbGljdD1mdW5jdGlvbigpe3JldHVybiExfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRDaGFubmVsSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gR3JhcGguY29tcHJlc3ModGhpcy5nZXRIYXNoKCkpLnJlcGxhY2UoL1tcLyArXS9nLCJfIil9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldENoYW5uZWxLZXk9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGx9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldEN1cnJlbnRVc2VyPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXRMYXRlc3RWZXJzaW9uPWZ1bmN0aW9uKGEsYyl7YShudWxsKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0TGFzdE1vZGlmaWVkRGF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZX07RHJhd2lvRmlsZS5wcm90b3R5cGUuc2V0Q3VycmVudFJldmlzaW9uSWQ9ZnVuY3Rpb24oYSl7dGhpcy5zZXREZXNjcmlwdG9yUmV2aXNpb25JZCh0aGlzLmdldERlc2NyaXB0b3IoKSxhKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0Q3VycmVudFJldmlzaW9uSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREZXNjcmlwdG9yUmV2aXNpb25JZCh0aGlzLmdldERlc2NyaXB0b3IoKSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnNldEN1cnJlbnRFdGFnPWZ1bmN0aW9uKGEpe3RoaXMuc2V0RGVzY3JpcHRvckV0YWcodGhpcy5nZXREZXNjcmlwdG9yKCksYSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLmdldEN1cnJlbnRFdGFnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RGVzY3JpcHRvckV0YWcodGhpcy5nZXREZXNjcmlwdG9yKCkpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0RGVzY3JpcHRvcj1mdW5jdGlvbigpe3JldHVybiBudWxsfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zZXREZXNjcmlwdG9yPWZ1bmN0aW9uKCl7fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zZXREZXNjcmlwdG9yUmV2aXNpb25JZD1mdW5jdGlvbihhLGMpe3RoaXMuc2V0RGVzY3JpcHRvckV0YWcoYSxjKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0RGVzY3JpcHRvclJldmlzaW9uSWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZ2V0RGVzY3JpcHRvckV0YWcoYSl9O0RyYXdpb0ZpbGUucHJvdG90eXBlLnNldERlc2NyaXB0b3JFdGFnPWZ1bmN0aW9uKGEsYyl7fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5nZXREZXNjcmlwdG9yRXRhZz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0RGVzY3JpcHRvclNlY3JldD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbH07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmluc3RhbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oKXtudWxsPT10aGlzLmNoYW5nZUxpc3RlbmVyJiYodGhpcy5jaGFuZ2VMaXN0ZW5lcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3ZhciBmPW51bGwhPWM/Yy5nZXRQcm9wZXJ0eSgiZWRpdCIpOm51bGw7IXRoaXMuY2hhbmdlTGlzdGVuZXJFbmFibGVkfHwhdGhpcy5pc0VkaXRhYmxlKCl8fG51bGwhPWYmJmYuaWdub3JlRWRpdHx8dGhpcy5maWxlQ2hhbmdlZCgpfSksdGhpcy51aS5lZGl0b3IuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5lZGl0b3IuZ3JhcGguYWRkTGlzdGVuZXIoImdyaWRTaXplQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5lZGl0b3IuZ3JhcGguYWRkTGlzdGVuZXIoInNoYWRvd1Zpc2libGVDaGFuZ2VkIix0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmFkZExpc3RlbmVyKCJwYWdlRm9ybWF0Q2hhbmdlZCIsCnRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoInBhZ2VTY2FsZUNoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoImJhY2tncm91bmRDb2xvckNoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoImJhY2tncm91bmRJbWFnZUNoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoImZvbGRpbmdFbmFibGVkQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigibWF0aEVuYWJsZWRDaGFuZ2VkIix0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmFkZExpc3RlbmVyKCJncmlkRW5hYmxlZENoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuYWRkTGlzdGVuZXIoImd1aWRlc0VuYWJsZWRDaGFuZ2VkIix0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmFkZExpc3RlbmVyKCJwYWdlVmlld0NoYW5nZWQiLAp0aGlzLmNoYW5nZUxpc3RlbmVyKSx0aGlzLnVpLmFkZExpc3RlbmVyKCJjb25uZWN0aW9uUG9pbnRzQ2hhbmdlZCIsdGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy51aS5hZGRMaXN0ZW5lcigiY29ubmVjdGlvbkFycm93c0NoYW5nZWQiLHRoaXMuY2hhbmdlTGlzdGVuZXIpKX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmFkZEFsbFNhdmVkU3RhdHVzPWZ1bmN0aW9uKGEpe251bGwhPXRoaXMudWkuc3RhdHVzQ29udGFpbmVyJiZ0aGlzLnVpLmdldEN1cnJlbnRGaWxlKCk9PXRoaXMmJihhPW51bGwhPWE/YTpteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQodGhpcy5hbGxDaGFuZ2VzU2F2ZWRLZXkpKSx0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMoJzxkaXYgdGl0bGU9IicrYSsnIj4nK2ErIjwvZGl2PiIpLGE9dGhpcy51aS5zdGF0dXNDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLDA8YS5sZW5ndGgmJnRoaXMuaXNSZXZpc2lvbkhpc3RvcnlTdXBwb3J0ZWQoKSYmKGFbMF0uc3R5bGUuY3Vyc29yPSJwb2ludGVyIixhWzBdLnN0eWxlLnRleHREZWNvcmF0aW9uPSJ1bmRlcmxpbmUiLG14RXZlbnQuYWRkTGlzdGVuZXIoYVswXSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5hY3Rpb25zLmdldCgicmV2aXNpb25IaXN0b3J5IikuZnVuY3QoKX0pKSkpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuc2F2ZURyYWZ0PWZ1bmN0aW9uKCl7dHJ5e251bGw9PXRoaXMuZHJhZnRJZCYmKHRoaXMuZHJhZnRJZD1FZGl0b3IuZ3VpZCgpKTt2YXIgYT17dHlwZToiZHJhZnQiLGNyZWF0ZWQ6dGhpcy5jcmVhdGVkLG1vZGlmaWVkOihuZXcgRGF0ZSkuZ2V0VGltZSgpLGRhdGE6dGhpcy51aS5nZXRGaWxlRGF0YSgpLHRpdGxlOnRoaXMuZ2V0VGl0bGUoKSxhbGl2ZUNoZWNrOnRoaXMudWkuZHJhZnRBbGl2ZUNoZWNrfTt0aGlzLnVpLnNldERhdGFiYXNlSXRlbSgiLmRyYWZ0XyIrdGhpcy5kcmFmdElkLEpTT04uc3RyaW5naWZ5KGEpKTtFZGl0b3JVaS5kZWJ1ZygiZHJhZnQgc2F2ZWQiLHRoaXMuZHJhZnRJZCxhKX1jYXRjaChjKXtjb25zb2xlLmVycm9yKGMpLHRoaXMucmVtb3ZlRHJhZnQoKX19OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5yZW1vdmVEcmFmdD1mdW5jdGlvbigpe3RyeXtudWxsIT10aGlzLmRyYWZ0SWQmJih0aGlzLnVpLnJlbW92ZURhdGFiYXNlSXRlbSgiLmRyYWZ0XyIrdGhpcy5kcmFmdElkKSxFZGl0b3JVaS5kZWJ1ZygiZHJhZnQgZGVsZXRlZCIsIi5kcmFmdF8iK3RoaXMuZHJhZnRJZCkpfWNhdGNoKGEpe319OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5hZGRVbnNhdmVkU3RhdHVzPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLmluQ29uZmxpY3RTdGF0ZSYmbnVsbCE9dGhpcy51aS5zdGF0dXNDb250YWluZXImJnRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKT09dGhpcylpZihhIGluc3RhbmNlb2YgRXJyb3ImJm51bGwhPWEubWVzc2FnZSYmIiIhPWEubWVzc2FnZSl7dmFyIGM9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ1bnNhdmVkQ2hhbmdlcyIpKTt0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMoJzxkaXYgdGl0bGU9IicrYysnIiBjbGFzcz0iZ2VTdGF0dXNBbGVydCIgc3R5bGU9Im92ZXJmbG93OmhpZGRlbjsiPicrYysiICgiK214VXRpbHMuaHRtbEVudGl0aWVzKGEubWVzc2FnZSkrIik8L2Rpdj4iKX1lbHNle2M9dGhpcy5nZXRFcnJvck1lc3NhZ2UoYSk7aWYobnVsbD09YyYmbnVsbCE9dGhpcy5sYXN0U2F2ZWQpe3ZhciBmPXRoaXMudWkudGltZVNpbmNlKG5ldyBEYXRlKHRoaXMubGFzdFNhdmVkKSk7Cm51bGwhPWYmJihjPW14UmVzb3VyY2VzLmdldCgibGFzdFNhdmVkIixbZl0pKX1udWxsIT1jJiY2MDxjLmxlbmd0aCYmKGM9Yy5zdWJzdHJpbmcoMCw2MCkrIi4uLiIpO2M9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ1bnNhdmVkQ2hhbmdlc0NsaWNrSGVyZVRvU2F2ZSIpKSsobnVsbCE9YyYmIiIhPWM/IiAoIitteFV0aWxzLmh0bWxFbnRpdGllcyhjKSsiKSI6IiIpO3RoaXMudWkuZWRpdG9yLnNldFN0YXR1cygnPGRpdiB0aXRsZT0iJytjKyciIGNsYXNzPSJnZVN0YXR1c0FsZXJ0IiBzdHlsZT0iY3Vyc29yOnBvaW50ZXI7b3ZlcmZsb3c6aGlkZGVuOyI+JytjKyI8L2Rpdj4iKTtjPXRoaXMudWkuc3RhdHVzQ29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKTtudWxsIT1jJiYwPGMubGVuZ3RoP214RXZlbnQuYWRkTGlzdGVuZXIoY1swXSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5hY3Rpb25zLmdldChudWxsIT0KdGhpcy51aS5tb2RlJiZ0aGlzLmlzRWRpdGFibGUoKT8ic2F2ZSI6InNhdmVBcyIpLmZ1bmN0KCl9KSk6KGM9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ1bnNhdmVkQ2hhbmdlcyIpKSx0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMoJzxkaXYgdGl0bGU9IicrYysnIiBjbGFzcz0iZ2VTdGF0dXNBbGVydCIgc3R5bGU9Im92ZXJmbG93OmhpZGRlbjsiPicrYysiICgiK214VXRpbHMuaHRtbEVudGl0aWVzKGEubWVzc2FnZSkrIik8L2Rpdj4iKSk7RWRpdG9yVWkuZW5hYmxlRHJhZnRzJiZudWxsPT10aGlzLmdldE1vZGUoKSYmdGhpcy5zYXZlRHJhZnQoKX19OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5hZGRDb25mbGljdFN0YXR1cz1mdW5jdGlvbihhLGMpe3RoaXMuaW52YWxpZENoZWNrc3VtJiZudWxsPT1jJiYoYz1teFJlc291cmNlcy5nZXQoImNoZWNrc3VtIikpO3RoaXMuc2V0Q29uZmxpY3RTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJmaWxlQ2hhbmdlZFN5bmMiKSkrKG51bGwhPWMmJiIiIT1jPyIgKCIrbXhVdGlscy5odG1sRW50aXRpZXMoYykrIikiOiIiKSk7dGhpcy51aS5zcGlubmVyLnN0b3AoKTt0aGlzLmNsZWFyQXV0b3NhdmUoKTt2YXIgZj1udWxsIT10aGlzLnVpLnN0YXR1c0NvbnRhaW5lcj90aGlzLnVpLnN0YXR1c0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGl2Iik6bnVsbDtudWxsIT1mJiYwPGYubGVuZ3RoP214RXZlbnQuYWRkTGlzdGVuZXIoZlswXSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpeyJJTUciIT1teEV2ZW50LmdldFNvdXJjZShjKS5ub2RlTmFtZSYmCmEoKX0pKTp0aGlzLnVpLmFsZXJ0KG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jIikpLGEpfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5zZXRDb25mbGljdFN0YXR1cz1mdW5jdGlvbihhKXt0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMoJzxkaXYgdGl0bGU9IicrYSsnIiBjbGFzcz0iZ2VTdGF0dXNBbGVydCBnZUJsaW5rIiBzdHlsZT0iY3Vyc29yOnBvaW50ZXI7b3ZlcmZsb3c6aGlkZGVuOyI+JythKycgPGEgaHJlZj0iaHR0cHM6Ly9kZXNrLmRyYXcuaW8vc3VwcG9ydC9zb2x1dGlvbnMvYXJ0aWNsZXMvMTYwMDAwODc5NDciIHRhcmdldD0iX2JsYW5rIj48aW1nIGJvcmRlcj0iMCIgc3R5bGU9Im1hcmdpbi1sZWZ0OjJweDtjdXJzb3I6aGVscDtvcGFjaXR5OjAuNTt3aWR0aDoxNnB4O2hlaWdodDoxNnB4OyIgdmFsaWduPSJib3R0b20iIHNyYz0iJytFZGl0b3IuaGVscEltYWdlKyciIHN0eWxlPSIiLz48L2E+PC9kaXY+Jyl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zaG93UmVmcmVzaERpYWxvZz1mdW5jdGlvbihhLGMsZil7bnVsbD09ZiYmKGY9bXhSZXNvdXJjZXMuZ2V0KCJjaGVja3N1bSIpKTt0aGlzLnVpLmVkaXRvci5pc0Nocm9tZWxlc3NWaWV3KCkmJiF0aGlzLnVpLmVkaXRvci5lZGl0YWJsZT90aGlzLnVpLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlbG9hZEZpbGUoYSxjKX0pKToodGhpcy5hZGRDb25mbGljdFN0YXR1cyhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2hvd1JlZnJlc2hEaWFsb2coYSxjKX0pLGYpLHRoaXMudWkuc2hvd0Vycm9yKG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsiICgiK2YrIikiLG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jRGlhbG9nIiksbXhSZXNvdXJjZXMuZ2V0KCJtYWtlQ29weSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jb3B5RmlsZShhLApjKX0pLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJzeW5jaHJvbml6ZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWxvYWRGaWxlKGEsYyl9KSxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy51aS5oaWRlRGlhbG9nKCl9KSwzNjAsMTUwKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zaG93Q29weURpYWxvZz1mdW5jdGlvbihhLGMsZil7dGhpcy5pbnZhbGlkQ2hlY2tzdW09dGhpcy5pbkNvbmZsaWN0U3RhdGU9ITE7dGhpcy5hZGRVbnNhdmVkU3RhdHVzKCk7dGhpcy51aS5zaG93RXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJleHRlcm5hbENoYW5nZXMiKSxteFJlc291cmNlcy5nZXQoImZpbGVDaGFuZ2VkT3ZlcndyaXRlRGlhbG9nIiksbXhSZXNvdXJjZXMuZ2V0KCJtYWtlQ29weSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jb3B5RmlsZShhLGMpfSksbnVsbCxteFJlc291cmNlcy5nZXQoIm92ZXJ3cml0ZSIpLGYsbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudWkuaGlkZURpYWxvZygpfSksMzYwLDE1MCl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5zaG93Q29uZmxpY3REaWFsb2c9ZnVuY3Rpb24oYSxjKXt0aGlzLnVpLnNob3dFcnJvcihteFJlc291cmNlcy5nZXQoImV4dGVybmFsQ2hhbmdlcyIpLG14UmVzb3VyY2VzLmdldCgiZmlsZUNoYW5nZWRTeW5jRGlhbG9nIiksbXhSZXNvdXJjZXMuZ2V0KCJvdmVyd3JpdGUiKSxhLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJzeW5jaHJvbml6ZSIpLGMsbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudWkuaGlkZURpYWxvZygpO3RoaXMuaGFuZGxlRmlsZUVycm9yKG51bGwsITEpfSksMzQwLDE1MCl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5yZWRpcmVjdFRvTmV3QXBwPWZ1bmN0aW9uKGEsYyl7dGhpcy51aS5zcGlubmVyLnN0b3AoKTtpZighdGhpcy5yZWRpcmVjdERpYWxvZ1Nob3dpbmcpe3RoaXMucmVkaXJlY3REaWFsb2dTaG93aW5nPSEwO3ZhciBmPXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCsiLy8iK3dpbmRvdy5sb2NhdGlvbi5ob3N0KyIvIit0aGlzLnVpLmdldFNlYXJjaCgiY3JlYXRlIHRpdGxlIG1vZGUgdXJsIGRyaXZlIHNwbGFzaCBzdGF0ZSIuc3BsaXQoIiAiKSkrIiMiK3RoaXMuZ2V0SGFzaCgpLGQ9bXhSZXNvdXJjZXMuZ2V0KCJyZWRpcmVjdFRvTmV3QXBwIik7bnVsbCE9YyYmKGQrPSIgKCIrYysiKSIpO3ZhciBrPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGM9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlZGlyZWN0RGlhbG9nU2hvd2luZz0hMTt3aW5kb3cubG9jYXRpb24uaHJlZj09Zj93aW5kb3cubG9jYXRpb24ucmVsb2FkKCk6CndpbmRvdy5sb2NhdGlvbi5ocmVmPWZ9KTtudWxsPT1hJiZ0aGlzLmlzTW9kaWZpZWQoKT90aGlzLnVpLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJhbGxDaGFuZ2VzTG9zdCIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWRpcmVjdERpYWxvZ1Nob3dpbmc9ITF9KSxjLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhSZXNvdXJjZXMuZ2V0KCJkaXNjYXJkQ2hhbmdlcyIpKTpjKCl9KTtudWxsIT1hP3RoaXMuaXNNb2RpZmllZCgpP3RoaXMudWkuY29uZmlybShkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZWRpcmVjdERpYWxvZ1Nob3dpbmc9ITE7YSgpfSksayxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14UmVzb3VyY2VzLmdldCgiZGlzY2FyZENoYW5nZXMiKSk6dGhpcy51aS5jb25maXJtKGQsayxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucmVkaXJlY3REaWFsb2dTaG93aW5nPSExO2EoKX0pKTp0aGlzLnVpLmFsZXJ0KG14UmVzb3VyY2VzLmdldCgicmVkaXJlY3RUb05ld0FwcCIpLAprKX19O0RyYXdpb0ZpbGUucHJvdG90eXBlLmhhbmRsZUZpbGVTdWNjZXNzPWZ1bmN0aW9uKGEpe3RoaXMudWkuc3Bpbm5lci5zdG9wKCk7dGhpcy51aS5nZXRDdXJyZW50RmlsZSgpPT10aGlzJiYodGhpcy5pc01vZGlmaWVkKCk/dGhpcy5maWxlQ2hhbmdlZCgpOmE/KHRoaXMuaXNUcmFzaGVkKCk/dGhpcy5hZGRBbGxTYXZlZFN0YXR1cyhteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQodGhpcy5hbGxDaGFuZ2VzU2F2ZWRLZXkpKSsiICgiK214VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZmlsZU1vdmVkVG9UcmFzaCIpKSsiKSIpOnRoaXMuYWRkQWxsU2F2ZWRTdGF0dXMoKSxudWxsIT10aGlzLnN5bmMmJih0aGlzLnN5bmMucmVzZXRVcGRhdGVTdGF0dXNUaHJlYWQoKSx0aGlzLnN5bmMucmVtb3RlRmlsZUNoYW5nZWQmJih0aGlzLnN5bmMucmVtb3RlRmlsZUNoYW5nZWQ9ITEsdGhpcy5zeW5jLmZpbGVDaGFuZ2VkTm90aWZ5KCkpKSk6dGhpcy51aS5lZGl0b3Iuc2V0U3RhdHVzKCIiKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5oYW5kbGVGaWxlRXJyb3I9ZnVuY3Rpb24oYSxjKXt0aGlzLnVpLnNwaW5uZXIuc3RvcCgpO2lmKHRoaXMudWkuZ2V0Q3VycmVudEZpbGUoKT09dGhpcylpZih0aGlzLmluQ29uZmxpY3RTdGF0ZSl0aGlzLmhhbmRsZUNvbmZsaWN0RXJyb3IoYSxjKTtlbHNlIGlmKHRoaXMuaXNNb2RpZmllZCgpJiZ0aGlzLmFkZFVuc2F2ZWRTdGF0dXMoYSksYyl0aGlzLnVpLmhhbmRsZUVycm9yKGEsbnVsbCE9YT9teFJlc291cmNlcy5nZXQoImVycm9yU2F2aW5nRmlsZSIpOm51bGwpO2Vsc2UgaWYoIXRoaXMuaXNNb2RpZmllZCgpKXt2YXIgZj1udWxsIT1hP251bGwhPWEuZXJyb3I/YS5lcnJvci5tZXNzYWdlOmEubWVzc2FnZTpudWxsO251bGwhPWYmJjYwPGYubGVuZ3RoJiYoZj1mLnN1YnN0cmluZygwLDYwKSsiLi4uIik7dGhpcy51aS5lZGl0b3Iuc2V0U3RhdHVzKCc8ZGl2IGNsYXNzPSJnZVN0YXR1c0FsZXJ0IiBzdHlsZT0iY3Vyc29yOnBvaW50ZXI7b3ZlcmZsb3c6aGlkZGVuOyI+JysKbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpKSsobnVsbCE9Zj8iICgiK214VXRpbHMuaHRtbEVudGl0aWVzKGYpKyIpIjoiIikrIjwvZGl2PiIpfX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmhhbmRsZUNvbmZsaWN0RXJyb3I9ZnVuY3Rpb24oYSxjKXt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGFuZGxlRmlsZVN1Y2Nlc3MoITApfSksZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhhbmRsZUZpbGVFcnJvcihhLCEwKX0pLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVpLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgic2F2aW5nIikpJiYodGhpcy51aS5lZGl0b3Iuc2V0U3RhdHVzKCIiKSx0aGlzLnNhdmUoITAsZixkLG51bGwsITAsdGhpcy5jb25zdHJ1Y3RvciE9R2l0SHViRmlsZSYmdGhpcy5jb25zdHJ1Y3RvciE9R2l0TGFiRmlsZXx8bnVsbD09YT9udWxsOmEuY29tbWl0TWVzc2FnZSkpfSksbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudWkuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJ1cGRhdGluZ0RvY3VtZW50IikpJiYKdGhpcy5zeW5jaHJvbml6ZUZpbGUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVpLnNwaW5uZXIuc3RvcCgpO3RoaXMudWkuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJzYXZpbmciKSkmJnRoaXMuc2F2ZSghMCxmLGQsbnVsbCxudWxsLHRoaXMuY29uc3RydWN0b3IhPUdpdEh1YkZpbGUmJnRoaXMuY29uc3RydWN0b3IhPUdpdExhYkZpbGV8fG51bGw9PWE/bnVsbDphLmNvbW1pdE1lc3NhZ2UpfSksZCl9KTsibm9uZSI9PURyYXdpb0ZpbGUuU1lOQz90aGlzLnNob3dDb3B5RGlhbG9nKGYsZCxrKTp0aGlzLmludmFsaWRDaGVja3N1bT90aGlzLnNob3dSZWZyZXNoRGlhbG9nKGYsZCx0aGlzLmdldEVycm9yTWVzc2FnZShhKSk6Yz90aGlzLnNob3dDb25mbGljdERpYWxvZyhrLG0pOnRoaXMuYWRkQ29uZmxpY3RTdGF0dXMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnVpLmVkaXRvci5zZXRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ1cGRhdGluZ0RvY3VtZW50IikpKTsKdGhpcy5zeW5jaHJvbml6ZUZpbGUoZixkKX0pLHRoaXMuZ2V0RXJyb3JNZXNzYWdlKGEpKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0RXJyb3JNZXNzYWdlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP251bGwhPWEuZXJyb3I/YS5lcnJvci5tZXNzYWdlOmEubWVzc2FnZTpudWxsfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5pc092ZXJkdWU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5hZ2VTdGFydCYmRGF0ZS5ub3coKS10aGlzLmFnZVN0YXJ0LmdldFRpbWUoKT49dGhpcy51aS53YXJuSW50ZXJ2YWx9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5maWxlQ2hhbmdlZD1mdW5jdGlvbigpe3RoaXMubGFzdENoYW5nZWQ9bmV3IERhdGU7dGhpcy5zZXRNb2RpZmllZCghMCk7dGhpcy5pc0F1dG9zYXZlKCk/KHRoaXMuYWRkQWxsU2F2ZWRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJzYXZpbmciKSkrIi4uLiIpLHRoaXMudWkuc2NoZWR1bGVTYW5pdHlDaGVjaygpLG51bGw9PXRoaXMuYWdlU3RhcnQmJih0aGlzLmFnZVN0YXJ0PW5ldyBEYXRlKSx0aGlzLmF1dG9zYXZlKHRoaXMuYXV0b3NhdmVEZWxheSx0aGlzLm1heEF1dG9zYXZlRGVsYXksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy51aS5zdG9wU2FuaXR5Q2hlY2soKTtudWxsPT10aGlzLmF1dG9zYXZlVGhyZWFkPyh0aGlzLmhhbmRsZUZpbGVTdWNjZXNzKCEwKSx0aGlzLmFnZVN0YXJ0PW51bGwpOnRoaXMuaXNNb2RpZmllZCgpJiYodGhpcy51aS5zY2hlZHVsZVNhbml0eUNoZWNrKCksdGhpcy5hZ2VTdGFydD0KdGhpcy5sYXN0Q2hhbmdlZCl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhhbmRsZUZpbGVFcnJvcihhKX0pKSk6KHRoaXMuYWdlU3RhcnQ9bnVsbCx0aGlzLmlzQXV0b3NhdmVPcHRpb25hbCgpJiZ0aGlzLnVpLmVkaXRvci5hdXRvc2F2ZXx8dGhpcy5pbkNvbmZsaWN0U3RhdGV8fHRoaXMuYWRkVW5zYXZlZFN0YXR1cygpKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuY3JlYXRlU2VjcmV0PWZ1bmN0aW9uKGEsYyl7dmFyIGY9RWRpdG9yLmd1aWQoMzIpO251bGwhPXRoaXMuc3luYz90aGlzLnN5bmMuY3JlYXRlVG9rZW4oZixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXthKGYsYyl9KSxjKTphKGYpfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUuZmlsZVNhdmVkPWZ1bmN0aW9uKGEsYyxmLGQsayl7dGhpcy5sYXN0U2F2ZWQ9bmV3IERhdGU7dGhpcy5hZ2VTdGFydD1udWxsO3RyeXt0aGlzLnN0YXRzLnNhdmVkKyssdGhpcy5pbnZhbGlkQ2hlY2tzdW09dGhpcy5pbkNvbmZsaWN0U3RhdGU9ITEsbnVsbD09dGhpcy5zeW5jPyh0aGlzLnNoYWRvd0RhdGE9YSx0aGlzLnNoYWRvd1BhZ2VzPW51bGwsbnVsbCE9ZiYmZigpKTp0aGlzLnN5bmMuZmlsZVNhdmVkKHRoaXMudWkuZ2V0UGFnZXNGb3JOb2RlKG14VXRpbHMucGFyc2VYbWwoYSkuZG9jdW1lbnRFbGVtZW50KSxjLGYsZCxrKX1jYXRjaChiKXt0aGlzLmludmFsaWRDaGVja3N1bT10aGlzLmluQ29uZmxpY3RTdGF0ZT0hMDt0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkKCk7bnVsbCE9ZCYmZChiKTt0cnl7aWYodGhpcy5lcnJvclJlcG9ydHNFbmFibGVkKXRoaXMuc2VuZEVycm9yUmVwb3J0KCJFcnJvciBpbiBmaWxlU2F2ZWQiLG51bGwsYik7ZWxzZXt2YXIgbT0KdGhpcy5nZXRDdXJyZW50VXNlcigpLHE9bnVsbCE9bT9tLmlkOiJ1bmtub3duIjtFZGl0b3JVaS5sb2dFcnJvcigiRXJyb3IgaW4gZmlsZVNhdmVkIixudWxsLHRoaXMuZ2V0TW9kZSgpKyIuIit0aGlzLmdldElkKCkscSxiKX19Y2F0Y2goZSl7fX19OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5hdXRvc2F2ZT1mdW5jdGlvbihhLGMsZixkKXtudWxsPT10aGlzLmxhc3RBdXRvc2F2ZSYmKHRoaXMubGFzdEF1dG9zYXZlPURhdGUubm93KCkpO2E9RGF0ZS5ub3coKS10aGlzLmxhc3RBdXRvc2F2ZTxjP2E6MDt0aGlzLmNsZWFyQXV0b3NhdmUoKTt2YXIgaz13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubGFzdEF1dG9zYXZlPW51bGw7dGhpcy5hdXRvc2F2ZVRocmVhZD09ayYmKHRoaXMuYXV0b3NhdmVUaHJlYWQ9bnVsbCk7aWYodGhpcy5pc01vZGlmaWVkKCkmJnRoaXMuaXNBdXRvc2F2ZU5vdygpKXt2YXIgYT10aGlzLmlzQXV0b3NhdmVSZXZpc2lvbigpO2EmJih0aGlzLmxhc3RBdXRvc2F2ZVJldmlzaW9uPShuZXcgRGF0ZSkuZ2V0VGltZSgpKTt0aGlzLnNhdmUoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmF1dG9zYXZlQ29tcGxldGVkKCk7bnVsbCE9ZiYmZihhKX0pLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhKXtudWxsIT1kJiZkKGEpfSkpfWVsc2UgdGhpcy5pc01vZGlmaWVkKCl8fHRoaXMudWkuZWRpdG9yLnNldFN0YXR1cygiIiksbnVsbCE9ZiYmZihudWxsKX0pLGEpO3RoaXMuYXV0b3NhdmVUaHJlYWQ9a307RHJhd2lvRmlsZS5wcm90b3R5cGUuaXNBdXRvc2F2ZU5vdz1mdW5jdGlvbigpe3JldHVybiEwfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5hdXRvc2F2ZUNvbXBsZXRlZD1mdW5jdGlvbigpe307RHJhd2lvRmlsZS5wcm90b3R5cGUuY2xlYXJBdXRvc2F2ZT1mdW5jdGlvbigpe251bGwhPXRoaXMuYXV0b3NhdmVUaHJlYWQmJih3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuYXV0b3NhdmVUaHJlYWQpLHRoaXMuYXV0b3NhdmVUaHJlYWQ9bnVsbCl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5pc0F1dG9zYXZlUmV2aXNpb249ZnVuY3Rpb24oKXt2YXIgYT0obmV3IERhdGUpLmdldFRpbWUoKTtyZXR1cm4gbnVsbD09dGhpcy5sYXN0QXV0b3NhdmVSZXZpc2lvbnx8YS10aGlzLmxhc3RBdXRvc2F2ZVJldmlzaW9uPnRoaXMubWF4QXV0b3NhdmVSZXZpc2lvbkRlbGF5fTtEcmF3aW9GaWxlLnByb3RvdHlwZS5kZXNjcmlwdG9yQ2hhbmdlZD1mdW5jdGlvbigpe3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJkZXNjcmlwdG9yQ2hhbmdlZCIpKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuY29udGVudENoYW5nZWQ9ZnVuY3Rpb24oKXt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY29udGVudENoYW5nZWQiKSl9OwpEcmF3aW9GaWxlLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZUZpbGVEYXRhKCk7dGhpcy5zdGF0cy5jbG9zZWQrKzt0aGlzLmlzQXV0b3NhdmUoKSYmdGhpcy5pc01vZGlmaWVkKCkmJnRoaXMuc2F2ZSh0aGlzLmlzQXV0b3NhdmVSZXZpc2lvbigpLG51bGwsbnVsbCxhKTt0aGlzLmRlc3Ryb3koKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuaGFzU2FtZUV4dGVuc2lvbj1mdW5jdGlvbihhLGMpe2lmKG51bGwhPWEmJm51bGwhPWMpe3ZhciBmPWEubGFzdEluZGV4T2YoIi4iKSxkPTA8Zj9hLnN1YnN0cmluZyhmKToiIixmPWMubGFzdEluZGV4T2YoIi4iKTtyZXR1cm4gZD09PSgwPGY/Yy5zdWJzdHJpbmcoZik6IiIpfXJldHVybiBhPT1jfTsKRHJhd2lvRmlsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXJzPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5jaGFuZ2VMaXN0ZW5lciYmKHRoaXMudWkuZWRpdG9yLmdyYXBoLm1vZGVsLnJlbW92ZUxpc3RlbmVyKHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkuZWRpdG9yLmdyYXBoLnJlbW92ZUxpc3RlbmVyKHRoaXMuY2hhbmdlTGlzdGVuZXIpLHRoaXMudWkucmVtb3ZlTGlzdGVuZXIodGhpcy5jaGFuZ2VMaXN0ZW5lciksdGhpcy5jaGFuZ2VMaXN0ZW5lcj1udWxsKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuc3RhdHMuZGVzdHJveWVkKys7dGhpcy5jbGVhckF1dG9zYXZlKCk7dGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtudWxsIT10aGlzLnN5bmMmJih0aGlzLnN5bmMuZGVzdHJveSgpLHRoaXMuc3luYz1udWxsKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuY29tbWVudHNTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07CkRyYXdpb0ZpbGUucHJvdG90eXBlLmNvbW1lbnRzUmVmcmVzaE5lZWRlZD1mdW5jdGlvbigpe3JldHVybiEwfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5jb21tZW50c1NhdmVOZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07RHJhd2lvRmlsZS5wcm90b3R5cGUuZ2V0Q29tbWVudHM9ZnVuY3Rpb24oYSxjKXthKFtdKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuYWRkQ29tbWVudD1mdW5jdGlvbihhLGMsZil7YyhEYXRlLm5vdygpKX07RHJhd2lvRmlsZS5wcm90b3R5cGUuY2FuUmVwbHlUb1JlcGxpZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMH07RHJhd2lvRmlsZS5wcm90b3R5cGUuY2FuQ29tbWVudD1mdW5jdGlvbigpe3JldHVybiEwfTtEcmF3aW9GaWxlLnByb3RvdHlwZS5uZXdDb21tZW50PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG5ldyBEcmF3aW9Db21tZW50KHRoaXMsbnVsbCxhLERhdGUubm93KCksRGF0ZS5ub3coKSwhMSxjKX07TG9jYWxGaWxlPWZ1bmN0aW9uKGEsYyxmLGQpe0RyYXdpb0ZpbGUuY2FsbCh0aGlzLGEsYyk7dGhpcy50aXRsZT1mO3RoaXMubW9kZT1kP251bGw6QXBwLk1PREVfREVWSUNFfTtteFV0aWxzLmV4dGVuZChMb2NhbEZpbGUsRHJhd2lvRmlsZSk7TG9jYWxGaWxlLnByb3RvdHlwZS5pc0F1dG9zYXZlPWZ1bmN0aW9uKCl7cmV0dXJuITF9O0xvY2FsRmlsZS5wcm90b3R5cGUuZ2V0TW9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGV9O0xvY2FsRmlsZS5wcm90b3R5cGUuZ2V0VGl0bGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aXRsZX07TG9jYWxGaWxlLnByb3RvdHlwZS5pc1JlbmFtYWJsZT1mdW5jdGlvbigpe3JldHVybiEwfTtMb2NhbEZpbGUucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oYSxjLGYpe3RoaXMuc2F2ZUFzKHRoaXMudGl0bGUsYyxmKX07TG9jYWxGaWxlLnByb3RvdHlwZS5zYXZlQXM9ZnVuY3Rpb24oYSxjLGYpe3RoaXMuc2F2ZUZpbGUoYSwhMSxjLGYpfTsKTG9jYWxGaWxlLnByb3RvdHlwZS5zYXZlRmlsZT1mdW5jdGlvbihhLGMsZixkKXt0aGlzLnRpdGxlPWE7dGhpcy51cGRhdGVGaWxlRGF0YSgpO2M9dGhpcy5nZXREYXRhKCk7dmFyIGs9dGhpcy51aS51c2VDYW52YXNGb3JFeHBvcnQmJi8oXC5wbmcpJC9pLnRlc3QodGhpcy5nZXRUaXRsZSgpKSxtPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpe2lmKHRoaXMudWkuaXNPZmZsaW5lQXBwKCl8fHRoaXMudWkuaXNMb2NhbEZpbGVTYXZlKCkpdGhpcy51aS5kb1NhdmVMb2NhbEZpbGUoYyxhLGs/ImltYWdlL3BuZyI6InRleHQveG1sIixrKTtlbHNlIGlmKGMubGVuZ3RoPE1BWF9SRVFVRVNUX1NJWkUpe3ZhciBiPWEubGFzdEluZGV4T2YoIi4iKSxiPTA8Yj9hLnN1YnN0cmluZyhiKzEpOiJ4bWwiOyhuZXcgbXhYbWxSZXF1ZXN0KFNBVkVfVVJMLCJmb3JtYXQ9IitiKyImeG1sPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKyImZmlsZW5hbWU9IitlbmNvZGVVUklDb21wb25lbnQoYSkrCihrPyImYmluYXJ5PTEiOiIiKSkpLnNpbXVsYXRlKGRvY3VtZW50LCJfYmxhbmsiKX1lbHNlIHRoaXMudWkuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJkcmF3aW5nVG9vTGFyZ2UiKX0sbXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bXhVdGlscy5wb3B1cChjKX0pKTt0aGlzLnNldE1vZGlmaWVkKCExKTt0aGlzLmNvbnRlbnRDaGFuZ2VkKCk7bnVsbCE9ZiYmZigpfSk7az8oYz10aGlzLnVpLmdldFBuZ0ZpbGVQcm9wZXJ0aWVzKHRoaXMudWkuZmlsZU5vZGUpLHRoaXMudWkuZ2V0RW1iZWRkZWRQbmcobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bShhKX0pLGQsdGhpcy51aS5nZXRDdXJyZW50RmlsZSgpIT10aGlzP3RoaXMuZ2V0RGF0YSgpOm51bGwsYy5zY2FsZSxjLmJvcmRlcikpOm0oYyl9OwpMb2NhbEZpbGUucHJvdG90eXBlLnJlbmFtZT1mdW5jdGlvbihhLGMsZil7dGhpcy50aXRsZT1hO3RoaXMuZGVzY3JpcHRvckNoYW5nZWQoKTtudWxsIT1jJiZjKCl9O0xvY2FsRmlsZS5wcm90b3R5cGUub3Blbj1mdW5jdGlvbigpe3RoaXMudWkuc2V0RmlsZURhdGEodGhpcy5nZXREYXRhKCkpO3RoaXMuaW5zdGFsbExpc3RlbmVycygpfTsoZnVuY3Rpb24oKXtFZGl0b3IucHJvdG90eXBlLmFwcE5hbWU9ImRpYWdyYW1zLm5ldCI7RWRpdG9yLnByb3RvdHlwZS5kaWFncmFtRmlsZVR5cGVzPVt7ZGVzY3JpcHRpb246ImRpYWdyYW1YbWxEZXNjIixleHRlbnNpb246ImRyYXdpbyJ9LHtkZXNjcmlwdGlvbjoiZGlhZ3JhbVBuZ0Rlc2MiLGV4dGVuc2lvbjoicG5nIn0se2Rlc2NyaXB0aW9uOiJkaWFncmFtU3ZnRGVzYyIsZXh0ZW5zaW9uOiJzdmcifSx7ZGVzY3JpcHRpb246ImRpYWdyYW1IdG1sRGVzYyIsZXh0ZW5zaW9uOiJodG1sIn0se2Rlc2NyaXB0aW9uOiJkaWFncmFtWG1sRGVzYyIsZXh0ZW5zaW9uOiJ4bWwifV07RWRpdG9yLnByb3RvdHlwZS5saWJyYXJ5RmlsZVR5cGVzPVt7ZGVzY3JpcHRpb246IkxpYnJhcnkgKC5kcmF3aW9saWIsIC54bWwpIixleHRlbnNpb25zOlsiZHJhd2lvbGliIiwieG1sIl19XTtFZGl0b3IucHJvdG90eXBlLmZpbGVFeHRlbnNpb25zPVt7ZXh0OiJodG1sIix0aXRsZToiZmlsZXR5cGVIdG1sIn0sCntleHQ6InBuZyIsdGl0bGU6ImZpbGV0eXBlUG5nIn0se2V4dDoic3ZnIix0aXRsZToiZmlsZXR5cGVTdmcifV07RWRpdG9yLmNsb3NlSW1hZ2U9bXhDbGllbnQuSVNfU1ZHPyJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJrQUFBQVpDQU1BQUFEek4zVlJBQUFBcFZCTVZFVUFBQUQvLy8vazVPVC8vLzhBQUFCMWRYWE16TXo5L2YzOS9mMzcrL3Y1K2ZuKy92Ny8vLzlpWW1KYVdscUZoWVducDZlam82T0hoNGYvLy8vLy8vLy8vLy8vLy8vNysvdjUrZm54OGZILy8vOEFBQUQvLy84Ykd4djcrL3Y1K2Zrb0tDZ2hJU0ZEUTBNWUdCamg0ZUhZMk5qYjI5dFFVRkJ2YjI5SFIwYy9QejgyTmpZckt5dS92NzhTRWhMdTd1N3M3T3pWMWRWVlZWVTdPenNWRlJYQXY3OFFFQkJ6cWVoTUFBQUFHM1JTVGxNQUEvN3Avdno1eFpsclRpUEwvdjc4Ky92NytPWGQyVFlRRHM4TDcwWmJBQUFCS1VsRVFWUW96M1ZTMTNMQ01CQlVYSENoZDhpdWtEc2xRQ2hKL3YvVGNoYUc0Y1hTK09TYjFjN3RyVTdWNjBPcGRSejJadE5aTDR6WE5sY044QkV0U0c2K054SVhrZVJQb0J1UTFjanZaMzEvVkpGQjEwSVNsaTZkaVlmSDhpWU8zV1VOQ2NObEIwZ1RyWE90a3hUbzBPMWFLS2lCQk1oaHYyTU5CUUtvaUE1d3hsWm8wSkR6RDNBWUtiV2FjeWozZnMwMXd4ZXkwcHlFUCtSOHBXS1dYb3F0SVowRERnNXBia2k5a3JFS09hNkxWRFFzZG9YRXNpNDZacWg2OUtGejdCMXU3SGIyeURWOGZpclhES0JsWjRVRmlzd0tHUmhYVFM5My9FQ0s3eXhuSjMrUzN5L1RocE8rY2ZTRDAxN25xYTE4YWFzYWJVMC90N2QrdGswLzFvTUVKMU5hRDY3aXdkRjY4T2FiRlNMbitlSGIwK3ZqeSt1azhicjlmZHJmdEgwTzJtZW5mZDcrQVFmWU0vbE5qb0RIQUFBQUFFbEZUa1N1UW1DQyI6CklNQUdFX1BBVEgrIi9kZWxldGUucG5nIjtFZGl0b3IucGx1c0ltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBb0FBQUFLQ0FZQUFBQ05Ncys5QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5SnBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU1DMWpNRFl3SURZeExqRXpORGMzTnl3Z01qQXhNQzh3TWk4eE1pMHhOem96TWpvd01DQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTlROU0JOWVdOcGJuUnZjMmdpSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TURkQ01UZEVOalZDT0VNNE1URkZORGxDUmpWQk5EZENPRFU1TmpOQk5VTWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZNRGRDTVRkRU5qWkNPRU00TVRGRk5EbENSalZCTkRkQ09EVTVOak5CTlVNaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3dOMEl4TjBRMk0wSTRRemd4TVVVME9VSkdOVUUwTjBJNE5UazJNMEUxUXlJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRvd04wSXhOMFEyTkVJNFF6Z3hNVVUwT1VKR05VRTBOMEk0TlRrMk0wRTFReUl2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUHRqcmptZ0FBQUF0U1VSQlZIamFZdnovL3o4RE1pZ3ZMd2NMZEhaMk1pS0xNekVRQ2FpdmtMR3NyT3cvZFUwY0FyNEdDREFBUlFzUWJURnJ2MTBBQUFBQVNVVk9SSzVDWUlJPSI6CklNQUdFX1BBVEgrIi9wbHVzLnBuZyI7RWRpdG9yLnNwaW5JbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaERBQU1BUFV4QUVWcmlWcDdsbUNBbW1HQm0yT0NuR21IbjNPUHBuZVNxWUticjRPY3NJU2NzSTJrdG82a3Q0Nmx0NUtudVptdHZwcXV2cHV2djU2eXdhQ3p3cUsxeEt1N3lheTl5cSsvekxIQXpiZkYwYmpHMGJ6SjFMeksxTUROMThqVDI4blQzTTNYM3RIYTRkVGM0OVhkNU5qZjVkbmc1dDNrNmQvbDZ1RG02dXJ1OGU3eDgvRHo5ZlQyOS9iNCtQajUrZmo1K3ZyNit2Ly8vd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDSDVCQWtLQURFQUlmOExUa1ZVVTBOQlVFVXlMakFEQVFBQUFDd0FBQUFBREFBTUFBQUdSOENZY0Vnc09nWUFJYXg0Q0NRdVFsZHJDQkVzaUs4VlMyaG9GR09ybEpEQStjWlF3a0xucXlvSkZaS3ZpU1MwSUNyRTBlYzBqREF3SWlVZUd5QkZHaE1QRkJraFpvMUJBQ0g1QkFrS0FDNEFMQUFBQUFBTUFBd0FoVkIwa0ZSM2sxVjRrMkNBbW1XRW5XNkxvM0tPcFhlU3FIMlhySU9jc0lTZHNJbWh0SXFodEpDbXVKR251WnV3djUyd3dKK3l3Wit5d3FtNnlMSEJ6YkxDenJYRXo3ZkYwTG5IMHJySTByN0wxYi9NMXNYUjJjZlQyOHJWM2N6VzNzL1o0TmZlNU52aTZPRG02dUxuNitMbjdPTG83T1hxN2Vmczcrenc4dS95OVBEeTlQWDMrUHI3Ky8vLy93QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaRFFKZHdTQ3hHREFJQW9WRmtGQndZU3lJd0dFNE9rQ0p4SWRHNldrSkV4OHNTS2o3ZWxmQkIwYTVTUWcxRVEwU1ZWTVBLaERNNmlVSWtSUjRaRnhzZ0psNkpRUUFoK1FRSkNnQXhBQ3dBQUFBQURBQU1BSVZHYTRsY2ZaZGpncHhrZzUxbmhwNXVpNk4za3FoNWxLcUZuYkdIbjdLSW9MT1FwN2lScDdtU3FMbVRxYnFhcnI2YnI3K2Zzc0dpdGNPaXRjU3V2c3V1djh1d3dNeXp3ODYxeE5DNXg5SzZ4OUsvek5iRHp0akUwTm5HMGRySjFOelEyZURTMitMVDIrTFYzZVBaNE9iYTRlYmI0dWZjNCtqbTYrN3Q4UEx0OFBQdDhmUHg4L1h4OVBYMDl2ZjE5L2ozK1BuLy8vOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1E4Q1ljRWdzVWhRRmdnRlNqQ1FtbkUxamNCaHFHQlhpSXVBUVNpN0ZHRUlnZkl6Q0ZvQ1hGQ1ppUE8waEtCTWl3bDdFVDZlVVlxbFdMa1VuSVNJbUtDMXhiVUVBSWZrRUNRb0FNZ0FzQUFBQUFBd0FEQUNGVG5LUFQzS1BWSGFUWW9LY2I0eWpjWTZsZVpTcGY1bXRnWnV2aDUreWlxRzBpNksxanFXM2thZTVuckhCbnJMQm43TENvTFBDb2JURHFicklxcnZJczhMT3RNUFB0Y1BQdGNUUHVNYlJ1Y2ZTdmNyVXZzdlZ3TXpXeGRIYXlkVGN5dFhkek5iZXpkZmYwZHJoMk9EbDIrTG4zZVRwNE9icTR1anM1T250NXV2dTZPM3c2dTd3NnU3eDcvTDA5dmo1K3ZyNyt2djcvLy8vQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJrZEFtWEJJTEhJY2ljT0NVcXhFTEtLUHhLQVlnaVlkNG9NQUVXbzhSVm1qSU1TY3dobUJjSk1LWHdMQ0VDbU1HQWhQSTFRUndCaWFTaXhDTURGaExTb3JMaTh3WVl4Q1FRQWgrUVFKQ2dBeEFDd0FBQUFBREFBTUFJVlplcFZnZ0pwaGdadG5ocDV2aktOMmthaDNrcW1CbXErS29iU0xvcldOcExhUnA3bVdxN3licjcrZ3M4S2l0Y1NrdHNXbnVNYW51Y2V4d00yeXdjNjN4dEc2eU5POXl0Uyt5dFcvek5iRHo5akgwdHZMMWQzTjE5N1MyK0xVM09QVTNlUFYzZVRYMytYYTRlZmI0dWZkNU9ubDZ1N3I3dkhzNy9MdDhQTHc4L1h5OVBieTlmYjA5ZmYyK1BuMytQbjYrdnIvLy84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHU01DWWNFZ3NlaXdTUitSUzdHQTRKRkdGOFJpV05pRWlKVEVSZ2tqRkdBUWgvS1RDR29Kd3BBcG5Ca0lUS3J3b0NGV25GbEVoYUF4WExDOUNCd0FHUlM0d1FnRUxZWTFDUVFBaCtRUUpDZ0F6QUN3QUFBQUFEQUFNQUlWTWNJNVNkWkZoZ1p0dGk2SndqYVI0azZtQW1hNkNtNitLb2JTTG9yV0xvN1dObzdhUHByZWRzTUNlc2NHaXRNT2l0Y1NtdU1hcXU4aXh3YzJ6d3M2M3hkQzR4dEc1eDlLOXl0WEF6ZGZDenRqRjBObkYwZHJLMWQzTTF0N1AyTi9QMmVEVDIrTFgzK1hlNU9uaDUrdmk1K3ZqNk96azZlM243Ty9vN08vcTd2SHM3L0x0OFBQdThmUHg4L1gzK1BuNit2djcrL3Y4L1B6Ly8vOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdSY0NaY0Vnc21rSWJUT1pUTElsR3FaTm5jaG0yU0NnaUo2SVJxbGpGbVFVaVhJVm5vSVRRZGU0Y2hDOVkrTEVReG1URlJrRlNORkFxREFNSVJRb0NBQUVFRG1lTFFRQWgrUVFKQ2dBd0FDd0FBQUFBREFBTUFJVlhlWlJlZnBsZmY1bGhnWnRwaDU5eWpxVjJrYWVBbXE2Rm5iR0ZuckdMb3JXTnBMYVFwN21ScUxtWXJiMmVzc0dnczhLbHQ4YXB1c2l0dmNxdXY4dTJ4TkM3eU5POHlkUzh5dFRBemRmQnpkZk0xdDdOMTk3UTJlRFUzT1BYMytYWjRPYlo0ZWJjNCtqZjVlcmc1ZXJnNXV2cDdmRHU4ZlB2OHZUejlmYjA5dmYxOS9qMytQbjQrZm41K3ZyNisvdi8vLzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHUlVDWWNFZ3Nwa3dqRUtoVVZKMVFzQk5wMHhtMlZpeGlTT01Sdmx4RkdBY1RKb29rNWVFSEloUWN3cFdJa0FGUUVDa055OUFRV0Z3eUVBa1BSUTRGQXdRSUUybGxRUUFoK1FRSkNnQXZBQ3dBQUFBQURBQU1BSVZOY1k1U2RaRmlncHRwaDZCdmpLTjBrS2Q4bHF1QW1xK0VuYkdHbjdLSG43T05wTGFPcGJlYXJyK2NzTUNkc2NDZXNjR2h0TU9udU1hdXZzdXp3czYwdzg2MnhkQzl5dFcveTlhL3pOYkN6dGpHMGRySDB0dksxTjNNMXQ3TjE5L1UzZVBiNHVmZjV1cmo2T3prNmUzbDZ1N202dTdvN1BEcTd2RHQ4UFB2OHZUdzh2VHc4L1gxOXZmNit2di8vLzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1E4Q1hjRWdzdmx5dFZVcGxKTEpJcFNFRFVFU0ZURUxCd1NnQ0NRRVY0MmtqREZpTW80dVFzREIyTWtMSG9FSFVURDdEUkFIQzhWQWlaMFFTQ2dZSUR4aE5pVUVBT3c9PSI6CklNQUdFX1BBVEgrIi9zcGluLmdpZiI7RWRpdG9yLmdsb2JlSW1hZ2U9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1URXVPVGtnTWtNMkxqUTNJRElnTWlBMkxqUTRJRElnTVRKek5DNDBOeUF4TUNBNUxqazVJREV3UXpFM0xqVXlJREl5SURJeUlERTNMalV5SURJeUlERXlVekUzTGpVeUlESWdNVEV1T1RrZ01ucHROaTQ1TXlBMmFDMHlMamsxWXkwdU16SXRNUzR5TlMwdU56Z3RNaTQwTlMweExqTTRMVE11TlRZZ01TNDROQzQyTXlBekxqTTNJREV1T1RFZ05DNHpNeUF6TGpVMmVrMHhNaUEwTGpBMFl5NDRNeUF4TGpJZ01TNDBPQ0F5TGpVeklERXVPVEVnTXk0NU5tZ3RNeTQ0TW1NdU5ETXRNUzQwTXlBeExqQTRMVEl1TnpZZ01TNDVNUzB6TGprMmVrMDBMakkySURFMFF6UXVNU0F4TXk0ek5pQTBJREV5TGpZNUlEUWdNVEp6TGpFdE1TNHpOaTR5TmkweWFETXVNemhqTFM0d09DNDJOaTB1TVRRZ01TNHpNaTB1TVRRZ01pQXdJQzQyT0M0d05pQXhMak0wTGpFMElESklOQzR5Tm5wdExqZ3lJREpvTWk0NU5XTXVNeklnTVM0eU5TNDNPQ0F5TGpRMUlERXVNemdnTXk0MU5pMHhMamcwTFM0Mk15MHpMak0zTFRFdU9TMDBMak16TFRNdU5UWjZiVEl1T1RVdE9FZzFMakE0WXk0NU5pMHhMalkySURJdU5Ea3RNaTQ1TXlBMExqTXpMVE11TlRaRE9DNDRNU0ExTGpVMUlEZ3VNelVnTmk0M05TQTRMakF6SURoNlRURXlJREU1TGprMll5MHVPRE10TVM0eUxURXVORGd0TWk0MU15MHhMamt4TFRNdU9UWm9NeTQ0TW1NdExqUXpJREV1TkRNdE1TNHdPQ0F5TGpjMkxURXVPVEVnTXk0NU5ucE5NVFF1TXpRZ01UUklPUzQyTm1NdExqQTVMUzQyTmkwdU1UWXRNUzR6TWkwdU1UWXRNaUF3TFM0Mk9DNHdOeTB4TGpNMUxqRTJMVEpvTkM0Mk9HTXVNRGt1TmpVdU1UWWdNUzR6TWk0eE5pQXlJREFnTGpZNExTNHdOeUF4TGpNMExTNHhOaUF5ZW0wdU1qVWdOUzQxTm1NdU5pMHhMakV4SURFdU1EWXRNaTR6TVNBeExqTTRMVE11TlRab01pNDVOV010TGprMklERXVOalV0TWk0ME9TQXlMamt6TFRRdU16TWdNeTQxTm5wTk1UWXVNellnTVRSakxqQTRMUzQyTmk0eE5DMHhMak15TGpFMExUSWdNQzB1TmpndExqQTJMVEV1TXpRdExqRTBMVEpvTXk0ek9HTXVNVFl1TmpRdU1qWWdNUzR6TVM0eU5pQXljeTB1TVNBeExqTTJMUzR5TmlBeWFDMHpMak00ZWlJdlBqd3ZjM1puUGc9PSI7CkVkaXRvci5jb21tZW50SW1hZ2U9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1qRXVPVGtnTkdNd0xURXVNUzB1T0RrdE1pMHhMams1TFRKSU5HTXRNUzR4SURBdE1pQXVPUzB5SURKMk1USmpNQ0F4TGpFdU9TQXlJRElnTW1neE5HdzBJRFF0TGpBeExURTRlazB4T0NBeE5FZzJkaTB5YURFeWRqSjZiVEF0TTBnMlZqbG9NVEoyTW5wdE1DMHpTRFpXTm1neE1uWXllaUl2UGp4d1lYUm9JR1E5SWswd0lEQm9NalIyTWpSSU1Ib2lJR1pwYkd3OUltNXZibVVpTHo0OEwzTjJaejQ9IjtFZGl0b3IuY29tbWVudEltYWdlSW52ZXJ0ZWQ9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBZ0NBWUFBQUJ6ZW5yMEFBQUJMRWxFUVZSWVIrMld2eTRGUVJqRmY0ZElOQXE5WHF0U2FWUnFYQXJQSU5Fb2RVcWxoeEM1L3BVNm5ZZFFTSFFlUVRSSE50bVZ1WHVYckl4djFrMXNONXZNT2I4NWM3NWt4TUNmQnZabkNzRDJFckFHekFmQXZVdDZUSFVuQUd3ZkFXZkFRb0I1STNraDZhQlpmQUxZWGdHZWc4MGIzMVZKVDlVaUJSZ0I0OENUcDlMYmt1N2FBUHZBWlNHQUhVbTNzd0VnS1d0VWJic2oxZjRKREE0QWJHYjI0aUVyZ1V6enI3YnZTcnJwVmNLZ0s1Z2hnS0FPOUUvZ3Z3TkJKUnhKdXU0MUJVRWQrQkZBUkEzK0pzQVdjQjl4M0E3TnpnU3F0K0FMc0Z3QVlocWdNclc5VWI4SjE0RzVRSkJ1Z0FoRDJ5ZkFhVXQ3VDlMVnhCaEdtRGVhdG8vclpKdGZaUUhxNjAwaHlnUFVFSWZBT1RBTVFBTHhXclFEN1g3WlhwVDBWcXlFM3hVODY4bjlHNVB6QVNQdnBpSGF2QkFVQUFBQUFFbEZUa1N1UW1DQyI7CkVkaXRvci51c2VySW1hZ2U9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1USWdNVEpqTWk0eU1TQXdJRFF0TVM0M09TQTBMVFJ6TFRFdU56a3ROQzAwTFRRdE5DQXhMamM1TFRRZ05DQXhMamM1SURRZ05DQTBlbTB3SURKakxUSXVOamNnTUMwNElERXVNelF0T0NBMGRqSm9NVFoyTFRKak1DMHlMalkyTFRVdU16TXROQzA0TFRSNklpOCtQQzl6ZG1jKyI7RWRpdG9yLnNoYXJlSW1hZ2U9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1UZ2dNVFl1TURoakxTNDNOaUF3TFRFdU5EUXVNeTB4TGprMkxqYzNURGd1T1RFZ01USXVOMk11TURVdExqSXpMakE1TFM0ME5pNHdPUzB1TjNNdExqQTBMUzQwTnkwdU1Ea3RMamRzTnk0d05TMDBMakV4WXk0MU5DNDFJREV1TWpVdU9ERWdNaTR3TkM0NE1TQXhMalkySURBZ015MHhMak0wSURNdE0zTXRNUzR6TkMwekxUTXRNeTB6SURFdU16UXRNeUF6WXpBZ0xqSTBMakEwTGpRM0xqQTVMamRNT0M0d05DQTVMamd4UXpjdU5TQTVMak14SURZdU56a2dPU0EySURsakxURXVOallnTUMweklERXVNelF0TXlBemN6RXVNelFnTXlBeklETmpMamM1SURBZ01TNDFMUzR6TVNBeUxqQTBMUzQ0TVd3M0xqRXlJRFF1TVRaakxTNHdOUzR5TVMwdU1EZ3VORE10TGpBNExqWTFJREFnTVM0Mk1TQXhMak14SURJdU9USWdNaTQ1TWlBeUxqa3lJREV1TmpFZ01DQXlMamt5TFRFdU16RWdNaTQ1TWkweUxqa3ljeTB4TGpNeExUSXVPVEl0TWk0NU1pMHlMamt5ZWlJdlBqd3ZjM1puUGc9PSI7CkVkaXRvci5zeW5jSW1hZ2U9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1USWdORll4VERnZ05XdzBJRFJXTm1NekxqTXhJREFnTmlBeUxqWTVJRFlnTmlBd0lERXVNREV0TGpJMUlERXVPVGN0TGpjZ01pNDRiREV1TkRZZ01TNDBOa014T1M0MU5DQXhOUzR3TXlBeU1DQXhNeTQxTnlBeU1DQXhNbU13TFRRdU5ESXRNeTQxT0MwNExUZ3RPSHB0TUNBeE5HTXRNeTR6TVNBd0xUWXRNaTQyT1MwMkxUWWdNQzB4TGpBeExqSTFMVEV1T1RjdU55MHlMamhNTlM0eU5DQTNMamMwUXpRdU5EWWdPQzQ1TnlBMElERXdMalF6SURRZ01USmpNQ0EwTGpReUlETXVOVGdnT0NBNElEaDJNMncwTFRRdE5DMDBkak42SWk4K1BDOXpkbWMrIjtFZGl0b3Iuc3luY0Rpc2FibGVkSW1hZ2U9CiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NVEFnTmk0ek5WWTBMakkyWXkwdU9DNHlNUzB4TGpVMUxqVTBMVEl1TWpNdU9UWnNNUzQwTmlBeExqUTJZeTR5TlMwdU1USXVOUzB1TWpRdU56Y3RMak16ZW0wdE55NHhOQzB1T1RSc01pNHpOaUF5TGpNMlF6UXVORFVnT0M0NU9TQTBJREV3TGpRMElEUWdNVEpqTUNBeUxqSXhMamt4SURRdU1pQXlMak0ySURVdU5qUk1OQ0F5TUdnMmRpMDJiQzB5TGpJMElESXVNalJETmk0Mk9DQXhOUzR4TlNBMklERXpMalkySURZZ01USmpNQzB4SUM0eU5TMHhMamswTGpZNExUSXVOemRzT0M0d09DQTRMakE0WXkwdU1qVXVNVE10TGpVdU1qVXRMamMzTGpNMGRqSXVNRGxqTGpndExqSXhJREV1TlRVdExqVTBJREl1TWpNdExqazJiREl1TXpZZ01pNHpOaUF4TGpJM0xURXVNamRNTkM0eE5DQTBMakUwSURJdU9EWWdOUzQwTVhwTk1qQWdOR2d0Tm5ZMmJESXVNalF0TWk0eU5FTXhOeTR6TWlBNExqZzFJREU0SURFd0xqTTBJREU0SURFeVl6QWdNUzB1TWpVZ01TNDVOQzB1TmpnZ01pNDNOMnd4TGpRMklERXVORFpETVRrdU5UVWdNVFV1TURFZ01qQWdNVE11TlRZZ01qQWdNVEpqTUMweUxqSXhMUzQ1TVMwMExqSXRNaTR6TmkwMUxqWTBUREl3SURSNklpOCtQQzl6ZG1jKyI7CkVkaXRvci5zeW5jUHJvYmxlbUltYWdlPSJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NeUF4TW1Nd0lESXVNakV1T1RFZ05DNHlJREl1TXpZZ05TNDJORXd6SURJd2FEWjJMVFpzTFRJdU1qUWdNaTR5TkVNMUxqWTRJREUxTGpFMUlEVWdNVE11TmpZZ05TQXhNbU13TFRJdU5qRWdNUzQyTnkwMExqZ3pJRFF0TlM0Mk5WWTBMakkyUXpVdU5UVWdOUzR4TlNBeklEZ3VNamNnTXlBeE1ucHRPQ0ExYURKMkxUSm9MVEoyTW5wTk1qRWdOR2d0Tm5ZMmJESXVNalF0TWk0eU5FTXhPQzR6TWlBNExqZzFJREU1SURFd0xqTTBJREU1SURFeVl6QWdNaTQyTVMweExqWTNJRFF1T0RNdE5DQTFMalkxZGpJdU1EbGpNeTQwTlMwdU9Ea2dOaTAwTGpBeElEWXROeTQzTkNBd0xUSXVNakV0TGpreExUUXVNaTB5TGpNMkxUVXVOalJNTWpFZ05IcHRMVEV3SURsb01sWTNhQzB5ZGpaNklpOCtQQzl6ZG1jKyI7CkVkaXRvci50d2VldEltYWdlPUlNQUdFX1BBVEgrIi90d2VldC5wbmciO0VkaXRvci5mYWNlYm9va0ltYWdlPUlNQUdFX1BBVEgrIi9mYWNlYm9vay5wbmciO0VkaXRvci5ibGFua0ltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBQ2tsRVFWUjRuR01BQVFBQUJRQUJEUW90dEFBQUFBQkpSVTVFcmtKZ2dnPT0iO0VkaXRvci5oaVJlc0ltYWdlPW14Q2xpZW50LklTX1NWRz8iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGQUFBQUErQ0FNQUFBQ0xNV3kxQUFBQWgxQk1WRVVBQUFCTVRFeEVSRVJCUVVGQlFVRkZSVVZBUUVCQ1FrSkFRRUE2T2pwRFEwTktTa3BCUVVGQlFVRkVSRVJFUkVSQlFVRkNRa0pDUWtKQ1FrSkpTVWxCUVVGQ1FrSkRRME5EUTBOQ1FrSkRRME5CUVVGQlFVRkNRa0pCUVVGQ1FrSkNRa0pEUTBOQ1FrSkhSMGRCUVVGQ1FrSkNRa0pBUUVCQ1FrSkRRME5BUUVCRVJFUkNRa0lrMWhTMkFBQUFLblJTVGxNQUFqajk2Qkw3UGdRRlJ3ZnUzVFlhekt1VmpSWGwxVjFEUENuMXVMR2puV05WSWd5OWhVNDBlR3FQa00zOEFBQUNHMGxFUVZSWXcrMlg2M0tiTUJDRnp3WmJsZ0dEY2VONzRtdWF0cExlLy9tNk1IVjNnSEdGQXYyUmpNOTRNQWJ4emRuVnNRYkJES3dIOEFIOE1EQXlhZnpqcVlleU9HMDRYRTdSUzhuSVJEWGc2QmxUK3JBMG5tdEFQaCtOUVJEeElBU0lNRzQ0ckFNckd1bkJnSHd5M3VVbGR4Z2dJU3RHS3AyZitEUWMyTzRoNGVRc1gzTzJJRkIvb0Vic2pPS2JTdG5qQUVBK3pKMHlsWlRiZ3ZvRG44eE55bjZEYmo1S2Q0R3NOcEFCYTZkdVFQZlNkRWo4OFRnTUFoS3VDV2pBa2dtRlhQTG5zRDBwV2QzT0ZHZHJNdWdRSUkvZU9NUEVpR096cVBNSWVXcmNTb01DZzcxVzFwWEJQdkNQK2dTL09kWHFRM3VXMjMrOTNYR1dMbC9PYUJiODA1Yk5jQlBvRUljVkpzbkh6Y3hwWkg4NnU1S1o5Z0RieTVkUUNjbktxZGJrZTRJdEk0VHpkN0lXOWhaUXQ0RU82R0c5YjlzWXV1SzlXd244VElyMnhLYkYyKzNOaHIrcXhDaEovQUk2cElmQ3U0ejRab3dwNFpVTmloejc5dmV3emN0bkhEd1R2UU8vaENkRkJ6clVHRE9QbjJZL0Y4WUtUNG9PQVRMdmxoT3puem1CU2RGQkpXdGM1OHk3citVVkZPQ1Fjenkzd3BONnBlZ0RxSHRzQ1BUR3ZIOUp1VE8wRHlnOGljbGRZUGsrUkI2ZzhBb2ZqNG0yRUtCdnRUbVVQRDl4RGQxcFBjU1JlVjJVNWlEL2lrMnlybmd0dnZxQmZQek92S2lEVEtUc0Nkb0haSjdwTExmZmdUd2xKNXZKZHRKVjIvamlBWWFMdkxHaE1BRURPNVFjRGcyTS9qT3cvOFpuK0szWndKdkhUN1pmZmdDL052QTN6Y3liVGVJZkU0RUFBQUFBU1VWT1JLNUNZSUk9IjoKSU1BR0VfUEFUSCsiL2ltZy1oaS1yZXMucG5nIjtFZGl0b3IubG9SZXNJbWFnZT1teENsaWVudC5JU19TVkc/ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRkFBQUFBK0NBTUFBQUNMTVd5MUFBQUFTMUJNVkVWQVFFQUFBQUExTlRWQlFVRkRRME5EUTBORlJVVkVSRVJCUVVGQlFVRkJRVUZBUUVCQlFVRkJRVUZDUWtKQ1FrSkNRa0pCUVVGQ1FrSkRRME5EUTBOQ1FrSkNRa0pDUWtKR1JrYjUvWHFUQUFBQUdYUlNUbFArQUFXT0RsQVNDc2VzWCtMYzJMeVdlM3B3YTF0Q1Bqb2hqU0pmb0FBQUFJMUpSRUZVV01QdDFNa0toVEFNUnVHMGFudm5lWHIvSjcxblV5cEtjZHFJL044eWhMTUtNWkUxQ2FobkNsRFF6TVBCNDRFRDNFZ2VDdWJnRFduV1FNSHB3VHRLd1RlK1VIRDRzSjk0d2JVRUhIRkdoSUxsWURlU25zUWVhYmVDZ3NQQmdCME1PWlo5b0dBNUdKRmlKU2ZVVUxBZmpMakFScmhDd1g3d2gyWUNEd1Zid1prVUJLcUZGSlJOK3dPY3dTZ1Iyc1JFY2dBQUFBQkpSVTVFcmtKZ2dnPT0iOgpJTUFHRV9QQVRIKyIvaW1nLWxvLXJlcy5wbmciO0VkaXRvci5jYW1lcmFMYXJnZUltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQVlBQUFCemVucjBBQUFBQVhOU1IwSUFyczRjNlFBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBVmxwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJbGhOVUNCRGIzSmxJRFV1TkM0d0lqNEtJQ0FnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0S0lDQWdJQ0FnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwUGNtbGxiblJoZEdsdmJqNHhQQzkwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQZ29nSUNBZ0lDQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNEtJQ0FnUEM5eVpHWTZVa1JHUGdvOEwzZzZlRzF3YldWMFlUNEtUTUluV1FBQUEvQkpSRUZVV0FuRmwwdUlqV0VZeDg4NWJ1UFN1R3dtU1l3dHdzWTFpa0tTTllOY2xtUW5hZGdyWlNQbHNuQkxTbGFHQmROWUtZMFZkaTRMNHpZeklxeEd4bVhHLy9kKzcvLzArdVk3bldNaVQvMi81M21mKzN2N3ZuTktwZjlNNVVickR3OFBqNG0rd3ptZVQxRkJVUzZYZitZTm94NnJlTU9OdWtpak1YVVRNM05tSTc1UHlYY0pQd1JXZzVrUzd4eXNETE5tZkVVeHB4MnJjZU5FNTBJbFlqeVJrbGNMZjBwclkreDRCVHFmbXgzWlVIUWFPOUlTR25nWXEzOFYvMUVIK0VDUGErUWFLMXUxa1ZCUWlyRE1DaGlTM0NUZUlrd1d2Z2h0d2hLQnBaOGcxQ08yQjk5RnluVlUvS293U1JnUTNtbHJCc1ZaMWF3bVFsUzBTR2JmWGdsZkJQYmRSR01tNU84UlhnMlA4MzVwREN2eldqZ2hUSEVUY0xwWkxId1M4a1RDdEJFSzFTTjgzRWdhbThZeHlWWnFjK0RvNXFrd1MrZ1Q5Z3JOd2tVQkc2Y2JzRy9nczNCVHVDLzBDaEN4cTRRdHdnekJNZHdVWkJQeU40RnRmaTRzWVBaSGt0Yk9TUmxJdXV0UlA1allqMHVlWnA4OHh5WWNTL3pab2lMeVFUMUlBL2NUajdlU2x3bnJoSStKbmtRYkN3bzJTeC8yTTdWSnQxN3dkaFZ0Z3h2cnBvRm5BdVNBYkpROTdiaVpBbEt4QmZEOXdnT2hWK0JnSVIvQVp0SjRrd0Q1UEdTajdPbW1la2pXRXkwb0FRSEFTMytLcEJwelhxWUszVUl0b3BIcFNSTW5vMk4rY203Z0RZbmZSQ2NyM1FCcXJpTUhMSkRrZXloRmZpRzVhVmJLKzhyaHRQOU02UWNJRUpIWDVGcDlOTUF5UWxZaXUrT09KTmxPRENJWHlrYS9QMjNibmNUZGlDN095ZEMxK3YxQnNiKzVyODRESzhTM1JkbWY1Y1JVRlczYlh0V1VTdDFSZGs2RzRTeUpWMm8xWUlkK3ZOVXhyK3g1eUNKaWFwRnRjeFF6TGpyeGJvR2NNeHZGSndFT0tuTHdqSWJreC9zZFNtZVNhVVkrK1N3VEF4Vis0REpUN1JWd2tiazQ2Z05Dc2lmSUl0dXkwZTlQRjMzQ2I0aG9taE41WVJ5ekw1cTVWMlZOa3Y5OGtxZ29HVG8zWUY5Q25NTTVZNXJJdEZmdkJTaTlKdWxWWE9nSStWd0ludGt0K1NhWjZ3ZVFmY292SmY3enBUZmw4NlAvd0FGN0Z6MThOZUt3bXZBV0NhWDBaL3VNSFFyNDJaeHZSL1J4Y3c1eE0rOUovQ0pxOHcyZ2R1RGhtRGdzby9RckJINDdkRVhRMUlxY3p5SHBJT2ZJUnRuVHRWN1N3TzFvS1hLa1UzZmJUb0ZHU0RIdE1XY2FIMVdCdVZZbkRiUkZpOTlpcVNNeVNkenhYY2tyYXpVaDIzS0JWWUdJY2ZOQmtUeGNhMGU0QVRKMEt1a0dZVkJnci9NbmxoUE90UXEva3NVZkNiemgrRUZDanRuQ1VvSGZqaEEvT3NpVHYySGNFdkpNRUxwMFZha1pEbGlUbXJpVGRQaXZ4VTRWbUVodFByR1YrS0poTzdaS3QwZG9GWmgxZmdaU0JXSVcyQUdFSHdnM0JVV09uS3RIK3N1cWR3MDd0WU1mZ2xDcldQRDVtdzlxVll1bmlhWGtUME90V2FTdW81TEpUWTFSQmYrcm9GOVg1K3kvNXFVK0RBQUFBQUJKUlU1RXJrSmdnZz09IjsKRWRpdG9yLnN2Z0Jyb2tlbkltYWdlPUdyYXBoLmNyZWF0ZVN2Z0ltYWdlKDEwLDEwLCc8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHN0cm9rZT0iIzAwMCIgZmlsbD0idHJhbnNwYXJlbnQiLz48cGF0aCBkPSJtIDAgMCBMIDEwIDEwIEwgMCAxMCBMIDEwIDAiIHN0cm9rZT0iIzAwMCIgZmlsbD0idHJhbnNwYXJlbnQiLz4nKTtFZGl0b3IuZGVmYXVsdEN1c3RvbUxpYnJhcmllcz1bXTtFZGl0b3IuZW5hYmxlQ3VzdG9tTGlicmFyaWVzPSEwO0VkaXRvci5lbmFibGVDdXN0b21Qcm9wZXJ0aWVzPSEwO0VkaXRvci5jb21wcmVzc1htbD0hMDtFZGl0b3IuZ2xvYmFsVmFycz1udWxsO0VkaXRvci5zaGFkb3dPcHRpb25FbmFibGVkPSFteENsaWVudC5JU19TRjtFZGl0b3IuY29uZmlnPW51bGw7RWRpdG9yLmNvbmZpZ1ZlcnNpb249bnVsbDtFZGl0b3IuY29tbW9uRWRnZVByb3BlcnRpZXM9W3t0eXBlOiJzZXBhcmF0b3IifSx7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIiwKdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LHtuYW1lOiJzb3VyY2VQb3J0Q29uc3RyYWludCIsZGlzcE5hbWU6IlNvdXJjZSBDb25zdHJhaW50Iix0eXBlOiJlbnVtIixkZWZWYWw6Im5vbmUiLGVudW1MaXN0Olt7dmFsOiJub25lIixkaXNwTmFtZToiTm9uZSJ9LHt2YWw6Im5vcnRoIixkaXNwTmFtZToiTm9ydGgifSx7dmFsOiJlYXN0IixkaXNwTmFtZToiRWFzdCJ9LHt2YWw6InNvdXRoIixkaXNwTmFtZToiU291dGgifSx7dmFsOiJ3ZXN0IixkaXNwTmFtZToiV2VzdCJ9XX0se25hbWU6InRhcmdldFBvcnRDb25zdHJhaW50IixkaXNwTmFtZToiVGFyZ2V0IENvbnN0cmFpbnQiLHR5cGU6ImVudW0iLGRlZlZhbDoibm9uZSIsZW51bUxpc3Q6W3t2YWw6Im5vbmUiLGRpc3BOYW1lOiJOb25lIn0se3ZhbDoibm9ydGgiLGRpc3BOYW1lOiJOb3J0aCJ9LHt2YWw6ImVhc3QiLGRpc3BOYW1lOiJFYXN0In0se3ZhbDoic291dGgiLGRpc3BOYW1lOiJTb3V0aCJ9LAp7dmFsOiJ3ZXN0IixkaXNwTmFtZToiV2VzdCJ9XX0se25hbWU6ImpldHR5U2l6ZSIsZGlzcE5hbWU6IkpldHR5IFNpemUiLHR5cGU6ImludCIsbWluOjAsZGVmVmFsOiJhdXRvIixhbGxvd0F1dG86ITAsaXNWaXNpYmxlOmZ1bmN0aW9uKGEpe3JldHVybiJvcnRob2dvbmFsRWRnZVN0eWxlIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLG14Q29uc3RhbnRzLlNUWUxFX0VER0UsbnVsbCl9fSx7bmFtZToiZmlsbE9wYWNpdHkiLGRpc3BOYW1lOiJGaWxsIE9wYWNpdHkiLHR5cGU6ImludCIsbWluOjAsbWF4OjEwMCxkZWZWYWw6MTAwfSx7bmFtZToic3Ryb2tlT3BhY2l0eSIsZGlzcE5hbWU6IlN0cm9rZSBPcGFjaXR5Iix0eXBlOiJpbnQiLG1pbjowLG1heDoxMDAsZGVmVmFsOjEwMH0se25hbWU6InN0YXJ0RmlsbCIsZGlzcE5hbWU6IlN0YXJ0IEZpbGwiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImVuZEZpbGwiLGRpc3BOYW1lOiJFbmQgRmlsbCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSwKe25hbWU6InBlcmltZXRlclNwYWNpbmciLGRpc3BOYW1lOiJUZXJtaW5hbCBTcGFjaW5nIix0eXBlOiJmbG9hdCIsZGVmVmFsOjB9LHtuYW1lOiJhbmNob3JQb2ludERpcmVjdGlvbiIsZGlzcE5hbWU6IkFuY2hvciBEaXJlY3Rpb24iLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6InNuYXBUb1BvaW50IixkaXNwTmFtZToiU25hcCB0byBQb2ludCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToiZml4RGFzaCIsZGlzcE5hbWU6IkZpeGVkIERhc2giLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6ImppZ2dsZSIsZGlzcE5hbWU6IkppZ2dsZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoxLjUsaXNWaXNpYmxlOmZ1bmN0aW9uKGEpe3JldHVybiIxIj09bXhVdGlscy5nZXRWYWx1ZShhLnN0eWxlLCJjb21pYyIsIjAiKX19LHtuYW1lOiJlZGl0YWJsZSIsZGlzcE5hbWU6IkVkaXRhYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJiYWNrZ3JvdW5kT3V0bGluZSIsCmRpc3BOYW1lOiJCYWNrZ3JvdW5kIE91dGxpbmUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6ImJlbmRhYmxlIixkaXNwTmFtZToiQmVuZGFibGUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6Im1vdmFibGUiLGRpc3BOYW1lOiJNb3ZhYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJjbG9uZWFibGUiLGRpc3BOYW1lOiJDbG9uZWFibGUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImRlbGV0YWJsZSIsZGlzcE5hbWU6IkRlbGV0YWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToib3J0aG9nb25hbExvb3AiLGRpc3BOYW1lOiJMb29wIFJvdXRpbmciLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6Im5vSnVtcCIsZGlzcE5hbWU6Ik5vIEp1bXBzIix0eXBlOiJib29sIixkZWZWYWw6ITF9XTtFZGl0b3IuY29tbW9uVmVydGV4UHJvcGVydGllcz1be3R5cGU6InNlcGFyYXRvciJ9LHtuYW1lOiJmaWxsT3BhY2l0eSIsZGlzcE5hbWU6IkZpbGwgT3BhY2l0eSIsCnR5cGU6ImludCIsbWluOjAsbWF4OjEwMCxkZWZWYWw6MTAwfSx7bmFtZToic3Ryb2tlT3BhY2l0eSIsZGlzcE5hbWU6IlN0cm9rZSBPcGFjaXR5Iix0eXBlOiJpbnQiLG1pbjowLG1heDoxMDAsZGVmVmFsOjEwMH0se25hbWU6Im92ZXJmbG93IixkaXNwTmFtZToiVGV4dCBPdmVyZmxvdyIsZGVmVmFsOiJ2aXNpYmxlIix0eXBlOiJlbnVtIixlbnVtTGlzdDpbe3ZhbDoidmlzaWJsZSIsZGlzcE5hbWU6IlZpc2libGUifSx7dmFsOiJoaWRkZW4iLGRpc3BOYW1lOiJIaWRkZW4ifSx7dmFsOiJmaWxsIixkaXNwTmFtZToiRmlsbCJ9LHt2YWw6IndpZHRoIixkaXNwTmFtZToiV2lkdGgifV19LHtuYW1lOiJub0xhYmVsIixkaXNwTmFtZToiSGlkZSBMYWJlbCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToibGFiZWxQYWRkaW5nIixkaXNwTmFtZToiTGFiZWwgUGFkZGluZyIsdHlwZToiZmxvYXQiLGRlZlZhbDowfSx7bmFtZToiZGlyZWN0aW9uIixkaXNwTmFtZToiRGlyZWN0aW9uIiwKdHlwZToiZW51bSIsZGVmVmFsOiJlYXN0IixlbnVtTGlzdDpbe3ZhbDoibm9ydGgiLGRpc3BOYW1lOiJOb3J0aCJ9LHt2YWw6ImVhc3QiLGRpc3BOYW1lOiJFYXN0In0se3ZhbDoic291dGgiLGRpc3BOYW1lOiJTb3V0aCJ9LHt2YWw6Indlc3QiLGRpc3BOYW1lOiJXZXN0In1dfSx7bmFtZToicG9ydENvbnN0cmFpbnQiLGRpc3BOYW1lOiJDb25zdHJhaW50Iix0eXBlOiJlbnVtIixkZWZWYWw6Im5vbmUiLGVudW1MaXN0Olt7dmFsOiJub25lIixkaXNwTmFtZToiTm9uZSJ9LHt2YWw6Im5vcnRoIixkaXNwTmFtZToiTm9ydGgifSx7dmFsOiJlYXN0IixkaXNwTmFtZToiRWFzdCJ9LHt2YWw6InNvdXRoIixkaXNwTmFtZToiU291dGgifSx7dmFsOiJ3ZXN0IixkaXNwTmFtZToiV2VzdCJ9XX0se25hbWU6InBvcnRDb25zdHJhaW50Um90YXRpb24iLGRpc3BOYW1lOiJSb3RhdGUgQ29uc3RyYWludCIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToiY29ubmVjdGFibGUiLGRpc3BOYW1lOiJDb25uZWN0YWJsZSIsCnR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImFsbG93QXJyb3dzIixkaXNwTmFtZToiQWxsb3cgQXJyb3dzIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJzbmFwVG9Qb2ludCIsZGlzcE5hbWU6IlNuYXAgdG8gUG9pbnQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6InBlcmltZXRlciIsZGlzcE5hbWU6IlBlcmltZXRlciIsZGVmVmFsOiJub25lIix0eXBlOiJlbnVtIixlbnVtTGlzdDpbe3ZhbDoibm9uZSIsZGlzcE5hbWU6Ik5vbmUifSx7dmFsOiJyZWN0YW5nbGVQZXJpbWV0ZXIiLGRpc3BOYW1lOiJSZWN0YW5nbGUifSx7dmFsOiJlbGxpcHNlUGVyaW1ldGVyIixkaXNwTmFtZToiRWxsaXBzZSJ9LHt2YWw6InJob21idXNQZXJpbWV0ZXIiLGRpc3BOYW1lOiJSaG9tYnVzIn0se3ZhbDoidHJpYW5nbGVQZXJpbWV0ZXIiLGRpc3BOYW1lOiJUcmlhbmdsZSJ9LHt2YWw6ImhleGFnb25QZXJpbWV0ZXIyIixkaXNwTmFtZToiSGV4YWdvbiJ9LHt2YWw6ImxpZmVsaW5lUGVyaW1ldGVyIiwKZGlzcE5hbWU6IkxpZmVsaW5lIn0se3ZhbDoib3J0aG9nb25hbFBlcmltZXRlciIsZGlzcE5hbWU6Ik9ydGhvZ29uYWwifSx7dmFsOiJiYWNrYm9uZVBlcmltZXRlciIsZGlzcE5hbWU6IkJhY2tib25lIn0se3ZhbDoiY2FsbG91dFBlcmltZXRlciIsZGlzcE5hbWU6IkNhbGxvdXQifSx7dmFsOiJwYXJhbGxlbG9ncmFtUGVyaW1ldGVyIixkaXNwTmFtZToiUGFyYWxsZWxvZ3JhbSJ9LHt2YWw6InRyYXBlem9pZFBlcmltZXRlciIsZGlzcE5hbWU6IlRyYXBlem9pZCJ9LHt2YWw6InN0ZXBQZXJpbWV0ZXIiLGRpc3BOYW1lOiJTdGVwIn1dfSx7bmFtZToiZml4RGFzaCIsZGlzcE5hbWU6IkZpeGVkIERhc2giLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6ImppZ2dsZSIsZGlzcE5hbWU6IkppZ2dsZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoxLjUsaXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIjEiPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsImNvbWljIiwiMCIpfX0sCntuYW1lOiJhdXRvc2l6ZSIsZGlzcE5hbWU6IkF1dG9zaXplIix0eXBlOiJib29sIixkZWZWYWw6ITF9LHtuYW1lOiJjb250YWluZXIiLGRpc3BOYW1lOiJDb250YWluZXIiLHR5cGU6ImJvb2wiLGRlZlZhbDohMSxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMT09YS52ZXJ0aWNlcy5sZW5ndGgmJjA9PWEuZWRnZXMubGVuZ3RofX0se25hbWU6ImRyb3BUYXJnZXQiLGRpc3BOYW1lOiJEcm9wIFRhcmdldCIsdHlwZToiYm9vbCIsZ2V0RGVmYXVsdFZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGU9MT09YS52ZXJ0aWNlcy5sZW5ndGgmJjA9PWEuZWRnZXMubGVuZ3RoP2EudmVydGljZXNbMF06bnVsbCxjPWIuZWRpdG9yVWkuZWRpdG9yLmdyYXBoO3JldHVybiBudWxsIT1lJiYoYy5pc1N3aW1sYW5lKGUpfHwwPGMubW9kZWwuZ2V0Q2hpbGRDb3VudChlKSl9LGlzVmlzaWJsZTpmdW5jdGlvbihhLGIpe3JldHVybiAxPT1hLnZlcnRpY2VzLmxlbmd0aCYmMD09YS5lZGdlcy5sZW5ndGh9fSwKe25hbWU6ImNvbGxhcHNpYmxlIixkaXNwTmFtZToiQ29sbGFwc2libGUiLHR5cGU6ImJvb2wiLGdldERlZmF1bHRWYWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBlPTE9PWEudmVydGljZXMubGVuZ3RoJiYwPT1hLmVkZ2VzLmxlbmd0aD9hLnZlcnRpY2VzWzBdOm51bGwsYz1iLmVkaXRvclVpLmVkaXRvci5ncmFwaDtyZXR1cm4gbnVsbCE9ZSYmKGMuaXNDb250YWluZXIoZSkmJiIwIiE9YS5zdHlsZS5jb2xsYXBzaWJsZXx8IWMuaXNDb250YWluZXIoZSkmJiIxIj09YS5zdHlsZS5jb2xsYXBzaWJsZSl9LGlzVmlzaWJsZTpmdW5jdGlvbihhLGIpe3JldHVybiAxPT1hLnZlcnRpY2VzLmxlbmd0aCYmMD09YS5lZGdlcy5sZW5ndGh9fSx7bmFtZToicmVjdXJzaXZlUmVzaXplIixkaXNwTmFtZToiUmVzaXplIENoaWxkcmVuIix0eXBlOiJib29sIixkZWZWYWw6ITAsaXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDE9PWEudmVydGljZXMubGVuZ3RoJiYwPT1hLmVkZ2VzLmxlbmd0aCYmCiFiLmVkaXRvclVpLmVkaXRvci5ncmFwaC5pc1N3aW1sYW5lKGEudmVydGljZXNbMF0pJiZudWxsPT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsImNoaWxkTGF5b3V0IixudWxsKX19LHtuYW1lOiJleHBhbmQiLGRpc3BOYW1lOiJFeHBhbmQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6InBhcnQiLGRpc3BOYW1lOiJQYXJ0Iix0eXBlOiJib29sIixkZWZWYWw6ITEsaXNWaXNpYmxlOmZ1bmN0aW9uKGEsYil7dmFyIGU9Yi5lZGl0b3JVaS5lZGl0b3IuZ3JhcGgubW9kZWw7cmV0dXJuIDA8YS52ZXJ0aWNlcy5sZW5ndGg/ZS5pc1ZlcnRleChlLmdldFBhcmVudChhLnZlcnRpY2VzWzBdKSk6ITF9fSx7bmFtZToiZWRpdGFibGUiLGRpc3BOYW1lOiJFZGl0YWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiYmFja2dyb3VuZE91dGxpbmUiLGRpc3BOYW1lOiJCYWNrZ3JvdW5kIE91dGxpbmUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6Im1vdmFibGUiLGRpc3BOYW1lOiJNb3ZhYmxlIiwKdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToibW92YWJsZUxhYmVsIixkaXNwTmFtZToiTW92YWJsZSBMYWJlbCIsdHlwZToiYm9vbCIsZGVmVmFsOiExLGlzVmlzaWJsZTpmdW5jdGlvbihhLGIpe3ZhciBlPTA8YS52ZXJ0aWNlcy5sZW5ndGg/Yi5lZGl0b3JVaS5lZGl0b3IuZ3JhcGguZ2V0Q2VsbEdlb21ldHJ5KGEudmVydGljZXNbMF0pOm51bGw7cmV0dXJuIG51bGwhPWUmJiFlLnJlbGF0aXZlfX0se25hbWU6InJlc2l6YWJsZSIsZGlzcE5hbWU6IlJlc2l6YWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToicmVzaXplV2lkdGgiLGRpc3BOYW1lOiJSZXNpemUgV2lkdGgiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6InJlc2l6ZUhlaWdodCIsZGlzcE5hbWU6IlJlc2l6ZSBIZWlnaHQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX0se25hbWU6InJvdGF0YWJsZSIsZGlzcE5hbWU6IlJvdGF0YWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiY2xvbmVhYmxlIiwKZGlzcE5hbWU6IkNsb25lYWJsZSIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToiZGVsZXRhYmxlIixkaXNwTmFtZToiRGVsZXRhYmxlIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJ0cmVlRm9sZGluZyIsZGlzcE5hbWU6IlRyZWUgRm9sZGluZyIsdHlwZToiYm9vbCIsZGVmVmFsOiExfSx7bmFtZToidHJlZU1vdmluZyIsZGlzcE5hbWU6IlRyZWUgTW92aW5nIix0eXBlOiJib29sIixkZWZWYWw6ITF9LHtuYW1lOiJwb2ludGVyRXZlbnRzIixkaXNwTmFtZToiUG9pbnRlciBFdmVudHMiLHR5cGU6ImJvb2wiLGRlZlZhbDohMCxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXt2YXIgZT1teFV0aWxzLmdldFZhbHVlKGEuc3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLG51bGwpO3JldHVybiBiLmVkaXRvclVpLmVkaXRvci5ncmFwaC5pc1N3aW1sYW5lKGEudmVydGljZXNbMF0pfHxudWxsPT1lfHxlPT1teENvbnN0YW50cy5OT05FfX0se25hbWU6Im1vdmVDZWxscyIsCmRpc3BOYW1lOiJNb3ZlIENlbGxzIG9uIEZvbGQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMSxpc1Zpc2libGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMDxhLnZlcnRpY2VzLmxlbmd0aCYmYi5lZGl0b3JVaS5lZGl0b3IuZ3JhcGguaXNDb250YWluZXIoYS52ZXJ0aWNlc1swXSl9fV07RWRpdG9yLmRlZmF1bHRDc3ZWYWx1ZT0nIyNcbiMjIEV4YW1wbGUgQ1NWIGltcG9ydC4gVXNlICMjIGZvciBjb21tZW50cyBhbmQgIyBmb3IgY29uZmlndXJhdGlvbi4gUGFzdGUgQ1NWIGJlbG93LlxuIyMgVGhlIGZvbGxvd2luZyBuYW1lcyBhcmUgcmVzZXJ2ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZCAob3IgaWdub3JlZCk6XG4jIyBpZCwgdG9vbHRpcCwgcGxhY2Vob2xkZXIocyksIGxpbmsgYW5kIGxhYmVsIChzZWUgYmVsb3cpXG4jI1xuI1xuIyMgTm9kZSBsYWJlbCB3aXRoIHBsYWNlaG9sZGVycyBhbmQgSFRNTC5cbiMjIERlZmF1bHQgaXMgXCclbmFtZV9vZl9maXJzdF9jb2x1bW4lXCcuXG4jXG4jIGxhYmVsOiAlbmFtZSU8YnI+PGkgc3R5bGU9ImNvbG9yOmdyYXk7Ij4lcG9zaXRpb24lPC9pPjxicj48YSBocmVmPSJtYWlsdG86JWVtYWlsJSI+RW1haWw8L2E+XG4jXG4jIyBOb2RlIHN0eWxlIChwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIG9uY2UpLlxuIyMgRGVmYXVsdCBpcyB0aGUgY3VycmVudCBzdHlsZSBmb3Igbm9kZXMuXG4jXG4jIHN0eWxlOiBsYWJlbDtpbWFnZT0laW1hZ2UlO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7cm91bmRlZD0xO2ZpbGxDb2xvcj0lZmlsbCU7c3Ryb2tlQ29sb3I9JXN0cm9rZSU7XG4jXG4jIyBQYXJlbnQgc3R5bGUgZm9yIG5vZGVzIHdpdGggY2hpbGQgbm9kZXMgKHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgb25jZSkuXG4jXG4jIHBhcmVudHN0eWxlOiBzd2ltbGFuZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2NoaWxkTGF5b3V0PXN0YWNrTGF5b3V0O2hvcml6b250YWw9MTtob3Jpem9udGFsU3RhY2s9MDtyZXNpemVQYXJlbnQ9MTtyZXNpemVMYXN0PTA7Y29sbGFwc2libGU9MTtcbiNcbiMjIE9wdGlvbmFsIGNvbHVtbiBuYW1lIHRoYXQgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gYSBuYW1lZCBzdHlsZSBpbiBzdHlsZXMuXG4jIyBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IHN0eWxlIGZvciBub2Rlcy5cbiNcbiMgc3R5bGVuYW1lOiAtXG4jXG4jIyBKU09OIGZvciBuYW1lZCBzdHlsZXMgb2YgdGhlIGZvcm0geyJuYW1lIjogInN0eWxlIiwgIm5hbWUiOiAic3R5bGUifSB3aGVyZSBzdHlsZSBpcyBhIGNlbGwgc3R5bGUgd2l0aFxuIyMgcGxhY2Vob2xkZXJzIHRoYXQgYXJlIHJlcGxhY2VkIG9uY2UuXG4jXG4jIHN0eWxlczogLVxuI1xuIyMgT3B0aW9uYWwgY29sdW1uIG5hbWUgdGhhdCBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhIG5hbWVkIGxhYmVsIGluIGxhYmVscy5cbiMjIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgbGFiZWwuXG4jXG4jIGxhYmVsbmFtZTogLVxuI1xuIyMgSlNPTiBmb3IgbmFtZWQgbGFiZWxzIG9mIHRoZSBmb3JtIHsibmFtZSI6ICJsYWJlbCIsICJuYW1lIjogImxhYmVsIn0gd2hlcmUgbGFiZWwgaXMgYSBjZWxsIGxhYmVsIHdpdGhcbiMjIHBsYWNlaG9sZGVycy5cbiNcbiMgbGFiZWxzOiAtXG4jXG4jIyBVc2VzIHRoZSBnaXZlbiBjb2x1bW4gbmFtZSBhcyB0aGUgaWRlbnRpdHkgZm9yIGNlbGxzICh1cGRhdGVzIGV4aXN0aW5nIGNlbGxzKS5cbiMjIERlZmF1bHQgaXMgbm8gaWRlbnRpdHkgKGVtcHR5IHZhbHVlIG9yIC0pLlxuI1xuIyBpZGVudGl0eTogLVxuI1xuIyMgVXNlcyB0aGUgZ2l2ZW4gY29sdW1uIG5hbWUgYXMgdGhlIHBhcmVudCByZWZlcmVuY2UgZm9yIGNlbGxzLiBEZWZhdWx0IGlzIG5vIHBhcmVudCAoZW1wdHkgb3IgLSkuXG4jIyBUaGUgaWRlbnRpdHkgYWJvdmUgaXMgdXNlZCBmb3IgcmVzb2x2aW5nIHRoZSByZWZlcmVuY2Ugc28gaXQgbXVzdCBiZSBzcGVjaWZpZWQuXG4jXG4jIHBhcmVudDogLVxuI1xuIyMgQWRkcyBhIHByZWZpeCB0byB0aGUgaWRlbnRpdHkgb2YgY2VsbHMgdG8gbWFrZSBzdXJlIHRoZXkgZG8gbm90IGNvbGxpZGUgd2l0aCBleGlzdGluZyBjZWxscyAod2hvc2VcbiMjIElEcyBhcmUgbnVtYmVycyBmcm9tIDAuLm4sIHNvbWV0aW1lcyB3aXRoIGEgR1VJRCBwcmVmaXggaW4gdGhlIGNvbnRleHQgb2YgcmVhbHRpbWUgY29sbGFib3JhdGlvbikuXG4jIyBEZWZhdWx0IGlzIGNzdmltcG9ydC0uXG4jXG4jIG5hbWVzcGFjZTogY3N2aW1wb3J0LVxuI1xuIyMgQ29ubmVjdGlvbnMgYmV0d2VlbiByb3dzICgiZnJvbSI6IHNvdXJjZSBjb2x1bSwgInRvIjogdGFyZ2V0IGNvbHVtbikuXG4jIyBMYWJlbCwgc3R5bGUgYW5kIGludmVydCBhcmUgb3B0aW9uYWwuIERlZmF1bHRzIGFyZSBcJ1wnLCBjdXJyZW50IHN0eWxlIGFuZCBmYWxzZS5cbiMjIElmIHBsYWNlaG9sZGVycyBhcmUgdXNlZCBpbiB0aGUgc3R5bGUsIHRoZXkgYXJlIHJlcGxhY2VkIHdpdGggZGF0YSBmcm9tIHRoZSBzb3VyY2UuXG4jIyBBbiBvcHRpb25hbCBwbGFjZWhvbGRlcnMgY2FuIGJlIHNldCB0byB0YXJnZXQgdG8gdXNlIGRhdGEgZnJvbSB0aGUgdGFyZ2V0IGluc3RlYWQuXG4jIyBJbiBhZGRpdGlvbiB0byBsYWJlbCwgYW4gb3B0aW9uYWwgZnJvbWxhYmVsIGFuZCB0b2xhYmVsIGNhbiBiZSB1c2VkIHRvIG5hbWUgdGhlIGNvbHVtblxuIyMgdGhhdCBjb250YWlucyB0aGUgdGV4dCBmb3IgdGhlIGxhYmVsIGluIHRoZSBlZGdlcyBzb3VyY2Ugb3IgdGFyZ2V0IChpbnZlcnQgaWdub3JlZCkuXG4jIyBUaGUgbGFiZWwgaXMgY29uY2F0ZW5hdGVkIGluIHRoZSBmb3JtIGZyb21sYWJlbCArIGxhYmVsICsgdG9sYWJlbCBpZiBhbGwgYXJlIGRlZmluZWQuXG4jIyBBZGRpdGlvbmFsIGxhYmVscyBjYW4gYmUgYWRkZWQgYnkgdXNpbmcgYW4gb3B0aW9uYWwgbGFiZWxzIGFycmF5IHdpdGggZW50cmllcyBvZiB0aGVcbiMjIGZvcm0geyJsYWJlbCI6IHN0cmluZywgIngiOiBudW1iZXIsICJ5IjogbnVtYmVyLCAiZHgiOiBudW1iZXIsICJkeSI6IG51bWJlcn0gd2hlcmVcbiMjIHggaXMgZnJvbSAtMSB0byAxIGFsb25nIHRoZSBlZGdlLCB5IGlzIG9ydGhvZ29uYWwsIGFuZCBkeC9keSBhcmUgb2Zmc2V0cyBpbiBwaXhlbHMuXG4jIyBUaGUgdGFyZ2V0IGNvbHVtbiBtYXkgY29udGFpbiBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZhbHVlcy5cbiMjIE11bHRpcGxlIGNvbm5lY3QgZW50cmllcyBhcmUgYWxsb3dlZC5cbiNcbiMgY29ubmVjdDogeyJmcm9tIjogIm1hbmFnZXIiLCAidG8iOiAibmFtZSIsICJpbnZlcnQiOiB0cnVlLCAibGFiZWwiOiAibWFuYWdlcyIsIFxcXG4jICAgICAgICAgICJzdHlsZSI6ICJjdXJ2ZWQ9MTtlbmRBcnJvdz1ibG9ja1RoaW47ZW5kRmlsbD0xO2ZvbnRTaXplPTExOyJ9XG4jIGNvbm5lY3Q6IHsiZnJvbSI6ICJyZWZzIiwgInRvIjogImlkIiwgInN0eWxlIjogImN1cnZlZD0xO2ZvbnRTaXplPTExOyJ9XG4jXG4jIyBOb2RlIHgtY29vcmRpbmF0ZS4gUG9zc2libGUgdmFsdWUgaXMgYSBjb2x1bW4gbmFtZS4gRGVmYXVsdCBpcyBlbXB0eS4gTGF5b3V0cyB3aWxsXG4jIyBvdmVycmlkZSB0aGlzIHZhbHVlLlxuI1xuIyBsZWZ0OiBcbiNcbiMjIE5vZGUgeS1jb29yZGluYXRlLiBQb3NzaWJsZSB2YWx1ZSBpcyBhIGNvbHVtbiBuYW1lLiBEZWZhdWx0IGlzIGVtcHR5LiBMYXlvdXRzIHdpbGxcbiMjIG92ZXJyaWRlIHRoaXMgdmFsdWUuXG4jXG4jIHRvcDogXG4jXG4jIyBOb2RlIHdpZHRoLiBQb3NzaWJsZSB2YWx1ZSBpcyBhIG51bWJlciAoaW4gcHgpLCBhdXRvIG9yIGFuIEAgc2lnbiBmb2xsb3dlZCBieSBhIGNvbHVtblxuIyMgbmFtZSB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZSBmb3IgdGhlIHdpZHRoLiBEZWZhdWx0IGlzIGF1dG8uXG4jXG4jIHdpZHRoOiBhdXRvXG4jXG4jIyBOb2RlIGhlaWdodC4gUG9zc2libGUgdmFsdWUgaXMgYSBudW1iZXIgKGluIHB4KSwgYXV0byBvciBhbiBAIHNpZ24gZm9sbG93ZWQgYnkgYSBjb2x1bW5cbiMjIG5hbWUgdGhhdCBjb250YWlucyB0aGUgdmFsdWUgZm9yIHRoZSBoZWlnaHQuIERlZmF1bHQgaXMgYXV0by5cbiNcbiMgaGVpZ2h0OiBhdXRvXG4jXG4jIyBQYWRkaW5nIGZvciBhdXRvc2l6ZS4gRGVmYXVsdCBpcyAwLlxuI1xuIyBwYWRkaW5nOiAtMTJcbiNcbiMjIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGlnbm9yZWQgY29sdW1ucyBmb3IgbWV0YWRhdGEuIChUaGVzZSBjYW4gYmVcbiMjIHVzZWQgZm9yIGNvbm5lY3Rpb25zIGFuZCBzdHlsZXMgYnV0IHdpbGwgbm90IGJlIGFkZGVkIGFzIG1ldGFkYXRhLilcbiNcbiMgaWdub3JlOiBpZCxpbWFnZSxmaWxsLHN0cm9rZSxyZWZzLG1hbmFnZXJcbiNcbiMjIENvbHVtbiB0byBiZSByZW5hbWVkIHRvIGxpbmsgYXR0cmlidXRlICh1c2VkIGFzIGxpbmspLlxuI1xuIyBsaW5rOiB1cmxcbiNcbiMjIFNwYWNpbmcgYmV0d2VlbiBub2Rlcy4gRGVmYXVsdCBpcyA0MC5cbiNcbiMgbm9kZXNwYWNpbmc6IDQwXG4jXG4jIyBTcGFjaW5nIGJldHdlZW4gbGV2ZWxzIG9mIGhpZXJhcmNoaWNhbCBsYXlvdXRzLiBEZWZhdWx0IGlzIDEwMC5cbiNcbiMgbGV2ZWxzcGFjaW5nOiAxMDBcbiNcbiMjIFNwYWNpbmcgYmV0d2VlbiBwYXJhbGxlbCBlZGdlcy4gRGVmYXVsdCBpcyA0MC4gVXNlIDAgdG8gZGlzYWJsZS5cbiNcbiMgZWRnZXNwYWNpbmc6IDQwXG4jXG4jIyBOYW1lIG9yIEpTT04gb2YgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGF1dG8sIG5vbmUsIHZlcnRpY2FsdHJlZSwgaG9yaXpvbnRhbHRyZWUsXG4jIyB2ZXJ0aWNhbGZsb3csIGhvcml6b250YWxmbG93LCBvcmdhbmljLCBjaXJjbGUgb3IgYSBKU09OIHN0cmluZyBhcyB1c2VkIGluIExheW91dCwgQXBwbHkuXG4jIyBEZWZhdWx0IGlzIGF1dG8uXG4jXG4jIGxheW91dDogYXV0b1xuI1xuIyMgLS0tLSBDU1YgYmVsb3cgdGhpcyBsaW5lLiBGaXJzdCBsaW5lIGFyZSBjb2x1bW4gbmFtZXMuIC0tLS1cbm5hbWUscG9zaXRpb24saWQsbG9jYXRpb24sbWFuYWdlcixlbWFpbCxmaWxsLHN0cm9rZSxyZWZzLHVybCxpbWFnZVxuRXZhbiBNaWxsZXIsQ0ZPLGVtaSxPZmZpY2UgMSwsbWVAZXhhbXBsZS5jb20sI2RhZThmYywjNmM4ZWJmLCxodHRwczovL3d3dy5kcmF3LmlvLGh0dHBzOi8vY2RuMy5pY29uZmluZGVyLmNvbS9kYXRhL2ljb25zL3VzZXItYXZhdGFycy0xLzUxMi91c2Vycy05LTItMTI4LnBuZ1xuRWR3YXJkIE1vcnJpc29uLEJyYW5kIE1hbmFnZXIsZW1vLE9mZmljZSAyLEV2YW4gTWlsbGVyLG1lQGV4YW1wbGUuY29tLCNkNWU4ZDQsIzgyYjM2NiwsaHR0cHM6Ly93d3cuZHJhdy5pbyxodHRwczovL2NkbjMuaWNvbmZpbmRlci5jb20vZGF0YS9pY29ucy91c2VyLWF2YXRhcnMtMS81MTIvdXNlcnMtMTAtMy0xMjgucG5nXG5Sb24gRG9ub3ZhbixTeXN0ZW0gQWRtaW4scmRvLE9mZmljZSAzLEV2YW4gTWlsbGVyLG1lQGV4YW1wbGUuY29tLCNkNWU4ZDQsIzgyYjM2NiwiZW1vLHR2YSIsaHR0cHM6Ly93d3cuZHJhdy5pbyxodHRwczovL2NkbjMuaWNvbmZpbmRlci5jb20vZGF0YS9pY29ucy91c2VyLWF2YXRhcnMtMS81MTIvdXNlcnMtMi0xMjgucG5nXG5UZXNzYSBWYWxldCxIUiBEaXJlY3Rvcix0dmEsT2ZmaWNlIDQsRXZhbiBNaWxsZXIsbWVAZXhhbXBsZS5jb20sI2Q1ZThkNCwjODJiMzY2LCxodHRwczovL3d3dy5kcmF3LmlvLGh0dHBzOi8vY2RuMy5pY29uZmluZGVyLmNvbS9kYXRhL2ljb25zL3VzZXItYXZhdGFycy0xLzUxMi91c2Vycy0zLTEyOC5wbmdcbic7CkVkaXRvci5mYXN0Q29tcHJlc3M9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWF8fDA9PWEubGVuZ3RofHwidW5kZWZpbmVkIj09PXR5cGVvZiBwYWtvP2E6cGFrby5kZWZsYXRlUmF3KGEse3RvOiJzdHJpbmcifSl9O0VkaXRvci5mYXN0RGVjb21wcmVzcz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09YXx8MD09YS5sZW5ndGh8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHBha28/YTpwYWtvLmluZmxhdGVSYXcoYSx7dG86InN0cmluZyJ9KX07RWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsPWZ1bmN0aW9uKGEsYixlKXtpZihudWxsIT1hJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBwYWtvKXt2YXIgYz1hLm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLGQ9W107aWYobnVsbCE9YyYmMDxjLmxlbmd0aClmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKylpZigibXhncmFwaCI9PWNbZl0uZ2V0QXR0cmlidXRlKCJjbGFzcyIpKXtkLnB1c2goY1tmXSk7YnJlYWt9MDxkLmxlbmd0aCYmCihjPWRbMF0uZ2V0QXR0cmlidXRlKCJkYXRhLW14Z3JhcGgiKSxudWxsIT1jPyhkPUpTT04ucGFyc2UoYyksbnVsbCE9ZCYmbnVsbCE9ZC54bWwmJihhPW14VXRpbHMucGFyc2VYbWwoZC54bWwpLGE9YS5kb2N1bWVudEVsZW1lbnQpKTooZD1kWzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKSwwPGQubGVuZ3RoJiYoYz1teFV0aWxzLmdldFRleHRDb250ZW50KGRbMF0pLGM9R3JhcGguZGVjb21wcmVzcyhjLG51bGwsZSksMDxjLmxlbmd0aCYmKGE9bXhVdGlscy5wYXJzZVhtbChjKSxhPWEuZG9jdW1lbnRFbGVtZW50KSkpKX1pZihudWxsIT1hJiYic3ZnIj09YS5ub2RlTmFtZSlpZihjPWEuZ2V0QXR0cmlidXRlKCJjb250ZW50IiksbnVsbCE9YyYmIjwiIT1jLmNoYXJBdCgwKSYmIiUiIT1jLmNoYXJBdCgwKSYmKGM9dW5lc2NhcGUod2luZG93LmF0b2I/YXRvYihjKTpCYXNlNjQuZGVjb2RlKGNvbnQsYykpKSxudWxsIT1jJiYiJSI9PWMuY2hhckF0KDApJiYoYz1kZWNvZGVVUklDb21wb25lbnQoYykpLApudWxsIT1jJiYwPGMubGVuZ3RoKWE9bXhVdGlscy5wYXJzZVhtbChjKS5kb2N1bWVudEVsZW1lbnQ7ZWxzZSB0aHJvd3ttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgibm90QURpYWdyYW1GaWxlIil9O251bGw9PWF8fGJ8fChkPW51bGwsImRpYWdyYW0iPT1hLm5vZGVOYW1lP2Q9YToibXhmaWxlIj09YS5ub2RlTmFtZSYmKGM9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpLDA8Yy5sZW5ndGgmJihkPWNbTWF0aC5tYXgoMCxNYXRoLm1pbihjLmxlbmd0aC0xLHVybFBhcmFtcy5wYWdlfHwwKSldKSksbnVsbCE9ZCYmKGE9RWRpdG9yLnBhcnNlRGlhZ3JhbU5vZGUoZCxlKSkpO251bGw9PWF8fCJteEdyYXBoTW9kZWwiPT1hLm5vZGVOYW1lfHxiJiYibXhmaWxlIj09YS5ub2RlTmFtZXx8KGE9bnVsbCk7cmV0dXJuIGF9O0VkaXRvci5wYXJzZURpYWdyYW1Ob2RlPWZ1bmN0aW9uKGEsYil7dmFyIGU9bXhVdGlscy50cmltKG14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYSkpLGM9bnVsbDsKMDxlLmxlbmd0aD8oZT1HcmFwaC5kZWNvbXByZXNzKGUsbnVsbCxiKSxudWxsIT1lJiYwPGUubGVuZ3RoJiYoYz1teFV0aWxzLnBhcnNlWG1sKGUpLmRvY3VtZW50RWxlbWVudCkpOihlPW14VXRpbHMuZ2V0Q2hpbGROb2RlcyhhKSwwPGUubGVuZ3RoJiYoYz1teFV0aWxzLmNyZWF0ZVhtbERvY3VtZW50KCksYy5hcHBlbmRDaGlsZChjLmltcG9ydE5vZGUoZVswXSwhMCkpLGM9Yy5kb2N1bWVudEVsZW1lbnQpKTtyZXR1cm4gY307RWRpdG9yLmdldERpYWdyYW1Ob2RlWG1sPWZ1bmN0aW9uKGEpe3ZhciBiPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYSksZT1udWxsOzA8Yi5sZW5ndGg/ZT1HcmFwaC5kZWNvbXByZXNzKGIpOm51bGwhPWEuZmlyc3RDaGlsZCYmKGU9bXhVdGlscy5nZXRYbWwoYS5maXJzdENoaWxkKSk7cmV0dXJuIGV9O0VkaXRvci5leHRyYWN0R3JhcGhNb2RlbEZyb21QZGY9ZnVuY3Rpb24oYSl7YT1hLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiKSsxKTthPXdpbmRvdy5hdG9iJiYKIW14Q2xpZW50LklTX1NGP2F0b2IoYSk6QmFzZTY0LmRlY29kZShhLCEwKTtmb3IodmFyIGI9bnVsbCxlPSIiLGM9MCxkPTAsZj1bXSxnPW51bGw7ZDxhLmxlbmd0aDspe3ZhciBsPWEuY2hhckNvZGVBdChkKSxkPWQrMTsxMCE9bCYmKGUrPVN0cmluZy5mcm9tQ2hhckNvZGUobCkpO2w9PSIvU3ViamVjdCAoJTNDbXhmaWxlIi5jaGFyQ29kZUF0KGMpP2MrKzpjPTA7aWYoMTk9PWMpe3ZhciBuPWEuaW5kZXhPZigiJTNDJTJGbXhmaWxlJTNFKSIsZCkrMTUsZD1kLTk7aWYobj5kKXtiPWEuc3Vic3RyaW5nKGQsbik7YnJlYWt9fTEwPT1sJiYoImVuZG9iaiI9PWU/Zz1udWxsOiJvYmoiPT1lLnN1YnN0cmluZyhlLmxlbmd0aC0zLGUubGVuZ3RoKXx8InhyZWYiPT1lfHwidHJhaWxlciI9PWU/KGc9W10sZltlLnNwbGl0KCIgIilbMF1dPWcpOm51bGwhPWcmJmcucHVzaChlKSxlPSIiKX1udWxsPT1iJiYoYj1FZGl0b3IuZXh0cmFjdEdyYXBoTW9kZWxGcm9tWHJlZihmKSk7bnVsbCE9YiYmCihiPWRlY29kZVVSSUNvbXBvbmVudChiLnJlcGxhY2UoL1xcXCgvZywiKCIpLnJlcGxhY2UoL1xcXCkvZywiKSIpKSk7cmV0dXJuIGJ9O0VkaXRvci5leHRyYWN0R3JhcGhNb2RlbEZyb21YcmVmPWZ1bmN0aW9uKGEpe3ZhciBiPWEudHJhaWxlcixlPW51bGw7bnVsbCE9YiYmKGI9Ly4qIFwvSW5mbyAoXGQrKSAoXGQrKSBSL2cuZXhlYyhiLmpvaW4oIlxuIikpLG51bGwhPWImJjA8Yi5sZW5ndGgmJihiPWFbYlsxXV0sbnVsbCE9YiYmKGI9Ly4qIFwvU3ViamVjdCAoXGQrKSAoXGQrKSBSL2cuZXhlYyhiLmpvaW4oIlxuIikpLG51bGwhPWImJjA8Yi5sZW5ndGgmJihhPWFbYlsxXV0sbnVsbCE9YSYmKGE9YS5qb2luKCJcbiIpLGU9YS5zdWJzdHJpbmcoMSxhLmxlbmd0aC0xKSkpKSkpO3JldHVybiBlfTtFZGl0b3IuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7dHJ5e3ZhciBlPWEuc3Vic3RyaW5nKGEuaW5kZXhPZigiLCIpKzEpLGM9d2luZG93LmF0b2ImJgohbXhDbGllbnQuSVNfU0Y/YXRvYihlKTpCYXNlNjQuZGVjb2RlKGUsITApO0VkaXRvclVpLnBhcnNlUG5nKGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxlLGQpe2E9Yy5zdWJzdHJpbmcoYSs4LGErOCtkKTsielRYdCI9PWU/KGQ9YS5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoMCkpLCJteEdyYXBoTW9kZWwiPT1hLnN1YnN0cmluZygwLGQpJiYoYT1wYWtvLmluZmxhdGVSYXcoYS5zdWJzdHJpbmcoZCsyKSx7dG86InN0cmluZyJ9KS5yZXBsYWNlKC9cKy9nLCIgIiksbnVsbCE9YSYmMDxhLmxlbmd0aCYmKGI9YSkpKToidEVYdCI9PWUmJihhPWEuc3BsaXQoU3RyaW5nLmZyb21DaGFyQ29kZSgwKSksMTxhLmxlbmd0aCYmKCJteEdyYXBoTW9kZWwiPT1hWzBdfHwibXhmaWxlIj09YVswXSkmJihiPWFbMV0pKTtpZihudWxsIT1ifHwiSURBVCI9PWUpcmV0dXJuITB9KSl9Y2F0Y2goUSl7fW51bGwhPWImJiIlIj09Yi5jaGFyQXQoMCkmJihiPWRlY29kZVVSSUNvbXBvbmVudChiKSk7Cm51bGwhPWImJiIlIj09Yi5jaGFyQXQoMCkmJihiPWRlY29kZVVSSUNvbXBvbmVudChiKSk7cmV0dXJuIGJ9O0VkaXRvci5leHRyYWN0UGFyc2VyRXJyb3I9ZnVuY3Rpb24oYSxiKXt2YXIgZT1udWxsLGM9bnVsbCE9YT9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJwYXJzZXJlcnJvciIpOm51bGw7bnVsbCE9YyYmMDxjLmxlbmd0aCYmKGU9Ynx8bXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkQ2hhcnMiKSxjPWNbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLDA8Yy5sZW5ndGgmJihlPW14VXRpbHMuZ2V0VGV4dENvbnRlbnQoY1swXSkpKTtyZXR1cm4gbnVsbCE9ZT9teFV0aWxzLnRyaW0oZSk6ZX07RWRpdG9yLmNvbmZpZ3VyZT1mdW5jdGlvbihhLGIpe2lmKG51bGwhPWEpe0VkaXRvci5jb25maWc9YTtFZGl0b3IuY29uZmlnVmVyc2lvbj1hLnZlcnNpb247TWVudXMucHJvdG90eXBlLmRlZmF1bHRGb250cz1hLmRlZmF1bHRGb250c3x8TWVudXMucHJvdG90eXBlLmRlZmF1bHRGb250czsKQ29sb3JEaWFsb2cucHJvdG90eXBlLnByZXNldENvbG9ycz1hLnByZXNldENvbG9yc3x8Q29sb3JEaWFsb2cucHJvdG90eXBlLnByZXNldENvbG9ycztDb2xvckRpYWxvZy5wcm90b3R5cGUuZGVmYXVsdENvbG9ycz1hLmRlZmF1bHRDb2xvcnN8fENvbG9yRGlhbG9nLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JzO1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmRlZmF1bHRDb2xvclNjaGVtZXM9YS5kZWZhdWx0Q29sb3JTY2hlbWVzfHxTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JTY2hlbWVzO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0RWRnZUxlbmd0aD1hLmRlZmF1bHRFZGdlTGVuZ3RofHxHcmFwaC5wcm90b3R5cGUuZGVmYXVsdEVkZ2VMZW5ndGg7RHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmVEZWxheT1hLmF1dG9zYXZlRGVsYXl8fERyYXdpb0ZpbGUucHJvdG90eXBlLmF1dG9zYXZlRGVsYXk7bnVsbCE9YS50ZW1wbGF0ZUZpbGUmJihFZGl0b3JVaS50ZW1wbGF0ZUZpbGU9CmEudGVtcGxhdGVGaWxlKTtudWxsIT1hLmdsb2JhbFZhcnMmJihFZGl0b3IuZ2xvYmFsVmFycz1hLmdsb2JhbFZhcnMpO251bGwhPWEuY29tcHJlc3NYbWwmJihFZGl0b3IuY29tcHJlc3NYbWw9YS5jb21wcmVzc1htbCk7YS5jdXN0b21Gb250cyYmKE1lbnVzLnByb3RvdHlwZS5kZWZhdWx0Rm9udHM9YS5jdXN0b21Gb250cy5jb25jYXQoTWVudXMucHJvdG90eXBlLmRlZmF1bHRGb250cykpO2EuY3VzdG9tUHJlc2V0Q29sb3JzJiYoQ29sb3JEaWFsb2cucHJvdG90eXBlLnByZXNldENvbG9ycz1hLmN1c3RvbVByZXNldENvbG9ycy5jb25jYXQoQ29sb3JEaWFsb2cucHJvdG90eXBlLnByZXNldENvbG9ycykpO251bGwhPWEuY3VzdG9tQ29sb3JTY2hlbWVzJiYoU3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuZGVmYXVsdENvbG9yU2NoZW1lcz1hLmN1c3RvbUNvbG9yU2NoZW1lcy5jb25jYXQoU3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuZGVmYXVsdENvbG9yU2NoZW1lcykpO2lmKG51bGwhPQphLmNzcyl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtlLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQvY3NzIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhLmNzcykpO3ZhciBjPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzY3JpcHQiKVswXTtjLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsYyl9bnVsbCE9YS5saWJyYXJpZXMmJihTaWRlYmFyLnByb3RvdHlwZS5jdXN0b21FbnRyaWVzPWEubGlicmFyaWVzKTtudWxsIT1hLmVuYWJsZWRMaWJyYXJpZXMmJihTaWRlYmFyLnByb3RvdHlwZS5lbmFibGVkTGlicmFyaWVzPWEuZW5hYmxlZExpYnJhcmllcyk7bnVsbCE9YS5kZWZhdWx0TGlicmFyaWVzJiYoU2lkZWJhci5wcm90b3R5cGUuZGVmYXVsdEVudHJpZXM9YS5kZWZhdWx0TGlicmFyaWVzKTtudWxsIT1hLmRlZmF1bHRDdXN0b21MaWJyYXJpZXMmJihFZGl0b3IuZGVmYXVsdEN1c3RvbUxpYnJhcmllcz1hLmRlZmF1bHRDdXN0b21MaWJyYXJpZXMpOwpudWxsIT1hLmVuYWJsZUN1c3RvbUxpYnJhcmllcyYmKEVkaXRvci5lbmFibGVDdXN0b21MaWJyYXJpZXM9YS5lbmFibGVDdXN0b21MaWJyYXJpZXMpO251bGwhPWEuZGVmYXVsdFZlcnRleFN0eWxlJiYoR3JhcGgucHJvdG90eXBlLmRlZmF1bHRWZXJ0ZXhTdHlsZT1hLmRlZmF1bHRWZXJ0ZXhTdHlsZSk7bnVsbCE9YS5kZWZhdWx0RWRnZVN0eWxlJiYoR3JhcGgucHJvdG90eXBlLmRlZmF1bHRFZGdlU3R5bGU9YS5kZWZhdWx0RWRnZVN0eWxlKTthLmVtcHR5RGlhZ3JhbVhtbCYmKEVkaXRvclVpLnByb3RvdHlwZS5lbXB0eURpYWdyYW1YbWw9YS5lbXB0eURpYWdyYW1YbWwpO2EudGh1bWJXaWR0aCYmKFNpZGViYXIucHJvdG90eXBlLnRodW1iV2lkdGg9YS50aHVtYldpZHRoKTthLnRodW1iSGVpZ2h0JiYoU2lkZWJhci5wcm90b3R5cGUudGh1bWJIZWlnaHQ9YS50aHVtYkhlaWdodCk7YS5lbXB0eUxpYnJhcnlYbWwmJihFZGl0b3JVaS5wcm90b3R5cGUuZW1wdHlMaWJyYXJ5WG1sPWEuZW1wdHlMaWJyYXJ5WG1sKTsKYS5zaWRlYmFyV2lkdGgmJihFZGl0b3JVaS5wcm90b3R5cGUuaHNwbGl0UG9zaXRpb249YS5zaWRlYmFyV2lkdGgpO2EuZm9udENzcyYmRWRpdG9yLmNvbmZpZ3VyZUZvbnRDc3MoYS5mb250Q3NzKTtudWxsIT1hLmF1dG9zYXZlRGVsYXkmJihlPXBhcnNlSW50KGEuYXV0b3NhdmVEZWxheSksIWlzTmFOKGUpJiYwPGU/RHJhd2lvRmlsZS5wcm90b3R5cGUuYXV0b3NhdmVEZWxheT1lOkVkaXRvclVpLmRlYnVnKCJJbnZhbGlkIGF1dG9zYXZlRGVsYXk6ICIrYS5hdXRvc2F2ZURlbGF5KSk7aWYobnVsbCE9YS5wbHVnaW5zJiYhYilmb3IoQXBwLmluaXRQbHVnaW5DYWxsYmFjaygpLGU9MDtlPGEucGx1Z2lucy5sZW5ndGg7ZSsrKW14c2NyaXB0KGEucGx1Z2luc1tlXSl9fTtFZGl0b3IuY29uZmlndXJlRm9udENzcz1mdW5jdGlvbihhKXtpZihudWxsIT1hKXtFZGl0b3IucHJvdG90eXBlLmZvbnRDc3M9YTt2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgic2NyaXB0IilbMF07CmlmKG51bGwhPWImJm51bGwhPWIucGFyZW50Tm9kZSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtlLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQvY3NzIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGIpO2E9YS5zcGxpdCgidXJsKCIpO2ZvcihlPTE7ZTxhLmxlbmd0aDtlKyspe3ZhciBjPWFbZV0uaW5kZXhPZigiKSIpLGM9YVtlXS5zdWJzdHJpbmcoMCxjKS5yZXBsYWNlKFJlZ0V4cCgiXltcXHNcIiddKyIsImciKSwiIikucmVwbGFjZShSZWdFeHAoIltcXHNcIiddKyQiLCJnIiksIiIpLGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGluayIpO2Quc2V0QXR0cmlidXRlKCJyZWwiLCJwcmVsb2FkIik7ZC5zZXRBdHRyaWJ1dGUoImhyZWYiLGMpO2Quc2V0QXR0cmlidXRlKCJhcyIsImZvbnQiKTtkLnNldEF0dHJpYnV0ZSgiY3Jvc3NvcmlnaW4iLCIiKTtiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGQsCmIpfX19fTtFZGl0b3IuR09PR0xFX0ZPTlRTPSJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9IjtFZGl0b3IuR1VJRF9BTFBIQUJFVD0iMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotXyI7RWRpdG9yLkdVSURfTEVOR1RIPTIwO0VkaXRvci5ndWlkPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOkVkaXRvci5HVUlEX0xFTkdUSDtmb3IodmFyIGI9W10sZT0wO2U8YTtlKyspYi5wdXNoKEVkaXRvci5HVUlEX0FMUEhBQkVULmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqRWRpdG9yLkdVSURfQUxQSEFCRVQubGVuZ3RoKSkpO3JldHVybiBiLmpvaW4oIiIpfTtFZGl0b3IucHJvdG90eXBlLnRpbWVvdXQ9MjVFMztFZGl0b3IucHJvdG90eXBlLnVzZUZvcmVpZ25PYmplY3RGb3JNYXRoPSFteENsaWVudC5JU19TRjtFZGl0b3IucHJvdG90eXBlLmVkaXRCdXR0b25MaW5rPW51bGwhPXVybFBhcmFtcy5lZGl0PwpkZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLmVkaXQpOm51bGw7RWRpdG9yLnByb3RvdHlwZS5jcm9zc09yaWdpbkltYWdlcz0hbXhDbGllbnQuSVNfSUU7dmFyIGE9RWRpdG9yLnByb3RvdHlwZS5zZXRHcmFwaFhtbDtFZGl0b3IucHJvdG90eXBlLnNldEdyYXBoWG1sPWZ1bmN0aW9uKGIpe2I9bnVsbCE9YiYmIm14bGlicmFyeSIhPWIubm9kZU5hbWU/dGhpcy5leHRyYWN0R3JhcGhNb2RlbChiKTpudWxsO2lmKG51bGwhPWIpe3ZhciBlPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInBhcnNlcmVycm9yIik7aWYobnVsbCE9ZSYmMDxlLmxlbmd0aCl7dmFyIGU9ZVswXSxjPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpO251bGwhPWMmJjA8Yy5sZW5ndGgmJihlPWNbMF0pO3Rocm93e21lc3NhZ2U6bXhVdGlscy5nZXRUZXh0Q29udGVudChlKX07fWlmKCJteEdyYXBoTW9kZWwiPT1iLm5vZGVOYW1lKXtlPWIuZ2V0QXR0cmlidXRlKCJzdHlsZSIpfHwiZGVmYXVsdC1zdHlsZTIiOwppZigiMSI9PXVybFBhcmFtcy5lbWJlZHx8bnVsbCE9ZSYmIiIhPWUpZSE9dGhpcy5ncmFwaC5jdXJyZW50U3R5bGUmJihjPW51bGwhPXRoaXMuZ3JhcGgudGhlbWVzP3RoaXMuZ3JhcGgudGhlbWVzW2VdOm14VXRpbHMubG9hZChTVFlMRV9QQVRIKyIvIitlKyIueG1sIikuZ2V0RG9jdW1lbnRFbGVtZW50KCksbnVsbCE9YyYmKGQ9bmV3IG14Q29kZWMoYy5vd25lckRvY3VtZW50KSxkLmRlY29kZShjLHRoaXMuZ3JhcGguZ2V0U3R5bGVzaGVldCgpKSkpO2Vsc2UgaWYoYz1udWxsIT10aGlzLmdyYXBoLnRoZW1lcz90aGlzLmdyYXBoLnRoZW1lc1siZGVmYXVsdC1vbGQiXTpteFV0aWxzLmxvYWQoU1RZTEVfUEFUSCsiL2RlZmF1bHQtb2xkLnhtbCIpLmdldERvY3VtZW50RWxlbWVudCgpLG51bGwhPWMpe3ZhciBkPW5ldyBteENvZGVjKGMub3duZXJEb2N1bWVudCk7ZC5kZWNvZGUoYyx0aGlzLmdyYXBoLmdldFN0eWxlc2hlZXQoKSl9dGhpcy5ncmFwaC5jdXJyZW50U3R5bGU9ZTt0aGlzLmdyYXBoLm1hdGhFbmFibGVkPQoiMSI9PXVybFBhcmFtcy5tYXRofHwiMSI9PWIuZ2V0QXR0cmlidXRlKCJtYXRoIik7ZT1iLmdldEF0dHJpYnV0ZSgiYmFja2dyb3VuZEltYWdlIik7bnVsbCE9ZT8oZT1KU09OLnBhcnNlKGUpLHRoaXMuZ3JhcGguc2V0QmFja2dyb3VuZEltYWdlKG5ldyBteEltYWdlKGUuc3JjLGUud2lkdGgsZS5oZWlnaHQpKSk6dGhpcy5ncmFwaC5zZXRCYWNrZ3JvdW5kSW1hZ2UobnVsbCk7bXhDbGllbnQuTk9fRk89dGhpcy5ncmFwaC5tYXRoRW5hYmxlZCYmIXRoaXMudXNlRm9yZWlnbk9iamVjdEZvck1hdGg/ITA6dGhpcy5vcmlnaW5hbE5vRm9yZWlnbk9iamVjdDt0aGlzLmdyYXBoLnVzZUNzc1RyYW5zZm9ybXM9IW14Q2xpZW50Lk5PX0ZPJiZ0aGlzLmlzQ2hyb21lbGVzc1ZpZXcoKSYmdGhpcy5ncmFwaC5pc0Nzc1RyYW5zZm9ybXNTdXBwb3J0ZWQoKTt0aGlzLmdyYXBoLnVwZGF0ZUNzc1RyYW5zZm9ybSgpO3RoaXMuZ3JhcGguc2V0U2hhZG93VmlzaWJsZSgiMSI9PWIuZ2V0QXR0cmlidXRlKCJzaGFkb3ciKSwKITEpO2lmKGU9Yi5nZXRBdHRyaWJ1dGUoImV4dEZvbnRzIikpdHJ5e2ZvcihlPWUuc3BsaXQoInwiKS5tYXAoZnVuY3Rpb24oYSl7YT1hLnNwbGl0KCJeIik7cmV0dXJue25hbWU6YVswXSx1cmw6YVsxXX19KSxjPTA7YzxlLmxlbmd0aDtjKyspdGhpcy5ncmFwaC5hZGRFeHRGb250KGVbY10ubmFtZSxlW2NdLnVybCl9Y2F0Y2goUSl7Y29uc29sZS5sb2coIkV4dEZvbnRzIGZvcm1hdCBlcnJvcjogIitRLm1lc3NhZ2UpfX1hLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lbHNlIHRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJub3RBRGlhZ3JhbUZpbGUiKXx8IkludmFsaWQgZGF0YSIsdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXNzYWdlfX07fTt2YXIgYz1FZGl0b3IucHJvdG90eXBlLmdldEdyYXBoWG1sO0VkaXRvci5wcm90b3R5cGUuZ2V0R3JhcGhYbWw9ZnVuY3Rpb24oYSl7YT1udWxsIT1hP2E6ITA7dmFyIGI9Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9CnRoaXMuZ3JhcGguY3VycmVudFN0eWxlJiYiZGVmYXVsdC1zdHlsZTIiIT10aGlzLmdyYXBoLmN1cnJlbnRTdHlsZSYmYi5zZXRBdHRyaWJ1dGUoInN0eWxlIix0aGlzLmdyYXBoLmN1cnJlbnRTdHlsZSk7bnVsbCE9dGhpcy5ncmFwaC5iYWNrZ3JvdW5kSW1hZ2UmJmIuc2V0QXR0cmlidXRlKCJiYWNrZ3JvdW5kSW1hZ2UiLEpTT04uc3RyaW5naWZ5KHRoaXMuZ3JhcGguYmFja2dyb3VuZEltYWdlKSk7Yi5zZXRBdHRyaWJ1dGUoIm1hdGgiLHRoaXMuZ3JhcGgubWF0aEVuYWJsZWQ/IjEiOiIwIik7Yi5zZXRBdHRyaWJ1dGUoInNoYWRvdyIsdGhpcy5ncmFwaC5zaGFkb3dWaXNpYmxlPyIxIjoiMCIpO2lmKG51bGwhPXRoaXMuZ3JhcGguZXh0Rm9udHMmJjA8dGhpcy5ncmFwaC5leHRGb250cy5sZW5ndGgpe3ZhciBlPXRoaXMuZ3JhcGguZXh0Rm9udHMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWUrIl4iK2EudXJsfSk7Yi5zZXRBdHRyaWJ1dGUoImV4dEZvbnRzIixlLmpvaW4oInwiKSl9cmV0dXJuIGJ9OwpFZGl0b3IucHJvdG90eXBlLmlzRGF0YVN2Zz1mdW5jdGlvbihhKXt0cnl7dmFyIGI9bXhVdGlscy5wYXJzZVhtbChhKS5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7aWYobnVsbCE9YiYmKG51bGwhPWImJiI8IiE9Yi5jaGFyQXQoMCkmJiIlIiE9Yi5jaGFyQXQoMCkmJihiPXVuZXNjYXBlKHdpbmRvdy5hdG9iP2F0b2IoYik6QmFzZTY0LmRlY29kZShjb250LGIpKSksbnVsbCE9YiYmIiUiPT1iLmNoYXJBdCgwKSYmKGI9ZGVjb2RlVVJJQ29tcG9uZW50KGIpKSxudWxsIT1iJiYwPGIubGVuZ3RoKSl7dmFyIGU9bXhVdGlscy5wYXJzZVhtbChiKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuIm14ZmlsZSI9PWUubm9kZU5hbWV8fCJteEdyYXBoTW9kZWwiPT1lLm5vZGVOYW1lfX1jYXRjaChNKXt9cmV0dXJuITF9O0VkaXRvci5wcm90b3R5cGUuZXh0cmFjdEdyYXBoTW9kZWw9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiBFZGl0b3IuZXh0cmFjdEdyYXBoTW9kZWwuYXBwbHkodGhpcywKYXJndW1lbnRzKX07dmFyIGY9RWRpdG9yLnByb3RvdHlwZS5yZXNldEdyYXBoO0VkaXRvci5wcm90b3R5cGUucmVzZXRHcmFwaD1mdW5jdGlvbigpe3RoaXMuZ3JhcGgubWF0aEVuYWJsZWQ9IjEiPT11cmxQYXJhbXMubWF0aDt0aGlzLmdyYXBoLnZpZXcueDA9bnVsbDt0aGlzLmdyYXBoLnZpZXcueTA9bnVsbDtteENsaWVudC5OT19GTz10aGlzLmdyYXBoLm1hdGhFbmFibGVkJiYhdGhpcy51c2VGb3JlaWduT2JqZWN0Rm9yTWF0aD8hMDp0aGlzLm9yaWdpbmFsTm9Gb3JlaWduT2JqZWN0O3RoaXMuZ3JhcGgudXNlQ3NzVHJhbnNmb3Jtcz0hbXhDbGllbnQuTk9fRk8mJnRoaXMuaXNDaHJvbWVsZXNzVmlldygpJiZ0aGlzLmdyYXBoLmlzQ3NzVHJhbnNmb3Jtc1N1cHBvcnRlZCgpO3RoaXMuZ3JhcGgudXBkYXRlQ3NzVHJhbnNmb3JtKCk7Zi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBkPUVkaXRvci5wcm90b3R5cGUudXBkYXRlR3JhcGhDb21wb25lbnRzO0VkaXRvci5wcm90b3R5cGUudXBkYXRlR3JhcGhDb21wb25lbnRzPQpmdW5jdGlvbigpe2QuYXBwbHkodGhpcyxhcmd1bWVudHMpO214Q2xpZW50Lk5PX0ZPPXRoaXMuZ3JhcGgubWF0aEVuYWJsZWQmJiF0aGlzLnVzZUZvcmVpZ25PYmplY3RGb3JNYXRoJiZudWxsIT1FZGl0b3IuTWF0aEpheFJlbmRlcj8hMDp0aGlzLm9yaWdpbmFsTm9Gb3JlaWduT2JqZWN0O3RoaXMuZ3JhcGgudXNlQ3NzVHJhbnNmb3Jtcz0hbXhDbGllbnQuTk9fRk8mJnRoaXMuaXNDaHJvbWVsZXNzVmlldygpJiZ0aGlzLmdyYXBoLmlzQ3NzVHJhbnNmb3Jtc1N1cHBvcnRlZCgpO3RoaXMuZ3JhcGgudXBkYXRlQ3NzVHJhbnNmb3JtKCl9O0VkaXRvci5pbml0TWF0aD1mdW5jdGlvbihhLGIpe2E9bnVsbCE9YT9hOkRSQVdfTUFUSF9VUkwrIi9NYXRoSmF4LmpzIjtFZGl0b3IubWF0aEpheFF1ZXVlPVtdO0VkaXRvci5kb01hdGhKYXhSZW5kZXI9ZnVuY3Rpb24oYSl7d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXsiaGlkZGVuIiE9YS5zdHlsZS52aXNpYmlsaXR5JiZNYXRoSmF4Lkh1Yi5RdWV1ZShbIlR5cGVzZXQiLApNYXRoSmF4Lkh1YixhXSl9LDApfTt3aW5kb3cuTWF0aEpheD17c2tpcFN0YXJ0dXBUeXBlc2V0OiEwLHNob3dNYXRoTWVudTohMSxtZXNzYWdlU3R5bGU6Im5vbmUiLEF1dGhvckluaXQ6ZnVuY3Rpb24oKXtNYXRoSmF4Lkh1Yi5Db25maWcoYnx8e2pheDpbImlucHV0L1RlWCIsImlucHV0L01hdGhNTCIsImlucHV0L0FzY2lpTWF0aCIsIm91dHB1dC9TVkciXSxleHRlbnNpb25zOlsidGV4MmpheC5qcyIsIm1tbDJqYXguanMiLCJhc2NpaW1hdGgyamF4LmpzIl0sVGVYOntleHRlbnNpb25zOlsiQU1TbWF0aC5qcyIsIkFNU3N5bWJvbHMuanMiLCJub0Vycm9ycy5qcyIsIm5vVW5kZWZpbmVkLmpzIl19LFNWRzp7Zm9udDpudWxsIT11cmxQYXJhbXNbIm1hdGgtZm9udCJdP2RlY29kZVVSSUNvbXBvbmVudCh1cmxQYXJhbXNbIm1hdGgtZm9udCJdKToiVGVYIix1c2VGb250Q2FjaGU6ITF9LHRleDJqYXg6e2lnbm9yZUNsYXNzOiJteENlbGxFZGl0b3IifSxhc2NpaW1hdGgyamF4OntpZ25vcmVDbGFzczoibXhDZWxsRWRpdG9yIn19KTsKTWF0aEpheC5IdWIuUmVnaXN0ZXIuU3RhcnR1cEhvb2soIkJlZ2luIixmdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8RWRpdG9yLm1hdGhKYXhRdWV1ZS5sZW5ndGg7YSsrKUVkaXRvci5kb01hdGhKYXhSZW5kZXIoRWRpdG9yLm1hdGhKYXhRdWV1ZVthXSl9KX19O0VkaXRvci5NYXRoSmF4UmVuZGVyPWZ1bmN0aW9uKGEpeyJ1bmRlZmluZWQiIT09dHlwZW9mIE1hdGhKYXgmJiJ1bmRlZmluZWQiIT09dHlwZW9mIE1hdGhKYXguSHViP0VkaXRvci5kb01hdGhKYXhSZW5kZXIoYSk6RWRpdG9yLm1hdGhKYXhRdWV1ZS5wdXNoKGEpfTtFZGl0b3IuTWF0aEpheENsZWFyPWZ1bmN0aW9uKCl7RWRpdG9yLm1hdGhKYXhRdWV1ZT1bXX07dmFyIGU9RWRpdG9yLnByb3RvdHlwZS5pbml0O0VkaXRvci5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe2UuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZ3JhcGguYWRkTGlzdGVuZXIobXhFdmVudC5TSVpFLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsCmIpe251bGwhPXRoaXMuZ3JhcGguY29udGFpbmVyJiZ0aGlzLmdyYXBoLm1hdGhFbmFibGVkJiYhdGhpcy5ncmFwaC5ibG9ja01hdGhSZW5kZXImJkVkaXRvci5NYXRoSmF4UmVuZGVyKHRoaXMuZ3JhcGguY29udGFpbmVyKX0pKX07dmFyIGM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInNjcmlwdCIpO2lmKG51bGwhPWMmJjA8Yy5sZW5ndGgpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNjcmlwdCIpO2QudHlwZT0idGV4dC9qYXZhc2NyaXB0IjtkLnNyYz1hO2NbMF0ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkKX19O0VkaXRvci5wcm90b3R5cGUuY3N2VG9BcnJheT1mdW5jdGlvbihhKXtpZighL15ccyooPzonW14nXFxdKig/OlxcW1xTXHNdW14nXFxdKikqJ3wiW14iXFxdKig/OlxcW1xTXHNdW14iXFxdKikqInxbXiwnIlxzXFxdKig/OlxzK1teLCciXHNcXF0rKSopXHMqKD86LFxzKig/OidbXidcXF0qKD86XFxbXFNcc11bXidcXF0qKSonfCJbXiJcXF0qKD86XFxbXFNcc11bXiJcXF0qKSoifFteLCciXHNcXF0qKD86XHMrW14sJyJcc1xcXSspKilccyopKiQvLnRlc3QoYSkpcmV0dXJuIG51bGw7CnZhciBiPVtdO2EucmVwbGFjZSgvKD8hXHMqJClccyooPzonKFteJ1xcXSooPzpcXFtcU1xzXVteJ1xcXSopKiknfCIoW14iXFxdKig/OlxcW1xTXHNdW14iXFxdKikqKSJ8KFteLCciXHNcXF0qKD86XHMrW14sJyJcc1xcXSspKikpXHMqKD86LHwkKS9nLGZ1bmN0aW9uKGEsZSxjLGQpe3ZvaWQgMCE9PWU/Yi5wdXNoKGUucmVwbGFjZSgvXFwnL2csIiciKSk6dm9pZCAwIT09Yz9iLnB1c2goYy5yZXBsYWNlKC9cXCIvZywnIicpKTp2b2lkIDAhPT1kJiZiLnB1c2goZCk7cmV0dXJuIiJ9KTsvLFxzKiQvLnRlc3QoYSkmJmIucHVzaCgiIik7cmV0dXJuIGJ9O0VkaXRvci5wcm90b3R5cGUuaXNDb3JzRW5hYmxlZEZvclVybD1mdW5jdGlvbihhKXtpZihteENsaWVudC5JU19DSFJPTUVBUFB8fEVkaXRvclVpLmlzRWxlY3Ryb25BcHApcmV0dXJuITA7bnVsbCE9dXJsUGFyYW1zLmNvcnMmJm51bGw9PXRoaXMuY29yc1JlZ0V4cCYmKHRoaXMuY29yc1JlZ0V4cD1uZXcgUmVnRXhwKGRlY29kZVVSSUNvbXBvbmVudCh1cmxQYXJhbXMuY29ycykpKTsKcmV0dXJuIG51bGwhPXRoaXMuY29yc1JlZ0V4cCYmdGhpcy5jb3JzUmVnRXhwLnRlc3QoYSl8fCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vIj09PWEuc3Vic3RyaW5nKDAsMzQpfTtFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUltYWdlVXJsQ29udmVydGVyPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14VXJsQ29udmVydGVyO2EudXBkYXRlQmFzZVVybCgpO3ZhciBiPWEuY29udmVydCxlPXRoaXM7YS5jb252ZXJ0PWZ1bmN0aW9uKGMpe2lmKG51bGwhPWMpe3ZhciBkPSJodHRwOi8vIj09Yy5zdWJzdHJpbmcoMCw3KXx8Imh0dHBzOi8vIj09Yy5zdWJzdHJpbmcoMCw4KTtkJiYhbmF2aWdhdG9yLm9uTGluZT9jPUVkaXRvci5zdmdCcm9rZW5JbWFnZS5zcmM6IWR8fGMuc3Vic3RyaW5nKDAsYS5iYXNlVXJsLmxlbmd0aCk9PWEuYmFzZVVybHx8ZS5jcm9zc09yaWdpbkltYWdlcyYmZS5pc0NvcnNFbmFibGVkRm9yVXJsKGMpPyJjaHJvbWUtZXh0ZW5zaW9uOi8vIj09Yy5zdWJzdHJpbmcoMCwKMTkpfHxteENsaWVudC5JU19DSFJPTUVBUFB8fChjPWIuYXBwbHkodGhpcyxhcmd1bWVudHMpKTpjPVBST1hZX1VSTCsiP3VybD0iK2VuY29kZVVSSUNvbXBvbmVudChjKX1yZXR1cm4gY307cmV0dXJuIGF9O0VkaXRvci5jcmVhdGVTdmdEYXRhVXJpPWZ1bmN0aW9uKGEpe3JldHVybiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCIrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYSkpKX07RWRpdG9yLnByb3RvdHlwZS5jb252ZXJ0SW1hZ2VUb0RhdGFVcmk9ZnVuY3Rpb24oYSxiKXt0cnl7dmFyIGU9ITAsYz13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2U9ITE7YihFZGl0b3Iuc3ZnQnJva2VuSW1hZ2Uuc3JjKX0pLHRoaXMudGltZW91dCk7aWYoLyhcLnN2ZykkL2kudGVzdChhKSlteFV0aWxzLmdldChhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3dpbmRvdy5jbGVhclRpbWVvdXQoYyk7ZSYmYihFZGl0b3IuY3JlYXRlU3ZnRGF0YVVyaShhLmdldFRleHQoKSkpfSksCmZ1bmN0aW9uKCl7d2luZG93LmNsZWFyVGltZW91dChjKTtlJiZiKEVkaXRvci5zdmdCcm9rZW5JbWFnZS5zcmMpfSk7ZWxzZXt2YXIgZD1uZXcgSW1hZ2U7dGhpcy5jcm9zc09yaWdpbkltYWdlcyYmKGQuY3Jvc3NPcmlnaW49ImFub255bW91cyIpO2Qub25sb2FkPWZ1bmN0aW9uKCl7d2luZG93LmNsZWFyVGltZW91dChjKTtpZihlKXRyeXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxmPWEuZ2V0Q29udGV4dCgiMmQiKTthLmhlaWdodD1kLmhlaWdodDthLndpZHRoPWQud2lkdGg7Zi5kcmF3SW1hZ2UoZCwwLDApO2IoYS50b0RhdGFVUkwoKSl9Y2F0Y2goWil7YihFZGl0b3Iuc3ZnQnJva2VuSW1hZ2Uuc3JjKX19O2Qub25lcnJvcj1mdW5jdGlvbigpe3dpbmRvdy5jbGVhclRpbWVvdXQoYyk7ZSYmYihFZGl0b3Iuc3ZnQnJva2VuSW1hZ2Uuc3JjKX07ZC5zcmM9YX19Y2F0Y2goSSl7YihFZGl0b3Iuc3ZnQnJva2VuSW1hZ2Uuc3JjKX19O0VkaXRvci5wcm90b3R5cGUuY29udmVydEltYWdlcz0KZnVuY3Rpb24oYSxiLGUsYyl7bnVsbD09YyYmKGM9dGhpcy5jcmVhdGVJbWFnZVVybENvbnZlcnRlcigpKTt2YXIgZD0wLGY9ZXx8e307ZT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihlLGcpe2Zvcih2YXIgbD1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpLG49MDtuPGwubGVuZ3RoO24rKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihlKXt0cnl7aWYobnVsbCE9ZSl7dmFyIGw9Yy5jb252ZXJ0KGUuZ2V0QXR0cmlidXRlKGcpKTtpZihudWxsIT1sJiYiZGF0YToiIT1sLnN1YnN0cmluZygwLDUpKXt2YXIgbj1mW2xdO251bGw9PW4/KGQrKyx0aGlzLmNvbnZlcnRJbWFnZVRvRGF0YVVyaShsLGZ1bmN0aW9uKGMpe251bGwhPWMmJihmW2xdPWMsZS5zZXRBdHRyaWJ1dGUoZyxjKSk7ZC0tOzA9PWQmJmIoYSl9KSk6ZS5zZXRBdHRyaWJ1dGUoZyxuKX1lbHNlIG51bGwhPWwmJmUuc2V0QXR0cmlidXRlKGcsbCl9fWNhdGNoKGRhKXt9fSkobFtuXSl9KTtlKCJpbWFnZSIsInhsaW5rOmhyZWYiKTsKZSgiaW1nIiwic3JjIik7MD09ZCYmYihhKX07RWRpdG9yLmJhc2U2NEVuY29kZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9IiIsZT0wLGM9YS5sZW5ndGgsZCxmLGc7ZTxjOyl7ZD1hLmNoYXJDb2RlQXQoZSsrKSYyNTU7aWYoZT09Yyl7Yis9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLmNoYXJBdChkPj4yKTtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KChkJjMpPDw0KTtiKz0iPT0iO2JyZWFrfWY9YS5jaGFyQ29kZUF0KGUrKyk7aWYoZT09Yyl7Yis9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLmNoYXJBdChkPj4yKTtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KChkJgozKTw8NHwoZiYyNDApPj40KTtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KChmJjE1KTw8Mik7Yis9Ij0iO2JyZWFrfWc9YS5jaGFyQ29kZUF0KGUrKyk7Yis9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLmNoYXJBdChkPj4yKTtiKz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIuY2hhckF0KChkJjMpPDw0fChmJjI0MCk+PjQpO2IrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIi5jaGFyQXQoKGYmMTUpPDwyfChnJjE5Mik+PjYpO2IrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIi5jaGFyQXQoZyY2Myl9cmV0dXJuIGJ9OwpFZGl0b3IucHJvdG90eXBlLmxvYWRVcmw9ZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsKXt0cnl7dmFyIG49IWcmJihjfHwvKFwucG5nKSgkfFw/KS9pLnRlc3QoYSl8fC8oXC5qcGU/ZykoJHxcPykvaS50ZXN0KGEpfHwvKFwuZ2lmKSgkfFw/KS9pLnRlc3QoYSl8fC8oXC5wZGYpKCR8XD8pL2kudGVzdChhKSk7ZD1udWxsIT1kP2Q6ITA7dmFyIHA9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtteFV0aWxzLmdldChhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKDIwMDw9YS5nZXRTdGF0dXMoKSYmMjk5Pj1hLmdldFN0YXR1cygpKXtpZihudWxsIT1iKXt2YXIgYz1hLmdldFRleHQoKTtpZihuKXtpZigoOT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwxMD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSYmInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93Lm14VXRpbHNCaW5hcnlUb0FycmF5KXthPW14VXRpbHNCaW5hcnlUb0FycmF5KGEucmVxdWVzdC5yZXNwb25zZUJvZHkpLnRvQXJyYXkoKTsKZm9yKHZhciBjPUFycmF5KGEubGVuZ3RoKSxkPTA7ZDxhLmxlbmd0aDtkKyspY1tkXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGFbZF0pO2M9Yy5qb2luKCIiKX1mPW51bGwhPWY/ZjoiZGF0YTppbWFnZS9wbmc7YmFzZTY0LCI7Yz1mK0VkaXRvci5iYXNlNjRFbmNvZGUoYyl9YihjKX19ZWxzZSBudWxsIT1lJiYoMD09YS5nZXRTdGF0dXMoKT9lKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiYWNjZXNzRGVuaWVkIil9LGEpOmUoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpKyIgIithLmdldFN0YXR1cygpfSxhKSl9KSxmdW5jdGlvbihhKXtudWxsIT1lJiZlKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsiICIrYS5nZXRTdGF0dXMoKX0pfSxuLHRoaXMudGltZW91dCxmdW5jdGlvbigpe2QmJm51bGwhPWUmJmUoe2NvZGU6QXBwLkVSUk9SX1RJTUVPVVQscmV0cnk6cH0pfSxsKX0pO3AoKX1jYXRjaChiYSl7bnVsbCE9ZSYmZShiYSl9fTtFZGl0b3IucHJvdG90eXBlLmVtYmVkQ3NzRm9udHM9CmZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gZShhKXtyZXR1cm4gYS5yZXBsYWNlKFJlZ0V4cCgiXltcXHNcIiddKyIsImciKSwiIikucmVwbGFjZShSZWdFeHAoIltcXHNcIiddKyQiLCJnIiksIiIpfXZhciBjPWEuc3BsaXQoInVybCgiKSxkPTA7bnVsbD09dGhpcy5jYWNoZWRGb250cyYmKHRoaXMuY2FjaGVkRm9udHM9e30pO3ZhciBmPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYoMD09ZCl7Zm9yKHZhciBhPVtjWzBdXSxmPTE7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl0uaW5kZXhPZigiKSIpO2EucHVzaCgndXJsKCInKTthLnB1c2godGhpcy5jYWNoZWRGb250c1tlKGNbZl0uc3Vic3RyaW5nKDAsZykpXSk7YS5wdXNoKCciJytjW2ZdLnN1YnN0cmluZyhnKSl9YihhLmpvaW4oIiIpKX19KTtpZigwPGMubGVuZ3RoKXtmb3IodmFyIGc9MTtnPGMubGVuZ3RoO2crKyl7dmFyIGw9Y1tnXS5pbmRleE9mKCIpIiksbj1udWxsLHA9Y1tnXS5pbmRleE9mKCJmb3JtYXQoIixsKTsKMDxwJiYobj1lKGNbZ10uc3Vic3RyaW5nKHArNyxjW2ddLmluZGV4T2YoIikiLHApKSkpO214VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKG51bGw9PXRoaXMuY2FjaGVkRm9udHNbYV0pe3RoaXMuY2FjaGVkRm9udHNbYV09YTtkKys7dmFyIGI9ImFwcGxpY2F0aW9uL3gtZm9udC10dGYiO2lmKCJzdmciPT1ufHwvKFwuc3ZnKSgkfFw/KS9pLnRlc3QoYSkpYj0iaW1hZ2Uvc3ZnK3htbCI7ZWxzZSBpZigib3RmIj09bnx8ImVtYmVkZGVkLW9wZW50eXBlIj09bnx8LyhcLm90ZikoJHxcPykvaS50ZXN0KGEpKWI9ImFwcGxpY2F0aW9uL3gtZm9udC1vcGVudHlwZSI7ZWxzZSBpZigid29mZiI9PW58fC8oXC53b2ZmKSgkfFw/KS9pLnRlc3QoYSkpYj0iYXBwbGljYXRpb24vZm9udC13b2ZmIjtlbHNlIGlmKCJ3b2ZmMiI9PW58fC8oXC53b2ZmMikoJHxcPykvaS50ZXN0KGEpKWI9ImFwcGxpY2F0aW9uL2ZvbnQtd29mZjIiO2Vsc2UgaWYoImVvdCI9PW58fC8oXC5lb3QpKCR8XD8pL2kudGVzdChhKSliPQoiYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QiO2Vsc2UgaWYoInNmbnQiPT1ufHwvKFwuc2ZudCkoJHxcPykvaS50ZXN0KGEpKWI9ImFwcGxpY2F0aW9uL2ZvbnQtc2ZudCI7dmFyIGU9YTsvXmh0dHBzPzpcL1wvLy50ZXN0KGUpJiYhdGhpcy5pc0NvcnNFbmFibGVkRm9yVXJsKGUpJiYoZT1QUk9YWV9VUkwrIj91cmw9IitlbmNvZGVVUklDb21wb25lbnQoYSkpO3RoaXMubG9hZFVybChlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuY2FjaGVkRm9udHNbYV09YjtkLS07ZigpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ZC0tO2YoKX0pLCEwLG51bGwsImRhdGE6IitiKyI7Y2hhcnNldD11dGYtODtiYXNlNjQsIil9fSkoZShjW2ddLnN1YnN0cmluZygwLGwpKSxuKX1mKCl9ZWxzZSBiKGEpfTtFZGl0b3IucHJvdG90eXBlLmxvYWRGb250cz1mdW5jdGlvbihhKXtudWxsIT10aGlzLmZvbnRDc3MmJm51bGw9PXRoaXMucmVzb2x2ZWRGb250Q3NzP3RoaXMuZW1iZWRDc3NGb250cyh0aGlzLmZvbnRDc3MsCm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMucmVzb2x2ZWRGb250Q3NzPWI7YSgpfSkpOmEoKX07RWRpdG9yLnByb3RvdHlwZS5lbWJlZEV4dEZvbnRzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZXh0Rm9udHM7aWYobnVsbCE9YiYmMDxiLmxlbmd0aCl7dmFyIGU9IiIsYz0wO251bGw9PXRoaXMuY2FjaGVkR29vZ2xlRm9udHMmJih0aGlzLmNhY2hlZEdvb2dsZUZvbnRzPXt9KTtmb3IodmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXswPT1jJiZ0aGlzLmVtYmVkQ3NzRm9udHMoZSxhKX0pLGY9MDtmPGIubGVuZ3RoO2YrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpezA9PWIuaW5kZXhPZihFZGl0b3IuR09PR0xFX0ZPTlRTKT9udWxsPT10aGlzLmNhY2hlZEdvb2dsZUZvbnRzW2JdPyhjKyssdGhpcy5sb2FkVXJsKGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5jYWNoZWRHb29nbGVGb250c1tiXT1hO2UrPWE7Yy0tOwpkKCl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLS07ZSs9IkBpbXBvcnQgdXJsKCIrYisiKTsiO2QoKX0pKSk6ZSs9dGhpcy5jYWNoZWRHb29nbGVGb250c1tiXTplKz0nQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6ICInK2ErJyI7c3JjOiB1cmwoIicrYisnIik7fSd9KShiW2ZdLm5hbWUsYltmXS51cmwpO2QoKX1lbHNlIGEoKX07RWRpdG9yLnByb3RvdHlwZS5hZGRNYXRoQ3NzPWZ1bmN0aW9uKGEpe2E9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGVmcyIpO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpZm9yKHZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdHlsZSIpLGU9MDtlPGIubGVuZ3RoO2UrKykwPG14VXRpbHMuZ2V0VGV4dENvbnRlbnQoYltlXSkuaW5kZXhPZigiTWF0aEpheCIpJiZhWzBdLmFwcGVuZENoaWxkKGJbZV0uY2xvbmVOb2RlKCEwKSl9O0VkaXRvci5wcm90b3R5cGUuYWRkRm9udENzcz1mdW5jdGlvbihhLGIpe2I9bnVsbCE9Yj8KYjp0aGlzLmZvbnRDc3M7aWYobnVsbCE9Yil7dmFyIGU9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGVmcyIpLGM9YS5vd25lckRvY3VtZW50OzA9PWUubGVuZ3RoPyhlPW51bGwhPWMuY3JlYXRlRWxlbWVudE5TP2MuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZGVmcyIpOmMuY3JlYXRlRWxlbWVudCgiZGVmcyIpLG51bGwhPWEuZmlyc3RDaGlsZD9hLmluc2VydEJlZm9yZShlLGEuZmlyc3RDaGlsZCk6YS5hcHBlbmRDaGlsZChlKSk6ZT1lWzBdO2M9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJzdHlsZSIpOmMuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtjLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQvY3NzIik7bXhVdGlscy5zZXRUZXh0Q29udGVudChjLGIpO2UuYXBwZW5kQ2hpbGQoYyl9fTtFZGl0b3IucHJvdG90eXBlLmlzRXhwb3J0VG9DYW52YXM9ZnVuY3Rpb24oKXtyZXR1cm4gbXhDbGllbnQuSVNfQ0hST01FQVBQfHwKdGhpcy51c2VDYW52YXNGb3JFeHBvcnR9O0VkaXRvci5wcm90b3R5cGUuZXhwb3J0VG9DYW52YXM9ZnVuY3Rpb24oYSxiLGUsYyxkLGYsZyxsLG4scCx0LGssbSx5LHYseCl7dHJ5e2Y9bnVsbCE9Zj9mOiEwO2c9bnVsbCE9Zz9nOiEwO2s9bnVsbCE9az9rOnRoaXMuZ3JhcGg7bT1udWxsIT1tP206MDt2YXIgdT1uP251bGw6ay5iYWNrZ3JvdW5kO3U9PW14Q29uc3RhbnRzLk5PTkUmJih1PW51bGwpO251bGw9PXUmJih1PWMpO251bGw9PXUmJjA9PW4mJih1PXg/dGhpcy5ncmFwaC5kZWZhdWx0UGFnZUJhY2tncm91bmRDb2xvcjoiI2ZmZmZmZiIpO3RoaXMuY29udmVydEltYWdlcyhrLmdldFN2ZyhudWxsLG51bGwsbnVsbCx5LG51bGwsZyxudWxsLG51bGwsbnVsbCxwLG51bGwseCksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7dHJ5e3ZhciBjPW5ldyBJbWFnZTtjLm9ubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RyeXt2YXIgZz1mdW5jdGlvbigpe214Q2xpZW50LklTX1NGPwp3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe3kuZHJhd0ltYWdlKGMsbS9sLG0vbCk7YShuKX0sMCk6KHkuZHJhd0ltYWdlKGMsbS9sLG0vbCksYShuKSl9LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIikscD1wYXJzZUludChlLmdldEF0dHJpYnV0ZSgid2lkdGgiKSksdD1wYXJzZUludChlLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IikpO2w9bnVsbCE9bD9sOjE7bnVsbCE9YiYmKGw9Zj9NYXRoLm1pbigxLE1hdGgubWluKDMqYi8oNCp0KSxiL3ApKTpiL3ApO3A9TWF0aC5jZWlsKGwqcCkrMiptO3Q9TWF0aC5jZWlsKGwqdCkrMiptO24uc2V0QXR0cmlidXRlKCJ3aWR0aCIscCk7bi5zZXRBdHRyaWJ1dGUoImhlaWdodCIsdCk7dmFyIHk9bi5nZXRDb250ZXh0KCIyZCIpO251bGwhPXUmJih5LmJlZ2luUGF0aCgpLHkucmVjdCgwLDAscCx0KSx5LmZpbGxTdHlsZT11LHkuZmlsbCgpKTt5LnNjYWxlKGwsbCk7aWYodil7dmFyIHg9ay52aWV3LEE9eC5zY2FsZTt4LnNjYWxlPQoxO3ZhciB6PWJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHguY3JlYXRlU3ZnR3JpZCh4LmdyaWRDb2xvcikpKSk7eC5zY2FsZT1BO3ZhciB6PSJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCIreixxPWsuZ3JpZFNpemUqeC5ncmlkU3RlcHMqbCxDPWsuZ2V0R3JhcGhCb3VuZHMoKSxLPXgudHJhbnNsYXRlLngqQSxJPXgudHJhbnNsYXRlLnkqQSxCPUsrKEMueC1LKS9BLEQ9SSsoQy55LUkpL0EsRT1uZXcgSW1hZ2U7RS5vbmxvYWQ9ZnVuY3Rpb24oKXt0cnl7Zm9yKHZhciBhPS1NYXRoLnJvdW5kKHEtbXhVdGlscy5tb2QoKEstQikqbCxxKSksYj0tTWF0aC5yb3VuZChxLW14VXRpbHMubW9kKChJLUQpKmwscSkpO2E8cDthKz1xKWZvcih2YXIgZT1iO2U8dDtlKz1xKXkuZHJhd0ltYWdlKEUsYS9sLGUvbCk7ZygpfWNhdGNoKGphKXtudWxsIT1kJiZkKGphKX19O0Uub25lcnJvcj1mdW5jdGlvbihhKXtudWxsIT1kJiZkKGEpfTtFLnNyYz16fWVsc2UgZygpfWNhdGNoKG9hKXtudWxsIT0KZCYmZChvYSl9fSk7Yy5vbmVycm9yPWZ1bmN0aW9uKGEpe251bGwhPWQmJmQoYSl9O3AmJnRoaXMuZ3JhcGguYWRkU3ZnU2hhZG93KGUpO3RoaXMuZ3JhcGgubWF0aEVuYWJsZWQmJnRoaXMuYWRkTWF0aENzcyhlKTt2YXIgZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RyeXtudWxsIT10aGlzLnJlc29sdmVkRm9udENzcyYmdGhpcy5hZGRGb250Q3NzKGUsdGhpcy5yZXNvbHZlZEZvbnRDc3MpLGMuc3JjPUVkaXRvci5jcmVhdGVTdmdEYXRhVXJpKG14VXRpbHMuZ2V0WG1sKGUpKX1jYXRjaChPKXtudWxsIT1kJiZkKE8pfX0pO3RoaXMuZW1iZWRFeHRGb250cyhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0cnl7bnVsbCE9YSYmdGhpcy5hZGRGb250Q3NzKGUsYSksdGhpcy5sb2FkRm9udHMoZyl9Y2F0Y2goWCl7bnVsbCE9ZCYmZChYKX19KSl9Y2F0Y2goTyl7bnVsbCE9ZCYmZChPKX19KSxlLHQpfWNhdGNoKFApe251bGwhPWQmJmQoUCl9fTtFZGl0b3IuY3JjVGFibGU9CltdO2Zvcih2YXIgaz0wOzI1Nj5rO2srKylmb3IodmFyIG09ayxxPTA7OD5xO3ErKyltPTE9PShtJjEpPzM5ODgyOTIzODRebT4+PjE6bT4+PjEsRWRpdG9yLmNyY1RhYmxlW2tdPW07RWRpdG9yLnVwZGF0ZUNSQz1mdW5jdGlvbihhLGIsZSxjKXtmb3IodmFyIGQ9MDtkPGM7ZCsrKWE9RWRpdG9yLmNyY1RhYmxlWyhhXmIuY2hhckNvZGVBdChlK2QpKSYyNTVdXmE+Pj44O3JldHVybiBhfTtFZGl0b3IuY3JjMzI9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPS0xLGU9MDtlPGEubGVuZ3RoO2UrKyliPWI+Pj44XkVkaXRvci5jcmNUYWJsZVsoYl5hLmNoYXJDb2RlQXQoZSkpJjI1NV07cmV0dXJuKGJeLTEpPj4+MH07RWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nPWZ1bmN0aW9uKGEsYixlLGMsZCl7ZnVuY3Rpb24gZihhLGIpe3ZhciBlPW47bis9YjtyZXR1cm4gYS5zdWJzdHJpbmcoZSxuKX1mdW5jdGlvbiBnKGEpe2E9ZihhLDQpO3JldHVybiBhLmNoYXJDb2RlQXQoMykrKGEuY2hhckNvZGVBdCgyKTw8CjgpKyhhLmNoYXJDb2RlQXQoMSk8PDE2KSsoYS5jaGFyQ29kZUF0KDApPDwyNCl9ZnVuY3Rpb24gbChhKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShhPj4yNCYyNTUsYT4+MTYmMjU1LGE+PjgmMjU1LGEmMjU1KX1hPWEuc3Vic3RyaW5nKGEuaW5kZXhPZigiLCIpKzEpO2E9d2luZG93LmF0b2I/YXRvYihhKTpCYXNlNjQuZGVjb2RlKGEsITApO3ZhciBuPTA7aWYoZihhLDgpIT1TdHJpbmcuZnJvbUNoYXJDb2RlKDEzNykrIlBORyIrU3RyaW5nLmZyb21DaGFyQ29kZSgxMywxMCwyNiwxMCkpbnVsbCE9ZCYmZCgpO2Vsc2UgaWYoZihhLDQpLCJJSERSIiE9ZihhLDQpKW51bGwhPWQmJmQoKTtlbHNle2YoYSwxNyk7ZD1hLnN1YnN0cmluZygwLG4pO2Rve3ZhciBwPWcoYSk7aWYoIklEQVQiPT1mKGEsNCkpe2Q9YS5zdWJzdHJpbmcoMCxuLTgpOyJwSFlzIj09YiYmImRwaSI9PWU/KGU9TWF0aC5yb3VuZChjLy4wMjU0KSxlPWwoZSkrbChlKStTdHJpbmcuZnJvbUNoYXJDb2RlKDEpKToKZT1lK1N0cmluZy5mcm9tQ2hhckNvZGUoMCkrKCJ6VFh0Ij09Yj9TdHJpbmcuZnJvbUNoYXJDb2RlKDApOiIiKStjO2M9NDI5NDk2NzI5NTtjPUVkaXRvci51cGRhdGVDUkMoYyxiLDAsNCk7Yz1FZGl0b3IudXBkYXRlQ1JDKGMsZSwwLGUubGVuZ3RoKTtkKz1sKGUubGVuZ3RoKStiK2UrbChjXjQyOTQ5NjcyOTUpO2QrPWEuc3Vic3RyaW5nKG4tOCxhLmxlbmd0aCk7YnJlYWt9ZCs9YS5zdWJzdHJpbmcobi04LG4tNCtwKTtmKGEscCk7ZihhLDQpfXdoaWxlKHApO3JldHVybiJkYXRhOmltYWdlL3BuZztiYXNlNjQsIisod2luZG93LmJ0b2E/YnRvYShkKTpCYXNlNjQuZW5jb2RlKGQsITApKX19O2lmKHdpbmRvdy5Db2xvckRpYWxvZyl7RmlsZW5hbWVEaWFsb2cuZmlsZW5hbWVIZWxwTGluaz0iaHR0cHM6Ly9kZXNrLmRyYXcuaW8vc3VwcG9ydC9zb2x1dGlvbnMvYXJ0aWNsZXMvMTYwMDAwOTE0MjYiO3ZhciBiPUNvbG9yRGlhbG9nLmFkZFJlY2VudENvbG9yO0NvbG9yRGlhbG9nLmFkZFJlY2VudENvbG9yPQpmdW5jdGlvbihhLGUpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpO214U2V0dGluZ3Muc2V0UmVjZW50Q29sb3JzKENvbG9yRGlhbG9nLnJlY2VudENvbG9ycyk7bXhTZXR0aW5ncy5zYXZlKCl9O3ZhciBlPUNvbG9yRGlhbG9nLnJlc2V0UmVjZW50Q29sb3JzO0NvbG9yRGlhbG9nLnJlc2V0UmVjZW50Q29sb3JzPWZ1bmN0aW9uKCl7ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bXhTZXR0aW5ncy5zZXRSZWNlbnRDb2xvcnMoQ29sb3JEaWFsb2cucmVjZW50Q29sb3JzKTtteFNldHRpbmdzLnNhdmUoKX19d2luZG93LkVkaXREYXRhRGlhbG9nJiYoRWRpdERhdGFEaWFsb2cuZ2V0RGlzcGxheUlkRm9yQ2VsbD1mdW5jdGlvbihhLGIpe3ZhciBlPW51bGw7bnVsbCE9YS5lZGl0b3IuZ3JhcGguZ2V0TW9kZWwoKS5nZXRQYXJlbnQoYik/ZT1iLmdldElkKCk6bnVsbCE9YS5jdXJyZW50UGFnZSYmKGU9YS5jdXJyZW50UGFnZS5nZXRJZCgpKTtyZXR1cm4gZX0pO2lmKG51bGwhPXdpbmRvdy5TdHlsZUZvcm1hdFBhbmVsKXt2YXIgZz0KRm9ybWF0LnByb3RvdHlwZS5pbml0O0Zvcm1hdC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe2cuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuZWRpdG9yVWkuZWRpdG9yLmFkZExpc3RlbmVyKCJmaWxlTG9hZGVkIix0aGlzLnVwZGF0ZSl9O3ZhciBuPUZvcm1hdC5wcm90b3R5cGUucmVmcmVzaDtGb3JtYXQucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmVkaXRvclVpLmdldEN1cnJlbnRGaWxlKCl8fCIxIj09dXJsUGFyYW1zLmVtYmVkfHx0aGlzLmVkaXRvclVpLmVkaXRvci5jaHJvbWVsZXNzP24uYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXMuY2xlYXIoKX07RGlhZ3JhbUZvcm1hdFBhbmVsLnByb3RvdHlwZS5pc1NoYWRvd09wdGlvblZpc2libGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVkaXRvclVpLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIjEiPT11cmxQYXJhbXMuZW1iZWR8fG51bGwhPWEmJmEuaXNFZGl0YWJsZSgpfTtEaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmlzTWF0aE9wdGlvblZpc2libGU9CmZ1bmN0aW9uKGEpe3JldHVybiExfTt2YXIgbD1EaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZFZpZXc7RGlhZ3JhbUZvcm1hdFBhbmVsLnByb3RvdHlwZS5hZGRWaWV3PWZ1bmN0aW9uKGEpe2E9bC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5lZGl0b3JVaS5nZXRDdXJyZW50RmlsZSgpO2lmKG14Q2xpZW50LklTX1NWRyYmdGhpcy5pc1NoYWRvd09wdGlvblZpc2libGUoKSl7dmFyIGI9dGhpcy5lZGl0b3JVaSxlPWIuZWRpdG9yLmdyYXBoLGM9dGhpcy5jcmVhdGVPcHRpb24obXhSZXNvdXJjZXMuZ2V0KCJzaGFkb3ciKSxmdW5jdGlvbigpe3JldHVybiBlLnNoYWRvd1Zpc2libGV9LGZ1bmN0aW9uKGEpe3ZhciBjPW5ldyBDaGFuZ2VQYWdlU2V0dXAoYik7Yy5pZ25vcmVDb2xvcj0hMDtjLmlnbm9yZUltYWdlPSEwO2Muc2hhZG93VmlzaWJsZT1hO2UubW9kZWwuZXhlY3V0ZShjKX0se2luc3RhbGw6ZnVuY3Rpb24oYSl7dGhpcy5saXN0ZW5lcj1mdW5jdGlvbigpe2EoZS5zaGFkb3dWaXNpYmxlKX07CmIuYWRkTGlzdGVuZXIoInNoYWRvd1Zpc2libGVDaGFuZ2VkIix0aGlzLmxpc3RlbmVyKX0sZGVzdHJveTpmdW5jdGlvbigpe2IucmVtb3ZlTGlzdGVuZXIodGhpcy5saXN0ZW5lcil9fSk7RWRpdG9yLnNoYWRvd09wdGlvbkVuYWJsZWR8fChjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJpbnB1dCIpWzBdLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpLG14VXRpbHMuc2V0T3BhY2l0eShjLDYwKSk7YS5hcHBlbmRDaGlsZChjKX1yZXR1cm4gYX07dmFyIHA9RGlhZ3JhbUZvcm1hdFBhbmVsLnByb3RvdHlwZS5hZGRPcHRpb25zO0RpYWdyYW1Gb3JtYXRQYW5lbC5wcm90b3R5cGUuYWRkT3B0aW9ucz1mdW5jdGlvbihhKXthPXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBiPXRoaXMuZWRpdG9yVWksZT1iLmVkaXRvci5ncmFwaDtpZihlLmlzRW5hYmxlZCgpKXt2YXIgYz1iLmdldEN1cnJlbnRGaWxlKCk7aWYobnVsbCE9YyYmYy5pc0F1dG9zYXZlT3B0aW9uYWwoKSl7dmFyIGQ9CnRoaXMuY3JlYXRlT3B0aW9uKG14UmVzb3VyY2VzLmdldCgiYXV0b3NhdmUiKSxmdW5jdGlvbigpe3JldHVybiBiLmVkaXRvci5hdXRvc2F2ZX0sZnVuY3Rpb24oYSl7Yi5lZGl0b3Iuc2V0QXV0b3NhdmUoYSk7Yi5lZGl0b3IuYXV0b3NhdmUmJmMuaXNNb2RpZmllZCgpJiZjLmZpbGVDaGFuZ2VkKCl9LHtpbnN0YWxsOmZ1bmN0aW9uKGEpe3RoaXMubGlzdGVuZXI9ZnVuY3Rpb24oKXthKGIuZWRpdG9yLmF1dG9zYXZlKX07Yi5lZGl0b3IuYWRkTGlzdGVuZXIoImF1dG9zYXZlQ2hhbmdlZCIsdGhpcy5saXN0ZW5lcil9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtiLmVkaXRvci5yZW1vdmVMaXN0ZW5lcih0aGlzLmxpc3RlbmVyKX19KTthLmFwcGVuZENoaWxkKGQpfX1pZih0aGlzLmlzTWF0aE9wdGlvblZpc2libGUoKSYmZS5pc0VuYWJsZWQoKSYmInVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheCl7ZD10aGlzLmNyZWF0ZU9wdGlvbihteFJlc291cmNlcy5nZXQoIm1hdGhlbWF0aWNhbFR5cGVzZXR0aW5nIiksCmZ1bmN0aW9uKCl7cmV0dXJuIGUubWF0aEVuYWJsZWR9LGZ1bmN0aW9uKGEpe2IuYWN0aW9ucy5nZXQoIm1hdGhlbWF0aWNhbFR5cGVzZXR0aW5nIikuZnVuY3QoKX0se2luc3RhbGw6ZnVuY3Rpb24oYSl7dGhpcy5saXN0ZW5lcj1mdW5jdGlvbigpe2EoZS5tYXRoRW5hYmxlZCl9O2IuYWRkTGlzdGVuZXIoIm1hdGhFbmFibGVkQ2hhbmdlZCIsdGhpcy5saXN0ZW5lcil9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtiLnJlbW92ZUxpc3RlbmVyKHRoaXMubGlzdGVuZXIpfX0pO2Quc3R5bGUucGFkZGluZ1RvcD0iNXB4IjthLmFwcGVuZENoaWxkKGQpO3ZhciBmPWIubWVudXMuY3JlYXRlSGVscExpbmsoImh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDMyODc1Iik7Zi5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2Yuc3R5bGUubWFyZ2luTGVmdD0iNnB4IjtmLnN0eWxlLnRvcD0iMnB4IjtkLmFwcGVuZENoaWxkKGYpfXJldHVybiBhfTtteENlbGxSZW5kZXJlci5wcm90b3R5cGUuZGVmYXVsdFZlcnRleFNoYXBlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPQpbe25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LHtuYW1lOiJhYnNvbHV0ZUFyY1NpemUiLGRpc3BOYW1lOiJBYnMuIEFyYyBTaXplIix0eXBlOiJib29sIixkZWZWYWw6ITF9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmxpbmsucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJ3aWR0aCIsZGlzcE5hbWU6IldpZHRoIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjR9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmZsZXhBcnJvdy5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6IndpZHRoIixkaXNwTmFtZToiV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MTB9LHtuYW1lOiJzdGFydFdpZHRoIixkaXNwTmFtZToiU3RhcnQgV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9LHtuYW1lOiJlbmRXaWR0aCIsCmRpc3BOYW1lOiJFbmQgV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnByb2Nlc3MucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiSW5kZW50Iix0eXBlOiJmbG9hdCIsbWluOjAsbWF4Oi41LGRlZlZhbDouMX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMucmhvbWJ1cy5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLG1heDo1MCxkZWZWYWw6bXhDb25zdGFudHMuTElORV9BUkNTSVpFfSx7bmFtZToiZG91YmxlIixkaXNwTmFtZToiRG91YmxlIix0eXBlOiJib29sIixkZWZWYWw6ITF9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnBhcnRpYWxSZWN0YW5nbGUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJ0b3AiLGRpc3BOYW1lOiJUb3AgTGluZSIsCnR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6ImJvdHRvbSIsZGlzcE5hbWU6IkJvdHRvbSBMaW5lIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJsZWZ0IixkaXNwTmFtZToiTGVmdCBMaW5lIix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJyaWdodCIsZGlzcE5hbWU6IlJpZ2h0IExpbmUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMucGFyYWxsZWxvZ3JhbS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LHtuYW1lOiJzaXplIixkaXNwTmFtZToiU2xvcGUgQW5nbGUiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmhleGFnb24ucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJhcmNTaXplIiwKZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0se25hbWU6InNpemUiLGRpc3BOYW1lOiJTbG9wZSBBbmdsZSIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouMjV9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnRyaWFuZ2xlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZG9jdW1lbnQucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLGRlZlZhbDouMyxtaW46MCxtYXg6MX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuaW50ZXJuYWxTdG9yYWdlLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPQpbe25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LHtuYW1lOiJkeCIsZGlzcE5hbWU6IkxlZnQgTGluZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH0se25hbWU6ImR5IixkaXNwTmFtZToiVG9wIExpbmUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmN1YmUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH0se25hbWU6ImRhcmtPcGFjaXR5IixkaXNwTmFtZToiRGFyayBPcGFjaXR5Iix0eXBlOiJmbG9hdCIsbWluOi0xLG1heDoxLGRlZlZhbDowfSx7bmFtZToiZGFya09wYWNpdHkyIixkaXNwTmFtZToiRGFyayBPcGFjaXR5IDIiLHR5cGU6ImZsb2F0IixtaW46LTEsbWF4OjEsZGVmVmFsOjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnN0ZXAucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9Clt7bmFtZToic2l6ZSIsZGlzcE5hbWU6Ik5vdGNoIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9LHtuYW1lOiJmaXhlZFNpemUiLGRpc3BOYW1lOiJGaXhlZCBTaXplIix0eXBlOiJib29sIixkZWZWYWw6ITB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnRyYXBlem9pZC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDpteENvbnN0YW50cy5MSU5FX0FSQ1NJWkV9LHtuYW1lOiJzaXplIixkaXNwTmFtZToiU2xvcGUgQW5nbGUiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnRhcGUucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouNH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMubm90ZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz0KW3tuYW1lOiJzaXplIixkaXNwTmFtZToiRm9sZCBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjMwfSx7bmFtZToiZGFya09wYWNpdHkiLGRpc3BOYW1lOiJEYXJrIE9wYWNpdHkiLHR5cGU6ImZsb2F0IixtaW46LTEsbWF4OjEsZGVmVmFsOjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmNhcmQucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6bXhDb25zdGFudHMuTElORV9BUkNTSVpFfSx7bmFtZToic2l6ZSIsZGlzcE5hbWU6IkN1dG9mZiBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjMwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5jYWxsb3V0LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOm14Q29uc3RhbnRzLkxJTkVfQVJDU0laRX0sCntuYW1lOiJiYXNlIixkaXNwTmFtZToiQ2FsbG91dCBXaWR0aCIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH0se25hbWU6InNpemUiLGRpc3BOYW1lOiJDYWxsb3V0IExlbmd0aCIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDozMH0se25hbWU6InBvc2l0aW9uIixkaXNwTmFtZToiQ2FsbG91dCBQb3NpdGlvbiIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouNX0se25hbWU6InBvc2l0aW9uMiIsZGlzcE5hbWU6IkNhbGxvdXQgVGlwIFBvc2l0aW9uIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi41fV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5mb2xkZXIucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJ0YWJXaWR0aCIsZGlzcE5hbWU6IlRhYiBXaWR0aCIsdHlwZToiZmxvYXQifSx7bmFtZToidGFiSGVpZ2h0IixkaXNwTmFtZToiVGFiIEhlaWdodCIsdHlwZToiZmxvYXQifSx7bmFtZToidGFiUG9zaXRpb24iLGRpc3BOYW1lOiJUYXAgUG9zaXRpb24iLAp0eXBlOiJlbnVtIixlbnVtTGlzdDpbe3ZhbDoibGVmdCIsZGlzcE5hbWU6IkxlZnQifSx7dmFsOiJyaWdodCIsZGlzcE5hbWU6IlJpZ2h0In1dfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5zd2ltbGFuZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoxNX0se25hbWU6InN0YXJ0U2l6ZSIsZGlzcE5hbWU6IkhlYWRlciBTaXplIix0eXBlOiJmbG9hdCJ9LHtuYW1lOiJob3Jpem9udGFsIixkaXNwTmFtZToiSG9yaXpvbnRhbCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfSx7bmFtZToic2VwYXJhdG9yQ29sb3IiLGRpc3BOYW1lOiJTZXBhcmF0b3IgQ29sb3IiLHR5cGU6ImNvbG9yIixkZWZWYWw6bnVsbH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZG91YmxlRWxsaXBzZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6Im1hcmdpbiIsZGlzcE5hbWU6IkluZGVudCIsCnR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6NH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZXh0LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjE1fSx7bmFtZToiZG91YmxlIixkaXNwTmFtZToiRG91YmxlIix0eXBlOiJib29sIixkZWZWYWw6ITF9LHtuYW1lOiJtYXJnaW4iLGRpc3BOYW1lOiJJbmRlbnQiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MH1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuY3VybHlCcmFja2V0LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToicm91bmRlZCIsZGlzcE5hbWU6IlJvdW5kZWQiLHR5cGU6ImJvb2wiLGRlZlZhbDohMH0se25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsbWF4OjEsZGVmVmFsOi41fV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5pbWFnZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz0KW3tuYW1lOiJpbWFnZUFzcGVjdCIsZGlzcE5hbWU6IkZpeGVkIEltYWdlIEFzcGVjdCIsdHlwZToiYm9vbCIsZGVmVmFsOiEwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5sYWJlbC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImltYWdlQXNwZWN0IixkaXNwTmFtZToiRml4ZWQgSW1hZ2UgQXNwZWN0Iix0eXBlOiJib29sIixkZWZWYWw6ITB9LHtuYW1lOiJpbWFnZUFsaWduIixkaXNwTmFtZToiSW1hZ2UgQWxpZ24iLHR5cGU6ImVudW0iLGVudW1MaXN0Olt7dmFsOiJsZWZ0IixkaXNwTmFtZToiTGVmdCJ9LHt2YWw6ImNlbnRlciIsZGlzcE5hbWU6IkNlbnRlciJ9LHt2YWw6InJpZ2h0IixkaXNwTmFtZToiUmlnaHQifV0sZGVmVmFsOiJsZWZ0In0se25hbWU6ImltYWdlVmVydGljYWxBbGlnbiIsZGlzcE5hbWU6IkltYWdlIFZlcnRpY2FsIEFsaWduIix0eXBlOiJlbnVtIixlbnVtTGlzdDpbe3ZhbDoidG9wIixkaXNwTmFtZToiVG9wIn0se3ZhbDoibWlkZGxlIiwKZGlzcE5hbWU6Ik1pZGRsZSJ9LHt2YWw6ImJvdHRvbSIsZGlzcE5hbWU6IkJvdHRvbSJ9XSxkZWZWYWw6Im1pZGRsZSJ9LHtuYW1lOiJpbWFnZVdpZHRoIixkaXNwTmFtZToiSW1hZ2UgV2lkdGgiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjR9LHtuYW1lOiJpbWFnZUhlaWdodCIsZGlzcE5hbWU6IkltYWdlIEhlaWdodCIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyNH0se25hbWU6ImFyY1NpemUiLGRpc3BOYW1lOiJBcmMgU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoxMn0se25hbWU6ImFic29sdXRlQXJjU2l6ZSIsZGlzcE5hbWU6IkFicy4gQXJjIFNpemUiLHR5cGU6ImJvb2wiLGRlZlZhbDohMX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMuZGF0YVN0b3JhZ2UucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9W3tuYW1lOiJzaXplIixkaXNwTmFtZToiU2l6ZSIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouMX1dO214Q2VsbFJlbmRlcmVyLmRlZmF1bHRTaGFwZXMubWFudWFsSW5wdXQucHJvdG90eXBlLmN1c3RvbVByb3BlcnRpZXM9Clt7bmFtZToic2l6ZSIsZGlzcE5hbWU6IlNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MzB9LHtuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmxvb3BMaW1pdC5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InNpemUiLGRpc3BOYW1lOiJTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfSx7bmFtZToiYXJjU2l6ZSIsZGlzcE5hbWU6IkFyYyBTaXplIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5vZmZQYWdlQ29ubmVjdG9yLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToic2l6ZSIsZGlzcE5hbWU6IlNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6Mzh9LHtuYW1lOiJhcmNTaXplIixkaXNwTmFtZToiQXJjIFNpemUiLHR5cGU6ImZsb2F0IiwKbWluOjAsZGVmVmFsOjIwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5kaXNwbGF5LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToic2l6ZSIsZGlzcE5hbWU6IlNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjI1fV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy5zaW5nbGVBcnJvdy5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImFycm93V2lkdGgiLGRpc3BOYW1lOiJBcnJvdyBXaWR0aCIsdHlwZToiZmxvYXQiLG1pbjowLG1heDoxLGRlZlZhbDouM30se25hbWU6ImFycm93U2l6ZSIsZGlzcE5hbWU6IkFycm93aGVhZCBMZW5ndGgiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmRvdWJsZUFycm93LnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToiYXJyb3dXaWR0aCIsZGlzcE5hbWU6IkFycm93IFdpZHRoIix0eXBlOiJmbG9hdCIsCm1pbjowLG1heDoxLGRlZlZhbDouM30se25hbWU6ImFycm93U2l6ZSIsZGlzcE5hbWU6IkFycm93aGVhZCBMZW5ndGgiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmNyb3NzLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPVt7bmFtZToic2l6ZSIsZGlzcE5hbWU6IlNpemUiLHR5cGU6ImZsb2F0IixtaW46MCxtYXg6MSxkZWZWYWw6LjJ9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLmNvcm5lci5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImR4IixkaXNwTmFtZToiV2lkdGgxIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfSx7bmFtZToiZHkiLGRpc3BOYW1lOiJXaWR0aDIiLHR5cGU6ImZsb2F0IixtaW46MCxkZWZWYWw6MjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnRlZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6ImR4IixkaXNwTmFtZToiV2lkdGgxIiwKdHlwZToiZmxvYXQiLG1pbjowLGRlZlZhbDoyMH0se25hbWU6ImR5IixkaXNwTmFtZToiV2lkdGgyIix0eXBlOiJmbG9hdCIsbWluOjAsZGVmVmFsOjIwfV07bXhDZWxsUmVuZGVyZXIuZGVmYXVsdFNoYXBlcy51bWxMaWZlbGluZS5wcm90b3R5cGUuY3VzdG9tUHJvcGVydGllcz1be25hbWU6InBhcnRpY2lwYW50IixkaXNwTmFtZToiUGFydGljaXBhbnQiLHR5cGU6ImVudW0iLGRlZlZhbDoibm9uZSIsZW51bUxpc3Q6W3t2YWw6Im5vbmUiLGRpc3BOYW1lOiJEZWZhdWx0In0se3ZhbDoidW1sQWN0b3IiLGRpc3BOYW1lOiJBY3RvciJ9LHt2YWw6InVtbEJvdW5kYXJ5IixkaXNwTmFtZToiQm91bmRhcnkifSx7dmFsOiJ1bWxFbnRpdHkiLGRpc3BOYW1lOiJFbnRpdHkifSx7dmFsOiJ1bWxDb250cm9sIixkaXNwTmFtZToiQ29udHJvbCJ9XX0se25hbWU6InNpemUiLGRpc3BOYW1lOiJIZWlnaHQiLHR5cGU6ImZsb2F0IixkZWZWYWw6NDAsbWluOjB9XTtteENlbGxSZW5kZXJlci5kZWZhdWx0U2hhcGVzLnVtbEZyYW1lLnByb3RvdHlwZS5jdXN0b21Qcm9wZXJ0aWVzPQpbe25hbWU6IndpZHRoIixkaXNwTmFtZToiVGl0bGUgV2lkdGgiLHR5cGU6ImZsb2F0IixkZWZWYWw6NjAsbWluOjB9LHtuYW1lOiJoZWlnaHQiLGRpc3BOYW1lOiJUaXRsZSBIZWlnaHQiLHR5cGU6ImZsb2F0IixkZWZWYWw6MzAsbWluOjB9XTtTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5kZWZhdWx0Q29sb3JTY2hlbWVzPVtbe2ZpbGw6IiIsc3Ryb2tlOiIifSx7ZmlsbDoiI2Y1ZjVmNSIsc3Ryb2tlOiIjNjY2NjY2Iixmb250OiIjMzMzMzMzIn0se2ZpbGw6IiNkYWU4ZmMiLHN0cm9rZToiIzZjOGViZiJ9LHtmaWxsOiIjZDVlOGQ0IixzdHJva2U6IiM4MmIzNjYifSx7ZmlsbDoiI2ZmZTZjYyIsc3Ryb2tlOiIjZDc5YjAwIn0se2ZpbGw6IiNmZmYyY2MiLHN0cm9rZToiI2Q2YjY1NiJ9LHtmaWxsOiIjZjhjZWNjIixzdHJva2U6IiNiODU0NTAifSx7ZmlsbDoiI2UxZDVlNyIsc3Ryb2tlOiIjOTY3M2E2In1dLFt7ZmlsbDoiIixzdHJva2U6IiJ9LHtmaWxsOiIjNjBhOTE3IixzdHJva2U6IiMyRDc2MDAiLApmb250OiIjZmZmZmZmIn0se2ZpbGw6IiMwMDhhMDAiLHN0cm9rZToiIzAwNTcwMCIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjMWJhMWUyIixzdHJva2U6IiMwMDZFQUYiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiIzAwNTBlZiIsc3Ryb2tlOiIjMDAxREJDIixmb250OiIjZmZmZmZmIn0se2ZpbGw6IiM2YTAwZmYiLHN0cm9rZToiIzM3MDBDQyIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjZDgwMDczIixzdHJva2U6IiNBNTAwNDAiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiI2EyMDAyNSIsc3Ryb2tlOiIjNkYwMDAwIixmb250OiIjZmZmZmZmIn1dLFt7ZmlsbDoiI2U1MTQwMCIsc3Ryb2tlOiIjQjIwMDAwIixmb250OiIjZmZmZmZmIn0se2ZpbGw6IiNmYTY4MDAiLHN0cm9rZToiI0M3MzUwMCIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjZjBhMzBhIixzdHJva2U6IiNCRDcwMDAiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiI2UzYzgwMCIsc3Ryb2tlOiIjQjA5NTAwIixmb250OiIjZmZmZmZmIn0sCntmaWxsOiIjNmQ4NzY0IixzdHJva2U6IiMzQTU0MzEiLGZvbnQ6IiNmZmZmZmYifSx7ZmlsbDoiIzY0NzY4NyIsc3Ryb2tlOiIjMzE0MzU0Iixmb250OiIjZmZmZmZmIn0se2ZpbGw6IiM3NjYwOGEiLHN0cm9rZToiIzQzMkQ1NyIsZm9udDoiI2ZmZmZmZiJ9LHtmaWxsOiIjYTA1MjJkIixzdHJva2U6IiM2RDFGMDAiLGZvbnQ6IiNmZmZmZmYifV0sW3tmaWxsOiIiLHN0cm9rZToiIn0se2ZpbGw6bXhDb25zdGFudHMuTk9ORSxzdHJva2U6IiJ9LHtmaWxsOiIjZmFkN2FjIixzdHJva2U6IiNiNDY1MDQifSx7ZmlsbDoiI2ZhZDlkNSIsc3Ryb2tlOiIjYWU0MTMyIn0se2ZpbGw6IiNiMGUzZTYiLHN0cm9rZToiIzBlODA4OCJ9LHtmaWxsOiIjYjFkZGYwIixzdHJva2U6IiMxMDczOWUifSx7ZmlsbDoiI2QwY2VlMiIsc3Ryb2tlOiIjNTY1MTdlIn0se2ZpbGw6IiNiYWM4ZDMiLHN0cm9rZToiIzIzNDQ1ZCJ9XSxbe2ZpbGw6IiIsc3Ryb2tlOiIifSx7ZmlsbDoiI2Y1ZjVmNSIsc3Ryb2tlOiIjNjY2NjY2IiwKZ3JhZGllbnQ6IiNiM2IzYjMifSx7ZmlsbDoiI2RhZThmYyIsc3Ryb2tlOiIjNmM4ZWJmIixncmFkaWVudDoiIzdlYTZlMCJ9LHtmaWxsOiIjZDVlOGQ0IixzdHJva2U6IiM4MmIzNjYiLGdyYWRpZW50OiIjOTdkMDc3In0se2ZpbGw6IiNmZmNkMjgiLHN0cm9rZToiI2Q3OWIwMCIsZ3JhZGllbnQ6IiNmZmE1MDAifSx7ZmlsbDoiI2ZmZjJjYyIsc3Ryb2tlOiIjZDZiNjU2IixncmFkaWVudDoiI2ZmZDk2NiJ9LHtmaWxsOiIjZjhjZWNjIixzdHJva2U6IiNiODU0NTAiLGdyYWRpZW50OiIjZWE2YjY2In0se2ZpbGw6IiNlNmQwZGUiLHN0cm9rZToiIzk5NjE4NSIsZ3JhZGllbnQ6IiNkNTczOWQifV0sW3tmaWxsOiIiLHN0cm9rZToiIn0se2ZpbGw6IiNlZWVlZWUiLHN0cm9rZToiIzM2MzkzZCJ9LHtmaWxsOiIjZjlmN2VkIixzdHJva2U6IiMzNjM5M2QifSx7ZmlsbDoiI2ZmY2M5OSIsc3Ryb2tlOiIjMzYzOTNkIn0se2ZpbGw6IiNjY2U1ZmYiLHN0cm9rZToiIzM2MzkzZCJ9LHtmaWxsOiIjZmZmZjg4IiwKc3Ryb2tlOiIjMzYzOTNkIn0se2ZpbGw6IiNjZGViOGIiLHN0cm9rZToiIzM2MzkzZCJ9LHtmaWxsOiIjZmZjY2NjIixzdHJva2U6IiMzNjM5M2QifV1dO1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmN1c3RvbUNvbG9yU2NoZW1lcz1udWxsO1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmZpbmRDb21tb25Qcm9wZXJ0aWVzPWZ1bmN0aW9uKGEsYixlKXtpZihudWxsIT1iKXt2YXIgYz1mdW5jdGlvbihhKXtpZihudWxsIT1hKWlmKGUpZm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYlthW2NdLm5hbWVdPWFbY107ZWxzZSBmb3IodmFyIGQgaW4gYil7Zm9yKHZhciBmPSExLGM9MDtjPGEubGVuZ3RoO2MrKylpZihhW2NdLm5hbWU9PWQmJmFbY10udHlwZT09YltkXS50eXBlKXtmPSEwO2JyZWFrfWZ8fGRlbGV0ZSBiW2RdfX0sZD10aGlzLmVkaXRvclVpLmVkaXRvci5ncmFwaC52aWV3LmdldFN0YXRlKGEpO251bGwhPWQmJm51bGwhPWQuc2hhcGUmJihkLnNoYXBlLmNvbW1vbkN1c3RvbVByb3BBZGRlZHx8CihkLnNoYXBlLmNvbW1vbkN1c3RvbVByb3BBZGRlZD0hMCxkLnNoYXBlLmN1c3RvbVByb3BlcnRpZXM9ZC5zaGFwZS5jdXN0b21Qcm9wZXJ0aWVzfHxbXSxkLmNlbGwudmVydGV4P0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGQuc2hhcGUuY3VzdG9tUHJvcGVydGllcyxFZGl0b3IuY29tbW9uVmVydGV4UHJvcGVydGllcyk6QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZC5zaGFwZS5jdXN0b21Qcm9wZXJ0aWVzLEVkaXRvci5jb21tb25FZGdlUHJvcGVydGllcykpLGMoZC5zaGFwZS5jdXN0b21Qcm9wZXJ0aWVzKSk7YT1hLmdldEF0dHJpYnV0ZSgiY3VzdG9tUHJvcGVydGllcyIpO2lmKG51bGwhPWEpdHJ5e2MoSlNPTi5wYXJzZShhKSl9Y2F0Y2goSSl7fX19O3ZhciB2PVN0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmluaXQ7U3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZm9ybWF0LmNyZWF0ZVNlbGVjdGlvblN0YXRlKCk7ImltYWdlIj09CmEuc3R5bGUuc2hhcGV8fGEuY29udGFpbnNMYWJlbHx8dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5hZGRTdHlsZXModGhpcy5jcmVhdGVQYW5lbCgpKSk7di5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoRWRpdG9yLmVuYWJsZUN1c3RvbVByb3BlcnRpZXMpe2Zvcih2YXIgYj17fSxlPWEudmVydGljZXMsYz1hLmVkZ2VzLGQ9MDtkPGUubGVuZ3RoO2QrKyl0aGlzLmZpbmRDb21tb25Qcm9wZXJ0aWVzKGVbZF0sYiwwPT1kKTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKXRoaXMuZmluZENvbW1vblByb3BlcnRpZXMoY1tkXSxiLDA9PWUubGVuZ3RoJiYwPT1kKTtudWxsIT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyYmMDxPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKS5sZW5ndGgmJnRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuYWRkUHJvcGVydGllcyh0aGlzLmNyZWF0ZVBhbmVsKCksYixhKSl9fTt2YXIgdD1TdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5hZGRTdHlsZU9wczsKU3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuYWRkU3R5bGVPcHM9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJjb3B5U3R5bGUiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvclVpLmFjdGlvbnMuZ2V0KCJjb3B5U3R5bGUiKS5mdW5jdCgpfSkpO2Iuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjb3B5U3R5bGUiKSsiICgiK3RoaXMuZWRpdG9yVWkuYWN0aW9ucy5nZXQoImNvcHlTdHlsZSIpLnNob3J0Y3V0KyIpIik7Yi5zdHlsZS5tYXJnaW5Cb3R0b209IjJweCI7Yi5zdHlsZS53aWR0aD0iMTAwcHgiO2Iuc3R5bGUubWFyZ2luUmlnaHQ9IjJweCI7YS5hcHBlbmRDaGlsZChiKTtiPW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgicGFzdGVTdHlsZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yVWkuYWN0aW9ucy5nZXQoInBhc3RlU3R5bGUiKS5mdW5jdCgpfSkpOwpiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgicGFzdGVTdHlsZSIpKyIgKCIrdGhpcy5lZGl0b3JVaS5hY3Rpb25zLmdldCgicGFzdGVTdHlsZSIpLnNob3J0Y3V0KyIpIik7Yi5zdHlsZS5tYXJnaW5Cb3R0b209IjJweCI7Yi5zdHlsZS53aWR0aD0iMTAwcHgiO2EuYXBwZW5kQ2hpbGQoYik7bXhVdGlscy5icihhKTtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0VkaXRvclVpLnByb3RvdHlwZS5wcm9wZXJ0aWVzQ29sbGFwc2VkPSEwO1N0eWxlRm9ybWF0UGFuZWwucHJvdG90eXBlLmFkZFByb3BlcnRpZXM9ZnVuY3Rpb24oYSxiLGUpe2Z1bmN0aW9uIGMoYSxiLGUsYyl7ay5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e3ZhciBkPVtdLGY9W107aWYobnVsbCE9ZS5pbmRleCl7Zm9yKHZhciBnPVtdLGw9ZS5wYXJlbnRSb3cubmV4dFNpYmxpbmc7bCYmbC5nZXRBdHRyaWJ1dGUoImRhdGEtcE5hbWUiKT09YTspZy5wdXNoKGwuZ2V0QXR0cmlidXRlKCJkYXRhLXBWYWx1ZSIpKSwKbD1sLm5leHRTaWJsaW5nO2UuaW5kZXg8Zy5sZW5ndGg/bnVsbCE9Yz9nLnNwbGljZShjLDEpOmdbZS5pbmRleF09YjpnLnB1c2goYik7bnVsbCE9ZS5zaXplJiZnLmxlbmd0aD5lLnNpemUmJihnPWcuc2xpY2UoMCxlLnNpemUpKTtiPWcuam9pbigiLCIpO251bGwhPWUuY291bnRQcm9wZXJ0eSYmKGsuc2V0Q2VsbFN0eWxlcyhlLmNvdW50UHJvcGVydHksZy5sZW5ndGgsay5nZXRTZWxlY3Rpb25DZWxscygpKSxkLnB1c2goZS5jb3VudFByb3BlcnR5KSxmLnB1c2goZy5sZW5ndGgpKX1rLnNldENlbGxTdHlsZXMoYSxiLGsuZ2V0U2VsZWN0aW9uQ2VsbHMoKSk7ZC5wdXNoKGEpO2YucHVzaChiKTtpZihudWxsIT1lLmRlcGVuZGVudFByb3BzKWZvcihhPTA7YTxlLmRlcGVuZGVudFByb3BzLmxlbmd0aDthKyspe3ZhciBuPWUuZGVwZW5kZW50UHJvcHNEZWZWYWxbYV0scD1lLmRlcGVuZGVudFByb3BzVmFsc1thXTtpZihwLmxlbmd0aD5iKXA9cC5zbGljZSgwLGIpO2Vsc2UgZm9yKHZhciBtPQpwLmxlbmd0aDttPGI7bSsrKXAucHVzaChuKTtwPXAuam9pbigiLCIpO2suc2V0Q2VsbFN0eWxlcyhlLmRlcGVuZGVudFByb3BzW2FdLHAsay5nZXRTZWxlY3Rpb25DZWxscygpKTtkLnB1c2goZS5kZXBlbmRlbnRQcm9wc1thXSk7Zi5wdXNoKHApfWlmKCJmdW5jdGlvbiI9PXR5cGVvZiBlLm9uQ2hhbmdlKWUub25DaGFuZ2UoayxiKTt0LmVkaXRvclVpLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgic3R5bGVDaGFuZ2VkIiwia2V5cyIsZCwidmFsdWVzIixmLCJjZWxscyIsay5nZXRTZWxlY3Rpb25DZWxscygpKSl9ZmluYWxseXtrLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fWZ1bmN0aW9uIGQoYixlLGMpe3ZhciBkPW14VXRpbHMuZ2V0T2Zmc2V0KGEsITApLGY9bXhVdGlscy5nZXRPZmZzZXQoYiwhMCk7ZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Uuc3R5bGUubGVmdD1mLngtZC54KyJweCI7ZS5zdHlsZS50b3A9Zi55LWQueSsicHgiO2Uuc3R5bGUud2lkdGg9Yi5vZmZzZXRXaWR0aCsKInB4IjtlLnN0eWxlLmhlaWdodD1iLm9mZnNldEhlaWdodC0oYz80OjApKyJweCI7ZS5zdHlsZS56SW5kZXg9NX1mdW5jdGlvbiBmKGEsYixlKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnN0eWxlLndpZHRoPSIzMnB4IjtkLnN0eWxlLmhlaWdodD0iNHB4IjtkLnN0eWxlLm1hcmdpbj0iMnB4IjtkLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkIGJsYWNrIjtkLnN0eWxlLmJhY2tncm91bmQ9YiYmIm5vbmUiIT1iP2I6InVybCgnIitEaWFsb2cucHJvdG90eXBlLm5vQ29sb3JJbWFnZSsiJykiO2J0bj1teFV0aWxzLmJ1dHRvbigiIixteFV0aWxzLmJpbmQodCxmdW5jdGlvbihmKXt0aGlzLmVkaXRvclVpLnBpY2tDb2xvcihiLGZ1bmN0aW9uKGIpe2Quc3R5bGUuYmFja2dyb3VuZD0ibm9uZSI9PWI/InVybCgnIitEaWFsb2cucHJvdG90eXBlLm5vQ29sb3JJbWFnZSsiJykiOmI7YyhhLGIsZSl9KTtteEV2ZW50LmNvbnN1bWUoZil9KSk7YnRuLnN0eWxlLmhlaWdodD0KIjEycHgiO2J0bi5zdHlsZS53aWR0aD0iNDBweCI7YnRuLmNsYXNzTmFtZT0iZ2VDb2xvckJ0biI7YnRuLmFwcGVuZENoaWxkKGQpO3JldHVybiBidG59ZnVuY3Rpb24gZyhhLGIsZSxkLGYsZyxsKXtudWxsIT1iJiYoYj1iLnNwbGl0KCIsIiksbS5wdXNoKHtuYW1lOmEsdmFsdWVzOmIsdHlwZTplLGRlZlZhbDpkLGNvdW50UHJvcGVydHk6ZixwYXJlbnRSb3c6Zyxpc0RlbGV0YWJsZTohMCxmbGlwQmtnOmx9KSk7YnRuPW14VXRpbHMuYnV0dG9uKCIrIixteFV0aWxzLmJpbmQodCxmdW5jdGlvbihiKXtmb3IodmFyIG49Zyx0PTA7bnVsbCE9bi5uZXh0U2libGluZzspaWYobi5uZXh0U2libGluZy5nZXRBdHRyaWJ1dGUoImRhdGEtcE5hbWUiKT09YSluPW4ubmV4dFNpYmxpbmcsdCsrO2Vsc2UgYnJlYWs7dmFyIGs9e3R5cGU6ZSxwYXJlbnRSb3c6ZyxpbmRleDp0LGlzRGVsZXRhYmxlOiEwLGRlZlZhbDpkLGNvdW50UHJvcGVydHk6Zn0sdD1wKGEsIiIsaywwPT10JTIsbCk7YyhhLGQsCmspO24ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCxuLm5leHRTaWJsaW5nKTtteEV2ZW50LmNvbnN1bWUoYil9KSk7YnRuLnN0eWxlLmhlaWdodD0iMTZweCI7YnRuLnN0eWxlLndpZHRoPSIyNXB4IjtidG4uY2xhc3NOYW1lPSJnZUNvbG9yQnRuIjtyZXR1cm4gYnRufWZ1bmN0aW9uIGwoYSxiLGUsYyxkLGYsZyl7aWYoMDxkKXt2YXIgbD1BcnJheShkKTtiPW51bGwhPWI/Yi5zcGxpdCgiLCIpOltdO2Zvcih2YXIgbj0wO248ZDtuKyspbFtuXT1udWxsIT1iW25dP2Jbbl06bnVsbCE9Yz9jOiIiO20ucHVzaCh7bmFtZTphLHZhbHVlczpsLHR5cGU6ZSxkZWZWYWw6YyxwYXJlbnRSb3c6ZixmbGlwQmtnOmcsc2l6ZTpkfSl9cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpfWZ1bmN0aW9uIG4oYSxiLGUpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7ZC50eXBlPSJjaGVja2JveCI7ZC5jaGVja2VkPSIxIj09YjtteEV2ZW50LmFkZExpc3RlbmVyKGQsCiJjaGFuZ2UiLGZ1bmN0aW9uKCl7YyhhLGQuY2hlY2tlZD8iMSI6IjAiLGUpfSk7cmV0dXJuIGR9ZnVuY3Rpb24gcChiLGUscCxrLG0pe3ZhciB5PXAuZGlzcE5hbWUsdj1wLnR5cGUsdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpO3UuY2xhc3NOYW1lPSJnZVByb3BSb3ciKyhtPyJEYXJrIjoiIikrKGs/IkFsdCI6IiIpKyIgZ2VQcm9wTm9uSGVhZGVyUm93Ijt1LnNldEF0dHJpYnV0ZSgiZGF0YS1wTmFtZSIsYik7dS5zZXRBdHRyaWJ1dGUoImRhdGEtcFZhbHVlIixlKTtrPSExO251bGwhPXAuaW5kZXgmJih1LnNldEF0dHJpYnV0ZSgiZGF0YS1pbmRleCIscC5pbmRleCkseT0obnVsbCE9eT95OiIiKSsiWyIrcC5pbmRleCsiXSIsaz0hMCk7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTt4LmNsYXNzTmFtZT0iZ2VQcm9wUm93Q2VsbCI7eC5pbm5lckhUTUw9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KHksbnVsbCx5KSk7ayYmKHguc3R5bGUudGV4dEFsaWduPQoicmlnaHQiKTt1LmFwcGVuZENoaWxkKHgpO3g9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKTt4LmNsYXNzTmFtZT0iZ2VQcm9wUm93Q2VsbCI7aWYoImNvbG9yIj09dil4LmFwcGVuZENoaWxkKGYoYixlLHApKTtlbHNlIGlmKCJib29sIj09dnx8ImJvb2xlYW4iPT12KXguYXBwZW5kQ2hpbGQobihiLGUscCkpO2Vsc2UgaWYoImVudW0iPT12KXt2YXIgQT1wLmVudW1MaXN0O2ZvcihtPTA7bTxBLmxlbmd0aDttKyspaWYoeT1BW21dLHkudmFsPT1lKXt4LmlubmVySFRNTD1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoeS5kaXNwTmFtZSxudWxsLHkuZGlzcE5hbWUpKTticmVha31teEV2ZW50LmFkZExpc3RlbmVyKHgsImNsaWNrIixteFV0aWxzLmJpbmQodCxmdW5jdGlvbigpe3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpO2QoeCxmKTtmb3IodmFyIGc9MDtnPEEubGVuZ3RoO2crKyl7dmFyIGw9QVtnXSxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpOwpuLnZhbHVlPW14VXRpbHMuaHRtbEVudGl0aWVzKGwudmFsKTtuLmlubmVySFRNTD1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQobC5kaXNwTmFtZSxudWxsLGwuZGlzcE5hbWUpKTtmLmFwcGVuZENoaWxkKG4pfWYudmFsdWU9ZTthLmFwcGVuZENoaWxkKGYpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiY2hhbmdlIixmdW5jdGlvbigpe3ZhciBhPW14VXRpbHMuaHRtbEVudGl0aWVzKGYudmFsdWUpO2MoYixhLHApfSk7Zi5mb2N1cygpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiYmx1ciIsZnVuY3Rpb24oKXthLnJlbW92ZUNoaWxkKGYpfSl9KSl9ZWxzZSJkeW5hbWljQXJyIj09dj94LmFwcGVuZENoaWxkKGcoYixlLHAuc3ViVHlwZSxwLnN1YkRlZlZhbCxwLmNvdW50UHJvcGVydHksdSxtKSk6InN0YXRpY0FyciI9PXY/eC5hcHBlbmRDaGlsZChsKGIsZSxwLnN1YlR5cGUscC5zdWJEZWZWYWwscC5zaXplLHUsbSkpOih4LmlubmVySFRNTD1lLG14RXZlbnQuYWRkTGlzdGVuZXIoeCwKImNsaWNrIixteFV0aWxzLmJpbmQodCxmdW5jdGlvbigpe2Z1bmN0aW9uIGYoKXt2YXIgYT1nLnZhbHVlLGE9MD09YS5sZW5ndGgmJiJzdHJpbmciIT12PzA6YTtwLmFsbG93QXV0byYmKG51bGwhPWEudHJpbSYmImF1dG8iPT1hLnRyaW0oKS50b0xvd2VyQ2FzZSgpPyhhPSJhdXRvIix2PSJzdHJpbmciKTooYT1wYXJzZUZsb2F0KGEpLGE9aXNOYU4oYSk/MDphKSk7bnVsbCE9cC5taW4mJmE8cC5taW4/YT1wLm1pbjpudWxsIT1wLm1heCYmYT5wLm1heCYmKGE9cC5tYXgpO2E9bXhVdGlscy5odG1sRW50aXRpZXMoKCJpbnQiPT12P3BhcnNlSW50KGEpOmEpKyIiKTtjKGIsYSxwKX12YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2QoeCxnLCEwKTtnLnZhbHVlPWU7Zy5jbGFzc05hbWU9ImdlUHJvcEVkaXRvciI7ImludCIhPXYmJiJmbG9hdCIhPXZ8fHAuYWxsb3dBdXRvfHwoZy50eXBlPSJudW1iZXIiLGcuc3RlcD0iaW50Ij09dj8iMSI6ImFueSIsbnVsbCE9cC5taW4mJgooZy5taW49cGFyc2VGbG9hdChwLm1pbikpLG51bGwhPXAubWF4JiYoZy5tYXg9cGFyc2VGbG9hdChwLm1heCkpKTthLmFwcGVuZENoaWxkKGcpO214RXZlbnQuYWRkTGlzdGVuZXIoZywia2V5cHJlc3MiLGZ1bmN0aW9uKGEpezEzPT1hLmtleUNvZGUmJmYoKX0pO2cuZm9jdXMoKTtteEV2ZW50LmFkZExpc3RlbmVyKGcsImJsdXIiLGZ1bmN0aW9uKCl7ZigpfSl9KSkpO3AuaXNEZWxldGFibGUmJihtPW14VXRpbHMuYnV0dG9uKCItIixteFV0aWxzLmJpbmQodCxmdW5jdGlvbihhKXtjKGIsIiIscCxwLmluZGV4KTtteEV2ZW50LmNvbnN1bWUoYSl9KSksbS5zdHlsZS5oZWlnaHQ9IjE2cHgiLG0uc3R5bGUud2lkdGg9IjI1cHgiLG0uc3R5bGVbImZsb2F0Il09InJpZ2h0IixtLmNsYXNzTmFtZT0iZ2VDb2xvckJ0biIseC5hcHBlbmRDaGlsZChtKSk7dS5hcHBlbmRDaGlsZCh4KTtyZXR1cm4gdX12YXIgdD10aGlzLGs9dGhpcy5lZGl0b3JVaS5lZGl0b3IuZ3JhcGgsbT1bXTthLnN0eWxlLnBvc2l0aW9uPQoicmVsYXRpdmUiO2Euc3R5bGUucGFkZGluZz0iMCI7dmFyIHk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGFibGUiKTt5LnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7eS5zdHlsZS53aWR0aD0iMTAwJSI7dmFyIHY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidHIiKTt2LmNsYXNzTmFtZT0iZ2VQcm9wSGVhZGVyIjt2YXIgdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0aCIpO3UuY2xhc3NOYW1lPSJnZVByb3BIZWFkZXJDZWxsIjt2YXIgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTt4LnNyYz1TaWRlYmFyLnByb3RvdHlwZS5leHBhbmRlZEltYWdlO3UuYXBwZW5kQ2hpbGQoeCk7bXhVdGlscy53cml0ZSh1LG14UmVzb3VyY2VzLmdldCgicHJvcGVydHkiKSk7di5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO3ZhciBBPWZ1bmN0aW9uKCl7dmFyIGI9eS5xdWVyeVNlbGVjdG9yQWxsKCIuZ2VQcm9wTm9uSGVhZGVyUm93IiksZTtpZih0LmVkaXRvclVpLnByb3BlcnRpZXNDb2xsYXBzZWQpe3guc3JjPQpTaWRlYmFyLnByb3RvdHlwZS5jb2xsYXBzZWRJbWFnZTtlPSJub25lIjtmb3IodmFyIGM9YS5jaGlsZE5vZGVzLmxlbmd0aC0xOzA8PWM7Yy0tKXRyeXt2YXIgZD1hLmNoaWxkTm9kZXNbY10sZj1kLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7IklOUFVUIiE9ZiYmIlNFTEVDVCIhPWZ8fGEucmVtb3ZlQ2hpbGQoZCl9Y2F0Y2gocWEpe319ZWxzZSB4LnNyYz1TaWRlYmFyLnByb3RvdHlwZS5leHBhbmRlZEltYWdlLGU9IiI7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyliW2NdLnN0eWxlLmRpc3BsYXk9ZX07bXhFdmVudC5hZGRMaXN0ZW5lcih2LCJjbGljayIsZnVuY3Rpb24oKXt0LmVkaXRvclVpLnByb3BlcnRpZXNDb2xsYXBzZWQ9IXQuZWRpdG9yVWkucHJvcGVydGllc0NvbGxhcHNlZDtBKCl9KTt2LmFwcGVuZENoaWxkKHUpO3U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGgiKTt1LmNsYXNzTmFtZT0iZ2VQcm9wSGVhZGVyQ2VsbCI7dS5pbm5lckhUTUw9bXhSZXNvdXJjZXMuZ2V0KCJ2YWx1ZSIpOwp2LmFwcGVuZENoaWxkKHUpO3kuYXBwZW5kQ2hpbGQodik7dmFyIHo9ITEscT0hMSxDO2ZvcihDIGluIGIpaWYodj1iW0NdLCJmdW5jdGlvbiIhPXR5cGVvZiB2LmlzVmlzaWJsZXx8di5pc1Zpc2libGUoZSx0aGlzKSl7dmFyIEI9bnVsbCE9ZS5zdHlsZVtDXT9teFV0aWxzLmh0bWxFbnRpdGllcyhlLnN0eWxlW0NdKyIiKTpudWxsIT12LmdldERlZmF1bHRWYWx1ZT92LmdldERlZmF1bHRWYWx1ZShlLHRoaXMpOnYuZGVmVmFsO2lmKCJzZXBhcmF0b3IiPT12LnR5cGUpcT0hcTtlbHNle2lmKCJzdGF0aWNBcnIiPT12LnR5cGUpdi5zaXplPXBhcnNlSW50KGUuc3R5bGVbdi5zaXplUHJvcGVydHldfHxiW3Yuc2l6ZVByb3BlcnR5XS5kZWZWYWwpfHwwO2Vsc2UgaWYobnVsbCE9di5kZXBlbmRlbnRQcm9wcyl7Zm9yKHZhciBEPXYuZGVwZW5kZW50UHJvcHMsRT1bXSxLPVtdLHU9MDt1PEQubGVuZ3RoO3UrKyl7dmFyIEc9ZS5zdHlsZVtEW3VdXTtLLnB1c2goYltEW3VdXS5zdWJEZWZWYWwpOwpFLnB1c2gobnVsbCE9Rz9HLnNwbGl0KCIsIik6W10pfXYuZGVwZW5kZW50UHJvcHNEZWZWYWw9Szt2LmRlcGVuZGVudFByb3BzVmFscz1FfXkuYXBwZW5kQ2hpbGQocChDLEIsdix6LHEpKTt6PSF6fX1mb3IodT0wO3U8bS5sZW5ndGg7dSsrKWZvcih2PW1bdV0sYj12LnBhcmVudFJvdyxlPTA7ZTx2LnZhbHVlcy5sZW5ndGg7ZSsrKUM9cCh2Lm5hbWUsdi52YWx1ZXNbZV0se3R5cGU6di50eXBlLHBhcmVudFJvdzp2LnBhcmVudFJvdyxpc0RlbGV0YWJsZTp2LmlzRGVsZXRhYmxlLGluZGV4OmUsZGVmVmFsOnYuZGVmVmFsLGNvdW50UHJvcGVydHk6di5jb3VudFByb3BlcnR5LHNpemU6di5zaXplfSwwPT1lJTIsdi5mbGlwQmtnKSxiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKEMsYi5uZXh0U2libGluZyksYj1DO2EuYXBwZW5kQ2hpbGQoeSk7QSgpO3JldHVybiBhfTtTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5hZGRTdHlsZXM9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXtteEV2ZW50LmFkZExpc3RlbmVyKGEsCiJtb3VzZWVudGVyIixmdW5jdGlvbigpe2Euc3R5bGUub3BhY2l0eT0iMSJ9KTtteEV2ZW50LmFkZExpc3RlbmVyKGEsIm1vdXNlbGVhdmUiLGZ1bmN0aW9uKCl7YS5zdHlsZS5vcGFjaXR5PSIwLjUifSl9dmFyIGU9dGhpcy5lZGl0b3JVaS5lZGl0b3IuZ3JhcGgsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7Yy5zdHlsZS5wYWRkaW5nTGVmdD0iMjRweCI7Yy5zdHlsZS5wYWRkaW5nUmlnaHQ9IjIwcHgiO2Euc3R5bGUucGFkZGluZ0xlZnQ9IjE2cHgiO2Euc3R5bGUucGFkZGluZ0JvdHRvbT0iNnB4IjthLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7YS5hcHBlbmRDaGlsZChjKTt2YXIgZD0icGxhaW4tZ3JheSBwbGFpbi1ibHVlIHBsYWluLWdyZWVuIHBsYWluLXR1cnF1b2lzZSBwbGFpbi1vcmFuZ2UgcGxhaW4teWVsbG93IHBsYWluLXJlZCBwbGFpbi1waW5rIHBsYWluLXB1cnBsZSBncmF5IGJsdWUgZ3JlZW4gdHVycXVvaXNlIG9yYW5nZSB5ZWxsb3cgcmVkIHBpbmsgcHVycGxlIi5zcGxpdCgiICIpLApmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Yuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtmLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7Zi5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7Zm9yKHZhciBnPVtdLGw9MDtsPHRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGg7bCsrKXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtuLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayI7bi5zdHlsZS53aWR0aD0iNnB4IjtuLnN0eWxlLmhlaWdodD0iNnB4IjtuLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7bi5zdHlsZS5tYXJnaW5SaWdodD0iM3B4IjtuLnN0eWxlLmJvcmRlclJhZGl1cz0iM3B4IjtuLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7bi5zdHlsZS5iYWNrZ3JvdW5kPSJ0cmFuc3BhcmVudCI7bi5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCAjYjViNmI3IjtteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtteEV2ZW50LmFkZExpc3RlbmVyKG4sCiJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtwKGEpfSkpfSkobCk7bXhFdmVudC5hZGQ7Zy5wdXNoKG4pO2YuYXBwZW5kQ2hpbGQobil9dmFyIHA9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9dGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lJiYoZ1t0aGlzLmVkaXRvclVpLmN1cnJlbnRTY2hlbWVdLnN0eWxlLmJhY2tncm91bmQ9InRyYW5zcGFyZW50Iik7dGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lPWE7dCh0aGlzLmRlZmF1bHRDb2xvclNjaGVtZXNbdGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lXSk7Z1t0aGlzLmVkaXRvclVpLmN1cnJlbnRTY2hlbWVdLnN0eWxlLmJhY2tncm91bmQ9IiM4NGQ3ZmYifSksdD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teFV0aWxzLmJ1dHRvbigiIixmdW5jdGlvbihiKXtlLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTsKdHJ5e3ZhciBjPWUuZ2V0U2VsZWN0aW9uQ2VsbHMoKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXtmb3IodmFyIGY9ZS5nZXRNb2RlbCgpLmdldFN0eWxlKGNbYl0pLGc9MDtnPGQubGVuZ3RoO2crKylmPW14VXRpbHMucmVtb3ZlU3R5bGVuYW1lKGYsZFtnXSk7dmFyIGw9ZS5nZXRNb2RlbCgpLmlzVmVydGV4KGNbYl0pP2UuZGVmYXVsdFZlcnRleFN0eWxlOmUuZGVmYXVsdEVkZ2VTdHlsZTtudWxsIT1hPyhmPW14VXRpbHMuc2V0U3R5bGUoZixteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SLGEuZ3JhZGllbnR8fG14VXRpbHMuZ2V0VmFsdWUobCxteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SLG51bGwpKSxmPSIiPT1hLmZpbGw/bXhVdGlscy5zZXRTdHlsZShmLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUixudWxsKTpteFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLGEuZmlsbHx8bXhVdGlscy5nZXRWYWx1ZShsLG14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUiwKbnVsbCkpLGY9IiI9PWEuc3Ryb2tlP214VXRpbHMuc2V0U3R5bGUoZixteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUixudWxsKTpteFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsYS5zdHJva2V8fG14VXRpbHMuZ2V0VmFsdWUobCxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUixudWxsKSksZS5nZXRNb2RlbCgpLmlzVmVydGV4KGNbYl0pJiYoZj1teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfRk9OVENPTE9SLGEuZm9udHx8bXhVdGlscy5nZXRWYWx1ZShsLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUixudWxsKSkpKTooZj1teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLG14VXRpbHMuZ2V0VmFsdWUobCxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsIiNmZmZmZmYiKSksZj1teFV0aWxzLnNldFN0eWxlKGYsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsbXhVdGlscy5nZXRWYWx1ZShsLApteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUiwiIzAwMDAwMCIpKSxmPW14VXRpbHMuc2V0U3R5bGUoZixteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SLG14VXRpbHMuZ2V0VmFsdWUobCxteENvbnN0YW50cy5TVFlMRV9HUkFESUVOVENPTE9SLG51bGwpKSxlLmdldE1vZGVsKCkuaXNWZXJ0ZXgoY1tiXSkmJihmPW14VXRpbHMuc2V0U3R5bGUoZixteENvbnN0YW50cy5TVFlMRV9GT05UQ09MT1IsbXhVdGlscy5nZXRWYWx1ZShsLG14Q29uc3RhbnRzLlNUWUxFX0ZPTlRDT0xPUixudWxsKSkpKTtlLmdldE1vZGVsKCkuc2V0U3R5bGUoY1tiXSxmKX19ZmluYWxseXtlLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fSk7Yi5jbGFzc05hbWU9ImdlU3R5bGVCdXR0b24iO2Iuc3R5bGUud2lkdGg9IjM2cHgiO2Iuc3R5bGUuaGVpZ2h0PTEwPj10aGlzLmRlZmF1bHRDb2xvclNjaGVtZXMubGVuZ3RoPyIyNHB4IjoiMzBweCI7Yi5zdHlsZS5tYXJnaW49IjBweCA2cHggNnB4IDBweCI7CmlmKG51bGwhPWEpbnVsbCE9YS5ncmFkaWVudD9teENsaWVudC5JU19JRSYmKG14Q2xpZW50LklTX1FVSVJLU3x8MTA+ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKT9iLnN0eWxlLmZpbHRlcj0icHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkdyYWRpZW50KFN0YXJ0Q29sb3JTdHI9JyIrYS5maWxsKyInLCBFbmRDb2xvclN0cj0nIithLmdyYWRpZW50KyInLCBHcmFkaWVudFR5cGU9MCkiOmIuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJsaW5lYXItZ3JhZGllbnQoIithLmZpbGwrIiAwcHgsIithLmdyYWRpZW50KyIgMTAwJSkiOmEuZmlsbD09bXhDb25zdGFudHMuTk9ORT9iLnN0eWxlLmJhY2tncm91bmQ9InVybCgnIitEaWFsb2cucHJvdG90eXBlLm5vQ29sb3JJbWFnZSsiJykiOmIuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiPT1hLmZpbGw/bXhVdGlscy5nZXRWYWx1ZShlLmRlZmF1bHRWZXJ0ZXhTdHlsZSxteENvbnN0YW50cy5TVFlMRV9GSUxMQ09MT1IsImRhcmsiPT11aVRoZW1lPwoiIzJhMmEyYSI6IiNmZmZmZmYiKTphLmZpbGx8fG14VXRpbHMuZ2V0VmFsdWUoZS5kZWZhdWx0VmVydGV4U3R5bGUsbXhDb25zdGFudHMuU1RZTEVfRklMTENPTE9SLCJkYXJrIj09dWlUaGVtZT8iIzJhMmEyYSI6IiNmZmZmZmYiKSxiLnN0eWxlLmJvcmRlcj1hLnN0cm9rZT09bXhDb25zdGFudHMuTk9ORT8iMXB4IHNvbGlkIHRyYW5zcGFyZW50IjoiIj09YS5zdHJva2U/IjFweCBzb2xpZCAiK214VXRpbHMuZ2V0VmFsdWUoZS5kZWZhdWx0VmVydGV4U3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsImRhcmsiIT11aVRoZW1lPyIjMmEyYTJhIjoiI2ZmZmZmZiIpOiIxcHggc29saWQgIisoYS5zdHJva2V8fG14VXRpbHMuZ2V0VmFsdWUoZS5kZWZhdWx0VmVydGV4U3R5bGUsbXhDb25zdGFudHMuU1RZTEVfU1RST0tFQ09MT1IsImRhcmsiIT11aVRoZW1lPyIjMmEyYTJhIjoiI2ZmZmZmZiIpKTtlbHNle3ZhciBmPW14VXRpbHMuZ2V0VmFsdWUoZS5kZWZhdWx0VmVydGV4U3R5bGUsCm14Q29uc3RhbnRzLlNUWUxFX0ZJTExDT0xPUiwiI2ZmZmZmZiIpLGc9bXhVdGlscy5nZXRWYWx1ZShlLmRlZmF1bHRWZXJ0ZXhTdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VDT0xPUiwiIzAwMDAwMCIpO2Iuc3R5bGUuYmFja2dyb3VuZENvbG9yPWY7Yi5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCAiK2d9Yy5hcHBlbmRDaGlsZChiKX0pO2MuaW5uZXJIVE1MPSIiO2Zvcih2YXIgZj0wO2Y8YS5sZW5ndGg7ZisrKTA8ZiYmMD09bXhVdGlscy5tb2QoZiw0KSYmbXhVdGlscy5icihjKSxiKGFbZl0pfSk7bnVsbD09dGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lP3AoImRhcmsiPT11aVRoZW1lPzE6MCk6cCh0aGlzLmVkaXRvclVpLmN1cnJlbnRTY2hlbWUpO3ZhciBsPTEwPj10aGlzLmRlZmF1bHRDb2xvclNjaGVtZXMubGVuZ3RoPzI4Ojgsaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtrLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MTBweDt0b3A6OHB4O2JvdHRvbToiKwpsKyJweDt3aWR0aDoyMHB4O21hcmdpbjo0cHg7b3BhY2l0eTowLjU7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGNlbnRlcjtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQVFCQU1BQUFEUVQ0TTBBQUFBSVZCTVZFVUFBQUIyZG5aNGVIaDNkM2QxZFhWeGNYRjJkbloyZG5aMmRuWnhjWEYyZG5ZbWIzdzFBQUFBQ25SU1RsTUFmQ1RraGh2YjdjUVNQSDJKUGdBQUFEUkpSRUZVQ05kandBQ01BbUJLYWlHWXMyb0ptTFBLQVozRGFiVThBTVJUWHBVS29waXNscUZ5VnpDQXVVWmdpa2tCWmpvQWNNWUxucDUzUC9VQUFBQUFTVVZPUks1Q1lJST0pOyI7bXhFdmVudC5hZGRMaXN0ZW5lcihrLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtwKG14VXRpbHMubW9kKHRoaXMuZWRpdG9yVWkuY3VycmVudFNjaGVtZS0xLHRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGgpKX0pKTsKdmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bS5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjIwMnB4O3RvcDo4cHg7Ym90dG9tOiIrbCsicHg7d2lkdGg6MjBweDttYXJnaW46NHB4O29wYWNpdHk6MC41O2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlciBjZW50ZXI7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFRQkFNQUFBRFFUNE0wQUFBQUlWQk1WRVVBQUFCMmRuWjJkbloyZG5aMmRuWjJkbloyZG5aMmRuWjJkbloyZG5aMmRuWUJ1d0NjQUFBQUNuUlNUbE1BZkNUa2hodmI3Y1FTUEgySlBnQUFBRFpKUkVGVUNOZGpRQU9NQW1CS2FpR1k4bG9GNXJLc3dzWmxyVm84QVVpRnJUSUNjYklXSzhBNURGMWdEb015bU1QQXBJQXdId0NTMFF4L1U3cUNCUUFBQUFCSlJVNUVya0pnZ2c9PSk7IjsxPHRoaXMuZGVmYXVsdENvbG9yU2NoZW1lcy5sZW5ndGgmJgooYS5hcHBlbmRDaGlsZChrKSxhLmFwcGVuZENoaWxkKG0pKTtteEV2ZW50LmFkZExpc3RlbmVyKG0sImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3AobXhVdGlscy5tb2QodGhpcy5lZGl0b3JVaS5jdXJyZW50U2NoZW1lKzEsdGhpcy5kZWZhdWx0Q29sb3JTY2hlbWVzLmxlbmd0aCkpfSkpO2Ioayk7YihtKTt0KHRoaXMuZGVmYXVsdENvbG9yU2NoZW1lc1t0aGlzLmVkaXRvclVpLmN1cnJlbnRTY2hlbWVdKTsxMD49dGhpcy5kZWZhdWx0Q29sb3JTY2hlbWVzLmxlbmd0aCYmYS5hcHBlbmRDaGlsZChmKTtyZXR1cm4gYX07U3R5bGVGb3JtYXRQYW5lbC5wcm90b3R5cGUuYWRkRWRpdE9wcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5nZXRTZWxlY3Rpb25TdGF0ZSgpLGU9bnVsbDsxPT10aGlzLmVkaXRvclVpLmVkaXRvci5ncmFwaC5nZXRTZWxlY3Rpb25Db3VudCgpJiYoZT1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImVkaXRTdHlsZSIpLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhKXt0aGlzLmVkaXRvclVpLmFjdGlvbnMuZ2V0KCJlZGl0U3R5bGUiKS5mdW5jdCgpfSkpLGUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0U3R5bGUiKSsiICgiK3RoaXMuZWRpdG9yVWkuYWN0aW9ucy5nZXQoImVkaXRTdHlsZSIpLnNob3J0Y3V0KyIpIiksZS5zdHlsZS53aWR0aD0iMjAycHgiLGUuc3R5bGUubWFyZ2luQm90dG9tPSIycHgiLGEuYXBwZW5kQ2hpbGQoZSkpO3ZhciBjPXRoaXMuZWRpdG9yVWkuZWRpdG9yLmdyYXBoLGQ9Yy52aWV3LmdldFN0YXRlKGMuZ2V0U2VsZWN0aW9uQ2VsbCgpKTsxPT1jLmdldFNlbGVjdGlvbkNvdW50KCkmJm51bGwhPWQmJm51bGwhPWQuc2hhcGUmJm51bGwhPWQuc2hhcGUuc3RlbmNpbD8oYj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImVkaXRTaGFwZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yVWkuYWN0aW9ucy5nZXQoImVkaXRTaGFwZSIpLmZ1bmN0KCl9KSksCmIuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0U2hhcGUiKSksYi5zdHlsZS5tYXJnaW5Cb3R0b209IjJweCIsbnVsbD09ZT9iLnN0eWxlLndpZHRoPSIyMDJweCI6KGUuc3R5bGUud2lkdGg9IjEwMHB4IixiLnN0eWxlLndpZHRoPSIxMDBweCIsYi5zdHlsZS5tYXJnaW5MZWZ0PSIycHgiKSxhLmFwcGVuZENoaWxkKGIpKTpiLmltYWdlJiYoYj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImVkaXRJbWFnZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yVWkuYWN0aW9ucy5nZXQoImltYWdlIikuZnVuY3QoKX0pKSxiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiZWRpdEltYWdlIikpLGIuc3R5bGUubWFyZ2luQm90dG9tPSIycHgiLG51bGw9PWU/Yi5zdHlsZS53aWR0aD0iMjAycHgiOihlLnN0eWxlLndpZHRoPSIxMDBweCIsYi5zdHlsZS53aWR0aD0iMTAwcHgiLGIuc3R5bGUubWFyZ2luTGVmdD0KIjJweCIpLGEuYXBwZW5kQ2hpbGQoYikpO3JldHVybiBhfX1HcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lTmFtZT0iZGVmYXVsdC1zdHlsZTIiO0dyYXBoLnByb3RvdHlwZS5sYXN0UGFzdGVYbWw9bnVsbDtHcmFwaC5wcm90b3R5cGUucGFzdGVDb3VudGVyPTA7R3JhcGgucHJvdG90eXBlLmRlZmF1bHRTY3JvbGxiYXJzPSIwIiE9dXJsUGFyYW1zLnNiO0dyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFnZVZpc2libGU9IjAiIT11cmxQYXJhbXMucHY7R3JhcGgucHJvdG90eXBlLnNoYWRvd0lkPSJkcm9wU2hhZG93IjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93Q29sb3I9IiMzRDQ1NzQiO0dyYXBoLnByb3RvdHlwZS5zdmdTaGFkb3dPcGFjaXR5PSIwLjQiO0dyYXBoLnByb3RvdHlwZS5zdmdTaGFkb3dCbHVyPSIxLjciO0dyYXBoLnByb3RvdHlwZS5zdmdTaGFkb3dTaXplPSIzIjtHcmFwaC5wcm90b3R5cGUuZWRnZU1vZGU9Im1vdmUiIT11cmxQYXJhbXMuZWRnZTt2YXIgeT1HcmFwaC5wcm90b3R5cGUuaW5pdDsKR3JhcGgucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2I9YTt0cnl7aWYobXhDbGllbnQuSVNfUVVJUktTfHw3PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSliPWRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KGEpLGIudHlwZT1hLnR5cGUsYi5jYW5CdWJibGU9YS5jYW5CdWJibGUsYi5jYW5jZWxhYmxlPWEuY2FuY2VsYWJsZSxiLnZpZXc9YS52aWV3LGIuZGV0YWlsPWEuZGV0YWlsLGIuc2NyZWVuWD1hLnNjcmVlblgsYi5zY3JlZW5ZPWEuc2NyZWVuWSxiLmNsaWVudFg9YS5jbGllbnRYLGIuY2xpZW50WT1hLmNsaWVudFksYi5jdHJsS2V5PWEuY3RybEtleSxiLmFsdEtleT1hLmFsdEtleSxiLnNoaWZ0S2V5PWEuc2hpZnRLZXksYi5tZXRhS2V5PWEubWV0YUtleSxiLmJ1dHRvbj1hLmJ1dHRvbixiLnJlbGF0ZWRUYXJnZXQ9YS5yZWxhdGVkVGFyZ2V0fWNhdGNoKEkpe319eS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7CndpbmRvdy5teEZyZWVoYW5kJiYodGhpcy5mcmVlaGFuZD1uZXcgbXhGcmVlaGFuZCh0aGlzKSk7dmFyIGI9bnVsbDtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuY29udGFpbmVyLCJtb3VzZWVudGVyIixhKTtteEV2ZW50LmFkZExpc3RlbmVyKHRoaXMuY29udGFpbmVyLCJtb3VzZW1vdmUiLGEpO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5jb250YWluZXIsIm1vdXNlbGVhdmUiLGZ1bmN0aW9uKGEpe2I9bnVsbH0pO3RoaXMuaXNNb3VzZUluc2VydFBvaW50PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPWJ9O3ZhciBlPXRoaXMuZ2V0SW5zZXJ0UG9pbnQ7dGhpcy5nZXRJbnNlcnRQb2ludD1mdW5jdGlvbigpe3JldHVybiBudWxsIT1iP3RoaXMuZ2V0UG9pbnRGb3JFdmVudChiKTplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGM9dGhpcy5sYXlvdXRNYW5hZ2VyLmdldExheW91dDt0aGlzLmxheW91dE1hbmFnZXIuZ2V0TGF5b3V0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ3JhcGguZ2V0Q2VsbFN0eWxlKGEpOwppZihudWxsIT1iKXtpZigicmFjayI9PWIuY2hpbGRMYXlvdXQpe3ZhciBlPW5ldyBteFN0YWNrTGF5b3V0KHRoaXMuZ3JhcGgsITEpO2UuZ3JpZFNpemU9bnVsbCE9Yi5yYWNrVW5pdFNpemU/cGFyc2VGbG9hdChiLnJhY2tVbml0U2l6ZSk6InVuZGVmaW5lZCIhPT10eXBlb2YgbXhSYWNrQ29udGFpbmVyP214UmFja0NvbnRhaW5lci51bml0U2l6ZToyMDtlLmZpbGw9ITA7ZS5tYXJnaW5MZWZ0PWIubWFyZ2luTGVmdHx8MDtlLm1hcmdpblJpZ2h0PWIubWFyZ2luUmlnaHR8fDA7ZS5tYXJnaW5Ub3A9Yi5tYXJnaW5Ub3B8fDA7ZS5tYXJnaW5Cb3R0b209Yi5tYXJnaW5Cb3R0b218fDA7ZS5hbGxvd0dhcHM9Yi5hbGxvd0dhcHN8fDA7ZS5yZXNpemVQYXJlbnQ9ITE7cmV0dXJuIGV9aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgbXhUYWJsZUxheW91dCYmInRhYmxlTGF5b3V0Ij09Yi5jaGlsZExheW91dClyZXR1cm4gZT1uZXcgbXhUYWJsZUxheW91dCh0aGlzLmdyYXBoKSxlLnJvd3M9Yi50YWJsZVJvd3N8fAoyLGUuY29sdW1ucz1iLnRhYmxlQ29sdW1uc3x8MixlLmNvbFBlcmNlbnRhZ2VzPWIuY29sUGVyY2VudGFnZXMsZS5yb3dQZXJjZW50YWdlcz1iLnJvd1BlcmNlbnRhZ2VzLGUuZXF1YWxDb2x1bW5zPSIxIj09bXhVdGlscy5nZXRWYWx1ZShiLCJlcXVhbENvbHVtbnMiLGUuY29sUGVyY2VudGFnZXM/IjAiOiIxIiksZS5lcXVhbFJvd3M9IjEiPT1teFV0aWxzLmdldFZhbHVlKGIsImVxdWFsUm93cyIsZS5yb3dQZXJjZW50YWdlcz8iMCI6IjEiKSxlLnJlc2l6ZVBhcmVudD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoYiwicmVzaXplUGFyZW50IiwiMSIpLGUuYm9yZGVyPWIudGFibGVCb3JkZXJ8fGUuYm9yZGVyLGUubWFyZ2luTGVmdD1iLm1hcmdpbkxlZnR8fDAsZS5tYXJnaW5SaWdodD1iLm1hcmdpblJpZ2h0fHwwLGUubWFyZ2luVG9wPWIubWFyZ2luVG9wfHwwLGUubWFyZ2luQm90dG9tPWIubWFyZ2luQm90dG9tfHwwLGUuYXV0b0FkZENvbD0iMSI9PW14VXRpbHMuZ2V0VmFsdWUoYiwKImF1dG9BZGRDb2wiLCIwIiksZS5hdXRvQWRkUm93PSIxIj09bXhVdGlscy5nZXRWYWx1ZShiLCJhdXRvQWRkUm93IixlLmF1dG9BZGRDb2w/IjAiOiIxIiksZS5jb2xXaWR0aHM9Yi5jb2xXaWR0aHN8fCIxMDAiLGUucm93SGVpZ2h0cz1iLnJvd0hlaWdodHN8fCI1MCIsZX1yZXR1cm4gYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3RoaXMudXBkYXRlR2xvYmFsVXJsVmFyaWFibGVzKCl9O3ZhciB4PUdyYXBoLnByb3RvdHlwZS5pc0Zhc3Rab29tRW5hYmxlZDtHcmFwaC5wcm90b3R5cGUuaXNGYXN0Wm9vbUVuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4geC5hcHBseSh0aGlzLGFyZ3VtZW50cykmJighdGhpcy5zaGFkb3dWaXNpYmxlfHwhbXhDbGllbnQuSVNfU0YpfTtHcmFwaC5wcm90b3R5cGUudXBkYXRlR2xvYmFsVXJsVmFyaWFibGVzPWZ1bmN0aW9uKCl7dGhpcy5nbG9iYWxWYXJzPUVkaXRvci5nbG9iYWxWYXJzO2lmKG51bGwhPXVybFBhcmFtcy52YXJzKXRyeXt0aGlzLmdsb2JhbFZhcnM9Cm51bGwhPXRoaXMuZ2xvYmFsVmFycz9teFV0aWxzLmNsb25lKHRoaXMuZ2xvYmFsVmFycyk6e307dmFyIGE9SlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLnZhcnMpKTtpZihudWxsIT1hKWZvcih2YXIgYiBpbiBhKXRoaXMuZ2xvYmFsVmFyc1tiXT1hW2JdfWNhdGNoKEEpe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiRXJyb3IgaW4gdmFycyBVUkwgcGFyYW1ldGVyOiAiK0EpfX07R3JhcGgucHJvdG90eXBlLmdldEV4cG9ydFZhcmlhYmxlcz1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmdsb2JhbFZhcnM/bXhVdGlscy5jbG9uZSh0aGlzLmdsb2JhbFZhcnMpOnt9fTt2YXIgQz1HcmFwaC5wcm90b3R5cGUuZ2V0R2xvYmFsVmFyaWFibGU7R3JhcGgucHJvdG90eXBlLmdldEdsb2JhbFZhcmlhYmxlPWZ1bmN0aW9uKGEpe3ZhciBiPUMuYXBwbHkodGhpcyxhcmd1bWVudHMpO251bGw9PWImJm51bGwhPXRoaXMuZ2xvYmFsVmFycyYmKGI9dGhpcy5nbG9iYWxWYXJzW2FdKTsKcmV0dXJuIGJ9O0dyYXBoLnByb3RvdHlwZS5nZXREZWZhdWx0U3R5bGVzaGVldD1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMuZGVmYXVsdFN0eWxlc2hlZXQpe3ZhciBhPXRoaXMudGhlbWVzWyJkZWZhdWx0LXN0eWxlMiJdO3RoaXMuZGVmYXVsdFN0eWxlc2hlZXQ9KG5ldyBteENvZGVjKGEub3duZXJEb2N1bWVudCkpLmRlY29kZShhKX1yZXR1cm4gdGhpcy5kZWZhdWx0U3R5bGVzaGVldH07R3JhcGgucHJvdG90eXBlLmlzVmlld2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHVybFBhcmFtcy52aWV3ZXJ9O3ZhciBCPUdyYXBoLnByb3RvdHlwZS5nZXRTdmc7R3JhcGgucHJvdG90eXBlLmdldFN2Zz1mdW5jdGlvbihhLGIsZSxjLGQsZixnLGwsbixwLHQsayl7dmFyIG09bnVsbDtrfHxudWxsPT10aGlzLnRoZW1lc3x8ImRhcmtUaGVtZSIhPXRoaXMuZGVmYXVsdFRoZW1lTmFtZXx8KG09dGhpcy5zdHlsZXNoZWV0LHRoaXMuc3R5bGVzaGVldD10aGlzLmdldERlZmF1bHRTdHlsZXNoZWV0KCksCnRoaXMucmVmcmVzaCgpKTt2YXIgdj1CLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZih0JiZudWxsIT10aGlzLmV4dEZvbnRzJiYwPHRoaXMuZXh0Rm9udHMubGVuZ3RoKXt2YXIgeT12Lm93bmVyRG9jdW1lbnQsdT1udWxsIT15LmNyZWF0ZUVsZW1lbnROUz95LmNyZWF0ZUVsZW1lbnROUyhteENvbnN0YW50cy5OU19TVkcsInN0eWxlIik6eS5jcmVhdGVFbGVtZW50KCJzdHlsZSIpO251bGwhPXkuc2V0QXR0cmlidXRlTlM/dS5zZXRBdHRyaWJ1dGVOUygidHlwZSIsInRleHQvY3NzIik6dS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0L2NzcyIpO2Zvcih2YXIgeD0iIixBPSIiLHo9MDt6PHRoaXMuZXh0Rm9udHMubGVuZ3RoO3orKyl7dmFyIHE9dGhpcy5leHRGb250c1t6XS5uYW1lLEM9dGhpcy5leHRGb250c1t6XS51cmw7MD09Qy5pbmRleE9mKEVkaXRvci5HT09HTEVfRk9OVFMpP3grPSJAaW1wb3J0IHVybCgiK0MrIik7XG4iOkErPSdAZm9udC1mYWNlIHtcbmZvbnQtZmFtaWx5OiAiJysKcSsnIjtcbnNyYzogdXJsKCInK0MrJyIpO1xufVxuJ311LmFwcGVuZENoaWxkKHkuY3JlYXRlVGV4dE5vZGUoeCtBKSk7di5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGVmcyIpWzBdLmFwcGVuZENoaWxkKHUpfW51bGwhPW0mJih0aGlzLnN0eWxlc2hlZXQ9bSx0aGlzLnJlZnJlc2goKSk7cmV0dXJuIHZ9O3ZhciBEPUdyYXBoLnByb3RvdHlwZS5jcmVhdGVTdmdJbWFnZUV4cG9ydDtHcmFwaC5wcm90b3R5cGUuY3JlYXRlU3ZnSW1hZ2VFeHBvcnQ9ZnVuY3Rpb24oKXt2YXIgYT1ELmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZih0aGlzLm1hdGhFbmFibGVkKXt0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt2YXIgYj1hLmRyYXdUZXh0O2EuZHJhd1RleHQ9ZnVuY3Rpb24oYSxlKXtpZihudWxsIT1hLnRleHQmJm51bGwhPWEudGV4dC52YWx1ZSYmYS50ZXh0LmNoZWNrQm91bmRzKCkmJihteFV0aWxzLmlzTm9kZShhLnRleHQudmFsdWUpfHxhLnRleHQuZGlhbGVjdD09Cm14Q29uc3RhbnRzLkRJQUxFQ1RfU1RSSUNUSFRNTCkpe3ZhciBjPWEudGV4dC5nZXRDb250ZW50Tm9kZSgpO2lmKG51bGwhPWMpe2M9Yy5jbG9uZU5vZGUoITApO2lmKGMuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUylmb3IodmFyIGQ9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MIiwibWF0aCIpOzA8ZC5sZW5ndGg7KWRbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkWzBdKTtudWxsIT1jLmlubmVySFRNTCYmKGQ9YS50ZXh0LnZhbHVlLGEudGV4dC52YWx1ZT1jLmlubmVySFRNTCxiLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxhLnRleHQudmFsdWU9ZCl9fWVsc2UgYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXJldHVybiBhfTt2YXIgej1teEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZTtteEdyYXBoVmlldy5wcm90b3R5cGUudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZT1mdW5jdGlvbigpe3ouYXBwbHkodGhpcywKYXJndW1lbnRzKTtpZihteENsaWVudC5JU19HQyYmbnVsbCE9dGhpcy5nZXREcmF3UGFuZSgpKXt2YXIgYT10aGlzLmdldERyYXdQYW5lKCkucGFyZW50Tm9kZTshdGhpcy5ncmFwaC5tYXRoRW5hYmxlZHx8bXhDbGllbnQuTk9fRk98fG51bGwhPXRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZSYmbnVsbCE9dGhpcy53ZWJLaXRGb3JjZVJlcGFpbnROb2RlLnBhcmVudE5vZGV8fCJzdmciIT10aGlzLmdyYXBoLmNvbnRhaW5lci5maXJzdENoaWxkLm5vZGVOYW1lP251bGw9PXRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZXx8dGhpcy5ncmFwaC5tYXRoRW5hYmxlZCYmKCJzdmciPT10aGlzLmdyYXBoLmNvbnRhaW5lci5maXJzdENoaWxkLm5vZGVOYW1lfHx0aGlzLmdyYXBoLmNvbnRhaW5lci5maXJzdENoaWxkPT10aGlzLndlYktpdEZvcmNlUmVwYWludE5vZGUpfHwobnVsbCE9dGhpcy53ZWJLaXRGb3JjZVJlcGFpbnROb2RlLnBhcmVudE5vZGUmJnRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZSksCnRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZT1udWxsKToodGhpcy53ZWJLaXRGb3JjZVJlcGFpbnROb2RlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZS5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTsiLGEub3duZXJTVkdFbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMud2ViS2l0Rm9yY2VSZXBhaW50Tm9kZSxhLm93bmVyU1ZHRWxlbWVudCkpfX07dmFyIEU9R3JhcGgucHJvdG90eXBlLmxvYWRTdHlsZXNoZWV0O0dyYXBoLnByb3RvdHlwZS5sb2FkU3R5bGVzaGVldD1mdW5jdGlvbigpe0UuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuY3VycmVudFN0eWxlPSJkZWZhdWx0LXN0eWxlMiJ9O0dyYXBoLnByb3RvdHlwZS5oYW5kbGVDdXN0b21MaW5rPWZ1bmN0aW9uKGEpe2lmKCJkYXRhOmFjdGlvbi9qc29uLCI9PWEuc3Vic3RyaW5nKDAsMTcpJiYoYT1KU09OLnBhcnNlKGEuc3Vic3RyaW5nKDE3KSksCm51bGwhPWEuYWN0aW9ucykpe2Zvcih2YXIgYj0wO2I8YS5hY3Rpb25zLmxlbmd0aDtiKyspe3ZhciBlPWEuYWN0aW9uc1tiXTtpZihudWxsIT1lLm9wZW4paWYodGhpcy5pc0N1c3RvbUxpbmsoZS5vcGVuKSl7aWYoIXRoaXMuY3VzdG9tTGlua0NsaWNrZWQoZS5vcGVuKSlyZXR1cm59ZWxzZSB0aGlzLm9wZW5MaW5rKGUub3Blbil9dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IoYj0wO2I8YS5hY3Rpb25zLmxlbmd0aDtiKyspZT1hLmFjdGlvbnNbYl0sbnVsbCE9ZS50b2dnbGUmJnRoaXMudG9nZ2xlQ2VsbHModGhpcy5nZXRDZWxsc0ZvckFjdGlvbihlLnRvZ2dsZSwhMCkpLG51bGwhPWUuc2hvdyYmdGhpcy5zZXRDZWxsc1Zpc2libGUodGhpcy5nZXRDZWxsc0ZvckFjdGlvbihlLnNob3csITApLCEwKSxudWxsIT1lLmhpZGUmJnRoaXMuc2V0Q2VsbHNWaXNpYmxlKHRoaXMuZ2V0Q2VsbHNGb3JBY3Rpb24oZS5oaWRlLCEwKSwhMSl9ZmluYWxseXt0aGlzLm1vZGVsLmVuZFVwZGF0ZSgpfWZvcihiPQowO2I8YS5hY3Rpb25zLmxlbmd0aDtiKyspe3ZhciBlPWEuYWN0aW9uc1tiXSxjPVtdO251bGwhPWUuc2VsZWN0JiZ0aGlzLmlzRW5hYmxlZCgpJiYoYz10aGlzLmdldENlbGxzRm9yQWN0aW9uKGUuc2VsZWN0KSx0aGlzLnNldFNlbGVjdGlvbkNlbGxzKGMpKTtudWxsIT1lLmhpZ2hsaWdodCYmKGM9dGhpcy5nZXRDZWxsc0ZvckFjdGlvbihlLmhpZ2hsaWdodCksdGhpcy5oaWdobGlnaHRDZWxscyhjLGUuaGlnaGxpZ2h0LmNvbG9yLGUuaGlnaGxpZ2h0LmR1cmF0aW9uLGUuaGlnaGxpZ2h0Lm9wYWNpdHkpKTtudWxsIT1lLnNjcm9sbCYmKGM9dGhpcy5nZXRDZWxsc0ZvckFjdGlvbihlLnNjcm9sbCkpOzA8Yy5sZW5ndGgmJnRoaXMuc2Nyb2xsQ2VsbFRvVmlzaWJsZShjWzBdKX19fTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tTGlua3NGb3JDZWxsPWZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcy5nZXRMaW5rRm9yQ2VsbChiKTtudWxsIT1lJiYiZGF0YTphY3Rpb24vanNvbiwiPT0KZS5zdWJzdHJpbmcoMCwxNykmJnRoaXMuc2V0TGlua0ZvckNlbGwoYix0aGlzLnVwZGF0ZUN1c3RvbUxpbmsoYSxlKSk7aWYodGhpcy5pc0h0bWxMYWJlbChiKSl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5pbm5lckhUTUw9dGhpcy5nZXRMYWJlbChiKTtmb3IodmFyIGQ9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpLGY9ITEsZz0wO2c8ZC5sZW5ndGg7ZysrKWU9ZFtnXS5nZXRBdHRyaWJ1dGUoImhyZWYiKSxudWxsIT1lJiYiZGF0YTphY3Rpb24vanNvbiwiPT1lLnN1YnN0cmluZygwLDE3KSYmKGRbZ10uc2V0QXR0cmlidXRlKCJocmVmIix0aGlzLnVwZGF0ZUN1c3RvbUxpbmsoYSxlKSksZj0hMCk7ZiYmdGhpcy5sYWJlbENoYW5nZWQoYixjLmlubmVySFRNTCl9fTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tTGluaz1mdW5jdGlvbihhLGIpe2lmKCJkYXRhOmFjdGlvbi9qc29uLCI9PWIuc3Vic3RyaW5nKDAsMTcpKXRyeXt2YXIgZT1KU09OLnBhcnNlKGIuc3Vic3RyaW5nKDE3KSk7Cm51bGwhPWUuYWN0aW9ucyYmKHRoaXMudXBkYXRlQ3VzdG9tTGlua0FjdGlvbnMoYSxlLmFjdGlvbnMpLGI9ImRhdGE6YWN0aW9uL2pzb24sIitKU09OLnN0cmluZ2lmeShlKSl9Y2F0Y2goTSl7fXJldHVybiBifTtHcmFwaC5wcm90b3R5cGUudXBkYXRlQ3VzdG9tTGlua0FjdGlvbnM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGU9MDtlPGIubGVuZ3RoO2UrKyl7dmFyIGM9YltlXTt0aGlzLnVwZGF0ZUN1c3RvbUxpbmtBY3Rpb24oYSxjLnRvZ2dsZSk7dGhpcy51cGRhdGVDdXN0b21MaW5rQWN0aW9uKGEsYy5zaG93KTt0aGlzLnVwZGF0ZUN1c3RvbUxpbmtBY3Rpb24oYSxjLmhpZGUpO3RoaXMudXBkYXRlQ3VzdG9tTGlua0FjdGlvbihhLGMuc2VsZWN0KTt0aGlzLnVwZGF0ZUN1c3RvbUxpbmtBY3Rpb24oYSxjLmhpZ2hsaWdodCk7dGhpcy51cGRhdGVDdXN0b21MaW5rQWN0aW9uKGEsYy5zY3JvbGwpfX07R3JhcGgucHJvdG90eXBlLnVwZGF0ZUN1c3RvbUxpbmtBY3Rpb249ZnVuY3Rpb24oYSwKYil7aWYobnVsbCE9YiYmbnVsbCE9Yi5jZWxscyl7Zm9yKHZhciBlPVtdLGM9MDtjPGIuY2VsbHMubGVuZ3RoO2MrKylpZigiKiI9PWIuY2VsbHNbY10pZS5wdXNoKGIuY2VsbHNbY10pO2Vsc2V7dmFyIGQ9YVtiLmNlbGxzW2NdXTtudWxsIT1kPyIiIT1kJiZlLnB1c2goZCk6ZS5wdXNoKGIuY2VsbHNbY10pfWIuY2VsbHM9ZX19O0dyYXBoLnByb3RvdHlwZS5nZXRDZWxsc0ZvckFjdGlvbj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmdldENlbGxzQnlJZChhLmNlbGxzKS5jb25jYXQodGhpcy5nZXRDZWxsc0ZvclRhZ3MoYS50YWdzLG51bGwsbnVsbCxiKSl9O0dyYXBoLnByb3RvdHlwZS5nZXRDZWxsc0J5SWQ9ZnVuY3Rpb24oYSl7dmFyIGI9W107aWYobnVsbCE9YSlmb3IodmFyIGU9MDtlPGEubGVuZ3RoO2UrKylpZigiKiI9PWFbZV0pdmFyIGM9dGhpcy5nZXREZWZhdWx0UGFyZW50KCksYj1iLmNvbmNhdCh0aGlzLm1vZGVsLmZpbHRlckRlc2NlbmRhbnRzKGZ1bmN0aW9uKGEpe3JldHVybiBhIT0KY30sYykpO2Vsc2V7dmFyIGQ9dGhpcy5tb2RlbC5nZXRDZWxsKGFbZV0pO251bGwhPWQmJmIucHVzaChkKX1yZXR1cm4gYn07R3JhcGgucHJvdG90eXBlLmdldENlbGxzRm9yVGFncz1mdW5jdGlvbihhLGIsZSxjKXt2YXIgZD1bXTtpZihudWxsIT1hKXtiPW51bGwhPWI/Yjp0aGlzLm1vZGVsLmdldERlc2NlbmRhbnRzKHRoaXMubW9kZWwuZ2V0Um9vdCgpKTtlPW51bGwhPWU/ZToidGFncyI7Zm9yKHZhciBmPTAsZz17fSxsPTA7bDxhLmxlbmd0aDtsKyspMDxhW2xdLmxlbmd0aCYmKGdbYVtsXS50b0xvd2VyQ2FzZSgpXT0hMCxmKyspO2ZvcihsPTA7bDxiLmxlbmd0aDtsKyspaWYoYyYmdGhpcy5tb2RlbC5nZXRQYXJlbnQoYltsXSk9PXRoaXMubW9kZWwucm9vdHx8dGhpcy5tb2RlbC5pc1ZlcnRleChiW2xdKXx8dGhpcy5tb2RlbC5pc0VkZ2UoYltsXSkpe3ZhciBuPW51bGwhPWJbbF0udmFsdWUmJiJvYmplY3QiPT10eXBlb2YgYltsXS52YWx1ZT9teFV0aWxzLnRyaW0oYltsXS52YWx1ZS5nZXRBdHRyaWJ1dGUoZSl8fAoiIik6IiIscD0hMTtpZigwPG4ubGVuZ3RoKXtpZihuPW4udG9Mb3dlckNhc2UoKS5zcGxpdCgiICIpLG4ubGVuZ3RoPj1hLmxlbmd0aCl7Zm9yKHZhciB0PXA9MDt0PG4ubGVuZ3RoJiZwPGY7dCsrKW51bGwhPWdbblt0XV0mJnArKztwPXA9PWZ9fWVsc2UgcD0wPT1hLmxlbmd0aDtwJiZkLnB1c2goYltsXSl9fXJldHVybiBkfTtHcmFwaC5wcm90b3R5cGUudG9nZ2xlQ2VsbHM9ZnVuY3Rpb24oYSl7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLm1vZGVsLnNldFZpc2libGUoYVtiXSwhdGhpcy5tb2RlbC5pc1Zpc2libGUoYVtiXSkpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19O0dyYXBoLnByb3RvdHlwZS5zZXRDZWxsc1Zpc2libGU9ZnVuY3Rpb24oYSxiKXt0aGlzLm1vZGVsLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7ZSsrKXRoaXMubW9kZWwuc2V0VmlzaWJsZShhW2VdLGIpfWZpbmFsbHl7dGhpcy5tb2RlbC5lbmRVcGRhdGUoKX19OwpHcmFwaC5wcm90b3R5cGUuaGlnaGxpZ2h0Q2VsbHM9ZnVuY3Rpb24oYSxiLGUsYyl7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspdGhpcy5oaWdobGlnaHRDZWxsKGFbZF0sYixlLGMpfTtHcmFwaC5wcm90b3R5cGUuaGlnaGxpZ2h0Q2VsbD1mdW5jdGlvbihhLGIsZSxjKXtiPW51bGwhPWI/YjpteENvbnN0YW50cy5ERUZBVUxUX1ZBTElEX0NPTE9SO2U9bnVsbCE9ZT9lOjFFMzthPXRoaXMudmlldy5nZXRTdGF0ZShhKTtpZihudWxsIT1hKXt2YXIgZD1NYXRoLm1heCg1LG14VXRpbHMuZ2V0VmFsdWUoYS5zdHlsZSxteENvbnN0YW50cy5TVFlMRV9TVFJPS0VXSURUSCwxKSs0KSxmPW5ldyBteENlbGxIaWdobGlnaHQodGhpcyxiLGQsITEpO251bGwhPWMmJihmLm9wYWNpdHk9Yyk7Zi5oaWdobGlnaHQoYSk7d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtudWxsIT1mLnNoYXBlJiYobXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGYuc2hhcGUubm9kZS5zdHlsZSwidHJhbnNpdGlvbiIsCiJhbGwgMTIwMG1zIGVhc2UtaW4tb3V0IiksZi5zaGFwZS5ub2RlLnN0eWxlLm9wYWNpdHk9MCk7d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtmLmRlc3Ryb3koKX0sMTIwMCl9LGUpfX07R3JhcGgucHJvdG90eXBlLmFkZFN2Z1NoYWRvdz1mdW5jdGlvbihhLGIsZSl7ZT1udWxsIT1lP2U6ITE7dmFyIGM9YS5vd25lckRvY3VtZW50LGQ9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJmaWx0ZXIiKTpjLmNyZWF0ZUVsZW1lbnQoImZpbHRlciIpO2Quc2V0QXR0cmlidXRlKCJpZCIsdGhpcy5zaGFkb3dJZCk7dmFyIGY9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJmZUdhdXNzaWFuQmx1ciIpOmMuY3JlYXRlRWxlbWVudCgiZmVHYXVzc2lhbkJsdXIiKTtmLnNldEF0dHJpYnV0ZSgiaW4iLCJTb3VyY2VBbHBoYSIpO2Yuc2V0QXR0cmlidXRlKCJzdGREZXZpYXRpb24iLAp0aGlzLnN2Z1NoYWRvd0JsdXIpO2Yuc2V0QXR0cmlidXRlKCJyZXN1bHQiLCJibHVyIik7ZC5hcHBlbmRDaGlsZChmKTtmPW51bGwhPWMuY3JlYXRlRWxlbWVudE5TP2MuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZmVPZmZzZXQiKTpjLmNyZWF0ZUVsZW1lbnQoImZlT2Zmc2V0Iik7Zi5zZXRBdHRyaWJ1dGUoImluIiwiYmx1ciIpO2Yuc2V0QXR0cmlidXRlKCJkeCIsdGhpcy5zdmdTaGFkb3dTaXplKTtmLnNldEF0dHJpYnV0ZSgiZHkiLHRoaXMuc3ZnU2hhZG93U2l6ZSk7Zi5zZXRBdHRyaWJ1dGUoInJlc3VsdCIsIm9mZnNldEJsdXIiKTtkLmFwcGVuZENoaWxkKGYpO2Y9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJmZUZsb29kIik6Yy5jcmVhdGVFbGVtZW50KCJmZUZsb29kIik7Zi5zZXRBdHRyaWJ1dGUoImZsb29kLWNvbG9yIix0aGlzLnN2Z1NoYWRvd0NvbG9yKTtmLnNldEF0dHJpYnV0ZSgiZmxvb2Qtb3BhY2l0eSIsCnRoaXMuc3ZnU2hhZG93T3BhY2l0eSk7Zi5zZXRBdHRyaWJ1dGUoInJlc3VsdCIsIm9mZnNldENvbG9yIik7ZC5hcHBlbmRDaGlsZChmKTtmPW51bGwhPWMuY3JlYXRlRWxlbWVudE5TP2MuY3JlYXRlRWxlbWVudE5TKG14Q29uc3RhbnRzLk5TX1NWRywiZmVDb21wb3NpdGUiKTpjLmNyZWF0ZUVsZW1lbnQoImZlQ29tcG9zaXRlIik7Zi5zZXRBdHRyaWJ1dGUoImluIiwib2Zmc2V0Q29sb3IiKTtmLnNldEF0dHJpYnV0ZSgiaW4yIiwib2Zmc2V0Qmx1ciIpO2Yuc2V0QXR0cmlidXRlKCJvcGVyYXRvciIsImluIik7Zi5zZXRBdHRyaWJ1dGUoInJlc3VsdCIsIm9mZnNldEJsdXIiKTtkLmFwcGVuZENoaWxkKGYpO2Y9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJmZUJsZW5kIik6Yy5jcmVhdGVFbGVtZW50KCJmZUJsZW5kIik7Zi5zZXRBdHRyaWJ1dGUoImluIiwiU291cmNlR3JhcGhpYyIpO2Yuc2V0QXR0cmlidXRlKCJpbjIiLAoib2Zmc2V0Qmx1ciIpO2QuYXBwZW5kQ2hpbGQoZik7Zj1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkZWZzIik7MD09Zi5sZW5ndGg/KGM9bnVsbCE9Yy5jcmVhdGVFbGVtZW50TlM/Yy5jcmVhdGVFbGVtZW50TlMobXhDb25zdGFudHMuTlNfU1ZHLCJkZWZzIik6Yy5jcmVhdGVFbGVtZW50KCJkZWZzIiksbnVsbCE9YS5maXJzdENoaWxkP2EuaW5zZXJ0QmVmb3JlKGMsYS5maXJzdENoaWxkKTphLmFwcGVuZENoaWxkKGMpKTpjPWZbMF07Yy5hcHBlbmRDaGlsZChkKTtlfHwoYj1udWxsIT1iP2I6YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZyIpWzBdLG51bGwhPWImJihiLnNldEF0dHJpYnV0ZSgiZmlsdGVyIiwidXJsKCMiK3RoaXMuc2hhZG93SWQrIikiKSxpc05hTihwYXJzZUludChhLmdldEF0dHJpYnV0ZSgid2lkdGgiKSkpfHwoYS5zZXRBdHRyaWJ1dGUoIndpZHRoIixwYXJzZUludChhLmdldEF0dHJpYnV0ZSgid2lkdGgiKSkrNiksYS5zZXRBdHRyaWJ1dGUoImhlaWdodCIscGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpKSsKNiksYj1hLmdldEF0dHJpYnV0ZSgidmlld0JveCIpLG51bGwhPWImJjA8Yi5sZW5ndGgmJihiPWIuc3BsaXQoIiAiKSwzPGIubGVuZ3RoJiYodz1wYXJzZUZsb2F0KGJbMl0pKzYsaD1wYXJzZUZsb2F0KGJbM10pKzYsYS5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLGJbMF0rIiAiK2JbMV0rIiAiK3crIiAiK2gpKSkpKSk7cmV0dXJuIGR9O0dyYXBoLnByb3RvdHlwZS5zZXRTaGFkb3dWaXNpYmxlPWZ1bmN0aW9uKGEsYil7bXhDbGllbnQuSVNfU1ZHJiYhbXhDbGllbnQuSVNfU0YmJihiPW51bGwhPWI/YjohMCwodGhpcy5zaGFkb3dWaXNpYmxlPWEpP3RoaXMudmlldy5nZXREcmF3UGFuZSgpLnNldEF0dHJpYnV0ZSgiZmlsdGVyIiwidXJsKCMiK3RoaXMuc2hhZG93SWQrIikiKTp0aGlzLnZpZXcuZ2V0RHJhd1BhbmUoKS5yZW1vdmVBdHRyaWJ1dGUoImZpbHRlciIpLGImJnRoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJzaGFkb3dWaXNpYmxlQ2hhbmdlZCIpKSl9O0dyYXBoLnByb3RvdHlwZS5zZWxlY3RVbmxvY2tlZExheWVyPQpmdW5jdGlvbigpe2lmKG51bGw9PXRoaXMuZGVmYXVsdFBhcmVudCl7dmFyIGE9dGhpcy5tb2RlbC5nZXRDaGlsZENvdW50KHRoaXMubW9kZWwucm9vdCksYixlPTA7ZG8gYj10aGlzLm1vZGVsLmdldENoaWxkQXQodGhpcy5tb2RlbC5yb290LGUpO3doaWxlKGUrKzxhJiYiMSI9PW14VXRpbHMuZ2V0VmFsdWUodGhpcy5nZXRDZWxsU3R5bGUoYiksImxvY2tlZCIsIjAiKSk7bnVsbCE9YiYmdGhpcy5zZXREZWZhdWx0UGFyZW50KGIpfX07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLm1vY2t1cD1bU0hBUEVTX1BBVEgrIi9tb2NrdXAvbXhNb2NrdXBCdXR0b25zLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmFycm93czI9W1NIQVBFU19QQVRIKyIvbXhBcnJvd3MuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYXRsYXNzaWFuPVtTVEVOQ0lMX1BBVEgrIi9hdGxhc3NpYW4ueG1sIixTSEFQRVNfUEFUSCsiL214QXRsYXNzaWFuLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmJwbW49CltTSEFQRVNfUEFUSCsiL2JwbW4vbXhCcG1uU2hhcGUyLmpzIixTVEVOQ0lMX1BBVEgrIi9icG1uLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5jND1bU0hBUEVTX1BBVEgrIi9teEM0LmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmNpc2NvMTk9W1NIQVBFU19QQVRIKyIvbXhDaXNjbzE5LmpzIixTVEVOQ0lMX1BBVEgrIi9jaXNjbzE5LnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5kZmQ9W1NIQVBFU19QQVRIKyIvbXhERkQuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuZXI9W1NIQVBFU19QQVRIKyIvZXIvbXhFUi5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5rdWJlcm5ldGVzPVtTSEFQRVNfUEFUSCsiL214S3ViZXJuZXRlcy5qcyIsU1RFTkNJTF9QQVRIKyIva3ViZXJuZXRlcy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuZmxvd2NoYXJ0PVtTSEFQRVNfUEFUSCsiL214Rmxvd2NoYXJ0LmpzIiwKU1RFTkNJTF9QQVRIKyIvZmxvd2NoYXJ0LnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5pb3M9W1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwaU9TLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnJhY2tHZW5lcmFsPVtTSEFQRVNfUEFUSCsiL3JhY2svbXhSYWNrLmpzIixTVEVOQ0lMX1BBVEgrIi9yYWNrL2dlbmVyYWwueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnJhY2tGNT1bU1RFTkNJTF9QQVRIKyIvcmFjay9mNS54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMubGVhbl9tYXBwaW5nPVtTSEFQRVNfUEFUSCsiL214TGVhbk1hcC5qcyIsU1RFTkNJTF9QQVRIKyIvbGVhbl9tYXBwaW5nLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5iYXNpYz1bU0hBUEVTX1BBVEgrIi9teEJhc2ljLmpzIixTVEVOQ0lMX1BBVEgrIi9iYXNpYy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuaW9zN2ljb25zPQpbU1RFTkNJTF9QQVRIKyIvaW9zNy9pY29ucy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuaW9zN3VpPVtTSEFQRVNfUEFUSCsiL2lvczcvbXhJT1M3VWkuanMiLFNURU5DSUxfUEFUSCsiL2lvczcvbWlzYy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYW5kcm9pZD1bU0hBUEVTX1BBVEgrIi9teEFuZHJvaWQuanMiLFNURU5DSUxfUEFUSCsiL2FuZHJvaWQvYW5kcm9pZC54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbImVsZWN0cmljYWwvbWlzY2VsbGFuZW91cyJdPVtTSEFQRVNfUEFUSCsiL214RWxlY3RyaWNhbC5qcyIsU1RFTkNJTF9QQVRIKyIvZWxlY3RyaWNhbC9taXNjZWxsYW5lb3VzLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1siZWxlY3RyaWNhbC90cmFuc21pc3Npb24iXT1bU0hBUEVTX1BBVEgrIi9teEVsZWN0cmljYWwuanMiLFNURU5DSUxfUEFUSCsiL2VsZWN0cmljYWwvdHJhbnNtaXNzaW9uLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1siZWxlY3RyaWNhbC9sb2dpY19nYXRlcyJdPQpbU0hBUEVTX1BBVEgrIi9teEVsZWN0cmljYWwuanMiLFNURU5DSUxfUEFUSCsiL2VsZWN0cmljYWwvbG9naWNfZ2F0ZXMueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJlbGVjdHJpY2FsL2Fic3RyYWN0Il09W1NIQVBFU19QQVRIKyIvbXhFbGVjdHJpY2FsLmpzIixTVEVOQ0lMX1BBVEgrIi9lbGVjdHJpY2FsL2Fic3RyYWN0LnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5pbmZvZ3JhcGhpYz1bU0hBUEVTX1BBVEgrIi9teEluZm9ncmFwaGljLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJtb2NrdXAvYnV0dG9ucyJdPVtTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cEJ1dHRvbnMuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbIm1vY2t1cC9jb250YWluZXJzIl09W1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwQ29udGFpbmVycy5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1sibW9ja3VwL2Zvcm1zIl09CltTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cEZvcm1zLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJtb2NrdXAvZ3JhcGhpY3MiXT1bU0hBUEVTX1BBVEgrIi9tb2NrdXAvbXhNb2NrdXBHcmFwaGljcy5qcyIsU1RFTkNJTF9QQVRIKyIvbW9ja3VwL21pc2MueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJtb2NrdXAvbWFya3VwIl09W1NIQVBFU19QQVRIKyIvbW9ja3VwL214TW9ja3VwTWFya3VwLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzWyJtb2NrdXAvbWlzYyJdPVtTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cE1pc2MuanMiLFNURU5DSUxfUEFUSCsiL21vY2t1cC9taXNjLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllc1sibW9ja3VwL25hdmlnYXRpb24iXT1bU0hBUEVTX1BBVEgrIi9tb2NrdXAvbXhNb2NrdXBOYXZpZ2F0aW9uLmpzIixTVEVOQ0lMX1BBVEgrIi9tb2NrdXAvbWlzYy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXNbIm1vY2t1cC90ZXh0Il09CltTSEFQRVNfUEFUSCsiL21vY2t1cC9teE1vY2t1cFRleHQuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuZmxvb3JwbGFuPVtTSEFQRVNfUEFUSCsiL214Rmxvb3JwbGFuLmpzIixTVEVOQ0lMX1BBVEgrIi9mbG9vcnBsYW4ueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmJvb3RzdHJhcD1bU0hBUEVTX1BBVEgrIi9teEJvb3RzdHJhcC5qcyIsU0hBUEVTX1BBVEgrIi9teEJhc2ljLmpzIixTVEVOQ0lMX1BBVEgrIi9ib290c3RyYXAueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmdtZGw9W1NIQVBFU19QQVRIKyIvbXhHbWRsLmpzIixTVEVOQ0lMX1BBVEgrIi9nbWRsLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5nY3AyPVtTSEFQRVNfUEFUSCsiL214R0NQMi5qcyIsU1RFTkNJTF9QQVRIKyIvZ2NwMi54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuaWJtPVtTSEFQRVNfUEFUSCsiL214SUJNLmpzIixTVEVOQ0lMX1BBVEgrCiIvaWJtLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5jYWJpbmV0cz1bU0hBUEVTX1BBVEgrIi9teENhYmluZXRzLmpzIixTVEVOQ0lMX1BBVEgrIi9jYWJpbmV0cy54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuYXJjaGltYXRlPVtTSEFQRVNfUEFUSCsiL214QXJjaGlNYXRlLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmFyY2hpbWF0ZTM9W1NIQVBFU19QQVRIKyIvbXhBcmNoaU1hdGUzLmpzIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnN5c21sPVtTSEFQRVNfUEFUSCsiL214U3lzTUwuanMiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMuZWlwPVtTSEFQRVNfUEFUSCsiL214RWlwLmpzIixTVEVOQ0lMX1BBVEgrIi9laXAueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLm5ldHdvcmtzPVtTSEFQRVNfUEFUSCsiL214TmV0d29ya3MuanMiLFNURU5DSUxfUEFUSCsiL25ldHdvcmtzLnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5hd3MzZD0KW1NIQVBFU19QQVRIKyIvbXhBV1MzRC5qcyIsU1RFTkNJTF9QQVRIKyIvYXdzM2QueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLmF3czQ9W1NIQVBFU19QQVRIKyIvbXhBV1M0LmpzIixTVEVOQ0lMX1BBVEgrIi9hd3M0LnhtbCJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5hd3M0Yj1bU0hBUEVTX1BBVEgrIi9teEFXUzQuanMiLFNURU5DSUxfUEFUSCsiL2F3czQueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnZlZWFtPVtTVEVOQ0lMX1BBVEgrIi92ZWVhbS8yZC54bWwiLFNURU5DSUxfUEFUSCsiL3ZlZWFtLzNkLnhtbCIsU1RFTkNJTF9QQVRIKyIvdmVlYW0vdmVlYW0ueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnZlZWFtMj1bU1RFTkNJTF9QQVRIKyIvdmVlYW0vMmQueG1sIixTVEVOQ0lMX1BBVEgrIi92ZWVhbS8zZC54bWwiLFNURU5DSUxfUEFUSCsiL3ZlZWFtL3ZlZWFtMi54bWwiXTtteFN0ZW5jaWxSZWdpc3RyeS5saWJyYXJpZXMucGlkMmluc3Q9CltTSEFQRVNfUEFUSCsiL3BpZDIvbXhQaWRJbnN0cnVtZW50cy5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5waWQybWlzYz1bU0hBUEVTX1BBVEgrIi9waWQyL214UGlkTWlzYy5qcyIsU1RFTkNJTF9QQVRIKyIvcGlkL21pc2MueG1sIl07bXhTdGVuY2lsUmVnaXN0cnkubGlicmFyaWVzLnBpZDJ2YWx2ZXM9W1NIQVBFU19QQVRIKyIvcGlkMi9teFBpZFZhbHZlcy5qcyJdO214U3RlbmNpbFJlZ2lzdHJ5LmxpYnJhcmllcy5waWRGbG93U2Vuc29ycz1bU1RFTkNJTF9QQVRIKyIvcGlkL2Zsb3dfc2Vuc29ycy54bWwiXTtteE1hcmtlci5nZXRQYWNrYWdlRm9yVHlwZT1mdW5jdGlvbihhKXt2YXIgYj1udWxsO251bGwhPWEmJjA8YS5sZW5ndGgmJigiRVIiPT1hLnN1YnN0cmluZygwLDIpP2I9Im14Z3JhcGguZXIiOiJzeXNNTCI9PWEuc3Vic3RyaW5nKDAsNSkmJihiPSJteGdyYXBoLnN5c21sIikpO3JldHVybiBifTt2YXIgRz1teE1hcmtlci5jcmVhdGVNYXJrZXI7bXhNYXJrZXIuY3JlYXRlTWFya2VyPQpmdW5jdGlvbihhLGIsZSxjLGQsZixnLGwsbixwKXtpZihudWxsIT1lJiZudWxsPT1teE1hcmtlci5tYXJrZXJzW2VdKXt2YXIgdD10aGlzLmdldFBhY2thZ2VGb3JUeXBlKGUpO251bGwhPXQmJm14U3RlbmNpbFJlZ2lzdHJ5LmdldFN0ZW5jaWwodCl9cmV0dXJuIEcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtQcmludERpYWxvZy5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gZSgpe3kudmFsdWU9TWF0aC5tYXgoMSxNYXRoLm1pbihsLE1hdGgubWF4KHBhcnNlSW50KHkudmFsdWUpLHBhcnNlSW50KG0udmFsdWUpKSkpO20udmFsdWU9TWF0aC5tYXgoMSxNYXRoLm1pbihsLE1hdGgubWluKHBhcnNlSW50KHkudmFsdWUpLHBhcnNlSW50KG0udmFsdWUpKSkpfWZ1bmN0aW9uIGMoYil7ZnVuY3Rpb24gZShiLGUsZil7dmFyIGc9Yi51c2VDc3NUcmFuc2Zvcm1zLGw9Yi5jdXJyZW50VHJhbnNsYXRlLG49Yi5jdXJyZW50U2NhbGUscD1iLnZpZXcudHJhbnNsYXRlLHQ9CmIudmlldy5zY2FsZTtiLnVzZUNzc1RyYW5zZm9ybXMmJihiLnVzZUNzc1RyYW5zZm9ybXM9ITEsYi5jdXJyZW50VHJhbnNsYXRlPW5ldyBteFBvaW50KDAsMCksYi5jdXJyZW50U2NhbGU9MSxiLnZpZXcudHJhbnNsYXRlPW5ldyBteFBvaW50KDAsMCksYi52aWV3LnNjYWxlPTEpO3ZhciBrPWIuZ2V0R3JhcGhCb3VuZHMoKSxtPTAsdj0wLHk9cmEuZ2V0KCkseD0xL2IucGFnZVNjYWxlLHE9ei5jaGVja2VkO2lmKHEpdmFyIHg9cGFyc2VJbnQoSy52YWx1ZSksQz1wYXJzZUludChwYS52YWx1ZSkseD1NYXRoLm1pbih5LmhlaWdodCpDLyhrLmhlaWdodC9iLnZpZXcuc2NhbGUpLHkud2lkdGgqeC8oay53aWR0aC9iLnZpZXcuc2NhbGUpKTtlbHNlIHg9cGFyc2VJbnQodS52YWx1ZSkvKDEwMCpiLnBhZ2VTY2FsZSksaXNOYU4oeCkmJihjPTEvYi5wYWdlU2NhbGUsdS52YWx1ZT0iMTAwICUiKTt5PW14UmVjdGFuZ2xlLmZyb21SZWN0YW5nbGUoeSk7eS53aWR0aD1NYXRoLmNlaWwoeS53aWR0aCoKYyk7eS5oZWlnaHQ9TWF0aC5jZWlsKHkuaGVpZ2h0KmMpO3gqPWM7IXEmJmIucGFnZVZpc2libGU/KGs9Yi5nZXRQYWdlTGF5b3V0KCksbS09ay54Knkud2lkdGgsdi09ay55KnkuaGVpZ2h0KTpxPSEwO2lmKG51bGw9PWUpe2U9UHJpbnREaWFsb2cuY3JlYXRlUHJpbnRQcmV2aWV3KGIseCx5LDAsbSx2LHEpO2UucGFnZVNlbGVjdG9yPSExO2UubWF0aEVuYWJsZWQ9ITE7bT1hLmdldEN1cnJlbnRGaWxlKCk7bnVsbCE9bSYmKGUudGl0bGU9bS5nZXRUaXRsZSgpKTt2YXIgQT1lLndyaXRlSGVhZDtlLndyaXRlSGVhZD1mdW5jdGlvbihlKXtBLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT1hLmVkaXRvci5mb250Q3NzJiYoZS53cml0ZWxuKCc8c3R5bGUgdHlwZT0idGV4dC9jc3MiPicpLGUud3JpdGVsbihhLmVkaXRvci5mb250Q3NzKSxlLndyaXRlbG4oIjwvc3R5bGU+IikpO2lmKG51bGwhPWIuZXh0Rm9udHMpZm9yKHZhciBjPTA7YzxiLmV4dEZvbnRzLmxlbmd0aDtjKyspe3ZhciBkPQpiLmV4dEZvbnRzW2NdLm5hbWUsZj1iLmV4dEZvbnRzW2NdLnVybDswPT1mLmluZGV4T2YoRWRpdG9yLkdPT0dMRV9GT05UUyk/ZS53cml0ZWxuKCc8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9IicrZisnIiBjaGFyc2V0PSJVVEYtOCIgdHlwZT0idGV4dC9jc3MiPicpOihlLndyaXRlbG4oJzxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+JyksZS53cml0ZWxuKCdAZm9udC1mYWNlIHtcblx0Zm9udC1mYW1pbHk6ICInK2QrJyI7XG5cdHNyYzogdXJsKCInK2YrJyIpO1xufScpLGUud3JpdGVsbigiPC9zdHlsZT4iKSl9fTtpZigidW5kZWZpbmVkIiE9PXR5cGVvZiBNYXRoSmF4KXt2YXIgRD1lLnJlbmRlclBhZ2U7ZS5yZW5kZXJQYWdlPWZ1bmN0aW9uKGIsZSxjLGQsZixnKXt2YXIgbD1teENsaWVudC5OT19GTztteENsaWVudC5OT19GTz10aGlzLmdyYXBoLm1hdGhFbmFibGVkJiYhYS5lZGl0b3IudXNlRm9yZWlnbk9iamVjdEZvck1hdGg/ITA6YS5lZGl0b3Iub3JpZ2luYWxOb0ZvcmVpZ25PYmplY3Q7CnZhciBuPUQuYXBwbHkodGhpcyxhcmd1bWVudHMpO214Q2xpZW50Lk5PX0ZPPWw7dGhpcy5ncmFwaC5tYXRoRW5hYmxlZD90aGlzLm1hdGhFbmFibGVkPXRoaXMubWF0aEVuYWJsZWR8fCEwOm4uY2xhc3NOYW1lPSJnZURpc2FibGVNYXRoSmF4IjtyZXR1cm4gbn19bT1udWxsO251bGwhPWQudGhlbWVzJiYiZGFya1RoZW1lIj09ZC5kZWZhdWx0VGhlbWVOYW1lJiYobT1kLnN0eWxlc2hlZXQsZC5zdHlsZXNoZWV0PWQuZ2V0RGVmYXVsdFN0eWxlc2hlZXQoKSxkLnJlZnJlc2goKSk7ZS5vcGVuKG51bGwsbnVsbCxmLCEwKTtudWxsIT1tJiYoZC5zdHlsZXNoZWV0PW0sZC5yZWZyZXNoKCkpfWVsc2V7eT1iLmJhY2tncm91bmQ7aWYobnVsbD09eXx8IiI9PXl8fHk9PW14Q29uc3RhbnRzLk5PTkUpeT0iI2ZmZmZmZiI7ZS5iYWNrZ3JvdW5kQ29sb3I9eTtlLmF1dG9PcmlnaW49cTtlLmFwcGVuZEdyYXBoKGIseCxtLHYsZiwhMCk7aWYobnVsbCE9Yi5leHRGb250cyYmbnVsbCE9ZS53bmQpZm9yKGY9CjA7ZjxiLmV4dEZvbnRzLmxlbmd0aDtmKyspbT1iLmV4dEZvbnRzW2ZdLm5hbWUsdj1iLmV4dEZvbnRzW2ZdLnVybCwwPT12LmluZGV4T2YoRWRpdG9yLkdPT0dMRV9GT05UUyk/ZS53bmQuZG9jdW1lbnQud3JpdGVsbignPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSInK3YrJyIgY2hhcnNldD0iVVRGLTgiIHR5cGU9InRleHQvY3NzIj4nKTooZS53bmQuZG9jdW1lbnQud3JpdGVsbignPHN0eWxlIHR5cGU9InRleHQvY3NzIj4nKSxlLnduZC5kb2N1bWVudC53cml0ZWxuKCdAZm9udC1mYWNlIHtcblx0Zm9udC1mYW1pbHk6ICInK20rJyI7XG5cdHNyYzogdXJsKCInK3YrJyIpO1xufScpLGUud25kLmRvY3VtZW50LndyaXRlbG4oIjwvc3R5bGU+IikpfWcmJihiLnVzZUNzc1RyYW5zZm9ybXM9ZyxiLmN1cnJlbnRUcmFuc2xhdGU9bCxiLmN1cnJlbnRTY2FsZT1uLGIudmlldy50cmFuc2xhdGU9cCxiLnZpZXcuc2NhbGU9dCk7cmV0dXJuIGV9dmFyIGM9cGFyc2VJbnQobGEudmFsdWUpLwoxMDA7aXNOYU4oYykmJihjPTEsbGEudmFsdWU9IjEwMCAlIik7dmFyIGM9Ljc1KmMsZj1udWxsO251bGwhPWQudGhlbWVzJiYiZGFya1RoZW1lIj09ZC5kZWZhdWx0VGhlbWVOYW1lJiYoZj1kLnN0eWxlc2hlZXQsZC5zdHlsZXNoZWV0PWQuZ2V0RGVmYXVsdFN0eWxlc2hlZXQoKSxkLnJlZnJlc2goKSk7dmFyIGc9bS52YWx1ZSxsPXkudmFsdWUscD0hdC5jaGVja2VkLGs9bnVsbDtwJiYocD1nPT1uJiZsPT1uKTtpZighcCYmbnVsbCE9YS5wYWdlcyYmYS5wYWdlcy5sZW5ndGgpe3ZhciB2PTAscD1hLnBhZ2VzLmxlbmd0aC0xO3QuY2hlY2tlZHx8KHY9cGFyc2VJbnQoZyktMSxwPXBhcnNlSW50KGwpLTEpO2Zvcih2YXIgeD12O3g8PXA7eCsrKXt2YXIgcT1hLnBhZ2VzW3hdLGc9cT09YS5jdXJyZW50UGFnZT9kOm51bGw7aWYobnVsbD09Zyl7dmFyIGc9YS5jcmVhdGVUZW1wb3JhcnlHcmFwaChkLnN0eWxlc2hlZXQpLGw9ITAsdj0hMSxDPW51bGwsQT1udWxsO251bGw9PXEudmlld1N0YXRlJiYKbnVsbD09cS5yb290JiZhLnVwZGF0ZVBhZ2VSb290KHEpO251bGwhPXEudmlld1N0YXRlJiYobD1xLnZpZXdTdGF0ZS5wYWdlVmlzaWJsZSx2PXEudmlld1N0YXRlLm1hdGhFbmFibGVkLEM9cS52aWV3U3RhdGUuYmFja2dyb3VuZCxBPXEudmlld1N0YXRlLmJhY2tncm91bmRJbWFnZSxnLmV4dEZvbnRzPXEudmlld1N0YXRlLmV4dEZvbnRzKTtnLmJhY2tncm91bmQ9QztnLmJhY2tncm91bmRJbWFnZT1udWxsIT1BP25ldyBteEltYWdlKEEuc3JjLEEud2lkdGgsQS5oZWlnaHQpOm51bGw7Zy5wYWdlVmlzaWJsZT1sO2cubWF0aEVuYWJsZWQ9djt2YXIgRD1nLmdldEdsb2JhbFZhcmlhYmxlO2cuZ2V0R2xvYmFsVmFyaWFibGU9ZnVuY3Rpb24oYil7cmV0dXJuInBhZ2UiPT1iP3EuZ2V0TmFtZSgpOiJwYWdlbnVtYmVyIj09Yj94KzE6InBhZ2Vjb3VudCI9PWI/bnVsbCE9YS5wYWdlcz9hLnBhZ2VzLmxlbmd0aDoxOkQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGcuY29udGFpbmVyKTsKYS51cGRhdGVQYWdlUm9vdChxKTtnLm1vZGVsLnNldFJvb3QocS5yb290KX1rPWUoZyxrLHghPXApO2chPWQmJmcuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZy5jb250YWluZXIpfX1lbHNlIGs9ZShkKTtudWxsPT1rP2EuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvclVwZGF0aW5nUHJldmlldyIpfSk6KGsubWF0aEVuYWJsZWQmJihwPWsud25kLmRvY3VtZW50LHAud3JpdGVsbignPHNjcmlwdCB0eXBlPSJ0ZXh0L3gtbWF0aGpheC1jb25maWciPicpLHAud3JpdGVsbigiTWF0aEpheC5IdWIuQ29uZmlnKHsiKSxwLndyaXRlbG4oInNob3dNYXRoTWVudTogZmFsc2UsIikscC53cml0ZWxuKCdtZXNzYWdlU3R5bGU6ICJub25lIiwnKSxwLndyaXRlbG4oJ2pheDogWyJpbnB1dC9UZVgiLCAiaW5wdXQvTWF0aE1MIiwgImlucHV0L0FzY2lpTWF0aCIsICJvdXRwdXQvU1ZHIl0sJykscC53cml0ZWxuKCdleHRlbnNpb25zOiBbInRleDJqYXguanMiLCAibW1sMmpheC5qcyIsICJhc2NpaW1hdGgyamF4LmpzIl0sJyksCnAud3JpdGVsbigiVGVYOiB7IikscC53cml0ZWxuKCdleHRlbnNpb25zOiBbIkFNU21hdGguanMiLCAiQU1Tc3ltYm9scy5qcyIsICJub0Vycm9ycy5qcyIsICJub1VuZGVmaW5lZC5qcyJdJykscC53cml0ZWxuKCJ9LCIpLHAud3JpdGVsbigiU1ZHOiB7IikscC53cml0ZWxuKCdmb250OiAiJysobnVsbCE9dXJsUGFyYW1zWyJtYXRoLWZvbnQiXT9kZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zWyJtYXRoLWZvbnQiXSk6IlRlWCIpKyciJykscC53cml0ZWxuKCJ9LCIpLHAud3JpdGVsbigidGV4MmpheDogeyIpLHAud3JpdGVsbignaWdub3JlQ2xhc3M6ICJnZURpc2FibGVNYXRoSmF4IicpLHAud3JpdGVsbigifSwiKSxwLndyaXRlbG4oImFzY2lpbWF0aDJqYXg6IHsiKSxwLndyaXRlbG4oJ2lnbm9yZUNsYXNzOiAiZ2VEaXNhYmxlTWF0aEpheCInKSxwLndyaXRlbG4oIn0iKSxwLndyaXRlbG4oIn0pOyIpLGImJihwLndyaXRlbG4oIk1hdGhKYXguSHViLlF1ZXVlKGZ1bmN0aW9uICgpIHsiKSwKcC53cml0ZWxuKCJ3aW5kb3cucHJpbnQoKTsiKSxwLndyaXRlbG4oIn0pOyIpKSxwLndyaXRlbG4oIlx4M2Mvc2NyaXB0PiIpLHAud3JpdGVsbignPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iJytEUkFXX01BVEhfVVJMKycvTWF0aEpheC5qcyI+XHgzYy9zY3JpcHQ+JykpLGsuY2xvc2VEb2N1bWVudCgpLCFrLm1hdGhFbmFibGVkJiZiJiZQcmludERpYWxvZy5wcmludFByZXZpZXcoaykpO251bGwhPWYmJihkLnN0eWxlc2hlZXQ9ZixkLnJlZnJlc2goKSl9dmFyIGQ9YS5lZGl0b3IuZ3JhcGgsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7Zy5zdHlsZS53aWR0aD0iMTAwJSI7Zy5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7Zy5zdHlsZS5tYXJnaW5Ub3A9IjBweCI7bXhVdGlscy53cml0ZShnLGJ8fG14UmVzb3VyY2VzLmdldCgicHJpbnQiKSk7Zi5hcHBlbmRDaGlsZChnKTt2YXIgbD0xLG49MSxwPQpkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtwLnN0eWxlLmNzc1RleHQ9ImJvcmRlci1ib3R0b206MXB4IHNvbGlkIGxpZ2h0R3JheTtwYWRkaW5nLWJvdHRvbToxMnB4O21hcmdpbi1ib3R0b206MTJweDsiO3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7dC5zdHlsZS5jc3NUZXh0PSJtYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi1ib3R0b206OHB4OyI7dC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiYWxsIik7dC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJyYWRpbyIpO3Quc2V0QXR0cmlidXRlKCJuYW1lIiwicGFnZXMtcHJpbnRkaWFsb2ciKTtwLmFwcGVuZENoaWxkKHQpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoInByaW50QWxsUGFnZXMiKSk7cC5hcHBlbmRDaGlsZChnKTtteFV0aWxzLmJyKHApO3ZhciBrPXQuY2xvbmVOb2RlKCEwKTt0LnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKTsKay5zZXRBdHRyaWJ1dGUoInZhbHVlIiwicmFuZ2UiKTtwLmFwcGVuZENoaWxkKGspO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoInBhZ2VzIikrIjoiKTtwLmFwcGVuZENoaWxkKGcpO3ZhciBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7bS5zdHlsZS5jc3NUZXh0PSJtYXJnaW46MCA4cHggMCA4cHg7IjttLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIxIik7bS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJudW1iZXIiKTttLnNldEF0dHJpYnV0ZSgibWluIiwiMSIpO20uc3R5bGUud2lkdGg9IjUwcHgiO3AuYXBwZW5kQ2hpbGQobSk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgidG8iKSk7cC5hcHBlbmRDaGlsZChnKTt2YXIgeT1tLmNsb25lTm9kZSghMCk7cC5hcHBlbmRDaGlsZCh5KTtteEV2ZW50LmFkZExpc3RlbmVyKG0sImZvY3VzIiwKZnVuY3Rpb24oKXtrLmNoZWNrZWQ9ITB9KTtteEV2ZW50LmFkZExpc3RlbmVyKHksImZvY3VzIixmdW5jdGlvbigpe2suY2hlY2tlZD0hMH0pO214RXZlbnQuYWRkTGlzdGVuZXIobSwiY2hhbmdlIixlKTtteEV2ZW50LmFkZExpc3RlbmVyKHksImNoYW5nZSIsZSk7aWYobnVsbCE9YS5wYWdlcyYmKGw9YS5wYWdlcy5sZW5ndGgsbnVsbCE9YS5jdXJyZW50UGFnZSkpZm9yKGc9MDtnPGEucGFnZXMubGVuZ3RoO2crKylpZihhLmN1cnJlbnRQYWdlPT1hLnBhZ2VzW2ddKXtuPWcrMTttLnZhbHVlPW47eS52YWx1ZT1uO2JyZWFrfW0uc2V0QXR0cmlidXRlKCJtYXgiLGwpO3kuc2V0QXR0cmlidXRlKCJtYXgiLGwpOzE8bCYmZi5hcHBlbmRDaGlsZChwKTt2YXIgdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt2LnN0eWxlLm1hcmdpbkJvdHRvbT0iMTBweCI7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt4LnN0eWxlLm1hcmdpblJpZ2h0PSI4cHgiO3guc2V0QXR0cmlidXRlKCJ2YWx1ZSIsCiJhZGp1c3QiKTt4LnNldEF0dHJpYnV0ZSgidHlwZSIsInJhZGlvIik7eC5zZXRBdHRyaWJ1dGUoIm5hbWUiLCJwcmludFpvb20iKTt2LmFwcGVuZENoaWxkKHgpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoImFkanVzdFRvIikpO3YuYXBwZW5kQ2hpbGQoZyk7dmFyIHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt1LnN0eWxlLmNzc1RleHQ9Im1hcmdpbjowIDhweCAwIDhweDsiO3Uuc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIjEwMCAlIik7dS5zdHlsZS53aWR0aD0iNTBweCI7di5hcHBlbmRDaGlsZCh1KTtteEV2ZW50LmFkZExpc3RlbmVyKHUsImZvY3VzIixmdW5jdGlvbigpe3guY2hlY2tlZD0hMH0pO2YuYXBwZW5kQ2hpbGQodik7dmFyIHA9cC5jbG9uZU5vZGUoITEpLHo9eC5jbG9uZU5vZGUoITApO3ouc2V0QXR0cmlidXRlKCJ2YWx1ZSIsImZpdCIpO3guc2V0QXR0cmlidXRlKCJjaGVja2VkIiwKImNoZWNrZWQiKTtnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2cuc3R5bGUuY3NzVGV4dD0iZGlzcGxheTppbmxpbmUtYmxvY2s7aGVpZ2h0OjEwMCU7dmVydGljYWwtYWxpZ246dG9wO3BhZGRpbmctdG9wOjJweDsiO2cuYXBwZW5kQ2hpbGQoeik7cC5hcHBlbmRDaGlsZChnKTt2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRhYmxlIik7di5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO3ZhciBxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRib2R5IiksQz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ0ciIpLEI9Qy5jbG9uZU5vZGUoITApLEQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGQiKSxFPUQuY2xvbmVOb2RlKCEwKSxHPUQuY2xvbmVOb2RlKCEwKSxGPUQuY2xvbmVOb2RlKCEwKSxIPUQuY2xvbmVOb2RlKCEwKSxKPUQuY2xvbmVOb2RlKCEwKTtELnN0eWxlLnRleHRBbGlnbj0icmlnaHQiO0Yuc3R5bGUudGV4dEFsaWduPSJyaWdodCI7bXhVdGlscy53cml0ZShELApteFJlc291cmNlcy5nZXQoImZpdFRvIikpO3ZhciBLPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7Sy5zdHlsZS5jc3NUZXh0PSJtYXJnaW46MCA4cHggMCA4cHg7IjtLLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIxIik7Sy5zZXRBdHRyaWJ1dGUoIm1pbiIsIjEiKTtLLnNldEF0dHJpYnV0ZSgidHlwZSIsIm51bWJlciIpO0suc3R5bGUud2lkdGg9IjQwcHgiO0UuYXBwZW5kQ2hpbGQoSyk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgiZml0VG9TaGVldHNBY3Jvc3MiKSk7Ry5hcHBlbmRDaGlsZChnKTtteFV0aWxzLndyaXRlKEYsbXhSZXNvdXJjZXMuZ2V0KCJmaXRUb0J5IikpO3ZhciBwYT1LLmNsb25lTm9kZSghMCk7SC5hcHBlbmRDaGlsZChwYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihLLCJmb2N1cyIsZnVuY3Rpb24oKXt6LmNoZWNrZWQ9ITB9KTtteEV2ZW50LmFkZExpc3RlbmVyKHBhLCJmb2N1cyIsCmZ1bmN0aW9uKCl7ei5jaGVja2VkPSEwfSk7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShnLG14UmVzb3VyY2VzLmdldCgiZml0VG9TaGVldHNEb3duIikpO0ouYXBwZW5kQ2hpbGQoZyk7Qy5hcHBlbmRDaGlsZChEKTtDLmFwcGVuZENoaWxkKEUpO0MuYXBwZW5kQ2hpbGQoRyk7Qi5hcHBlbmRDaGlsZChGKTtCLmFwcGVuZENoaWxkKEgpO0IuYXBwZW5kQ2hpbGQoSik7cS5hcHBlbmRDaGlsZChDKTtxLmFwcGVuZENoaWxkKEIpO3YuYXBwZW5kQ2hpbGQocSk7cC5hcHBlbmRDaGlsZCh2KTtmLmFwcGVuZENoaWxkKHApO3A9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtnLnN0eWxlLmZvbnRXZWlnaHQ9ImJvbGQiO2cuc3R5bGUubWFyZ2luQm90dG9tPSIxMnB4IjtteFV0aWxzLndyaXRlKGcsbXhSZXNvdXJjZXMuZ2V0KCJwYXBlclNpemUiKSk7cC5hcHBlbmRDaGlsZChnKTtnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwpnLnN0eWxlLm1hcmdpbkJvdHRvbT0iMTJweCI7dmFyIHJhPVBhZ2VTZXR1cERpYWxvZy5hZGRQYWdlRm9ybWF0UGFuZWwoZywicHJpbnRkaWFsb2ciLGEuZWRpdG9yLmdyYXBoLnBhZ2VGb3JtYXR8fG14Q29uc3RhbnRzLlBBR0VfRk9STUFUX0E0X1BPUlRSQUlUKTtwLmFwcGVuZENoaWxkKGcpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoZyxteFJlc291cmNlcy5nZXQoInBhZ2VTY2FsZSIpKTtwLmFwcGVuZENoaWxkKGcpO3ZhciBsYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2xhLnN0eWxlLmNzc1RleHQ9Im1hcmdpbjowIDhweCAwIDhweDsiO2xhLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIxMDAgJSIpO2xhLnN0eWxlLndpZHRoPSI2MHB4IjtwLmFwcGVuZENoaWxkKGxhKTtmLmFwcGVuZENoaWxkKHApO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zy5zdHlsZS5jc3NUZXh0PSJ0ZXh0LWFsaWduOnJpZ2h0O21hcmdpbjo0OHB4IDAgMCAwOyI7CnA9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpfSk7cC5jbGFzc05hbWU9ImdlQnRuIjthLmVkaXRvci5jYW5jZWxGaXJzdCYmZy5hcHBlbmRDaGlsZChwKTthLmlzT2ZmbGluZSgpfHwodj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImhlbHAiKSxmdW5jdGlvbigpe2Qub3BlbkxpbmsoImh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDQ4OTQ3Iil9KSx2LmNsYXNzTmFtZT0iZ2VCdG4iLGcuYXBwZW5kQ2hpbGQodikpO1ByaW50RGlhbG9nLnByZXZpZXdFbmFibGVkJiYodj1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoInByZXZpZXciKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO2MoITEpfSksdi5jbGFzc05hbWU9ImdlQnRuIixnLmFwcGVuZENoaWxkKHYpKTt2PW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldChQcmludERpYWxvZy5wcmV2aWV3RW5hYmxlZD8KInByaW50Ijoib2siKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO2MoITApfSk7di5jbGFzc05hbWU9ImdlQnRuIGdlUHJpbWFyeUJ0biI7Zy5hcHBlbmRDaGlsZCh2KTthLmVkaXRvci5jYW5jZWxGaXJzdHx8Zy5hcHBlbmRDaGlsZChwKTtmLmFwcGVuZENoaWxkKGcpO3RoaXMuY29udGFpbmVyPWZ9O3ZhciBGPUNoYW5nZVBhZ2VTZXR1cC5wcm90b3R5cGUuZXhlY3V0ZTtDaGFuZ2VQYWdlU2V0dXAucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtudWxsPT10aGlzLnBhZ2UmJih0aGlzLnBhZ2U9dGhpcy51aS5jdXJyZW50UGFnZSk7dGhpcy5wYWdlIT10aGlzLnVpLmN1cnJlbnRQYWdlP251bGwhPXRoaXMucGFnZS52aWV3U3RhdGUmJih0aGlzLmlnbm9yZUNvbG9yfHwodGhpcy5wYWdlLnZpZXdTdGF0ZS5iYWNrZ3JvdW5kPXRoaXMuY29sb3IpLHRoaXMuaWdub3JlSW1hZ2V8fCh0aGlzLnBhZ2Uudmlld1N0YXRlLmJhY2tncm91bmRJbWFnZT10aGlzLmltYWdlKSxudWxsIT10aGlzLmZvcm1hdCYmCih0aGlzLnBhZ2Uudmlld1N0YXRlLnBhZ2VGb3JtYXQ9dGhpcy5mb3JtYXQpLG51bGwhPXRoaXMubWF0aEVuYWJsZWQmJih0aGlzLnBhZ2Uudmlld1N0YXRlLm1hdGhFbmFibGVkPXRoaXMubWF0aEVuYWJsZWQpLG51bGwhPXRoaXMuc2hhZG93VmlzaWJsZSYmKHRoaXMucGFnZS52aWV3U3RhdGUuc2hhZG93VmlzaWJsZT10aGlzLnNoYWRvd1Zpc2libGUpKTooRi5hcHBseSh0aGlzLGFyZ3VtZW50cyksbnVsbCE9dGhpcy5tYXRoRW5hYmxlZCYmdGhpcy5tYXRoRW5hYmxlZCE9dGhpcy51aS5pc01hdGhFbmFibGVkKCkmJih0aGlzLnVpLnNldE1hdGhFbmFibGVkKHRoaXMubWF0aEVuYWJsZWQpLHRoaXMubWF0aEVuYWJsZWQ9IXRoaXMubWF0aEVuYWJsZWQpLG51bGwhPXRoaXMuc2hhZG93VmlzaWJsZSYmdGhpcy5zaGFkb3dWaXNpYmxlIT10aGlzLnVpLmVkaXRvci5ncmFwaC5zaGFkb3dWaXNpYmxlJiYodGhpcy51aS5lZGl0b3IuZ3JhcGguc2V0U2hhZG93VmlzaWJsZSh0aGlzLnNoYWRvd1Zpc2libGUpLAp0aGlzLnNoYWRvd1Zpc2libGU9IXRoaXMuc2hhZG93VmlzaWJsZSkpfTtFZGl0b3IucHJvdG90eXBlLnVzZUNhbnZhc0ZvckV4cG9ydD0hMTt0cnl7dmFyIEg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksSj1uZXcgSW1hZ2U7Si5vbmxvYWQ9ZnVuY3Rpb24oKXt0cnl7SC5nZXRDb250ZXh0KCIyZCIpLmRyYXdJbWFnZShKLDAsMCk7dmFyIGE9SC50b0RhdGFVUkwoImltYWdlL3BuZyIpO0VkaXRvci5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PW51bGwhPWEmJjY8YS5sZW5ndGh9Y2F0Y2goSyl7fX07Si5zcmM9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCgnPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMXB4IiBoZWlnaHQ9IjFweCIgdmVyc2lvbj0iMS4xIj48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JykpKX1jYXRjaCh1KXt9fSkoKTsKKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IENoYW5nZVBhZ2VTZXR1cCxbInVpIiwicHJldmlvdXNDb2xvciIsInByZXZpb3VzSW1hZ2UiLCJwcmV2aW91c0Zvcm1hdCJdKTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGYsZCl7ZC51aT1hLnVpO3JldHVybiBmfTthLmFmdGVyRGVjb2RlPWZ1bmN0aW9uKGEsZixkKXtkLnByZXZpb3VzQ29sb3I9ZC5jb2xvcjtkLnByZXZpb3VzSW1hZ2U9ZC5pbWFnZTtkLnByZXZpb3VzRm9ybWF0PWQuZm9ybWF0O251bGwhPWQuZm9sZGluZ0VuYWJsZWQmJihkLmZvbGRpbmdFbmFibGVkPSFkLmZvbGRpbmdFbmFibGVkKTtudWxsIT1kLm1hdGhFbmFibGVkJiYoZC5tYXRoRW5hYmxlZD0hZC5tYXRoRW5hYmxlZCk7bnVsbCE9ZC5zaGFkb3dWaXNpYmxlJiYoZC5zaGFkb3dWaXNpYmxlPSFkLnNoYWRvd1Zpc2libGUpO3JldHVybiBkfTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoYSl9KSgpOyhmdW5jdGlvbigpe0VkaXRvclVpLlZFUlNJT049IkBEUkFXSU8tVkVSU0lPTkAiO0VkaXRvclVpLmNvbXBhY3RVaT0iYXRsYXMiIT11aVRoZW1lO214R3JhcGhWaWV3LnByb3RvdHlwZS5kZWZhdWx0RGFya0dyaWRDb2xvcj0iIzZlNmU2ZSI7ImRhcmsiPT11aVRoZW1lJiYobXhHcmFwaFZpZXcucHJvdG90eXBlLmdyaWRDb2xvcj1teEdyYXBoVmlldy5wcm90b3R5cGUuZGVmYXVsdERhcmtHcmlkQ29sb3IpO0VkaXRvclVpLmVuYWJsZUxvZ2dpbmc9IjEiIT11cmxQYXJhbXMuc3RlYWx0aCYmKC8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSl8fC8uKlwuZGlhZ3JhbXNcLm5ldCQvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKSkmJiJzdXBwb3J0LmRyYXcuaW8iIT13aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7RWRpdG9yVWkuZHJhd0hvc3Q9d2luZG93LkRSQVdJT19CQVNFX1VSTDtFZGl0b3JVaS5sYXN0RXJyb3JNZXNzYWdlPW51bGw7RWRpdG9yVWkuaWdub3JlZEFub255bWl6ZWRDaGFycz0KIlxuXHRgfiFAIyQlXiYqKClfK3t9fDpcIjw+Py09W107Jy4vLFxuXHQiO0VkaXRvclVpLnRlbXBsYXRlRmlsZT1URU1QTEFURV9QQVRIKyIvaW5kZXgueG1sIjtFZGl0b3JVaS5jYWNoZVVybD0iMSI9PXVybFBhcmFtcy5kZXY/Ii9jYWNoZSI6d2luZG93LlJFQUxUSU1FX1VSTDtudWxsPT1FZGl0b3JVaS5jYWNoZVVybCYmInVuZGVmaW5lZCIhPT10eXBlb2YgRHJhd2lvRmlsZSYmKERyYXdpb0ZpbGUuU1lOQz0ibm9uZSIpO0VkaXRvci5jYWNoZVRpbWVvdXQ9MUU0O0VkaXRvclVpLmVuYWJsZVBsYW50VW1sPUVkaXRvclVpLmVuYWJsZUxvZ2dpbmc7RWRpdG9yVWkuaXNFbGVjdHJvbkFwcD1udWxsIT13aW5kb3cmJm51bGwhPXdpbmRvdy5wcm9jZXNzJiZudWxsIT13aW5kb3cucHJvY2Vzcy52ZXJzaW9ucyYmbnVsbCE9d2luZG93LnByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247RWRpdG9yVWkuZW5hYmxlRHJhZnRzPSFteENsaWVudC5JU19DSFJPTUVBUFAmJmlzTG9jYWxTdG9yYWdlJiYKIUVkaXRvclVpLmlzRWxlY3Ryb25BcHAmJiIwIiE9dXJsUGFyYW1zLmRyYWZ0cztFZGl0b3JVaS5zY3JhdGNocGFkSGVscExpbms9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDQyMzY3IjtFZGl0b3JVaS5kZWZhdWx0TWVybWFpZENvbmZpZz17dGhlbWU6Im5ldXRyYWwiLGFycm93TWFya2VyQWJzb2x1dGU6ITEsZmxvd2NoYXJ0OntodG1sTGFiZWxzOiExfSxzZXF1ZW5jZTp7ZGlhZ3JhbU1hcmdpblg6NTAsZGlhZ3JhbU1hcmdpblk6MTAsYWN0b3JNYXJnaW46NTAsd2lkdGg6MTUwLGhlaWdodDo2NSxib3hNYXJnaW46MTAsYm94VGV4dE1hcmdpbjo1LG5vdGVNYXJnaW46MTAsbWVzc2FnZU1hcmdpbjozNSxtaXJyb3JBY3RvcnM6ITAsYm90dG9tTWFyZ2luQWRqOjEsdXNlTWF4V2lkdGg6ITAscmlnaHRBbmdsZXM6ITEsc2hvd1NlcXVlbmNlTnVtYmVyczohMX0sZ2FudHQ6e3RpdGxlVG9wTWFyZ2luOjI1LGJhckhlaWdodDoyMCxiYXJHYXA6NCwKdG9wUGFkZGluZzo1MCxsZWZ0UGFkZGluZzo3NSxncmlkTGluZVN0YXJ0UGFkZGluZzozNSxmb250U2l6ZToxMSxmb250RmFtaWx5OiciT3Blbi1TYW5zIiwgInNhbnMtc2VyaWYiJyxudW1iZXJTZWN0aW9uU3R5bGVzOjQsYXhpc0Zvcm1hdDoiJVktJW0tJWQifX07RWRpdG9yVWkubG9nRXJyb3I9ZnVuY3Rpb24oYSxlLGMsZCxmLHAsayl7cD1udWxsIT1wP3A6MDw9YS5pbmRleE9mKCJOZXR3b3JrRXJyb3IiKXx8MDw9YS5pbmRleE9mKCJTZWN1cml0eUVycm9yIil8fDA8PWEuaW5kZXhPZigiTlNfRVJST1JfRkFJTFVSRSIpfHwwPD1hLmluZGV4T2YoIm91dCBvZiBtZW1vcnkiKT8iQ09ORklHIjoiU0VWRVJFIjtpZihFZGl0b3JVaS5lbmFibGVMb2dnaW5nJiYiMSIhPXVybFBhcmFtcy5kZXYpdHJ5e2lmKGEhPUVkaXRvclVpLmxhc3RFcnJvck1lc3NhZ2UmJihudWxsPT1hfHxudWxsPT1lfHwtMT09YS5pbmRleE9mKCJTY3JpcHQgZXJyb3IiKSYmLTE9PWEuaW5kZXhPZigiZXh0ZW5zaW9uIikpJiYKbnVsbCE9YSYmMD5hLmluZGV4T2YoIkRvY3VtZW50Q2xvc2VkRXJyb3IiKSl7RWRpdG9yVWkubGFzdEVycm9yTWVzc2FnZT1hO3ZhciBiPW51bGwhPXdpbmRvdy5EUkFXSU9fTE9HX1VSTD93aW5kb3cuRFJBV0lPX0xPR19VUkw6IiI7Zj1udWxsIT1mP2Y6RXJyb3IoYSk7KG5ldyBJbWFnZSkuc3JjPWIrIi9sb2c/c2V2ZXJpdHk9IitwKyImdj0iK2VuY29kZVVSSUNvbXBvbmVudChFZGl0b3JVaS5WRVJTSU9OKSsiJm1zZz1jbGllbnRFcnJvcjoiK2VuY29kZVVSSUNvbXBvbmVudChhKSsiOnVybDoiK2VuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZikrIjpsbnVtOiIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKyhudWxsIT1kPyI6Y29sbm86IitlbmNvZGVVUklDb21wb25lbnQoZCk6IiIpKyhudWxsIT1mJiZudWxsIT1mLnN0YWNrPyImc3RhY2s9IitlbmNvZGVVUklDb21wb25lbnQoZi5zdGFjayk6IiIpfX1jYXRjaCh5KXt9dHJ5e2t8fG51bGw9PXdpbmRvdy5jb25zb2xlfHwKY29uc29sZS5lcnJvcihwLGEsZSxjLGQsZil9Y2F0Y2goeSl7fX07RWRpdG9yVWkubG9nRXZlbnQ9ZnVuY3Rpb24oYSl7aWYoIjEiPT11cmxQYXJhbXMuZGV2KUVkaXRvclVpLmRlYnVnKCJsb2dFdmVudCIsYSk7ZWxzZSBpZihFZGl0b3JVaS5lbmFibGVMb2dnaW5nKXRyeXt2YXIgYj1udWxsIT13aW5kb3cuRFJBV0lPX0xPR19VUkw/d2luZG93LkRSQVdJT19MT0dfVVJMOiIiOyhuZXcgSW1hZ2UpLnNyYz1iKyIvaW1hZ2VzLzF4MS5wbmc/dj0iK2VuY29kZVVSSUNvbXBvbmVudChFZGl0b3JVaS5WRVJTSU9OKSsobnVsbCE9YT8iJmRhdGE9IitlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoYSkpOiIiKX1jYXRjaChnKXt9fTtFZGl0b3JVaS5zZW5kUmVwb3J0PWZ1bmN0aW9uKGEsZSl7aWYoIjEiPT11cmxQYXJhbXMuZGV2KUVkaXRvclVpLmRlYnVnKCJzZW5kUmVwb3J0IixhKTtlbHNlIGlmKEVkaXRvclVpLmVuYWJsZUxvZ2dpbmcpdHJ5e2U9bnVsbCE9ZT9lOjVFNCxhLmxlbmd0aD4KZSYmKGE9YS5zdWJzdHJpbmcoMCxlKSsiXG4uLi5bU0hPUlRFTkVEXSIpLG14VXRpbHMucG9zdCgiL2VtYWlsIiwidmVyc2lvbj0iK2VuY29kZVVSSUNvbXBvbmVudChFZGl0b3JVaS5WRVJTSU9OKSsiJnVybD0iK2VuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZikrIiZkYXRhPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpKX1jYXRjaChnKXt9fTtFZGl0b3JVaS5kZWJ1Zz1mdW5jdGlvbigpe3RyeXtpZihudWxsIT13aW5kb3cuY29uc29sZSYmIjEiPT11cmxQYXJhbXMudGVzdCl7Zm9yKHZhciBhPVsobmV3IERhdGUpLnRvSVNPU3RyaW5nKCldLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKW51bGwhPWFyZ3VtZW50c1tlXSYmYS5wdXNoKGFyZ3VtZW50c1tlXSk7Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSxhKX19Y2F0Y2goZyl7fX07RWRpdG9yVWkucGFyc2VQbmc9ZnVuY3Rpb24oYSxlLGMpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgZT1mO2YrPWI7cmV0dXJuIGEuc3Vic3RyaW5nKGUsCmYpfWZ1bmN0aW9uIGQoYSl7YT1iKGEsNCk7cmV0dXJuIGEuY2hhckNvZGVBdCgzKSsoYS5jaGFyQ29kZUF0KDIpPDw4KSsoYS5jaGFyQ29kZUF0KDEpPDwxNikrKGEuY2hhckNvZGVBdCgwKTw8MjQpfXZhciBmPTA7aWYoYihhLDgpIT1TdHJpbmcuZnJvbUNoYXJDb2RlKDEzNykrIlBORyIrU3RyaW5nLmZyb21DaGFyQ29kZSgxMywxMCwyNiwxMCkpbnVsbCE9YyYmYygpO2Vsc2UgaWYoYihhLDQpLCJJSERSIiE9YihhLDQpKW51bGwhPWMmJmMoKTtlbHNle2IoYSwxNyk7ZG97Yz1kKGEpO3ZhciBnPWIoYSw0KTtpZihudWxsIT1lJiZlKGYtOCxnLGMpKWJyZWFrO3ZhbHVlPWIoYSxjKTtiKGEsNCk7aWYoIklFTkQiPT1nKWJyZWFrfXdoaWxlKGMpfX07RWRpdG9yVWkucmVtb3ZlQ2hpbGROb2Rlcz1mdW5jdGlvbihhKXtmb3IoO251bGwhPWEuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpfTtFZGl0b3JVaS5wcm90b3R5cGUuZW1wdHlEaWFncmFtWG1sPSc8bXhHcmFwaE1vZGVsPjxyb290PjxteENlbGwgaWQ9IjAiLz48bXhDZWxsIGlkPSIxIiBwYXJlbnQ9IjAiLz48L3Jvb3Q+PC9teEdyYXBoTW9kZWw+JzsKRWRpdG9yVWkucHJvdG90eXBlLmVtcHR5TGlicmFyeVhtbD0iPG14bGlicmFyeT5bXTwvbXhsaWJyYXJ5PiI7RWRpdG9yVWkucHJvdG90eXBlLm1vZGU9bnVsbDtFZGl0b3JVaS5wcm90b3R5cGUudGltZW91dD1FZGl0b3IucHJvdG90eXBlLnRpbWVvdXQ7RWRpdG9yVWkucHJvdG90eXBlLnNpZGViYXJGb290ZXJIZWlnaHQ9Mzg7RWRpdG9yVWkucHJvdG90eXBlLmRlZmF1bHRDdXN0b21TaGFwZVN0eWxlPSJzaGFwZT1zdGVuY2lsKHRaUnRUc1FnRUVCUHcxK0RKUjdBb042RGJXZnRwQWdFME9ydGQvallSR3E3MlIrWU5FMllnVGVQbG9FSkdXYmxnQTE4WnVLRkRjTWo1L1NtOGJvWnErQmdqQ1g0cFR5cWs2WmxLUk9pdHd1c09NWEtRRE9EeDVpeTRwWHhaNXFUSGlGSGF3eEIwSnJRWkg3bENhYlEwRnIrWFdDMS9FOHpjc1QvZ0FpK1N1Ym8yLzNNaDZkL29KYjVuVTFiNXRXN3Iya25hdXRhYTNUK1UzMm83Zjd2WndwSmthTkRMT1JKamN1N3Q1OW0yalh4cVg5dW4rdHQwMjJhY3NmbW9LYVFaK3ZoaHN3WnRTNk5lL1RoUUd0MElWME4zWXl2NlAzQ2VUOS90SE8wWEZJNWNBRT0pO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7IjsKRWRpdG9yVWkucHJvdG90eXBlLm1heEJhY2tncm91bmRTaXplPTE2MDA7RWRpdG9yVWkucHJvdG90eXBlLm1heEltYWdlU2l6ZT01MjA7RWRpdG9yVWkucHJvdG90eXBlLm1heFRleHRXaWR0aD01MjA7RWRpdG9yVWkucHJvdG90eXBlLnJlc2FtcGxlVGhyZXNob2xkPTFFNTtFZGl0b3JVaS5wcm90b3R5cGUubWF4SW1hZ2VCeXRlcz0xRTY7RWRpdG9yVWkucHJvdG90eXBlLm1heEJhY2tncm91bmRCeXRlcz0yNUU1O0VkaXRvclVpLnByb3RvdHlwZS5tYXhUZXh0Qnl0ZXM9NUU1O0VkaXRvclVpLnByb3RvdHlwZS5jdXJyZW50RmlsZT1udWxsO0VkaXRvclVpLnByb3RvdHlwZS5wcmludFBkZkV4cG9ydD0hMTtFZGl0b3JVaS5wcm90b3R5cGUucGRmUGFnZUV4cG9ydD0hMDtFZGl0b3JVaS5wcm90b3R5cGUuZm9ybWF0RW5hYmxlZD0iMCIhPXVybFBhcmFtcy5mb3JtYXQ7RWRpdG9yVWkucHJvdG90eXBlLmluc2VydFRlbXBsYXRlRW5hYmxlZD0hMDtFZGl0b3JVaS5wcm90b3R5cGUuY2xvc2FibGVTY3JhdGNocGFkPQohMDsoZnVuY3Rpb24oKXtFZGl0b3JVaS5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PSExO0VkaXRvclVpLnByb3RvdHlwZS5qcGdTdXBwb3J0ZWQ9ITE7dHJ5e3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO0VkaXRvclVpLnByb3RvdHlwZS5jYW52YXNTdXBwb3J0ZWQ9ISghYS5nZXRDb250ZXh0fHwhYS5nZXRDb250ZXh0KCIyZCIpKX1jYXRjaChsKXt9dHJ5e3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLGM9bmV3IEltYWdlO2Mub25sb2FkPWZ1bmN0aW9uKCl7dHJ5e2UuZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2UoYywwLDApO3ZhciBhPWUudG9EYXRhVVJMKCJpbWFnZS9wbmciKTtFZGl0b3JVaS5wcm90b3R5cGUudXNlQ2FudmFzRm9yRXhwb3J0PW51bGwhPWEmJjY8YS5sZW5ndGh9Y2F0Y2gocCl7fX07Yy5zcmM9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCgnPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMXB4IiBoZWlnaHQ9IjFweCIgdmVyc2lvbj0iMS4xIj48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JykpKX1jYXRjaChsKXt9dHJ5e2U9CmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO2Uud2lkdGg9ZS5oZWlnaHQ9MTt2YXIgZD1lLnRvRGF0YVVSTCgiaW1hZ2UvanBlZyIpO0VkaXRvclVpLnByb3RvdHlwZS5qcGdTdXBwb3J0ZWQ9bnVsbCE9PWQubWF0Y2goImltYWdlL2pwZWciKX1jYXRjaChsKXt9fSkoKTtFZGl0b3JVaS5wcm90b3R5cGUub3Blbkxpbms9ZnVuY3Rpb24oYSxlLGMpe3JldHVybiB0aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluayhhLGUsYyl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93U3BsYXNoPWZ1bmN0aW9uKGEpe307RWRpdG9yVWkucHJvdG90eXBlLmdldExvY2FsRGF0YT1mdW5jdGlvbihhLGUpe2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oYSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2V0TG9jYWxEYXRhPWZ1bmN0aW9uKGEsZSxjKXtsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhLGUpO251bGwhPWMmJmMoKX07RWRpdG9yVWkucHJvdG90eXBlLnJlbW92ZUxvY2FsRGF0YT1mdW5jdGlvbihhLGUpe2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGEpOwplKCl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRNYXRoRW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5tYXRoRW5hYmxlZD1hO3RoaXMuZWRpdG9yLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO3RoaXMuZWRpdG9yLmdyYXBoLnJlZnJlc2goKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgibWF0aEVuYWJsZWRDaGFuZ2VkIikpfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNNYXRoRW5hYmxlZD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lZGl0b3IuZ3JhcGgubWF0aEVuYWJsZWR9O0VkaXRvclVpLnByb3RvdHlwZS5pc09mZmxpbmVBcHA9ZnVuY3Rpb24oKXtyZXR1cm4iMSI9PXVybFBhcmFtcy5vZmZsaW5lfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNPZmZsaW5lPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzT2ZmbGluZUFwcCgpfHwhbmF2aWdhdG9yLm9uTGluZXx8IWEmJiIxIj09dXJsUGFyYW1zLnN0ZWFsdGh9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVTcGlubmVyPQpmdW5jdGlvbihhLGUsYyl7Yz1udWxsIT1jP2M6MjQ7dmFyIGI9bmV3IFNwaW5uZXIoe2xpbmVzOjEyLGxlbmd0aDpjLHdpZHRoOk1hdGgucm91bmQoYy8zKSxyYWRpdXM6TWF0aC5yb3VuZChjLzIpLHJvdGF0ZTowLGNvbG9yOiJkYXJrIj09dWlUaGVtZT8iI2MwYzBjMCI6IiMwMDAiLHNwZWVkOjEuNSx0cmFpbDo2MCxzaGFkb3c6ITEsaHdhY2NlbDohMSx6SW5kZXg6MkU5fSksZD1iLnNwaW47Yi5zcGluPWZ1bmN0aW9uKGMsZil7dmFyIGc9ITE7dGhpcy5hY3RpdmV8fChkLmNhbGwodGhpcyxjKSx0aGlzLmFjdGl2ZT0hMCxudWxsIT1mJiYoZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxnLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsZy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLGcuc3R5bGUuYmFja2dyb3VuZD0iIzRCNDI0MyIsZy5zdHlsZS5jb2xvcj0id2hpdGUiLGcuc3R5bGUuZm9udEZhbWlseT0iSGVsdmV0aWNhLCBBcmlhbCIsZy5zdHlsZS5mb250U2l6ZT0KIjlwdCIsZy5zdHlsZS5wYWRkaW5nPSI2cHgiLGcuc3R5bGUucGFkZGluZ0xlZnQ9IjEwcHgiLGcuc3R5bGUucGFkZGluZ1JpZ2h0PSIxMHB4IixnLnN0eWxlLnpJbmRleD0yRTksZy5zdHlsZS5sZWZ0PU1hdGgubWF4KDAsYSkrInB4IixnLnN0eWxlLnRvcD1NYXRoLm1heCgwLGUrNzApKyJweCIsbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGcuc3R5bGUsImJvcmRlclJhZGl1cyIsIjZweCIpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShnLnN0eWxlLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoLTUwJSwtNTAlKSIpLCJkYXJrIiE9dWlUaGVtZSYmbXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGcuc3R5bGUsImJveFNoYWRvdyIsIjJweCAycHggM3B4IDBweCAjZGRkIiksIi4uLiIhPWYuc3Vic3RyaW5nKGYubGVuZ3RoLTMsZi5sZW5ndGgpJiYiISIhPWYuY2hhckF0KGYubGVuZ3RoLTEpJiYoZis9Ii4uLiIpLGcuaW5uZXJIVE1MPWYsYy5hcHBlbmRDaGlsZChnKSxiLnN0YXR1cz1nLG14Q2xpZW50LklTX1ZNTCYmCihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDg+PWRvY3VtZW50LmRvY3VtZW50TW9kZSkmJihnLnN0eWxlLmxlZnQ9TWF0aC5yb3VuZChNYXRoLm1heCgwLGEtZy5vZmZzZXRXaWR0aC8yKSkrInB4IixnLnN0eWxlLnRvcD1NYXRoLnJvdW5kKE1hdGgubWF4KDAsZSs3MC1nLm9mZnNldEhlaWdodC8yKSkrInB4IikpLHRoaXMucGF1c2U9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbigpe307dGhpcy5hY3RpdmUmJihhPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zcGluKGMsZil9KSk7dGhpcy5zdG9wKCk7cmV0dXJuIGF9KSxnPSEwKTtyZXR1cm4gZ307dmFyIGY9Yi5zdG9wO2Iuc3RvcD1mdW5jdGlvbigpe2YuY2FsbCh0aGlzKTt0aGlzLmFjdGl2ZT0hMTtudWxsIT1iLnN0YXR1cyYmbnVsbCE9Yi5zdGF0dXMucGFyZW50Tm9kZSYmYi5zdGF0dXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiLnN0YXR1cyk7Yi5zdGF0dXM9bnVsbH07CmIucGF1c2U9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oKXt9fTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLmlzQ29tcGF0aWJsZVN0cmluZz1mdW5jdGlvbihhKXt0cnl7dmFyIGI9bXhVdGlscy5wYXJzZVhtbChhKSxjPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGIuZG9jdW1lbnRFbGVtZW50LCEwKTtyZXR1cm4gbnVsbCE9YyYmMD09Yy5nZXRFbGVtZW50c0J5VGFnTmFtZSgicGFyc2VyZXJyb3IiKS5sZW5ndGh9Y2F0Y2gobil7fXJldHVybiExfTtFZGl0b3JVaS5wcm90b3R5cGUuaXNWaXNpb0RhdGE9ZnVuY3Rpb24oYSl7cmV0dXJuIDg8YS5sZW5ndGgmJigyMDg9PWEuY2hhckNvZGVBdCgwKSYmMjA3PT1hLmNoYXJDb2RlQXQoMSkmJjE3PT1hLmNoYXJDb2RlQXQoMikmJjIyND09YS5jaGFyQ29kZUF0KDMpJiYxNjE9PWEuY2hhckNvZGVBdCg0KSYmMTc3PT1hLmNoYXJDb2RlQXQoNSkmJjI2PT1hLmNoYXJDb2RlQXQoNikmJjIyNT09YS5jaGFyQ29kZUF0KDcpfHwKODA9PWEuY2hhckNvZGVBdCgwKSYmNzU9PWEuY2hhckNvZGVBdCgxKSYmMz09YS5jaGFyQ29kZUF0KDIpJiY0PT1hLmNoYXJDb2RlQXQoMyl8fDgwPT1hLmNoYXJDb2RlQXQoMCkmJjc1PT1hLmNoYXJDb2RlQXQoMSkmJjM9PWEuY2hhckNvZGVBdCgyKSYmNj09YS5jaGFyQ29kZUF0KDMpKX07RWRpdG9yVWkucHJvdG90eXBlLmlzUmVtb3RlVmlzaW9EYXRhPWZ1bmN0aW9uKGEpe3JldHVybiA4PGEubGVuZ3RoJiYoMjA4PT1hLmNoYXJDb2RlQXQoMCkmJjIwNz09YS5jaGFyQ29kZUF0KDEpJiYxNz09YS5jaGFyQ29kZUF0KDIpJiYyMjQ9PWEuY2hhckNvZGVBdCgzKSYmMTYxPT1hLmNoYXJDb2RlQXQoNCkmJjE3Nz09YS5jaGFyQ29kZUF0KDUpJiYyNj09YS5jaGFyQ29kZUF0KDYpJiYyMjU9PWEuY2hhckNvZGVBdCg3KXx8NjA9PWEuY2hhckNvZGVBdCgwKSYmNjM9PWEuY2hhckNvZGVBdCgxKSYmMTIwPT1hLmNoYXJDb2RlQXQoMikmJjEwOT09YS5jaGFyQ29kZUF0KDMpJiYxMDg9PWEuY2hhckNvZGVBdCgzKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaXNQbmdEYXRhPWZ1bmN0aW9uKGEpe3JldHVybiA4PGEubGVuZ3RoJiYxMzc9PWEuY2hhckNvZGVBdCgwKSYmODA9PWEuY2hhckNvZGVBdCgxKSYmNzg9PWEuY2hhckNvZGVBdCgyKSYmNzE9PWEuY2hhckNvZGVBdCgzKSYmMTM9PWEuY2hhckNvZGVBdCg0KSYmMTA9PWEuY2hhckNvZGVBdCg1KSYmMjY9PWEuY2hhckNvZGVBdCg2KSYmMTA9PWEuY2hhckNvZGVBdCg3KX07dmFyIGE9RWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUh0bWw7RWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbUh0bWw9ZnVuY3Rpb24oYil7dmFyIGU9YS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYobnVsbD09ZSl0cnl7dmFyIGM9Yi5pbmRleE9mKCImbHQ7bXhmaWxlICIpO2lmKDA8PWMpe3ZhciBkPWIubGFzdEluZGV4T2YoIiZsdDsvbXhmaWxlJmd0OyIpO2Q+YyYmKGU9Yi5zdWJzdHJpbmcoYyxkKzE1KS5yZXBsYWNlKC8mZ3Q7L2csCiI+IikucmVwbGFjZSgvJmx0Oy9nLCI8IikucmVwbGFjZSgvXFwmcXVvdDsvZywnIicpLnJlcGxhY2UoL1xuL2csIiIpKX1lbHNlIHZhciBmPW14VXRpbHMucGFyc2VYbWwoYikscD10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChmLmRvY3VtZW50RWxlbWVudCxudWxsIT10aGlzLnBhZ2VzfHwiaGlkZGVuIj09dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkpLGU9bnVsbCE9cD9teFV0aWxzLmdldFhtbChwKToiIn1jYXRjaCh2KXt9cmV0dXJuIGV9O0VkaXRvclVpLnByb3RvdHlwZS52YWxpZGF0ZUZpbGVEYXRhPWZ1bmN0aW9uKGEpe2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBiPWEuaW5kZXhPZignPG1ldGEgY2hhcnNldD0idXRmLTgiPicpOzA8PWImJihhPWEuc2xpY2UoMCxiKSsnPG1ldGEgY2hhcnNldD0idXRmLTgiLz4nK2Euc2xpY2UoYisyMy0xLGEubGVuZ3RoKSk7YT1HcmFwaC56YXBHcmVtbGlucyhhKX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLnJlcGxhY2VGaWxlRGF0YT0KZnVuY3Rpb24oYSl7YT10aGlzLnZhbGlkYXRlRmlsZURhdGEoYSk7YT1udWxsIT1hJiYwPGEubGVuZ3RoP214VXRpbHMucGFyc2VYbWwoYSkuZG9jdW1lbnRFbGVtZW50Om51bGw7dmFyIGI9bnVsbCE9YT90aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChhLCEwKTpudWxsO251bGwhPWImJihhPWIpO2lmKG51bGwhPWEpe2I9dGhpcy5lZGl0b3IuZ3JhcGg7Yi5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgYz1udWxsIT10aGlzLnBhZ2VzP3RoaXMucGFnZXMuc2xpY2UoKTpudWxsLGQ9YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpO2lmKCIwIiE9dXJsUGFyYW1zLnBhZ2VzfHwxPGQubGVuZ3RofHwxPT1kLmxlbmd0aCYmZFswXS5oYXNBdHRyaWJ1dGUoIm5hbWUiKSl7dGhpcy5maWxlTm9kZT1hO3RoaXMucGFnZXM9bnVsbCE9dGhpcy5wYWdlcz90aGlzLnBhZ2VzOltdO2Zvcih2YXIgZj1kLmxlbmd0aC0xOzA8PWY7Zi0tKXt2YXIgcD10aGlzLnVwZGF0ZVBhZ2VSb290KG5ldyBEaWFncmFtUGFnZShkW2ZdKSk7Cm51bGw9PXAuZ2V0TmFtZSgpJiZwLnNldE5hbWUobXhSZXNvdXJjZXMuZ2V0KCJwYWdlV2l0aE51bWJlciIsW2YrMV0pKTtiLm1vZGVsLmV4ZWN1dGUobmV3IENoYW5nZVBhZ2UodGhpcyxwLDA9PWY/cDpudWxsLDApKX19ZWxzZSIwIiE9dXJsUGFyYW1zLnBhZ2VzJiZudWxsPT10aGlzLmZpbGVOb2RlJiYodGhpcy5maWxlTm9kZT1hLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibXhmaWxlIiksdGhpcy5jdXJyZW50UGFnZT1uZXcgRGlhZ3JhbVBhZ2UoYS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpYWdyYW0iKSksdGhpcy5jdXJyZW50UGFnZS5zZXROYW1lKG14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFsxXSkpLGIubW9kZWwuZXhlY3V0ZShuZXcgQ2hhbmdlUGFnZSh0aGlzLHRoaXMuY3VycmVudFBhZ2UsdGhpcy5jdXJyZW50UGFnZSwwKSkpLHRoaXMuZWRpdG9yLnNldEdyYXBoWG1sKGEpLG51bGwhPXRoaXMuY3VycmVudFBhZ2UmJih0aGlzLmN1cnJlbnRQYWdlLnJvb3Q9CnRoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLnJvb3QpO2lmKG51bGwhPWMpZm9yKGY9MDtmPGMubGVuZ3RoO2YrKyliLm1vZGVsLmV4ZWN1dGUobmV3IENoYW5nZVBhZ2UodGhpcyxjW2ZdLG51bGwpKX1maW5hbGx5e2IubW9kZWwuZW5kVXBkYXRlKCl9fX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUZpbGVEYXRhPWZ1bmN0aW9uKGEsZSxjLGQsZixwLGssdCxtLHgscSl7ZT1udWxsIT1lP2U6dGhpcy5lZGl0b3IuZ3JhcGg7Zj1udWxsIT1mP2Y6ITE7bT1udWxsIT1tP206ITA7dmFyIGIsZz1udWxsO251bGw9PWN8fGMuZ2V0TW9kZSgpPT1BcHAuTU9ERV9ERVZJQ0V8fGMuZ2V0TW9kZSgpPT1BcHAuTU9ERV9CUk9XU0VSP2I9Il9ibGFuayI6Zz1iPWQ7aWYobnVsbD09YSlyZXR1cm4iIjt2YXIgbD1hO2lmKCJteGZpbGUiIT1sLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpe2lmKHEpe3ZhciBuPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaWFncmFtIik7bi5zZXRBdHRyaWJ1dGUoImlkIiwKRWRpdG9yLmd1aWQoKSk7bi5hcHBlbmRDaGlsZChhKX1lbHNle249R3JhcGguemFwR3JlbWxpbnMobXhVdGlscy5nZXRYbWwoYSkpO2w9R3JhcGguY29tcHJlc3Mobik7aWYoR3JhcGguZGVjb21wcmVzcyhsKSE9bilyZXR1cm4gbjtuPWEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaWFncmFtIik7bi5zZXRBdHRyaWJ1dGUoImlkIixFZGl0b3IuZ3VpZCgpKTtteFV0aWxzLnNldFRleHRDb250ZW50KG4sbCl9bD1hLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibXhmaWxlIik7bC5hcHBlbmRDaGlsZChuKX14PyhsPWwuY2xvbmVOb2RlKCEwKSxsLnJlbW92ZUF0dHJpYnV0ZSgibW9kaWZpZWQiKSxsLnJlbW92ZUF0dHJpYnV0ZSgiaG9zdCIpLGwucmVtb3ZlQXR0cmlidXRlKCJhZ2VudCIpLGwucmVtb3ZlQXR0cmlidXRlKCJldGFnIiksbC5yZW1vdmVBdHRyaWJ1dGUoInVzZXJBZ2VudCIpLGwucmVtb3ZlQXR0cmlidXRlKCJ2ZXJzaW9uIiksbC5yZW1vdmVBdHRyaWJ1dGUoImVkaXRvciIpLApsLnJlbW92ZUF0dHJpYnV0ZSgidHlwZSIpKToobC5yZW1vdmVBdHRyaWJ1dGUoInVzZXJBZ2VudCIpLGwucmVtb3ZlQXR0cmlidXRlKCJ2ZXJzaW9uIiksbC5yZW1vdmVBdHRyaWJ1dGUoImVkaXRvciIpLGwucmVtb3ZlQXR0cmlidXRlKCJwYWdlcyIpLGwucmVtb3ZlQXR0cmlidXRlKCJ0eXBlIiksbXhDbGllbnQuSVNfQ0hST01FQVBQP2wuc2V0QXR0cmlidXRlKCJob3N0IiwiQ2hyb21lIik6RWRpdG9yVWkuaXNFbGVjdHJvbkFwcD9sLnNldEF0dHJpYnV0ZSgiaG9zdCIsIkVsZWN0cm9uIik6bC5zZXRBdHRyaWJ1dGUoImhvc3QiLHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSksbC5zZXRBdHRyaWJ1dGUoIm1vZGlmaWVkIiwobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkpLGwuc2V0QXR0cmlidXRlKCJhZ2VudCIsbmF2aWdhdG9yLmFwcFZlcnNpb24pLGwuc2V0QXR0cmlidXRlKCJ2ZXJzaW9uIixFZGl0b3JVaS5WRVJTSU9OKSxsLnNldEF0dHJpYnV0ZSgiZXRhZyIsRWRpdG9yLmd1aWQoKSksCmE9bnVsbCE9Yz9jLmdldE1vZGUoKTp0aGlzLm1vZGUsbnVsbCE9YSYmbC5zZXRBdHRyaWJ1dGUoInR5cGUiLGEpLDE8bC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpLmxlbmd0aCYmbnVsbCE9dGhpcy5wYWdlcyYmbC5zZXRBdHRyaWJ1dGUoInBhZ2VzIix0aGlzLnBhZ2VzLmxlbmd0aCkpO3E9cT9teFV0aWxzLmdldFByZXR0eVhtbChsKTpteFV0aWxzLmdldFhtbChsKTtpZighcCYmIWYmJihrfHxudWxsIT1jJiYvKFwuaHRtbCkkL2kudGVzdChjLmdldFRpdGxlKCkpKSlxPXRoaXMuZ2V0SHRtbDIobXhVdGlscy5nZXRYbWwobCksZSxudWxsIT1jP2MuZ2V0VGl0bGUoKTpudWxsLGIsZyk7ZWxzZSBpZihwfHwhZiYmbnVsbCE9YyYmLyhcLnN2ZykkL2kudGVzdChjLmdldFRpdGxlKCkpKW51bGw9PWN8fGMuZ2V0TW9kZSgpIT1BcHAuTU9ERV9ERVZJQ0UmJmMuZ2V0TW9kZSgpIT1BcHAuTU9ERV9CUk9XU0VSfHwoZD1udWxsKSxxPXRoaXMuZ2V0RW1iZWRkZWRTdmcocSxlLApkLG51bGwsdCxtLGcpO3JldHVybiBxfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0WG1sRmlsZURhdGE9ZnVuY3Rpb24oYSxlLGMpe2E9bnVsbCE9YT9hOiEwO2U9bnVsbCE9ZT9lOiExO2M9bnVsbCE9Yz9jOiFFZGl0b3IuY29tcHJlc3NYbWw7dmFyIGI9dGhpcy5lZGl0b3IuZ2V0R3JhcGhYbWwoYSk7aWYoYSYmbnVsbCE9dGhpcy5maWxlTm9kZSYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZSlpZihhPWZ1bmN0aW9uKGEpe3ZhciBlPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm14R3JhcGhNb2RlbCIpLGU9MDxlLmxlbmd0aD9lWzBdOm51bGw7bnVsbD09ZSYmYz8oZT1teFV0aWxzLnRyaW0obXhVdGlscy5nZXRUZXh0Q29udGVudChhKSksYT1hLmNsb25lTm9kZSghMSksMDxlLmxlbmd0aCYmKGU9R3JhcGguZGVjb21wcmVzcyhlKSxudWxsIT1lJiYwPGUubGVuZ3RoJiZhLmFwcGVuZENoaWxkKG14VXRpbHMucGFyc2VYbWwoZSkuZG9jdW1lbnRFbGVtZW50KSkpOm51bGw9PWV8fGM/YT1hLmNsb25lTm9kZSghMCk6CihhPWEuY2xvbmVOb2RlKCExKSxteFV0aWxzLnNldFRleHRDb250ZW50KGEsR3JhcGguY29tcHJlc3NOb2RlKGUpKSk7Yi5hcHBlbmRDaGlsZChhKX0sRWRpdG9yVWkucmVtb3ZlQ2hpbGROb2Rlcyh0aGlzLmN1cnJlbnRQYWdlLm5vZGUpLG14VXRpbHMuc2V0VGV4dENvbnRlbnQodGhpcy5jdXJyZW50UGFnZS5ub2RlLEdyYXBoLmNvbXByZXNzTm9kZShiKSksYj10aGlzLmZpbGVOb2RlLmNsb25lTm9kZSghMSksZSlhKHRoaXMuY3VycmVudFBhZ2Uubm9kZSk7ZWxzZSBmb3IoZT0wO2U8dGhpcy5wYWdlcy5sZW5ndGg7ZSsrKXtpZih0aGlzLmN1cnJlbnRQYWdlIT10aGlzLnBhZ2VzW2VdJiZ0aGlzLnBhZ2VzW2VdLm5lZWRzVXBkYXRlKXt2YXIgZD0obmV3IG14Q29kZWMobXhVdGlscy5jcmVhdGVYbWxEb2N1bWVudCgpKSkuZW5jb2RlKG5ldyBteEdyYXBoTW9kZWwodGhpcy5wYWdlc1tlXS5yb290KSk7dGhpcy5lZGl0b3IuZ3JhcGguc2F2ZVZpZXdTdGF0ZSh0aGlzLnBhZ2VzW2VdLnZpZXdTdGF0ZSwKZCk7RWRpdG9yVWkucmVtb3ZlQ2hpbGROb2Rlcyh0aGlzLnBhZ2VzW2VdLm5vZGUpO214VXRpbHMuc2V0VGV4dENvbnRlbnQodGhpcy5wYWdlc1tlXS5ub2RlLEdyYXBoLmNvbXByZXNzTm9kZShkKSk7ZGVsZXRlIHRoaXMucGFnZXNbZV0ubmVlZHNVcGRhdGV9YSh0aGlzLnBhZ2VzW2VdLm5vZGUpfXJldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuYW5vbnltaXplU3RyaW5nPWZ1bmN0aW9uKGEsZSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGFyQXQoYyk7MDw9RWRpdG9yVWkuaWdub3JlZEFub255bWl6ZWRDaGFycy5pbmRleE9mKGQpP2IucHVzaChkKTppc05hTihwYXJzZUludChkKSk/ZC50b0xvd2VyQ2FzZSgpIT1kP2IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDY1K01hdGgucm91bmQoMjUqTWF0aC5yYW5kb20oKSkpKTpkLnRvVXBwZXJDYXNlKCkhPWQ/Yi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoOTcrTWF0aC5yb3VuZCgyNSpNYXRoLnJhbmRvbSgpKSkpOgovXHMvLnRlc3QoZCk/Yi5wdXNoKCIgIik6Yi5wdXNoKCI/Iik6Yi5wdXNoKGU/IjAiOk1hdGgucm91bmQoOSpNYXRoLnJhbmRvbSgpKSl9cmV0dXJuIGIuam9pbigiIil9O0VkaXRvclVpLnByb3RvdHlwZS5hbm9ueW1pemVQYXRjaD1mdW5jdGlvbihhKXtpZihudWxsIT1hW0VkaXRvclVpLkRJRkZfSU5TRVJUXSlmb3IodmFyIGI9MDtiPGFbRWRpdG9yVWkuRElGRl9JTlNFUlRdLmxlbmd0aDtiKyspdHJ5e3ZhciBjPW14VXRpbHMucGFyc2VYbWwoYVtFZGl0b3JVaS5ESUZGX0lOU0VSVF1bYl0uZGF0YSkuZG9jdW1lbnRFbGVtZW50LmNsb25lTm9kZSghMSk7bnVsbCE9Yy5nZXRBdHRyaWJ1dGUoIm5hbWUiKSYmYy5zZXRBdHRyaWJ1dGUoIm5hbWUiLHRoaXMuYW5vbnltaXplU3RyaW5nKGMuZ2V0QXR0cmlidXRlKCJuYW1lIikpKTthW0VkaXRvclVpLkRJRkZfSU5TRVJUXVtiXS5kYXRhPW14VXRpbHMuZ2V0WG1sKGMpfWNhdGNoKHApe2FbRWRpdG9yVWkuRElGRl9JTlNFUlRdW2JdLmRhdGE9CnAubWVzc2FnZX1pZihudWxsIT1hW0VkaXRvclVpLkRJRkZfVVBEQVRFXSl7Zm9yKHZhciBkIGluIGFbRWRpdG9yVWkuRElGRl9VUERBVEVdKXt2YXIgZj1hW0VkaXRvclVpLkRJRkZfVVBEQVRFXVtkXTtudWxsIT1mLm5hbWUmJihmLm5hbWU9dGhpcy5hbm9ueW1pemVTdHJpbmcoZi5uYW1lKSk7bnVsbCE9Zi5jZWxscyYmKGI9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9Zi5jZWxsc1thXTtpZihudWxsIT1iKXtmb3IodmFyIGUgaW4gYiludWxsIT1iW2VdLnZhbHVlJiYoYltlXS52YWx1ZT0iWyIrYltlXS52YWx1ZS5sZW5ndGgrIl0iKSxudWxsIT1iW2VdLnhtbFZhbHVlJiYoYltlXS54bWxWYWx1ZT0iWyIrYltlXS54bWxWYWx1ZS5sZW5ndGgrIl0iKSxudWxsIT1iW2VdLnN0eWxlJiYoYltlXS5zdHlsZT0iWyIrYltlXS5zdHlsZS5sZW5ndGgrIl0iKSwwPT1PYmplY3Qua2V5cyhiW2VdKS5sZW5ndGgmJmRlbGV0ZSBiW2VdOzA9PU9iamVjdC5rZXlzKGIpLmxlbmd0aCYmCmRlbGV0ZSBmLmNlbGxzW2FdfX0pLGIoRWRpdG9yVWkuRElGRl9JTlNFUlQpLGIoRWRpdG9yVWkuRElGRl9VUERBVEUpLDA9PU9iamVjdC5rZXlzKGYuY2VsbHMpLmxlbmd0aCYmZGVsZXRlIGYuY2VsbHMpOzA9PU9iamVjdC5rZXlzKGYpLmxlbmd0aCYmZGVsZXRlIGFbRWRpdG9yVWkuRElGRl9VUERBVEVdW2RdfTA9PU9iamVjdC5rZXlzKGFbRWRpdG9yVWkuRElGRl9VUERBVEVdKS5sZW5ndGgmJmRlbGV0ZSBhW0VkaXRvclVpLkRJRkZfVVBEQVRFXX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmFub255bWl6ZUF0dHJpYnV0ZXM9ZnVuY3Rpb24oYSxlKXtpZihudWxsIT1hLmF0dHJpYnV0ZXMpZm9yKHZhciBiPTA7YjxhLmF0dHJpYnV0ZXMubGVuZ3RoO2IrKykiYXMiIT1hLmF0dHJpYnV0ZXNbYl0ubmFtZSYmYS5zZXRBdHRyaWJ1dGUoYS5hdHRyaWJ1dGVzW2JdLm5hbWUsdGhpcy5hbm9ueW1pemVTdHJpbmcoYS5hdHRyaWJ1dGVzW2JdLnZhbHVlLGUpKTtpZihudWxsIT1hLmNoaWxkTm9kZXMpZm9yKGI9CjA7YjxhLmNoaWxkTm9kZXMubGVuZ3RoO2IrKyl0aGlzLmFub255bWl6ZUF0dHJpYnV0ZXMoYS5jaGlsZE5vZGVzW2JdLGUpfTtFZGl0b3JVaS5wcm90b3R5cGUuYW5vbnltaXplTm9kZT1mdW5jdGlvbihhLGUpe2Zvcih2YXIgYj1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJteENlbGwiKSxjPTA7YzxiLmxlbmd0aDtjKyspbnVsbCE9YltjXS5nZXRBdHRyaWJ1dGUoInZhbHVlIikmJmJbY10uc2V0QXR0cmlidXRlKCJ2YWx1ZSIsIlsiK2JbY10uZ2V0QXR0cmlidXRlKCJ2YWx1ZSIpLmxlbmd0aCsiXSIpLG51bGwhPWJbY10uZ2V0QXR0cmlidXRlKCJ4bWxWYWx1ZSIpJiZiW2NdLnNldEF0dHJpYnV0ZSgieG1sVmFsdWUiLCJbIitiW2NdLmdldEF0dHJpYnV0ZSgieG1sVmFsdWUiKS5sZW5ndGgrIl0iKSxudWxsIT1iW2NdLmdldEF0dHJpYnV0ZSgic3R5bGUiKSYmYltjXS5zZXRBdHRyaWJ1dGUoInN0eWxlIiwiWyIrYltjXS5nZXRBdHRyaWJ1dGUoInN0eWxlIikubGVuZ3RoKyJdIiksbnVsbCE9CmJbY10ucGFyZW50Tm9kZSYmInJvb3QiIT1iW2NdLnBhcmVudE5vZGUubm9kZU5hbWUmJm51bGwhPWJbY10ucGFyZW50Tm9kZS5wYXJlbnROb2RlJiYoYltjXS5zZXRBdHRyaWJ1dGUoImlkIixiW2NdLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJpZCIpKSxiW2NdLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYltjXSxiW2NdLnBhcmVudE5vZGUpKTtyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLnN5bmNocm9uaXplQ3VycmVudEZpbGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWImJihiLnNhdmluZ0ZpbGU/dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImJ1c3kiKX0pOiFhJiZiLmludmFsaWRDaGVja3N1bT9iLmhhbmRsZUZpbGVFcnJvcihudWxsLCEwKTp0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgidXBkYXRpbmdEb2N1bWVudCIpKSYmKGIuY2xlYXJBdXRvc2F2ZSgpLAp0aGlzLmVkaXRvci5zZXRTdGF0dXMoIiIpLGE/Yi5yZWxvYWRGaWxlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yi5oYW5kbGVGaWxlU3VjY2VzcygibWFudWFsIj09RHJhd2lvRmlsZS5TWU5DKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2IuaGFuZGxlRmlsZUVycm9yKGEsITApfSkpOmIuc3luY2hyb25pemVGaWxlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yi5oYW5kbGVGaWxlU3VjY2VzcygibWFudWFsIj09RHJhd2lvRmlsZS5TWU5DKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2IuaGFuZGxlRmlsZUVycm9yKGEsITApfSkpKSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRGaWxlRGF0YT1mdW5jdGlvbihhLGUsYyxkLGYscCxrLHQsbSx4KXtmPW51bGwhPWY/ZjohMDtwPW51bGwhPXA/cDohMTt2YXIgYj10aGlzLmVkaXRvci5ncmFwaDtpZihlfHwhYSYmbnVsbCE9bSYmLyhcLnN2ZykkL2kudGVzdChtLmdldFRpdGxlKCkpKWlmKHg9CiExLG51bGwhPXRoaXMucGFnZXMmJnRoaXMuY3VycmVudFBhZ2UhPXRoaXMucGFnZXNbMF0pe3ZhciBnPWIuZ2V0R2xvYmFsVmFyaWFibGUsYj10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKGIuZ2V0U3R5bGVzaGVldCgpKSxsPXRoaXMucGFnZXNbMF07Yi5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4icGFnZSI9PWE/bC5nZXROYW1lKCk6InBhZ2VudW1iZXIiPT1hPzE6Zy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5jb250YWluZXIpO2IubW9kZWwuc2V0Um9vdChsLnJvb3QpfWs9bnVsbCE9az9rOnRoaXMuZ2V0WG1sRmlsZURhdGEoZixwLHgpO209bnVsbCE9bT9tOnRoaXMuZ2V0Q3VycmVudEZpbGUoKTthPXRoaXMuY3JlYXRlRmlsZURhdGEoayxiLG0sd2luZG93LmxvY2F0aW9uLmhyZWYsYSxlLGMsZCxmLHQseCk7YiE9dGhpcy5lZGl0b3IuZ3JhcGgmJmIuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYi5jb250YWluZXIpOwpyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmdldEh0bWw9ZnVuY3Rpb24oYSxlLGMsZCxmLHApe3A9bnVsbCE9cD9wOiEwO3ZhciBiPW51bGwsZz1FZGl0b3JVaS5kcmF3SG9zdCsiL2pzL2VtYmVkLXN0YXRpYy5taW4uanMiO2lmKG51bGwhPWUpe3ZhciBiPXA/ZS5nZXRHcmFwaEJvdW5kcygpOmUuZ2V0Qm91bmRpbmdCb3goZS5nZXRTZWxlY3Rpb25DZWxscygpKSxsPWUudmlldy5zY2FsZTtwPU1hdGguZmxvb3IoYi54L2wtZS52aWV3LnRyYW5zbGF0ZS54KTtsPU1hdGguZmxvb3IoYi55L2wtZS52aWV3LnRyYW5zbGF0ZS55KTtiPWUuYmFja2dyb3VuZDtudWxsPT1mJiYoZT10aGlzLmdldEJhc2VuYW1lcygpLmpvaW4oIjsiKSwwPGUubGVuZ3RoJiYoZz1FZGl0b3JVaS5kcmF3SG9zdCsiL2VtYmVkLmpzP3M9IitlKSk7YS5zZXRBdHRyaWJ1dGUoIngwIixwKTthLnNldEF0dHJpYnV0ZSgieTAiLGwpfW51bGwhPWEmJihhLnNldEF0dHJpYnV0ZSgicGFuIiwiMSIpLGEuc2V0QXR0cmlidXRlKCJ6b29tIiwKIjEiKSxhLnNldEF0dHJpYnV0ZSgicmVzaXplIiwiMCIpLGEuc2V0QXR0cmlidXRlKCJmaXQiLCIwIiksYS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjIwIiksYS5zZXRBdHRyaWJ1dGUoImxpbmtzIiwiMSIpLG51bGwhPWQmJmEuc2V0QXR0cmlidXRlKCJlZGl0IixkKSk7bnVsbCE9ZiYmKGY9Zi5yZXBsYWNlKC8mL2csIiZhbXA7IikpO2E9bnVsbCE9YT9HcmFwaC56YXBHcmVtbGlucyhteFV0aWxzLmdldFhtbChhKSk6IiI7ZD1HcmFwaC5jb21wcmVzcyhhKTtHcmFwaC5kZWNvbXByZXNzKGQpIT1hJiYoZD1lbmNvZGVVUklDb21wb25lbnQoYSkpO3JldHVybihudWxsPT1mPydceDNjIS0tW2lmIElFXT48bWV0YSBodHRwLWVxdWl2PSJYLVVBLUNvbXBhdGlibGUiIGNvbnRlbnQ9IklFPTUsSUU9OSIgPjwhW2VuZGlmXS0tXHgzZVxuJzoiIikrIjwhRE9DVFlQRSBodG1sPlxuPGh0bWwiKyhudWxsIT1mPycgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPic6Ij4iKSsiXG48aGVhZD5cbiIrCihudWxsPT1mP251bGwhPWM/Ijx0aXRsZT4iK214VXRpbHMuaHRtbEVudGl0aWVzKGMpKyI8L3RpdGxlPlxuIjoiIjoiPHRpdGxlPmRpYWdyYW1zLm5ldDwvdGl0bGU+XG4iKSsobnVsbCE9Zj8nPG1ldGEgaHR0cC1lcXVpdj0icmVmcmVzaCIgY29udGVudD0iMDtVUkw9XCcnK2YrIidcIi8+XG4iOiIiKSsiPC9oZWFkPlxuPGJvZHkiKyhudWxsPT1mJiZudWxsIT1iJiZiIT1teENvbnN0YW50cy5OT05FPycgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6JytiKyc7Ij4nOiI+IikrJ1xuPGRpdiBjbGFzcz0ibXhncmFwaCIgc3R5bGU9InBvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmF1dG87d2lkdGg6MTAwJTsiPlxuPGRpdiBzdHlsZT0id2lkdGg6MXB4O2hlaWdodDoxcHg7b3ZlcmZsb3c6aGlkZGVuOyI+JytkKyI8L2Rpdj5cbjwvZGl2PlxuIisobnVsbD09Zj8nPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iJytnKyciPlx4M2Mvc2NyaXB0Pic6JzxhIHN0eWxlPSJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlO21hcmdpbi10b3A6LTEyOHB4O21hcmdpbi1sZWZ0Oi02NHB4OyIgaHJlZj0iJysKZisnIiB0YXJnZXQ9Il9ibGFuayI+PGltZyBib3JkZXI9IjAiIHNyYz0iJytFZGl0b3JVaS5kcmF3SG9zdCsnL2ltYWdlcy9kcmF3bG9nbzEyOC5wbmciLz48L2E+JykrIlxuPC9ib2R5PlxuPC9odG1sPlxuIn07RWRpdG9yVWkucHJvdG90eXBlLmdldEh0bWwyPWZ1bmN0aW9uKGEsZSxjLGQsZil7ZT13aW5kb3cuRFJBV0lPX1ZJRVdFUl9VUkx8fEVkaXRvclVpLmRyYXdIb3N0KyIvanMvdmlld2VyLm1pbi5qcyI7bnVsbCE9ZiYmKGY9Zi5yZXBsYWNlKC8mL2csIiZhbXA7IikpO2E9e2hpZ2hsaWdodDoiIzAwMDBmZiIsbmF2OnRoaXMuZWRpdG9yLmdyYXBoLmZvbGRpbmdFbmFibGVkLHJlc2l6ZTohMCx4bWw6R3JhcGguemFwR3JlbWxpbnMoYSksdG9vbGJhcjoicGFnZXMgem9vbSBsYXllcnMgbGlnaHRib3gifTtudWxsIT10aGlzLnBhZ2VzJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlJiYoYS5wYWdlPW14VXRpbHMuaW5kZXhPZih0aGlzLnBhZ2VzLHRoaXMuY3VycmVudFBhZ2UpKTtyZXR1cm4obnVsbD09CmY/J1x4M2MhLS1baWYgSUVdPjxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9NSxJRT05IiA+PCFbZW5kaWZdLS1ceDNlXG4nOiIiKSsiPCFET0NUWVBFIGh0bWw+XG48aHRtbCIrKG51bGwhPWY/JyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+JzoiPiIpKyJcbjxoZWFkPlxuIisobnVsbD09Zj9udWxsIT1jPyI8dGl0bGU+IitteFV0aWxzLmh0bWxFbnRpdGllcyhjKSsiPC90aXRsZT5cbiI6IiI6Ijx0aXRsZT5kaWFncmFtcy5uZXQ8L3RpdGxlPlxuIikrKG51bGwhPWY/JzxtZXRhIGh0dHAtZXF1aXY9InJlZnJlc2giIGNvbnRlbnQ9IjA7VVJMPVwnJytmKyInXCIvPlxuIjoiIikrJzxtZXRhIGNoYXJzZXQ9InV0Zi04Ii8+XG48L2hlYWQ+XG48Ym9keT5cbjxkaXYgY2xhc3M9Im14Z3JhcGgiIHN0eWxlPSJtYXgtd2lkdGg6MTAwJTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50OyIgZGF0YS1teGdyYXBoPSInK214VXRpbHMuaHRtbEVudGl0aWVzKEpTT04uc3RyaW5naWZ5KGEpKSsKJyI+PC9kaXY+XG4nKyhudWxsPT1mPyc8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCIgc3JjPSInK2UrJyI+XHgzYy9zY3JpcHQ+JzonPGEgc3R5bGU9InBvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7bWFyZ2luLXRvcDotMTI4cHg7bWFyZ2luLWxlZnQ6LTY0cHg7IiBocmVmPSInK2YrJyIgdGFyZ2V0PSJfYmxhbmsiPjxpbWcgYm9yZGVyPSIwIiBzcmM9IicrRWRpdG9yVWkuZHJhd0hvc3QrJy9pbWFnZXMvZHJhd2xvZ28xMjgucG5nIi8+PC9hPicpKyJcbjwvYm9keT5cbjwvaHRtbD5cbiJ9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRGaWxlRGF0YT1mdW5jdGlvbihhKXthPXRoaXMudmFsaWRhdGVGaWxlRGF0YShhKTt0aGlzLnBhZ2VzPXRoaXMuZmlsZU5vZGU9dGhpcy5jdXJyZW50UGFnZT1udWxsO2E9bnVsbCE9YSYmMDxhLmxlbmd0aD9teFV0aWxzLnBhcnNlWG1sKGEpLmRvY3VtZW50RWxlbWVudDpudWxsO3ZhciBiPUVkaXRvci5leHRyYWN0UGFyc2VyRXJyb3IoYSwKbXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpKTtpZihiKXRocm93IEVycm9yKG14UmVzb3VyY2VzLmdldCgibm90QURpYWdyYW1GaWxlIikrIiAoIitiKyIpIik7Yj1udWxsIT1hP3RoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGEsITApOm51bGw7bnVsbCE9YiYmKGE9Yik7aWYobnVsbCE9YSYmIm14ZmlsZSI9PWEubm9kZU5hbWUmJihiPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpYWdyYW0iKSwiMCIhPXVybFBhcmFtcy5wYWdlc3x8MTxiLmxlbmd0aHx8MT09Yi5sZW5ndGgmJmJbMF0uaGFzQXR0cmlidXRlKCJuYW1lIikpKXt2YXIgYz1udWxsO3RoaXMuZmlsZU5vZGU9YTt0aGlzLnBhZ2VzPVtdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKW51bGw9PWJbZF0uZ2V0QXR0cmlidXRlKCJpZCIpJiZiW2RdLnNldEF0dHJpYnV0ZSgiaWQiLGQpLGE9bmV3IERpYWdyYW1QYWdlKGJbZF0pLG51bGw9PWEuZ2V0TmFtZSgpJiZhLnNldE5hbWUobXhSZXNvdXJjZXMuZ2V0KCJwYWdlV2l0aE51bWJlciIsCltkKzFdKSksdGhpcy5wYWdlcy5wdXNoKGEpLG51bGwhPXVybFBhcmFtc1sicGFnZS1pZCJdJiZhLmdldElkKCk9PXVybFBhcmFtc1sicGFnZS1pZCJdJiYoYz1hKTt0aGlzLmN1cnJlbnRQYWdlPW51bGwhPWM/Yzp0aGlzLnBhZ2VzW01hdGgubWF4KDAsTWF0aC5taW4odGhpcy5wYWdlcy5sZW5ndGgtMSx1cmxQYXJhbXMucGFnZXx8MCkpXTthPXRoaXMuY3VycmVudFBhZ2Uubm9kZX0iMCIhPXVybFBhcmFtcy5wYWdlcyYmbnVsbD09dGhpcy5maWxlTm9kZSYmbnVsbCE9YSYmKHRoaXMuZmlsZU5vZGU9YS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm14ZmlsZSIpLHRoaXMuY3VycmVudFBhZ2U9bmV3IERpYWdyYW1QYWdlKGEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaWFncmFtIikpLHRoaXMuY3VycmVudFBhZ2Uuc2V0TmFtZShteFJlc291cmNlcy5nZXQoInBhZ2VXaXRoTnVtYmVyIixbMV0pKSx0aGlzLnBhZ2VzPVt0aGlzLmN1cnJlbnRQYWdlXSk7dGhpcy5lZGl0b3Iuc2V0R3JhcGhYbWwoYSk7Cm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJih0aGlzLmN1cnJlbnRQYWdlLnJvb3Q9dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwucm9vdCk7aWYobnVsbCE9dXJsUGFyYW1zWyJsYXllci1pZHMiXSl0cnl7dmFyIGY9dXJsUGFyYW1zWyJsYXllci1pZHMiXS5zcGxpdCgiICIpO2E9e307Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhW2ZbZF1dPSEwO2Zvcih2YXIgcD10aGlzLmVkaXRvci5ncmFwaC5nZXRNb2RlbCgpLGs9cC5nZXRDaGlsZHJlbihwLnJvb3QpLGQ9MDtkPGsubGVuZ3RoO2QrKyl7dmFyIHQ9a1tkXTtwLnNldFZpc2libGUodCxhW3QuaWRdfHwhMSl9fWNhdGNoKHkpe319O0VkaXRvclVpLnByb3RvdHlwZS5nZXRCYXNlRmlsZW5hbWU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGI9bnVsbCE9YiYmbnVsbCE9Yi5nZXRUaXRsZSgpP2IuZ2V0VGl0bGUoKTp0aGlzLmRlZmF1bHRGaWxlbmFtZTtpZigvKFwueG1sKSQvaS50ZXN0KGIpfHwvKFwuaHRtbCkkL2kudGVzdChiKXx8Ci8oXC5zdmcpJC9pLnRlc3QoYil8fC8oXC5wbmcpJC9pLnRlc3QoYil8fC8oXC5kcmF3aW8pJC9pLnRlc3QoYikpYj1iLnN1YnN0cmluZygwLGIubGFzdEluZGV4T2YoIi4iKSk7IWEmJm51bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGgmJm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJm51bGwhPXRoaXMuY3VycmVudFBhZ2Uubm9kZS5nZXRBdHRyaWJ1dGUoIm5hbWUiKSYmMDx0aGlzLmN1cnJlbnRQYWdlLmdldE5hbWUoKS5sZW5ndGgmJihiPWIrIi0iK3RoaXMuY3VycmVudFBhZ2UuZ2V0TmFtZSgpKTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLmRvd25sb2FkRmlsZT1mdW5jdGlvbihhLGUsYyxkLGYscCxrLHQsbSx4LHEpe3RyeXtkPW51bGwhPWQ/ZDp0aGlzLmVkaXRvci5ncmFwaC5pc1NlbGVjdGlvbkVtcHR5KCk7dmFyIGI9dGhpcy5nZXRCYXNlRmlsZW5hbWUoIWYpLGc9YisiLiIrYTtpZigieG1sIj09YSl7dmFyIGw9Jzw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04Ij8+XG4nKwp0aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLGQsZixudWxsLG51bGwsbnVsbCxlKTt0aGlzLnNhdmVEYXRhKGcsYSxsLCJ0ZXh0L3htbCIpfWVsc2UgaWYoImh0bWwiPT1hKWw9dGhpcy5nZXRIdG1sMih0aGlzLmdldEZpbGVEYXRhKCEwKSx0aGlzLmVkaXRvci5ncmFwaCxiKSx0aGlzLnNhdmVEYXRhKGcsYSxsLCJ0ZXh0L2h0bWwiKTtlbHNlIGlmKCJzdmciIT1hJiYieG1sc3ZnIiE9YXx8IXRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJleHBvcnQiKSkpInhtbHBuZyI9PWE/Zz1iKyIucG5nIjoianBlZyI9PWEmJihnPWIrIi5qcGciKSx0aGlzLnNhdmVSZXF1ZXN0KGcsYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGUpe3RyeXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaC5wYWdlVmlzaWJsZTtudWxsIT1wJiYodGhpcy5lZGl0b3IuZ3JhcGgucGFnZVZpc2libGU9cCk7dmFyIGc9dGhpcy5jcmVhdGVEb3dubG9hZFJlcXVlc3QoYiwKYSxkLGUsayxmLHQsbSx4LHEpO3RoaXMuZWRpdG9yLmdyYXBoLnBhZ2VWaXNpYmxlPWM7cmV0dXJuIGd9Y2F0Y2goTSl7dGhpcy5oYW5kbGVFcnJvcihNKX19KSk7ZWxzZXt2YXIgbj1udWxsLHk9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YS5sZW5ndGg8PU1BWF9SRVFVRVNUX1NJWkU/dGhpcy5zYXZlRGF0YShnLCJzdmciLGEsImltYWdlL3N2Zyt4bWwiKTp0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZHJhd2luZ1Rvb0xhcmdlIil9LG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMucG9wdXAobil9KSl9KTtpZigic3ZnIj09YSl7dmFyIHY9dGhpcy5lZGl0b3IuZ3JhcGguYmFja2dyb3VuZDtpZihrfHx2PT1teENvbnN0YW50cy5OT05FKXY9bnVsbDt2YXIgQz10aGlzLmVkaXRvci5ncmFwaC5nZXRTdmcodixudWxsLG51bGwsbnVsbCxudWxsLGQpO2MmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZFN2Z1NoYWRvdyhDKTsKdGhpcy5lZGl0b3IuY29udmVydEltYWdlcyhDLG14VXRpbHMuYmluZCh0aGlzLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7eSgnPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz5cbjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+XG4nK214VXRpbHMuZ2V0WG1sKGEpKX0pKSl9ZWxzZSBnPWIrIi5zdmciLG49dGhpcy5nZXRGaWxlRGF0YSghMSwhMCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7eShhKX0pLGQpfX1jYXRjaChKKXt0aGlzLmhhbmRsZUVycm9yKEopfX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZURvd25sb2FkUmVxdWVzdD1mdW5jdGlvbihhLGUsYyxkLGYscCxrLHQsbSx4KXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaCxnPWIuZ2V0R3JhcGhCb3VuZHMoKTsKYz10aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLGMsMD09cD8hMToieG1scG5nIiE9ZSk7dmFyIGw9IiIsbj0iIjtpZihnLndpZHRoKmcuaGVpZ2h0Pk1BWF9BUkVBfHxjLmxlbmd0aD5NQVhfUkVRVUVTVF9TSVpFKXRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJkcmF3aW5nVG9vTGFyZ2UiKX07eD14PyIxIjoiMCI7InBkZiI9PWUmJjA9PXAmJihuPSImYWxsUGFnZXM9MSIpO2lmKCJ4bWxwbmciPT1lJiYoeD0iMSIsZT0icG5nIixudWxsIT10aGlzLnBhZ2VzJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlKSlmb3IocD0wO3A8dGhpcy5wYWdlcy5sZW5ndGg7cCsrKWlmKHRoaXMucGFnZXNbcF09PXRoaXMuY3VycmVudFBhZ2Upe2w9IiZmcm9tPSIrcDticmVha31wPWIuYmFja2dyb3VuZDsicG5nIj09ZSYmZj9wPW14Q29uc3RhbnRzLk5PTkU6Znx8bnVsbCE9cCYmcCE9bXhDb25zdGFudHMuTk9ORXx8KHA9IiNmZmZmZmYiKTtmPXtnbG9iYWxWYXJzOmIuZ2V0RXhwb3J0VmFyaWFibGVzKCl9OwptJiYoZi5ncmlkPXtzaXplOmIuZ3JpZFNpemUsc3RlcHM6Yi52aWV3LmdyaWRTdGVwcyxjb2xvcjpiLnZpZXcuZ3JpZENvbG9yfSk7cmV0dXJuIG5ldyBteFhtbFJlcXVlc3QoRVhQT1JUX1VSTCwiZm9ybWF0PSIrZStsK24rIiZiZz0iKyhudWxsIT1wP3A6bXhDb25zdGFudHMuTk9ORSkrIiZiYXNlNjQ9IitkKyImZW1iZWRYbWw9Iit4KyImeG1sPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKyhudWxsIT1hPyImZmlsZW5hbWU9IitlbmNvZGVVUklDb21wb25lbnQoYSk6IiIpKyImZXh0cmFzPSIrZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGYpKSsobnVsbCE9az8iJnNjYWxlPSIrazoiIikrKG51bGwhPXQ/IiZib3JkZXI9Iit0OiIiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRNb2RlPWZ1bmN0aW9uKGEsZSl7dGhpcy5tb2RlPWF9O0VkaXRvclVpLnByb3RvdHlwZS5sb2FkRGVzY3JpcHRvcj1mdW5jdGlvbihhLGUsYyl7dmFyIGI9d2luZG93LmxvY2F0aW9uLmhhc2gsCmQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7dmFyIGQ9bnVsbCE9YS5kYXRhP2EuZGF0YToiIjtudWxsIT1jJiYwPGMubGVuZ3RoJiYoMDxkLmxlbmd0aCYmKGQrPSJcbiIpLGQrPWMpO2M9bmV3IExvY2FsRmlsZSh0aGlzLCJjc3YiIT1hLmZvcm1hdCYmMDxkLmxlbmd0aD9kOnRoaXMuZW1wdHlEaWFncmFtWG1sLG51bGwhPXVybFBhcmFtcy50aXRsZT9kZWNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zLnRpdGxlKTp0aGlzLmRlZmF1bHRGaWxlbmFtZSwhMCk7Yy5nZXRIYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGJ9O3RoaXMuZmlsZUxvYWRlZChjKTsiY3N2Ij09YS5mb3JtYXQmJnRoaXMuaW1wb3J0Q3N2KGQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLmVkaXRvci5zZXRNb2RpZmllZCghMSk7dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKCIiKX0pKTtpZihudWxsIT1hLnVwZGF0ZSl7dmFyIGY9bnVsbCE9YS5pbnRlcnZhbD8KcGFyc2VJbnQoYS5pbnRlcnZhbCk6NkU0LGc9bnVsbCxsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5jdXJyZW50UGFnZTtteFV0aWxzLnBvc3QoYS51cGRhdGUsInhtbD0iK2VuY29kZVVSSUNvbXBvbmVudChteFV0aWxzLmdldFhtbCh0aGlzLmVkaXRvci5nZXRHcmFwaFhtbCgpKSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yj09PXRoaXMuY3VycmVudFBhZ2UmJigyMDA8PWEuZ2V0U3RhdHVzKCkmJjMwMD49YS5nZXRTdGF0dXMoKT8odGhpcy51cGRhdGVEaWFncmFtKGEuZ2V0VGV4dCgpKSxuKCkpOnRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpKyIgIithLmdldFN0YXR1cygpfSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pKX0pLG49bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt3aW5kb3cuY2xlYXJUaW1lb3V0KGcpO2c9d2luZG93LnNldFRpbWVvdXQobCwKZil9KTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe24oKTtsKCl9KSk7bigpO2woKX1udWxsIT1lJiZlKCl9KTtpZihudWxsIT1hLnVybCYmMDxhLnVybC5sZW5ndGgpe3ZhciBmPWEudXJsOy9eaHR0cHM/OlwvXC8vLnRlc3QoZikmJiF0aGlzLmVkaXRvci5pc0NvcnNFbmFibGVkRm9yVXJsKGYpJiYoZj1QUk9YWV9VUkwrIj91cmw9IitlbmNvZGVVUklDb21wb25lbnQoZikpO3RoaXMuZWRpdG9yLmxvYWRVcmwoZixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtkKGEpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9YyYmYyhhKX0pKX1lbHNlIGQoIiIpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlRGlhZ3JhbT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe3ZhciBiPW5ldyBteENlbGxPdmVybGF5KGEuaW1hZ2V8fGYud2FybmluZ0ltYWdlLGEudG9vbHRpcCxhLmFsaWduLGEudmFsaWduLAphLm9mZnNldCk7Yi5hZGRMaXN0ZW5lcihteEV2ZW50LkNMSUNLLGZ1bmN0aW9uKGIsZSl7ZC5hbGVydChhLnRvb2x0aXApfSk7cmV0dXJuIGJ9dmFyIGM9bnVsbCxkPXRoaXM7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCYmKGM9bXhVdGlscy5wYXJzZVhtbChhKSxhPW51bGwhPWM/Yy5kb2N1bWVudEVsZW1lbnQ6bnVsbCxudWxsIT1hJiYidXBkYXRlcyI9PWEubm9kZU5hbWUpKXt2YXIgZj10aGlzLmVkaXRvci5ncmFwaCxwPWYuZ2V0TW9kZWwoKTtwLmJlZ2luVXBkYXRlKCk7dmFyIGs9bnVsbDt0cnl7Zm9yKGE9YS5maXJzdENoaWxkO251bGwhPWE7KXtpZigidXBkYXRlIj09YS5ub2RlTmFtZSl7dmFyIHQ9cC5nZXRDZWxsKGEuZ2V0QXR0cmlidXRlKCJpZCIpKTtpZihudWxsIT10KXt0cnl7dmFyIG09YS5nZXRBdHRyaWJ1dGUoInZhbHVlIik7aWYobnVsbCE9bSl7dmFyIHg9bXhVdGlscy5wYXJzZVhtbChtKS5kb2N1bWVudEVsZW1lbnQ7aWYobnVsbCE9eClpZigiMSI9PXguZ2V0QXR0cmlidXRlKCJyZXBsYWNlLXZhbHVlIikpcC5zZXRWYWx1ZSh0LAp4KTtlbHNlIGZvcih2YXIgcT14LmF0dHJpYnV0ZXMsQj0wO0I8cS5sZW5ndGg7QisrKWYuc2V0QXR0cmlidXRlRm9yQ2VsbCh0LHFbQl0ubm9kZU5hbWUsMDxxW0JdLm5vZGVWYWx1ZS5sZW5ndGg/cVtCXS5ub2RlVmFsdWU6bnVsbCl9fWNhdGNoKHUpe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiRXJyb3IgaW4gdmFsdWUgZm9yICIrdC5pZCsiOiAiK3UpfXRyeXt2YXIgRD1hLmdldEF0dHJpYnV0ZSgic3R5bGUiKTtudWxsIT1EJiZmLm1vZGVsLnNldFN0eWxlKHQsRCl9Y2F0Y2godSl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJFcnJvciBpbiBzdHlsZSBmb3IgIit0LmlkKyI6ICIrdSl9dHJ5e3ZhciB6PWEuZ2V0QXR0cmlidXRlKCJpY29uIik7aWYobnVsbCE9eil7dmFyIEU9MDx6Lmxlbmd0aD9KU09OLnBhcnNlKHopOm51bGw7bnVsbCE9RSYmRS5hcHBlbmR8fGYucmVtb3ZlQ2VsbE92ZXJsYXlzKHQpO251bGwhPUUmJmYuYWRkQ2VsbE92ZXJsYXkodCwKYihFKSl9fWNhdGNoKHUpe251bGwhPXdpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZygiRXJyb3IgaW4gaWNvbiBmb3IgIit0LmlkKyI6ICIrdSl9dHJ5e3ZhciBHPWEuZ2V0QXR0cmlidXRlKCJnZW9tZXRyeSIpO2lmKG51bGwhPUcpe3ZhciBHPUpTT04ucGFyc2UoRyksRj1mLmdldENlbGxHZW9tZXRyeSh0KTtpZihudWxsIT1GKXtGPUYuY2xvbmUoKTtmb3Ioa2V5IGluIEcpe3ZhciBIPXBhcnNlRmxvYXQoR1trZXldKTsiZHgiPT1rZXk/Ri54Kz1IOiJkeSI9PWtleT9GLnkrPUg6ImR3Ij09a2V5P0Yud2lkdGgrPUg6ImRoIj09a2V5P0YuaGVpZ2h0Kz1IOkZba2V5XT1wYXJzZUZsb2F0KEdba2V5XSl9Zi5tb2RlbC5zZXRHZW9tZXRyeSh0LEYpfX19Y2F0Y2godSl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJFcnJvciBpbiBpY29uIGZvciAiK3QuaWQrIjogIit1KX19fWVsc2UgaWYoIm1vZGVsIj09YS5ub2RlTmFtZSl7Zm9yKHZhciBKPWEuZmlyc3RDaGlsZDtudWxsIT0KSiYmSi5ub2RlVHlwZSE9bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVDspSj1KLm5leHRTaWJsaW5nO251bGwhPUomJihuZXcgbXhDb2RlYyhhLmZpcnN0Q2hpbGQpKS5kZWNvZGUoSixwKX1lbHNlIGlmKCJ2aWV3Ij09YS5ub2RlTmFtZSl7aWYoYS5oYXNBdHRyaWJ1dGUoInNjYWxlIikmJihmLnZpZXcuc2NhbGU9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgic2NhbGUiKSkpLGEuaGFzQXR0cmlidXRlKCJkeCIpfHxhLmhhc0F0dHJpYnV0ZSgiZHkiKSlmLnZpZXcudHJhbnNsYXRlPW5ldyBteFBvaW50KHBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoImR4Iil8fDApLHBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoImR5Iil8fDApKX1lbHNlImZpdCI9PWEubm9kZU5hbWUmJihrPWEuaGFzQXR0cmlidXRlKCJtYXgtc2NhbGUiKT9wYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJtYXgtc2NhbGUiKSk6MSk7YT1hLm5leHRTaWJsaW5nfX1maW5hbGx5e3AuZW5kVXBkYXRlKCl9bnVsbCE9CmsmJnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSYmdGhpcy5jaHJvbWVsZXNzUmVzaXplKCEwLGspfXJldHVybiBjfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0Q29weUZpbGVuYW1lPWZ1bmN0aW9uKGEsZSl7dmFyIGI9bnVsbCE9YSYmbnVsbCE9YS5nZXRUaXRsZSgpP2EuZ2V0VGl0bGUoKTp0aGlzLmRlZmF1bHRGaWxlbmFtZSxjPSIiLGQ9Yi5sYXN0SW5kZXhPZigiLiIpOzA8PWQmJihjPWIuc3Vic3RyaW5nKGQpLGI9Yi5zdWJzdHJpbmcoMCxkKSk7aWYoZSl2YXIgZj1uZXcgRGF0ZSxkPWYuZ2V0RnVsbFllYXIoKSxrPWYuZ2V0TW9udGgoKSsxLHQ9Zi5nZXREYXRlKCksbT1mLmdldEhvdXJzKCkseD1mLmdldE1pbnV0ZXMoKSxmPWYuZ2V0U2Vjb25kcygpLGI9YisoIiAiKyhkKyItIitrKyItIit0KyItIittKyItIit4KyItIitmKSk7cmV0dXJuIGI9bXhSZXNvdXJjZXMuZ2V0KCJjb3B5T2YiLFtiXSkrY307RWRpdG9yVWkucHJvdG90eXBlLmZpbGVMb2FkZWQ9ZnVuY3Rpb24oYSxlKXt2YXIgYj0KdGhpcy5nZXRDdXJyZW50RmlsZSgpO3RoaXMuZmlsZUxvYWRlZEVycm9yPW51bGw7dGhpcy5zZXRDdXJyZW50RmlsZShudWxsKTt2YXIgYz0hMTt0aGlzLmhpZGVEaWFsb2coKTtudWxsIT1iJiYoRWRpdG9yVWkuZGVidWcoIkZpbGUuY2xvc2VkIixbYl0pLGIucmVtb3ZlTGlzdGVuZXIodGhpcy5kZXNjcmlwdG9yQ2hhbmdlZExpc3RlbmVyKSxiLmNsb3NlKCkpO3RoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNsZWFyKCk7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt2YXIgZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2V0R3JhcGhFbmFibGVkKCExKTt0aGlzLnNldEN1cnJlbnRGaWxlKG51bGwpO251bGwhPWImJnRoaXMudXBkYXRlRG9jdW1lbnRUaXRsZSgpO3RoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNsZWFyKCk7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLnNldEJhY2tncm91bmRJbWFnZShudWxsKTshZSYmbnVsbCE9d2luZG93LmxvY2F0aW9uLmhhc2gmJgowPHdpbmRvdy5sb2NhdGlvbi5oYXNoLmxlbmd0aCYmKHdpbmRvdy5sb2NhdGlvbi5oYXNoPSIiKTtudWxsIT10aGlzLmZuYW1lJiYodGhpcy5mbmFtZVdyYXBwZXIuc3R5bGUuZGlzcGxheT0ibm9uZSIsdGhpcy5mbmFtZS5pbm5lckhUTUw9IiIsdGhpcy5mbmFtZS5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInJlbmFtZSIpKSk7dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKCIiKTt0aGlzLnVwZGF0ZVVpKCk7ZXx8dGhpcy5zaG93U3BsYXNoKCl9KTtpZihudWxsIT1hKXRyeXtteENsaWVudC5JU19TRiYmIm1pbiI9PXVpVGhlbWUmJih0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUudmlzaWJpbGl0eT0iIik7dGhpcy5vcGVuaW5nRmlsZT0hMDt0aGlzLnNldEN1cnJlbnRGaWxlKGEpO2EuYWRkTGlzdGVuZXIoImRlc2NyaXB0b3JDaGFuZ2VkIix0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkTGlzdGVuZXIpO2EuYWRkTGlzdGVuZXIoImNvbnRlbnRDaGFuZ2VkIix0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkTGlzdGVuZXIpOwphLm9wZW4oKTtkZWxldGUgdGhpcy5vcGVuaW5nRmlsZTt0aGlzLnNldEdyYXBoRW5hYmxlZCghMCk7dGhpcy5zZXRNb2RlKGEuZ2V0TW9kZSgpKTt0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5wcmVmaXg9RWRpdG9yLmd1aWQoKSsiLSI7dGhpcy5lZGl0b3IudW5kb01hbmFnZXIuY2xlYXIoKTt0aGlzLmRlc2NyaXB0b3JDaGFuZ2VkKCk7dGhpcy51cGRhdGVVaSgpO2EuaXNFZGl0YWJsZSgpP2EuaXNNb2RpZmllZCgpPyhhLmFkZFVuc2F2ZWRTdGF0dXMoKSxudWxsIT1hLmJhY2t1cFBhdGNoJiZhLnBhdGNoKFthLmJhY2t1cFBhdGNoXSkpOnRoaXMuZWRpdG9yLnNldFN0YXR1cygiIik6dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKCc8c3BhbiBjbGFzcz0iZ2VTdGF0dXNBbGVydCIgc3R5bGU9Im1hcmdpbi1sZWZ0OjhweDsiPicrbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJyZWFkT25seSIpKSsiPC9zcGFuPiIpOyF0aGlzLmVkaXRvci5pc0Nocm9tZWxlc3NWaWV3KCl8fAp0aGlzLmVkaXRvci5lZGl0YWJsZT8odGhpcy5lZGl0b3IuZ3JhcGguc2VsZWN0VW5sb2NrZWRMYXllcigpLHRoaXMuc2hvd0xheWVyc0RpYWxvZygpLHRoaXMucmVzdG9yZUxpYnJhcmllcygpLHdpbmRvdy5zZWxmIT09d2luZG93LnRvcCYmd2luZG93LmZvY3VzKCkpOnRoaXMuZWRpdG9yLmdyYXBoLmlzTGlnaHRib3hWaWV3KCkmJnRoaXMubGlnaHRib3hGaXQoKTt0aGlzLmNocm9tZWxlc3NSZXNpemUmJnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSgpO3RoaXMuZWRpdG9yLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiZmlsZUxvYWRlZCIpKTtjPSEwO3RoaXMuaXNPZmZsaW5lKCl8fG51bGw9PWEuZ2V0TW9kZSgpfHxFZGl0b3JVaS5sb2dFdmVudCh7Y2F0ZWdvcnk6YS5nZXRNb2RlKCkudG9VcHBlckNhc2UoKSsiLU9QRU4tRklMRS0iK2EuZ2V0SGFzaCgpLGFjdGlvbjoic2l6ZV8iK2EuZ2V0U2l6ZSgpLGxhYmVsOiJhdXRvc2F2ZV8iKyh0aGlzLmVkaXRvci5hdXRvc2F2ZT8ib24iOgoib2ZmIil9KTtFZGl0b3JVaS5kZWJ1ZygiRmlsZS5vcGVuZWQiLFthXSk7aWYodGhpcy5lZGl0b3IuZWRpdGFibGUmJnRoaXMubW9kZT09YS5nZXRNb2RlKCkmJmEuZ2V0TW9kZSgpIT1BcHAuTU9ERV9ERVZJQ0UmJm51bGwhPWEuZ2V0TW9kZSgpKXRyeXt0aGlzLmFkZFJlY2VudCh7aWQ6YS5nZXRIYXNoKCksdGl0bGU6YS5nZXRUaXRsZSgpLG1vZGU6YS5nZXRNb2RlKCl9KX1jYXRjaCh2KXt9dHJ5e214U2V0dGluZ3Muc2V0T3BlbkNvdW50ZXIobXhTZXR0aW5ncy5nZXRPcGVuQ291bnRlcigpKzEpLG14U2V0dGluZ3Muc2F2ZSgpfWNhdGNoKHYpe319Y2F0Y2godil7dGhpcy5maWxlTG9hZGVkRXJyb3I9djtpZihFZGl0b3JVaS5lbmFibGVMb2dnaW5nJiYhdGhpcy5pc09mZmxpbmUoKSl0cnl7RWRpdG9yVWkubG9nRXZlbnQoe2NhdGVnb3J5OiJFUlJPUi1MT0FELUZJTEUtIisobnVsbCE9YT9hLmdldEhhc2goKToibm9uZSIpLGFjdGlvbjoibWVzc2FnZV8iK3YubWVzc2FnZSxsYWJlbDoic3RhY2tfIisKdi5zdGFja30pfWNhdGNoKHQpe312YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXVybFBhcmFtcy51cmwmJnRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJyZWNvbm5lY3RpbmciKSk/d2luZG93LmxvY2F0aW9uLnNlYXJjaD10aGlzLmdldFNlYXJjaChbInVybCJdKTpudWxsIT1iP3RoaXMuZmlsZUxvYWRlZChiKTpkKCl9KTtlP2YoKTp0aGlzLmhhbmRsZUVycm9yKHYsbXhSZXNvdXJjZXMuZ2V0KCJlcnJvckxvYWRpbmdGaWxlIiksZiwhMCxudWxsLG51bGwsITApfWVsc2UgZCgpO3JldHVybiBjfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0SGFzaFZhbHVlRm9yUGFnZXM9ZnVuY3Rpb24oYSxlKXt2YXIgYj0wLGM9bmV3IG14R3JhcGhNb2RlbCxkPW5ldyBteENvZGVjO251bGwhPWUmJihlLmJ5dGVDb3VudD0wLGUuYXR0ckNvdW50PTAsZS5lbHRDb3VudD0wLGUubm9kZUNvdW50PTApO2Zvcih2YXIgZj0wO2Y8YS5sZW5ndGg7ZisrKXt0aGlzLnVwZGF0ZVBhZ2VSb290KGFbZl0pOwp2YXIgaz1hW2ZdLm5vZGUuY2xvbmVOb2RlKCExKTtrLnJlbW92ZUF0dHJpYnV0ZSgibmFtZSIpO2Mucm9vdD1hW2ZdLnJvb3Q7dmFyIHQ9ZC5lbmNvZGUoYyk7dGhpcy5lZGl0b3IuZ3JhcGguc2F2ZVZpZXdTdGF0ZShhW2ZdLnZpZXdTdGF0ZSx0LCEwKTt0LnJlbW92ZUF0dHJpYnV0ZSgicGFnZVdpZHRoIik7dC5yZW1vdmVBdHRyaWJ1dGUoInBhZ2VIZWlnaHQiKTtrLmFwcGVuZENoaWxkKHQpO251bGwhPWUmJihlLmVsdENvdW50Kz1rLmdldEVsZW1lbnRzQnlUYWdOYW1lKCIqIikubGVuZ3RoLGUubm9kZUNvdW50Kz1rLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJteENlbGwiKS5sZW5ndGgpO2I9KGI8PDUpLWIrdGhpcy5oYXNoVmFsdWUoayxmdW5jdGlvbihhLGIsZSxjKXtyZXR1cm4hY3x8Im14R2VvbWV0cnkiIT1hLm5vZGVOYW1lJiYibXhQb2ludCIhPWEubm9kZU5hbWV8fCJ4IiE9YiYmInkiIT1iJiYid2lkdGgiIT1iJiYiaGVpZ2h0IiE9Yj9jJiYibXhDZWxsIj09YS5ub2RlTmFtZSYmCiJwcmV2aW91cyI9PWI/bnVsbDplOk1hdGgucm91bmQoZSl9LGUpPDwwfXJldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuaGFzaFZhbHVlPWZ1bmN0aW9uKGEsZSxjKXt2YXIgYj0wO2lmKG51bGwhPWEmJiJvYmplY3QiPT09dHlwZW9mIGEmJiJudW1iZXIiPT09dHlwZW9mIGEubm9kZVR5cGUmJiJzdHJpbmciPT09dHlwZW9mIGEubm9kZU5hbWUmJiJmdW5jdGlvbiI9PT10eXBlb2YgYS5nZXRBdHRyaWJ1dGUpe251bGwhPWEubm9kZU5hbWUmJihiXj10aGlzLmhhc2hWYWx1ZShhLm5vZGVOYW1lLGUsYykpO2lmKG51bGwhPWEuYXR0cmlidXRlcyl7bnVsbCE9YyYmKGMuYXR0ckNvdW50Kz1hLmF0dHJpYnV0ZXMubGVuZ3RoKTtmb3IodmFyIGQ9MDtkPGEuYXR0cmlidXRlcy5sZW5ndGg7ZCsrKXt2YXIgZj1hLmF0dHJpYnV0ZXNbZF0ubmFtZSxnPW51bGwhPWU/ZShhLGYsYS5hdHRyaWJ1dGVzW2RdLnZhbHVlLCEwKTphLmF0dHJpYnV0ZXNbZF0udmFsdWU7bnVsbCE9ZyYmKGJePXRoaXMuaGFzaFZhbHVlKGYsCmUsYykrdGhpcy5oYXNoVmFsdWUoZyxlLGMpKX19aWYobnVsbCE9YS5jaGlsZE5vZGVzKWZvcihkPTA7ZDxhLmNoaWxkTm9kZXMubGVuZ3RoO2QrKyliPShiPDw1KS1iK3RoaXMuaGFzaFZhbHVlKGEuY2hpbGROb2Rlc1tkXSxlLGMpPDwwfWVsc2UgaWYobnVsbCE9YSYmImZ1bmN0aW9uIiE9PXR5cGVvZiBhKXthPVN0cmluZyhhKTtlPTA7bnVsbCE9YyYmKGMuYnl0ZUNvdW50Kz1hLmxlbmd0aCk7Zm9yKGQ9MDtkPGEubGVuZ3RoO2QrKyllPShlPDw1KS1lK2EuY2hhckNvZGVBdChkKTw8MDtiXj1lfXJldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuZGVzY3JpcHRvckNoYW5nZWQ9ZnVuY3Rpb24oKXt9O0VkaXRvclVpLnByb3RvdHlwZS5yZXN0b3JlTGlicmFyaWVzPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuc2F2ZUxpYnJhcnk9ZnVuY3Rpb24oYSxjLGQsZixsLHAsayl7fTtFZGl0b3JVaS5wcm90b3R5cGUuaXNTY3JhdGNocGFkRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiBpc0xvY2FsU3RvcmFnZXx8Cm14Q2xpZW50LklTX0NIUk9NRUFQUH07RWRpdG9yVWkucHJvdG90eXBlLnRvZ2dsZVNjcmF0Y2hwYWQ9ZnVuY3Rpb24oKXt0aGlzLmlzU2NyYXRjaHBhZEVuYWJsZWQoKSYmKG51bGw9PXRoaXMuc2NyYXRjaHBhZD9TdG9yYWdlRmlsZS5nZXRGaWxlQ29udGVudCh0aGlzLCIuc2NyYXRjaHBhZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbD09YSYmKGE9dGhpcy5lbXB0eUxpYnJhcnlYbWwpO3RoaXMubG9hZExpYnJhcnkobmV3IFN0b3JhZ2VMaWJyYXJ5KHRoaXMsYSwiLnNjcmF0Y2hwYWQiKSl9KSk6dGhpcy5jbG9zZUxpYnJhcnkodGhpcy5zY3JhdGNocGFkKSl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVMaWJyYXJ5RGF0YUZyb21JbWFnZXM9ZnVuY3Rpb24oYSl7dmFyIGI9bXhVdGlscy5jcmVhdGVYbWxEb2N1bWVudCgpLGM9Yi5jcmVhdGVFbGVtZW50KCJteGxpYnJhcnkiKTtteFV0aWxzLnNldFRleHRDb250ZW50KGMsSlNPTi5zdHJpbmdpZnkoYSkpO2IuYXBwZW5kQ2hpbGQoYyk7CnJldHVybiBteFV0aWxzLmdldFhtbChiKX07RWRpdG9yVWkucHJvdG90eXBlLmNsb3NlTGlicmFyeT1mdW5jdGlvbihhKXtudWxsIT1hJiYodGhpcy5yZW1vdmVMaWJyYXJ5U2lkZWJhcihhLmdldEhhc2goKSksYS5jb25zdHJ1Y3RvciE9TG9jYWxMaWJyYXJ5JiZteFNldHRpbmdzLnJlbW92ZUN1c3RvbUxpYnJhcnkoYS5nZXRIYXNoKCkpLCIuc2NyYXRjaHBhZCI9PWEudGl0bGUmJih0aGlzLnNjcmF0Y2hwYWQ9bnVsbCkpfTtFZGl0b3JVaS5wcm90b3R5cGUucmVtb3ZlTGlicmFyeVNpZGViYXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zaWRlYmFyLnBhbGV0dGVzW2FdO2lmKG51bGwhPWIpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKWJbY10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiW2NdKTtkZWxldGUgdGhpcy5zaWRlYmFyLnBhbGV0dGVzW2FdfX07RWRpdG9yVWkucHJvdG90eXBlLnJlcG9zaXRpb25MaWJyYXJ5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2lkZWJhci5jb250YWluZXI7CmlmKG51bGw9PWEpe3ZhciBjPXRoaXMuc2lkZWJhci5wYWxldHRlc1siTC5zY3JhdGNocGFkIl07bnVsbD09YyYmKGM9dGhpcy5zaWRlYmFyLnBhbGV0dGVzLnNlYXJjaCk7bnVsbCE9YyYmKGE9Y1tjLmxlbmd0aC0xXS5uZXh0U2libGluZyl9YT1udWxsIT1hP2E6Yi5maXJzdENoaWxkLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nO3ZhciBjPWIubGFzdENoaWxkLGQ9Yy5wcmV2aW91c1NpYmxpbmc7Yi5pbnNlcnRCZWZvcmUoYyxhKTtiLmluc2VydEJlZm9yZShkLGMpfTtFZGl0b3JVaS5wcm90b3R5cGUubG9hZExpYnJhcnk9ZnVuY3Rpb24oYSxjKXt2YXIgYj1teFV0aWxzLnBhcnNlWG1sKGEuZ2V0RGF0YSgpKTtpZigibXhsaWJyYXJ5Ij09Yi5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUpe3ZhciBlPUpTT04ucGFyc2UobXhVdGlscy5nZXRUZXh0Q29udGVudChiLmRvY3VtZW50RWxlbWVudCkpO3RoaXMubGlicmFyeUxvYWRlZChhLGUsYi5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCJ0aXRsZSIpLApjKX1lbHNlIHRocm93e21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJub3RBTGlicmFyeUZpbGUiKX07fTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0TGlicmFyeVN0b3JhZ2VIaW50PWZ1bmN0aW9uKGEpe3JldHVybiIifTtFZGl0b3JVaS5wcm90b3R5cGUubGlicmFyeUxvYWRlZD1mdW5jdGlvbihhLGMsZCxmKXtpZihudWxsIT10aGlzLnNpZGViYXIpe2EuY29uc3RydWN0b3IhPUxvY2FsTGlicmFyeSYmbXhTZXR0aW5ncy5hZGRDdXN0b21MaWJyYXJ5KGEuZ2V0SGFzaCgpKTsiLnNjcmF0Y2hwYWQiPT1hLnRpdGxlJiYodGhpcy5zY3JhdGNocGFkPWEpO3ZhciBiPXRoaXMuc2lkZWJhci5wYWxldHRlc1thLmdldEhhc2goKV0sYj1udWxsIT1iP2JbYi5sZW5ndGgtMV0ubmV4dFNpYmxpbmc6bnVsbDt0aGlzLnJlbW92ZUxpYnJhcnlTaWRlYmFyKGEuZ2V0SGFzaCgpKTt2YXIgZT1udWxsLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixjKXswPT1iLmxlbmd0aCYmYS5pc0VkaXRhYmxlKCk/CihudWxsPT1lJiYoZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxlLmNsYXNzTmFtZT0iZ2VEcm9wVGFyZ2V0IixteFV0aWxzLndyaXRlKGUsbXhSZXNvdXJjZXMuZ2V0KCJkcmFnRWxlbWVudHNIZXJlIikpKSxjLmFwcGVuZENoaWxkKGUpKTp0aGlzLmFkZExpYnJhcnlFbnRyaWVzKGIsYyl9KTtudWxsIT10aGlzLnNpZGViYXImJm51bGwhPWMmJnRoaXMuc2lkZWJhci5hZGRFbnRyaWVzKGMpO2Q9bnVsbCE9ZCYmMDxkLmxlbmd0aD9kOmEuZ2V0VGl0bGUoKTt2YXIgbj10aGlzLnNpZGViYXIuYWRkUGFsZXR0ZShhLmdldEhhc2goKSxkLG51bGwhPWY/ZjohMCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtnKGMsYSl9KSk7dGhpcy5yZXBvc2l0aW9uTGlicmFyeShiKTt2YXIgaz1uLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nO2Y9ay5nZXRBdHRyaWJ1dGUoInRpdGxlIik7bnVsbCE9ZiYmMDxmLmxlbmd0aCYmIi5zY3JhdGNocGFkIiE9YS50aXRsZSYmay5zZXRBdHRyaWJ1dGUoInRpdGxlIiwKdGhpcy5nZXRMaWJyYXJ5U3RvcmFnZUhpbnQoYSkrIlxuIitmKTt2YXIgbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTttLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7bS5zdHlsZS5yaWdodD0iMHB4IjttLnN0eWxlLnRvcD0iMHB4IjttLnN0eWxlLnBhZGRpbmc9IjhweCI7bXhDbGllbnQuSVNfUVVJUktTfHw4PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fChtLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iaW5oZXJpdCIpO2suc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjt2YXIgcT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtxLnNldEF0dHJpYnV0ZSgic3JjIixEaWFsb2cucHJvdG90eXBlLmNsb3NlSW1hZ2UpO3Euc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjbG9zZSIpKTtxLnNldEF0dHJpYnV0ZSgidmFsaWduIiwiYWJzbWlkZGxlIik7cS5zZXRBdHRyaWJ1dGUoImJvcmRlciIsIjAiKTtxLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7cS5zdHlsZS5tYXJnaW49CiIwIDNweCI7dmFyIEI9bnVsbDtpZigiLnNjcmF0Y2hwYWQiIT1hLnRpdGxlfHx0aGlzLmNsb3NhYmxlU2NyYXRjaHBhZCltLmFwcGVuZENoaWxkKHEpLG14RXZlbnQuYWRkTGlzdGVuZXIocSwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2lmKCFteEV2ZW50LmlzQ29uc3VtZWQoYikpe3ZhciBjPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5jbG9zZUxpYnJhcnkoYSl9KTtudWxsIT1CP3RoaXMuY29uZmlybShteFJlc291cmNlcy5nZXQoImFsbENoYW5nZXNMb3N0IiksbnVsbCxjLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhSZXNvdXJjZXMuZ2V0KCJkaXNjYXJkQ2hhbmdlcyIpKTpjKCk7bXhFdmVudC5jb25zdW1lKGIpfX0pKTtpZihhLmlzRWRpdGFibGUoKSl7dmFyIEQ9dGhpcy5lZGl0b3IuZ3JhcGgsej1udWxsLEU9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7dGhpcy5zaG93TGlicmFyeURpYWxvZyhhLmdldFRpdGxlKCksbiwKYyxhLGEuZ2V0TW9kZSgpKTtteEV2ZW50LmNvbnN1bWUoYil9KSxHPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2Euc2V0TW9kaWZpZWQoITApO2EuaXNBdXRvc2F2ZSgpPyhudWxsIT16JiZudWxsIT16LnBhcmVudE5vZGUmJnoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh6KSx6PXEuY2xvbmVOb2RlKCExKSx6LnNldEF0dHJpYnV0ZSgic3JjIixFZGl0b3Iuc3BpbkltYWdlKSx6LnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgic2F2aW5nIikpLHouc3R5bGUuY3Vyc29yPSJkZWZhdWx0Iix6LnN0eWxlLm1hcmdpblJpZ2h0PSIycHgiLHouc3R5bGUubWFyZ2luVG9wPSItMnB4IixtLmluc2VydEJlZm9yZSh6LG0uZmlyc3RDaGlsZCksay5zdHlsZS5wYWRkaW5nUmlnaHQ9MTgqbS5jaGlsZE5vZGVzLmxlbmd0aCsicHgiLHRoaXMuc2F2ZUxpYnJhcnkoYS5nZXRUaXRsZSgpLGMsYSxhLmdldE1vZGUoKSwhMCwhMCxmdW5jdGlvbigpe251bGwhPXomJm51bGwhPQp6LnBhcmVudE5vZGUmJih6LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeiksay5zdHlsZS5wYWRkaW5nUmlnaHQ9MTgqbS5jaGlsZE5vZGVzLmxlbmd0aCsicHgiKX0pKTpudWxsPT1CJiYoQj1xLmNsb25lTm9kZSghMSksQi5zZXRBdHRyaWJ1dGUoInNyYyIsSU1BR0VfUEFUSCsiL2Rvd25sb2FkLnBuZyIpLEIuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlIikpLG0uaW5zZXJ0QmVmb3JlKEIsbS5maXJzdENoaWxkKSxteEV2ZW50LmFkZExpc3RlbmVyKEIsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0aGlzLnNhdmVMaWJyYXJ5KGEuZ2V0VGl0bGUoKSxjLGEsYS5nZXRNb2RlKCksYS5jb25zdHJ1Y3Rvcj09TG9jYWxMaWJyYXJ5LCEwLGZ1bmN0aW9uKCl7bnVsbD09Qnx8YS5pc01vZGlmaWVkKCl8fChrLnN0eWxlLnBhZGRpbmdSaWdodD0xOCptLmNoaWxkTm9kZXMubGVuZ3RoKyJweCIsQi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEIpLApCPW51bGwpfSk7bXhFdmVudC5jb25zdW1lKGIpfSkpLGsuc3R5bGUucGFkZGluZ1JpZ2h0PTE4Km0uY2hpbGROb2Rlcy5sZW5ndGgrInB4Iil9KSxGPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYixkLGYpe2E9RC5jbG9uZUNlbGxzKG14VXRpbHMuc29ydENlbGxzKEQubW9kZWwuZ2V0VG9wbW9zdENlbGxzKGEpKSk7Zm9yKHZhciBnPTA7ZzxhLmxlbmd0aDtnKyspe3ZhciBsPUQuZ2V0Q2VsbEdlb21ldHJ5KGFbZ10pO251bGwhPWwmJmwudHJhbnNsYXRlKC1iLngsLWIueSl9bi5hcHBlbmRDaGlsZCh0aGlzLnNpZGViYXIuY3JlYXRlVmVydGV4VGVtcGxhdGVGcm9tQ2VsbHMoYSxiLndpZHRoLGIuaGVpZ2h0LGZ8fCIiLCEwLCExLCExKSk7YT17eG1sOkdyYXBoLmNvbXByZXNzKG14VXRpbHMuZ2V0WG1sKHRoaXMuZWRpdG9yLmdyYXBoLmVuY29kZUNlbGxzKGEpKSksdzpiLndpZHRoLGg6Yi5oZWlnaHR9O251bGwhPWYmJihhLnRpdGxlPWYpO2MucHVzaChhKTtHKGQpO251bGwhPQplJiZudWxsIT1lLnBhcmVudE5vZGUmJjA8Yy5sZW5ndGgmJihlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksZT1udWxsKX0pLEg9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYoRC5pc1NlbGVjdGlvbkVtcHR5KCkpRC5nZXRSdWJiZXJiYW5kKCkuaXNBY3RpdmUoKT8oRC5nZXRSdWJiZXJiYW5kKCkuZXhlY3V0ZShhKSxELmdldFJ1YmJlcmJhbmQoKS5yZXNldCgpKTp0aGlzLnNob3dFcnJvcihteFJlc291cmNlcy5nZXQoImVycm9yIiksbXhSZXNvdXJjZXMuZ2V0KCJub3RoaW5nSXNTZWxlY3RlZCIpLG14UmVzb3VyY2VzLmdldCgib2siKSk7ZWxzZXt2YXIgYj1ELmdldFNlbGVjdGlvbkNlbGxzKCksYz1ELnZpZXcuZ2V0Qm91bmRzKGIpLGU9RC52aWV3LnNjYWxlO2MueC89ZTtjLnkvPWU7Yy53aWR0aC89ZTtjLmhlaWdodC89ZTtjLngtPUQudmlldy50cmFuc2xhdGUueDtjLnktPUQudmlldy50cmFuc2xhdGUueTtGKGIsYyl9bXhFdmVudC5jb25zdW1lKGEpfSk7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKG4sCmZ1bmN0aW9uKCl7fSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtELmlzTW91c2VEb3duJiZudWxsIT1ELnBhbm5pbmdNYW5hZ2VyJiZudWxsIT1ELmdyYXBoSGFuZGxlci5maXJzdCYmKEQuZ3JhcGhIYW5kbGVyLnN1c3BlbmQoKSxudWxsIT1ELmdyYXBoSGFuZGxlci5oaW50JiYoRC5ncmFwaEhhbmRsZXIuaGludC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iKSxuLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iI2YxZjNmNCIsbi5zdHlsZS5jdXJzb3I9ImNvcHkiLEQucGFubmluZ01hbmFnZXIuc3RvcCgpLEQuYXV0b1Njcm9sbD0hMSxteEV2ZW50LmNvbnN1bWUoYSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7RC5pc01vdXNlRG93biYmbnVsbCE9RC5wYW5uaW5nTWFuYWdlciYmbnVsbCE9RC5ncmFwaEhhbmRsZXImJihuLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIixuLnN0eWxlLmN1cnNvcj0iZGVmYXVsdCIsdGhpcy5zaWRlYmFyLnNob3dUb29sdGlwcz0hMCwKRC5wYW5uaW5nTWFuYWdlci5zdG9wKCksRC5ncmFwaEhhbmRsZXIucmVzZXQoKSxELmlzTW91c2VEb3duPSExLEQuYXV0b1Njcm9sbD0hMCxIKGEpLG14RXZlbnQuY29uc3VtZShhKSl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihuLCJtb3VzZWxlYXZlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtELmlzTW91c2VEb3duJiZudWxsIT1ELmdyYXBoSGFuZGxlci5maXJzdCYmKEQuZ3JhcGhIYW5kbGVyLnJlc3VtZSgpLG51bGwhPUQuZ3JhcGhIYW5kbGVyLmhpbnQmJihELmdyYXBoSGFuZGxlci5oaW50LnN0eWxlLnZpc2liaWxpdHk9InZpc2libGUiKSxuLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIixuLnN0eWxlLmN1cnNvcj0iIixELmF1dG9TY3JvbGw9ITApfSkpO0dyYXBoLmZpbGVTdXBwb3J0JiYobXhFdmVudC5hZGRMaXN0ZW5lcihuLCJkcmFnb3ZlciIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNmMWYzZjQiO2EuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q9CiJjb3B5IjtuLnN0eWxlLmN1cnNvcj0iY29weSI7dGhpcy5zaWRlYmFyLmhpZGVUb29sdGlwKCk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihuLCJkcm9wIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtuLnN0eWxlLmN1cnNvcj0iIjtuLnN0eWxlLmJhY2tncm91bmRDb2xvcj0iIjswPGEuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCYmdGhpcy5pbXBvcnRGaWxlcyhhLmRhdGFUcmFuc2Zlci5maWxlcywwLDAsdGhpcy5tYXhJbWFnZVNpemUsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYixkLGYsbCxwLGssdCxtLHkpe2lmKG51bGwhPWImJiJpbWFnZS8iPT1kLnN1YnN0cmluZygwLDYpKWI9InNoYXBlPWltYWdlO3ZlcnRpY2FsTGFiZWxQb3NpdGlvbj1ib3R0b207dmVydGljYWxBbGlnbj10b3A7aW1hZ2VBc3BlY3Q9MDthc3BlY3Q9Zml4ZWQ7aW1hZ2U9Iit0aGlzLmNvbnZlcnREYXRhVXJpKGIpLGI9W25ldyBteENlbGwoIiIsCm5ldyBteEdlb21ldHJ5KDAsMCxwLGspLGIpXSxiWzBdLnZlcnRleD0hMCxGKGIsbmV3IG14UmVjdGFuZ2xlKDAsMCxwLGspLGEsbXhFdmVudC5pc0FsdERvd24oYSk/bnVsbDp0LnN1YnN0cmluZygwLHQubGFzdEluZGV4T2YoIi4iKSkucmVwbGFjZSgvXy9nLCIgIikpLG51bGwhPWUmJm51bGwhPWUucGFyZW50Tm9kZSYmMDxjLmxlbmd0aCYmKGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxlPW51bGwpO2Vsc2V7dmFyIHY9ITEseD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGQpe2lmKG51bGwhPWImJiJhcHBsaWNhdGlvbi9wZGYiPT1kKXt2YXIgZj1FZGl0b3IuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUGRmKGIpO251bGwhPWYmJjA8Zi5sZW5ndGgmJihiPWYpfWlmKG51bGwhPWIpaWYoZj1teFV0aWxzLnBhcnNlWG1sKGIpLCJteGxpYnJhcnkiPT1mLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSl0cnl7dmFyIGw9SlNPTi5wYXJzZShteFV0aWxzLmdldFRleHRDb250ZW50KGYuZG9jdW1lbnRFbGVtZW50KSk7CmcobCxuKTtjPWMuY29uY2F0KGwpO0coYSk7dGhpcy5zcGlubmVyLnN0b3AoKTt2PSEwfWNhdGNoKEwpe31lbHNlIGlmKCJteGZpbGUiPT1mLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSl0cnl7Zm9yKHZhciBwPWYuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIiksbD0wO2w8cC5sZW5ndGg7bCsrKXt2YXIgaz10aGlzLnN0cmluZ1RvQ2VsbHMoRWRpdG9yLmdldERpYWdyYW1Ob2RlWG1sKHBbbF0pKSx0PXRoaXMuZWRpdG9yLmdyYXBoLmdldEJvdW5kaW5nQm94RnJvbUdlb21ldHJ5KGspO0YoayxuZXcgbXhSZWN0YW5nbGUoMCwwLHQud2lkdGgsdC5oZWlnaHQpLGEpfXY9ITB9Y2F0Y2goTCl7bnVsbCE9d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKCJlcnJvciBpbiBkcm9wIGhhbmRsZXI6IixMKX12fHwodGhpcy5zcGlubmVyLnN0b3AoKSx0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiZXJyb3JMb2FkaW5nRmlsZSIpfSkpOwpudWxsIT1lJiZudWxsIT1lLnBhcmVudE5vZGUmJjA8Yy5sZW5ndGgmJihlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksZT1udWxsKX0pO251bGwhPXkmJm51bGwhPXQmJigvKFwudihkeHxzZHg/KSkoJHxcPykvaS50ZXN0KHQpfHwvKFwudnMoeHxzeD8pKSgkfFw/KS9pLnRlc3QodCkpP3RoaXMuaW1wb3J0VmlzaW8oeSxmdW5jdGlvbihhKXt4KGEsInRleHQveG1sIil9LG51bGwsdCk6IXRoaXMuaXNPZmZsaW5lKCkmJihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoYix0KSYmbnVsbCE9eT90aGlzLnBhcnNlRmlsZSh5LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezQ9PWEucmVhZHlTdGF0ZSYmKHRoaXMuc3Bpbm5lci5zdG9wKCksMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz94KGEucmVzcG9uc2VUZXh0LCJ0ZXh0L3htbCIpOnRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KDQxMz09YS5zdGF0dXM/CiJkcmF3aW5nVG9vTGFyZ2UiOiJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpfSxteFJlc291cmNlcy5nZXQoImVycm9yTG9hZGluZ0ZpbGUiKSkpfSkpOngoYixkKX19KSk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSksbXhFdmVudC5hZGRMaXN0ZW5lcihuLCJkcmFnbGVhdmUiLGZ1bmN0aW9uKGEpe24uc3R5bGUuY3Vyc29yPSIiO24uc3R5bGUuYmFja2dyb3VuZENvbG9yPSIiO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO3E9cS5jbG9uZU5vZGUoITEpO3Euc2V0QXR0cmlidXRlKCJzcmMiLEVkaXRvci5lZGl0SW1hZ2UpO3Euc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJlZGl0IikpO20uaW5zZXJ0QmVmb3JlKHEsbS5maXJzdENoaWxkKTtteEV2ZW50LmFkZExpc3RlbmVyKHEsImNsaWNrIixFKTtteEV2ZW50LmFkZExpc3RlbmVyKG4sImRibGNsaWNrIixmdW5jdGlvbihhKXtteEV2ZW50LmdldFNvdXJjZShhKT09Cm4mJkUoYSl9KTtmPXEuY2xvbmVOb2RlKCExKTtmLnNldEF0dHJpYnV0ZSgic3JjIixFZGl0b3IucGx1c0ltYWdlKTtmLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiYWRkIikpO20uaW5zZXJ0QmVmb3JlKGYsbS5maXJzdENoaWxkKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsImNsaWNrIixIKTt0aGlzLmlzT2ZmbGluZSgpfHwiLnNjcmF0Y2hwYWQiIT1hLnRpdGxlfHxudWxsPT1FZGl0b3JVaS5zY3JhdGNocGFkSGVscExpbmt8fChmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKSxmLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiaGVscCIpKSxmLnN0eWxlLmNzc1RleHQ9ImNvbG9yOiNhM2EzYTM7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bWFyZ2luLXJpZ2h0OjJweDsiLG14VXRpbHMud3JpdGUoZiwiPyIpLG14RXZlbnQuYWRkR2VzdHVyZUxpc3RlbmVycyhmLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMub3BlbkxpbmsoRWRpdG9yVWkuc2NyYXRjaHBhZEhlbHBMaW5rKTsKbXhFdmVudC5jb25zdW1lKGEpfSkpLG0uaW5zZXJ0QmVmb3JlKGYsbS5maXJzdENoaWxkKSl9ay5hcHBlbmRDaGlsZChtKTtrLnN0eWxlLnBhZGRpbmdSaWdodD0xOCptLmNoaWxkTm9kZXMubGVuZ3RoKyJweCJ9fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkTGlicmFyeUVudHJpZXM9ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGU9YVtiXSxkPWUuZGF0YTtpZihudWxsIT1kKXt2YXIgZD10aGlzLmNvbnZlcnREYXRhVXJpKGQpLGY9InNoYXBlPWltYWdlO3ZlcnRpY2FsTGFiZWxQb3NpdGlvbj1ib3R0b207dmVydGljYWxBbGlnbj10b3A7aW1hZ2VBc3BlY3Q9MDsiOyJmaXhlZCI9PWUuYXNwZWN0JiYoZis9ImFzcGVjdD1maXhlZDsiKTtjLmFwcGVuZENoaWxkKHRoaXMuc2lkZWJhci5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZShmKyJpbWFnZT0iK2QsZS53LGUuaCwiIixlLnRpdGxlfHwiIiwhMSwhMSwhMCkpfWVsc2UgbnVsbCE9ZS54bWwmJihkPXRoaXMuc3RyaW5nVG9DZWxscyhHcmFwaC5kZWNvbXByZXNzKGUueG1sKSksCjA8ZC5sZW5ndGgmJmMuYXBwZW5kQ2hpbGQodGhpcy5zaWRlYmFyLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKGQsZS53LGUuaCxlLnRpdGxlfHwiIiwhMCwhMSwhMCkpKX19O0VkaXRvclVpLnByb3RvdHlwZS5nZXRSZXNvdXJjZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YT9hW214TGFuZ3VhZ2VdfHxhLm1haW46bnVsbH07RWRpdG9yVWkucHJvdG90eXBlLmZvb3RlckhlaWdodD0wOyIxIj09dXJsUGFyYW1zLnNhdmVzaWRlYmFyJiYoU2lkZWJhci5wcm90b3R5cGUudGh1bWJXaWR0aD02NCxTaWRlYmFyLnByb3RvdHlwZS50aHVtYkhlaWdodD02NCk7RWRpdG9yVWkuaW5pdFRoZW1lPWZ1bmN0aW9uKCl7ImF0bGFzIj09dWlUaGVtZT8obXhDbGllbnQubGluaygic3R5bGVzaGVldCIsU1RZTEVfUEFUSCsiL2F0bGFzLmNzcyIpLCJ1bmRlZmluZWQiIT09dHlwZW9mIFRvb2xiYXImJihUb29sYmFyLnByb3RvdHlwZS51bnNlbGVjdGVkQmFja2dyb3VuZD1teENsaWVudC5JU19RVUlSS1M/CiJub25lIjoibGluZWFyLWdyYWRpZW50KHJnYigyNTUsIDI1NSwgMjU1KSAwcHgsIHJnYigyNDIsIDI0MiwgMjQyKSAxMDAlKSIsVG9vbGJhci5wcm90b3R5cGUuc2VsZWN0ZWRCYWNrZ3JvdW5kPSJyZ2IoMjQyLCAyNDIsIDI0MikiKSxFZGl0b3IucHJvdG90eXBlLmluaXRpYWxUb3BTcGFjaW5nPTMsRWRpdG9yVWkucHJvdG90eXBlLm1lbnViYXJIZWlnaHQ9NDEsRWRpdG9yVWkucHJvdG90eXBlLnRvb2xiYXJIZWlnaHQ9MzgpOiJkYXJrIj09dWlUaGVtZSYmKG14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLFNUWUxFX1BBVEgrIi9kYXJrLmNzcyIpLERpYWxvZy5iYWNrZHJvcENvbG9yPSIjMmEyYTJhIixHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lTmFtZT0iZGFya1RoZW1lIixHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFBhZ2VCYWNrZ3JvdW5kQ29sb3I9IiMyYTJhMmEiLEdyYXBoLnByb3RvdHlwZS5kZWZhdWx0UGFnZUJvcmRlckNvbG9yPSIjNTA1NzU5IixGb3JtYXQucHJvdG90eXBlLmluYWN0aXZlVGFiQmFja2dyb3VuZENvbG9yPQoiYmxhY2siLEJhc2VGb3JtYXRQYW5lbC5wcm90b3R5cGUuYnV0dG9uQmFja2dyb3VuZENvbG9yPSIjMmEyYTJhIixTaWRlYmFyLnByb3RvdHlwZS5kcmFnUHJldmlld0JvcmRlcj0iMXB4IGRhc2hlZCAjY2NjY2NjIixteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucHJldmlld0NvbG9yPSIjY2NjY2NjIixTdHlsZUZvcm1hdFBhbmVsLnByb3RvdHlwZS5kZWZhdWx0U3Ryb2tlQ29sb3I9IiNjY2NjY2MiLG14Q29uc3RhbnRzLkRST1BfVEFSR0VUX0NPTE9SPSIjMDBmZjAwIixteENsaWVudC5JU19TVkcmJihFZGl0b3IuaGVscEltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFBUDFCTVZFVUFBQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOUR1L3BxQUFBQUZYUlNUbE1BVDMwcUNKUkJib3lEWnlDZ1J6VVVkRjQ2TUpsZ1hFVGdBQUFBZWtsRVFWUVkwMjJPMnc0RElRaEVRVVVSZGEvOS8yOHRVTzIrN0NRUzVzZ1E0RjFSYXBYNzhZVXdScVFqVFU4SUxxUWZLZXJUS1R2QUNKNG5MWDNrcnQrOGFTODJvSThhUUM0S2F2Umd0dkVXL21EdnNJQ2dBMDNQU0dScjc5TXFYMVlQTkl4emp5cXR3OFpublJvNHQ1YTV1bmR0SllSeXdhdStkczRDeXphM0U2WUFBQUFBU1VWT1JLNUNZSUk9IiwKRWRpdG9yLmNoZWNrbWFya0ltYWdlPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJVQUFBQVZDQU1BQUFDZXlWV2tBQUFBUlZCTVZFVUFBQUNabVprSUNBZ0VCQVNOalkyRGc0TVlHQmlUazVONWVYbDFkWFZtWm1aUVVGQkNRa0kzTnpjZUhoNE1EQXlrcEtTSmlZbCtmbjVzYkd4YVdsby9QejhTRWhLOTZ1UGxBQUFBQVhSU1RsTUFRT2JZWmdBQUFFNUpSRUZVR05QRnpUY1NnREFRUTFISkdVZnkvWTlLN1YxcWVPVWZ6UWlmQ1FaYWkxWEhhejExTEZ5c2JEYnpnRFNTV01aaUVUejMrYjh5TlVjL01Nc2t0eHVDOFhRQlNuY2RMd3orOGdDQ2dnR1h6QmNvekFBQUFBQkpSVTVFcmtKZ2dnPT0iKSl9O0VkaXRvclVpLmluaXRUaGVtZSgpO0VkaXRvclVpLnByb3RvdHlwZS5zaG93SW1hZ2VEaWFsb2c9ZnVuY3Rpb24oYSxjLGQsZixsKXthPW5ldyBJbWFnZURpYWxvZyh0aGlzLGEsYyxkLGYsbCk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLEdyYXBoLmZpbGVTdXBwb3J0Pwo0ODA6MzYwLEdyYXBoLmZpbGVTdXBwb3J0PzIwMDo5MCwhMCwhMCk7YS5pbml0KCl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93QmFja2dyb3VuZEltYWdlRGlhbG9nPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2E9bmV3IENoYW5nZVBhZ2VTZXR1cCh0aGlzLG51bGwsYSk7YS5pZ25vcmVDb2xvcj0hMDt0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5leGVjdXRlKGEpfSk7dmFyIGI9bmV3IEJhY2tncm91bmRJbWFnZURpYWxvZyh0aGlzLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2EoYil9KSk7dGhpcy5zaG93RGlhbG9nKGIuY29udGFpbmVyLDM2MCwyMDAsITAsITApO2IuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd0xpYnJhcnlEaWFsb2c9ZnVuY3Rpb24oYSxjLGQsZixsKXthPW5ldyBMaWJyYXJ5RGlhbG9nKHRoaXMsYSxjLGQsZixsKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsNjQwLDQ0MCwhMCwhMSwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YSYmbnVsbD09dGhpcy5nZXRDdXJyZW50RmlsZSgpJiYiMSIhPXVybFBhcmFtcy5lbWJlZCYmdGhpcy5zaG93U3BsYXNoKCl9KSk7YS5pbml0KCl9O3ZhciBjPUVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVGb3JtYXQ7RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUZvcm1hdD1mdW5jdGlvbihhKXt2YXIgYj1jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmVkaXRvci5ncmFwaC5hZGRMaXN0ZW5lcigidmlld1N0YXRlQ2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5lZGl0b3IuZ3JhcGguaXNTZWxlY3Rpb25FbXB0eSgpJiZiLnJlZnJlc2goKX0pKTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVNpZGViYXJGb290ZXJDb250YWluZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNyZWF0ZURpdigiZ2VTaWRlYmFyQ29udGFpbmVyIGdlU2lkZWJhckZvb3RlciIpO2Euc3R5bGUucG9zaXRpb249CiJhYnNvbHV0ZSI7YS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7Yy5jbGFzc05hbWU9ImdlVGl0bGUiO2Muc3R5bGUuY29sb3I9IiNERjZDMEMiO2Muc3R5bGUuZm9udFdlaWdodD0iYm9sZCI7Yy5zdHlsZS5oZWlnaHQ9IjEwMCUiO2Muc3R5bGUucGFkZGluZ1RvcD0iOXB4IjtjLmlubmVySFRNTD0nPHNwYW4gc3R5bGU9ImZvbnQtc2l6ZToxOHB4O21hcmdpbi1yaWdodDo1cHg7Ij4rPC9zcGFuPic7bXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgibW9yZVNoYXBlcyIpKyIuLi4iKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcmRvd24iOiJtb3VzZWRvd24iLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmFjdGlvbnMuZ2V0KCJzaGFwZXMiKS5mdW5jdCgpOwpteEV2ZW50LmNvbnN1bWUoYSl9KSk7YS5hcHBlbmRDaGlsZChjKTtyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZUVycm9yPWZ1bmN0aW9uKGEsYyxkLGYsbCxwLGspe3ZhciBiPW51bGwhPXRoaXMuc3Bpbm5lciYmbnVsbCE9dGhpcy5zcGlubmVyLnBhdXNlP3RoaXMuc3Bpbm5lci5wYXVzZSgpOmZ1bmN0aW9uKCl7fSxlPW51bGwhPWEmJm51bGwhPWEuZXJyb3I/YS5lcnJvcjphO2lmKG51bGwhPWEmJm51bGwhPWEuc3RhY2smJm51bGwhPWEubWVzc2FnZSl0cnl7az9udWxsIT13aW5kb3cuY29uc29sZSYmY29uc29sZS5lcnJvcigiRWRpdG9yVWkuaGFuZGxlRXJyb3I6IixhKTpFZGl0b3JVaS5sb2dFcnJvcigiQ2F1Z2h0OiAiKyhudWxsIT1hLm1lc3NhZ2U/YS5tZXNzYWdlOiJudWxsIiksbnVsbCxudWxsLG51bGwsYSwiSU5GTyIpfWNhdGNoKHope31pZihudWxsIT1lfHxudWxsIT1jKXtrPW14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgidW5rbm93bkVycm9yIikpOwp2YXIgZz1teFJlc291cmNlcy5nZXQoIm9rIiksbj1udWxsO2M9bnVsbCE9Yz9jOm14UmVzb3VyY2VzLmdldCgiZXJyb3IiKTtpZihudWxsIT1lKXtudWxsIT1lLnJldHJ5JiYoZz1teFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG49ZnVuY3Rpb24oKXtiKCk7ZS5yZXRyeSgpfSk7aWYoNDA0PT1lLmNvZGV8fDQwND09ZS5zdGF0dXN8fDQwMz09ZS5jb2RlKXtrPTQwMz09ZS5jb2RlP251bGwhPWUubWVzc2FnZT9teFV0aWxzLmh0bWxFbnRpdGllcyhlLm1lc3NhZ2UpOm14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiYWNjZXNzRGVuaWVkIikpOm51bGwhPWw/bDpteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImZpbGVOb3RGb3VuZE9yRGVuaWVkIikrKG51bGwhPXRoaXMuZHJpdmUmJm51bGwhPXRoaXMuZHJpdmUudXNlcj8iICgiK3RoaXMuZHJpdmUudXNlci5kaXNwbGF5TmFtZSsiLCAiK3RoaXMuZHJpdmUudXNlci5lbWFpbCsiKSI6IiIpKTt2YXIgbT0KbnVsbCE9cD9wOndpbmRvdy5sb2NhdGlvbi5oYXNoO2lmKG51bGwhPW0mJigiI0ciPT1tLnN1YnN0cmluZygwLDIpfHwiI1VodHRwcyUzQSUyRiUyRmRyaXZlLmdvb2dsZS5jb20lMkZ1YyUzRmlkJTNEIj09bS5zdWJzdHJpbmcoMCw0NSkpJiYobnVsbCE9YSYmbnVsbCE9YS5lcnJvciYmKG51bGwhPWEuZXJyb3IuZXJyb3JzJiYwPGEuZXJyb3IuZXJyb3JzLmxlbmd0aCYmImZpbGVBY2Nlc3MiPT1hLmVycm9yLmVycm9yc1swXS5yZWFzb258fG51bGwhPWEuZXJyb3IuZGF0YSYmMDxhLmVycm9yLmRhdGEubGVuZ3RoJiYiZmlsZUFjY2VzcyI9PWEuZXJyb3IuZGF0YVswXS5yZWFzb24pfHw0MDQ9PWUuY29kZXx8NDA0PT1lLnN0YXR1cykpe209IiNVIj09bS5zdWJzdHJpbmcoMCwyKT9tLnN1YnN0cmluZyg0NSxtLmxhc3RJbmRleE9mKCIlMjZleCIpKTptLnN1YnN0cmluZygyKTt0aGlzLnNob3dFcnJvcihjLGssbXhSZXNvdXJjZXMuZ2V0KCJvcGVuSW5OZXdXaW5kb3ciKSxteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oKXt0aGlzLmVkaXRvci5ncmFwaC5vcGVuTGluaygiaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL29wZW4/aWQ9IittKTt0aGlzLmhhbmRsZUVycm9yKGEsYyxkLGYsbCl9KSxuLG14UmVzb3VyY2VzLmdldCgiY2hhbmdlVXNlciIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe2QuaW5uZXJIVE1MPSIiO2Zvcih2YXIgYT0wO2E8Yi5sZW5ndGg7YSsrKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtteFV0aWxzLndyaXRlKGMsYlthXS5kaXNwbGF5TmFtZSk7Yy52YWx1ZT1hO2QuYXBwZW5kQ2hpbGQoYyk7Yz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtjLmlubmVySFRNTD0iJm5ic3A7Jm5ic3A7Jm5ic3A7IjtteFV0aWxzLndyaXRlKGMsIjwiK2JbYV0uZW1haWwrIj4iKTtjLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpO2QuYXBwZW5kQ2hpbGQoYyl9Yz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTsKbXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgiYWRkQWNjb3VudCIpKTtjLnZhbHVlPWIubGVuZ3RoO2QuYXBwZW5kQ2hpbGQoYyl9dmFyIGI9dGhpcy5kcml2ZS5nZXRVc2Vyc0xpc3QoKSxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO2Uuc3R5bGUubWFyZ2luVG9wPSI2cHgiO214VXRpbHMud3JpdGUoZSxteFJlc291cmNlcy5nZXQoImNoYW5nZVVzZXIiKSsiOiAiKTtjLmFwcGVuZENoaWxkKGUpO3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNlbGVjdCIpO2Quc3R5bGUud2lkdGg9IjIwMHB4IjthKCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjaGFuZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGM9ZC52YWx1ZSxlPWIubGVuZ3RoIT1jO2UmJnRoaXMuZHJpdmUuc2V0VXNlcihiW2NdKTt0aGlzLmRyaXZlLmF1dGhvcml6ZShlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZXx8CihiPXRoaXMuZHJpdmUuZ2V0VXNlcnNMaXN0KCksYSgpKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxlRXJyb3IoYSl9KSwhMCl9KSk7Yy5hcHBlbmRDaGlsZChkKTtjPW5ldyBDdXN0b21EaWFsb2codGhpcyxjLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5sb2FkRmlsZSh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSksITApfSkpO3RoaXMuc2hvd0RpYWxvZyhjLmNvbnRhaW5lciwzMDAsNzUsITAsITApfSksbXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpO251bGwhPWQmJmQoKX0pLDQ4MCwxNTApO3JldHVybn19bnVsbCE9ZS5tZXNzYWdlP2s9bXhVdGlscy5odG1sRW50aXRpZXMoZS5tZXNzYWdlKTpudWxsIT1lLnJlc3BvbnNlJiZudWxsIT1lLnJlc3BvbnNlLmVycm9yP2s9bXhVdGlscy5odG1sRW50aXRpZXMoZS5yZXNwb25zZS5lcnJvcik6InVuZGVmaW5lZCIhPT0KdHlwZW9mIHdpbmRvdy5BcHAmJihlLmNvZGU9PUFwcC5FUlJPUl9USU1FT1VUP2s9bXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJ0aW1lb3V0IikpOmUuY29kZT09QXBwLkVSUk9SX0JVU1kmJihrPW14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiYnVzeSIpKSkpfXZhciB2PXA9bnVsbDtudWxsIT1lJiZudWxsIT1lLmhlbHBMaW5rJiYocD1teFJlc291cmNlcy5nZXQoImhlbHAiKSx2PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRpdG9yLmdyYXBoLm9wZW5MaW5rKGUuaGVscExpbmspfSkpO3RoaXMuc2hvd0Vycm9yKGMsayxnLGQsbixudWxsLG51bGwscCx2LG51bGwsbnVsbCxudWxsLGY/ZDpudWxsKX1lbHNlIG51bGwhPWQmJmQoKX07RWRpdG9yVWkucHJvdG90eXBlLmFsZXJ0PWZ1bmN0aW9uKGEsYyl7dmFyIGI9bmV3IEVycm9yRGlhbG9nKHRoaXMsbnVsbCxhLG14UmVzb3VyY2VzLmdldCgib2siKSxjKTt0aGlzLnNob3dEaWFsb2coYi5jb250YWluZXIsCjM0MCwxMDAsITAsITEpO2IuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUuY29uZmlybT1mdW5jdGlvbihhLGMsZCxmLGwscCl7dmFyIGI9bnVsbCE9dGhpcy5zcGlubmVyJiZudWxsIT10aGlzLnNwaW5uZXIucGF1c2U/dGhpcy5zcGlubmVyLnBhdXNlKCk6ZnVuY3Rpb24oKXt9LGU9TWF0aC5taW4oMjAwLDI4Kk1hdGguY2VpbChhLmxlbmd0aC81MCkpO2E9bmV3IENvbmZpcm1EaWFsb2codGhpcyxhLGZ1bmN0aW9uKCl7YigpO251bGwhPWMmJmMoKX0sZnVuY3Rpb24oKXtiKCk7bnVsbCE9ZCYmZCgpfSxmLGwsbnVsbCxudWxsLG51bGwsbnVsbCxlKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsMzQwLDQ2K2UsITAscCk7YS5pbml0KCl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93QmFubmVyPWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj0hMTtpZighKHRoaXMuYmFubmVyU2hvd2luZ3x8dGhpc1siaGlkZUJhbm5lciIrYV18fGlzTG9jYWxTdG9yYWdlJiZudWxsIT1teFNldHRpbmdzLnNldHRpbmdzJiYKbnVsbCE9bXhTZXR0aW5ncy5zZXR0aW5nc1siY2xvc2UiK2FdKSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZS5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MTBweDtsZWZ0OjUwJTttYXgtd2lkdGg6OTAlO3BhZGRpbmc6MThweCAzNHB4IDEycHggMjBweDtmb250LXNpemU6MTZweDtmb250LXdlaWdodDpib2xkO3doaXRlLXNwYWNlOm5vd3JhcDtjdXJzb3I6cG9pbnRlcjt6LWluZGV4OiIrbXhQb3B1cE1lbnUucHJvdG90eXBlLnpJbmRleCsiOyI7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGUuc3R5bGUsImJveC1zaGFkb3ciLCIxcHggMXB4IDJweCAwcHggI2RkZCIpO214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoLTUwJSwxMjAlKSIpO214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2l0aW9uIiwiYWxsIDFzIGVhc2UiKTtlLmNsYXNzTmFtZT0iZ2VCdG4gZ2VQcmltYXJ5QnRuIjsKYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtiLnNldEF0dHJpYnV0ZSgic3JjIixJTUFHRV9QQVRIKyIvbG9nby5wbmciKTtiLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Iuc2V0QXR0cmlidXRlKCJhbGlnbiIsImFic21pZGRsZSIpO2Iuc3R5bGUuY3NzVGV4dD0ibWFyZ2luLXRvcDotNHB4O21hcmdpbi1sZWZ0OjhweDttYXJnaW4tcmlnaHQ6MTJweDt3aWR0aDoyNnB4O2hlaWdodDoyNnB4OyI7ZS5hcHBlbmRDaGlsZChiKTtiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO2Iuc2V0QXR0cmlidXRlKCJzcmMiLERpYWxvZy5wcm90b3R5cGUuY2xvc2VJbWFnZSk7Yi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImNsb3NlIikpO2Iuc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIik7Yi5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxMHB4O3RvcDoxMnB4O2ZpbHRlcjppbnZlcnQoMSk7cGFkZGluZzo2cHg7bWFyZ2luOi02cHg7Y3Vyc29yOmRlZmF1bHQ7IjsKZS5hcHBlbmRDaGlsZChiKTtteFV0aWxzLndyaXRlKGUsYyk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTt0aGlzLmJhbm5lclNob3dpbmc9ITA7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zi5zdHlsZS5jc3NUZXh0PSJmb250LXNpemU6MTFweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDpub3JtYWw7Ijt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO2cuc2V0QXR0cmlidXRlKCJ0eXBlIiwiY2hlY2tib3giKTtnLnNldEF0dHJpYnV0ZSgiaWQiLCJnZURvTm90U2hvd0FnYWluQ2hlY2tib3giKTtnLnN0eWxlLm1hcmdpblJpZ2h0PSI2cHgiO2YuYXBwZW5kQ2hpbGQoZyk7Yz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJsYWJlbCIpO2Muc2V0QXR0cmlidXRlKCJmb3IiLCJnZURvTm90U2hvd0FnYWluQ2hlY2tib3giKTtteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KCJkb05vdFNob3dBZ2FpbiIpKTtmLmFwcGVuZENoaWxkKGMpOwplLnN0eWxlLnBhZGRpbmdCb3R0b209IjMwcHgiO2UuYXBwZW5kQ2hpbGQoZik7dmFyIGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7bnVsbCE9ZS5wYXJlbnROb2RlJiYoZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLHRoaXMuYmFubmVyU2hvd2luZz0hMSxnLmNoZWNrZWQmJih0aGlzWyJoaWRlQmFubmVyIithXT0hMCxpc0xvY2FsU3RvcmFnZSYmbnVsbCE9bXhTZXR0aW5ncy5zZXR0aW5ncyYmKG14U2V0dGluZ3Muc2V0dGluZ3NbImNsb3NlIithXT1EYXRlLm5vdygpLG14U2V0dGluZ3Muc2F2ZSgpKSkpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bXhFdmVudC5jb25zdW1lKGEpO2soKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGUsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldFNvdXJjZShhKTtiIT1nJiZiIT1jJiYobXhFdmVudC5jb25zdW1lKGEpLApkKCksaygpKX0pKTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2Zvcm0iLCJ0cmFuc2xhdGUoLTUwJSwwJSkiKX0pLDUwMCk7d2luZG93LnNldFRpbWVvdXQobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoZS5zdHlsZSwidHJhbnNmb3JtIiwidHJhbnNsYXRlKC01MCUsMTIwJSkiKTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2soITApfSksMUUzKX0pLDNFNCk7Yj0hMH1yZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLnNldEN1cnJlbnRGaWxlPWZ1bmN0aW9uKGEpe251bGwhPWEmJihhLm9wZW5lZD1uZXcgRGF0ZSk7dGhpcy5jdXJyZW50RmlsZT1hfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0Q3VycmVudEZpbGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50RmlsZX07RWRpdG9yVWkucHJvdG90eXBlLmlzRXhwb3J0VG9DYW52YXM9CmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRpdG9yLmlzRXhwb3J0VG9DYW52YXMoKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUltYWdlRGF0YVVyaT1mdW5jdGlvbihhLGMsZCxmKXt2YXIgYj1hLnRvRGF0YVVSTCgiaW1hZ2UvIitkKTtpZig2Pj1iLmxlbmd0aHx8Yj09YS5jbG9uZU5vZGUoITEpLnRvRGF0YVVSTCgiaW1hZ2UvIitkKSl0aHJvd3ttZXNzYWdlOiJJbnZhbGlkIGltYWdlIn07bnVsbCE9YyYmKGI9RWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGIsInRFWHQiLCJteGZpbGUiLGVuY29kZVVSSUNvbXBvbmVudChjKSkpOzA8ZiYmKGI9RWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGIsInBIWXMiLCJkcGkiLGYpKTtyZXR1cm4gYn07RWRpdG9yVWkucHJvdG90eXBlLnNhdmVDYW52YXM9ZnVuY3Rpb24oYSxjLGQsZixsKXt2YXIgYj0ianBlZyI9PWQ/ImpwZyI6ZDtmPXRoaXMuZ2V0QmFzZUZpbGVuYW1lKGYpKyIuIitiO2E9dGhpcy5jcmVhdGVJbWFnZURhdGFVcmkoYSwKYyxkLGwpO3RoaXMuc2F2ZURhdGEoZixiLGEuc3Vic3RyaW5nKGEubGFzdEluZGV4T2YoIiwiKSsxKSwiaW1hZ2UvIitkLCEwKX07RWRpdG9yVWkucHJvdG90eXBlLmlzTG9jYWxGaWxlU2F2ZT1mdW5jdGlvbigpe3JldHVybiJyZW1vdGUiIT11cmxQYXJhbXMuc2F2ZSYmKG14Q2xpZW50LklTX0lFfHwidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cuQmxvYiYmInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93LlVSTCkmJjkhPWRvY3VtZW50LmRvY3VtZW50TW9kZSYmOCE9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlJiY3IT1kb2N1bWVudC5kb2N1bWVudE1vZGUmJiFteENsaWVudC5JU19RVUlSS1N8fHRoaXMuaXNPZmZsaW5lQXBwKCl8fG14Q2xpZW50LklTX0lPU307RWRpdG9yVWkucHJvdG90eXBlLnNob3dUZXh0RGlhbG9nPWZ1bmN0aW9uKGEsYyl7dmFyIGI9bmV3IFRleHRhcmVhRGlhbG9nKHRoaXMsYSxjLG51bGwsbnVsbCxteFJlc291cmNlcy5nZXQoImNsb3NlIikpO2IudGV4dGFyZWEuc3R5bGUud2lkdGg9CiI2MDBweCI7Yi50ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9IjM4MHB4Ijt0aGlzLnNob3dEaWFsb2coYi5jb250YWluZXIsNjIwLDQ2MCwhMCwhMCxudWxsLG51bGwsbnVsbCxudWxsLCEwKTtiLmluaXQoKTtkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0YWxsIiwhMSxudWxsKX07RWRpdG9yVWkucHJvdG90eXBlLmRvU2F2ZUxvY2FsRmlsZT1mdW5jdGlvbihhLGMsZCxmLGwpeyJ0ZXh0L3htbCIhPWR8fC8oXC5kcmF3aW8pJC9pLnRlc3QoYyl8fC8oXC54bWwpJC9pLnRlc3QoYyl8fChjKz0iLmRyYXdpbyIpO2lmKHdpbmRvdy5CbG9iJiZuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYilhPWY/dGhpcy5iYXNlNjRUb0Jsb2IoYSxkKTpuZXcgQmxvYihbYV0se3R5cGU6ZH0pLG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGEsYyk7ZWxzZSBpZihteENsaWVudC5JU19JRSlkPXdpbmRvdy5vcGVuKCJhYm91dDpibGFuayIsIl9ibGFuayIpLG51bGw9PWQ/bXhVdGlscy5wb3B1cChhLCEwKToKKGQuZG9jdW1lbnQud3JpdGUoYSksZC5kb2N1bWVudC5jbG9zZSgpLGQuZG9jdW1lbnQuZXhlY0NvbW1hbmQoIlNhdmVBcyIsITAsYyksZC5jbG9zZSgpKTtlbHNlIGlmKG14Q2xpZW50LklTX0lPUyYmdGhpcy5pc09mZmxpbmUoKSluYXZpZ2F0b3Iuc3RhbmRhbG9uZXx8bnVsbD09ZHx8ImltYWdlLyIhPWQuc3Vic3RyaW5nKDAsNik/dGhpcy5zaG93VGV4dERpYWxvZyhjKyI6IixhKTp0aGlzLm9wZW5Jbk5ld1dpbmRvdyhhLGQsZik7ZWxzZXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIiksZT0obnVsbD09bmF2aWdhdG9yLnVzZXJBZ2VudHx8MD5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIlBhbGVNb29uLyIpKSYmIW14Q2xpZW50LklTX0lPUyYmInVuZGVmaW5lZCIhPT10eXBlb2YgYi5kb3dubG9hZDtpZihteENsaWVudC5JU19HQyYmbnVsbCE9bmF2aWdhdG9yLnVzZXJBZ2VudCl2YXIgZz1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbShlfGl1bSlcLyhbMC05XSspXC4vKSwKZT02NT09KGc/cGFyc2VJbnQoZ1syXSwxMCk6ITEpPyExOmU7aWYoZXx8dGhpcy5pc09mZmxpbmUoKSl7Yi5ocmVmPVVSTC5jcmVhdGVPYmplY3RVUkwoZj90aGlzLmJhc2U2NFRvQmxvYihhLGQpOm5ldyBCbG9iKFthXSx7dHlwZTpkfSkpO2U/Yi5kb3dubG9hZD1jOmIuc2V0QXR0cmlidXRlKCJ0YXJnZXQiLCJfYmxhbmsiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpO3RyeXt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1VSTC5yZXZva2VPYmplY3RVUkwoYi5ocmVmKX0sMCksYi5jbGljaygpLGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKX1jYXRjaCh5KXt9fWVsc2UgdGhpcy5jcmVhdGVFY2hvUmVxdWVzdChhLGMsZCxmLGwpLnNpbXVsYXRlKGRvY3VtZW50LCJfYmxhbmsiKX19O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVFY2hvUmVxdWVzdD1mdW5jdGlvbihhLGMsZCxmLGwscCl7YT0ieG1sPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpO3JldHVybiBuZXcgbXhYbWxSZXF1ZXN0KFNBVkVfVVJMLAphKyhudWxsIT1kPyImbWltZT0iK2Q6IiIpKyhudWxsIT1sPyImZm9ybWF0PSIrbDoiIikrKG51bGwhPXA/IiZiYXNlNjQ9IitwOiIiKSsobnVsbCE9Yz8iJmZpbGVuYW1lPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpOiIiKSsoZj8iJmJpbmFyeT0xIjoiIikpfTtFZGl0b3JVaS5wcm90b3R5cGUuYmFzZTY0VG9CbG9iPWZ1bmN0aW9uKGEsYyl7Yz1jfHwiIjtmb3IodmFyIGI9YXRvYihhKSxlPWIubGVuZ3RoLGQ9TWF0aC5jZWlsKGUvMTAyNCksZj1BcnJheShkKSxrPTA7azxkOysrayl7Zm9yKHZhciBtPTEwMjQqayx5PU1hdGgubWluKG0rMTAyNCxlKSx4PUFycmF5KHktbSkscT0wO208eTsrK3EsKyttKXhbcV09YlttXS5jaGFyQ29kZUF0KDApO2Zba109bmV3IFVpbnQ4QXJyYXkoeCl9cmV0dXJuIG5ldyBCbG9iKGYse3R5cGU6Y30pfTtFZGl0b3JVaS5wcm90b3R5cGUuc2F2ZUxvY2FsRmlsZT1mdW5jdGlvbihhLGMsZCxmLGwscCxrKXtwPW51bGwhPXA/cDohMTtrPW51bGwhPWs/azoKInZzZHgiIT1sJiYoIW14Q2xpZW50LklTX0lPU3x8IW5hdmlnYXRvci5zdGFuZGFsb25lKTtsPXRoaXMuZ2V0U2VydmljZUNvdW50KHApO2lzTG9jYWxTdG9yYWdlJiZsKys7dmFyIGI9ND49bD8yOjY8bD80OjM7Yz1uZXcgQ3JlYXRlRGlhbG9nKHRoaXMsYyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGMpe3RyeXtpZigiX2JsYW5rIj09YylpZihudWxsIT1kJiYiaW1hZ2UvIj09ZC5zdWJzdHJpbmcoMCw2KSl0aGlzLm9wZW5Jbk5ld1dpbmRvdyhhLGQsZik7ZWxzZXt2YXIgZT13aW5kb3cub3BlbigiYWJvdXQ6YmxhbmsiKTtudWxsPT1lP214VXRpbHMucG9wdXAoYSwhMCk6KGUuZG9jdW1lbnQud3JpdGUoIjxwcmU+IitteFV0aWxzLmh0bWxFbnRpdGllcyhhLCExKSsiPC9wcmU+IiksZS5kb2N1bWVudC5jbG9zZSgpKX1lbHNlIGM9PUFwcC5NT0RFX0RFVklDRXx8ImRvd25sb2FkIj09Yz90aGlzLmRvU2F2ZUxvY2FsRmlsZShhLGIsZCxmKTpudWxsIT1iJiYwPGIubGVuZ3RoJiYKdGhpcy5waWNrRm9sZGVyKGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7dHJ5e3RoaXMuZXhwb3J0RmlsZShhLGIsZCxmLGMsZSl9Y2F0Y2goRCl7dGhpcy5oYW5kbGVFcnJvcihEKX19KSl9Y2F0Y2goQil7dGhpcy5oYW5kbGVFcnJvcihCKX19KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpfSksbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQXMiKSxteFJlc291cmNlcy5nZXQoImRvd25sb2FkIiksITEscCxrLG51bGwsMTxsLGIsYSxkLGYpO3A9dGhpcy5pc1NlcnZpY2VzKGwpP2w+Yj8zOTA6MjcwOjE2MDt0aGlzLnNob3dEaWFsb2coYy5jb250YWluZXIsNDAwLHAsITAsITApO2MuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUub3BlbkluTmV3V2luZG93PWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj13aW5kb3cub3BlbigiYWJvdXQ6YmxhbmsiKTtudWxsPT1ifHxudWxsPT1iLmRvY3VtZW50P214VXRpbHMucG9wdXAoYSwhMCk6KCJpbWFnZS9zdmcreG1sIiE9CmN8fG14Q2xpZW50LklTX1NWRz8iaW1hZ2Uvc3ZnK3htbCI9PWM/Yi5kb2N1bWVudC53cml0ZSgiPGh0bWw+IithKyI8L2h0bWw+Iik6KGE9ZD9hOmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGEpKSksYi5kb2N1bWVudC53cml0ZSgnPGh0bWw+PGltZyBzdHlsZT0ibWF4LXdpZHRoOjEwMCU7IiBzcmM9ImRhdGE6JytjKyI7YmFzZTY0LCIrYSsnIi8+PC9odG1sPicpKTpiLmRvY3VtZW50LndyaXRlKCI8aHRtbD48cHJlPiIrbXhVdGlscy5odG1sRW50aXRpZXMoYSwhMSkrIjwvcHJlPjwvaHRtbD4iKSxiLmRvY3VtZW50LmNsb3NlKCkpfTt2YXIgZj1FZGl0b3JVaS5wcm90b3R5cGUuYWRkQ2hyb21lbGVzc1Rvb2xiYXJJdGVtcztFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ2hyb21lbGVzc1Rvb2xiYXJJdGVtcz1mdW5jdGlvbihhKXtpZih0aGlzLmlzRXhwb3J0VG9DYW52YXMoKSl7dGhpcy5leHBvcnREaWFsb2c9bnVsbDt2YXIgYj1hKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBjPQpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe214RXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5lZGl0b3IuZ3JhcGguY29udGFpbmVyLCJjbGljayIsYyk7bnVsbCE9dGhpcy5leHBvcnREaWFsb2cmJih0aGlzLmV4cG9ydERpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZXhwb3J0RGlhbG9nKSx0aGlzLmV4cG9ydERpYWxvZz1udWxsKX0pO2lmKG51bGwhPXRoaXMuZXhwb3J0RGlhbG9nKWMuYXBwbHkodGhpcyk7ZWxzZXt0aGlzLmV4cG9ydERpYWxvZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt2YXIgZT1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO214VXRpbHMuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmV4cG9ydERpYWxvZy5zdHlsZSwiYm9yZGVyUmFkaXVzIiwiNXB4Iik7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUucG9zaXRpb249ImZpeGVkIjt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuZm9udEZhbWlseT0KIkhlbHZldGljYSxBcmlhbCI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjMDAwMDAwIjt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS53aWR0aD0iNTBweCI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuaGVpZ2h0PSI1MHB4Ijt0aGlzLmV4cG9ydERpYWxvZy5zdHlsZS5wYWRkaW5nPSI0cHggMnB4IDRweCAycHgiO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLmNvbG9yPSIjZmZmZmZmIjtteFV0aWxzLnNldE9wYWNpdHkodGhpcy5leHBvcnREaWFsb2csNzApO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLmxlZnQ9ZS5sZWZ0KyJweCI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUuYm90dG9tPXBhcnNlSW50KHRoaXMuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuYm90dG9tKSt0aGlzLmNocm9tZWxlc3NUb29sYmFyLm9mZnNldEhlaWdodCs0KyJweCI7ZT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZSh0aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIpO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLnpJbmRleD0KZS56SW5kZXg7dmFyIGQ9bmV3IFNwaW5uZXIoe2xpbmVzOjgsbGVuZ3RoOjYsd2lkdGg6NSxyYWRpdXM6Nixyb3RhdGU6MCxjb2xvcjoiI2ZmZiIsc3BlZWQ6MS41LHRyYWlsOjYwLHNoYWRvdzohMSxod2FjY2VsOiExLHRvcDoiMjhweCIsekluZGV4OjJFOX0pO2Quc3Bpbih0aGlzLmV4cG9ydERpYWxvZyk7dGhpcy5lZGl0b3IuZXhwb3J0VG9DYW52YXMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ZC5zdG9wKCk7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUud2lkdGg9ImF1dG8iO3RoaXMuZXhwb3J0RGlhbG9nLnN0eWxlLmhlaWdodD0iYXV0byI7dGhpcy5leHBvcnREaWFsb2cuc3R5bGUucGFkZGluZz0iMTBweCI7dmFyIGI9dGhpcy5jcmVhdGVJbWFnZURhdGFVcmkoYSxudWxsLCJwbmciKTthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO2Euc3R5bGUubWF4V2lkdGg9IjE0MHB4IjthLnN0eWxlLm1heEhlaWdodD0iMTQwcHgiO2Euc3R5bGUuY3Vyc29yPSJwb2ludGVyIjsKYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IndoaXRlIjthLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgib3BlbkluTmV3V2luZG93IikpO2Euc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIik7YS5zZXRBdHRyaWJ1dGUoInNyYyIsYik7dGhpcy5leHBvcnREaWFsb2cuYXBwZW5kQ2hpbGQoYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihhLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLm9wZW5Jbk5ld1dpbmRvdyhiLnN1YnN0cmluZyhiLmluZGV4T2YoIiwiKSsxKSwiaW1hZ2UvcG5nIiwhMCk7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSl9KSxudWxsLHRoaXMudGh1bWJJbWFnZUNhY2hlLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zcGlubmVyLnN0b3AoKTt0aGlzLmhhbmRsZUVycm9yKGEpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5lZGl0b3IuZ3JhcGguY29udGFpbmVyLCJjbGljayIsYyk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmV4cG9ydERpYWxvZyl9bXhFdmVudC5jb25zdW1lKGEpfSksCkVkaXRvci5jYW1lcmFMYXJnZUltYWdlLG14UmVzb3VyY2VzLmdldCgiZXhwb3J0IikpfWYuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2F2ZURhdGE9ZnVuY3Rpb24oYSxjLGQsZixsKXt0aGlzLmlzTG9jYWxGaWxlU2F2ZSgpP3RoaXMuc2F2ZUxvY2FsRmlsZShkLGEsZixsLGMpOnRoaXMuc2F2ZVJlcXVlc3QoYSxjLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuY3JlYXRlRWNob1JlcXVlc3QoZCxhLGYsbCxjLGIpfSksZCxsLGYpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2F2ZVJlcXVlc3Q9ZnVuY3Rpb24oYSxjLGQsZixsLHAsayl7az1udWxsIT1rP2s6IW14Q2xpZW50LklTX0lPU3x8IW5hdmlnYXRvci5zdGFuZGFsb25lO3ZhciBiPXRoaXMuZ2V0U2VydmljZUNvdW50KCExKTtpc0xvY2FsU3RvcmFnZSYmYisrO3ZhciBlPTQ+PWI/Mjo2PGI/NDozO2E9bmV3IENyZWF0ZURpYWxvZyh0aGlzLGEsbXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEsYil7aWYoIl9ibGFuayI9PWJ8fG51bGwhPWEmJjA8YS5sZW5ndGgpe3ZhciBlPWQoIl9ibGFuayI9PWI/bnVsbDphLGI9PUFwcC5NT0RFX0RFVklDRXx8ImRvd25sb2FkIj09Ynx8bnVsbD09Ynx8Il9ibGFuayI9PWI/IjAiOiIxIik7bnVsbCE9ZSYmKGI9PUFwcC5NT0RFX0RFVklDRXx8ImRvd25sb2FkIj09Ynx8Il9ibGFuayI9PWI/ZS5zaW11bGF0ZShkb2N1bWVudCwiX2JsYW5rIik6dGhpcy5waWNrRm9sZGVyKGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZCl7cD1udWxsIT1wP3A6InBkZiI9PWM/ImFwcGxpY2F0aW9uL3BkZiI6ImltYWdlLyIrYztpZihudWxsIT1mKXRyeXt0aGlzLmV4cG9ydEZpbGUoZixhLHAsITAsYixkKX1jYXRjaCh6KXt0aGlzLmhhbmRsZUVycm9yKHopfWVsc2UgdGhpcy5zcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSxteFJlc291cmNlcy5nZXQoInNhdmluZyIpKSYmZS5zZW5kKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zcGlubmVyLnN0b3AoKTsKaWYoMjAwPD1lLmdldFN0YXR1cygpJiYyOTk+PWUuZ2V0U3RhdHVzKCkpdHJ5e3RoaXMuZXhwb3J0RmlsZShlLmdldFRleHQoKSxhLHAsITAsYixkKX1jYXRjaCh6KXt0aGlzLmhhbmRsZUVycm9yKHopfWVsc2UgdGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImVycm9yU2F2aW5nRmlsZSIpfSl9KSxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSl9KX0pKSl9fSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVEaWFsb2coKX0pLG14UmVzb3VyY2VzLmdldCgic2F2ZUFzIiksbXhSZXNvdXJjZXMuZ2V0KCJkb3dubG9hZCIpLCExLCExLGssbnVsbCwxPGIsZSxmLHAsbCk7Yj10aGlzLmlzU2VydmljZXMoYik/NDxiPzM5MDoyNzA6MTYwO3RoaXMuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciwzODAsYiwhMCwhMCk7YS5pbml0KCl9O0VkaXRvclVpLnByb3RvdHlwZS5pc1NlcnZpY2VzPWZ1bmN0aW9uKGEpe3JldHVybiAxIT0KYX07RWRpdG9yVWkucHJvdG90eXBlLmdldEVkaXRCbGFua1htbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZpbGVEYXRhKCEwKX07RWRpdG9yVWkucHJvdG90eXBlLmV4cG9ydEZpbGU9ZnVuY3Rpb24oYSxjLGQsZixsLHApe307RWRpdG9yVWkucHJvdG90eXBlLnBpY2tGb2xkZXI9ZnVuY3Rpb24oYSxjLGQpe2MobnVsbCl9O0VkaXRvclVpLnByb3RvdHlwZS5leHBvcnRTdmc9ZnVuY3Rpb24oYSxjLGQsZixsLHAsayxtLHkseCxxKXtpZih0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG14UmVzb3VyY2VzLmdldCgiZXhwb3J0IikpKXRyeXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaC5pc1NlbGVjdGlvbkVtcHR5KCk7ZD1udWxsIT1kP2Q6Yjt2YXIgZT1jP251bGw6dGhpcy5lZGl0b3IuZ3JhcGguYmFja2dyb3VuZDtlPT1teENvbnN0YW50cy5OT05FJiYoZT1udWxsKTtudWxsPT1lJiYwPT1jJiYoZT1xP3RoaXMuZWRpdG9yLmdyYXBoLmRlZmF1bHRQYWdlQmFja2dyb3VuZENvbG9yOgoiI2ZmZmZmZiIpO3ZhciBnPXRoaXMuZWRpdG9yLmdyYXBoLmdldFN2ZyhlLGEsayxtLG51bGwsZCxudWxsLG51bGwsImJsYW5rIj09eD8iX2JsYW5rIjoic2VsZiI9PXg/Il90b3AiOm51bGwsbnVsbCwhMCxxKTtmJiZ0aGlzLmVkaXRvci5ncmFwaC5hZGRTdmdTaGFkb3coZyk7dmFyIG49dGhpcy5nZXRCYXNlRmlsZW5hbWUoKSsiLnN2ZyIsdD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO2wmJmEuc2V0QXR0cmlidXRlKCJjb250ZW50Iix0aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLGQseSxudWxsLG51bGwsbnVsbCwhMSkpO3ZhciBiPSc8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/PlxuPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj5cbicrbXhVdGlscy5nZXRYbWwoYSk7dGhpcy5pc0xvY2FsRmlsZVNhdmUoKXx8CmIubGVuZ3RoPD1NQVhfUkVRVUVTVF9TSVpFP3RoaXMuc2F2ZURhdGEobiwic3ZnIixiLCJpbWFnZS9zdmcreG1sIik6dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImRyYXdpbmdUb29MYXJnZSIpfSxteFJlc291cmNlcy5nZXQoImVycm9yIiksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtteFV0aWxzLnBvcHVwKGIpfSkpfSk7dGhpcy5lZGl0b3IuYWRkRm9udENzcyhnKTt0aGlzLmVkaXRvci5ncmFwaC5tYXRoRW5hYmxlZCYmdGhpcy5lZGl0b3IuYWRkTWF0aENzcyhnKTtwPyhudWxsPT10aGlzLnRodW1iSW1hZ2VDYWNoZSYmKHRoaXMudGh1bWJJbWFnZUNhY2hlPXt9KSx0aGlzLmVkaXRvci5jb252ZXJ0SW1hZ2VzKGcsdCx0aGlzLnRodW1iSW1hZ2VDYWNoZSkpOnQoZyl9Y2F0Y2goRil7dGhpcy5oYW5kbGVFcnJvcihGKX19O0VkaXRvclVpLnByb3RvdHlwZS5hZGRSYWRpb2JveD1mdW5jdGlvbihhLGMsZCxmLGwscCxrKXtyZXR1cm4gdGhpcy5hZGRDaGVja2JveChhLApkLGYsbCxwLGssITAsYyl9O0VkaXRvclVpLnByb3RvdHlwZS5hZGRDaGVja2JveD1mdW5jdGlvbihhLGMsZCxmLGwscCxrLG0pe3A9bnVsbCE9cD9wOiEwO3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7Yi5zdHlsZS5tYXJnaW5SaWdodD0iOHB4IjtiLnN0eWxlLm1hcmdpblRvcD0iMTZweCI7Yi5zZXRBdHRyaWJ1dGUoInR5cGUiLGs/InJhZGlvIjoiY2hlY2tib3giKTtrPSJnZUNoZWNrYm94LSIrRWRpdG9yLmd1aWQoKTtiLmlkPWs7bnVsbCE9bSYmYi5zZXRBdHRyaWJ1dGUoIm5hbWUiLG0pO2QmJihiLnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKSxiLmRlZmF1bHRDaGVja2VkPSEwKTtmJiZiLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpO3AmJihhLmFwcGVuZENoaWxkKGIpLGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGFiZWwiKSxteFV0aWxzLndyaXRlKGQsYyksZC5zZXRBdHRyaWJ1dGUoImZvciIsayksYS5hcHBlbmRDaGlsZChkKSwKbHx8bXhVdGlscy5icihhKSk7cmV0dXJuIGJ9O0VkaXRvclVpLnByb3RvdHlwZS5hZGRFZGl0QnV0dG9uPWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5hZGRDaGVja2JveChhLG14UmVzb3VyY2VzLmdldCgiZWRpdCIpKyI6IiwhMCxudWxsLCEwKTtiLnN0eWxlLm1hcmdpbkxlZnQ9IjI0cHgiO3ZhciBlPXRoaXMuZ2V0Q3VycmVudEZpbGUoKSxkPSIiO251bGwhPWUmJmUuZ2V0TW9kZSgpIT1BcHAuTU9ERV9ERVZJQ0UmJmUuZ2V0TW9kZSgpIT1BcHAuTU9ERV9CUk9XU0VSJiYoZD13aW5kb3cubG9jYXRpb24uaHJlZik7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7Zi5zdHlsZS53aWR0aD0iMTIwcHgiO2Yuc3R5bGUubWFyZ2luTGVmdD0iOHB4IjtmLnN0eWxlLm1hcmdpblJpZ2h0PSIxMHB4IjtmLmNsYXNzTmFtZT0iZ2VCdG4iO2U9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7ZS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiYmxhbmsiKTtteFV0aWxzLndyaXRlKGUsCm14UmVzb3VyY2VzLmdldCgibWFrZUNvcHkiKSk7Zi5hcHBlbmRDaGlsZChlKTtlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpO2Uuc2V0QXR0cmlidXRlKCJ2YWx1ZSIsImN1c3RvbSIpO214VXRpbHMud3JpdGUoZSxteFJlc291cmNlcy5nZXQoImN1c3RvbSIpKyIuLi4iKTtmLmFwcGVuZENoaWxkKGUpO2EuYXBwZW5kQ2hpbGQoZik7bXhFdmVudC5hZGRMaXN0ZW5lcihmLCJjaGFuZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYoImN1c3RvbSI9PWYudmFsdWUpe3ZhciBhPW5ldyBGaWxlbmFtZURpYWxvZyh0aGlzLGQsbXhSZXNvdXJjZXMuZ2V0KCJvayIpLGZ1bmN0aW9uKGEpe251bGwhPWE/ZD1hOmYudmFsdWU9ImJsYW5rIn0sbXhSZXNvdXJjZXMuZ2V0KCJ1cmwiKSxudWxsLG51bGwsbnVsbCxudWxsLGZ1bmN0aW9uKCl7Zi52YWx1ZT0iYmxhbmsifSk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDMwMCw4MCwhMCwhMSk7YS5pbml0KCl9fSkpOwpteEV2ZW50LmFkZExpc3RlbmVyKGIsImNoYW5nZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtiLmNoZWNrZWQmJihudWxsPT1jfHxjLmNoZWNrZWQpP2YucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpOmYuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIil9KSk7bXhVdGlscy5icihhKTtyZXR1cm57Z2V0TGluazpmdW5jdGlvbigpe3JldHVybiBiLmNoZWNrZWQ/ImJsYW5rIj09PWYudmFsdWU/Il9ibGFuayI6ZDpudWxsfSxnZXRFZGl0SW5wdXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYn0sZ2V0RWRpdFNlbGVjdDpmdW5jdGlvbigpe3JldHVybiBmfX19O0VkaXRvclVpLnByb3RvdHlwZS5hZGRMaW5rU2VjdGlvbj1mdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGIoKXtrLmlubmVySFRNTD0nPGRpdiBzdHlsZT0id2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7JysobnVsbCE9ZiYmZiE9bXhDb25zdGFudHMuTk9ORT8iYm9yZGVyOjFweCBzb2xpZCBibGFjaztiYWNrZ3JvdW5kLWNvbG9yOiIrCmY6ImJhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGNlbnRlcjtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoJyIrRGlhbG9nLnByb3RvdHlwZS5jbG9zZUltYWdlKyInKSIpKyc7Ij48L2Rpdj4nfW14VXRpbHMud3JpdGUoYSxteFJlc291cmNlcy5nZXQoImxpbmtzIikrIjoiKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzZWxlY3QiKTtlLnN0eWxlLndpZHRoPSIxMDBweCI7ZS5zdHlsZS5tYXJnaW5MZWZ0PSI4cHgiO2Uuc3R5bGUubWFyZ2luUmlnaHQ9IjEwcHgiO2UuY2xhc3NOYW1lPSJnZUJ0biI7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7ZC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiYXV0byIpO214VXRpbHMud3JpdGUoZCxteFJlc291cmNlcy5nZXQoImF1dG9tYXRpYyIpKTtlLmFwcGVuZENoaWxkKGQpO2Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7ZC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwKImJsYW5rIik7bXhVdGlscy53cml0ZShkLG14UmVzb3VyY2VzLmdldCgib3BlbkluTmV3V2luZG93IikpO2UuYXBwZW5kQ2hpbGQoZCk7ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTtkLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJzZWxmIik7bXhVdGlscy53cml0ZShkLG14UmVzb3VyY2VzLmdldCgib3BlbkluVGhpc1dpbmRvdyIpKTtlLmFwcGVuZENoaWxkKGQpO2MmJihkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIm9wdGlvbiIpLGQuc2V0QXR0cmlidXRlKCJ2YWx1ZSIsImZyYW1lIiksbXhVdGlscy53cml0ZShkLG14UmVzb3VyY2VzLmdldCgib3BlbkluVGhpc1dpbmRvdyIpKyIgKCIrbXhSZXNvdXJjZXMuZ2V0KCJpZnJhbWUiKSsiKSIpLGUuYXBwZW5kQ2hpbGQoZCkpO2EuYXBwZW5kQ2hpbGQoZSk7bXhVdGlscy53cml0ZShhLG14UmVzb3VyY2VzLmdldCgiYm9yZGVyQ29sb3IiKSsiOiIpO3ZhciBmPSIjMDAwMGZmIixrPW51bGwsaz1teFV0aWxzLmJ1dHRvbigiIiwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5waWNrQ29sb3IoZnx8Im5vbmUiLGZ1bmN0aW9uKGEpe2Y9YTtiKCl9KTtteEV2ZW50LmNvbnN1bWUoYSl9KSk7YigpO2suc3R5bGUucGFkZGluZz1teENsaWVudC5JU19GRj8iNHB4IDJweCA0cHggMnB4IjoiNHB4IjtrLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7ay5zdHlsZS5oZWlnaHQ9IjIycHgiO2suc3R5bGUud2lkdGg9IjIycHgiO2suc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjtrLnN0eWxlLnRvcD1teENsaWVudC5JU19JRXx8bXhDbGllbnQuSVNfSUUxMXx8bXhDbGllbnQuSVNfRURHRT8iNnB4IjoiMXB4IjtrLmNsYXNzTmFtZT0iZ2VDb2xvckJ0biI7YS5hcHBlbmRDaGlsZChrKTtteFV0aWxzLmJyKGEpO3JldHVybntnZXRDb2xvcjpmdW5jdGlvbigpe3JldHVybiBmfSxnZXRUYXJnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS52YWx1ZX0sZm9jdXM6ZnVuY3Rpb24oKXtlLmZvY3VzKCl9fX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUxpbms9CmZ1bmN0aW9uKGEsYyxkLGYsbCxwLGssbSl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGU9W107ZiYmKGUucHVzaCgibGlnaHRib3g9MSIpLCJhdXRvIiE9YSYmZS5wdXNoKCJ0YXJnZXQ9IithKSxudWxsIT1jJiZjIT1teENvbnN0YW50cy5OT05FJiZlLnB1c2goImhpZ2hsaWdodD0iKygiIyI9PWMuY2hhckF0KDApP2Muc3Vic3RyaW5nKDEpOmMpKSxudWxsIT1sJiYwPGwubGVuZ3RoJiZlLnB1c2goImVkaXQ9IitlbmNvZGVVUklDb21wb25lbnQobCkpLHAmJmUucHVzaCgibGF5ZXJzPTEiKSx0aGlzLmVkaXRvci5ncmFwaC5mb2xkaW5nRW5hYmxlZCYmZS5wdXNoKCJuYXY9MSIpKTtkJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlJiZudWxsIT10aGlzLnBhZ2VzJiZ0aGlzLmN1cnJlbnRQYWdlIT10aGlzLnBhZ2VzWzBdJiZlLnB1c2goInBhZ2UtaWQ9Iit0aGlzLmN1cnJlbnRQYWdlLmdldElkKCkpO2E9ITA7bnVsbCE9az9kPSIjVSIrZW5jb2RlVVJJQ29tcG9uZW50KGspOihiPQp0aGlzLmdldEN1cnJlbnRGaWxlKCksbXx8bnVsbD09Ynx8Yi5jb25zdHJ1Y3RvciE9d2luZG93LkRyaXZlRmlsZT9kPSIjUiIrZW5jb2RlVVJJQ29tcG9uZW50KGQ/dGhpcy5nZXRGaWxlRGF0YSghMCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwhMCxudWxsLCExKTpHcmFwaC5jb21wcmVzcyhteFV0aWxzLmdldFhtbCh0aGlzLmVkaXRvci5nZXRHcmFwaFhtbCgpKSkpOihkPSIjIitiLmdldEhhc2goKSxhPSExKSk7YSYmbnVsbCE9YiYmbnVsbCE9Yi5nZXRUaXRsZSgpJiZiLmdldFRpdGxlKCkhPXRoaXMuZGVmYXVsdEZpbGVuYW1lJiZlLnB1c2goInRpdGxlPSIrZW5jb2RlVVJJQ29tcG9uZW50KGIuZ2V0VGl0bGUoKSkpO3JldHVybihteENsaWVudC5JU19DSFJPTUVBUFB8fEVkaXRvclVpLmlzRWxlY3Ryb25BcHB8fCEvLipcLmRyYXdcLmlvJC8udGVzdCh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpP0VkaXRvclVpLmRyYXdIb3N0OiJodHRwczovLyIrd2luZG93LmxvY2F0aW9uLmhvc3QpKwoiLyIrKDA8ZS5sZW5ndGg/Ij8iK2Uuam9pbigiJiIpOiIiKStkfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlSHRtbD1mdW5jdGlvbihhLGMsZCxmLGwscCxrLG0seSx4LHEpe3RoaXMuZ2V0QmFzZW5hbWVzKCk7dmFyIGI9e307IiIhPWwmJmwhPW14Q29uc3RhbnRzLk5PTkUmJihiLmhpZ2hsaWdodD1sKTsiYXV0byIhPT1mJiYoYi50YXJnZXQ9Zik7eXx8KGIubGlnaHRib3g9ITEpO2IubmF2PXRoaXMuZWRpdG9yLmdyYXBoLmZvbGRpbmdFbmFibGVkO2Q9cGFyc2VJbnQoZCk7aXNOYU4oZCl8fDEwMD09ZHx8KGIuem9vbT1kLzEwMCk7ZD1bXTtrJiYoZC5wdXNoKCJwYWdlcyIpLGIucmVzaXplPSEwLG51bGwhPXRoaXMucGFnZXMmJm51bGwhPXRoaXMuY3VycmVudFBhZ2UmJihiLnBhZ2U9bXhVdGlscy5pbmRleE9mKHRoaXMucGFnZXMsdGhpcy5jdXJyZW50UGFnZSkpKTtjJiYoZC5wdXNoKCJ6b29tIiksYi5yZXNpemU9ITApO20mJmQucHVzaCgibGF5ZXJzIik7MDxkLmxlbmd0aCYmCih5JiZkLnB1c2goImxpZ2h0Ym94IiksYi50b29sYmFyPWQuam9pbigiICIpKTtudWxsIT14JiYwPHgubGVuZ3RoJiYoYi5lZGl0PXgpO251bGwhPWE/Yi51cmw9YTpiLnhtbD10aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLG51bGwsIWspO2M9JzxkaXYgY2xhc3M9Im14Z3JhcGgiIHN0eWxlPSInKyhwPyJtYXgtd2lkdGg6MTAwJTsiOiIiKSsoIiIhPWQ/ImJvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7IjoiIikrJyIgZGF0YS1teGdyYXBoPSInK214VXRpbHMuaHRtbEVudGl0aWVzKEpTT04uc3RyaW5naWZ5KGIpKSsnIj48L2Rpdj4nO2E9bnVsbCE9YT8iJmZldGNoPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpOiIiO3EoYywnPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iJysoMDxhLmxlbmd0aD8oIjEiPT11cmxQYXJhbXMuZGV2PyJodHRwczovL3Rlc3QuZHJhdy5pby9lbWJlZDIuanM/ZGV2PTEiOkVkaXRvclVpLmRyYXdIb3N0KyIvZW1iZWQyLmpzPyIpKwphOiIxIj09dXJsUGFyYW1zLmRldj8iaHR0cHM6Ly90ZXN0LmRyYXcuaW8vanMvdmlld2VyLm1pbi5qcyI6d2luZG93LlZJRVdFUl9VUkw/d2luZG93LlZJRVdFUl9VUkw6RWRpdG9yVWkuZHJhd0hvc3QrIi9qcy92aWV3ZXIubWluLmpzIikrJyI+XHgzYy9zY3JpcHQ+Jyl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93SHRtbERpYWxvZz1mdW5jdGlvbihhLGMsZCxmKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaDMiKTtteFV0aWxzLndyaXRlKGUsbXhSZXNvdXJjZXMuZ2V0KCJodG1sIikpO2Uuc3R5bGUuY3NzVGV4dD0id2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOjEycHgiO2IuYXBwZW5kQ2hpbGQoZSk7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zy5zdHlsZS5jc3NUZXh0PSJib3JkZXItYm90dG9tOjFweCBzb2xpZCBsaWdodEdyYXk7cGFkZGluZy1ib3R0b206OHB4O21hcmdpbi1ib3R0b206MTJweDsiOwp2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpO24uc3R5bGUuY3NzVGV4dD0ibWFyZ2luLXJpZ2h0OjhweDttYXJnaW4tdG9wOjhweDttYXJnaW4tYm90dG9tOjhweDsiO24uc2V0QXR0cmlidXRlKCJ2YWx1ZSIsInVybCIpO24uc2V0QXR0cmlidXRlKCJ0eXBlIiwicmFkaW8iKTtuLnNldEF0dHJpYnV0ZSgibmFtZSIsInR5cGUtZW1iZWRodG1sZGlhbG9nIik7ZT1uLmNsb25lTm9kZSghMCk7ZS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiY29weSIpO2cuYXBwZW5kQ2hpbGQoZSk7dmFyIGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO214VXRpbHMud3JpdGUoayxteFJlc291cmNlcy5nZXQoImluY2x1ZGVDb3B5T2ZNeURpYWdyYW0iKSk7Zy5hcHBlbmRDaGlsZChrKTtteFV0aWxzLmJyKGcpO2cuYXBwZW5kQ2hpbGQobik7az1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7bXhVdGlscy53cml0ZShrLG14UmVzb3VyY2VzLmdldCgicHVibGljRGlhZ3JhbVVybCIpKTsKZy5hcHBlbmRDaGlsZChrKTt2YXIgbT10aGlzLmdldEN1cnJlbnRGaWxlKCk7bnVsbD09ZCYmbnVsbCE9bSYmbS5jb25zdHJ1Y3Rvcj09d2luZG93LkRyaXZlRmlsZSYmKGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpLGsuc3R5bGUucGFkZGluZ0xlZnQ9IjEycHgiLGsuc3R5bGUuY29sb3I9ImdyYXkiLGsuc3R5bGUuY3Vyc29yPSJwb2ludGVyIixteFV0aWxzLndyaXRlKGssbXhSZXNvdXJjZXMuZ2V0KCJzaGFyZSIpKSxnLmFwcGVuZENoaWxkKGspLG14RXZlbnQuYWRkTGlzdGVuZXIoaywiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oaWRlRGlhbG9nKCk7dGhpcy5kcml2ZS5zaG93UGVybWlzc2lvbnMobS5nZXRJZCgpKX0pKSk7ZS5zZXRBdHRyaWJ1dGUoImNoZWNrZWQiLCJjaGVja2VkIik7bnVsbD09ZCYmbi5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKTtiLmFwcGVuZENoaWxkKGcpO3ZhciBxPXRoaXMuYWRkTGlua1NlY3Rpb24oYiksCkI9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgiem9vbSIpLCEwLG51bGwsITApO214VXRpbHMud3JpdGUoYiwiOiIpO3ZhciBEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7RC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0Iik7RC5zdHlsZS5tYXJnaW5SaWdodD0iMTZweCI7RC5zdHlsZS53aWR0aD0iNjBweCI7RC5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO0Quc3R5bGUubWFyZ2luUmlnaHQ9IjEycHgiO0QudmFsdWU9IjEwMCUiO2IuYXBwZW5kQ2hpbGQoRCk7dmFyIHo9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgiZml0IiksITApLGc9bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aCxFPUU9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgiYWxsUGFnZXMiKSxnLCFnKSxHPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImxheWVycyIpLCEwKSxGPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImxpZ2h0Ym94IiksCiEwKSxIPXRoaXMuYWRkRWRpdEJ1dHRvbihiLEYpLEo9SC5nZXRFZGl0SW5wdXQoKTtKLnN0eWxlLm1hcmdpbkJvdHRvbT0iMTZweCI7bXhFdmVudC5hZGRMaXN0ZW5lcihGLCJjaGFuZ2UiLGZ1bmN0aW9uKCl7Ri5jaGVja2VkP0oucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpOkouc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIik7Si5jaGVja2VkJiZGLmNoZWNrZWQ/SC5nZXRFZGl0U2VsZWN0KCkucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpOkguZ2V0RWRpdFNlbGVjdCgpLnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpfSk7YT1uZXcgQ3VzdG9tRGlhbG9nKHRoaXMsYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Yobi5jaGVja2VkP2Q6bnVsbCxCLmNoZWNrZWQsRC52YWx1ZSxxLmdldFRhcmdldCgpLHEuZ2V0Q29sb3IoKSx6LmNoZWNrZWQsRS5jaGVja2VkLEcuY2hlY2tlZCxGLmNoZWNrZWQsSC5nZXRMaW5rKCkpfSksbnVsbCxhLApjKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsMzQwLDM4NCwhMCwhMCk7ZS5mb2N1cygpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd1B1Ymxpc2hMaW5rRGlhbG9nPWZ1bmN0aW9uKGEsYyxkLGYsbCxwKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaDMiKTtteFV0aWxzLndyaXRlKGUsYXx8bXhSZXNvdXJjZXMuZ2V0KCJsaW5rIikpO2Uuc3R5bGUuY3NzVGV4dD0id2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOjEycHgiO2IuYXBwZW5kQ2hpbGQoZSk7dmFyIGc9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGU9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDUxOTQxIjthPTA7aWYobnVsbCE9ZyYmZy5jb25zdHJ1Y3Rvcj09d2luZG93LkRyaXZlRmlsZSYmCiFjKXthPTgwO3ZhciBlPSJodHRwczovL2Rlc2suZHJhdy5pby9zdXBwb3J0L3NvbHV0aW9ucy9hcnRpY2xlcy8xNjAwMDAzOTM4NCIsbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtuLnN0eWxlLmNzc1RleHQ9ImJvcmRlci1ib3R0b206MXB4IHNvbGlkIGxpZ2h0R3JheTtwYWRkaW5nLWJvdHRvbToxNHB4O3BhZGRpbmctdG9wOjZweDttYXJnaW4tYm90dG9tOjE0cHg7dGV4dC1hbGlnbjpjZW50ZXI7Ijt2YXIgaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtrLnN0eWxlLndoaXRlU3BhY2U9Im5vcm1hbCI7bXhVdGlscy53cml0ZShrLG14UmVzb3VyY2VzLmdldCgibGlua0FjY291bnRSZXF1aXJlZCIpKTtuLmFwcGVuZENoaWxkKGspO2s9bXhVdGlscy5idXR0b24obXhSZXNvdXJjZXMuZ2V0KCJzaGFyZSIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kcml2ZS5zaG93UGVybWlzc2lvbnMoZy5nZXRJZCgpKX0pKTtrLnN0eWxlLm1hcmdpblRvcD0KIjEycHgiO2suY2xhc3NOYW1lPSJnZUJ0biI7bi5hcHBlbmRDaGlsZChrKTtiLmFwcGVuZENoaWxkKG4pO2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpO2suc3R5bGUucGFkZGluZ0xlZnQ9IjEycHgiO2suc3R5bGUuY29sb3I9ImdyYXkiO2suc3R5bGUuZm9udFNpemU9IjExcHgiO2suc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtteFV0aWxzLndyaXRlKGssbXhSZXNvdXJjZXMuZ2V0KCJjaGVjayIpKTtuLmFwcGVuZENoaWxkKGspO214RXZlbnQuYWRkTGlzdGVuZXIoaywiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSxteFJlc291cmNlcy5nZXQoImxvYWRpbmciKSkmJnRoaXMuZ2V0UHVibGljVXJsKHRoaXMuZ2V0Q3VycmVudEZpbGUoKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO2E9bmV3IEVycm9yRGlhbG9nKHRoaXMsbnVsbCxteFJlc291cmNlcy5nZXQobnVsbCE9CmE/ImRpYWdyYW1Jc1B1YmxpYyI6ImRpYWdyYW1Jc05vdFB1YmxpYyIpLG14UmVzb3VyY2VzLmdldCgib2siKSk7dGhpcy5zaG93RGlhbG9nKGEuY29udGFpbmVyLDMwMCw4MCwhMCwhMSk7YS5pbml0KCl9KSl9KSl9dmFyIG09bnVsbCxxPW51bGw7aWYobnVsbCE9ZHx8bnVsbCE9ZilhKz0zMCxteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJ3aWR0aCIpKyI6IiksbT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbnB1dCIpLG0uc2V0QXR0cmlidXRlKCJ0eXBlIiwidGV4dCIpLG0uc3R5bGUubWFyZ2luUmlnaHQ9IjE2cHgiLG0uc3R5bGUud2lkdGg9IjUwcHgiLG0uc3R5bGUubWFyZ2luTGVmdD0iNnB4IixtLnN0eWxlLm1hcmdpblJpZ2h0PSIxNnB4IixtLnN0eWxlLm1hcmdpbkJvdHRvbT0iMTBweCIsbS52YWx1ZT0iMTAwJSIsYi5hcHBlbmRDaGlsZChtKSxteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJoZWlnaHQiKSsiOiIpLHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKSwKcS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0IikscS5zdHlsZS53aWR0aD0iNTBweCIscS5zdHlsZS5tYXJnaW5MZWZ0PSI2cHgiLHEuc3R5bGUubWFyZ2luQm90dG9tPSIxMHB4IixxLnZhbHVlPWYrInB4IixiLmFwcGVuZENoaWxkKHEpLG14VXRpbHMuYnIoYik7dmFyIHo9dGhpcy5hZGRMaW5rU2VjdGlvbihiLHApO2Q9bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aDt2YXIgRT1udWxsO2lmKG51bGw9PWd8fGcuY29uc3RydWN0b3IhPXdpbmRvdy5Ecml2ZUZpbGV8fGMpRT10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJhbGxQYWdlcyIpLGQsIWQpO3ZhciBHPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImxpZ2h0Ym94IiksITApLEY9dGhpcy5hZGRFZGl0QnV0dG9uKGIsRyksSD1GLmdldEVkaXRJbnB1dCgpLEo9dGhpcy5hZGRDaGVja2JveChiLG14UmVzb3VyY2VzLmdldCgibGF5ZXJzIiksITApO0ouc3R5bGUubWFyZ2luTGVmdD0KSC5zdHlsZS5tYXJnaW5MZWZ0O0ouc3R5bGUubWFyZ2luQm90dG9tPSIxNnB4IjtKLnN0eWxlLm1hcmdpblRvcD0iOHB4IjtteEV2ZW50LmFkZExpc3RlbmVyKEcsImNoYW5nZSIsZnVuY3Rpb24oKXtHLmNoZWNrZWQ/KEoucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpLEgucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpKTooSi5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKSxILnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpKTtILmNoZWNrZWQmJkcuY2hlY2tlZD9GLmdldEVkaXRTZWxlY3QoKS5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6Ri5nZXRFZGl0U2VsZWN0KCkuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIil9KTtjPW5ldyBDdXN0b21EaWFsb2codGhpcyxiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bCh6LmdldFRhcmdldCgpLHouZ2V0Q29sb3IoKSxudWxsPT1FPyEwOkUuY2hlY2tlZCxHLmNoZWNrZWQsCkYuZ2V0TGluaygpLEouY2hlY2tlZCxudWxsIT1tP20udmFsdWU6bnVsbCxudWxsIT1xP3EudmFsdWU6bnVsbCl9KSxudWxsLG14UmVzb3VyY2VzLmdldCgiY3JlYXRlIiksZSk7dGhpcy5zaG93RGlhbG9nKGMuY29udGFpbmVyLDM0MCwyNTQrYSwhMCwhMCk7bnVsbCE9bT8obS5mb2N1cygpLG14Q2xpZW50LklTX0dDfHxteENsaWVudC5JU19GRnx8NTw9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHxteENsaWVudC5JU19RVUlSS1M/bS5zZWxlY3QoKTpkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKSk6ei5mb2N1cygpfTtFZGl0b3JVaS5wcm90b3R5cGUuc2hvd1JlbW90ZUV4cG9ydERpYWxvZz1mdW5jdGlvbihhLGMsZCxmLGwpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Iuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJoMyIpO214VXRpbHMud3JpdGUoZSxteFJlc291cmNlcy5nZXQoImltYWdlIikpOwplLnN0eWxlLmNzc1RleHQ9IndpZHRoOjEwMCU7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luLXRvcDowcHg7bWFyZ2luLWJvdHRvbToiKyhsPyIxMCI6IjQiKSsicHgiO2IuYXBwZW5kQ2hpbGQoZSk7aWYobCl7bXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgiem9vbSIpKyI6Iik7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtnLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTtnLnN0eWxlLm1hcmdpblJpZ2h0PSIxNnB4IjtnLnN0eWxlLndpZHRoPSI2MHB4IjtnLnN0eWxlLm1hcmdpbkxlZnQ9IjRweCI7Zy5zdHlsZS5tYXJnaW5SaWdodD0iMTJweCI7Zy52YWx1ZT10aGlzLmxhc3RFeHBvcnRab29tfHwiMTAwJSI7Yi5hcHBlbmRDaGlsZChnKTtteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJib3JkZXJXaWR0aCIpKyI6Iik7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtuLnNldEF0dHJpYnV0ZSgidHlwZSIsInRleHQiKTsKbi5zdHlsZS5tYXJnaW5SaWdodD0iMTZweCI7bi5zdHlsZS53aWR0aD0iNjBweCI7bi5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO24udmFsdWU9dGhpcy5sYXN0RXhwb3J0Qm9yZGVyfHwiMCI7Yi5hcHBlbmRDaGlsZChuKTtteFV0aWxzLmJyKGIpfXZhciBrPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoInNlbGVjdGlvbk9ubHkiKSwhMSx0aGlzLmVkaXRvci5ncmFwaC5pc1NlbGVjdGlvbkVtcHR5KCkpLG09Zj9udWxsOnRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImluY2x1ZGVDb3B5T2ZNeURpYWdyYW0iKSwhMCksZT10aGlzLmVkaXRvci5ncmFwaCxxPWY/bnVsbDp0aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJ0cmFuc3BhcmVudEJhY2tncm91bmQiKSxlLmJhY2tncm91bmQ9PW14Q29uc3RhbnRzLk5PTkV8fG51bGw9PWUuYmFja2dyb3VuZCk7bnVsbCE9cSYmKHEuc3R5bGUubWFyZ2luQm90dG9tPSIxNnB4Iik7YT1uZXcgQ3VzdG9tRGlhbG9nKHRoaXMsCmIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1wYXJzZUludChnLnZhbHVlKS8xMDB8fDEsYj1wYXJzZUludChuLnZhbHVlKXx8MDtkKCFrLmNoZWNrZWQsbnVsbCE9bT9tLmNoZWNrZWQ6ITEsbnVsbCE9cT9xLmNoZWNrZWQ6ITEsYSxiKX0pLG51bGwsYSxjKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsMzAwLChsPzI1OjApKyhmPzEyNToyMTApLCEwLCEwKX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dFeHBvcnREaWFsb2c9ZnVuY3Rpb24oYSxjLGQsZixsLHAsayxtKXtrPW51bGwhPWs/azohMDt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7dmFyIGU9dGhpcy5lZGl0b3IuZ3JhcGgsZz0ianBlZyI9PW0/MTk2OjMwMCxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7bXhVdGlscy53cml0ZShuLGEpO24uc3R5bGUuY3NzVGV4dD0id2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcjttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOjEwcHgiOwpiLmFwcGVuZENoaWxkKG4pO214VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoInpvb20iKSsiOiIpO3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7dC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0Iik7dC5zdHlsZS5tYXJnaW5SaWdodD0iMTZweCI7dC5zdHlsZS53aWR0aD0iNjBweCI7dC5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO3Quc3R5bGUubWFyZ2luUmlnaHQ9IjEycHgiO3QudmFsdWU9dGhpcy5sYXN0RXhwb3J0Wm9vbXx8IjEwMCUiO2IuYXBwZW5kQ2hpbGQodCk7bXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgiYm9yZGVyV2lkdGgiKSsiOiIpO3ZhciBxPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7cS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJ0ZXh0Iik7cS5zdHlsZS5tYXJnaW5SaWdodD0iMTZweCI7cS5zdHlsZS53aWR0aD0iNjBweCI7cS5zdHlsZS5tYXJnaW5MZWZ0PSI0cHgiO3EudmFsdWU9dGhpcy5sYXN0RXhwb3J0Qm9yZGVyfHwKIjAiO2IuYXBwZW5kQ2hpbGQocSk7bXhVdGlscy5icihiKTt2YXIgdj10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJ0cmFuc3BhcmVudEJhY2tncm91bmQiKSwhMSxudWxsLG51bGwsImpwZWciIT1tKSxHPW51bGw7ImRhcmsiPT11aVRoZW1lJiYoRz10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJkYXJrIiksITApLGcrPTI2KTt2YXIgRj10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJzZWxlY3Rpb25Pbmx5IiksITEsZS5pc1NlbGVjdGlvbkVtcHR5KCkpLEg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtILnN0eWxlLm1hcmdpblRvcD0iMTZweCI7SC5zdHlsZS5tYXJnaW5SaWdodD0iOHB4IjtILnN0eWxlLm1hcmdpbkxlZnQ9IjI0cHgiO0guc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIik7SC5zZXRBdHRyaWJ1dGUoInR5cGUiLCJjaGVja2JveCIpO3AmJihiLmFwcGVuZENoaWxkKEgpLG14VXRpbHMud3JpdGUoYiwKbXhSZXNvdXJjZXMuZ2V0KCJjcm9wIikpLG14VXRpbHMuYnIoYiksZys9MjYsbXhFdmVudC5hZGRMaXN0ZW5lcihGLCJjaGFuZ2UiLGZ1bmN0aW9uKCl7Ri5jaGVja2VkP0gucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpOkguc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIil9KSk7ZS5pc1NlbGVjdGlvbkVtcHR5KCl8fChILnNldEF0dHJpYnV0ZSgiY2hlY2tlZCIsImNoZWNrZWQiKSxILmRlZmF1bHRDaGVja2VkPSEwKTt2YXIgSj10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJzaGFkb3ciKSxlLnNoYWRvd1Zpc2libGUpLHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTt1LnN0eWxlLm1hcmdpblRvcD0iMTZweCI7dS5zdHlsZS5tYXJnaW5SaWdodD0iOHB4Ijt1LnNldEF0dHJpYnV0ZSgidHlwZSIsImNoZWNrYm94Iik7IXRoaXMuaXNPZmZsaW5lKCkmJnRoaXMuY2FudmFzU3VwcG9ydGVkfHx1LnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLAoiZGlzYWJsZWQiKTtjJiYoYi5hcHBlbmRDaGlsZCh1KSxteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJlbWJlZEltYWdlcyIpKSxteFV0aWxzLmJyKGIpLGcrPTI2KTt2YXIgSz1udWxsO2lmKCJwbmciPT1tfHwianBlZyI9PW0pSz10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJncmlkIiksITEsdGhpcy5pc09mZmxpbmUoKXx8IXRoaXMuY2FudmFzU3VwcG9ydGVkLCExLCEwKSxnKz0yNjt2YXIgQT10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJpbmNsdWRlQ29weU9mTXlEaWFncmFtIiksayxudWxsLG51bGwsImpwZWciIT1tKSxNPW51bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGgsUT10aGlzLmFkZENoZWNrYm94KGIsTT9teFJlc291cmNlcy5nZXQoImFsbFBhZ2VzIik6IiIsTSwhTSxudWxsLCJqcGVnIiE9bSk7US5zdHlsZS5tYXJnaW5MZWZ0PSIyNHB4IjtRLnN0eWxlLm1hcmdpbkJvdHRvbT0iMTZweCI7TT9nKz0KMjY6US5zdHlsZS5kaXNwbGF5PSJub25lIjtteEV2ZW50LmFkZExpc3RlbmVyKEEsImNoYW5nZSIsZnVuY3Rpb24oKXtBLmNoZWNrZWQmJk0/US5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6US5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKX0pO2smJk18fFEuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIik7dmFyIEk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2VsZWN0Iik7SS5zdHlsZS5tYXhXaWR0aD0iMjYwcHgiO0kuc3R5bGUubWFyZ2luTGVmdD0iOHB4IjtJLnN0eWxlLm1hcmdpblJpZ2h0PSIxMHB4IjtJLmNsYXNzTmFtZT0iZ2VCdG4iO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7YS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiYXV0byIpO214VXRpbHMud3JpdGUoYSxteFJlc291cmNlcy5nZXQoImF1dG9tYXRpYyIpKTtJLmFwcGVuZENoaWxkKGEpO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgib3B0aW9uIik7YS5zZXRBdHRyaWJ1dGUoInZhbHVlIiwKImJsYW5rIik7bXhVdGlscy53cml0ZShhLG14UmVzb3VyY2VzLmdldCgib3BlbkluTmV3V2luZG93IikpO0kuYXBwZW5kQ2hpbGQoYSk7YT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJvcHRpb24iKTthLnNldEF0dHJpYnV0ZSgidmFsdWUiLCJzZWxmIik7bXhVdGlscy53cml0ZShhLG14UmVzb3VyY2VzLmdldCgib3BlbkluVGhpc1dpbmRvdyIpKTtJLmFwcGVuZENoaWxkKGEpOyJzdmciPT1tJiYobXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgibGlua3MiKSsiOiIpLGIuYXBwZW5kQ2hpbGQoSSksbXhVdGlscy5icihiKSxteFV0aWxzLmJyKGIpLGcrPTI2KTtkPW5ldyBDdXN0b21EaWFsb2codGhpcyxiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5sYXN0RXhwb3J0Qm9yZGVyPXEudmFsdWU7dGhpcy5sYXN0RXhwb3J0Wm9vbT10LnZhbHVlO2wodC52YWx1ZSx2LmNoZWNrZWQsIUYuY2hlY2tlZCxKLmNoZWNrZWQsQS5jaGVja2VkLHUuY2hlY2tlZCxxLnZhbHVlLApILmNoZWNrZWQsIVEuY2hlY2tlZCxJLnZhbHVlLG51bGwhPUs/Sy5jaGVja2VkOm51bGwsbnVsbCE9Rz9HLmNoZWNrZWQ6bnVsbCl9KSxudWxsLGQsZik7dGhpcy5zaG93RGlhbG9nKGQuY29udGFpbmVyLDM0MCxnLCEwLCEwLG51bGwsbnVsbCxudWxsLG51bGwsITApO3QuZm9jdXMoKTtteENsaWVudC5JU19HQ3x8bXhDbGllbnQuSVNfRkZ8fDU8PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8bXhDbGllbnQuSVNfUVVJUktTP3Quc2VsZWN0KCk6ZG9jdW1lbnQuZXhlY0NvbW1hbmQoInNlbGVjdEFsbCIsITEsbnVsbCl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93RW1iZWRJbWFnZURpYWxvZz1mdW5jdGlvbihhLGMsZCxmLGwpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Iuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjt2YXIgZT10aGlzLmVkaXRvci5ncmFwaDtpZihudWxsIT1jKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJoMyIpO214VXRpbHMud3JpdGUoZywKYyk7Zy5zdHlsZS5jc3NUZXh0PSJ3aWR0aDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbi10b3A6MHB4O21hcmdpbi1ib3R0b206NHB4IjtiLmFwcGVuZENoaWxkKGcpfXZhciBuPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImZpdCIpLCEwKSxrPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoInNoYWRvdyIpLGUuc2hhZG93VmlzaWJsZSYmZiwhZiksbT10aGlzLmFkZENoZWNrYm94KGIsZCkscT10aGlzLmFkZENoZWNrYm94KGIsbXhSZXNvdXJjZXMuZ2V0KCJsaWdodGJveCIpLCEwKSxEPXRoaXMuYWRkRWRpdEJ1dHRvbihiLHEpLHo9RC5nZXRFZGl0SW5wdXQoKSxFPTE8ZS5tb2RlbC5nZXRDaGlsZENvdW50KGUubW9kZWwuZ2V0Um9vdCgpKSxHPXRoaXMuYWRkQ2hlY2tib3goYixteFJlc291cmNlcy5nZXQoImxheWVycyIpLEUsIUUpO0cuc3R5bGUubWFyZ2luTGVmdD16LnN0eWxlLm1hcmdpbkxlZnQ7Ry5zdHlsZS5tYXJnaW5Cb3R0b209CiIxMnB4IjtHLnN0eWxlLm1hcmdpblRvcD0iOHB4IjtteEV2ZW50LmFkZExpc3RlbmVyKHEsImNoYW5nZSIsZnVuY3Rpb24oKXtxLmNoZWNrZWQ/KEUmJkcucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpLHoucmVtb3ZlQXR0cmlidXRlKCJkaXNhYmxlZCIpKTooRy5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKSx6LnNldEF0dHJpYnV0ZSgiZGlzYWJsZWQiLCJkaXNhYmxlZCIpKTt6LmNoZWNrZWQmJnEuY2hlY2tlZD9ELmdldEVkaXRTZWxlY3QoKS5yZW1vdmVBdHRyaWJ1dGUoImRpc2FibGVkIik6RC5nZXRFZGl0U2VsZWN0KCkuc2V0QXR0cmlidXRlKCJkaXNhYmxlZCIsImRpc2FibGVkIil9KTtjPW5ldyBDdXN0b21EaWFsb2codGhpcyxiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YShuLmNoZWNrZWQsay5jaGVja2VkLG0uY2hlY2tlZCxxLmNoZWNrZWQsRC5nZXRMaW5rKCksRy5jaGVja2VkKX0pLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJlbWJlZCIpLApsKTt0aGlzLnNob3dEaWFsb2coYy5jb250YWluZXIsMjgwLDI4MCwhMCwhMCl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVFbWJlZEltYWdlPWZ1bmN0aW9uKGEsYyxkLGYsbCxwLGssbSl7ZnVuY3Rpb24gYihiKXt2YXIgYz0iICIsZz0iIjtmJiYoYz0iIG9uY2xpY2s9XCIoZnVuY3Rpb24oaW1nKXtpZihpbWcud25kIT1udWxsJiYhaW1nLnduZC5jbG9zZWQpe2ltZy53bmQuZm9jdXMoKTt9ZWxzZXt2YXIgcj1mdW5jdGlvbihldnQpe2lmKGV2dC5kYXRhPT0ncmVhZHknJiZldnQuc291cmNlPT1pbWcud25kKXtpbWcud25kLnBvc3RNZXNzYWdlKGRlY29kZVVSSUNvbXBvbmVudChpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKSksJyonKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScscik7fX07d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLHIpO2ltZy53bmQ9d2luZG93Lm9wZW4oJyIrRWRpdG9yVWkuZHJhd0hvc3QrIi8/Y2xpZW50PTEmbGlnaHRib3g9MSIrCihsPyImZWRpdD1fYmxhbmsiOiIiKSsocD8iJmxheWVycz0xIjoiIikrIicpO319KSh0aGlzKTtcIiIsZys9ImN1cnNvcjpwb2ludGVyOyIpO2EmJihnKz0ibWF4LXdpZHRoOjEwMCU7Iik7dmFyIG49IiI7ZCYmKG49JyB3aWR0aD0iJytNYXRoLnJvdW5kKGUud2lkdGgpKyciIGhlaWdodD0iJytNYXRoLnJvdW5kKGUuaGVpZ2h0KSsnIicpO2soJzxpbWcgc3JjPSInK2IrJyInK24rKCIiIT1nPycgc3R5bGU9IicrZysnIic6IiIpK2MrIi8+Iil9dmFyIGU9dGhpcy5lZGl0b3IuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKTtpZih0aGlzLmlzRXhwb3J0VG9DYW52YXMoKSl0aGlzLmVkaXRvci5leHBvcnRUb0NhbnZhcyhteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYz1mP3RoaXMuZ2V0RmlsZURhdGEoITApOm51bGw7YT10aGlzLmNyZWF0ZUltYWdlRGF0YVVyaShhLGMsInBuZyIpO2IoYSl9KSxudWxsLG51bGwsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXttKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgidW5rbm93bkVycm9yIil9KX0pLApudWxsLCEwLGQ/MjoxLG51bGwsYyk7ZWxzZSBpZihjPXRoaXMuZ2V0RmlsZURhdGEoITApLGUud2lkdGgqZS5oZWlnaHQ8PU1BWF9BUkVBJiZjLmxlbmd0aDw9TUFYX1JFUVVFU1RfU0laRSl7dmFyIGc9IiI7ZCYmKGc9IiZ3PSIrTWF0aC5yb3VuZCgyKmUud2lkdGgpKyImaD0iK01hdGgucm91bmQoMiplLmhlaWdodCkpO3ZhciBuPW5ldyBteFhtbFJlcXVlc3QoRVhQT1JUX1VSTCwiZm9ybWF0PXBuZyZiYXNlNjQ9MSZlbWJlZFhtbD0iKyhmPyIxIjoiMCIpK2crIiZ4bWw9IitlbmNvZGVVUklDb21wb25lbnQoYykpO24uc2VuZChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpezIwMDw9bi5nZXRTdGF0dXMoKSYmMjk5Pj1uLmdldFN0YXR1cygpP2IoImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwiK24uZ2V0VGV4dCgpKTptKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgidW5rbm93bkVycm9yIil9KX0pKX1lbHNlIG0oe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJkcmF3aW5nVG9vTGFyZ2UiKX0pfTsKRWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUVtYmVkU3ZnPWZ1bmN0aW9uKGEsYyxkLGYsbCxwLGspe3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoLmdldFN2ZyhudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCFkKSxlPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKTtpZihudWxsIT1lKWZvcih2YXIgZz0wO2c8ZS5sZW5ndGg7ZysrKXt2YXIgbj1lW2ddLmdldEF0dHJpYnV0ZSgiaHJlZiIpO251bGwhPW4mJiIjIj09bi5jaGFyQXQoMCkmJiJfYmxhbmsiPT1lW2ddLmdldEF0dHJpYnV0ZSgidGFyZ2V0IikmJmVbZ10ucmVtb3ZlQXR0cmlidXRlKCJ0YXJnZXQiKX1mJiZiLnNldEF0dHJpYnV0ZSgiY29udGVudCIsdGhpcy5nZXRGaWxlRGF0YSghMCkpO2MmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZFN2Z1NoYWRvdyhiKTtpZihkKXt2YXIgbT0iICIscT0iIjtmJiYobT0ib25jbGljaz1cIihmdW5jdGlvbihpbWcpe2lmKGltZy53bmQhPW51bGwmJiFpbWcud25kLmNsb3NlZCl7aW1nLnduZC5mb2N1cygpO31lbHNle3ZhciByPWZ1bmN0aW9uKGV2dCl7aWYoZXZ0LmRhdGE9PSdyZWFkeScmJmV2dC5zb3VyY2U9PWltZy53bmQpe2ltZy53bmQucG9zdE1lc3NhZ2UoZGVjb2RlVVJJQ29tcG9uZW50KGltZy5nZXRBdHRyaWJ1dGUoJ3NyYycpKSwnKicpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJyxyKTt9fTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScscik7aW1nLnduZD13aW5kb3cub3BlbignIisKRWRpdG9yVWkuZHJhd0hvc3QrIi8/Y2xpZW50PTEmbGlnaHRib3g9MSIrKGw/IiZlZGl0PV9ibGFuayI6IiIpKyhwPyImbGF5ZXJzPTEiOiIiKSsiJyk7fX0pKHRoaXMpO1wiIixxKz0iY3Vyc29yOnBvaW50ZXI7Iik7YSYmKHErPSJtYXgtd2lkdGg6MTAwJTsiKTt0aGlzLmVkaXRvci5jb252ZXJ0SW1hZ2VzKGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aygnPGltZyBzcmM9IicrRWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkobXhVdGlscy5nZXRYbWwoYSkpKyciJysoIiIhPXE/JyBzdHlsZT0iJytxKyciJzoiIikrbSsiLz4iKX0pKX1lbHNlIHE9IiIsZiYmKGIuc2V0QXR0cmlidXRlKCJvbmNsaWNrIiwiKGZ1bmN0aW9uKHN2Zyl7dmFyIHNyYz13aW5kb3cuZXZlbnQudGFyZ2V0fHx3aW5kb3cuZXZlbnQuc3JjRWxlbWVudDt3aGlsZSAoc3JjIT1udWxsJiZzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSE9J2EnKXtzcmM9c3JjLnBhcmVudE5vZGU7fWlmKHNyYz09bnVsbCl7aWYoc3ZnLnduZCE9bnVsbCYmIXN2Zy53bmQuY2xvc2VkKXtzdmcud25kLmZvY3VzKCk7fWVsc2V7dmFyIHI9ZnVuY3Rpb24oZXZ0KXtpZihldnQuZGF0YT09J3JlYWR5JyYmZXZ0LnNvdXJjZT09c3ZnLnduZCl7c3ZnLnduZC5wb3N0TWVzc2FnZShkZWNvZGVVUklDb21wb25lbnQoc3ZnLmdldEF0dHJpYnV0ZSgnY29udGVudCcpKSwnKicpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJyxyKTt9fTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScscik7c3ZnLnduZD13aW5kb3cub3BlbignIisKRWRpdG9yVWkuZHJhd0hvc3QrIi8/Y2xpZW50PTEmbGlnaHRib3g9MSIrKGw/IiZlZGl0PV9ibGFuayI6IiIpKyhwPyImbGF5ZXJzPTEiOiIiKSsiJyk7fX19KSh0aGlzKTsiKSxxKz0iY3Vyc29yOnBvaW50ZXI7IiksYSYmKGE9cGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoIndpZHRoIikpLGM9cGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoImhlaWdodCIpKSxiLnNldEF0dHJpYnV0ZSgidmlld0JveCIsIi0wLjUgLTAuNSAiK2ErIiAiK2MpLHErPSJtYXgtd2lkdGg6MTAwJTttYXgtaGVpZ2h0OiIrYysicHg7IixiLnJlbW92ZUF0dHJpYnV0ZSgiaGVpZ2h0IikpLCIiIT1xJiZiLnNldEF0dHJpYnV0ZSgic3R5bGUiLHEpLHRoaXMuZWRpdG9yLmFkZEZvbnRDc3MoYiksdGhpcy5lZGl0b3IuZ3JhcGgubWF0aEVuYWJsZWQmJnRoaXMuZWRpdG9yLmFkZE1hdGhDc3MoYiksayhteFV0aWxzLmdldFhtbChiKSl9O0VkaXRvclVpLnByb3RvdHlwZS50aW1lU2luY2U9ZnVuY3Rpb24oYSl7YT1NYXRoLmZsb29yKChuZXcgRGF0ZS0KYSkvMUUzKTt2YXIgYj1NYXRoLmZsb29yKGEvMzE1MzZFMyk7aWYoMTxiKXJldHVybiBiKyIgIitteFJlc291cmNlcy5nZXQoInllYXJzIik7Yj1NYXRoLmZsb29yKGEvMjU5MkUzKTtpZigxPGIpcmV0dXJuIGIrIiAiK214UmVzb3VyY2VzLmdldCgibW9udGhzIik7Yj1NYXRoLmZsb29yKGEvODY0MDApO2lmKDE8YilyZXR1cm4gYisiICIrbXhSZXNvdXJjZXMuZ2V0KCJkYXlzIik7Yj1NYXRoLmZsb29yKGEvMzYwMCk7aWYoMTxiKXJldHVybiBiKyIgIitteFJlc291cmNlcy5nZXQoImhvdXJzIik7Yj1NYXRoLmZsb29yKGEvNjApO3JldHVybiAxPGI/YisiICIrbXhSZXNvdXJjZXMuZ2V0KCJtaW51dGVzIik6MT09Yj9iKyIgIitteFJlc291cmNlcy5nZXQoIm1pbnV0ZSIpOm51bGx9O0VkaXRvclVpLnByb3RvdHlwZS5kZWNvZGVOb2RlSW50b0dyYXBoPWZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9YSl7dmFyIGI9bnVsbDtpZigiZGlhZ3JhbSI9PWEubm9kZU5hbWUpYj1hO2Vsc2UgaWYoIm14ZmlsZSI9PQphLm5vZGVOYW1lKXt2YXIgZT1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIik7aWYoMDxlLmxlbmd0aCl7dmFyIGI9ZVswXSxkPWMuZ2V0R2xvYmFsVmFyaWFibGU7Yy5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4icGFnZSI9PWE/Yi5nZXRBdHRyaWJ1dGUoIm5hbWUiKXx8bXhSZXNvdXJjZXMuZ2V0KCJwYWdlV2l0aE51bWJlciIsWzFdKToicGFnZW51bWJlciI9PWE/MTpkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19fW51bGwhPWImJihhPUVkaXRvci5wYXJzZURpYWdyYW1Ob2RlKGIpKX1lPXRoaXMuZWRpdG9yLmdyYXBoO3RyeXt0aGlzLmVkaXRvci5ncmFwaD1jLHRoaXMuZWRpdG9yLnNldEdyYXBoWG1sKGEpfWNhdGNoKHApe31maW5hbGx5e3RoaXMuZWRpdG9yLmdyYXBoPWV9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRQbmdGaWxlUHJvcGVydGllcz1mdW5jdGlvbihhKXt2YXIgYj0xLGM9MDtpZihudWxsIT1hKXtpZihhLmhhc0F0dHJpYnV0ZSgic2NhbGUiKSl7dmFyIGQ9CnBhcnNlRmxvYXQoYS5nZXRBdHRyaWJ1dGUoInNjYWxlIikpOyFpc05hTihkKSYmMDxkJiYoYj1kKX1hLmhhc0F0dHJpYnV0ZSgiYm9yZGVyIikmJihkPXBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCJib3JkZXIiKSksIWlzTmFOKGQpJiYwPGQmJihjPWQpKX1yZXR1cm57c2NhbGU6Yixib3JkZXI6Y319O0VkaXRvclVpLnByb3RvdHlwZS5nZXRFbWJlZGRlZFBuZz1mdW5jdGlvbihhLGMsZCxmLGwpe3RyeXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaCxlPW51bGwhPWIudGhlbWVzJiYiZGFya1RoZW1lIj09Yi5kZWZhdWx0VGhlbWVOYW1lLGc9bnVsbDtpZihudWxsIT1kJiYwPGQubGVuZ3RoKWI9dGhpcy5jcmVhdGVUZW1wb3JhcnlHcmFwaCh0aGlzLmVkaXRvci5ncmFwaC5nZXRTdHlsZXNoZWV0KCkpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5jb250YWluZXIpLHRoaXMuZGVjb2RlTm9kZUludG9HcmFwaCh0aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChteFV0aWxzLnBhcnNlWG1sKGQpLmRvY3VtZW50RWxlbWVudCwKITApLGIpLGc9ZDtlbHNlIGlmKGV8fG51bGwhPXRoaXMucGFnZXMmJnRoaXMuY3VycmVudFBhZ2UhPXRoaXMucGFnZXNbMF0pe3ZhciBiPXRoaXMuY3JlYXRlVGVtcG9yYXJ5R3JhcGgoYi5nZXRTdHlsZXNoZWV0KCkpLG49Yi5nZXRHbG9iYWxWYXJpYWJsZSxrPXRoaXMucGFnZXNbMF07Yi5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4icGFnZSI9PWE/ay5nZXROYW1lKCk6InBhZ2VudW1iZXIiPT1hPzE6bi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5jb250YWluZXIpO2IubW9kZWwuc2V0Um9vdChrLnJvb3QpfXRoaXMuZWRpdG9yLmV4cG9ydFRvQ2FudmFzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUpe3RyeXtudWxsPT1nJiYoZz10aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCwhMSkpO3ZhciBkPWUudG9EYXRhVVJMKCJpbWFnZS9wbmciKSxkPUVkaXRvci53cml0ZUdyYXBoTW9kZWxUb1BuZyhkLAoidEVYdCIsIm14ZmlsZSIsZW5jb2RlVVJJQ29tcG9uZW50KGcpKTthKGQuc3Vic3RyaW5nKGQubGFzdEluZGV4T2YoIiwiKSsxKSk7YiE9dGhpcy5lZGl0b3IuZ3JhcGgmJmIuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYi5jb250YWluZXIpfWNhdGNoKEQpe251bGwhPWMmJmMoRCl9fSksbnVsbCxudWxsLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9YyYmYyhhKX0pLG51bGwsbnVsbCxmLG51bGwsYi5zaGFkb3dWaXNpYmxlLG51bGwsYixsKX1jYXRjaChDKXtudWxsIT1jJiZjKEMpfX07RWRpdG9yVWkucHJvdG90eXBlLmdldEVtYmVkZGVkU3ZnPWZ1bmN0aW9uKGEsYyxkLGYsbCxrLG0sdCl7dD1udWxsIT10P3Q6ITA7bT1jLmJhY2tncm91bmQ7bT09bXhDb25zdGFudHMuTk9ORSYmKG09bnVsbCk7az1jLmdldFN2ZyhtLG51bGwsbnVsbCxudWxsLG51bGwsayk7Yy5zaGFkb3dWaXNpYmxlJiZjLmFkZFN2Z1NoYWRvdyhrKTtudWxsIT1hJiYKay5zZXRBdHRyaWJ1dGUoImNvbnRlbnQiLGEpO251bGwhPWQmJmsuc2V0QXR0cmlidXRlKCJyZXNvdXJjZSIsZCk7aWYobnVsbCE9bCl0aGlzLmVtYmVkRm9udHMoayxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0P3RoaXMuZWRpdG9yLmNvbnZlcnRJbWFnZXMoYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtsKChmPyIiOic8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/PlxuPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj5cbicpK214VXRpbHMuZ2V0WG1sKGEpKX0pKTpsKChmPyIiOic8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCI/PlxuPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj5cbicpKwpteFV0aWxzLmdldFhtbChhKSl9KSk7ZWxzZSByZXR1cm4oZj8iIjonPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz5cbjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+XG4nKStteFV0aWxzLmdldFhtbChrKX07RWRpdG9yVWkucHJvdG90eXBlLmVtYmVkRm9udHM9ZnVuY3Rpb24oYSxjKXt0aGlzLmVkaXRvci5sb2FkRm9udHMobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0cnl7bnVsbCE9dGhpcy5lZGl0b3IucmVzb2x2ZWRGb250Q3NzJiZ0aGlzLmVkaXRvci5hZGRGb250Q3NzKGEsdGhpcy5lZGl0b3IucmVzb2x2ZWRGb250Q3NzKSx0aGlzLmVkaXRvci5lbWJlZEV4dEZvbnRzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RyeXtudWxsIT1iJiZ0aGlzLmVkaXRvci5hZGRGb250Q3NzKGEsYiksYyhhKX1jYXRjaChuKXtjKGEpfX0pKX1jYXRjaChnKXtjKGEpfX0pKX07CkVkaXRvclVpLnByb3RvdHlwZS5leHBvcnRJbWFnZT1mdW5jdGlvbihhLGMsZCxmLGwsayxtLHQscSx4LEMsQil7cT1udWxsIT1xP3E6InBuZyI7aWYodGhpcy5zcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSxteFJlc291cmNlcy5nZXQoImV4cG9ydGluZyIpKSl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGguaXNTZWxlY3Rpb25FbXB0eSgpO2Q9bnVsbCE9ZD9kOmI7bnVsbD09dGhpcy50aHVtYkltYWdlQ2FjaGUmJih0aGlzLnRodW1iSW1hZ2VDYWNoZT17fSk7dHJ5e3RoaXMuZWRpdG9yLmV4cG9ydFRvQ2FudmFzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7dHJ5e3RoaXMuc2F2ZUNhbnZhcyhhLGw/dGhpcy5nZXRGaWxlRGF0YSghMCxudWxsLG51bGwsbnVsbCxkLHQpOm51bGwscSxudWxsPT10aGlzLnBhZ2VzfHwwPT10aGlzLnBhZ2VzLmxlbmd0aCxDKX1jYXRjaChFKXsiSW52YWxpZCBpbWFnZSI9PUUubWVzc2FnZT90aGlzLmRvd25sb2FkRmlsZShxKToKdGhpcy5oYW5kbGVFcnJvcihFKX19KSxudWxsLHRoaXMudGh1bWJJbWFnZUNhY2hlLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zcGlubmVyLnN0b3AoKTt0aGlzLmhhbmRsZUVycm9yKGEpfSksbnVsbCxkLGF8fDEsYyxmLG51bGwsbnVsbCxrLG0seCxCKX1jYXRjaCh6KXt0aGlzLnNwaW5uZXIuc3RvcCgpLHRoaXMuaGFuZGxlRXJyb3Ioeil9fX07RWRpdG9yVWkucHJvdG90eXBlLmlzQ29yc0VuYWJsZWRGb3JVcmw9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWRpdG9yLmlzQ29yc0VuYWJsZWRGb3JVcmwoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5pbXBvcnRYbWw9ZnVuY3Rpb24oYSxjLGQsZixsKXtjPW51bGwhPWM/YzowO2Q9bnVsbCE9ZD9kOjA7dmFyIGI9W107dHJ5e3ZhciBlPXRoaXMuZWRpdG9yLmdyYXBoO2lmKG51bGwhPWEmJjA8YS5sZW5ndGgpe2UubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGc9bXhVdGlscy5wYXJzZVhtbChhKTthPXt9Owp2YXIgbj10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChnLmRvY3VtZW50RWxlbWVudCxudWxsIT10aGlzLnBhZ2VzKTtpZihudWxsIT1uJiYibXhmaWxlIj09bi5ub2RlTmFtZSYmbnVsbCE9dGhpcy5wYWdlcyl7dmFyIGs9bi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpO2lmKDE9PWsubGVuZ3RoKW49RWRpdG9yLnBhcnNlRGlhZ3JhbU5vZGUoa1swXSksbnVsbCE9dGhpcy5jdXJyZW50UGFnZSYmKGFba1swXS5nZXRBdHRyaWJ1dGUoImlkIildPXRoaXMuY3VycmVudFBhZ2UuZ2V0SWQoKSk7ZWxzZSBpZigxPGsubGVuZ3RoKXt2YXIgZz1bXSxtPTA7bnVsbCE9dGhpcy5wYWdlcyYmMT09dGhpcy5wYWdlcy5sZW5ndGgmJnRoaXMuaXNEaWFncmFtRW1wdHkoKSYmKGFba1swXS5nZXRBdHRyaWJ1dGUoImlkIildPXRoaXMucGFnZXNbMF0uZ2V0SWQoKSxuPUVkaXRvci5wYXJzZURpYWdyYW1Ob2RlKGtbMF0pLGY9ITEsbT0xKTtmb3IoO208ay5sZW5ndGg7bSsrKXt2YXIgcT0Ka1ttXS5nZXRBdHRyaWJ1dGUoImlkIik7a1ttXS5yZW1vdmVBdHRyaWJ1dGUoImlkIik7dmFyIEQ9dGhpcy51cGRhdGVQYWdlUm9vdChuZXcgRGlhZ3JhbVBhZ2Uoa1ttXSkpO2FbcV09a1ttXS5nZXRBdHRyaWJ1dGUoImlkIik7dmFyIHo9dGhpcy5wYWdlcy5sZW5ndGg7bnVsbD09RC5nZXROYW1lKCkmJkQuc2V0TmFtZShteFJlc291cmNlcy5nZXQoInBhZ2VXaXRoTnVtYmVyIixbeisxXSkpO2UubW9kZWwuZXhlY3V0ZShuZXcgQ2hhbmdlUGFnZSh0aGlzLEQsRCx6LCEwKSk7Zy5wdXNoKEQpfXRoaXMudXBkYXRlUGFnZUxpbmtzKGEsZyl9fWlmKG51bGwhPW4mJiJteEdyYXBoTW9kZWwiPT09bi5ub2RlTmFtZSYmKGI9ZS5pbXBvcnRHcmFwaE1vZGVsKG4sYyxkLGYpLG51bGwhPWIpKWZvcihtPTA7bTxiLmxlbmd0aDttKyspdGhpcy51cGRhdGVQYWdlTGlua3NGb3JDZWxsKGEsYlttXSl9ZmluYWxseXtlLm1vZGVsLmVuZFVwZGF0ZSgpfX19Y2F0Y2goRSl7aWYobCl0aHJvdyBFO3RoaXMuaGFuZGxlRXJyb3IoRSl9cmV0dXJuIGJ9OwpFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlUGFnZUxpbmtzPWZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBiPTA7YjxjLmxlbmd0aDtiKyspdGhpcy51cGRhdGVQYWdlTGlua3NGb3JDZWxsKGEsY1tiXS5yb290KX07RWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZVBhZ2VMaW5rc0ZvckNlbGw9ZnVuY3Rpb24oYSxjKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxlPXRoaXMuZWRpdG9yLmdyYXBoLGQ9ZS5nZXRMaW5rRm9yQ2VsbChjKTtudWxsIT1kJiZlLnNldExpbmtGb3JDZWxsKGMsdGhpcy51cGRhdGVQYWdlTGluayhhLGQpKTtpZihlLmlzSHRtbExhYmVsKGMpKXtiLmlubmVySFRNTD1lLmdldExhYmVsKGMpO2Zvcih2YXIgZj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJhIiksaz0hMSxtPTA7bTxmLmxlbmd0aDttKyspZD1mW21dLmdldEF0dHJpYnV0ZSgiaHJlZiIpLG51bGwhPWQmJihmW21dLnNldEF0dHJpYnV0ZSgiaHJlZiIsdGhpcy51cGRhdGVQYWdlTGluayhhLGQpKSwKaz0hMCk7ayYmZS5sYWJlbENoYW5nZWQoYyxiLmlubmVySFRNTCl9Zm9yKG09MDttPGUubW9kZWwuZ2V0Q2hpbGRDb3VudChjKTttKyspdGhpcy51cGRhdGVQYWdlTGlua3NGb3JDZWxsKGEsZS5tb2RlbC5nZXRDaGlsZEF0KGMsbSkpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlUGFnZUxpbms9ZnVuY3Rpb24oYSxjKXtpZigiZGF0YTpwYWdlL2lkLCI9PWMuc3Vic3RyaW5nKDAsMTMpKXt2YXIgYj1hW2Muc3Vic3RyaW5nKGMuaW5kZXhPZigiLCIpKzEpXTtjPW51bGwhPWI/ImRhdGE6cGFnZS9pZCwiK2I6bnVsbH1lbHNlIGlmKCJkYXRhOmFjdGlvbi9qc29uLCI9PWMuc3Vic3RyaW5nKDAsMTcpKXRyeXt2YXIgZT1KU09OLnBhcnNlKGMuc3Vic3RyaW5nKDE3KSk7aWYobnVsbCE9ZS5hY3Rpb25zKXtmb3IodmFyIGQ9MDtkPGUuYWN0aW9ucy5sZW5ndGg7ZCsrKXt2YXIgZj1lLmFjdGlvbnNbZF07bnVsbCE9Zi5vcGVuJiYiZGF0YTpwYWdlL2lkLCI9PWYub3Blbi5zdWJzdHJpbmcoMCwKMTMpJiYoYj1hW2Yub3Blbi5zdWJzdHJpbmcoZi5vcGVuLmluZGV4T2YoIiwiKSsxKV0sbnVsbCE9Yj9mLm9wZW49ImRhdGE6cGFnZS9pZCwiK2I6ZGVsZXRlIGYub3Blbil9Yz0iZGF0YTphY3Rpb24vanNvbiwiK0pTT04uc3RyaW5naWZ5KGUpfX1jYXRjaCh2KXt9cmV0dXJuIGN9O0VkaXRvclVpLnByb3RvdHlwZS5pc1JlbW90ZVZpc2lvRm9ybWF0PWZ1bmN0aW9uKGEpe3JldHVybi8oXC52KHNkfGR4KSkoJHxcPykvaS50ZXN0KGEpfHwvKFwudnMoc3x4KSkoJHxcPykvaS50ZXN0KGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0VmlzaW89ZnVuY3Rpb24oYSxjLGQsZil7Zj1udWxsIT1mP2Y6YS5uYW1lO2Q9bnVsbCE9ZD9kOm14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaGFuZGxlRXJyb3IoYSl9KTt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITE7aWYodGhpcy5kb0ltcG9ydFZpc2lvKXt2YXIgYj10aGlzLmlzUmVtb3RlVmlzaW9Gb3JtYXQoZik7CnRyeXt2YXIgZT0iVU5LTk9XTi1WSVNJTyIsZz1mLmxhc3RJbmRleE9mKCIuIik7aWYoMDw9ZyYmZzxmLmxlbmd0aCllPWYuc3Vic3RyaW5nKGcrMSkudG9VcHBlckNhc2UoKTtlbHNle3ZhciBsPWYubGFzdEluZGV4T2YoIi8iKTswPD1sJiZsPGYubGVuZ3RoJiYoZj1mLnN1YnN0cmluZyhsKzEpKX1FZGl0b3JVaS5sb2dFdmVudCh7Y2F0ZWdvcnk6ZSsiLU1TLUlNUE9SVC1GSUxFIixhY3Rpb246ImZpbGVuYW1lXyIrZixsYWJlbDpiPyJyZW1vdGUiOiJsb2NhbCJ9KX1jYXRjaChDKXt9aWYoYilpZihudWxsPT1WU0RfQ09OVkVSVF9VUkx8fHRoaXMuaXNPZmZsaW5lKCkpZCh7bWVzc2FnZToiY29uZiI9PXRoaXMuZ2V0U2VydmljZU5hbWUoKT9teFJlc291cmNlcy5nZXQoInZzZE5vQ29uZmlnIik6bXhSZXNvdXJjZXMuZ2V0KCJzZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQiKX0pO2Vsc2V7Yj1uZXcgRm9ybURhdGE7Yi5hcHBlbmQoImZpbGUxIixhLGYpO3ZhciBrPW5ldyBYTUxIdHRwUmVxdWVzdDsKay5vcGVuKCJQT1NUIixWU0RfQ09OVkVSVF9VUkwpO2sucmVzcG9uc2VUeXBlPSJibG9iIjt0aGlzLmFkZFJlbW90ZVNlcnZpY2VTZWN1cml0eUNoZWNrKGspO2sub25yZWFkeXN0YXRlY2hhbmdlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYoND09ay5yZWFkeVN0YXRlKWlmKDIwMDw9ay5zdGF0dXMmJjI5OT49ay5zdGF0dXMpdHJ5e3ZhciBhPWsucmVzcG9uc2U7aWYoInRleHQveG1sIj09YS50eXBlKXt2YXIgYj1uZXcgRmlsZVJlYWRlcjtiLm9ubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0cnl7YyhhLnRhcmdldC5yZXN1bHQpfWNhdGNoKHope2Qoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJlcnJvckxvYWRpbmdGaWxlIil9KX19KTtiLnJlYWRBc1RleHQoYSl9ZWxzZSB0aGlzLmRvSW1wb3J0VmlzaW8oYSxjLGQsZil9Y2F0Y2goRCl7ZChEKX1lbHNlIGQoe30pfSk7ay5zZW5kKGIpfWVsc2UgdHJ5e3RoaXMuZG9JbXBvcnRWaXNpbyhhLGMsZCxmKX1jYXRjaChDKXtkKEMpfX1lbHNlIHRoaXMuc3Bpbm5lci5zdG9wKCksCnRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJzZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQiKX0pfSk7dGhpcy5kb0ltcG9ydFZpc2lvfHx0aGlzLmxvYWRpbmdFeHRlbnNpb25zfHx0aGlzLmlzT2ZmbGluZSghMCk/YigpOih0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSEwLG14c2NyaXB0KCJqcy9leHRlbnNpb25zLm1pbi5qcyIsYikpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0R3JhcGhNTD1mdW5jdGlvbihhLGMsZCl7ZD1udWxsIT1kP2Q6bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pO3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5sb2FkaW5nRXh0ZW5zaW9ucz0hMTtpZih0aGlzLmRvSW1wb3J0R3JhcGhNTCl0cnl7dGhpcy5kb0ltcG9ydEdyYXBoTUwoYSxjLGQpfWNhdGNoKGwpe2QobCl9ZWxzZSB0aGlzLnNwaW5uZXIuc3RvcCgpLHRoaXMuaGFuZGxlRXJyb3Ioe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJzZXJ2aWNlVW5hdmFpbGFibGVPckJsb2NrZWQiKX0pfSk7CnRoaXMuZG9JbXBvcnRHcmFwaE1MfHx0aGlzLmxvYWRpbmdFeHRlbnNpb25zfHx0aGlzLmlzT2ZmbGluZSghMCk/YigpOih0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSEwLG14c2NyaXB0KCJqcy9leHRlbnNpb25zLm1pbi5qcyIsYikpfTtFZGl0b3JVaS5wcm90b3R5cGUuZXhwb3J0VmlzaW89ZnVuY3Rpb24oKXt2YXIgYT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITE7aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgVnNkeEV4cG9ydCl0cnl7KG5ldyBWc2R4RXhwb3J0KHRoaXMpKS5leHBvcnRDdXJyZW50RGlhZ3JhbXMoKXx8dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpfSl9Y2F0Y2goZSl7dGhpcy5oYW5kbGVFcnJvcihlKX1lbHNlIHRoaXMuc3Bpbm5lci5zdG9wKCksdGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInNlcnZpY2VVbmF2YWlsYWJsZU9yQmxvY2tlZCIpfSl9KTsKInVuZGVmaW5lZCIhPT10eXBlb2YgVnNkeEV4cG9ydHx8dGhpcy5sb2FkaW5nRXh0ZW5zaW9uc3x8dGhpcy5pc09mZmxpbmUoITApP2EoKToodGhpcy5sb2FkaW5nRXh0ZW5zaW9ucz0hMCxteHNjcmlwdCgianMvZXh0ZW5zaW9ucy5taW4uanMiLGEpKX07RWRpdG9yVWkucHJvdG90eXBlLmNvbnZlcnRMdWNpZENoYXJ0PWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITE7aWYoInVuZGVmaW5lZCIhPT10eXBlb2Ygd2luZG93Lkx1Y2lkSW1wb3J0ZXIpe3RyeXtFZGl0b3JVaS5sb2dFdmVudCh7Y2F0ZWdvcnk6IkxVQ0lEQ0hBUlQtSU1QT1JULUZJTEUiLGFjdGlvbjoic2l6ZV8iK2EubGVuZ3RofSksRWRpdG9yVWkuZGVidWcoImNvbnZlcnRMdWNpZENoYXJ0IixhKX1jYXRjaChsKXt9dHJ5e2MoTHVjaWRJbXBvcnRlci5pbXBvcnRTdGF0ZShKU09OLnBhcnNlKGEpKSl9Y2F0Y2gobCl7bnVsbCE9d2luZG93LmNvbnNvbGUmJgpjb25zb2xlLmVycm9yKGwpLGQobCl9fWVsc2UgZCh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInNlcnZpY2VVbmF2YWlsYWJsZU9yQmxvY2tlZCIpfSl9KTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cuTHVjaWRJbXBvcnRlcnx8dGhpcy5sb2FkaW5nRXh0ZW5zaW9uc3x8dGhpcy5pc09mZmxpbmUoITApP3dpbmRvdy5zZXRUaW1lb3V0KGIsMCk6KHRoaXMubG9hZGluZ0V4dGVuc2lvbnM9ITAsIjEiPT11cmxQYXJhbXMuZGV2P214c2NyaXB0KCJqcy9kaWFncmFtbHkvRXh0ZW5zaW9ucy5qcyIsYik6bXhzY3JpcHQoImpzL2V4dGVuc2lvbnMubWluLmpzIixiKSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZW5lcmF0ZU1lcm1haWRJbWFnZT1mdW5jdGlvbihhLGMsZCxmKXt2YXIgYj10aGlzLGU9ZnVuY3Rpb24oKXt0cnl7dGhpcy5sb2FkaW5nTWVybWFpZD0hMSxjPW51bGwhPWM/YzpFZGl0b3JVaS5kZWZhdWx0TWVybWFpZENvbmZpZyxjLnNlY3VyaXR5TGV2ZWw9InN0cmljdCIsYy5zdGFydE9uTG9hZD0KITEsbWVybWFpZC5tZXJtYWlkQVBJLmluaXRpYWxpemUoYyksbWVybWFpZC5tZXJtYWlkQVBJLnJlbmRlcigiZ2VNZXJtYWlkT3V0cHV0LSIrKG5ldyBEYXRlKS5nZXRUaW1lKCksYSxmdW5jdGlvbihhKXt0cnl7aWYobXhDbGllbnQuSVNfSUV8fG14Q2xpZW50LklTX0lFMTEpYT1hLnJlcGxhY2UoLyB4bWxuczpcUyo9Imh0dHA6XC9cL3d3dy53My5vcmdcL1hNTFwvMTk5OFwvbmFtZXNwYWNlIi9nLCIiKS5yZXBsYWNlKC8gKE5TIHhtbHxcUyopOnNwYWNlPSJwcmVzZXJ2ZSIvZywnIHhtbDpzcGFjZT0icHJlc2VydmUiJyk7dmFyIGM9bXhVdGlscy5wYXJzZVhtbChhKS5nZXRFbGVtZW50c0J5VGFnTmFtZSgic3ZnIik7aWYoMDxjLmxlbmd0aCl7dmFyIGU9cGFyc2VGbG9hdChjWzBdLmdldEF0dHJpYnV0ZSgid2lkdGgiKSksZz1wYXJzZUZsb2F0KGNbMF0uZ2V0QXR0cmlidXRlKCJoZWlnaHQiKSk7ZChiLmNvbnZlcnREYXRhVXJpKEVkaXRvci5jcmVhdGVTdmdEYXRhVXJpKGEpKSxlLApnKX1lbHNlIGYoe21lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJpbnZhbGlkSW5wdXQiKX0pfWNhdGNoKEMpe2YoQyl9fSl9Y2F0Y2godil7Zih2KX19OyJ1bmRlZmluZWQiIT09dHlwZW9mIG1lcm1haWR8fHRoaXMubG9hZGluZ01lcm1haWR8fHRoaXMuaXNPZmZsaW5lKCEwKT9lKCk6KHRoaXMubG9hZGluZ01lcm1haWQ9ITAsIjEiPT11cmxQYXJhbXMuZGV2P214c2NyaXB0KCJqcy9tZXJtYWlkL21lcm1haWQubWluLmpzIixlKTpteHNjcmlwdCgianMvZXh0ZW5zaW9ucy5taW4uanMiLGUpKX07RWRpdG9yVWkucHJvdG90eXBlLmdlbmVyYXRlUGxhbnRVbWxJbWFnZT1mdW5jdGlvbihhLGMsZCxmKXtmdW5jdGlvbiBiKGEsYixjKXtjMT1hPj4yO2MyPShhJjMpPDw0fGI+PjQ7YzM9KGImMTUpPDwyfGM+PjY7YzQ9YyY2MztyPSIiO3IrPWUoYzEmNjMpO3IrPWUoYzImNjMpO3IrPWUoYzMmNjMpO3JldHVybiByKz1lKGM0JjYzKX1mdW5jdGlvbiBlKGEpe2lmKDEwPmEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNDgrCmEpO2EtPTEwO2lmKDI2PmEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUrYSk7YS09MjY7aWYoMjY+YSlyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NythKTthLT0yNjtyZXR1cm4gMD09YT8iLSI6MT09YT8iXyI6Ij8ifXZhciBnPW5ldyBYTUxIdHRwUmVxdWVzdDtnLm9wZW4oIkdFVCIsKCJ0eHQiPT1jP1BMQU5UX1VSTCsiL3R4dC8iOiJwbmciPT1jP1BMQU5UX1VSTCsiL3BuZy8iOlBMQU5UX1VSTCsiL3N2Zy8iKStmdW5jdGlvbihhKXtyPSIiO2ZvcihpPTA7aTxhLmxlbmd0aDtpKz0zKXI9aSsyPT1hLmxlbmd0aD9yK2IoYS5jaGFyQ29kZUF0KGkpLGEuY2hhckNvZGVBdChpKzEpLDApOmkrMT09YS5sZW5ndGg/citiKGEuY2hhckNvZGVBdChpKSwwLDApOnIrYihhLmNoYXJDb2RlQXQoaSksYS5jaGFyQ29kZUF0KGkrMSksYS5jaGFyQ29kZUF0KGkrMikpO3JldHVybiByfShwYWtvLmRlZmxhdGVSYXcoYSx7dG86InN0cmluZyJ9KSksITApOyJ0eHQiIT1jJiYoZy5yZXNwb25zZVR5cGU9CiJibG9iIik7Zy5vbmxvYWQ9ZnVuY3Rpb24oYSl7aWYoMjAwPD10aGlzLnN0YXR1cyYmMzAwPnRoaXMuc3RhdHVzKWlmKCJ0eHQiPT1jKWQodGhpcy5yZXNwb25zZSk7ZWxzZXt2YXIgYj1uZXcgRmlsZVJlYWRlcjtiLnJlYWRBc0RhdGFVUkwodGhpcy5yZXNwb25zZSk7Yi5vbmxvYWRlbmQ9ZnVuY3Rpb24oYSl7dmFyIGM9bmV3IEltYWdlO2Mub25sb2FkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWMud2lkdGgsZT1jLmhlaWdodDtpZigwPT1hJiYwPT1lKXt2YXIgZz1iLnJlc3VsdCxsPWcuaW5kZXhPZigiLCIpLGs9ZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShhdG9iKGcuc3Vic3RyaW5nKGwrMSkpKSksbj1teFV0aWxzLnBhcnNlWG1sKGspLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdmciKTswPG4ubGVuZ3RoJiYoYT1wYXJzZUZsb2F0KG5bMF0uZ2V0QXR0cmlidXRlKCJ3aWR0aCIpKSxlPXBhcnNlRmxvYXQoblswXS5nZXRBdHRyaWJ1dGUoImhlaWdodCIpKSl9ZChiLnJlc3VsdCxhLAplKX1jYXRjaChIKXtmKEgpfX07Yy5zcmM9Yi5yZXN1bHR9O2Iub25lcnJvcj1mdW5jdGlvbihhKXtmKGEpfX1lbHNlIGYoYSl9O2cub25lcnJvcj1mdW5jdGlvbihhKXtmKGEpfTtnLnNlbmQoKX07RWRpdG9yVWkucHJvdG90eXBlLmluc2VydEFzUHJlVGV4dD1mdW5jdGlvbihhLGMsZCl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGgsZT1udWxsO2IuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtlPWIuaW5zZXJ0VmVydGV4KG51bGwsbnVsbCwiPHByZT4iK2ErIjwvcHJlPiIsYyxkLDEsMSwidGV4dDtodG1sPTE7YWxpZ249bGVmdDt2ZXJ0aWNhbEFsaWduPXRvcDsiKSxiLnVwZGF0ZUNlbGxTaXplKGUsITApfWZpbmFsbHl7Yi5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfXJldHVybiBlfTtFZGl0b3JVaS5wcm90b3R5cGUuaW5zZXJ0VGV4dEF0PWZ1bmN0aW9uKGEsYyxkLGYsbCxrLG0pe2s9bnVsbCE9az9rOiEwO209bnVsbCE9bT9tOiEwO2lmKG51bGwhPWEpaWYoR3JhcGguZmlsZVN1cHBvcnQmJgohdGhpcy5pc09mZmxpbmUoKSYmKG5ldyBYTUxIdHRwUmVxdWVzdCkudXBsb2FkJiZ0aGlzLmlzUmVtb3RlRmlsZUZvcm1hdChhKSl0aGlzLnBhcnNlRmlsZShuZXcgQmxvYihbYS5yZXBsYWNlKC9ccysvZywiICIpXSx7dHlwZToiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIn0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezQ9PWEucmVhZHlTdGF0ZSYmMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cyYmdGhpcy5lZGl0b3IuZ3JhcGguc2V0U2VsZWN0aW9uQ2VsbHModGhpcy5pbnNlcnRUZXh0QXQoYS5yZXNwb25zZVRleHQsYyxkLCEwKSl9KSk7ZWxzZSBpZigiZGF0YToiPT1hLnN1YnN0cmluZygwLDUpfHwhdGhpcy5pc09mZmxpbmUoKSYmKGx8fC9cLihnaWZ8anBnfGpwZWd8dGlmZnxwbmd8c3ZnKSQvaS50ZXN0KGEpKSl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoImRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwiPT1hLnN1YnN0cmluZygwLDI4KSl7dmFyIGU9CkVkaXRvci5leHRyYWN0R3JhcGhNb2RlbEZyb21QZGYoYSk7aWYobnVsbCE9ZSYmMDxlLmxlbmd0aClyZXR1cm4gdGhpcy5pbXBvcnRYbWwoZSxjLGQsaywhMCl9aWYoImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwiPT1hLnN1YnN0cmluZygwLDIyKSYmKGU9dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoYSksbnVsbCE9ZSYmMDxlLmxlbmd0aCkpcmV0dXJuIHRoaXMuaW1wb3J0WG1sKGUsYyxkLGssITApO2lmKCJkYXRhOmltYWdlL3N2Zyt4bWw7Ij09YS5zdWJzdHJpbmcoMCwxOSkpdHJ5e2U9bnVsbDsiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwiPT1hLnN1YnN0cmluZygwLDI2KT8oZT1hLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiKSsxKSxlPXdpbmRvdy5hdG9iJiYhbXhDbGllbnQuSVNfU0Y/YXRvYihlKTpCYXNlNjQuZGVjb2RlKGUsITApKTplPWRlY29kZVVSSUNvbXBvbmVudChhLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiKSsxKSk7dmFyIGc9dGhpcy5pbXBvcnRYbWwoZSwKYyxkLGssITApO2lmKDA8Zy5sZW5ndGgpcmV0dXJuIGd9Y2F0Y2goQil7fXRoaXMubG9hZEltYWdlKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZSl7aWYoImRhdGE6Ij09YS5zdWJzdHJpbmcoMCw1KSl0aGlzLnJlc2l6ZUltYWdlKGUsYSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGUsZil7Yi5zZXRTZWxlY3Rpb25DZWxsKGIuaW5zZXJ0VmVydGV4KG51bGwsbnVsbCwiIixiLnNuYXAoYyksYi5zbmFwKGQpLGUsZiwic2hhcGU9aW1hZ2U7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTtsYWJlbEJhY2tncm91bmRDb2xvcj0jZmZmZmZmO3ZlcnRpY2FsQWxpZ249dG9wO2FzcGVjdD1maXhlZDtpbWFnZUFzcGVjdD0wO2ltYWdlPSIrdGhpcy5jb252ZXJ0RGF0YVVyaShhKSsiOyIpKX0pLG0sdGhpcy5tYXhJbWFnZVNpemUpO2Vsc2V7dmFyIGY9TWF0aC5taW4oMSxNYXRoLm1pbih0aGlzLm1heEltYWdlU2l6ZS9lLndpZHRoLHRoaXMubWF4SW1hZ2VTaXplL2UuaGVpZ2h0KSksCmc9TWF0aC5yb3VuZChlLndpZHRoKmYpO2U9TWF0aC5yb3VuZChlLmhlaWdodCpmKTtiLnNldFNlbGVjdGlvbkNlbGwoYi5pbnNlcnRWZXJ0ZXgobnVsbCxudWxsLCIiLGIuc25hcChjKSxiLnNuYXAoZCksZyxlLCJzaGFwZT1pbWFnZTt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2xhYmVsQmFja2dyb3VuZENvbG9yPSNmZmZmZmY7dmVydGljYWxBbGlnbj10b3A7YXNwZWN0PWZpeGVkO2ltYWdlQXNwZWN0PTA7aW1hZ2U9IithKyI7IikpfX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGU9bnVsbDtiLmdldE1vZGVsKCkuYmVnaW5VcGRhdGUoKTt0cnl7ZT1iLmluc2VydFZlcnRleChiLmdldERlZmF1bHRQYXJlbnQoKSxudWxsLGEsYi5zbmFwKGMpLGIuc25hcChkKSwxLDEsInRleHQ7IisoZj8iaHRtbD0xOyI6IiIpKSxiLnVwZGF0ZUNlbGxTaXplKGUpLGIuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJ0ZXh0SW5zZXJ0ZWQiLCJjZWxscyIsW2VdKSl9ZmluYWxseXtiLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9Yi5zZXRTZWxlY3Rpb25DZWxsKGUpfSkpfWVsc2V7YT0KR3JhcGguemFwR3JlbWxpbnMobXhVdGlscy50cmltKGEpKTtpZih0aGlzLmlzQ29tcGF0aWJsZVN0cmluZyhhKSlyZXR1cm4gdGhpcy5pbXBvcnRYbWwoYSxjLGQsayk7aWYoMDxhLmxlbmd0aClpZih0aGlzLmlzTHVjaWRDaGFydERhdGEoYSkpdGhpcy5jb252ZXJ0THVjaWRDaGFydChhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMuZWRpdG9yLmdyYXBoLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW1wb3J0WG1sKGIsYyxkLGspKTshdGhpcy5pc09mZmxpbmUoKSYmKC8uKlwuZGlhZ3JhbXNcLm5ldCQvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKXx8Ly4qXC5hcHBzcG90XC5jb20kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSl8fC8uKlwuZHJhd1wuaW8kLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSkpJiZ0aGlzLnNob3dCYW5uZXIoIkx1Y2lkQ2hhcnRJbXBvcnRTdXJ2ZXkiLG14UmVzb3VyY2VzLmdldCgibm90U2F0aXNmaWVkV2l0aEltcG9ydCIpLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3ZhciBiPW5ldyBGZWVkYmFja0RpYWxvZyh0aGlzLCJMdWNpZGNoYXJ0IEltcG9ydCBGZWVkYmFjayIsITAsYSk7dGhpcy5zaG93RGlhbG9nKGIuY29udGFpbmVyLDYxMCwzNjAsITAsITEpO2IuaW5pdCgpfSkpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pKTtlbHNle2I9dGhpcy5lZGl0b3IuZ3JhcGg7bD1udWxsO2IuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtsPWIuaW5zZXJ0VmVydGV4KGIuZ2V0RGVmYXVsdFBhcmVudCgpLG51bGwsIiIsYi5zbmFwKGMpLGIuc25hcChkKSwxLDEsInRleHQ7d2hpdGVTcGFjZT13cmFwOyIrKGY/Imh0bWw9MTsiOiIiKSk7Yi5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInRleHRJbnNlcnRlZCIsImNlbGxzIixbbF0pKTsiPCI9PWEuY2hhckF0KDApJiZhLmluZGV4T2YoIj4iKT09YS5sZW5ndGgtMSYmKGE9bXhVdGlscy5odG1sRW50aXRpZXMoYSkpOwphLmxlbmd0aD50aGlzLm1heFRleHRCeXRlcyYmKGE9YS5zdWJzdHJpbmcoMCx0aGlzLm1heFRleHRCeXRlcykrIi4uLiIpO2wudmFsdWU9YTtiLnVwZGF0ZUNlbGxTaXplKGwpO2lmKDA8dGhpcy5tYXhUZXh0V2lkdGgmJmwuZ2VvbWV0cnkud2lkdGg+dGhpcy5tYXhUZXh0V2lkdGgpe3ZhciBuPWIuZ2V0UHJlZmVycmVkU2l6ZUZvckNlbGwobCx0aGlzLm1heFRleHRXaWR0aCk7bC5nZW9tZXRyeS53aWR0aD1uLndpZHRoO2wuZ2VvbWV0cnkuaGVpZ2h0PW4uaGVpZ2h0fUdyYXBoLmlzTGluayhsLnZhbHVlKSYmYi5zZXRMaW5rRm9yQ2VsbChsLGwudmFsdWUpO2wuZ2VvbWV0cnkud2lkdGgrPWIuZ3JpZFNpemU7bC5nZW9tZXRyeS5oZWlnaHQrPWIuZ3JpZFNpemV9ZmluYWxseXtiLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9cmV0dXJuW2xdfX1yZXR1cm5bXX07RWRpdG9yVWkucHJvdG90eXBlLmZvcm1hdEZpbGVTaXplPWZ1bmN0aW9uKGEpe3ZhciBiPS0xO2RvIGEvPTEwMjQsYisrO3doaWxlKDEwMjQ8CmEpO3JldHVybiBNYXRoLm1heChhLC4xKS50b0ZpeGVkKDEpKyIga0I7IE1COyBHQjsgVEI7UEI7RUI7WkI7WUIiLnNwbGl0KCI7IilbYl19O0VkaXRvclVpLnByb3RvdHlwZS5jb252ZXJ0RGF0YVVyaT1mdW5jdGlvbihhKXtpZigiZGF0YToiPT1hLnN1YnN0cmluZygwLDUpKXt2YXIgYj1hLmluZGV4T2YoIjsiKTswPGImJihhPWEuc3Vic3RyaW5nKDAsYikrYS5zdWJzdHJpbmcoYS5pbmRleE9mKCIsIixiKzEpKSl9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5pc1JlbW90ZUZpbGVGb3JtYXQ9ZnVuY3Rpb24oYSxjKXtyZXR1cm4vKFwiY29udGVudFR5cGVcIjpccypcImFwcGxpY2F0aW9uXC9nbGlmZnlcK2pzb25cIikvLnRlc3QoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5pc0x1Y2lkQ2hhcnREYXRhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiYoJ3sic3RhdGUiOiJ7XFwiUHJvcGVydGllc1xcIjonPT1hLnN1YnN0cmluZygwLDI2KXx8J3siUHJvcGVydGllcyI6Jz09YS5zdWJzdHJpbmcoMCwKMTQpKX07RWRpdG9yVWkucHJvdG90eXBlLmltcG9ydExvY2FsRmlsZT1mdW5jdGlvbihhLGMpe2lmKGEmJkdyYXBoLmZpbGVTdXBwb3J0KXtpZihudWxsPT10aGlzLmltcG9ydEZpbGVJbnB1dEVsdCl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTtiLnNldEF0dHJpYnV0ZSgidHlwZSIsImZpbGUiKTtteEV2ZW50LmFkZExpc3RlbmVyKGIsImNoYW5nZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT1iLmZpbGVzJiYodGhpcy5pbXBvcnRGaWxlcyhiLmZpbGVzLG51bGwsbnVsbCx0aGlzLm1heEltYWdlU2l6ZSksYi50eXBlPSIiLGIudHlwZT0iZmlsZSIsYi52YWx1ZT0iIil9KSk7Yi5zdHlsZS5kaXNwbGF5PSJub25lIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpO3RoaXMuaW1wb3J0RmlsZUlucHV0RWx0PWJ9dGhpcy5pbXBvcnRGaWxlSW5wdXRFbHQuY2xpY2soKX1lbHNle3dpbmRvdy5vcGVuTmV3PSExO3dpbmRvdy5vcGVuS2V5PSJpbXBvcnQiOwppZighYyl7dmFyIGU9RWRpdG9yLnVzZUxvY2FsU3RvcmFnZTtFZGl0b3IudXNlTG9jYWxTdG9yYWdlPSFhfXdpbmRvdy5vcGVuRmlsZT1uZXcgT3BlbkZpbGUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oaWRlRGlhbG9nKGEpfSkpO3dpbmRvdy5vcGVuRmlsZS5zZXRDb25zdW1lcihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe2lmKG51bGwhPWImJkdyYXBoLmZpbGVTdXBwb3J0JiYvKFwudihkeHxzZHg/KSkoJHxcPykvaS50ZXN0KGIpKXt2YXIgYz1uZXcgQmxvYihbYV0se3R5cGU6ImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSJ9KTt0aGlzLmltcG9ydFZpc2lvKGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5pbXBvcnRYbWwoYSwwLDAsITApfSksbnVsbCxiKX1lbHNlIHRoaXMuZWRpdG9yLmdyYXBoLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW1wb3J0WG1sKGEsMCwwLCEwKSl9KSk7dGhpcy5zaG93RGlhbG9nKChuZXcgT3BlbkRpYWxvZyh0aGlzKSkuY29udGFpbmVyLAozNjAsMjIwLCEwLCEwLGZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW51bGx9KTtpZighYyl7dmFyIGQ9dGhpcy5kaWFsb2csZj1kLmNsb3NlO3RoaXMuZGlhbG9nLmNsb3NlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe0VkaXRvci51c2VMb2NhbFN0b3JhZ2U9ZTtmLmFwcGx5KGQsYXJndW1lbnRzKTthJiZudWxsPT10aGlzLmdldEN1cnJlbnRGaWxlKCkmJiIxIiE9dXJsUGFyYW1zLmVtYmVkJiZ0aGlzLnNob3dTcGxhc2goKX0pfX19O0VkaXRvclVpLnByb3RvdHlwZS5pbXBvcnRaaXBGaWxlPWZ1bmN0aW9uKGEsYyxkKXt2YXIgYj10aGlzLGU9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSExOyJ1bmRlZmluZWQiIT09dHlwZW9mIEpTWmlwP0pTWmlwLmxvYWRBc3luYyhhKS50aGVuKGZ1bmN0aW9uKGUpe2lmKDA9PU9iamVjdC5rZXlzKGUuZmlsZXMpLmxlbmd0aClkKCk7ZWxzZXt2YXIgZj0wLGcsbD0hMTtlLmZvckVhY2goZnVuY3Rpb24oYSwKYil7dmFyIGU9Yi5uYW1lLnRvTG93ZXJDYXNlKCk7ImRpYWdyYW0vZGlhZ3JhbS54bWwiPT1lPyhsPSEwLGIuYXN5bmMoInN0cmluZyIpLnRoZW4oZnVuY3Rpb24oYSl7MD09YS5pbmRleE9mKCI8bXhmaWxlICIpP2MoYSk6ZCgpfSkpOjA9PWUuaW5kZXhPZigidmVyc2lvbnMvIikmJihlPXBhcnNlSW50KGUuc3Vic3RyKDkpKSxlPmYmJihmPWUsZz1iKSl9KTswPGY/Zy5hc3luYygic3RyaW5nIikudGhlbihmdW5jdGlvbihlKXshYi5pc09mZmxpbmUoKSYmKG5ldyBYTUxIdHRwUmVxdWVzdCkudXBsb2FkJiZiLmlzUmVtb3RlRmlsZUZvcm1hdChlLGEubmFtZSk/Yi5wYXJzZUZpbGUobmV3IEJsb2IoW2VdLHt0eXBlOiJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0ifSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ND09YS5yZWFkeVN0YXRlJiYoMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz9jKGEucmVzcG9uc2VUZXh0KTpkKCkpfSksYS5uYW1lKTpkKCl9KTpsfHxkKCl9fSwKZnVuY3Rpb24oYSl7ZChhKX0pOmQoKX0pOyJ1bmRlZmluZWQiIT09dHlwZW9mIEpTWmlwfHx0aGlzLmxvYWRpbmdFeHRlbnNpb25zfHx0aGlzLmlzT2ZmbGluZSghMCk/ZSgpOih0aGlzLmxvYWRpbmdFeHRlbnNpb25zPSEwLG14c2NyaXB0KCJqcy9leHRlbnNpb25zLm1pbi5qcyIsZSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0RmlsZT1mdW5jdGlvbihhLGMsZCxmLGwsayxtLHQscSx4LEMpe3g9bnVsbCE9eD94OiEwO3ZhciBiPSExLGU9bnVsbCxnPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7bnVsbCE9YSYmIjxteGxpYnJhcnkiPT1hLnN1YnN0cmluZygwLDEwKT90aGlzLmxvYWRMaWJyYXJ5KG5ldyBMb2NhbExpYnJhcnkodGhpcyxhLG0pKTpiPXRoaXMuaW1wb3J0WG1sKGEsZCxmLHgpO251bGwhPXQmJnQoYil9KTsiaW1hZ2UiPT1jLnN1YnN0cmluZygwLDUpPyhxPSExLCJpbWFnZS9wbmciPT1jLnN1YnN0cmluZygwLDkpJiYoYz1DP251bGw6CnRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nKGEpLG51bGwhPWMmJjA8Yy5sZW5ndGgmJihlPXRoaXMuaW1wb3J0WG1sKGMsZCxmLHgpLHE9ITApKSxxfHwoYz10aGlzLmVkaXRvci5ncmFwaCxDPWEuaW5kZXhPZigiOyIpLDA8QyYmKGE9YS5zdWJzdHJpbmcoMCxDKSthLnN1YnN0cmluZyhhLmluZGV4T2YoIiwiLEMrMSkpKSx4JiZjLmlzR3JpZEVuYWJsZWQoKSYmKGQ9Yy5zbmFwKGQpLGY9Yy5zbmFwKGYpKSxlPVtjLmluc2VydFZlcnRleChudWxsLG51bGwsIiIsZCxmLGwsaywic2hhcGU9aW1hZ2U7dmVydGljYWxMYWJlbFBvc2l0aW9uPWJvdHRvbTtsYWJlbEJhY2tncm91bmRDb2xvcj0jZmZmZmZmO3ZlcnRpY2FsQWxpZ249dG9wO2FzcGVjdD1maXhlZDtpbWFnZUFzcGVjdD0wO2ltYWdlPSIrYSsiOyIpXSkpOi8oXC4qPGdyYXBobWwgKS8udGVzdChhKT8oYj0hMCx0aGlzLmltcG9ydEdyYXBoTUwoYSxnKSk6bnVsbCE9cSYmbnVsbCE9bSYmKC8oXC52KGR4fHNkeD8pKSgkfFw/KS9pLnRlc3QobSl8fAovKFwudnMoeHxzeD8pKSgkfFw/KS9pLnRlc3QobSkpPyhiPSEwLHRoaXMuaW1wb3J0VmlzaW8ocSxnKSk6IXRoaXMuaXNPZmZsaW5lKCkmJihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoYSxtKT8oYj0hMCx0aGlzLnBhcnNlRmlsZShudWxsIT1xP3E6bmV3IEJsb2IoW2FdLHt0eXBlOiJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0ifSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7ND09YS5yZWFkeVN0YXRlJiYoMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz9nKGEucmVzcG9uc2VUZXh0KTpudWxsIT10JiZ0KG51bGwpKX0pLG0pKTowPT1hLmluZGV4T2YoIlBLIikmJm51bGwhPXE/KGI9ITAsdGhpcy5pbXBvcnRaaXBGaWxlKHEsZyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2U9dGhpcy5pbnNlcnRUZXh0QXQodGhpcy52YWxpZGF0ZUZpbGVEYXRhKGEpLGQsZiwhMCxudWxsLHgpO3QoZSl9KSkpOi8oXC52KHNkfGR4KSkoJHxcPykvaS50ZXN0KG0pfHwKLyhcLnZzKHN8eCkpKCR8XD8pL2kudGVzdChtKXx8KGU9dGhpcy5pbnNlcnRUZXh0QXQodGhpcy52YWxpZGF0ZUZpbGVEYXRhKGEpLGQsZiwhMCxudWxsLHgpKTtifHxudWxsPT10fHx0KGUpO3JldHVybiBlfTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0RmlsZXM9ZnVuY3Rpb24oYSxjLGQsZixsLGssbSx0LHEseCxDLEIpe2Y9bnVsbCE9Zj9mOnRoaXMubWF4SW1hZ2VTaXplO3g9bnVsbCE9eD94OnRoaXMubWF4SW1hZ2VCeXRlczt2YXIgYj1udWxsIT1jJiZudWxsIT1kLGU9ITA7Yz1udWxsIT1jP2M6MDtkPW51bGwhPWQ/ZDowO3ZhciBnPSExO2lmKCFteENsaWVudC5JU19DSFJPTUVBUFAmJm51bGwhPWEpZm9yKHZhciBuPUN8fHRoaXMucmVzYW1wbGVUaHJlc2hvbGQscD0wO3A8YS5sZW5ndGg7cCsrKWlmKCJpbWFnZS8iPT1hW3BdLnR5cGUuc3Vic3RyaW5nKDAsNikmJmFbcF0uc2l6ZT5uKXtnPSEwO2JyZWFrfXZhciB5PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGc9CnRoaXMuZWRpdG9yLmdyYXBoLG49Zy5ncmlkU2l6ZTtsPW51bGwhPWw/bDpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMsZSxkLGYsZyxsLGssbil7dHJ5e3JldHVybiBudWxsIT1hJiYiPG14bGlicmFyeSI9PWEuc3Vic3RyaW5nKDAsMTApPyh0aGlzLnNwaW5uZXIuc3RvcCgpLHRoaXMubG9hZExpYnJhcnkobmV3IExvY2FsTGlicmFyeSh0aGlzLGEsbCkpLG51bGwpOnRoaXMuaW1wb3J0RmlsZShhLGMsZSxkLGYsZyxsLGssbixiLEIpfWNhdGNoKFQpe3JldHVybiB0aGlzLmhhbmRsZUVycm9yKFQpLG51bGx9fSk7az1udWxsIT1rP2s6bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Zy5zZXRTZWxlY3Rpb25DZWxscyhhKX0pO2lmKHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJsb2FkaW5nIikpKWZvcih2YXIgcD1hLmxlbmd0aCxxPXAseT1bXSx2PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7eVthXT1iO2lmKDA9PQotLXEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7aWYobnVsbCE9dCl0KHkpO2Vsc2V7dmFyIGM9W107Zy5nZXRNb2RlbCgpLmJlZ2luVXBkYXRlKCk7dHJ5e2Zvcih2YXIgZT0wO2U8eS5sZW5ndGg7ZSsrKXt2YXIgZD15W2VdKCk7bnVsbCE9ZCYmKGM9Yy5jb25jYXQoZCkpfX1maW5hbGx5e2cuZ2V0TW9kZWwoKS5lbmRVcGRhdGUoKX19ayhjKX19KSx6PTA7ejxwO3orKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgaz1hW2JdO2lmKG51bGwhPWspe3ZhciBwPW5ldyBGaWxlUmVhZGVyO3Aub25sb2FkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2lmKG51bGw9PW18fG0oaykpaWYoImltYWdlLyI9PWsudHlwZS5zdWJzdHJpbmcoMCw2KSlpZigiaW1hZ2Uvc3ZnIj09ay50eXBlLnN1YnN0cmluZygwLDkpKXt2YXIgcD1hLnRhcmdldC5yZXN1bHQsdD1wLmluZGV4T2YoIiwiKSxxPWRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoYXRvYihwLnN1YnN0cmluZyh0KzEpKSkpLAp5PW14VXRpbHMucGFyc2VYbWwocSkscT15LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdmciKTtpZigwPHEubGVuZ3RoKXt2YXIgcT1xWzBdLHU9Qj9udWxsOnEuZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7bnVsbCE9dSYmIjwiIT11LmNoYXJBdCgwKSYmIiUiIT11LmNoYXJBdCgwKSYmKHU9dW5lc2NhcGUod2luZG93LmF0b2I/YXRvYih1KTpCYXNlNjQuZGVjb2RlKHUsITApKSk7bnVsbCE9dSYmIiUiPT11LmNoYXJBdCgwKSYmKHU9ZGVjb2RlVVJJQ29tcG9uZW50KHUpKTtudWxsPT11fHwiPG14ZmlsZSAiIT09dS5zdWJzdHJpbmcoMCw4KSYmIjxteEdyYXBoTW9kZWwgIiE9PXUuc3Vic3RyaW5nKDAsMTQpP3YoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RyeXtpZihwLnN1YnN0cmluZygwLHQrMSksbnVsbCE9eSl7dmFyIGE9eS5nZXRFbGVtZW50c0J5VGFnTmFtZSgic3ZnIik7aWYoMDxhLmxlbmd0aCl7dmFyIGU9YVswXSxtPWUuZ2V0QXR0cmlidXRlKCJ3aWR0aCIpLHE9CmUuZ2V0QXR0cmlidXRlKCJoZWlnaHQiKSxtPW51bGwhPW0mJiIlIiE9bS5jaGFyQXQobS5sZW5ndGgtMSk/cGFyc2VGbG9hdChtKTpOYU4scT1udWxsIT1xJiYiJSIhPXEuY2hhckF0KHEubGVuZ3RoLTEpP3BhcnNlRmxvYXQocSk6TmFOLHg9ZS5nZXRBdHRyaWJ1dGUoInZpZXdCb3giKTtpZihudWxsPT14fHwwPT14Lmxlbmd0aCllLnNldEF0dHJpYnV0ZSgidmlld0JveCIsIjAgMCAiK20rIiAiK3EpO2Vsc2UgaWYoaXNOYU4obSl8fGlzTmFOKHEpKXt2YXIgdT14LnNwbGl0KCIgIik7Mzx1Lmxlbmd0aCYmKG09cGFyc2VGbG9hdCh1WzJdKSxxPXBhcnNlRmxvYXQodVszXSkpfXA9RWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkobXhVdGlscy5nZXRYbWwoZSkpO3ZhciB2PU1hdGgubWluKDEsTWF0aC5taW4oZi9NYXRoLm1heCgxLG0pKSxmL01hdGgubWF4KDEscSkpLEE9bChwLGsudHlwZSxjK2IqbixkK2IqbixNYXRoLm1heCgxLE1hdGgucm91bmQobSp2KSksTWF0aC5tYXgoMSxNYXRoLnJvdW5kKHEqCnYpKSxrLm5hbWUpO2lmKGlzTmFOKG0pfHxpc05hTihxKSl7dmFyIHo9bmV3IEltYWdlO3oub25sb2FkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bT1NYXRoLm1heCgxLHoud2lkdGgpO3E9TWF0aC5tYXgoMSx6LmhlaWdodCk7QVswXS5nZW9tZXRyeS53aWR0aD1tO0FbMF0uZ2VvbWV0cnkuaGVpZ2h0PXE7ZS5zZXRBdHRyaWJ1dGUoInZpZXdCb3giLCIwIDAgIittKyIgIitxKTtwPUVkaXRvci5jcmVhdGVTdmdEYXRhVXJpKG14VXRpbHMuZ2V0WG1sKGUpKTt2YXIgYT1wLmluZGV4T2YoIjsiKTswPGEmJihwPXAuc3Vic3RyaW5nKDAsYSkrcC5zdWJzdHJpbmcocC5pbmRleE9mKCIsIixhKzEpKSk7Zy5zZXRDZWxsU3R5bGVzKCJpbWFnZSIscCxbQVswXV0pfSk7ei5zcmM9RWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkobXhVdGlscy5nZXRYbWwoZSkpfXJldHVybiBBfX19Y2F0Y2goUyl7fXJldHVybiBudWxsfSkpOnYoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3JldHVybiBsKHUsCiJ0ZXh0L3htbCIsYytiKm4sZCtiKm4sMCwwLGsubmFtZSl9KSl9ZWxzZSB2KGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pKX1lbHNle3E9ITE7aWYoImltYWdlL3BuZyI9PWsudHlwZSl7dmFyIEE9Qj9udWxsOnRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nKGEudGFyZ2V0LnJlc3VsdCk7aWYobnVsbCE9QSYmMDxBLmxlbmd0aCl7dmFyIHo9bmV3IEltYWdlO3ouc3JjPWEudGFyZ2V0LnJlc3VsdDt2KGIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gbChBLCJ0ZXh0L3htbCIsYytiKm4sZCtiKm4sei53aWR0aCx6LmhlaWdodCxrLm5hbWUpfSkpO3E9ITB9fXF8fChteENsaWVudC5JU19DSFJPTUVBUFA/KHRoaXMuc3Bpbm5lci5zdG9wKCksdGhpcy5zaG93RXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJlcnJvciIpLG14UmVzb3VyY2VzLmdldCgiZHJhZ0FuZERyb3BOb3RTdXBwb3J0ZWQiKSxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe30pLG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJvayIpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgiaW1wb3J0IikuZnVuY3QoKX0pKSk6dGhpcy5sb2FkSW1hZ2UoYS50YXJnZXQucmVzdWx0LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGcpe3RoaXMucmVzaXplSW1hZ2UoZyxhLnRhcmdldC5yZXN1bHQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZyxtLHApe3YoYixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPWcmJmcubGVuZ3RoPHgpe3ZhciBxPWUmJnRoaXMuaXNSZXNhbXBsZUltYWdlKGEudGFyZ2V0LnJlc3VsdCxDKT9NYXRoLm1pbigxLE1hdGgubWluKGYvbSxmL3ApKToxO3JldHVybiBsKGcsay50eXBlLGMrYipuLGQrYipuLE1hdGgucm91bmQobSpxKSxNYXRoLnJvdW5kKHAqcSksay5uYW1lKX10aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCgiaW1hZ2VUb29CaWciKX0pOwpyZXR1cm4gbnVsbH0pKX0pLGUsZixDKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oYW5kbGVFcnJvcih7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoImludmFsaWRPck1pc3NpbmdGaWxlIil9KX0pKSl9ZWxzZSBwPWEudGFyZ2V0LnJlc3VsdCxsKHAsay50eXBlLGMrYipuLGQrYipuLDI0MCwxNjAsay5uYW1lLGZ1bmN0aW9uKGEpe3YoYixmdW5jdGlvbigpe3JldHVybiBhfSl9LGspfSk7LyhcLnYoZHh8c2R4PykpKCR8XD8pL2kudGVzdChrLm5hbWUpfHwvKFwudnMoeHxzeD8pKSgkfFw/KS9pLnRlc3Qoay5uYW1lKT9sKG51bGwsay50eXBlLGMrYipuLGQrYipuLDI0MCwxNjAsay5uYW1lLGZ1bmN0aW9uKGEpe3YoYixmdW5jdGlvbigpe3JldHVybiBhfSl9LGspOiJpbWFnZSI9PWsudHlwZS5zdWJzdHJpbmcoMCw1KXx8ImFwcGxpY2F0aW9uL3BkZiI9PWsudHlwZT9wLnJlYWRBc0RhdGFVUkwoayk6cC5yZWFkQXNUZXh0KGspfX0pKHopfSk7aWYoZyl7Zz1bXTsKZm9yKHA9MDtwPGEubGVuZ3RoO3ArKylnLnB1c2goYVtwXSk7YT1nO3RoaXMuY29uZmlybUltYWdlUmVzaXplKGZ1bmN0aW9uKGEpe2U9YTt5KCl9LHEpfWVsc2UgeSgpfTtFZGl0b3JVaS5wcm90b3R5cGUuY29uZmlybUltYWdlUmVzaXplPWZ1bmN0aW9uKGEsYyl7Yz1udWxsIT1jP2M6ITE7dmFyIGI9bnVsbCE9dGhpcy5zcGlubmVyJiZudWxsIT10aGlzLnNwaW5uZXIucGF1c2U/dGhpcy5zcGlubmVyLnBhdXNlKCk6ZnVuY3Rpb24oKXt9LGU9aXNMb2NhbFN0b3JhZ2V8fG14Q2xpZW50LklTX0NIUk9NRUFQUD9teFNldHRpbmdzLmdldFJlc2l6ZUltYWdlcygpOm51bGwsZD1mdW5jdGlvbihlLGQpe2lmKGV8fGMpbXhTZXR0aW5ncy5zZXRSZXNpemVJbWFnZXMoZT9kOm51bGwpLG14U2V0dGluZ3Muc2F2ZSgpO2IoKTthKGQpfTtudWxsPT1lfHxjP3RoaXMuc2hvd0RpYWxvZygobmV3IENvbmZpcm1EaWFsb2codGhpcyxteFJlc291cmNlcy5nZXQoInJlc2l6ZUxhcmdlSW1hZ2VzIiksCmZ1bmN0aW9uKGEpe2QoYSwhMCl9LGZ1bmN0aW9uKGEpe2QoYSwhMSl9LG14UmVzb3VyY2VzLmdldCgicmVzaXplIiksbXhSZXNvdXJjZXMuZ2V0KCJhY3R1YWxTaXplIiksJzxpbWcgc3R5bGU9Im1hcmdpbi10b3A6OHB4OyIgc3JjPSInK0VkaXRvci5sb1Jlc0ltYWdlKyciLz4nLCc8aW1nIHN0eWxlPSJtYXJnaW4tdG9wOjhweDsiIHNyYz0iJytFZGl0b3IuaGlSZXNJbWFnZSsnIi8+Jyxpc0xvY2FsU3RvcmFnZXx8bXhDbGllbnQuSVNfQ0hST01FQVBQKSkuY29udGFpbmVyLDM0MCxpc0xvY2FsU3RvcmFnZXx8bXhDbGllbnQuSVNfQ0hST01FQVBQPzIyMDoyMDAsITAsITApOmQoITEsZSl9O0VkaXRvclVpLnByb3RvdHlwZS5wYXJzZUZpbGU9ZnVuY3Rpb24oYSxjLGQpe2Q9bnVsbCE9ZD9kOmEubmFtZTt2YXIgYj1uZXcgRm9ybURhdGE7Yi5hcHBlbmQoImZvcm1hdCIsInhtbCIpO2IuYXBwZW5kKCJ1cGZpbGUiLGEsZCk7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O2Uub3BlbigiUE9TVCIsCk9QRU5fVVJMKTtlLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2MoZSl9O2Uuc2VuZChiKTt0cnl7RWRpdG9yVWkubG9nRXZlbnQoe2NhdGVnb3J5OiJHTElGRlktSU1QT1JULUZJTEUiLGFjdGlvbjoic2l6ZV8iK2Euc2l6ZX0pfWNhdGNoKHApe319O0VkaXRvclVpLnByb3RvdHlwZS5pc1Jlc2FtcGxlSW1hZ2U9ZnVuY3Rpb24oYSxjKXtjPW51bGwhPWM/Yzp0aGlzLnJlc2FtcGxlVGhyZXNob2xkO3JldHVybiBhLmxlbmd0aD5jfTtFZGl0b3JVaS5wcm90b3R5cGUucmVzaXplSW1hZ2U9ZnVuY3Rpb24oYSxjLGQsZixsLGspe2w9bnVsbCE9bD9sOnRoaXMubWF4SW1hZ2VTaXplO3ZhciBiPU1hdGgubWF4KDEsYS53aWR0aCksZT1NYXRoLm1heCgxLGEuaGVpZ2h0KTtpZihmJiZ0aGlzLmlzUmVzYW1wbGVJbWFnZShjLGspKXRyeXt2YXIgZz1NYXRoLm1heChiL2wsZS9sKTtpZigxPGcpe3ZhciBtPU1hdGgucm91bmQoYi9nKSxuPU1hdGgucm91bmQoZS9nKSxwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpOwpwLndpZHRoPW07cC5oZWlnaHQ9bjtwLmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKGEsMCwwLG0sbik7dmFyIHE9cC50b0RhdGFVUkwoKTtpZihxLmxlbmd0aDxjLmxlbmd0aCl7dmFyIHo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7ei53aWR0aD1tO3ouaGVpZ2h0PW47dmFyIEU9ei50b0RhdGFVUkwoKTtxIT09RSYmKGM9cSxiPW0sZT1uKX19fWNhdGNoKEcpe31kKGMsYixlKX07RWRpdG9yVWkucHJvdG90eXBlLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBuZz1mdW5jdGlvbihhKXtyZXR1cm4gRWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBuZyhhKX07RWRpdG9yVWkucHJvdG90eXBlLmxvYWRJbWFnZT1mdW5jdGlvbihhLGMsZCl7dHJ5e3ZhciBiPW5ldyBJbWFnZTtiLm9ubG9hZD1mdW5jdGlvbigpe2Iud2lkdGg9MDxiLndpZHRoP2Iud2lkdGg6MTIwO2IuaGVpZ2h0PTA8Yi5oZWlnaHQ/Yi5oZWlnaHQ6MTIwO2MoYil9O251bGwhPWQmJihiLm9uZXJyb3I9ZCk7CmIuc3JjPWF9Y2F0Y2gobCl7aWYobnVsbCE9ZClkKGwpO2Vsc2UgdGhyb3cgbDt9fTt2YXIgZD1FZGl0b3JVaS5wcm90b3R5cGUuaW5pdDtFZGl0b3JVaS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe214U3RlbmNpbFJlZ2lzdHJ5LmFsbG93RXZhbD1teFN0ZW5jaWxSZWdpc3RyeS5hbGxvd0V2YWwmJiF0aGlzLmlzT2ZmbGluZUFwcCgpOyJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdy5teFNldHRpbmdzJiYodGhpcy5mb3JtYXRXaWR0aD1teFNldHRpbmdzLmdldEZvcm1hdFdpZHRoKCkpO3ZhciBhPXRoaXMsYz10aGlzLmVkaXRvci5ncmFwaDtjLmNlbGxFZGl0b3IuZWRpdFBsYW50VW1sRGF0YT1mdW5jdGlvbihiLGUsZCl7dmFyIGY9SlNPTi5wYXJzZShkKTtlPW5ldyBUZXh0YXJlYURpYWxvZyhhLG14UmVzb3VyY2VzLmdldCgicGxhbnRVbWwiKSsiOiIsZi5kYXRhLGZ1bmN0aW9uKGUpe251bGwhPWUmJmEuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJpbnNlcnRpbmciKSkmJgphLmdlbmVyYXRlUGxhbnRVbWxJbWFnZShlLGYuZm9ybWF0LGZ1bmN0aW9uKGQsZyxsKXthLnNwaW5uZXIuc3RvcCgpO2MuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtpZigidHh0Ij09Zi5mb3JtYXQpYy5sYWJlbENoYW5nZWQoYiwiPHByZT4iK2QrIjwvcHJlPiIpLGMudXBkYXRlQ2VsbFNpemUoYiwhMCk7ZWxzZXtjLnNldENlbGxTdHlsZXMoImltYWdlIixhLmNvbnZlcnREYXRhVXJpKGQpLFtiXSk7dmFyIGs9Yy5tb2RlbC5nZXRHZW9tZXRyeShiKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay53aWR0aD1nLGsuaGVpZ2h0PWwsYy5jZWxsc1Jlc2l6ZWQoW2JdLFtrXSwhMSkpfWMuc2V0QXR0cmlidXRlRm9yQ2VsbChiLCJwbGFudFVtbERhdGEiLEpTT04uc3RyaW5naWZ5KHtkYXRhOmUsZm9ybWF0OmYuZm9ybWF0fSkpfWZpbmFsbHl7Yy5nZXRNb2RlbCgpLmVuZFVwZGF0ZSgpfX0sZnVuY3Rpb24oYil7YS5oYW5kbGVFcnJvcihiKX0pfSxudWxsLG51bGwsNDAwLDIyMCk7YS5zaG93RGlhbG9nKGUuY29udGFpbmVyLAo0MjAsMzAwLCEwLCEwKTtlLmluaXQoKX07Yy5jZWxsRWRpdG9yLmVkaXRNZXJtYWlkRGF0YT1mdW5jdGlvbihiLGUsZCl7dmFyIGY9SlNPTi5wYXJzZShkKTtlPW5ldyBUZXh0YXJlYURpYWxvZyhhLG14UmVzb3VyY2VzLmdldCgibWVybWFpZCIpKyI6IixmLmRhdGEsZnVuY3Rpb24oZSl7bnVsbCE9ZSYmYS5zcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSxteFJlc291cmNlcy5nZXQoImluc2VydGluZyIpKSYmYS5nZW5lcmF0ZU1lcm1haWRJbWFnZShlLGYuY29uZmlnLGZ1bmN0aW9uKGQsZyxsKXthLnNwaW5uZXIuc3RvcCgpO2MuZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXtjLnNldENlbGxTdHlsZXMoImltYWdlIixkLFtiXSk7dmFyIGs9Yy5tb2RlbC5nZXRHZW9tZXRyeShiKTtudWxsIT1rJiYoaz1rLmNsb25lKCksay53aWR0aD1NYXRoLm1heChrLndpZHRoLGcpLGsuaGVpZ2h0PU1hdGgubWF4KGsuaGVpZ2h0LGwpLGMuY2VsbHNSZXNpemVkKFtiXSxba10sITEpKTtjLnNldEF0dHJpYnV0ZUZvckNlbGwoYiwKIm1lcm1haWREYXRhIixKU09OLnN0cmluZ2lmeSh7ZGF0YTplLGNvbmZpZzpmLmNvbmZpZ30sbnVsbCwyKSl9ZmluYWxseXtjLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9fSxmdW5jdGlvbihiKXthLmhhbmRsZUVycm9yKGIpfSl9LG51bGwsbnVsbCw0MDAsMjIwKTthLnNob3dEaWFsb2coZS5jb250YWluZXIsNDIwLDMwMCwhMCwhMCk7ZS5pbml0KCl9O3ZhciBmPWMuY2VsbEVkaXRvci5zdGFydEVkaXRpbmc7Yy5jZWxsRWRpdG9yLnN0YXJ0RWRpdGluZz1mdW5jdGlvbihiLGMpe3RyeXt2YXIgZT10aGlzLmdyYXBoLmdldEF0dHJpYnV0ZUZvckNlbGwoYiwicGxhbnRVbWxEYXRhIik7bnVsbCE9ZT90aGlzLmVkaXRQbGFudFVtbERhdGEoYixjLGUpOihlPXRoaXMuZ3JhcGguZ2V0QXR0cmlidXRlRm9yQ2VsbChiLCJtZXJtYWlkRGF0YSIpLG51bGwhPWU/dGhpcy5lZGl0TWVybWFpZERhdGEoYixjLGUpOmYuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1jYXRjaChHKXthLmhhbmRsZUVycm9yKEcpfX07CmMuZ2V0TGlua1RpdGxlPWZ1bmN0aW9uKGIpe3JldHVybiBhLmdldExpbmtUaXRsZShiKX07Yy5jdXN0b21MaW5rQ2xpY2tlZD1mdW5jdGlvbihiKXt2YXIgYz0hMTt0cnl7YS5oYW5kbGVDdXN0b21MaW5rKGIpLGM9ITB9Y2F0Y2goRSl7YS5oYW5kbGVFcnJvcihFKX1yZXR1cm4gY307dmFyIGs9dGhpcy5jbGVhckRlZmF1bHRTdHlsZTt0aGlzLmNsZWFyRGVmYXVsdFN0eWxlPWZ1bmN0aW9uKCl7ay5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3RoaXMuaXNPZmZsaW5lKCl8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHdpbmRvdy5FZGl0RGF0YURpYWxvZ3x8KEVkaXREYXRhRGlhbG9nLnBsYWNlaG9sZGVySGVscExpbms9Imh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDUxOTc5Iik7dmFyIGw9YS5lZGl0b3IuZ2V0RWRpdEJsYW5rVXJsO3RoaXMuZWRpdG9yLmdldEVkaXRCbGFua1VybD1mdW5jdGlvbihiKXtiPW51bGwhPWI/YjoiIjtpZihudWxsIT0KYS5wYWdlcyYmbnVsbCE9YS5jdXJyZW50UGFnZSlmb3IodmFyIGM9MDtjPGEucGFnZXMubGVuZ3RoO2MrKylpZihhLnBhZ2VzW2NdPT1hLmN1cnJlbnRQYWdlKXswPGMmJihiKz0oMDxiLmxlbmd0aD8iJiI6Ij8iKSsicGFnZT0iK2MpO2JyZWFrfSIxIj09dXJsUGFyYW1zLmRldiYmKGIrPSgwPGIubGVuZ3RoPyImIjoiPyIpKyJkZXY9MSZkcmF3ZGV2PTEiKTtyZXR1cm4gbC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBtPWMuYWRkQ2xpY2tIYW5kbGVyO2MuYWRkQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEsYixlKXt2YXIgZD1iO2I9ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXt2YXIgZT1teEV2ZW50LmdldFNvdXJjZShhKTsiYSI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmKGI9ZS5nZXRBdHRyaWJ1dGUoImhyZWYiKSl9bnVsbCE9YiYmYy5pc0N1c3RvbUxpbmsoYikmJihteEV2ZW50LmlzVG91Y2hFdmVudChhKXx8IW14RXZlbnQuaXNQb3B1cFRyaWdnZXIoYSkpJiZjLmN1c3RvbUxpbmtDbGlja2VkKGIpJiYKbXhFdmVudC5jb25zdW1lKGEpO251bGwhPWQmJmQoYSxiKX07bS5jYWxsKHRoaXMsYSxiLGUpfTtkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtteENsaWVudC5JU19TVkcmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZFN2Z1NoYWRvdyhjLnZpZXcuY2FudmFzLm93bmVyU1ZHRWxlbWVudCxudWxsLCEwKTthLmFjdGlvbnMuZ2V0KCJwcmludCIpLmZ1bmN0PWZ1bmN0aW9uKCl7YS5zaG93RGlhbG9nKChuZXcgUHJpbnREaWFsb2coYSkpLmNvbnRhaW5lciwzNjAsbnVsbCE9YS5wYWdlcyYmMTxhLnBhZ2VzLmxlbmd0aD80NTA6MzcwLCEwLCEwKX07dGhpcy5kZWZhdWx0RmlsZW5hbWU9bXhSZXNvdXJjZXMuZ2V0KCJ1bnRpdGxlZERpYWdyYW0iKTt2YXIgcT1jLmdldEV4cG9ydFZhcmlhYmxlcztjLmdldEV4cG9ydFZhcmlhYmxlcz1mdW5jdGlvbigpe3ZhciBiPXEuYXBwbHkodGhpcyxhcmd1bWVudHMpLGM9YS5nZXRDdXJyZW50RmlsZSgpO251bGwhPWMmJihiLmZpbGVuYW1lPWMuZ2V0VGl0bGUoKSk7CmIucGFnZWNvdW50PW51bGwhPWEucGFnZXM/YS5wYWdlcy5sZW5ndGg6MTtiLnBhZ2U9bnVsbCE9YS5jdXJyZW50UGFnZT9hLmN1cnJlbnRQYWdlLmdldE5hbWUoKToiIjtiLnBhZ2VudW1iZXI9bnVsbCE9YS5wYWdlcyYmbnVsbCE9YS5jdXJyZW50UGFnZT9teFV0aWxzLmluZGV4T2YoYS5wYWdlcyxhLmN1cnJlbnRQYWdlKSsxOjE7cmV0dXJuIGJ9O3ZhciB0PWMuZ2V0R2xvYmFsVmFyaWFibGU7Yy5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihiKXt2YXIgYz1hLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuImZpbGVuYW1lIj09YiYmbnVsbCE9Yz9jLmdldFRpdGxlKCk6InBhZ2UiPT1iJiZudWxsIT1hLmN1cnJlbnRQYWdlP2EuY3VycmVudFBhZ2UuZ2V0TmFtZSgpOiJwYWdlbnVtYmVyIj09Yj9udWxsIT1hLmN1cnJlbnRQYWdlJiZudWxsIT1hLnBhZ2VzP214VXRpbHMuaW5kZXhPZihhLnBhZ2VzLGEuY3VycmVudFBhZ2UpKzE6MToicGFnZWNvdW50Ij09Yj9udWxsIT1hLnBhZ2VzPwphLnBhZ2VzLmxlbmd0aDoxOnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgeT1jLmxhYmVsTGlua0NsaWNrZWQ7Yy5sYWJlbExpbmtDbGlja2VkPWZ1bmN0aW9uKGEsYixlKXt2YXIgZD1iLmdldEF0dHJpYnV0ZSgiaHJlZiIpO2lmKG51bGw9PWR8fCFjLmlzQ3VzdG9tTGluayhkKXx8IW14RXZlbnQuaXNUb3VjaEV2ZW50KGUpJiZteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGUpKXkuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Vsc2V7aWYoIWMuaXNFbmFibGVkKCl8fG51bGwhPWEmJmMuaXNDZWxsTG9ja2VkKGEuY2VsbCkpYy5jdXN0b21MaW5rQ2xpY2tlZChkKSxjLmdldFJ1YmJlcmJhbmQoKS5yZXNldCgpO214RXZlbnQuY29uc3VtZShlKX19O3RoaXMuZWRpdG9yLmdldE9yQ3JlYXRlRmlsZW5hbWU9ZnVuY3Rpb24oKXt2YXIgYj1hLmRlZmF1bHRGaWxlbmFtZSxjPWEuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1jJiYoYj1udWxsIT1jLmdldFRpdGxlKCk/Yy5nZXRUaXRsZSgpOmIpO3JldHVybiBifTsKdmFyIHg9dGhpcy5hY3Rpb25zLmdldCgicHJpbnQiKTt4LnNldEVuYWJsZWQoIW14Q2xpZW50LklTX0lPU3x8IW5hdmlnYXRvci5zdGFuZGFsb25lKTt4LnZpc2libGU9eC5pc0VuYWJsZWQoKTtpZighdGhpcy5lZGl0b3IuY2hyb21lbGVzc3x8dGhpcy5lZGl0b3IuZWRpdGFibGUpdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oNzAsITAsImZpbmQiKSx0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbig2NywhMCwiY29weVN0eWxlIiwhMCksdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oODYsITAsInBhc3RlU3R5bGUiLCEwKSx0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbig3NywhMCwiZWRpdEdlb21ldHJ5IiwhMCksdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oODgsITAsImluc2VydFRleHQiLCEwKSx0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbig3NSwhMCwiaW5zZXJ0UmVjdGFuZ2xlIiksdGhpcy5rZXlIYW5kbGVyLmJpbmRBY3Rpb24oNzUsITAsImluc2VydEVsbGlwc2UiLAohMCksbXhDbGllbnQuSVNfQ0hST01FQVBQfHxFZGl0b3JVaS5pc0VsZWN0cm9uQXBwfHwodGhpcy5hbHRTaGlmdEFjdGlvbnNbODNdPSJzeW5jaHJvbml6ZSIpLHRoaXMuaW5zdGFsbEltYWdlUGFzdGVIYW5kbGVyKCksdGhpcy5pbnN0YWxsTmF0aXZlQ2xpcGJvYXJkSGFuZGxlcigpO3RoaXMuc3Bpbm5lcj10aGlzLmNyZWF0ZVNwaW5uZXIoZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aC8yLTIsTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHR8fDAsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodHx8MCkvMiwyNCk7R3JhcGguZmlsZVN1cHBvcnQmJnRoaXMuZWRpdG9yLmdyYXBoLmFkZExpc3RlbmVyKG14RXZlbnQuRURJVElOR19TVEFSVEVELG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoLGM9Yi5jZWxsRWRpdG9yLnRleHQyLGU9bnVsbDtudWxsIT1jJiYobXhFdmVudC5hZGRMaXN0ZW5lcihjLCJkcmFnbGVhdmUiLApmdW5jdGlvbihhKXtudWxsIT1lJiYoZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLGU9bnVsbCk7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSxteEV2ZW50LmFkZExpc3RlbmVyKGMsImRyYWdvdmVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1lJiYoIW14Q2xpZW50LklTX0lFfHwxMDxkb2N1bWVudC5kb2N1bWVudE1vZGUpJiYoZT10aGlzLmhpZ2hsaWdodEVsZW1lbnQoYykpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywiZHJvcCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9ZSYmKGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxlPW51bGwpO2lmKDA8YS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKXRoaXMuaW1wb3J0RmlsZXMoYS5kYXRhVHJhbnNmZXIuZmlsZXMsMCwwLHRoaXMubWF4SW1hZ2VTaXplLGZ1bmN0aW9uKGEsYyxlLGQsCmYsZyl7Yi5pbnNlcnRJbWFnZShhLGYsZyl9LGZ1bmN0aW9uKCl7fSxmdW5jdGlvbihhKXtyZXR1cm4iaW1hZ2UvIj09YS50eXBlLnN1YnN0cmluZygwLDYpfSxmdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKylhW2JdKCl9LG14RXZlbnQuaXNDb250cm9sRG93bihhKSk7ZWxzZSBpZigwPD1teFV0aWxzLmluZGV4T2YoYS5kYXRhVHJhbnNmZXIudHlwZXMsInRleHQvdXJpLWxpc3QiKSl7dmFyIGM9YS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgidGV4dC91cmktbGlzdCIpOy9cLihnaWZ8anBnfGpwZWd8dGlmZnxwbmd8c3ZnKSQvaS50ZXN0KGMpP3RoaXMubG9hZEltYWdlKGRlY29kZVVSSUNvbXBvbmVudChjKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgZT1NYXRoLm1heCgxLGEud2lkdGgpO2E9TWF0aC5tYXgoMSxhLmhlaWdodCk7dmFyIGQ9dGhpcy5tYXhJbWFnZVNpemUsZD1NYXRoLm1pbigxLE1hdGgubWluKGQvTWF0aC5tYXgoMSxlKSksZC9NYXRoLm1heCgxLAphKSk7Yi5pbnNlcnRJbWFnZShkZWNvZGVVUklDb21wb25lbnQoYyksZSpkLGEqZCl9KSk6ZG9jdW1lbnQuZXhlY0NvbW1hbmQoImluc2VydEhUTUwiLCExLGEuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvcGxhaW4iKSl9ZWxzZSAwPD1teFV0aWxzLmluZGV4T2YoYS5kYXRhVHJhbnNmZXIudHlwZXMsInRleHQvaHRtbCIpP2RvY3VtZW50LmV4ZWNDb21tYW5kKCJpbnNlcnRIVE1MIiwhMSxhLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L2h0bWwiKSk6MDw9bXhVdGlscy5pbmRleE9mKGEuZGF0YVRyYW5zZmVyLnR5cGVzLCJ0ZXh0L3BsYWluIikmJmRvY3VtZW50LmV4ZWNDb21tYW5kKCJpbnNlcnRIVE1MIiwhMSxhLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L3BsYWluIikpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpKX0pKTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cubXhTZXR0aW5ncyYmKHg9dGhpcy5lZGl0b3IuZ3JhcGgudmlldywKeC5zZXRVbml0KG14U2V0dGluZ3MuZ2V0VW5pdCgpKSx4LmFkZExpc3RlbmVyKCJ1bml0Q2hhbmdlZCIsZnVuY3Rpb24oYSxiKXtteFNldHRpbmdzLnNldFVuaXQoYi5nZXRQcm9wZXJ0eSgidW5pdCIpKTtteFNldHRpbmdzLnNhdmUoKX0pLHRoaXMucnVsZXI9IXRoaXMuY2FudmFzU3VwcG9ydGVkfHw5PT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fCIxIiE9dXJsUGFyYW1zLnJ1bGVyJiYhbXhTZXR0aW5ncy5pc1J1bGVyT24oKXx8dGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpJiYhdGhpcy5lZGl0b3IuZWRpdGFibGU/bnVsbDpuZXcgbXhEdWFsUnVsZXIodGhpcyx4LnVuaXQpLHRoaXMucmVmcmVzaCgpKTtpZigiMSI9PXVybFBhcmFtcy5zdHlsZWRldil7eD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VGb290ZXIiKTtudWxsIT14JiYodGhpcy5zdHlsZUlucHV0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0IiksdGhpcy5zdHlsZUlucHV0LnNldEF0dHJpYnV0ZSgidHlwZSIsCiJ0ZXh0IiksdGhpcy5zdHlsZUlucHV0LnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsdGhpcy5zdHlsZUlucHV0LnN0eWxlLnRvcD0iMTRweCIsdGhpcy5zdHlsZUlucHV0LnN0eWxlLmxlZnQ9IjJweCIsdGhpcy5zdHlsZUlucHV0LnN0eWxlLndpZHRoPSI5OCUiLHRoaXMuc3R5bGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLHRoaXMuc3R5bGVJbnB1dC5zdHlsZS5vcGFjaXR5PSIwLjkiLG14RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5zdHlsZUlucHV0LCJjaGFuZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5lZGl0b3IuZ3JhcGguZ2V0TW9kZWwoKS5zZXRTdHlsZSh0aGlzLmVkaXRvci5ncmFwaC5nZXRTZWxlY3Rpb25DZWxsKCksdGhpcy5zdHlsZUlucHV0LnZhbHVlKX0pKSx4LmFwcGVuZENoaWxkKHRoaXMuc3R5bGVJbnB1dCksdGhpcy5lZGl0b3IuZ3JhcGguZ2V0U2VsZWN0aW9uTW9kZWwoKS5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxiKXtpZigwPHRoaXMuZWRpdG9yLmdyYXBoLmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBjPXRoaXMuZWRpdG9yLmdyYXBoLmdldFNlbGVjdGlvbkNlbGwoKSxjPXRoaXMuZWRpdG9yLmdyYXBoLmdldE1vZGVsKCkuZ2V0U3R5bGUoYyk7dGhpcy5zdHlsZUlucHV0LnZhbHVlPWN8fCIiO3RoaXMuc3R5bGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5PSJ2aXNpYmxlIn1lbHNlIHRoaXMuc3R5bGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4ifSkpKTt2YXIgQz10aGlzLmlzU2VsZWN0aW9uQWxsb3dlZDt0aGlzLmlzU2VsZWN0aW9uQWxsb3dlZD1mdW5jdGlvbihhKXtyZXR1cm4gbXhFdmVudC5nZXRTb3VyY2UoYSk9PXRoaXMuc3R5bGVJbnB1dD8hMDpDLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19eD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2VJbmZvIik7bnVsbCE9eCYmeC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHgpO2lmKEdyYXBoLmZpbGVTdXBwb3J0JiYoIXRoaXMuZWRpdG9yLmNocm9tZWxlc3N8fAp0aGlzLmVkaXRvci5lZGl0YWJsZSkpe3ZhciBCPW51bGw7bXhFdmVudC5hZGRMaXN0ZW5lcihjLmNvbnRhaW5lciwiZHJhZ2xlYXZlIixmdW5jdGlvbihhKXtjLmlzRW5hYmxlZCgpJiYobnVsbCE9QiYmKEIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChCKSxCPW51bGwpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKX0pO214RXZlbnQuYWRkTGlzdGVuZXIoYy5jb250YWluZXIsImRyYWdvdmVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1CJiYoIW14Q2xpZW50LklTX0lFfHwxMDxkb2N1bWVudC5kb2N1bWVudE1vZGUpJiYoQj10aGlzLmhpZ2hsaWdodEVsZW1lbnQoYy5jb250YWluZXIpKTtudWxsIT10aGlzLnNpZGViYXImJnRoaXMuc2lkZWJhci5oaWRlVG9vbHRpcCgpO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoYy5jb250YWluZXIsImRyb3AiLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbihhKXtudWxsIT1CJiYoQi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEIpLEI9bnVsbCk7aWYoYy5pc0VuYWJsZWQoKSl7dmFyIGI9bXhVdGlscy5jb252ZXJ0UG9pbnQoYy5jb250YWluZXIsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSksZT1jLnZpZXcudHJhbnNsYXRlLGQ9Yy52aWV3LnNjYWxlLGY9Yi54L2QtZS54LGc9Yi55L2QtZS55O2lmKDA8YS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoKW14RXZlbnQuaXNBbHREb3duKGEpJiYoZz1mPW51bGwpLHRoaXMuaW1wb3J0RmlsZXMoYS5kYXRhVHJhbnNmZXIuZmlsZXMsZixnLHRoaXMubWF4SW1hZ2VTaXplLG51bGwsbnVsbCxudWxsLG51bGwsbXhFdmVudC5pc0NvbnRyb2xEb3duKGEpLG51bGwsbnVsbCxteEV2ZW50LmlzU2hpZnREb3duKGEpKTtlbHNle214RXZlbnQuaXNBbHREb3duKGEpJiYoZz1mPTApO3ZhciBsPTA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywKInRleHQvdXJpLWxpc3QiKT9hLmRhdGFUcmFuc2Zlci5nZXREYXRhKCJ0ZXh0L3VyaS1saXN0Iik6bnVsbCxiPXRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tRXZlbnQoYSxudWxsIT10aGlzLnBhZ2VzKTtpZihudWxsIT1iKWMuc2V0U2VsZWN0aW9uQ2VsbHModGhpcy5pbXBvcnRYbWwoYixmLGcsITApKTtlbHNlIGlmKDA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywidGV4dC9odG1sIikpe3ZhciBrPWEuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvaHRtbCIpLGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yi5pbm5lckhUTUw9azt2YXIgbT1udWxsLGU9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaW1nIik7bnVsbCE9ZSYmMT09ZS5sZW5ndGg/KGs9ZVswXS5nZXRBdHRyaWJ1dGUoInNyYyIpLC9cLihnaWZ8anBnfGpwZWd8dGlmZnxwbmd8c3ZnKSQvaS50ZXN0KGspfHwobT0hMCkpOihlPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKSxudWxsIT0KZSYmMT09ZS5sZW5ndGg/az1lWzBdLmdldEF0dHJpYnV0ZSgiaHJlZiIpOihiPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInByZSIpLG51bGwhPWImJjE9PWIubGVuZ3RoJiYoaz1teFV0aWxzLmdldFRleHRDb250ZW50KGJbMF0pKSkpO3ZhciBuPSEwLHA9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtjLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW5zZXJ0VGV4dEF0KGssZixnLCEwLG0sbnVsbCxuKSl9KTttJiZrLmxlbmd0aD50aGlzLnJlc2FtcGxlVGhyZXNob2xkP3RoaXMuY29uZmlybUltYWdlUmVzaXplKGZ1bmN0aW9uKGEpe249YTtwKCl9LG14RXZlbnQuaXNDb250cm9sRG93bihhKSk6cCgpfWVsc2UgbnVsbCE9bCYmL1wuKGdpZnxqcGd8anBlZ3x0aWZmfHBuZ3xzdmcpJC9pLnRlc3QobCk/dGhpcy5sb2FkSW1hZ2UoZGVjb2RlVVJJQ29tcG9uZW50KGwpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPU1hdGgubWF4KDEsYS53aWR0aCk7YT1NYXRoLm1heCgxLAphLmhlaWdodCk7dmFyIGU9dGhpcy5tYXhJbWFnZVNpemUsZT1NYXRoLm1pbigxLE1hdGgubWluKGUvTWF0aC5tYXgoMSxiKSksZS9NYXRoLm1heCgxLGEpKTtjLnNldFNlbGVjdGlvbkNlbGwoYy5pbnNlcnRWZXJ0ZXgobnVsbCxudWxsLCIiLGYsZyxiKmUsYSplLCJzaGFwZT1pbWFnZTt2ZXJ0aWNhbExhYmVsUG9zaXRpb249Ym90dG9tO2xhYmVsQmFja2dyb3VuZENvbG9yPSNmZmZmZmY7dmVydGljYWxBbGlnbj10b3A7YXNwZWN0PWZpeGVkO2ltYWdlQXNwZWN0PTA7aW1hZ2U9IitsKyI7IikpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yy5zZXRTZWxlY3Rpb25DZWxscyh0aGlzLmluc2VydFRleHRBdChsLGYsZywhMCkpfSkpOjA8PW14VXRpbHMuaW5kZXhPZihhLmRhdGFUcmFuc2Zlci50eXBlcywidGV4dC9wbGFpbiIpJiZjLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW5zZXJ0VGV4dEF0KGEuZGF0YVRyYW5zZmVyLmdldERhdGEoInRleHQvcGxhaW4iKSxmLGcsITApKX19YS5zdG9wUHJvcGFnYXRpb24oKTsKYS5wcmV2ZW50RGVmYXVsdCgpfSksITEpfXRoaXMuaW5pdFBhZ2VzKCk7IjEiPT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuaW5pdGlhbGl6ZUVtYmVkTW9kZSgpO3RoaXMuaW5zdGFsbFNldHRpbmdzKCl9O0VkaXRvclVpLnByb3RvdHlwZS5pbnN0YWxsSW1hZ2VQYXN0ZUhhbmRsZXI9ZnVuY3Rpb24oKXtpZighbXhDbGllbnQuSVNfSUUpe3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoO2EuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoInBhc3RlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtpZighbXhFdmVudC5pc0NvbnN1bWVkKGIpKXRyeXtmb3IodmFyIGM9Yi5jbGlwYm9hcmREYXRhfHxiLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YSxlPSExLGQ9MDtkPGMudHlwZXMubGVuZ3RoO2QrKylpZigidGV4dC8iPT09Yy50eXBlc1tkXS5zdWJzdHJpbmcoMCw1KSl7ZT0hMDticmVha31pZighZSl7dmFyIGY9Yy5pdGVtcztmb3IoaW5kZXggaW4gZil7dmFyIGs9ZltpbmRleF07CmlmKCJmaWxlIj09PWsua2luZCl7aWYoYS5pc0VkaXRpbmcoKSl0aGlzLmltcG9ydEZpbGVzKFtrLmdldEFzRmlsZSgpXSwwLDAsdGhpcy5tYXhJbWFnZVNpemUsZnVuY3Rpb24oYixjLGUsZCxmLGcpe2EuaW5zZXJ0SW1hZ2UoYixmLGcpfSxmdW5jdGlvbigpe30sZnVuY3Rpb24oYSl7cmV0dXJuImltYWdlLyI9PWEudHlwZS5zdWJzdHJpbmcoMCw2KX0sZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspYVtiXSgpfSk7ZWxzZXt2YXIgbT10aGlzLmVkaXRvci5ncmFwaC5nZXRJbnNlcnRQb2ludCgpO3RoaXMuaW1wb3J0RmlsZXMoW2suZ2V0QXNGaWxlKCldLG0ueCxtLnksdGhpcy5tYXhJbWFnZVNpemUpO214RXZlbnQuY29uc3VtZShiKX1icmVha319fX1jYXRjaCh5KXt9fSksITEpfX07RWRpdG9yVWkucHJvdG90eXBlLmluc3RhbGxOYXRpdmVDbGlwYm9hcmRIYW5kbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3dpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5pbm5lckhUTUw9CiImbmJzcDsiO2QuZm9jdXMoKTtkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKX0sMCl9dmFyIGM9dGhpcy5lZGl0b3IuZ3JhcGgsZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtkLnNldEF0dHJpYnV0ZSgiYXV0b2NvbXBsZXRlIiwib2ZmIik7ZC5zZXRBdHRyaWJ1dGUoImF1dG9jb3JyZWN0Iiwib2ZmIik7ZC5zZXRBdHRyaWJ1dGUoImF1dG9jYXBpdGFsaXplIiwib2ZmIik7ZC5zZXRBdHRyaWJ1dGUoInNwZWxsY2hlY2siLCJmYWxzZSIpO2Quc3R5bGUudGV4dFJlbmRlcmluZz0ib3B0aW1pemVTcGVlZCI7ZC5zdHlsZS5mb250RmFtaWx5PSJtb25vc3BhY2UiO2Quc3R5bGUud29yZEJyZWFrPSJicmVhay1hbGwiO2Quc3R5bGUuYmFja2dyb3VuZD0idHJhbnNwYXJlbnQiO2Quc3R5bGUuY29sb3I9InRyYW5zcGFyZW50IjtkLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7ZC5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2Quc3R5bGUub3ZlcmZsb3c9CiJoaWRkZW4iO2Quc3R5bGUuZGlzcGxheT0iYmxvY2siO2Quc3R5bGUuZm9udFNpemU9IjEiO2Quc3R5bGUuekluZGV4PSItMSI7ZC5zdHlsZS5yZXNpemU9Im5vbmUiO2Quc3R5bGUub3V0bGluZT0ibm9uZSI7ZC5zdHlsZS53aWR0aD0iMXB4IjtkLnN0eWxlLmhlaWdodD0iMXB4IjtteFV0aWxzLnNldE9wYWNpdHkoZCwwKTtkLmNvbnRlbnRFZGl0YWJsZT0hMDtkLmlubmVySFRNTD0iJm5ic3A7Ijt2YXIgZj0hMTt0aGlzLmtleUhhbmRsZXIuYmluZENvbnRyb2xLZXkoODgsbnVsbCk7dGhpcy5rZXlIYW5kbGVyLmJpbmRDb250cm9sS2V5KDY3LG51bGwpO3RoaXMua2V5SGFuZGxlci5iaW5kQ29udHJvbEtleSg4NixudWxsKTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJrZXlkb3duIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1teEV2ZW50LmdldFNvdXJjZShhKTtudWxsPT1jLmNvbnRhaW5lcnx8IWMuaXNFbmFibGVkKCl8fGMuaXNNb3VzZURvd258fApjLmlzRWRpdGluZygpfHxudWxsIT10aGlzLmRpYWxvZ3x8IklOUFVUIj09Yi5ub2RlTmFtZXx8IlRFWFRBUkVBIj09Yi5ub2RlTmFtZXx8ISgyMjQ9PWEua2V5Q29kZXx8IW14Q2xpZW50LklTX01BQyYmMTc9PWEua2V5Q29kZXx8bXhDbGllbnQuSVNfTUFDJiY5MT09YS5rZXlDb2RlKXx8Znx8KGQuc3R5bGUubGVmdD1jLmNvbnRhaW5lci5zY3JvbGxMZWZ0KzEwKyJweCIsZC5zdHlsZS50b3A9Yy5jb250YWluZXIuc2Nyb2xsVG9wKzEwKyJweCIsYy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZCksZj0hMCxteENsaWVudC5JU19RVUlSS1M/d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtkLmZvY3VzKCk7ZG9jdW1lbnQuZXhlY0NvbW1hbmQoInNlbGVjdEFsbCIsITEsbnVsbCl9LDApOihkLmZvY3VzKCksZG9jdW1lbnQuZXhlY0NvbW1hbmQoInNlbGVjdEFsbCIsITEsbnVsbCkpKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCJrZXl1cCIsbXhVdGlscy5iaW5kKHRoaXMsCmZ1bmN0aW9uKGEpe3ZhciBiPWEua2V5Q29kZTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpeyFmfHwyMjQhPWImJjE3IT1iJiY5MSE9Ynx8KGY9ITEsYy5pc0VkaXRpbmcoKXx8bnVsbCE9dGhpcy5kaWFsb2d8fG51bGw9PWMuY29udGFpbmVyfHxjLmNvbnRhaW5lci5mb2N1cygpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxudWxsPT10aGlzLmRpYWxvZyYmbXhVdGlscy5jbGVhclNlbGVjdGlvbigpKX0pLDApfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiY29weSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYil7aWYoYy5pc0VuYWJsZWQoKSl0cnl7bXhDbGlwYm9hcmQuY29weShjKSx0aGlzLmNvcHlDZWxscyhkKSxhKCl9Y2F0Y2godil7dGhpcy5oYW5kbGVFcnJvcih2KX19KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjdXQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2lmKGMuaXNFbmFibGVkKCkpdHJ5e214Q2xpcGJvYXJkLmNvcHkoYyksCnRoaXMuY29weUNlbGxzKGQsITApLGEoKX1jYXRjaCh2KXt0aGlzLmhhbmRsZUVycm9yKHYpfX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGQsInBhc3RlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLmlzRW5hYmxlZCgpJiYhYy5pc0NlbGxMb2NrZWQoYy5nZXREZWZhdWx0UGFyZW50KCkpJiYoKG5ldyBEYXRlKS5nZXRUaW1lKCksZC5pbm5lckhUTUw9IiZuYnNwOyIsZC5mb2N1cygpLG51bGwhPWEuY2xpcGJvYXJkRGF0YSYmdGhpcy5wYXN0ZUNlbGxzKGEsZCwhMCwhMCksbXhFdmVudC5pc0NvbnN1bWVkKGEpfHx3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMucGFzdGVDZWxscyhhLGQsITEsITApfSksMCkpfSksITApO3ZhciBsPXRoaXMuaXNTZWxlY3Rpb25BbGxvd2VkO3RoaXMuaXNTZWxlY3Rpb25BbGxvd2VkPWZ1bmN0aW9uKGEpe3JldHVybiBteEV2ZW50LmdldFNvdXJjZShhKT09ZD8hMDpsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19OwpFZGl0b3JVaS5wcm90b3R5cGUuZ2V0TGlua1RpdGxlPWZ1bmN0aW9uKGEpe3ZhciBiPUdyYXBoLnByb3RvdHlwZS5nZXRMaW5rVGl0bGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKCJkYXRhOnBhZ2UvaWQsIj09YS5zdWJzdHJpbmcoMCwxMykpe3ZhciBjPWEuaW5kZXhPZigiLCIpOzA8YyYmKGI9dGhpcy5nZXRQYWdlQnlJZChhLnN1YnN0cmluZyhjKzEpKSxiPW51bGwhPWI/Yi5nZXROYW1lKCk6bXhSZXNvdXJjZXMuZ2V0KCJwYWdlTm90Rm91bmQiKSl9ZWxzZSJkYXRhOiI9PWEuc3Vic3RyaW5nKDAsNSkmJihiPW14UmVzb3VyY2VzLmdldCgiYWN0aW9uIikpO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuaGFuZGxlQ3VzdG9tTGluaz1mdW5jdGlvbihhKXtpZigiZGF0YTpwYWdlL2lkLCI9PWEuc3Vic3RyaW5nKDAsMTMpKXt2YXIgYj1hLmluZGV4T2YoIiwiKTtpZihhPXRoaXMuZ2V0UGFnZUJ5SWQoYS5zdWJzdHJpbmcoYisxKSkpdGhpcy5zZWxlY3RQYWdlKGEpO2Vsc2UgdGhyb3cgRXJyb3IobXhSZXNvdXJjZXMuZ2V0KCJwYWdlTm90Rm91bmQiKXx8CiJQYWdlIG5vdCBmb3VuZCIpO31lbHNlIHRoaXMuZWRpdG9yLmdyYXBoLmhhbmRsZUN1c3RvbUxpbmsoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5pc1NldHRpbmdzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiJ1bmRlZmluZWQiIT09dHlwZW9mIHdpbmRvdy5teFNldHRpbmdzJiYoaXNMb2NhbFN0b3JhZ2V8fG14Q2xpZW50LklTX0NIUk9NRUFQUCl9O0VkaXRvclVpLnByb3RvdHlwZS5pbnN0YWxsU2V0dGluZ3M9ZnVuY3Rpb24oKXtpZih0aGlzLmlzU2V0dGluZ3NFbmFibGVkKCkpe0NvbG9yRGlhbG9nLnJlY2VudENvbG9ycz1teFNldHRpbmdzLmdldFJlY2VudENvbG9ycygpO2lmKGlzTG9jYWxTdG9yYWdlKXRyeXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigic3RvcmFnZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7YS5rZXk9PW14U2V0dGluZ3Mua2V5JiYobXhTZXR0aW5ncy5sb2FkKCksQ29sb3JEaWFsb2cucmVjZW50Q29sb3JzPW14U2V0dGluZ3MuZ2V0UmVjZW50Q29sb3JzKCksCnRoaXMubWVudXMuY3VzdG9tRm9udHM9bXhTZXR0aW5ncy5nZXRDdXN0b21Gb250cygpKX0pLCExKX1jYXRjaChiKXt9dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInN0eWxlQ2hhbmdlZCIsImtleXMiLFtdLCJ2YWx1ZXMiLFtdLCJjZWxscyIsW10pKTt0aGlzLm1lbnVzLmN1c3RvbUZvbnRzPW14U2V0dGluZ3MuZ2V0Q3VzdG9tRm9udHMoKTt0aGlzLmFkZExpc3RlbmVyKCJjdXN0b21Gb250c0NoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7dmFyIGI9Yy5nZXRQcm9wZXJ0eSgiY3VzdG9tRm9udHMiKTt0aGlzLm1lbnVzLmN1c3RvbUZvbnRzPWI7bXhTZXR0aW5ncy5zZXRDdXN0b21Gb250cyhiKTtteFNldHRpbmdzLnNhdmUoKX0pKTt0aGlzLmVkaXRvci5ncmFwaC5jb25uZWN0aW9uSGFuZGxlci5zZXRDcmVhdGVUYXJnZXQobXhTZXR0aW5ncy5pc0NyZWF0ZVRhcmdldCgpKTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgiY29weUNvbm5lY3RDaGFuZ2VkIikpOwp0aGlzLmFkZExpc3RlbmVyKCJjb3B5Q29ubmVjdENoYW5nZWQiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7bXhTZXR0aW5ncy5zZXRDcmVhdGVUYXJnZXQodGhpcy5lZGl0b3IuZ3JhcGguY29ubmVjdGlvbkhhbmRsZXIuaXNDcmVhdGVUYXJnZXQoKSk7bXhTZXR0aW5ncy5zYXZlKCl9KSk7dGhpcy5lZGl0b3IuZ3JhcGgucGFnZUZvcm1hdD1teFNldHRpbmdzLmdldFBhZ2VGb3JtYXQoKTt0aGlzLmFkZExpc3RlbmVyKCJwYWdlRm9ybWF0Q2hhbmdlZCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtteFNldHRpbmdzLnNldFBhZ2VGb3JtYXQodGhpcy5lZGl0b3IuZ3JhcGgucGFnZUZvcm1hdCk7bXhTZXR0aW5ncy5zYXZlKCl9KSk7dGhpcy5lZGl0b3IuZ3JhcGgudmlldy5ncmlkQ29sb3I9bXhTZXR0aW5ncy5nZXRHcmlkQ29sb3IoImRhcmsiPT11aVRoZW1lKTt0aGlzLmFkZExpc3RlbmVyKCJncmlkQ29sb3JDaGFuZ2VkIixteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSxjKXtteFNldHRpbmdzLnNldEdyaWRDb2xvcih0aGlzLmVkaXRvci5ncmFwaC52aWV3LmdyaWRDb2xvciwiZGFyayI9PXVpVGhlbWUpO214U2V0dGluZ3Muc2F2ZSgpfSkpO2lmKG14Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcCl0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigiYXV0b3NhdmVDaGFuZ2VkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe214U2V0dGluZ3Muc2V0QXV0b3NhdmUodGhpcy5lZGl0b3IuYXV0b3NhdmUpO214U2V0dGluZ3Muc2F2ZSgpfSkpLHRoaXMuZWRpdG9yLmF1dG9zYXZlPW14U2V0dGluZ3MuZ2V0QXV0b3NhdmUoKTtudWxsIT10aGlzLnNpZGViYXImJnRoaXMuc2lkZWJhci5zaG93UGFsZXR0ZSgic2VhcmNoIixteFNldHRpbmdzLnNldHRpbmdzLnNlYXJjaCk7dGhpcy5lZGl0b3IuY2hyb21lbGVzcyYmIXRoaXMuZWRpdG9yLmVkaXRhYmxlfHxudWxsPT10aGlzLnNpZGViYXJ8fCEobXhTZXR0aW5ncy5zZXR0aW5ncy5pc05ld3x8Cjg+PXBhcnNlSW50KG14U2V0dGluZ3Muc2V0dGluZ3MudmVyc2lvbnx8MCkpfHwodGhpcy50b2dnbGVTY3JhdGNocGFkKCksbXhTZXR0aW5ncy5zYXZlKCkpO3RoaXMuYWRkTGlzdGVuZXIoImZvcm1hdFdpZHRoQ2hhbmdlZCIsZnVuY3Rpb24oKXtteFNldHRpbmdzLnNldEZvcm1hdFdpZHRoKHRoaXMuZm9ybWF0V2lkdGgpO214U2V0dGluZ3Muc2F2ZSgpfSl9fTtFZGl0b3JVaS5wcm90b3R5cGUuY29weUNlbGxzPWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoYi5pc1NlbGVjdGlvbkVtcHR5KCkpYS5pbm5lckhUTUw9IiI7ZWxzZXt2YXIgZD1teFV0aWxzLnNvcnRDZWxscyhiLm1vZGVsLmdldFRvcG1vc3RDZWxscyhiLmdldFNlbGVjdGlvbkNlbGxzKCkpKSxlPW14VXRpbHMuZ2V0WG1sKGIuZW5jb2RlQ2VsbHMoZCkpO214VXRpbHMuc2V0VGV4dENvbnRlbnQoYSxlbmNvZGVVUklDb21wb25lbnQoZSkpO2M/KGIucmVtb3ZlQ2VsbHMoZCwhMSksYi5sYXN0UGFzdGVYbWw9Cm51bGwpOihiLmxhc3RQYXN0ZVhtbD1lLGIucGFzdGVDb3VudGVyPTApO2EuZm9jdXMoKTtkb2N1bWVudC5leGVjQ29tbWFuZCgic2VsZWN0QWxsIiwhMSxudWxsKX19O0VkaXRvclVpLnByb3RvdHlwZS5wYXN0ZUNlbGxzPWZ1bmN0aW9uKGEsYyxkLGYpe2lmKCFteEV2ZW50LmlzQ29uc3VtZWQoYSkpe3ZhciBiPWMsZT0hMTtpZihkJiZudWxsIT1hLmNsaXBib2FyZERhdGEmJmEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKXt2YXIgZz1hLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgidGV4dC9odG1sIik7aWYobnVsbCE9ZyYmMDxnLmxlbmd0aCl7Yj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLmlubmVySFRNTD1nO2U9ITA7Zz1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzdHlsZSIpO2lmKG51bGwhPWcpZm9yKDswPGcubGVuZ3RoOylnWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ1swXSk7bnVsbCE9Yi5maXJzdENoaWxkJiZiLmZpcnN0Q2hpbGQubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQmJgpudWxsIT1iLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcmJmIuZmlyc3RDaGlsZC5uZXh0U2libGluZy5ub2RlVHlwZT09bXhDb25zdGFudHMuTk9ERVRZUEVfRUxFTUVOVCYmIk1FVEEiPT1iLmZpcnN0Q2hpbGQubm9kZU5hbWUmJiJBIj09Yi5maXJzdENoaWxkLm5leHRTaWJsaW5nLm5vZGVOYW1lJiZudWxsPT1iLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcubmV4dFNpYmxpbmcmJihnPW51bGw9PWIuZmlyc3RDaGlsZC5uZXh0U2libGluZy5pbm5lclRleHQ/bXhVdGlscy5nZXRUZXh0Q29udGVudChiLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcpOmIuZmlyc3RDaGlsZC5uZXh0U2libGluZy5pbm5lclRleHQsZz09Yi5maXJzdENoaWxkLm5leHRTaWJsaW5nLmdldEF0dHJpYnV0ZSgiaHJlZiIpJiYobXhVdGlscy5zZXRUZXh0Q29udGVudChiLGcpLGU9ITEpKTtHcmFwaC5yZW1vdmVQYXN0ZUZvcm1hdHRpbmcoYil9ZWxzZSBnPWEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCJ0ZXh0L3BsYWluIiksCm51bGwhPWcmJjA8Zy5sZW5ndGgmJihiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLG14VXRpbHMuc2V0VGV4dENvbnRlbnQoYixnKSl9Zz1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzcGFuIik7aWYobnVsbCE9ZyYmMDxnLmxlbmd0aCYmImFwcGxpY2F0aW9uL3ZuZC5sdWNpZC5jaGFydC5vYmplY3RzIj09PWdbMF0uZ2V0QXR0cmlidXRlKCJkYXRhLWx1Y2lkLXR5cGUiKSlkPWdbMF0uZ2V0QXR0cmlidXRlKCJkYXRhLWx1Y2lkLWNvbnRlbnQiKSxudWxsIT1kJiYwPGQubGVuZ3RoJiYodGhpcy5jb252ZXJ0THVjaWRDaGFydChkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWRpdG9yLmdyYXBoO2IubGFzdFBhc3RlWG1sPT1hP2IucGFzdGVDb3VudGVyKys6KGIubGFzdFBhc3RlWG1sPWEsYi5wYXN0ZUNvdW50ZXI9MCk7dmFyIGM9Yi5wYXN0ZUNvdW50ZXIqYi5ncmlkU2l6ZTtiLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW1wb3J0WG1sKGEsYywKYykpO2Iuc2Nyb2xsQ2VsbFRvVmlzaWJsZShiLmdldFNlbGVjdGlvbkNlbGwoKSl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhhbmRsZUVycm9yKGEpfSkpLG14RXZlbnQuY29uc3VtZShhKSk7ZWxzZXt2YXIgZT1lP2IuaW5uZXJIVE1MOm14VXRpbHMudHJpbShudWxsPT1iLmlubmVyVGV4dD9teFV0aWxzLmdldFRleHRDb250ZW50KGIpOmIuaW5uZXJUZXh0KSxrPSExO3RyeXt2YXIgbT1lLmxhc3RJbmRleE9mKCIlM0UiKTswPD1tJiZtPGUubGVuZ3RoLTMmJihlPWUuc3Vic3RyaW5nKDAsbSszKSl9Y2F0Y2goeil7fXRyeXt2YXIgZz1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJzcGFuIiksbj1udWxsIT1nJiYwPGcubGVuZ3RoP214VXRpbHMudHJpbShkZWNvZGVVUklDb21wb25lbnQoZ1swXS50ZXh0Q29udGVudCkpOmRlY29kZVVSSUNvbXBvbmVudChlKTt0aGlzLmlzQ29tcGF0aWJsZVN0cmluZyhuKSYmKGs9ITAsZT1uKX1jYXRjaCh6KXt9dHJ5e3ZhciBxPQp0aGlzLmVkaXRvci5ncmFwaDtpZihudWxsIT1lJiYwPGUubGVuZ3RoKXtxLmxhc3RQYXN0ZVhtbD09ZT9xLnBhc3RlQ291bnRlcisrOihxLmxhc3RQYXN0ZVhtbD1lLHEucGFzdGVDb3VudGVyPTApO3ZhciBCPXEucGFzdGVDb3VudGVyKnEuZ3JpZFNpemU7aWYoa3x8dGhpcy5pc0NvbXBhdGlibGVTdHJpbmcoZSkpcS5zZXRTZWxlY3Rpb25DZWxscyh0aGlzLmltcG9ydFhtbChlLEIsQikpO2Vsc2UgaWYoZiYmMT09cS5nZXRTZWxlY3Rpb25Db3VudCgpKXEubGFiZWxDaGFuZ2VkKHEuZ2V0U2VsZWN0aW9uQ2VsbCgpLGUpLEdyYXBoLmlzTGluayhlKSYmcS5zZXRMaW5rRm9yQ2VsbChxLmdldFNlbGVjdGlvbkNlbGwoKSxlKTtlbHNle3ZhciBEPXEuZ2V0SW5zZXJ0UG9pbnQoKTtxLmlzTW91c2VJbnNlcnRQb2ludCgpJiYoQj0wLHEubGFzdFBhc3RlWG1sPT1lJiYwPHEucGFzdGVDb3VudGVyJiZxLnBhc3RlQ291bnRlci0tKTtxLnNldFNlbGVjdGlvbkNlbGxzKHRoaXMuaW5zZXJ0VGV4dEF0KGUsCkQueCtCLEQueStCLCEwKSl9cS5pc1NlbGVjdGlvbkVtcHR5KCl8fChxLnNjcm9sbENlbGxUb1Zpc2libGUocS5nZXRTZWxlY3Rpb25DZWxsKCkpLG51bGwhPXRoaXMuaG92ZXJJY29ucyYmdGhpcy5ob3Zlckljb25zLnVwZGF0ZShxLnZpZXcuZ2V0U3RhdGUocS5nZXRTZWxlY3Rpb25DZWxsKCkpKSk7dHJ5e214RXZlbnQuY29uc3VtZShhKX1jYXRjaCh6KXt9fWVsc2UgZHx8KHEubGFzdFBhc3RlWG1sPW51bGwscS5wYXN0ZUNvdW50ZXI9MCl9Y2F0Y2goeil7dGhpcy5oYW5kbGVFcnJvcih6KX19fWMuaW5uZXJIVE1MPSImbmJzcDsifTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkRmlsZURyb3BIYW5kbGVyPWZ1bmN0aW9uKGEpe2lmKEdyYXBoLmZpbGVTdXBwb3J0KWZvcih2YXIgYj1udWxsLGM9MDtjPGEubGVuZ3RoO2MrKylteEV2ZW50LmFkZExpc3RlbmVyKGFbY10sImRyYWdsZWF2ZSIsZnVuY3Rpb24oYSl7bnVsbCE9YiYmKGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSxiPW51bGwpOwphLnN0b3BQcm9wYWdhdGlvbigpO2EucHJldmVudERlZmF1bHQoKX0pLG14RXZlbnQuYWRkTGlzdGVuZXIoYVtjXSwiZHJhZ292ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpeyh0aGlzLmVkaXRvci5ncmFwaC5pc0VuYWJsZWQoKXx8IjEiIT11cmxQYXJhbXMuZW1iZWQpJiZudWxsPT1iJiYoIW14Q2xpZW50LklTX0lFfHwxMDxkb2N1bWVudC5kb2N1bWVudE1vZGUmJjEyPmRvY3VtZW50LmRvY3VtZW50TW9kZSkmJihiPXRoaXMuaGlnaGxpZ2h0RWxlbWVudCgpKTthLnN0b3BQcm9wYWdhdGlvbigpO2EucHJldmVudERlZmF1bHQoKX0pKSxteEV2ZW50LmFkZExpc3RlbmVyKGFbY10sImRyb3AiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWImJihiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1udWxsKTtpZih0aGlzLmVkaXRvci5ncmFwaC5pc0VuYWJsZWQoKXx8IjEiIT11cmxQYXJhbXMuZW1iZWQpaWYoMDxhLmRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGgpdGhpcy5oaWRlRGlhbG9nKCksCiIxIj09dXJsUGFyYW1zLmVtYmVkP3RoaXMuaW1wb3J0RmlsZXMoYS5kYXRhVHJhbnNmZXIuZmlsZXMsMCwwLHRoaXMubWF4SW1hZ2VTaXplLG51bGwsbnVsbCxudWxsLG51bGwsIW14RXZlbnQuaXNDb250cm9sRG93bihhKSYmIW14RXZlbnQuaXNTaGlmdERvd24oYSkpOnRoaXMub3BlbkZpbGVzKGEuZGF0YVRyYW5zZmVyLmZpbGVzLCEwKTtlbHNle3ZhciBjPXRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tRXZlbnQoYSk7aWYobnVsbD09Yyl7dmFyIGQ9bnVsbCE9YS5kYXRhVHJhbnNmZXI/YS5kYXRhVHJhbnNmZXI6YS5jbGlwYm9hcmREYXRhO251bGwhPWQmJigxMD09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHwxMT09ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP2M9ZC5nZXREYXRhKCJUZXh0Iik6KGM9bnVsbCxjPTA8PW14VXRpbHMuaW5kZXhPZihkLnR5cGVzLCJ0ZXh0L3VyaS1saXN0Iik/YS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgidGV4dC91cmktbGlzdCIpOjA8PW14VXRpbHMuaW5kZXhPZihkLnR5cGVzLAoidGV4dC9odG1sIik/ZC5nZXREYXRhKCJ0ZXh0L2h0bWwiKTpudWxsLG51bGwhPWMmJjA8Yy5sZW5ndGg/KGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IiksZC5pbm5lckhUTUw9YyxkPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImltZyIpLDA8ZC5sZW5ndGgmJihjPWRbMF0uZ2V0QXR0cmlidXRlKCJzcmMiKSkpOjA8PW14VXRpbHMuaW5kZXhPZihkLnR5cGVzLCJ0ZXh0L3BsYWluIikmJihjPWQuZ2V0RGF0YSgidGV4dC9wbGFpbiIpKSksbnVsbCE9YyYmKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsIj09Yy5zdWJzdHJpbmcoMCwyMik/KGM9dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoYyksbnVsbCE9YyYmMDxjLmxlbmd0aCYmdGhpcy5vcGVuTG9jYWxGaWxlKGMsbnVsbCwhMCkpOiF0aGlzLmlzT2ZmbGluZSgpJiZ0aGlzLmlzUmVtb3RlRmlsZUZvcm1hdChjKT8obmV3IG14WG1sUmVxdWVzdChPUEVOX1VSTCwiZm9ybWF0PXhtbCZkYXRhPSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKSkuc2VuZChteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7MjAwPD1hLmdldFN0YXR1cygpJiYyOTk+PWEuZ2V0U3RhdHVzKCkmJnRoaXMub3BlbkxvY2FsRmlsZShhLmdldFRleHQoKSxudWxsLCEwKX0pKTovXmh0dHBzPzpcL1wvLy50ZXN0KGMpJiYobnVsbD09dGhpcy5nZXRDdXJyZW50RmlsZSgpP3dpbmRvdy5sb2NhdGlvbi5oYXNoPSIjVSIrZW5jb2RlVVJJQ29tcG9uZW50KGMpOndpbmRvdy5vcGVuV2luZG93KChteENsaWVudC5JU19DSFJPTUVBUFA/RWRpdG9yVWkuZHJhd0hvc3QrIi8iOiJodHRwczovLyIrbG9jYXRpb24uaG9zdCsiLyIpK3dpbmRvdy5sb2NhdGlvbi5zZWFyY2grIiNVIitlbmNvZGVVUklDb21wb25lbnQoYykpKSkpfWVsc2UgdGhpcy5vcGVuTG9jYWxGaWxlKGMsbnVsbCwhMCl9YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSl9O0VkaXRvclVpLnByb3RvdHlwZS5oaWdobGlnaHRFbGVtZW50PWZ1bmN0aW9uKGEpe3ZhciBiPTAsYz0wLGQsZjtpZihudWxsPT1hKXtmPWRvY3VtZW50LmJvZHk7CnZhciBrPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtkPShmLmNsaWVudFdpZHRofHxrLmNsaWVudFdpZHRoKS0zO2Y9TWF0aC5tYXgoZi5jbGllbnRIZWlnaHR8fDAsay5jbGllbnRIZWlnaHQpLTN9ZWxzZSBiPWEub2Zmc2V0VG9wLGM9YS5vZmZzZXRMZWZ0LGQ9YS5jbGllbnRXaWR0aCxmPWEuY2xpZW50SGVpZ2h0O2s9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ay5zdHlsZS56SW5kZXg9bXhQb3B1cE1lbnUucHJvdG90eXBlLnpJbmRleCsyO2suc3R5bGUuYm9yZGVyPSIzcHggZG90dGVkIHJnYigyNTQsIDEzNywgMTIpIjtrLnN0eWxlLnBvaW50ZXJFdmVudHM9Im5vbmUiO2suc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtrLnN0eWxlLnRvcD1iKyJweCI7ay5zdHlsZS5sZWZ0PWMrInB4IjtrLnN0eWxlLndpZHRoPU1hdGgubWF4KDAsZC0zKSsicHgiO2suc3R5bGUuaGVpZ2h0PU1hdGgubWF4KDAsZi0zKSsicHgiO251bGwhPWEmJmEucGFyZW50Tm9kZT09dGhpcy5lZGl0b3IuZ3JhcGguY29udGFpbmVyPwp0aGlzLmVkaXRvci5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQoayk6ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChrKTtyZXR1cm4ga307RWRpdG9yVWkucHJvdG90eXBlLnN0cmluZ1RvQ2VsbHM9ZnVuY3Rpb24oYSl7YT1teFV0aWxzLnBhcnNlWG1sKGEpO3ZhciBiPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGEuZG9jdW1lbnRFbGVtZW50KTthPVtdO2lmKG51bGwhPWIpe3ZhciBjPW5ldyBteENvZGVjKGIub3duZXJEb2N1bWVudCksZD1uZXcgbXhHcmFwaE1vZGVsO2MuZGVjb2RlKGIsZCk7Yj1kLmdldENoaWxkQXQoZC5nZXRSb290KCksMCk7Zm9yKGM9MDtjPGQuZ2V0Q2hpbGRDb3VudChiKTtjKyspYS5wdXNoKGQuZ2V0Q2hpbGRBdChiLGMpKX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLm9wZW5GaWxlcz1mdW5jdGlvbihhLGMpe2lmKHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJsb2FkaW5nIikpKWZvcih2YXIgYj0KMDtiPGEubGVuZ3RoO2IrKylteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt2YXIgYj1uZXcgRmlsZVJlYWRlcjtiLm9ubG9hZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0cnl7dmFyIGQ9Yi50YXJnZXQucmVzdWx0LGU9YS5uYW1lO2lmKG51bGwhPWUmJjA8ZS5sZW5ndGgpeyF0aGlzLnVzZUNhbnZhc0ZvckV4cG9ydCYmLyhcLnBuZykkL2kudGVzdChlKT9lPWUuc3Vic3RyaW5nKDAsZS5sZW5ndGgtNCkrIi5kcmF3aW8iOi8oXC5wZGYpJC9pLnRlc3QoZSkmJihlPWUuc3Vic3RyaW5nKDAsZS5sZW5ndGgtNCkrIi5kcmF3aW8iKTt2YXIgZj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtlPTA8PWUubGFzdEluZGV4T2YoIi4iKT9lLnN1YnN0cmluZygwLGUubGFzdEluZGV4T2YoIi4iKSkrIi5kcmF3aW8iOmUrIi5kcmF3aW8iO2lmKCI8bXhsaWJyYXJ5Ij09YS5zdWJzdHJpbmcoMCwxMCkpe251bGw9PXRoaXMuZ2V0Q3VycmVudEZpbGUoKSYmIjEiIT11cmxQYXJhbXMuZW1iZWQmJgp0aGlzLm9wZW5Mb2NhbEZpbGUodGhpcy5lbXB0eURpYWdyYW1YbWwsdGhpcy5kZWZhdWx0RmlsZW5hbWUsYyk7dHJ5e3RoaXMubG9hZExpYnJhcnkobmV3IExvY2FsTGlicmFyeSh0aGlzLGEsZSkpfWNhdGNoKEIpe3RoaXMuaGFuZGxlRXJyb3IoQixteFJlc291cmNlcy5nZXQoImVycm9yTG9hZGluZ0ZpbGUiKSl9fWVsc2UgdGhpcy5vcGVuTG9jYWxGaWxlKGEsZSxjKX0pO2lmKC8oXC52KGR4fHNkeD8pKSgkfFw/KS9pLnRlc3QoZSl8fC8oXC52cyh4fHN4PykpKCR8XD8pL2kudGVzdChlKSl0aGlzLmltcG9ydFZpc2lvKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zcGlubmVyLnN0b3AoKTtmKGEpfSkpO2Vsc2UgaWYoLyhcLio8Z3JhcGhtbCApLy50ZXN0KGQpKXRoaXMuaW1wb3J0R3JhcGhNTChkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7ZihhKX0pKTtlbHNlIGlmKEdyYXBoLmZpbGVTdXBwb3J0JiYhdGhpcy5pc09mZmxpbmUoKSYmCihuZXcgWE1MSHR0cFJlcXVlc3QpLnVwbG9hZCYmdGhpcy5pc1JlbW90ZUZpbGVGb3JtYXQoZCxlKSl0aGlzLnBhcnNlRmlsZShhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpezQ9PWEucmVhZHlTdGF0ZSYmKHRoaXMuc3Bpbm5lci5zdG9wKCksMjAwPD1hLnN0YXR1cyYmMjk5Pj1hLnN0YXR1cz9mKGEucmVzcG9uc2VUZXh0KTp0aGlzLmhhbmRsZUVycm9yKHttZXNzYWdlOm14UmVzb3VyY2VzLmdldCg0MTM9PWEuc3RhdHVzPyJkcmF3aW5nVG9vTGFyZ2UiOiJpbnZhbGlkT3JNaXNzaW5nRmlsZSIpfSxteFJlc291cmNlcy5nZXQoImVycm9yTG9hZGluZ0ZpbGUiKSkpfSkpO2Vsc2UgaWYodGhpcy5pc0x1Y2lkQ2hhcnREYXRhKGQpKS8oXC5qc29uKSQvaS50ZXN0KGUpJiYoZT1lLnN1YnN0cmluZygwLGUubGVuZ3RoLTUpKyIuZHJhd2lvIiksdGhpcy5jb252ZXJ0THVjaWRDaGFydChkLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuc3Bpbm5lci5zdG9wKCk7dGhpcy5vcGVuTG9jYWxGaWxlKGEsCmUsYyl9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSl9KSk7ZWxzZSBpZigiPG14bGlicmFyeSI9PWIudGFyZ2V0LnJlc3VsdC5zdWJzdHJpbmcoMCwxMCkpe3RoaXMuc3Bpbm5lci5zdG9wKCk7bnVsbD09dGhpcy5nZXRDdXJyZW50RmlsZSgpJiYiMSIhPXVybFBhcmFtcy5lbWJlZCYmdGhpcy5vcGVuTG9jYWxGaWxlKHRoaXMuZW1wdHlEaWFncmFtWG1sLHRoaXMuZGVmYXVsdEZpbGVuYW1lLGMpO3RyeXt0aGlzLmxvYWRMaWJyYXJ5KG5ldyBMb2NhbExpYnJhcnkodGhpcyxiLnRhcmdldC5yZXN1bHQsYS5uYW1lKSl9Y2F0Y2goQyl7dGhpcy5oYW5kbGVFcnJvcihDLG14UmVzb3VyY2VzLmdldCgiZXJyb3JMb2FkaW5nRmlsZSIpKX19ZWxzZSBpZigwPT1kLmluZGV4T2YoIlBLIikpdGhpcy5pbXBvcnRaaXBGaWxlKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5zcGlubmVyLnN0b3AoKTsKZihhKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zcGlubmVyLnN0b3AoKTt0aGlzLm9wZW5Mb2NhbEZpbGUoZCxlLGMpfSkpO2Vsc2V7aWYoImltYWdlL3BuZyI9PWEudHlwZS5zdWJzdHJpbmcoMCw5KSlkPXRoaXMuZXh0cmFjdEdyYXBoTW9kZWxGcm9tUG5nKGQpO2Vsc2UgaWYoImFwcGxpY2F0aW9uL3BkZiI9PWEudHlwZSl7dmFyIGc9RWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBkZihkKTtudWxsIT1nJiYoZD1nKX10aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMub3BlbkxvY2FsRmlsZShkLGUsYyl9fX1jYXRjaChDKXt0aGlzLmhhbmRsZUVycm9yKEMpfX0pO2Iub25lcnJvcj1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnNwaW5uZXIuc3RvcCgpO3RoaXMuaGFuZGxlRXJyb3IoYSk7d2luZG93Lm9wZW5GaWxlPW51bGx9KTsiaW1hZ2UiIT09YS50eXBlLnN1YnN0cmluZygwLDUpJiYiYXBwbGljYXRpb24vcGRmIiE9PWEudHlwZXx8ImltYWdlL3N2ZyI9PT0KYS50eXBlLnN1YnN0cmluZygwLDkpP2IucmVhZEFzVGV4dChhKTpiLnJlYWRBc0RhdGFVUkwoYSl9KShhW2JdKX07RWRpdG9yVWkucHJvdG90eXBlLm9wZW5Mb2NhbEZpbGU9ZnVuY3Rpb24oYSxjLGQpe3ZhciBiPXRoaXMuZ2V0Q3VycmVudEZpbGUoKSxlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7d2luZG93Lm9wZW5GaWxlPW51bGw7aWYobnVsbD09YyYmbnVsbCE9dGhpcy5nZXRDdXJyZW50RmlsZSgpJiZ0aGlzLmlzRGlhZ3JhbUVtcHR5KCkpe3ZhciBiPW14VXRpbHMucGFyc2VYbWwoYSk7bnVsbCE9YiYmKHRoaXMuZWRpdG9yLnNldEdyYXBoWG1sKGIuZG9jdW1lbnRFbGVtZW50KSx0aGlzLmVkaXRvci5ncmFwaC5zZWxlY3RBbGwoKSl9ZWxzZSB0aGlzLmZpbGVMb2FkZWQobmV3IExvY2FsRmlsZSh0aGlzLGEsY3x8dGhpcy5kZWZhdWx0RmlsZW5hbWUsZCkpfSk7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCludWxsPT1ifHwhYi5pc01vZGlmaWVkKCkmJihteENsaWVudC5JU19DSFJPTUVBUFB8fApFZGl0b3JVaS5pc0VsZWN0cm9uQXBwKT9lKCk6KG14Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcCkmJm51bGwhPWImJmIuaXNNb2RpZmllZCgpP3RoaXMuY29uZmlybShteFJlc291cmNlcy5nZXQoImFsbENoYW5nZXNMb3N0IiksbnVsbCxlLG14UmVzb3VyY2VzLmdldCgiY2FuY2VsIiksbXhSZXNvdXJjZXMuZ2V0KCJkaXNjYXJkQ2hhbmdlcyIpKTood2luZG93Lm9wZW5GaWxlPW5ldyBPcGVuRmlsZShmdW5jdGlvbigpe3dpbmRvdy5vcGVuRmlsZT1udWxsfSksd2luZG93Lm9wZW5GaWxlLnNldERhdGEoYSxjKSx3aW5kb3cub3BlbldpbmRvdyh0aGlzLmdldFVybCgpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtudWxsIT1iJiZiLmlzTW9kaWZpZWQoKT90aGlzLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJhbGxDaGFuZ2VzTG9zdCIpLG51bGwsZSxteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLG14UmVzb3VyY2VzLmdldCgiZGlzY2FyZENoYW5nZXMiKSk6CmUoKX0pKSk7ZWxzZSB0aHJvdyBFcnJvcihteFJlc291cmNlcy5nZXQoIm5vdEFEaWFncmFtRmlsZSIpKTt9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRCYXNlbmFtZXM9ZnVuY3Rpb24oKXt2YXIgYT17fTtpZihudWxsIT10aGlzLnBhZ2VzKWZvcih2YXIgYz0wO2M8dGhpcy5wYWdlcy5sZW5ndGg7YysrKXRoaXMudXBkYXRlUGFnZVJvb3QodGhpcy5wYWdlc1tjXSksdGhpcy5hZGRCYXNlbmFtZXNGb3JDZWxsKHRoaXMucGFnZXNbY10ucm9vdCxhKTtlbHNlIHRoaXMuYWRkQmFzZW5hbWVzRm9yQ2VsbCh0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5nZXRSb290KCksYSk7dmFyIGM9W10sZDtmb3IoZCBpbiBhKWMucHVzaChkKTtyZXR1cm4gY307RWRpdG9yVWkucHJvdG90eXBlLmFkZEJhc2VuYW1lc0ZvckNlbGw9ZnVuY3Rpb24oYSxjKXtmdW5jdGlvbiBiKGEpe2lmKG51bGwhPWEpe3ZhciBiPWEubGFzdEluZGV4T2YoIi4iKTswPGImJihhPWEuc3Vic3RyaW5nKGIrMSxhLmxlbmd0aCkpOwpudWxsPT1jW2FdJiYoY1thXT0hMCl9fXZhciBkPXRoaXMuZWRpdG9yLmdyYXBoLGU9ZC5nZXRDZWxsU3R5bGUoYSk7YihteFN0ZW5jaWxSZWdpc3RyeS5nZXRCYXNlbmFtZUZvclN0ZW5jaWwoZVtteENvbnN0YW50cy5TVFlMRV9TSEFQRV0pKTtkLm1vZGVsLmlzRWRnZShhKSYmKGIobXhNYXJrZXIuZ2V0UGFja2FnZUZvclR5cGUoZVtteENvbnN0YW50cy5TVFlMRV9TVEFSVEFSUk9XXSkpLGIobXhNYXJrZXIuZ2V0UGFja2FnZUZvclR5cGUoZVtteENvbnN0YW50cy5TVFlMRV9FTkRBUlJPV10pKSk7Zm9yKHZhciBlPWQubW9kZWwuZ2V0Q2hpbGRDb3VudChhKSxmPTA7ZjxlO2YrKyl0aGlzLmFkZEJhc2VuYW1lc0ZvckNlbGwoZC5tb2RlbC5nZXRDaGlsZEF0KGEsZiksYyl9O0VkaXRvclVpLnByb3RvdHlwZS5zZXRHcmFwaEVuYWJsZWQ9ZnVuY3Rpb24oYSl7dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIjt0aGlzLmZvcm1hdENvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5PQphPyIiOiJoaWRkZW4iO3RoaXMuc2lkZWJhckZvb3RlckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiO3RoaXMuc2lkZWJhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PWE/IiI6Im5vbmUiO3RoaXMuaHNwbGl0LnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSI7dGhpcy5lZGl0b3IuZ3JhcGguc2V0RW5hYmxlZChhKTtudWxsIT10aGlzLnJ1bGVyJiYodGhpcy5ydWxlci5oUnVsZXIuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIix0aGlzLnJ1bGVyLnZSdWxlci5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT1hPyIiOiJoaWRkZW4iKTtudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmKHRoaXMudGFiQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9YT8iIjoiaGlkZGVuIik7YXx8KG51bGwhPXRoaXMuYWN0aW9ucy5vdXRsaW5lV2luZG93JiZ0aGlzLmFjdGlvbnMub3V0bGluZVdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSksbnVsbCE9dGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdyYmCnRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3cud2luZG93LnNldFZpc2libGUoITEpLG51bGwhPXRoaXMubWVudXMudGFnc1dpbmRvdyYmdGhpcy5tZW51cy50YWdzV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSxudWxsIT10aGlzLm1lbnVzLmZpbmRXaW5kb3cmJnRoaXMubWVudXMuZmluZFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSkpfTtFZGl0b3JVaS5wcm90b3R5cGUuaW5pdGlhbGl6ZUVtYmVkTW9kZT1mdW5jdGlvbigpe3RoaXMuc2V0R3JhcGhFbmFibGVkKCExKTsod2luZG93Lm9wZW5lcnx8d2luZG93LnBhcmVudCkhPXdpbmRvdyYmKCIxIiE9dXJsUGFyYW1zLnNwaW58fHRoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJsb2FkaW5nIikpKSYmdGhpcy5pbnN0YWxsTWVzc2FnZUhhbmRsZXIobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjLGQpe3RoaXMuc3Bpbm5lci5zdG9wKCk7dGhpcy5hZGRFbWJlZEJ1dHRvbnMoKTt0aGlzLnNldEdyYXBoRW5hYmxlZCghMCk7CmlmKG51bGw9PWF8fDA9PWEubGVuZ3RoKWE9dGhpcy5lbXB0eURpYWdyYW1YbWw7dGhpcy5zZXRDdXJyZW50RmlsZShuZXcgTG9jYWxGaWxlKHRoaXMsYSx0aGlzLmRlZmF1bHRGaWxlbmFtZSwhMCkpO3RoaXMuc2V0RmlsZURhdGEoYSk7dGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpP3RoaXMuZWRpdG9yLmdyYXBoLmlzTGlnaHRib3hWaWV3KCkmJnRoaXMubGlnaHRib3hGaXQoKTp0aGlzLnNob3dMYXllcnNEaWFsb2coKTt0aGlzLmNocm9tZWxlc3NSZXNpemUmJnRoaXMuY2hyb21lbGVzc1Jlc2l6ZSgpO3RoaXMuZWRpdG9yLnVuZG9NYW5hZ2VyLmNsZWFyKCk7dGhpcy5lZGl0b3IubW9kaWZpZWQ9bnVsbCE9ZD9kOiExO3RoaXMudXBkYXRlVWkoKTt3aW5kb3cuc2VsZiE9PXdpbmRvdy50b3AmJndpbmRvdy5mb2N1cygpO251bGwhPXRoaXMuZm9ybWF0JiZ0aGlzLmZvcm1hdC5yZWZyZXNoKCl9KSl9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93TGF5ZXJzRGlhbG9nPWZ1bmN0aW9uKCl7MTwKdGhpcy5lZGl0b3IuZ3JhcGguZ2V0TW9kZWwoKS5nZXRDaGlsZENvdW50KHRoaXMuZWRpdG9yLmdyYXBoLmdldE1vZGVsKCkuZ2V0Um9vdCgpKSYmKG51bGw9PXRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3c/dGhpcy5hY3Rpb25zLmdldCgibGF5ZXJzIikuZnVuY3QoKTp0aGlzLmFjdGlvbnMubGF5ZXJzV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCEwKSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRQdWJsaWNVcmw9ZnVuY3Rpb24oYSxjKXtudWxsIT1hP2EuZ2V0UHVibGljVXJsKGMpOmMobnVsbCl9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVMb2FkTWVzc2FnZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmVkaXRvci5ncmFwaDtyZXR1cm57ZXZlbnQ6YSxwYWdlVmlzaWJsZTpiLnBhZ2VWaXNpYmxlLHRyYW5zbGF0ZTpiLnZpZXcudHJhbnNsYXRlLGJvdW5kczpiLmdldEdyYXBoQm91bmRzKCksY3VycmVudFBhZ2U6dGhpcy5nZXRTZWxlY3RlZFBhZ2VJbmRleCgpLHNjYWxlOmIudmlldy5zY2FsZSwKcGFnZTpiLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHMoKX19O0VkaXRvclVpLnByb3RvdHlwZS5pbnN0YWxsTWVzc2FnZUhhbmRsZXI9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbCxjPSExLGQ9ITEsZj1udWxsLGs9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLmVkaXRvci5tb2RpZmllZCYmIjAiIT11cmxQYXJhbXMubW9kaWZpZWQ/bnVsbCE9dXJsUGFyYW1zLm1vZGlmaWVkJiZ0aGlzLmVkaXRvci5zZXRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KHVybFBhcmFtcy5tb2RpZmllZCkpKTp0aGlzLmVkaXRvci5zZXRTdGF0dXMoIiIpfSk7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0Usayk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csIm1lc3NhZ2UiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGUpe2lmKGUuc291cmNlPT0od2luZG93Lm9wZW5lcnx8d2luZG93LnBhcmVudCkpe3ZhciBnPQplLmRhdGEsbD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZihudWxsIT1hJiYiZnVuY3Rpb24iPT09dHlwZW9mIGEuY2hhckF0JiYiPCIhPWEuY2hhckF0KDApKXRyeXsiZGF0YTppbWFnZS9wbmc7YmFzZTY0LCI9PWEuc3Vic3RyaW5nKDAsMjIpP2E9dGhpcy5leHRyYWN0R3JhcGhNb2RlbEZyb21QbmcoYSk6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsIj09YS5zdWJzdHJpbmcoMCwyNik/YT1hdG9iKGEuc3Vic3RyaW5nKDI2KSk6ImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCI9PWEuc3Vic3RyaW5nKDAsMjQpJiYoYT1hLnN1YnN0cmluZygyNCkpLG51bGwhPWEmJigiJSI9PWEuY2hhckF0KDApP2E9ZGVjb2RlVVJJQ29tcG9uZW50KGEpOiI8IiE9YS5jaGFyQXQoMCkmJihhPUdyYXBoLmRlY29tcHJlc3MoYSkpKX1jYXRjaChZKXt9cmV0dXJuIGF9KTtpZigianNvbiI9PXVybFBhcmFtcy5wcm90byl7dHJ5e2c9SlNPTi5wYXJzZShnKX1jYXRjaChUKXtnPW51bGx9dHJ5e2lmKG51bGw9PQpnKXJldHVybjtpZigiZGlhbG9nIj09Zy5hY3Rpb24pe3RoaXMuc2hvd0Vycm9yKG51bGwhPWcudGl0bGVLZXk/bXhSZXNvdXJjZXMuZ2V0KGcudGl0bGVLZXkpOmcudGl0bGUsbnVsbCE9Zy5tZXNzYWdlS2V5P214UmVzb3VyY2VzLmdldChnLm1lc3NhZ2VLZXkpOmcubWVzc2FnZSxudWxsIT1nLmJ1dHRvbktleT9teFJlc291cmNlcy5nZXQoZy5idXR0b25LZXkpOmcuYnV0dG9uKTtudWxsIT1nLm1vZGlmaWVkJiYodGhpcy5lZGl0b3IubW9kaWZpZWQ9Zy5tb2RpZmllZCk7cmV0dXJufWlmKCJwcm9tcHQiPT1nLmFjdGlvbil7dGhpcy5zcGlubmVyLnN0b3AoKTt2YXIgaz1uZXcgRmlsZW5hbWVEaWFsb2codGhpcyxnLmRlZmF1bHRWYWx1ZXx8IiIsbnVsbCE9Zy5va0tleT9teFJlc291cmNlcy5nZXQoZy5va0tleSk6bnVsbCxmdW5jdGlvbihhKXtudWxsIT1hJiZtLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoicHJvbXB0Iix2YWx1ZTphLG1lc3NhZ2U6Z30pLCIqIil9LApudWxsIT1nLnRpdGxlS2V5P214UmVzb3VyY2VzLmdldChnLnRpdGxlS2V5KTpnLnRpdGxlKTt0aGlzLnNob3dEaWFsb2coay5jb250YWluZXIsMzAwLDgwLCEwLCExKTtrLmluaXQoKTtyZXR1cm59aWYoImRyYWZ0Ij09Zy5hY3Rpb24pe3ZhciBuPWwoZy54bWwpO3RoaXMuc3Bpbm5lci5zdG9wKCk7az1uZXcgRHJhZnREaWFsb2codGhpcyxteFJlc291cmNlcy5nZXQoImRyYWZ0Rm91bmQiLFtnLm5hbWV8fHRoaXMuZGVmYXVsdEZpbGVuYW1lXSksbixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpO20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJkcmFmdCIscmVzdWx0OiJlZGl0IixtZXNzYWdlOmd9KSwiKiIpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhpZGVEaWFsb2coKTttLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoiZHJhZnQiLHJlc3VsdDoiZGlzY2FyZCIsbWVzc2FnZTpnfSksIioiKX0pLApnLmVkaXRLZXk/bXhSZXNvdXJjZXMuZ2V0KGcuZWRpdEtleSk6bnVsbCxnLmRpc2NhcmRLZXk/bXhSZXNvdXJjZXMuZ2V0KGcuZGlzY2FyZEtleSk6bnVsbCxnLmlnbm9yZT9teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuaGlkZURpYWxvZygpO20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJkcmFmdCIscmVzdWx0OiJpZ25vcmUiLG1lc3NhZ2U6Z30pLCIqIil9KTpudWxsKTt0aGlzLnNob3dEaWFsb2coay5jb250YWluZXIsNjQwLDQ4MCwhMCwhMSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthJiZ0aGlzLmFjdGlvbnMuZ2V0KCJleGl0IikuZnVuY3QoKX0pKTt0cnl7ay5pbml0KCl9Y2F0Y2goVCl7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6ImRyYWZ0IixlcnJvcjpULnRvU3RyaW5nKCksbWVzc2FnZTpnfSksIioiKX1yZXR1cm59aWYoInRlbXBsYXRlIj09Zy5hY3Rpb24pe3RoaXMuc3Bpbm5lci5zdG9wKCk7dmFyIHA9CjE9PWcuZW5hYmxlUmVjZW50LHE9MT09Zy5lbmFibGVTZWFyY2gsdD0xPT1nLmVuYWJsZUN1c3RvbVRlbXAsaz1uZXcgTmV3RGlhbG9nKHRoaXMsITEsbnVsbCE9Zy5jYWxsYmFjayxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiLGMpe2I9Ynx8dGhpcy5lbXB0eURpYWdyYW1YbWw7bnVsbCE9Zy5jYWxsYmFjaz9tLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoidGVtcGxhdGUiLHhtbDpiLGJsYW5rOmI9PXRoaXMuZW1wdHlEaWFncmFtWG1sLG5hbWU6YyxtZXNzYWdlOmd9KSwiKiIpOihhKGIsZSxiIT10aGlzLmVtcHR5RGlhZ3JhbVhtbCksdGhpcy5lZGl0b3IubW9kaWZpZWR8fHRoaXMuZWRpdG9yLnNldFN0YXR1cygiIikpfSksbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxwP214VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMucmVtb3RlSW52b2tlKCJnZXRSZWNlbnREaWFncmFtcyIsbnVsbCxudWxsLGEsZnVuY3Rpb24oKXthKG51bGwsCiJOZXR3b3JrIEVycm9yISIpfSl9KTpudWxsLHE/bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXt0aGlzLnJlbW90ZUludm9rZSgic2VhcmNoRGlhZ3JhbXMiLFthXSxudWxsLGIsZnVuY3Rpb24oKXtiKG51bGwsIk5ldHdvcmsgRXJyb3IhIil9KX0pOm51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiLGMpe20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2V2ZW50OiJ0ZW1wbGF0ZSIsZG9jVXJsOmEsaW5mbzpiLG5hbWU6Y30pLCIqIil9KSxudWxsLG51bGwsdD9teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLnJlbW90ZUludm9rZSgiZ2V0Q3VzdG9tVGVtcGxhdGVzIixudWxsLG51bGwsYSxmdW5jdGlvbigpe2Eoe30sMCl9KX0pOm51bGwpO3RoaXMuc2hvd0RpYWxvZyhrLmNvbnRhaW5lciw2MjAsNDQwLCEwLCExLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2EmJnRoaXMuYWN0aW9ucy5nZXQoImV4aXQiKS5mdW5jdCgpfSkpO2suaW5pdCgpOwpyZXR1cm59aWYoInRleHRDb250ZW50Ij09Zy5hY3Rpb24pe3ZhciB5PXRoaXMuZ2V0RGlhZ3JhbVRleHRDb250ZW50KCk7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6InRleHRDb250ZW50IixkYXRhOnksbWVzc2FnZTpnfSksIioiKTtyZXR1cm59aWYoInN0YXR1cyI9PWcuYWN0aW9uKXtudWxsIT1nLm1lc3NhZ2VLZXk/dGhpcy5lZGl0b3Iuc2V0U3RhdHVzKG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldChnLm1lc3NhZ2VLZXkpKSk6bnVsbCE9Zy5tZXNzYWdlJiZ0aGlzLmVkaXRvci5zZXRTdGF0dXMobXhVdGlscy5odG1sRW50aXRpZXMoZy5tZXNzYWdlKSk7bnVsbCE9Zy5tb2RpZmllZCYmKHRoaXMuZWRpdG9yLm1vZGlmaWVkPWcubW9kaWZpZWQpO3JldHVybn1pZigic3Bpbm5lciI9PWcuYWN0aW9uKXt2YXIgdj1udWxsIT1nLm1lc3NhZ2VLZXk/bXhSZXNvdXJjZXMuZ2V0KGcubWVzc2FnZUtleSk6Zy5tZXNzYWdlO251bGw9PWcuc2hvd3x8Cmcuc2hvdz90aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LHYpOnRoaXMuc3Bpbm5lci5zdG9wKCk7cmV0dXJufWlmKCJleHBvcnQiPT1nLmFjdGlvbil7aWYoInBuZyI9PWcuZm9ybWF0fHwieG1scG5nIj09Zy5mb3JtYXQpe2lmKG51bGw9PWcuc3BpbiYmbnVsbD09Zy5zcGluS2V5fHx0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG51bGwhPWcuc3BpbktleT9teFJlc291cmNlcy5nZXQoZy5zcGluS2V5KTpnLnNwaW4pKXt2YXIgSj1udWxsIT1nLnhtbD9nLnhtbDp0aGlzLmdldEZpbGVEYXRhKCEwKTt0aGlzLmVkaXRvci5ncmFwaC5zZXRFbmFibGVkKCExKTt2YXIgdT10aGlzLmVkaXRvci5ncmFwaCxLPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEVuYWJsZWQoITApO3RoaXMuc3Bpbm5lci5zdG9wKCk7dmFyIGI9dGhpcy5jcmVhdGVMb2FkTWVzc2FnZSgiZXhwb3J0Iik7Yi5mb3JtYXQ9Zy5mb3JtYXQ7Yi5tZXNzYWdlPQpnO2IuZGF0YT1hO2IueG1sPUo7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShiKSwiKiIpfSksQT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsPT1hJiYoYT1FZGl0b3IuYmxhbmtJbWFnZSk7InhtbHBuZyI9PWcuZm9ybWF0JiYoYT1FZGl0b3Iud3JpdGVHcmFwaE1vZGVsVG9QbmcoYSwidEVYdCIsIm14ZmlsZSIsZW5jb2RlVVJJQ29tcG9uZW50KEopKSk7dSE9dGhpcy5lZGl0b3IuZ3JhcGgmJnUuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodS5jb250YWluZXIpO0soYSl9KSxNPWcucGFnZUlkfHwobnVsbCE9dGhpcy5wYWdlcz90aGlzLnBhZ2VzWzBdLmdldElkKCk6bnVsbCk7aWYodGhpcy5pc0V4cG9ydFRvQ2FudmFzKCkpe2lmKG51bGwhPXRoaXMucGFnZXMmJnRoaXMuY3VycmVudFBhZ2UuZ2V0SWQoKSE9TSl7Zm9yKHZhciBRPXUuZ2V0R2xvYmFsVmFyaWFibGUsdT10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKHUuZ2V0U3R5bGVzaGVldCgpKSwKSSxSPTA7Ujx0aGlzLnBhZ2VzLmxlbmd0aDtSKyspaWYodGhpcy5wYWdlc1tSXS5nZXRJZCgpPT1NKXtJPXRoaXMudXBkYXRlUGFnZVJvb3QodGhpcy5wYWdlc1tSXSk7YnJlYWt9dS5nZXRHbG9iYWxWYXJpYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4icGFnZSI9PWE/SS5nZXROYW1lKCk6InBhZ2VudW1iZXIiPT1hPzE6US5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodS5jb250YWluZXIpO3UubW9kZWwuc2V0Um9vdChJLnJvb3QpfWlmKG51bGwhPWcubGF5ZXJJZHMpe2Zvcih2YXIgWj11Lm1vZGVsLFc9Wi5nZXRDaGlsZENlbGxzKFouZ2V0Um9vdCgpKSxrPXt9LFI9MDtSPGcubGF5ZXJJZHMubGVuZ3RoO1IrKylrW2cubGF5ZXJJZHNbUl1dPSEwO2ZvcihSPTA7UjxXLmxlbmd0aDtSKyspWi5zZXRWaXNpYmxlKFdbUl0sa1tXW1JdLmlkXXx8ITEpfXRoaXMuZWRpdG9yLmV4cG9ydFRvQ2FudmFzKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe0EoYS50b0RhdGFVUkwoImltYWdlL3BuZyIpKX0pLApudWxsLG51bGwsbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe0EobnVsbCl9KSxudWxsLG51bGwsZy5zY2FsZSxudWxsLG51bGwsbnVsbCx1KX1lbHNlKG5ldyBteFhtbFJlcXVlc3QoRVhQT1JUX1VSTCwiZm9ybWF0PXBuZyZlbWJlZFhtbD0iKygieG1scG5nIj09Zy5mb3JtYXQ/IjEiOiIwIikrKG51bGwhPU0/IiZwYWdlSWQ9IitNOiIiKSsobnVsbCE9Zy5sYXllcklkcz8iJmV4dHJhcz0iK2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7bGF5ZXJJZHM6Zy5sYXllcklkc30pKToiIikrKG51bGwhPWcuc2NhbGU/IiZzY2FsZT0iK2cuc2NhbGU6IiIpKyImYmFzZTY0PTEmeG1sPSIrZW5jb2RlVVJJQ29tcG9uZW50KEopKSkuc2VuZChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXsyMDA8PWEuZ2V0U3RhdHVzKCkmJjI5OT49YS5nZXRTdGF0dXMoKT9LKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsIithLmdldFRleHQoKSk6QShudWxsKX0pLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe0EobnVsbCl9KSl9fWVsc2V7bnVsbCE9Zy54bWwmJjA8Zy54bWwubGVuZ3RoJiZ0aGlzLnNldEZpbGVEYXRhKGcueG1sKTt2PXRoaXMuY3JlYXRlTG9hZE1lc3NhZ2UoImV4cG9ydCIpO3YubWVzc2FnZT1nO2lmKCJodG1sMiI9PWcuZm9ybWF0fHwiaHRtbCI9PWcuZm9ybWF0JiYoIjAiIT11cmxQYXJhbXMucGFnZXN8fG51bGwhPXRoaXMucGFnZXMmJjE8dGhpcy5wYWdlcy5sZW5ndGgpKXt2YXIgaWE9dGhpcy5nZXRYbWxGaWxlRGF0YSgpO3YueG1sPW14VXRpbHMuZ2V0WG1sKGlhKTt2LmRhdGE9dGhpcy5nZXRGaWxlRGF0YShudWxsLG51bGwsITAsbnVsbCxudWxsLG51bGwsaWEpO3YuZm9ybWF0PWcuZm9ybWF0fWVsc2UgaWYoImh0bWwiPT1nLmZvcm1hdClKPXRoaXMuZWRpdG9yLmdldEdyYXBoWG1sKCksdi5kYXRhPXRoaXMuZ2V0SHRtbChKLHRoaXMuZWRpdG9yLmdyYXBoKSx2LnhtbD1teFV0aWxzLmdldFhtbChKKSx2LmZvcm1hdD1nLmZvcm1hdDtlbHNle214U3ZnQ2FudmFzMkQucHJvdG90eXBlLmZvQWx0VGV4dD0KbnVsbDt2YXIgYmE9dGhpcy5lZGl0b3IuZ3JhcGguYmFja2dyb3VuZDtiYT09bXhDb25zdGFudHMuTk9ORSYmKGJhPW51bGwpO3YueG1sPXRoaXMuZ2V0RmlsZURhdGEoITAsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCExKTt2LmZvcm1hdD0ic3ZnIjt2YXIgVT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5zZXRFbmFibGVkKCEwKTt0aGlzLnNwaW5uZXIuc3RvcCgpO3YuZGF0YT1FZGl0b3IuY3JlYXRlU3ZnRGF0YVVyaShhKTttLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHYpLCIqIil9KTtpZigieG1sc3ZnIj09Zy5mb3JtYXQpKG51bGw9PWcuc3BpbiYmbnVsbD09Zy5zcGluS2V5fHx0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG51bGwhPWcuc3BpbktleT9teFJlc291cmNlcy5nZXQoZy5zcGluS2V5KTpnLnNwaW4pKSYmdGhpcy5nZXRFbWJlZGRlZFN2Zyh2LnhtbCx0aGlzLmVkaXRvci5ncmFwaCwKbnVsbCwhMCxVLG51bGwsbnVsbCxnLmVtYmVkSW1hZ2VzKTtlbHNlIGlmKG51bGw9PWcuc3BpbiYmbnVsbD09Zy5zcGluS2V5fHx0aGlzLnNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5LG51bGwhPWcuc3BpbktleT9teFJlc291cmNlcy5nZXQoZy5zcGluS2V5KTpnLnNwaW4pKXt0aGlzLmVkaXRvci5ncmFwaC5zZXRFbmFibGVkKCExKTt2YXIgY2E9dGhpcy5lZGl0b3IuZ3JhcGguZ2V0U3ZnKGJhKTt0aGlzLmVtYmVkRm9udHMoY2EsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Zy5lbWJlZEltYWdlc3x8bnVsbD09Zy5lbWJlZEltYWdlcz90aGlzLmVkaXRvci5jb252ZXJ0SW1hZ2VzKGEsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7VShteFV0aWxzLmdldFhtbChhKSl9KSk6VShteFV0aWxzLmdldFhtbChhKSl9KSl9cmV0dXJufW0ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkodiksIioiKX1yZXR1cm59aWYoImxvYWQiPT1nLmFjdGlvbilkPTE9PWcuYXV0b3NhdmUsCnRoaXMuaGlkZURpYWxvZygpLG51bGwhPWcubW9kaWZpZWQmJm51bGw9PXVybFBhcmFtcy5tb2RpZmllZCYmKHVybFBhcmFtcy5tb2RpZmllZD1nLm1vZGlmaWVkKSxudWxsIT1nLnNhdmVBbmRFeGl0JiZudWxsPT11cmxQYXJhbXMuc2F2ZUFuZEV4aXQmJih1cmxQYXJhbXMuc2F2ZUFuZEV4aXQ9Zy5zYXZlQW5kRXhpdCksbnVsbCE9Zy5ub1NhdmVCdG4mJm51bGw9PXVybFBhcmFtcy5ub1NhdmVCdG4mJih1cmxQYXJhbXMubm9TYXZlQnRuPWcubm9TYXZlQnRuKSxudWxsIT1nLm5vRXhpdEJ0biYmbnVsbD09dXJsUGFyYW1zLm5vRXhpdEJ0biYmKHVybFBhcmFtcy5ub0V4aXRCdG49Zy5ub0V4aXRCdG4pLG51bGwhPWcudGl0bGUmJm51bGwhPXRoaXMuYnV0dG9uQ29udGFpbmVyJiYobj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIiksbXhVdGlscy53cml0ZShuLGcudGl0bGUpLCJhdGxhcyI9PXVpVGhlbWU/KHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdSaWdodD0KIjEycHgiLHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdUb3A9IjZweCIsdGhpcy5idXR0b25Db250YWluZXIuc3R5bGUucmlnaHQ9IjI1cHgiKToibWluIiE9dWlUaGVtZSYmKHRoaXMuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdSaWdodD0iMzhweCIsdGhpcy5idXR0b25Db250YWluZXIuc3R5bGUucGFkZGluZ1RvcD0iNnB4IiksbnVsbCE9dGhpcy5lbWJlZEZpbGVuYW1lU3BhbiYmdGhpcy5lbWJlZEZpbGVuYW1lU3Bhbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZW1iZWRGaWxlbmFtZVNwYW4pLHRoaXMuYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKG4pLHRoaXMuZW1iZWRGaWxlbmFtZVNwYW49biksZz1udWxsIT1nLnhtbHBuZz90aGlzLmV4dHJhY3RHcmFwaE1vZGVsRnJvbVBuZyhnLnhtbHBuZyk6Zy54bWw7ZWxzZXtpZigibWVyZ2UiPT1nLmFjdGlvbil7dmFyIGRhPXRoaXMuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1kYSYmKG49bChnLnhtbCksCm51bGwhPW4mJiIiIT1uJiZkYS5tZXJnZUZpbGUobmV3IExvY2FsRmlsZSh0aGlzLG4pLGZ1bmN0aW9uKCl7bS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7ZXZlbnQ6Im1lcmdlIixtZXNzYWdlOmd9KSwiKiIpfSxmdW5jdGlvbihhKXttLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoibWVyZ2UiLG1lc3NhZ2U6ZyxlcnJvcjphfSksIioiKX0pKX1lbHNlInJlbW90ZUludm9rZVJlYWR5Ij09Zy5hY3Rpb24/dGhpcy5oYW5kbGVSZW1vdGVJbnZva2VSZWFkeShtKToicmVtb3RlSW52b2tlIj09Zy5hY3Rpb24/dGhpcy5oYW5kbGVSZW1vdGVJbnZva2UoZyxlLm9yaWdpbik6InJlbW90ZUludm9rZVJlc3BvbnNlIj09Zy5hY3Rpb24/dGhpcy5oYW5kbGVSZW1vdGVJbnZva2VSZXNwb25zZShnKTptLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtlcnJvcjoidW5rbm93bk1lc3NhZ2UiLGRhdGE6SlNPTi5zdHJpbmdpZnkoZyl9KSwiKiIpO3JldHVybn19Y2F0Y2goVCl7dGhpcy5oYW5kbGVFcnJvcihUKX19dmFyIGFhPQpteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihlLGcpe2M9ITA7dHJ5e2EoZSxnKX1jYXRjaChlYSl7dGhpcy5oYW5kbGVFcnJvcihlYSl9Yz0hMTtudWxsIT11cmxQYXJhbXMubW9kaWZpZWQmJnRoaXMuZWRpdG9yLnNldFN0YXR1cygiIik7dmFyIGw9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4iMCIhPXVybFBhcmFtcy5wYWdlc3x8bnVsbCE9dGhpcy5wYWdlcyYmMTx0aGlzLnBhZ2VzLmxlbmd0aD90aGlzLmdldEZpbGVEYXRhKCEwKTpteFV0aWxzLmdldFhtbCh0aGlzLmVkaXRvci5nZXRHcmFwaFhtbCgpKX0pO2Y9bCgpO2QmJm51bGw9PWImJihiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dmFyIGQ9bCgpO2lmKGQhPWYmJiFjKXt2YXIgZT10aGlzLmNyZWF0ZUxvYWRNZXNzYWdlKCJhdXRvc2F2ZSIpO2UueG1sPWQ7ZD1KU09OLnN0cmluZ2lmeShlKTsod2luZG93Lm9wZW5lcnx8d2luZG93LnBhcmVudCkucG9zdE1lc3NhZ2UoZCwiKiIpfWY9ZH0pLAp0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxiKSx0aGlzLmVkaXRvci5ncmFwaC5hZGRMaXN0ZW5lcigiZ3JpZFNpemVDaGFuZ2VkIixiKSx0aGlzLmVkaXRvci5ncmFwaC5hZGRMaXN0ZW5lcigic2hhZG93VmlzaWJsZUNoYW5nZWQiLGIpLHRoaXMuYWRkTGlzdGVuZXIoInBhZ2VGb3JtYXRDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJwYWdlU2NhbGVDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJiYWNrZ3JvdW5kQ29sb3JDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJiYWNrZ3JvdW5kSW1hZ2VDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJmb2xkaW5nRW5hYmxlZENoYW5nZWQiLGIpLHRoaXMuYWRkTGlzdGVuZXIoIm1hdGhFbmFibGVkQ2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigiZ3JpZEVuYWJsZWRDaGFuZ2VkIixiKSx0aGlzLmFkZExpc3RlbmVyKCJndWlkZXNFbmFibGVkQ2hhbmdlZCIsYiksdGhpcy5hZGRMaXN0ZW5lcigicGFnZVZpZXdDaGFuZ2VkIiwKYikpO2lmKCIxIj09dXJsUGFyYW1zLnJldHVybmJvdW5kc3x8Impzb24iPT11cmxQYXJhbXMucHJvdG8pe3ZhciBrPXRoaXMuY3JlYXRlTG9hZE1lc3NhZ2UoImxvYWQiKTtrLnhtbD1lO20ucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoayksIioiKX19KTtudWxsIT1nJiYiZnVuY3Rpb24iPT09dHlwZW9mIGcuc3Vic3RyaW5nJiYiZGF0YTphcHBsaWNhdGlvbi92bmQudmlzaW87YmFzZTY0LCI9PWcuc3Vic3RyaW5nKDAsMzQpPyhsPSIwTThSNEtHeEd1RSI9PWcuc3Vic3RyaW5nKDM0LDQ1KT8icmF3LnZzZCI6InJhdy52c2R4Iix0aGlzLmltcG9ydFZpc2lvKHRoaXMuYmFzZTY0VG9CbG9iKGcuc3Vic3RyaW5nKGcuaW5kZXhPZigiLCIpKzEpKSxmdW5jdGlvbihhKXthYShhLGUpfSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmhhbmRsZUVycm9yKGEpfSksbCkpOm51bGwhPWcmJiJmdW5jdGlvbiI9PT10eXBlb2YgZy5zdWJzdHJpbmcmJiF0aGlzLmlzT2ZmbGluZSgpJiYKKG5ldyBYTUxIdHRwUmVxdWVzdCkudXBsb2FkJiZ0aGlzLmlzUmVtb3RlRmlsZUZvcm1hdChnLCIiKT90aGlzLnBhcnNlRmlsZShuZXcgQmxvYihbZ10se3R5cGU6ImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSJ9KSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXs0PT1hLnJlYWR5U3RhdGUmJjIwMDw9YS5zdGF0dXMmJjI5OT49YS5zdGF0dXMmJiI8bXhHcmFwaE1vZGVsIj09YS5yZXNwb25zZVRleHQuc3Vic3RyaW5nKDAsMTMpJiZhYShhLnJlc3BvbnNlVGV4dCxlKX0pLCIiKTpudWxsIT1nJiYiZnVuY3Rpb24iPT09dHlwZW9mIGcuc3Vic3RyaW5nJiZ0aGlzLmlzTHVjaWRDaGFydERhdGEoZyk/dGhpcy5jb252ZXJ0THVjaWRDaGFydChnLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe2FhKGEpfSksbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGVFcnJvcihhKX0pKTooZz1sKGcpLGFhKGcsZSkpfX0pKTt2YXIgbT13aW5kb3cub3BlbmVyfHx3aW5kb3cucGFyZW50LAprPSJqc29uIj09dXJsUGFyYW1zLnByb3RvP0pTT04uc3RyaW5naWZ5KHtldmVudDoiaW5pdCJ9KTp1cmxQYXJhbXMucmVhZHl8fCJyZWFkeSI7bS5wb3N0TWVzc2FnZShrLCIqIik7aWYoImpzb24iPT11cmxQYXJhbXMucHJvdG8pe3ZhciBxPXRoaXMuZWRpdG9yLmdyYXBoLm9wZW5MaW5rO3RoaXMuZWRpdG9yLmdyYXBoLm9wZW5MaW5rPWZ1bmN0aW9uKGEsYixjKXtxLmFwcGx5KHRoaXMsYXJndW1lbnRzKTttLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtldmVudDoib3BlbkxpbmsiLGhyZWY6YSx0YXJnZXQ6YixhbGxvd09wZW5lcjpjfSksIioiKX19fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkRW1iZWRCdXR0b25zPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5tZW51YmFyKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayI7YS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Euc3R5bGUucGFkZGluZ1RvcD0KImF0bGFzIj09dWlUaGVtZT8iMnB4IjoiMHB4IjthLnN0eWxlLnBhZGRpbmdMZWZ0PSI4cHgiO2Euc3R5bGUucGFkZGluZ0JvdHRvbT0iMnB4Ijt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTtjLmNsYXNzTmFtZT0iZ2VCaWdCdXR0b24iO3ZhciBkPWM7IjEiPT11cmxQYXJhbXMubm9TYXZlQnRuPyIwIiE9dXJsUGFyYW1zLnNhdmVBbmRFeGl0JiYobXhVdGlscy53cml0ZShjLG14UmVzb3VyY2VzLmdldCgic2F2ZUFuZEV4aXQiKSksYy5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoInNhdmVBbmRFeGl0IikpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgic2F2ZUFuZEV4aXQiKS5mdW5jdCgpfSkpLGEuYXBwZW5kQ2hpbGQoYykpOihteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlIikpLGMuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlIikrCiIgKCIrRWRpdG9yLmN0cmxLZXkrIitTKSIpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgic2F2ZSIpLmZ1bmN0KCl9KSksYS5hcHBlbmRDaGlsZChjKSwiMSI9PXVybFBhcmFtcy5zYXZlQW5kRXhpdCYmKGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpLG14VXRpbHMud3JpdGUoYyxteFJlc291cmNlcy5nZXQoInNhdmVBbmRFeGl0IikpLGMuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQW5kRXhpdCIpKSxjLmNsYXNzTmFtZT0iZ2VCaWdCdXR0b24gZ2VCaWdTdGFuZGFyZEJ1dHRvbiIsYy5zdHlsZS5tYXJnaW5MZWZ0PSI2cHgiLG14RXZlbnQuYWRkTGlzdGVuZXIoYywiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgic2F2ZUFuZEV4aXQiKS5mdW5jdCgpfSkpLGEuYXBwZW5kQ2hpbGQoYyksZD1jKSk7IjEiIT0KdXJsUGFyYW1zLm5vRXhpdEJ0biYmKGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpLG14VXRpbHMud3JpdGUoYyxteFJlc291cmNlcy5nZXQoImV4aXQiKSksYy5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImV4aXQiKSksYy5jbGFzc05hbWU9ImdlQmlnQnV0dG9uIGdlQmlnU3RhbmRhcmRCdXR0b24iLGMuc3R5bGUubWFyZ2luTGVmdD0iNnB4IixteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoImV4aXQiKS5mdW5jdCgpfSkpLGEuYXBwZW5kQ2hpbGQoYyksZD1jKTtkLnN0eWxlLm1hcmdpblJpZ2h0PSIyMHB4Ijt0aGlzLnRvb2xiYXIuY29udGFpbmVyLmFwcGVuZENoaWxkKGEpO3RoaXMudG9vbGJhci5zdGF0aWNFbGVtZW50cy5wdXNoKGEpO2Euc3R5bGUucmlnaHQ9ImF0bGFzIiE9dWlUaGVtZT8iNTJweCI6IjQycHgifX07RWRpdG9yVWkucHJvdG90eXBlLnNob3dJbXBvcnRDc3ZEaWFsb2c9CmZ1bmN0aW9uKCl7bnVsbD09dGhpcy5pbXBvcnRDc3ZEaWFsb2cmJih0aGlzLmltcG9ydENzdkRpYWxvZz1uZXcgVGV4dGFyZWFEaWFsb2codGhpcyxteFJlc291cmNlcy5nZXQoImNzdiIpKyI6IixFZGl0b3IuZGVmYXVsdENzdlZhbHVlLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RoaXMuaW1wb3J0Q3N2KGEpfSksbnVsbCxudWxsLDYyMCw0MzAsbnVsbCwhMCwhMCxteFJlc291cmNlcy5nZXQoImltcG9ydCIpLHRoaXMuaXNPZmZsaW5lKCk/bnVsbDoiaHR0cHM6Ly9kcmF3aW8tYXBwLmNvbS9pbXBvcnQtZnJvbS1jc3YtdG8tZHJhd2lvLyIpKTt0aGlzLnNob3dEaWFsb2codGhpcy5pbXBvcnRDc3ZEaWFsb2cuY29udGFpbmVyLDY0MCw1MjAsITAsITAsbnVsbCxudWxsLG51bGwsbnVsbCwhMCk7dGhpcy5pbXBvcnRDc3ZEaWFsb2cuaW5pdCgpfTtFZGl0b3JVaS5wcm90b3R5cGUuZXhlY3V0ZUxheW91dExpc3Q9ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGI9dGhpcy5lZGl0b3IuZ3JhcGgsCmQ9Yi5nZXRTZWxlY3Rpb25DZWxscygpLGU9MDtlPGEubGVuZ3RoO2UrKyl7dmFyIGY9bmV3IHdpbmRvd1thW2VdLmxheW91dF0oYik7aWYobnVsbCE9YVtlXS5jb25maWcpZm9yKHZhciBrIGluIGFbZV0uY29uZmlnKWZba109YVtlXS5jb25maWdba107dGhpcy5leGVjdXRlTGF5b3V0KGZ1bmN0aW9uKCl7Zi5leGVjdXRlKGIuZ2V0RGVmYXVsdFBhcmVudCgpLDA9PWQubGVuZ3RoP251bGw6ZCl9LGU9PWEubGVuZ3RoLTEsYyl9fTtFZGl0b3JVaS5wcm90b3R5cGUuaW1wb3J0Q3N2PWZ1bmN0aW9uKGEsYyl7dHJ5e3ZhciBiPWEuc3BsaXQoIlxuIiksZD1bXSxlPVtdLGY9e307aWYoMDxiLmxlbmd0aCl7dmFyIGs9e30sbT1udWxsLHE9bnVsbCx4PW51bGwsQz1udWxsLEI9bnVsbCxEPW51bGwsej1udWxsLEU9bnVsbCxHPSIiLEY9ImF1dG8iLEg9ImF1dG8iLEo9bnVsbCx1PW51bGwsSz00MCxBPTQwLE09MTAwLFE9MCxJPXRoaXMuZWRpdG9yLmdyYXBoO0kuZ2V0R3JhcGhCb3VuZHMoKTsKZm9yKHZhciBSPWZ1bmN0aW9uKCl7bnVsbCE9Yz9jKG5hKTooSS5zZXRTZWxlY3Rpb25DZWxscyhuYSksSS5zY3JvbGxDZWxsVG9WaXNpYmxlKEkuZ2V0U2VsZWN0aW9uQ2VsbCgpKSl9LFo9SS5nZXRGcmVlSW5zZXJ0UG9pbnQoKSxXPVoueCxpYT1aLnksWj1pYSxiYT1udWxsLFU9ImF1dG8iLEU9bnVsbCxjYT1bXSxkYT1udWxsLGFhPW51bGwsVD0wO1Q8Yi5sZW5ndGgmJiIjIj09YltUXS5jaGFyQXQoMCk7KXthPWJbVF07Zm9yKFQrKztUPGIubGVuZ3RoJiYiXFwiPT1hLmNoYXJBdChhLmxlbmd0aC0xKSYmIiMiPT1iW1RdLmNoYXJBdCgwKTspYT1hLnN1YnN0cmluZygwLGEubGVuZ3RoLTEpK214VXRpbHMudHJpbShiW1RdLnN1YnN0cmluZygxKSksVCsrO2lmKCIjIiE9YS5jaGFyQXQoMSkpe3ZhciBZPWEuaW5kZXhPZigiOiIpO2lmKDA8WSl7dmFyIFA9bXhVdGlscy50cmltKGEuc3Vic3RyaW5nKDEsWSkpLEw9bXhVdGlscy50cmltKGEuc3Vic3RyaW5nKFkrMSkpOyJsYWJlbCI9PQpQP2JhPUkuc2FuaXRpemVIdG1sKEwpOiJsYWJlbG5hbWUiPT1QJiYwPEwubGVuZ3RoJiYiLSIhPUw/Qz1MOiJsYWJlbHMiPT1QJiYwPEwubGVuZ3RoJiYiLSIhPUw/Qj1KU09OLnBhcnNlKEwpOiJzdHlsZSI9PVA/bT1MOiJwYXJlbnRzdHlsZSI9PVA/RD1MOiJzdHlsZW5hbWUiPT1QJiYwPEwubGVuZ3RoJiYiLSIhPUw/eD1MOiJzdHlsZXMiPT1QJiYwPEwubGVuZ3RoJiYiLSIhPUw/cT1KU09OLnBhcnNlKEwpOiJpZGVudGl0eSI9PVAmJjA8TC5sZW5ndGgmJiItIiE9TD96PUw6InBhcmVudCI9PVAmJjA8TC5sZW5ndGgmJiItIiE9TD9FPUw6Im5hbWVzcGFjZSI9PVAmJjA8TC5sZW5ndGgmJiItIiE9TD9HPUw6IndpZHRoIj09UD9GPUw6ImhlaWdodCI9PVA/SD1MOiJsZWZ0Ij09UCYmMDxMLmxlbmd0aD9KPUw6InRvcCI9PVAmJjA8TC5sZW5ndGg/dT1MOiJpZ25vcmUiPT1QP2FhPUwuc3BsaXQoIiwiKToiY29ubmVjdCI9PVA/Y2EucHVzaChKU09OLnBhcnNlKEwpKToibGluayI9PVA/CmRhPUw6InBhZGRpbmciPT1QP1E9cGFyc2VGbG9hdChMKToiZWRnZXNwYWNpbmciPT1QP0s9cGFyc2VGbG9hdChMKToibm9kZXNwYWNpbmciPT1QP0E9cGFyc2VGbG9hdChMKToibGV2ZWxzcGFjaW5nIj09UD9NPXBhcnNlRmxvYXQoTCk6ImxheW91dCI9PVAmJihVPUwpfX19aWYobnVsbD09YltUXSl0aHJvdyBFcnJvcihteFJlc291cmNlcy5nZXQoImludmFsaWRPck1pc3NpbmdGaWxlIikpO2Zvcih2YXIgZWE9dGhpcy5lZGl0b3IuY3N2VG9BcnJheShiW1RdKSxQPVk9bnVsbCxMPVtdLE89MDtPPGVhLmxlbmd0aDtPKyspej09ZWFbT10mJihZPU8pLEU9PWVhW09dJiYoUD1PKSxMLnB1c2gobXhVdGlscy50cmltKGVhW09dKS5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCJfIikucmVwbGFjZSgvXlxkKy8sIiIpLnJlcGxhY2UoL18rJC8sIiIpKTtudWxsPT1iYSYmKGJhPSIlIitMWzBdKyIlIik7aWYobnVsbCE9Y2EpZm9yKHZhciBYPTA7WDxjYS5sZW5ndGg7WCsrKW51bGw9PWtbY2FbWF0udG9dJiYKKGtbY2FbWF0udG9dPXt9KTt6PVtdO2ZvcihPPVQrMTtPPGIubGVuZ3RoO08rKyl7dmFyIGdhPXRoaXMuZWRpdG9yLmNzdlRvQXJyYXkoYltPXSk7aWYobnVsbD09Z2Epe3ZhciB4YT00MDxiW09dLmxlbmd0aD9iW09dLnN1YnN0cmluZygwLDQwKSsiLi4uIjpiW09dO3Rocm93IEVycm9yKHhhKyIgKCIrTysiKTpcbiIrbXhSZXNvdXJjZXMuZ2V0KCJjb250YWluc1ZhbGlkYXRpb25FcnJvcnMiKSk7fTA8Z2EubGVuZ3RoJiZ6LnB1c2goZ2EpfUkubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKE89MDtPPHoubGVuZ3RoO08rKyl7dmFyIGdhPXpbT10sTj1udWxsLGhhPW51bGwhPVk/RytnYVtZXTpudWxsO251bGwhPWhhJiYoTj1JLm1vZGVsLmdldENlbGwoaGEpKTt2YXIgYj1udWxsIT1OLFM9bmV3IG14Q2VsbChiYSxuZXcgbXhHZW9tZXRyeShXLFosMCwwKSxtfHwid2hpdGVTcGFjZT13cmFwO2h0bWw9MTsiKTtTLnZlcnRleD0hMDtTLmlkPWhhO2Zvcih2YXIgZmE9MDtmYTxnYS5sZW5ndGg7ZmErKylJLnNldEF0dHJpYnV0ZUZvckNlbGwoUywKTFtmYV0sZ2FbZmFdKTtpZihudWxsIT1DJiZudWxsIT1CKXt2YXIgcGE9QltTLmdldEF0dHJpYnV0ZShDKV07bnVsbCE9cGEmJkkubGFiZWxDaGFuZ2VkKFMscGEpfWlmKG51bGwhPXgmJm51bGwhPXEpe3ZhciByYT1xW1MuZ2V0QXR0cmlidXRlKHgpXTtudWxsIT1yYSYmKFMuc3R5bGU9cmEpfUkuc2V0QXR0cmlidXRlRm9yQ2VsbChTLCJwbGFjZWhvbGRlcnMiLCIxIik7Uy5zdHlsZT1JLnJlcGxhY2VQbGFjZWhvbGRlcnMoUyxTLnN0eWxlKTtiJiYoSS5tb2RlbC5zZXRHZW9tZXRyeShOLFMuZ2VvbWV0cnkpLEkubW9kZWwuc2V0U3R5bGUoTixTLnN0eWxlKSwwPm14VXRpbHMuaW5kZXhPZihlLE4pJiZlLnB1c2goTikpO049UztpZighYilmb3IoWD0wO1g8Y2EubGVuZ3RoO1grKylrW2NhW1hdLnRvXVtOLmdldEF0dHJpYnV0ZShjYVtYXS50byldPU47bnVsbCE9ZGEmJiJsaW5rIiE9ZGEmJihJLnNldExpbmtGb3JDZWxsKE4sTi5nZXRBdHRyaWJ1dGUoZGEpKSxJLnNldEF0dHJpYnV0ZUZvckNlbGwoTiwKZGEsbnVsbCkpO0kuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJjZWxsc0luc2VydGVkIiwiY2VsbHMiLFtOXSkpO3ZhciBsYT10aGlzLmVkaXRvci5ncmFwaC5nZXRQcmVmZXJyZWRTaXplRm9yQ2VsbChOKTtOLnZlcnRleCYmKG51bGwhPUomJm51bGwhPU4uZ2V0QXR0cmlidXRlKEopJiYoTi5nZW9tZXRyeS54PVcrcGFyc2VGbG9hdChOLmdldEF0dHJpYnV0ZShKKSkpLG51bGwhPXUmJm51bGwhPU4uZ2V0QXR0cmlidXRlKHUpJiYoTi5nZW9tZXRyeS55PWlhK3BhcnNlRmxvYXQoTi5nZXRBdHRyaWJ1dGUodSkpKSwiQCI9PUYuY2hhckF0KDApJiZudWxsIT1OLmdldEF0dHJpYnV0ZShGLnN1YnN0cmluZygxKSk/Ti5nZW9tZXRyeS53aWR0aD1wYXJzZUZsb2F0KE4uZ2V0QXR0cmlidXRlKEYuc3Vic3RyaW5nKDEpKSk6Ti5nZW9tZXRyeS53aWR0aD0iYXV0byI9PUY/bGEud2lkdGgrUTpwYXJzZUZsb2F0KEYpLCJAIj09SC5jaGFyQXQoMCkmJm51bGwhPU4uZ2V0QXR0cmlidXRlKEguc3Vic3RyaW5nKDEpKT8KTi5nZW9tZXRyeS5oZWlnaHQ9cGFyc2VGbG9hdChOLmdldEF0dHJpYnV0ZShILnN1YnN0cmluZygxKSkpOk4uZ2VvbWV0cnkuaGVpZ2h0PSJhdXRvIj09SD9sYS5oZWlnaHQrUTpwYXJzZUZsb2F0KEgpLForPU4uZ2VvbWV0cnkuaGVpZ2h0K0EpO2I/KG51bGw9PWZbaGFdJiYoZltoYV09W10pLGZbaGFdLnB1c2goTikpOihFPW51bGwhPVA/SS5tb2RlbC5nZXRDZWxsKEcrZ2FbUF0pOm51bGwsZC5wdXNoKE4pLG51bGwhPUU/KEUuc3R5bGU9SS5yZXBsYWNlUGxhY2Vob2xkZXJzKEUsRCksSS5hZGRDZWxsKE4sRSkpOmUucHVzaChJLmFkZENlbGwoTikpKX1mb3IodmFyIHFhPWUuc2xpY2UoKSxuYT1lLnNsaWNlKCksWD0wO1g8Y2EubGVuZ3RoO1grKylmb3IodmFyIEFhPWNhW1hdLE89MDtPPGQubGVuZ3RoO08rKyl7dmFyIE49ZFtPXSx5YT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yi5nZXRBdHRyaWJ1dGUoYy5mcm9tKTtpZihudWxsIT1kJiYoSS5zZXRBdHRyaWJ1dGVGb3JDZWxsKGIsCmMuZnJvbSxudWxsKSwiIiE9ZCkpZm9yKHZhciBkPWQuc3BsaXQoIiwiKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWtbYy50b11bZFtlXV07aWYobnVsbCE9Zil7dmFyIGc9Yy5sYWJlbDtudWxsIT1jLmZyb21sYWJlbCYmKGc9KGIuZ2V0QXR0cmlidXRlKGMuZnJvbWxhYmVsKXx8IiIpKyhnfHwiIikpO251bGwhPWMudG9sYWJlbCYmKGc9KGd8fCIiKSsoZi5nZXRBdHRyaWJ1dGUoYy50b2xhYmVsKXx8IiIpKTt2YXIgbD0idGFyZ2V0Ij09Yy5wbGFjZWhvbGRlcnM9PSFjLmludmVydD9mOmEsbD1udWxsIT1jLnN0eWxlP0kucmVwbGFjZVBsYWNlaG9sZGVycyhsLGMuc3R5bGUpOkkuY3JlYXRlQ3VycmVudEVkZ2VTdHlsZSgpLGc9SS5pbnNlcnRFZGdlKG51bGwsbnVsbCxnfHwiIixjLmludmVydD9mOmEsYy5pbnZlcnQ/YTpmLGwpO2lmKG51bGwhPWMubGFiZWxzKWZvcihsPTA7bDxjLmxhYmVscy5sZW5ndGg7bCsrKXt2YXIgbT1jLmxhYmVsc1tsXSxuPW5ldyBteENlbGwobS5sYWJlbHx8CmwsbmV3IG14R2VvbWV0cnkobnVsbCE9bS54P20ueDowLG51bGwhPW0ueT9tLnk6MCwwLDApLCJyZXNpemFibGU9MDtodG1sPTE7Iik7bi52ZXJ0ZXg9ITA7bi5jb25uZWN0YWJsZT0hMTtuLmdlb21ldHJ5LnJlbGF0aXZlPSEwO2lmKG51bGwhPW0uZHh8fG51bGwhPW0uZHkpbi5nZW9tZXRyeS5vZmZzZXQ9bmV3IG14UG9pbnQobnVsbCE9bS5keD9tLmR4OjAsbnVsbCE9bS5keT9tLmR5OjApO2cuaW5zZXJ0KG4pfW5hLnB1c2goZyk7bXhVdGlscy5yZW1vdmUoYy5pbnZlcnQ/YTpmLHFhKX19fSk7eWEoTixOLEFhKTtpZihudWxsIT1mW04uaWRdKWZvcihmYT0wO2ZhPGZbTi5pZF0ubGVuZ3RoO2ZhKyspeWEoTixmW04uaWRdW2ZhXSxBYSl9aWYobnVsbCE9YWEpZm9yKE89MDtPPGQubGVuZ3RoO08rKylmb3IoTj1kW09dLGZhPTA7ZmE8YWEubGVuZ3RoO2ZhKyspSS5zZXRBdHRyaWJ1dGVGb3JDZWxsKE4sbXhVdGlscy50cmltKGFhW2ZhXSksbnVsbCk7aWYoMDxlLmxlbmd0aCl7dmFyIG9hPQpuZXcgbXhQYXJhbGxlbEVkZ2VMYXlvdXQoSSk7b2Euc3BhY2luZz1LO3ZhciBzYT1mdW5jdGlvbigpezA8b2Euc3BhY2luZyYmb2EuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSk7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDthKyspe3ZhciBiPUkuZ2V0Q2VsbEdlb21ldHJ5KGVbYV0pO2IueD1NYXRoLnJvdW5kKEkuc25hcChiLngpKTtiLnk9TWF0aC5yb3VuZChJLnNuYXAoYi55KSk7ImF1dG8iPT1GJiYoYi53aWR0aD1NYXRoLnJvdW5kKEkuc25hcChiLndpZHRoKSkpOyJhdXRvIj09SCYmKGIuaGVpZ2h0PU1hdGgucm91bmQoSS5zbmFwKGIuaGVpZ2h0KSkpfX07aWYoIlsiPT1VLmNoYXJBdCgwKSl7dmFyIHVhPVI7SS52aWV3LnZhbGlkYXRlKCk7dGhpcy5leGVjdXRlTGF5b3V0TGlzdChKU09OLnBhcnNlKFUpLGZ1bmN0aW9uKCl7c2EoKTt1YSgpfSk7Uj1udWxsfWVsc2UgaWYoImNpcmNsZSI9PVUpe3ZhciBqYT1uZXcgbXhDaXJjbGVMYXlvdXQoSSk7amEucmVzZXRFZGdlcz0KITE7dmFyIERhPWphLmlzVmVydGV4SWdub3JlZDtqYS5pc1ZlcnRleElnbm9yZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIERhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MD5teFV0aWxzLmluZGV4T2YoZSxhKX07dGhpcy5leGVjdXRlTGF5b3V0KGZ1bmN0aW9uKCl7amEuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSk7c2EoKX0sITAsUik7Uj1udWxsfWVsc2UgaWYoImhvcml6b250YWx0cmVlIj09VXx8InZlcnRpY2FsdHJlZSI9PVV8fCJhdXRvIj09VSYmbmEubGVuZ3RoPT0yKmUubGVuZ3RoLTEmJjE9PXFhLmxlbmd0aCl7SS52aWV3LnZhbGlkYXRlKCk7dmFyIHZhPW5ldyBteENvbXBhY3RUcmVlTGF5b3V0KEksImhvcml6b250YWx0cmVlIj09VSk7dmEubGV2ZWxEaXN0YW5jZT1BO3ZhLmVkZ2VSb3V0aW5nPSExO3ZhLnJlc2V0RWRnZXM9ITE7dGhpcy5leGVjdXRlTGF5b3V0KGZ1bmN0aW9uKCl7dmEuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSwwPHFhLmxlbmd0aD9xYVswXToKbnVsbCl9LCEwLFIpO1I9bnVsbH1lbHNlIGlmKCJob3Jpem9udGFsZmxvdyI9PVV8fCJ2ZXJ0aWNhbGZsb3ciPT1VfHwiYXV0byI9PVUmJjE9PXFhLmxlbmd0aCl7SS52aWV3LnZhbGlkYXRlKCk7dmFyIG1hPW5ldyBteEhpZXJhcmNoaWNhbExheW91dChJLCJob3Jpem9udGFsZmxvdyI9PVU/bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q6bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIKTttYS5pbnRyYUNlbGxTcGFjaW5nPUE7bWEucGFyYWxsZWxFZGdlU3BhY2luZz1LO21hLmludGVyUmFua0NlbGxTcGFjaW5nPU07bWEuZGlzYWJsZUVkZ2VTdHlsZT0hMTt0aGlzLmV4ZWN1dGVMYXlvdXQoZnVuY3Rpb24oKXttYS5leGVjdXRlKEkuZ2V0RGVmYXVsdFBhcmVudCgpLG5hKTtJLm1vdmVDZWxscyhuYSxXLGlhKX0sITAsUik7Uj1udWxsfWVsc2UgaWYoIm9yZ2FuaWMiPT1VfHwiYXV0byI9PVUmJm5hLmxlbmd0aD5lLmxlbmd0aCl7SS52aWV3LnZhbGlkYXRlKCk7dmFyIHphPW5ldyBteEZhc3RPcmdhbmljTGF5b3V0KEkpOwp6YS5mb3JjZUNvbnN0YW50PTMqQTt6YS5yZXNldEVkZ2VzPSExO3ZhciBJYT16YS5pc1ZlcnRleElnbm9yZWQ7emEuaXNWZXJ0ZXhJZ25vcmVkPWZ1bmN0aW9uKGEpe3JldHVybiBJYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fDA+bXhVdGlscy5pbmRleE9mKGUsYSl9O29hPW5ldyBteFBhcmFsbGVsRWRnZUxheW91dChJKTtvYS5zcGFjaW5nPUs7dGhpcy5leGVjdXRlTGF5b3V0KGZ1bmN0aW9uKCl7emEuZXhlY3V0ZShJLmdldERlZmF1bHRQYXJlbnQoKSk7c2EoKX0sITAsUik7Uj1udWxsfX10aGlzLmhpZGVEaWFsb2coKX1maW5hbGx5e0kubW9kZWwuZW5kVXBkYXRlKCl9bnVsbCE9UiYmUigpfX1jYXRjaChKYSl7dGhpcy5oYW5kbGVFcnJvcihKYSl9fTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0U2VhcmNoPWZ1bmN0aW9uKGEpe3ZhciBiPSIiO2lmKCIxIiE9dXJsUGFyYW1zLm9mZmxpbmUmJiIxIiE9dXJsUGFyYW1zLmRlbW8mJm51bGwhPWEmJjA8d2luZG93LmxvY2F0aW9uLnNlYXJjaC5sZW5ndGgpe3ZhciBjPQoiPyIsZDtmb3IoZCBpbiB1cmxQYXJhbXMpMD5teFV0aWxzLmluZGV4T2YoYSxkKSYmbnVsbCE9dXJsUGFyYW1zW2RdJiYoYis9YytkKyI9Iit1cmxQYXJhbXNbZF0sYz0iJiIpfWVsc2UgYj13aW5kb3cubG9jYXRpb24uc2VhcmNoO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0VXJsPWZ1bmN0aW9uKGEpe2E9bnVsbCE9YT9hOndpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTt2YXIgYj0wPGEuaW5kZXhPZigiPyIpPzE6MDtpZigiMSI9PXVybFBhcmFtcy5vZmZsaW5lKWErPXdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7ZWxzZXt2YXIgYz0idG1wIGxpYnMgY2xpYnMgc3RhdGUgZmlsZUlkIGNvZGUgc2hhcmUgbm90aXRsZSBkYXRhIHVybCBlbWJlZCBjbGllbnQgY3JlYXRlIHRpdGxlIHNwbGFzaCIuc3BsaXQoIiAiKSxkO2ZvcihkIGluIHVybFBhcmFtcykwPm14VXRpbHMuaW5kZXhPZihjLGQpJiYoYT0wPT1iP2ErIj8iOmErIiYiLG51bGwhPXVybFBhcmFtc1tkXSYmKGErPWQrIj0iKwp1cmxQYXJhbXNbZF0sYisrKSl9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5zaG93TGlua0RpYWxvZz1mdW5jdGlvbihhLGMsZCl7YT1uZXcgTGlua0RpYWxvZyh0aGlzLGEsYyxkLCEwKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsNTYwLDEzMCwhMCwhMCk7YS5pbml0KCl9O3ZhciBrPUVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVPdXRsaW5lO0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVPdXRsaW5lPWZ1bmN0aW9uKGEpe3ZhciBiPWsuYXBwbHkodGhpcyxhcmd1bWVudHMpLGM9dGhpcy5lZGl0b3IuZ3JhcGgsZD1iLmdldFNvdXJjZUdyYXBoQm91bmRzO2IuZ2V0U291cmNlR3JhcGhCb3VuZHM9ZnVuY3Rpb24oKXtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYy5jb250YWluZXIpJiZjLnBhZ2VWaXNpYmxlJiZudWxsIT10aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplKXt2YXIgYT10aGlzLnNvdXJjZS5nZXRQYWdlUGFkZGluZygpLGI9dGhpcy5zb3VyY2Uudmlldy5zY2FsZTsKcmV0dXJuIG5ldyBteFJlY3RhbmdsZSgwLDAsTWF0aC5jZWlsKHRoaXMuc291cmNlLm1pbmltdW1HcmFwaFNpemUud2lkdGgtMiphLngvYiksTWF0aC5jZWlsKHRoaXMuc291cmNlLm1pbmltdW1HcmFwaFNpemUuaGVpZ2h0LTIqYS55L2IpKX1yZXR1cm4gZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBmPWIuZ2V0U291cmNlQ29udGFpbmVyU2l6ZTtiLmdldFNvdXJjZUNvbnRhaW5lclNpemU9ZnVuY3Rpb24oKXtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYy5jb250YWluZXIpJiZudWxsIT10aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplKXt2YXIgYT10aGlzLnNvdXJjZS5nZXRQYWdlUGFkZGluZygpLGI9dGhpcy5zb3VyY2Uudmlldy5zY2FsZTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKDAsMCxNYXRoLmNlaWwodGhpcy5zb3VyY2UubWluaW11bUdyYXBoU2l6ZS53aWR0aCpiLTIqYS54KSxNYXRoLmNlaWwodGhpcy5zb3VyY2UubWluaW11bUdyYXBoU2l6ZS5oZWlnaHQqYi0yKgphLnkpKX1yZXR1cm4gZi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2IuZ2V0T3V0bGluZU9mZnNldD1mdW5jdGlvbihhKXtpZihteFV0aWxzLmhhc1Njcm9sbGJhcnMoYy5jb250YWluZXIpJiZudWxsIT10aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplKXt2YXIgZD10aGlzLnNvdXJjZS5nZXRQYWdlUGFkZGluZygpO3JldHVybiBuZXcgbXhQb2ludChNYXRoLnJvdW5kKE1hdGgubWF4KDAsKGIub3V0bGluZS5jb250YWluZXIuY2xpZW50V2lkdGgvYS0odGhpcy5zb3VyY2UubWluaW11bUdyYXBoU2l6ZS53aWR0aC0yKmQueCkpLzIpLWQueCksTWF0aC5yb3VuZChNYXRoLm1heCgwLChiLm91dGxpbmUuY29udGFpbmVyLmNsaWVudEhlaWdodC9hLSh0aGlzLnNvdXJjZS5taW5pbXVtR3JhcGhTaXplLmhlaWdodC0yKmQueSkpLzIpLWQueS01L2EpKX1yZXR1cm4gbmV3IG14UG9pbnQoOC9hLDgvYSl9O3ZhciBtPWIuaW5pdDtiLmluaXQ9ZnVuY3Rpb24oKXttLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsKYi5vdXRsaW5lLnZpZXcuZ2V0QmFja2dyb3VuZFBhZ2VCb3VuZHM9ZnVuY3Rpb24oKXt2YXIgYT1jLmdldFBhZ2VMYXlvdXQoKSxiPWMuZ2V0UGFnZVNpemUoKTtyZXR1cm4gbmV3IG14UmVjdGFuZ2xlKHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLngrYS54KmIud2lkdGgpLHRoaXMuc2NhbGUqKHRoaXMudHJhbnNsYXRlLnkrYS55KmIuaGVpZ2h0KSx0aGlzLnNjYWxlKmEud2lkdGgqYi53aWR0aCx0aGlzLnNjYWxlKmEuaGVpZ2h0KmIuaGVpZ2h0KX07Yi5vdXRsaW5lLnZpZXcudmFsaWRhdGVCYWNrZ3JvdW5kUGFnZSgpfTt0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIixmdW5jdGlvbihhLGMpe3ZhciBkPWMuZ2V0UHJvcGVydHkoImNoYW5nZSIpLGU9Yi5zb3VyY2UsZj1iLm91dGxpbmU7Zi5wYWdlU2NhbGU9ZS5wYWdlU2NhbGU7Zi5wYWdlRm9ybWF0PWUucGFnZUZvcm1hdDtmLmJhY2tncm91bmQ9ZS5iYWNrZ3JvdW5kO2YucGFnZVZpc2libGU9ZS5wYWdlVmlzaWJsZTsKZi5iYWNrZ3JvdW5kPWUuYmFja2dyb3VuZDt2YXIgZz1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShlLmNvbnRhaW5lcik7Zi5jb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yPWcuYmFja2dyb3VuZENvbG9yO251bGwhPWUudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlJiZudWxsIT1mLnZpZXcuYmFja2dyb3VuZFBhZ2VTaGFwZSYmKGYudmlldy5iYWNrZ3JvdW5kUGFnZVNoYXBlLmZpbGw9ZS52aWV3LmJhY2tncm91bmRQYWdlU2hhcGUuZmlsbCk7Yi5vdXRsaW5lLnZpZXcuY2xlYXIoZC5wcmV2aW91c1BhZ2Uucm9vdCwhMCk7Yi5vdXRsaW5lLnZpZXcudmFsaWRhdGUoKX0pO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0U2VydmljZUNvdW50PWZ1bmN0aW9uKGEsYyl7dmFyIGI9MTtudWxsPT10aGlzLmRyaXZlJiYiZnVuY3Rpb24iIT09dHlwZW9mIHdpbmRvdy5Ecml2ZUNsaWVudHx8YisrO2N8fG51bGw9PXRoaXMuZHJvcGJveCYmImZ1bmN0aW9uIiE9PXR5cGVvZiB3aW5kb3cuRHJvcGJveENsaWVudHx8CmIrKztudWxsPT10aGlzLm9uZURyaXZlJiYiZnVuY3Rpb24iIT09dHlwZW9mIHdpbmRvdy5PbmVEcml2ZUNsaWVudHx8YisrO2N8fG51bGw9PXRoaXMuZ2l0SHVifHxiKys7Y3x8bnVsbD09dGhpcy5naXRMYWJ8fGIrKztjJiZhJiZpc0xvY2FsU3RvcmFnZSYmIjEiPT11cmxQYXJhbXMuYnJvd3NlciYmYisrO3JldHVybiBifTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlVWk9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZUJ1dHRvbkNvbnRhaW5lcigpO3RoaXMudXBkYXRlQWN0aW9uU3RhdGVzKCk7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpLGM9bnVsbCE9YXx8IjEiPT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpO3RoaXMubWVudXMuZ2V0KCJ2aWV3UGFuZWxzIikuc2V0RW5hYmxlZChjKTt0aGlzLm1lbnVzLmdldCgidmlld1pvb20iKS5zZXRFbmFibGVkKGMpO3ZhciBkPSgiMSIhPXVybFBhcmFtcy5lbWJlZHx8IXRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpKSYmCihudWxsPT1hfHxhLmlzUmVzdHJpY3RlZCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJtYWtlQ29weSIpLnNldEVuYWJsZWQoIWQpO3RoaXMuYWN0aW9ucy5nZXQoInByaW50Iikuc2V0RW5hYmxlZCghZCk7dGhpcy5tZW51cy5nZXQoImV4cG9ydEFzIikuc2V0RW5hYmxlZCghZCk7dGhpcy5tZW51cy5nZXQoImVtYmVkIikuc2V0RW5hYmxlZCghZCk7ZD0iMSIhPXVybFBhcmFtcy5lbWJlZHx8dGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCk7dGhpcy5tZW51cy5nZXQoImV4dHJhcyIpLnNldEVuYWJsZWQoZCk7RWRpdG9yLmVuYWJsZUN1c3RvbUxpYnJhcmllcyYmKHRoaXMubWVudXMuZ2V0KCJvcGVuTGlicmFyeUZyb20iKS5zZXRFbmFibGVkKGQpLHRoaXMubWVudXMuZ2V0KCJuZXdMaWJyYXJ5Iikuc2V0RW5hYmxlZChkKSk7YT0iMSI9PXVybFBhcmFtcy5lbWJlZCYmdGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCl8fG51bGwhPWEmJmEuaXNFZGl0YWJsZSgpO3RoaXMuYWN0aW9ucy5nZXQoImltYWdlIikuc2V0RW5hYmxlZChjKTsKdGhpcy5hY3Rpb25zLmdldCgiem9vbUluIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJ6b29tT3V0Iikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJyZXNldFZpZXciKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoInVuZG8iKS5zZXRFbmFibGVkKHRoaXMuY2FuVW5kbygpJiZhKTt0aGlzLmFjdGlvbnMuZ2V0KCJyZWRvIikuc2V0RW5hYmxlZCh0aGlzLmNhblJlZG8oKSYmYSk7dGhpcy5tZW51cy5nZXQoImVkaXQiKS5zZXRFbmFibGVkKGMpO3RoaXMubWVudXMuZ2V0KCJ2aWV3Iikuc2V0RW5hYmxlZChjKTt0aGlzLm1lbnVzLmdldCgiaW1wb3J0RnJvbSIpLnNldEVuYWJsZWQoYSk7dGhpcy5tZW51cy5nZXQoImFycmFuZ2UiKS5zZXRFbmFibGVkKGEpO251bGwhPXRoaXMudG9vbGJhciYmKG51bGwhPXRoaXMudG9vbGJhci5lZGdlU2hhcGVNZW51JiZ0aGlzLnRvb2xiYXIuZWRnZVNoYXBlTWVudS5zZXRFbmFibGVkKGEpLG51bGwhPXRoaXMudG9vbGJhci5lZGdlU3R5bGVNZW51JiYKdGhpcy50b29sYmFyLmVkZ2VTdHlsZU1lbnUuc2V0RW5hYmxlZChhKSk7dGhpcy51cGRhdGVVc2VyRWxlbWVudCgpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQnV0dG9uQ29udGFpbmVyPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlVXNlckVsZW1lbnQ9ZnVuY3Rpb24oKXt9O0VkaXRvclVpLnByb3RvdHlwZS5zY2hlZHVsZVNhbml0eUNoZWNrPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuc3RvcFNhbml0eUNoZWNrPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuaXNEaWFncmFtQWN0aXZlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hJiZhLmlzRWRpdGFibGUoKXx8IjEiPT11cmxQYXJhbXMuZW1iZWQmJnRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpfTt2YXIgbT1FZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQWN0aW9uU3RhdGVzO0VkaXRvclVpLnByb3RvdHlwZS51cGRhdGVBY3Rpb25TdGF0ZXM9CmZ1bmN0aW9uKCl7bS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGgsYz10aGlzLmlzRGlhZ3JhbUFjdGl2ZSgpLGQ9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3RoaXMuYWN0aW9ucy5nZXQoInBhZ2VTZXR1cCIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgiYXV0b3NhdmUiKS5zZXRFbmFibGVkKG51bGwhPWQmJmQuaXNFZGl0YWJsZSgpJiZkLmlzQXV0b3NhdmVPcHRpb25hbCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJndWlkZXMiKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoImVkaXREYXRhIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJzaGFkb3dWaXNpYmxlIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJjb25uZWN0aW9uQXJyb3dzIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJjb25uZWN0aW9uUG9pbnRzIikuc2V0RW5hYmxlZChjKTt0aGlzLmFjdGlvbnMuZ2V0KCJjb3B5U3R5bGUiKS5zZXRFbmFibGVkKGMmJgohYS5pc1NlbGVjdGlvbkVtcHR5KCkpO3RoaXMuYWN0aW9ucy5nZXQoInBhc3RlU3R5bGUiKS5zZXRFbmFibGVkKGMmJiFhLmlzU2VsZWN0aW9uRW1wdHkoKSk7dGhpcy5hY3Rpb25zLmdldCgiZWRpdEdlb21ldHJ5Iikuc2V0RW5hYmxlZChhLmdldE1vZGVsKCkuaXNWZXJ0ZXgoYS5nZXRTZWxlY3Rpb25DZWxsKCkpKTt0aGlzLmFjdGlvbnMuZ2V0KCJjcmVhdGVTaGFwZSIpLnNldEVuYWJsZWQoYyk7dGhpcy5hY3Rpb25zLmdldCgiY3JlYXRlUmV2aXNpb24iKS5zZXRFbmFibGVkKGMpO3RoaXMuYWN0aW9ucy5nZXQoIm1vdmVUb0ZvbGRlciIpLnNldEVuYWJsZWQobnVsbCE9ZCk7dGhpcy5hY3Rpb25zLmdldCgibWFrZUNvcHkiKS5zZXRFbmFibGVkKG51bGwhPWQmJiFkLmlzUmVzdHJpY3RlZCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJlZGl0RGlhZ3JhbSIpLnNldEVuYWJsZWQoYyYmKG51bGw9PWR8fCFkLmlzUmVzdHJpY3RlZCgpKSk7dGhpcy5hY3Rpb25zLmdldCgicHVibGlzaExpbmsiKS5zZXRFbmFibGVkKG51bGwhPQpkJiYhZC5pc1Jlc3RyaWN0ZWQoKSk7dGhpcy5hY3Rpb25zLmdldCgidGFncyIpLnNldEVuYWJsZWQoImhpZGRlbiIhPXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5KTt0aGlzLmFjdGlvbnMuZ2V0KCJmaW5kIikuc2V0RW5hYmxlZCgiaGlkZGVuIiE9dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkpO3RoaXMuYWN0aW9ucy5nZXQoImxheWVycyIpLnNldEVuYWJsZWQoImhpZGRlbiIhPXRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5KTt0aGlzLmFjdGlvbnMuZ2V0KCJvdXRsaW5lIikuc2V0RW5hYmxlZCgiaGlkZGVuIiE9dGhpcy5kaWFncmFtQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkpO3RoaXMuYWN0aW9ucy5nZXQoInJlbmFtZSIpLnNldEVuYWJsZWQobnVsbCE9ZCYmZC5pc1JlbmFtYWJsZSgpfHwiMSI9PXVybFBhcmFtcy5lbWJlZCk7dGhpcy5hY3Rpb25zLmdldCgiY2xvc2UiKS5zZXRFbmFibGVkKG51bGwhPWQpOwp0aGlzLm1lbnVzLmdldCgicHVibGlzaCIpLnNldEVuYWJsZWQobnVsbCE9ZCYmIWQuaXNSZXN0cmljdGVkKCkpO2E9YS52aWV3LmdldFN0YXRlKGEuZ2V0U2VsZWN0aW9uQ2VsbCgpKTt0aGlzLmFjdGlvbnMuZ2V0KCJlZGl0U2hhcGUiKS5zZXRFbmFibGVkKGMmJm51bGwhPWEmJm51bGwhPWEuc2hhcGUmJm51bGwhPWEuc2hhcGUuc3RlbmNpbCl9O3ZhciBxPUVkaXRvclVpLnByb3RvdHlwZS5kZXN0cm95O0VkaXRvclVpLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5leHBvcnREaWFsb2cmJih0aGlzLmV4cG9ydERpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZXhwb3J0RGlhbG9nKSx0aGlzLmV4cG9ydERpYWxvZz1udWxsKTtxLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07bnVsbCE9d2luZG93LkV4cG9ydERpYWxvZyYmKEV4cG9ydERpYWxvZy5zaG93WG1sT3B0aW9uPSExLEV4cG9ydERpYWxvZy5zaG93R2lmT3B0aW9uPSExLEV4cG9ydERpYWxvZy5leHBvcnRGaWxlPQpmdW5jdGlvbihhLGMsZCxmLGssbSxxKXt2YXIgYj1hLmVkaXRvci5ncmFwaDtpZigieG1sIj09ZClhLmhpZGVEaWFsb2coKSxhLnNhdmVEYXRhKGMsInhtbCIsbXhVdGlscy5nZXRYbWwoYS5lZGl0b3IuZ2V0R3JhcGhYbWwoKSksInRleHQveG1sIik7ZWxzZSBpZigic3ZnIj09ZClhLmhpZGVEaWFsb2coKSxhLnNhdmVEYXRhKGMsInN2ZyIsbXhVdGlscy5nZXRYbWwoYi5nZXRTdmcoZixrLG0pKSwiaW1hZ2Uvc3ZnK3htbCIpO2Vsc2V7dmFyIGU9YS5nZXRGaWxlRGF0YSghMCxudWxsLG51bGwsbnVsbCxudWxsLCEwKSxnPWIuZ2V0R3JhcGhCb3VuZHMoKSxsPU1hdGguZmxvb3IoZy53aWR0aCprL2Iudmlldy5zY2FsZSksbj1NYXRoLmZsb29yKGcuaGVpZ2h0KmsvYi52aWV3LnNjYWxlKTtpZihlLmxlbmd0aDw9TUFYX1JFUVVFU1RfU0laRSYmbCpuPE1BWF9BUkVBKWlmKGEuaGlkZURpYWxvZygpLCJwbmciIT1kJiYianBnIiE9ZCYmImpwZWciIT1kfHwhYS5pc0V4cG9ydFRvQ2FudmFzKCkpe3ZhciBwPQp7Z2xvYmFsVmFyczpiLmdldEV4cG9ydFZhcmlhYmxlcygpfTthLnNhdmVSZXF1ZXN0KGMsZCxmdW5jdGlvbihhLGIpe3JldHVybiBuZXcgbXhYbWxSZXF1ZXN0KEVYUE9SVF9VUkwsImZvcm1hdD0iK2QrIiZiYXNlNjQ9IisoYnx8IjAiKSsobnVsbCE9YT8iJmZpbGVuYW1lPSIrZW5jb2RlVVJJQ29tcG9uZW50KGEpOiIiKSsiJmV4dHJhcz0iK2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShwKSkrKDA8cT8iJmRwaT0iK3E6IiIpKyImYmc9IisobnVsbCE9Zj9mOiJub25lIikrIiZ3PSIrbCsiJmg9IituKyImYm9yZGVyPSIrbSsiJnhtbD0iK2VuY29kZVVSSUNvbXBvbmVudChlKSl9KX1lbHNlInBuZyI9PWQ/YS5leHBvcnRJbWFnZShrLG51bGw9PWZ8fCJub25lIj09ZiwhMCwhMSwhMSxtLCEwLCExLG51bGwsbnVsbCxxKTphLmV4cG9ydEltYWdlKGssITEsITAsITEsITEsbSwhMCwhMSwianBlZyIpO2Vsc2UgbXhVdGlscy5hbGVydChteFJlc291cmNlcy5nZXQoImRyYXdpbmdUb29MYXJnZSIpKX19KTsKRWRpdG9yVWkucHJvdG90eXBlLmdldERpYWdyYW1UZXh0Q29udGVudD1mdW5jdGlvbigpe3RoaXMuZWRpdG9yLmdyYXBoLnNldEVuYWJsZWQoITEpO3ZhciBhPXRoaXMuZWRpdG9yLmdyYXBoLGM9IiI7aWYobnVsbCE9dGhpcy5wYWdlcylmb3IodmFyIGQ9MDtkPHRoaXMucGFnZXMubGVuZ3RoO2QrKyl7dmFyIGY9YTt0aGlzLmN1cnJlbnRQYWdlIT10aGlzLnBhZ2VzW2RdJiYoZj10aGlzLmNyZWF0ZVRlbXBvcmFyeUdyYXBoKGEuZ2V0U3R5bGVzaGVldCgpKSx0aGlzLnVwZGF0ZVBhZ2VSb290KHRoaXMucGFnZXNbZF0pLGYubW9kZWwuc2V0Um9vdCh0aGlzLnBhZ2VzW2RdLnJvb3QpKTtjKz10aGlzLnBhZ2VzW2RdLmdldE5hbWUoKSsiICIrZi5nZXRJbmRleGFibGVUZXh0KCkrIiAifWVsc2UgYz1hLmdldEluZGV4YWJsZVRleHQoKTt0aGlzLmVkaXRvci5ncmFwaC5zZXRFbmFibGVkKCEwKTtyZXR1cm4gY307RWRpdG9yVWkucHJvdG90eXBlLnNob3dSZW1vdGVseVN0b3JlZExpYnJhcnk9CmZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Yy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImgzIik7bXhVdGlscy53cml0ZShkLG14VXRpbHMuaHRtbEVudGl0aWVzKGEpKTtkLnN0eWxlLmNzc1RleHQ9IndpZHRoOjEwMCU7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luLXRvcDowcHg7bWFyZ2luLWJvdHRvbToxMnB4IjtjLmFwcGVuZENoaWxkKGQpO3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Yuc3R5bGUuY3NzVGV4dD0iYm9yZGVyOjFweCBzb2xpZCBsaWdodEdyYXk7b3ZlcmZsb3c6IGF1dG87aGVpZ2h0OjMwMHB4IjtmLmlubmVySFRNTD0nPGRpdiBzdHlsZT0idGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzo4cHg7Ij48aW1nIHNyYz0iL2ltYWdlcy9zcGluLmdpZiI+PC9kaXY+Jzt2YXIgaz17fTt0cnl7dmFyIG09bXhTZXR0aW5ncy5nZXRDdXN0b21MaWJyYXJpZXMoKTsKZm9yKGE9MDthPG0ubGVuZ3RoO2ErKyl7dmFyIHE9bVthXTtpZigiUiI9PXEuc3Vic3RyaW5nKDAsMSkpe3ZhciB5PUpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHEuc3Vic3RyaW5nKDEpKSk7a1t5WzBdXT17aWQ6eVswXSx0aXRsZTp5WzFdLGRvd25sb2FkVXJsOnlbMl19fX19Y2F0Y2goeCl7fXRoaXMucmVtb3RlSW52b2tlKCJnZXRDdXN0b21MaWJyYXJpZXMiLG51bGwsbnVsbCxmdW5jdGlvbihhKXtmLmlubmVySFRNTD0iIjtpZigwPT1hLmxlbmd0aClmLmlubmVySFRNTD0nPGRpdiBzdHlsZT0idGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZy10b3A6MjBweDtjb2xvcjpncmF5OyI+JytteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoIm5vTGlicmFyaWVzIikpKyI8L2Rpdj4iO2Vsc2UgZm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY107a1tkLmlkXSYmKGJbZC5pZF09ZCk7dmFyIGU9dGhpcy5hZGRDaGVja2JveChmLGQudGl0bGUsa1tkLmlkXSk7CihmdW5jdGlvbihhLGMpe214RXZlbnQuYWRkTGlzdGVuZXIoYywiY2hhbmdlIixmdW5jdGlvbigpe3RoaXMuY2hlY2tlZD9iW2EuaWRdPWE6ZGVsZXRlIGJbYS5pZF19KX0pKGQsZSl9fSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtmLmlubmVySFRNTD0iIjt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtiLnN0eWxlLnBhZGRpbmc9IjhweCI7Yi5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7bXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsiOiAiKTtteFV0aWxzLndyaXRlKGIsbnVsbCE9YSYmbnVsbCE9YS5tZXNzYWdlP2EubWVzc2FnZTpteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpKTtmLmFwcGVuZENoaWxkKGIpfSkpO2MuYXBwZW5kQ2hpbGQoZik7Yz1uZXcgQ3VzdG9tRGlhbG9nKHRoaXMsYyxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc3Bpbm5lci5zcGluKGRvY3VtZW50LmJvZHksbXhSZXNvdXJjZXMuZ2V0KCJsb2FkaW5nIikpOwp2YXIgYT0wLGM7Zm9yKGMgaW4gYiludWxsPT1rW2NdJiYoYSsrLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RoaXMucmVtb3RlSW52b2tlKCJnZXRGaWxlQ29udGVudCIsW2IuZG93bmxvYWRVcmxdLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7YS0tOzA9PWEmJnRoaXMuc3Bpbm5lci5zdG9wKCk7dHJ5e3RoaXMubG9hZExpYnJhcnkobmV3IFJlbW90ZUxpYnJhcnkodGhpcyxjLGIpKX1jYXRjaCh6KXt0aGlzLmhhbmRsZUVycm9yKHosbXhSZXNvdXJjZXMuZ2V0KCJlcnJvckxvYWRpbmdGaWxlIikpfX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7YS0tOzA9PWEmJnRoaXMuc3Bpbm5lci5zdG9wKCk7dGhpcy5oYW5kbGVFcnJvcihudWxsLG14UmVzb3VyY2VzLmdldCgiZXJyb3JMb2FkaW5nRmlsZSIpKX0pKX0pKGJbY10pKTtmb3IoYyBpbiBrKWJbY118fHRoaXMuY2xvc2VMaWJyYXJ5KG5ldyBSZW1vdGVMaWJyYXJ5KHRoaXMsbnVsbCxrW2NdKSk7CjA9PWEmJnRoaXMuc3Bpbm5lci5zdG9wKCl9KSxudWxsLG51bGwsImh0dHBzOi8vZGVzay5kcmF3LmlvL3N1cHBvcnQvc29sdXRpb25zL2FydGljbGVzLzE2MDAwMDkyNzYzIik7dGhpcy5zaG93RGlhbG9nKGMuY29udGFpbmVyLDM0MCwzNzUsITAsITAsbnVsbCxudWxsLG51bGwsbnVsbCwhMCl9O0VkaXRvclVpLnByb3RvdHlwZS5yZW1vdGVJbnZva2FibGVGbnM9e2dldERpYWdyYW1UZXh0Q29udGVudDp7aXNBc3luYzohMX0sZ2V0TG9jYWxTdG9yYWdlRmlsZTp7aXNBc3luYzohMSxhbGxvd2VkRG9tYWluczpbImFwcC5kaWFncmFtcy5uZXQiXX0sZ2V0TG9jYWxTdG9yYWdlRmlsZU5hbWVzOntpc0FzeW5jOiExLGFsbG93ZWREb21haW5zOlsiYXBwLmRpYWdyYW1zLm5ldCJdfSxzZXRNaWdyYXRlZEZsYWc6e2lzQXN5bmM6ITEsYWxsb3dlZERvbWFpbnM6WyJhcHAuZGlhZ3JhbXMubmV0Il19fTtFZGl0b3JVaS5wcm90b3R5cGUucmVtb3RlSW52b2tlQ2FsbGJhY2tzPVtdO0VkaXRvclVpLnByb3RvdHlwZS5yZW1vdGVJbnZva2VRdWV1ZT0KW107RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZVJlbW90ZUludm9rZVJlYWR5PWZ1bmN0aW9uKGEpe3RoaXMucmVtb3RlV2luPWE7Zm9yKHZhciBiPTA7Yjx0aGlzLnJlbW90ZUludm9rZVF1ZXVlLmxlbmd0aDtiKyspYS5wb3N0TWVzc2FnZSh0aGlzLnJlbW90ZUludm9rZVF1ZXVlW2JdLCIqIik7dGhpcy5yZW1vdGVJbnZva2VRdWV1ZT1bXX07RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZVJlbW90ZUludm9rZVJlc3BvbnNlPWZ1bmN0aW9uKGEpe3ZhciBiPWEubXNnTWFya2VycyxjPXRoaXMucmVtb3RlSW52b2tlQ2FsbGJhY2tzW2IuY2FsbGJhY2tJZF07aWYobnVsbD09Yyl0aHJvdyBFcnJvcigiTm8gY2FsbGJhY2sgZm9yICIrKG51bGwhPWI/Yi5jYWxsYmFja0lkOiJudWxsIikpO2EuZXJyb3I/Yy5lcnJvciYmYy5lcnJvcihhLmVycm9yLmVyclJlc3ApOmMuY2FsbGJhY2smJmMuY2FsbGJhY2suYXBwbHkodGhpcyxhLnJlc3ApO3RoaXMucmVtb3RlSW52b2tlQ2FsbGJhY2tzW2IuY2FsbGJhY2tJZF09Cm51bGx9O0VkaXRvclVpLnByb3RvdHlwZS5yZW1vdGVJbnZva2U9ZnVuY3Rpb24oYSxjLGQsZixrKXt2YXIgYj0hMCxlPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Yj0hMTtrKHtjb2RlOkFwcC5FUlJPUl9USU1FT1VULG1lc3NhZ2U6bXhSZXNvdXJjZXMuZ2V0KCJ0aW1lb3V0Iil9KX0pLHRoaXMudGltZW91dCksZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3dpbmRvdy5jbGVhclRpbWVvdXQoZSk7YiYmZi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTtkPWR8fHt9O2QuY2FsbGJhY2tJZD10aGlzLnJlbW90ZUludm9rZUNhbGxiYWNrcy5sZW5ndGg7dGhpcy5yZW1vdGVJbnZva2VDYWxsYmFja3MucHVzaCh7Y2FsbGJhY2s6ZyxlcnJvcjprfSk7YT1KU09OLnN0cmluZ2lmeSh7ZXZlbnQ6InJlbW90ZUludm9rZSIsZnVudGlvbk5hbWU6YSxmdW5jdGlvbkFyZ3M6Yyxtc2dNYXJrZXJzOmR9KTtudWxsIT10aGlzLnJlbW90ZVdpbj90aGlzLnJlbW90ZVdpbi5wb3N0TWVzc2FnZShhLAoiKiIpOnRoaXMucmVtb3RlSW52b2tlUXVldWUucHVzaChhKX07RWRpdG9yVWkucHJvdG90eXBlLmhhbmRsZVJlbW90ZUludm9rZT1mdW5jdGlvbihhLGMpe3ZhciBiPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9e2V2ZW50OiJyZW1vdGVJbnZva2VSZXNwb25zZSIsbXNnTWFya2VyczphLm1zZ01hcmtlcnN9O251bGwhPWM/ZC5lcnJvcj17ZXJyUmVzcDpjfTpudWxsIT1iJiYoZC5yZXNwPWIpO3RoaXMucmVtb3RlV2luLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KGQpLCIqIil9KTt0cnl7dmFyIGQ9YS5mdW50aW9uTmFtZSxlPXRoaXMucmVtb3RlSW52b2thYmxlRm5zW2RdO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PT10eXBlb2YgdGhpc1tkXSl7aWYoZS5hbGxvd2VkRG9tYWlucyl7Zm9yKHZhciBmPSExLGs9MDtrPGUuYWxsb3dlZERvbWFpbnMubGVuZ3RoO2srKylpZihjPT0iaHR0cHM6Ly8iK2UuYWxsb3dlZERvbWFpbnNba10pe2Y9ITA7YnJlYWt9aWYoIWYpe2IobnVsbCwKIkludmFsaWQgQ2FsbDogIitkKyIgaXMgbm90IGFsbG93ZWQuIik7cmV0dXJufX12YXIgbT1hLmZ1bmN0aW9uQXJncztBcnJheS5pc0FycmF5KG0pfHwobT1bXSk7aWYoZS5pc0FzeW5jKW0ucHVzaChmdW5jdGlvbigpe2IoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpfSksbS5wdXNoKGZ1bmN0aW9uKGEpe2IobnVsbCxhfHwiVW5rb3duIEVycm9yIil9KSx0aGlzW2RdLmFwcGx5KHRoaXMsbSk7ZWxzZXt2YXIgcT10aGlzW2RdLmFwcGx5KHRoaXMsbSk7YihbcV0pfX1lbHNlIGIobnVsbCwiSW52YWxpZCBDYWxsOiAiK2QrIiBpcyBub3QgZm91bmQuIil9Y2F0Y2goeCl7YihudWxsLCJJbnZhbGlkIENhbGw6IEFuIGVycm9yIG9jY3VyZWQsICIreC5tZXNzYWdlKX19O0VkaXRvclVpLnByb3RvdHlwZS5vcGVuRGF0YWJhc2U9ZnVuY3Rpb24oYSxjKXtpZihudWxsPT10aGlzLmRhdGFiYXNlKXt2YXIgYj13aW5kb3cuaW5kZXhlZERCfHx3aW5kb3cubW96SW5kZXhlZERCfHwKd2luZG93LndlYmtpdEluZGV4ZWREQjtpZihudWxsIT1iKXRyeXt2YXIgZD1iLm9wZW4oImRhdGFiYXNlIiwyKTtkLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihhKXt0cnl7dmFyIGI9ZC5yZXN1bHQ7MT5hLm9sZFZlcnNpb24mJmIuY3JlYXRlT2JqZWN0U3RvcmUoIm9iamVjdHMiLHtrZXlQYXRoOiJrZXkifSk7Mj5hLm9sZFZlcnNpb24mJihiLmNyZWF0ZU9iamVjdFN0b3JlKCJmaWxlcyIse2tleVBhdGg6InRpdGxlIn0pLGIuY3JlYXRlT2JqZWN0U3RvcmUoImZpbGVzSW5mbyIse2tleVBhdGg6InRpdGxlIn0pLEVkaXRvclVpLm1pZ3JhdGVTdG9yYWdlRmlsZXM9aXNMb2NhbFN0b3JhZ2UpfWNhdGNoKHYpe251bGwhPWMmJmModil9fTtkLm9uc3VjY2Vzcz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgYz1kLnJlc3VsdDt0aGlzLmRhdGFiYXNlPWM7RWRpdG9yVWkubWlncmF0ZVN0b3JhZ2VGaWxlcyYmKFN0b3JhZ2VGaWxlLm1pZ3JhdGUoYyksRWRpdG9yVWkubWlncmF0ZVN0b3JhZ2VGaWxlcz0KITEpOyJhcHAuZGlhZ3JhbXMubmV0IiE9bG9jYXRpb24uaG9zdHx8dGhpcy5kcmF3aW9NaWdyYXRpb25TdGFydGVkfHwodGhpcy5kcmF3aW9NaWdyYXRpb25TdGFydGVkPSEwLHRoaXMuZ2V0RGF0YWJhc2VJdGVtKCIuZHJhd2lvTWlncmF0ZWQzIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtpZighYXx8IjEiPT11cmxQYXJhbXMuZm9yY2VNaWdyYXRpb24pe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlmcmFtZSIpO2Iuc3R5bGUuZGlzcGxheT0ibm9uZSI7Yi5zZXRBdHRyaWJ1dGUoInNyYyIsImh0dHBzOi8vd3d3LmRyYXcuaW8/ZW1iZWQ9MSZwcm90bz1qc29uJmZvcmNlTWlncmF0aW9uPSIrdXJsUGFyYW1zLmZvcmNlTWlncmF0aW9uKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpO3ZhciBjPSEwLGQ9ITEsZSxmPTAsZz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Q9ITA7dGhpcy5zZXREYXRhYmFzZUl0ZW0oIi5kcmF3aW9NaWdyYXRlZDMiLCEwKTsKYi5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHthY3Rpb246InJlbW90ZUludm9rZSIsZnVudGlvbk5hbWU6InNldE1pZ3JhdGVkRmxhZyJ9KSwiKiIpfSksaz1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2YrKztsKCl9KSxsPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dHJ5e2lmKGY+PWUubGVuZ3RoKWcoKTtlbHNle3ZhciBhPWVbZl07U3RvcmFnZUZpbGUuZ2V0RmlsZUNvbnRlbnQodGhpcyxhLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGMpe251bGw9PWN8fCIuc2NyYXRjaHBhZCI9PWEmJmM9PXRoaXMuZW1wdHlMaWJyYXJ5WG1sP2IuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7YWN0aW9uOiJyZW1vdGVJbnZva2UiLGZ1bnRpb25OYW1lOiJnZXRMb2NhbFN0b3JhZ2VGaWxlIixmdW5jdGlvbkFyZ3M6W2FdfSksIioiKTprKCl9KSxrKX19Y2F0Y2goSCl7Y29uc29sZS5sb2coSCl9fSksbT1teFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7dHJ5e3RoaXMuc2V0RGF0YWJhc2VJdGVtKG51bGwsW3t0aXRsZTphLnRpdGxlLHNpemU6YS5kYXRhLmxlbmd0aCxsYXN0TW9kaWZpZWQ6RGF0ZS5ub3coKSx0eXBlOmEuaXNMaWI/IkwiOiJGIn0se3RpdGxlOmEudGl0bGUsZGF0YTphLmRhdGF9XSxrLGssWyJmaWxlc0luZm8iLCJmaWxlcyJdKX1jYXRjaChIKXtjb25zb2xlLmxvZyhIKX19KTthPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3RyeXtpZihhLnNvdXJjZT09Yi5jb250ZW50V2luZG93KXt2YXIgZj17fTt0cnl7Zj1KU09OLnBhcnNlKGEuZGF0YSl9Y2F0Y2goSil7fSJpbml0Ij09Zi5ldmVudD8oYi5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHthY3Rpb246InJlbW90ZUludm9rZVJlYWR5In0pLCIqIiksYi5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHthY3Rpb246InJlbW90ZUludm9rZSIsZnVudGlvbk5hbWU6ImdldExvY2FsU3RvcmFnZUZpbGVOYW1lcyJ9KSwKIioiKSk6InJlbW90ZUludm9rZVJlc3BvbnNlIiE9Zi5ldmVudHx8ZHx8KGM/bnVsbCE9Zi5yZXNwJiYwPGYucmVzcC5sZW5ndGgmJm51bGwhPWYucmVzcFswXT8oZT1mLnJlc3BbMF0sYz0hMSxsKCkpOmcoKTpudWxsIT1mLnJlc3AmJjA8Zi5yZXNwLmxlbmd0aCYmbnVsbCE9Zi5yZXNwWzBdP20oZi5yZXNwWzBdKTprKCkpfX1jYXRjaChKKXtjb25zb2xlLmxvZyhKKX19KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsYSl9fSkpKTthKGMpO2Mub252ZXJzaW9uY2hhbmdlPWZ1bmN0aW9uKCl7Yy5jbG9zZSgpfX0pO2Qub25lcnJvcj1jO2Qub25ibG9ja2VkPWZ1bmN0aW9uKCl7fX1jYXRjaChsKXtudWxsIT1jJiZjKGwpfWVsc2UgbnVsbCE9YyYmYygpfWVsc2UgYSh0aGlzLmRhdGFiYXNlKX07RWRpdG9yVWkucHJvdG90eXBlLnNldERhdGFiYXNlSXRlbT1mdW5jdGlvbihhLGMsZCxmLGspe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RyeXtrPQprfHwib2JqZWN0cyI7QXJyYXkuaXNBcnJheShrKXx8KGs9W2tdLGE9W2FdLGM9W2NdKTt2YXIgZT1iLnRyYW5zYWN0aW9uKGssInJlYWR3cml0ZSIpO2Uub25jb21wbGV0ZT1kO2Uub25lcnJvcj1mO2ZvcihiPTA7YjxrLmxlbmd0aDtiKyspZS5vYmplY3RTdG9yZShrW2JdKS5wdXQobnVsbCE9YSYmbnVsbCE9YVtiXT97a2V5OmFbYl0sZGF0YTpjW2JdfTpjW2JdKX1jYXRjaCh0KXtudWxsIT1mJiZmKHQpfX0pLGYpfTtFZGl0b3JVaS5wcm90b3R5cGUucmVtb3ZlRGF0YWJhc2VJdGVtPWZ1bmN0aW9uKGEsYyxkLGYpe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe2Y9Znx8Im9iamVjdHMiO0FycmF5LmlzQXJyYXkoZil8fChmPVtmXSxhPVthXSk7Yj1iLnRyYW5zYWN0aW9uKGYsInJlYWR3cml0ZSIpO2Iub25jb21wbGV0ZT1jO2Iub25lcnJvcj1kO2Zvcih2YXIgZT0wO2U8Zi5sZW5ndGg7ZSsrKWIub2JqZWN0U3RvcmUoZltlXSlbImRlbGV0ZSJdKGFbZV0pfSksCmQpfTtFZGl0b3JVaS5wcm90b3R5cGUuZ2V0RGF0YWJhc2VJdGVtPWZ1bmN0aW9uKGEsYyxkLGYpe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RyeXtmPWZ8fCJvYmplY3RzIjt2YXIgZT1iLnRyYW5zYWN0aW9uKFtmXSwicmVhZG9ubHkiKS5vYmplY3RTdG9yZShmKS5nZXQoYSk7ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtjKGUucmVzdWx0KX07ZS5vbmVycm9yPWR9Y2F0Y2godil7bnVsbCE9ZCYmZCh2KX19KSxkKX07RWRpdG9yVWkucHJvdG90eXBlLmdldERhdGFiYXNlSXRlbXM9ZnVuY3Rpb24oYSxjLGQpe3RoaXMub3BlbkRhdGFiYXNlKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3RyeXtkPWR8fCJvYmplY3RzIjt2YXIgZT1iLnRyYW5zYWN0aW9uKFtkXSwicmVhZG9ubHkiKS5vYmplY3RTdG9yZShkKS5vcGVuQ3Vyc29yKElEQktleVJhbmdlLmxvd2VyQm91bmQoMCkpLGY9W107ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYil7bnVsbD09CmIudGFyZ2V0LnJlc3VsdD9hKGYpOihmLnB1c2goYi50YXJnZXQucmVzdWx0LnZhbHVlKSxiLnRhcmdldC5yZXN1bHRbImNvbnRpbnVlIl0oKSl9O2Uub25lcnJvcj1jfWNhdGNoKHYpe251bGwhPWMmJmModil9fSksYyl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXREYXRhYmFzZUl0ZW1LZXlzPWZ1bmN0aW9uKGEsYyxkKXt0aGlzLm9wZW5EYXRhYmFzZShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt0cnl7ZD1kfHwib2JqZWN0cyI7dmFyIGU9Yi50cmFuc2FjdGlvbihbZF0sInJlYWRvbmx5Iikub2JqZWN0U3RvcmUoZCkuZ2V0QWxsS2V5cygpO2Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7YShlLnJlc3VsdCl9O2Uub25lcnJvcj1jfWNhdGNoKHApe251bGwhPWMmJmMocCl9fSksYyl9O0VkaXRvclVpLnByb3RvdHlwZS5jb21tZW50c1N1cHBvcnRlZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0Q3VycmVudEZpbGUoKTtyZXR1cm4gbnVsbCE9YT9hLmNvbW1lbnRzU3VwcG9ydGVkKCk6CiExfTtFZGl0b3JVaS5wcm90b3R5cGUuY29tbWVudHNSZWZyZXNoTmVlZGVkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hP2EuY29tbWVudHNSZWZyZXNoTmVlZGVkKCk6ITB9O0VkaXRvclVpLnByb3RvdHlwZS5jb21tZW50c1NhdmVOZWVkZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIG51bGwhPWE/YS5jb21tZW50c1NhdmVOZWVkZWQoKTohMX07RWRpdG9yVWkucHJvdG90eXBlLmdldENvbW1lbnRzPWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWI/Yi5nZXRDb21tZW50cyhhLGMpOmEoW10pfTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ29tbWVudD1mdW5jdGlvbihhLGMsZCl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWI/Yi5hZGRDb21tZW50KGEsYyxkKTpjKERhdGUubm93KCkpfTtFZGl0b3JVaS5wcm90b3R5cGUuY2FuUmVwbHlUb1JlcGxpZXM9CmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hP2EuY2FuUmVwbHlUb1JlcGxpZXMoKTohMH07RWRpdG9yVWkucHJvdG90eXBlLmNhbkNvbW1lbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIG51bGwhPWE/YS5jYW5Db21tZW50KCk6ITB9O0VkaXRvclVpLnByb3RvdHlwZS5uZXdDb21tZW50PWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1iP2IubmV3Q29tbWVudChhLGMpOm5ldyBEcmF3aW9Db21tZW50KHRoaXMsbnVsbCxhLERhdGUubm93KCksRGF0ZS5ub3coKSwhMSxjKX07RWRpdG9yVWkucHJvdG90eXBlLmlzUmV2aXNpb25IaXN0b3J5U3VwcG9ydGVkPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJyZW50RmlsZSgpO3JldHVybiBudWxsIT1hJiZhLmlzUmV2aXNpb25IaXN0b3J5U3VwcG9ydGVkKCl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRSZXZpc2lvbnM9CmZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcy5nZXRDdXJyZW50RmlsZSgpO251bGwhPWImJmIuZ2V0UmV2aXNpb25zP2IuZ2V0UmV2aXNpb25zKGEsYyk6Yyh7bWVzc2FnZTpteFJlc291cmNlcy5nZXQoInVua25vd25FcnJvciIpfSl9O0VkaXRvclVpLnByb3RvdHlwZS5pc1JldmlzaW9uSGlzdG9yeUVuYWJsZWQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldEN1cnJlbnRGaWxlKCk7cmV0dXJuIG51bGwhPWEmJihhLmNvbnN0cnVjdG9yPT1Ecml2ZUZpbGUmJmEuaXNFZGl0YWJsZSgpfHxhLmNvbnN0cnVjdG9yPT1Ecm9wYm94RmlsZSl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRTZXJ2aWNlTmFtZT1mdW5jdGlvbigpe3JldHVybiJkcmF3LmlvIn07RWRpdG9yVWkucHJvdG90eXBlLmFkZFJlbW90ZVNlcnZpY2VTZWN1cml0eUNoZWNrPWZ1bmN0aW9uKGEpe2Euc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1MYW5ndWFnZSIsImRhLCBtaSwgZW4sIGRlLURFIil9O0VkaXRvclVpLnByb3RvdHlwZS5sb2FkVXJsPQpmdW5jdGlvbihhLGMsZCxmLGssbSxxLHQpe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogbG9hZFVybCIpO3JldHVybiB0aGlzLmVkaXRvci5sb2FkVXJsKGEsYyxkLGYsayxtLHEsdCl9O0VkaXRvclVpLnByb3RvdHlwZS5sb2FkRm9udHM9ZnVuY3Rpb24oYSl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBsb2FkRm9udHMiKTtyZXR1cm4gdGhpcy5lZGl0b3IubG9hZEZvbnRzKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlU3ZnRGF0YVVyaT1mdW5jdGlvbihhKXtFZGl0b3JVaS5sb2dFdmVudCgiU0hPVUxEIE5PVCBCRSBDQUxMRUQ6IGNyZWF0ZVN2Z0RhdGFVcmkiKTtyZXR1cm4gRWRpdG9yLmNyZWF0ZVN2Z0RhdGFVcmkoYSl9O0VkaXRvclVpLnByb3RvdHlwZS5lbWJlZENzc0ZvbnRzPWZ1bmN0aW9uKGEsYyl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBlbWJlZENzc0ZvbnRzIik7cmV0dXJuIHRoaXMuZWRpdG9yLmVtYmVkQ3NzRm9udHMoYSwKYyl9O0VkaXRvclVpLnByb3RvdHlwZS5lbWJlZEV4dEZvbnRzPWZ1bmN0aW9uKGEpe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogZW1iZWRFeHRGb250cyIpO3JldHVybiB0aGlzLmVkaXRvci5lbWJlZEV4dEZvbnRzKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUuZXhwb3J0VG9DYW52YXM9ZnVuY3Rpb24oYSxjLGQsZixrLG0scSx0LHkseCxDLEIsRCx6LEUsRyl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBleHBvcnRUb0NhbnZhcyIpO3JldHVybiB0aGlzLmVkaXRvci5leHBvcnRUb0NhbnZhcyhhLGMsZCxmLGssbSxxLHQseSx4LEMsQixELHosRSxHKX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZUltYWdlVXJsQ29udmVydGVyPWZ1bmN0aW9uKCl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBjcmVhdGVJbWFnZVVybENvbnZlcnRlciIpO3JldHVybiB0aGlzLmVkaXRvci5jcmVhdGVJbWFnZVVybENvbnZlcnRlcigpfTsKRWRpdG9yVWkucHJvdG90eXBlLmNvbnZlcnRJbWFnZXM9ZnVuY3Rpb24oYSxjLGQsZil7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBjb252ZXJ0SW1hZ2VzIik7cmV0dXJuIHRoaXMuZWRpdG9yLmNvbnZlcnRJbWFnZXMoYSxjLGQsZil9O0VkaXRvclVpLnByb3RvdHlwZS5jb252ZXJ0SW1hZ2VUb0RhdGFVcmk9ZnVuY3Rpb24oYSxjKXtFZGl0b3JVaS5sb2dFdmVudCgiU0hPVUxEIE5PVCBCRSBDQUxMRUQ6IGNvbnZlcnRJbWFnZVRvRGF0YVVyaSIpO3JldHVybiB0aGlzLmVkaXRvci5jb252ZXJ0SW1hZ2VUb0RhdGFVcmkoYSxjKX07RWRpdG9yVWkucHJvdG90eXBlLmJhc2U2NEVuY29kZT1mdW5jdGlvbihhKXtFZGl0b3JVaS5sb2dFdmVudCgiU0hPVUxEIE5PVCBCRSBDQUxMRUQ6IGJhc2U2NEVuY29kZSIpO3JldHVybiBFZGl0b3IuYmFzZTY0RW5jb2RlKGEpfTtFZGl0b3JVaS5wcm90b3R5cGUudXBkYXRlQ1JDPWZ1bmN0aW9uKGEsYyxkLGYpe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogdXBkYXRlQ1JDIik7CnJldHVybiBFZGl0b3IudXBkYXRlQ1JDKGEsYyxkLGYpfTtFZGl0b3JVaS5wcm90b3R5cGUuY3JjMzI9ZnVuY3Rpb24oYSl7RWRpdG9yVWkubG9nRXZlbnQoIlNIT1VMRCBOT1QgQkUgQ0FMTEVEOiBjcmMzMiIpO3JldHVybiBFZGl0b3IuY3JjMzIoYSl9O0VkaXRvclVpLnByb3RvdHlwZS53cml0ZUdyYXBoTW9kZWxUb1BuZz1mdW5jdGlvbihhLGMsZCxmLGspe0VkaXRvclVpLmxvZ0V2ZW50KCJTSE9VTEQgTk9UIEJFIENBTExFRDogd3JpdGVHcmFwaE1vZGVsVG9QbmciKTtyZXR1cm4gRWRpdG9yLndyaXRlR3JhcGhNb2RlbFRvUG5nKGEsYyxkLGYsayl9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRMb2NhbFN0b3JhZ2VGaWxlTmFtZXM9ZnVuY3Rpb24oKXtpZigiMSI9PWxvY2FsU3RvcmFnZS5nZXRJdGVtKCIubG9jYWxTdG9yYWdlTWlncmF0ZWQiKSYmIjEiIT11cmxQYXJhbXMuZm9yY2VNaWdyYXRpb24pcmV0dXJuIG51bGw7Zm9yKHZhciBhPVtdLGM9MDtjPGxvY2FsU3RvcmFnZS5sZW5ndGg7YysrKXt2YXIgZD0KbG9jYWxTdG9yYWdlLmtleShjKSxmPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGQpO2lmKDA8ZC5sZW5ndGgmJigiLnNjcmF0Y2hwYWQiPT1kfHwiLiIhPWQuY2hhckF0KDApKSYmMDxmLmxlbmd0aCl7dmFyIGs9IjxteGZpbGUgIj09PWYuc3Vic3RyaW5nKDAsOCl8fCI8P3htbCI9PT1mLnN1YnN0cmluZygwLDUpfHwiXHgzYyEtLVtpZiBJRV0+Ij09PWYuc3Vic3RyaW5nKDAsMTIpLGY9IjxteGxpYnJhcnk+Ij09PWYuc3Vic3RyaW5nKDAsMTEpOyhrfHxmKSYmYS5wdXNoKGQpfX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmdldExvY2FsU3RvcmFnZUZpbGU9ZnVuY3Rpb24oYSl7aWYoIjEiPT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgiLmxvY2FsU3RvcmFnZU1pZ3JhdGVkIikmJiIxIiE9dXJsUGFyYW1zLmZvcmNlTWlncmF0aW9uKXJldHVybiBudWxsO3ZhciBiPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGEpO3JldHVybnt0aXRsZTphLGRhdGE6Yixpc0xpYjoiPG14bGlicmFyeT4iPT09CmIuc3Vic3RyaW5nKDAsMTEpfX07RWRpdG9yVWkucHJvdG90eXBlLnNldE1pZ3JhdGVkRmxhZz1mdW5jdGlvbigpe2xvY2FsU3RvcmFnZS5zZXRJdGVtKCIubG9jYWxTdG9yYWdlTWlncmF0ZWQiLCIxIil9fSkoKTsKdmFyIENvbW1lbnRzV2luZG93PWZ1bmN0aW9uKGEsYyxmLGQsayxtKXtmdW5jdGlvbiBxKCl7Zm9yKHZhciBhPUIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpLGI9MCxjPTA7YzxhLmxlbmd0aDtjKyspIm5vbmUiIT1hW2NdLnN0eWxlLmRpc3BsYXkmJmFbY10ucGFyZW50Tm9kZT09QiYmYisrO0Quc3R5bGUuZGlzcGxheT0wPT1iPyJibG9jayI6Im5vbmUifWZ1bmN0aW9uIGIoYSxiLGMsZCl7ZnVuY3Rpb24gZSgpe2IucmVtb3ZlQ2hpbGQoayk7Yi5yZW1vdmVDaGlsZChsKTtnLnN0eWxlLmRpc3BsYXk9ImJsb2NrIjtmLnN0eWxlLmRpc3BsYXk9ImJsb2NrIn15PXtkaXY6Yixjb21tZW50OmEsc2F2ZUNhbGxiYWNrOmMsZGVsZXRlT25DYW5jZWw6ZH07dmFyIGY9Yi5xdWVyeVNlbGVjdG9yKCIuZ2VDb21tZW50VHh0IiksZz1iLnF1ZXJ5U2VsZWN0b3IoIi5nZUNvbW1lbnRBY3Rpb25zTGlzdCIpLGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGV4dGFyZWEiKTtrLmNsYXNzTmFtZT0KImdlQ29tbWVudEVkaXRUeHRBcmVhIjtrLnN0eWxlLm1pbkhlaWdodD1mLm9mZnNldEhlaWdodCsicHgiO2sudmFsdWU9YS5jb250ZW50O2IuaW5zZXJ0QmVmb3JlKGssZik7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bC5jbGFzc05hbWU9ImdlQ29tbWVudEVkaXRCdG5zIjt2YXIgbT1teFV0aWxzLmJ1dHRvbihteFJlc291cmNlcy5nZXQoImNhbmNlbCIpLGZ1bmN0aW9uKCl7ZD8oYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLHEoKSk6ZSgpO3k9bnVsbH0pO20uY2xhc3NOYW1lPSJnZUNvbW1lbnRFZGl0QnRuIjtsLmFwcGVuZENoaWxkKG0pO3ZhciBuPW14VXRpbHMuYnV0dG9uKG14UmVzb3VyY2VzLmdldCgic2F2ZSIpLGZ1bmN0aW9uKCl7Zi5pbm5lckhUTUw9IiI7YS5jb250ZW50PWsudmFsdWU7bXhVdGlscy53cml0ZShmLGEuY29udGVudCk7ZSgpO2MoYSk7eT1udWxsfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihrLCJrZXlkb3duIixteFV0aWxzLmJpbmQodGhpcywKZnVuY3Rpb24oYSl7bXhFdmVudC5pc0NvbnN1bWVkKGEpfHwoKG14RXZlbnQuaXNDb250cm9sRG93bihhKXx8bXhDbGllbnQuSVNfTUFDJiZteEV2ZW50LmlzTWV0YURvd24oYSkpJiYxMz09YS5rZXlDb2RlPyhuLmNsaWNrKCksbXhFdmVudC5jb25zdW1lKGEpKToyNz09YS5rZXlDb2RlJiYobS5jbGljaygpLG14RXZlbnQuY29uc3VtZShhKSkpfSkpO24uZm9jdXMoKTtuLmNsYXNzTmFtZT0iZ2VDb21tZW50RWRpdEJ0biBnZVByaW1hcnlCdG4iO2wuYXBwZW5kQ2hpbGQobik7Yi5pbnNlcnRCZWZvcmUobCxmKTtnLnN0eWxlLmRpc3BsYXk9Im5vbmUiO2Yuc3R5bGUuZGlzcGxheT0ibm9uZSI7ay5mb2N1cygpfWZ1bmN0aW9uIGUoYixjKXtjLmlubmVySFRNTD0iIjt2YXIgZD1uZXcgRGF0ZShiLm1vZGlmaWVkRGF0ZSksZT1hLnRpbWVTaW5jZShkKTtudWxsPT1lJiYoZT1teFJlc291cmNlcy5nZXQoImxlc3NUaGFuQU1pbnV0ZSIpKTtteFV0aWxzLndyaXRlKGMsbXhSZXNvdXJjZXMuZ2V0KCJ0aW1lQWdvIiwKW2VdLCJ7MX0gYWdvIikpO2Muc2V0QXR0cmlidXRlKCJ0aXRsZSIsZC50b0xvY2FsZURhdGVTdHJpbmcoKSsiICIrZC50b0xvY2FsZVRpbWVTdHJpbmcoKSl9ZnVuY3Rpb24gZyhhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtiLmNsYXNzTmFtZT0iZ2VDb21tZW50QnVzeUltZyI7Yi5zcmM9SU1BR0VfUEFUSCsiL3NwaW4uZ2lmIjthLmFwcGVuZENoaWxkKGIpO2EuYnVzeUltZz1ifWZ1bmN0aW9uIG4oYSl7YS5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCByZWQiO2EucmVtb3ZlQ2hpbGQoYS5idXN5SW1nKX1mdW5jdGlvbiBsKGEpe2Euc3R5bGUuYm9yZGVyPSIiO2EucmVtb3ZlQ2hpbGQoYS5idXN5SW1nKX1mdW5jdGlvbiBwKGMsZCxmLGssbSl7ZnVuY3Rpb24gQShhLGIsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgibGkiKTtlLmNsYXNzTmFtZT0iZ2VDb21tZW50QWN0aW9uIjt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7Zi5jbGFzc05hbWU9CiJnZUNvbW1lbnRBY3Rpb25MbmsiO214VXRpbHMud3JpdGUoZixhKTtlLmFwcGVuZENoaWxkKGYpO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiY2xpY2siLGZ1bmN0aW9uKGEpe2IoYSxjKTthLnByZXZlbnREZWZhdWx0KCk7bXhFdmVudC5jb25zdW1lKGEpfSk7Ri5hcHBlbmRDaGlsZChlKTtkJiYoZS5zdHlsZS5kaXNwbGF5PSJub25lIil9ZnVuY3Rpb24gdSgpe2Z1bmN0aW9uIGEoYyl7Yi5wdXNoKGQpO2lmKG51bGwhPWMucmVwbGllcylmb3IodmFyIGU9MDtlPGMucmVwbGllcy5sZW5ndGg7ZSsrKWQ9ZC5uZXh0U2libGluZyxhKGMucmVwbGllc1tlXSl9dmFyIGI9W10sZD14O2EoYyk7cmV0dXJue3BkaXY6ZCxyZXBsaWVzOmJ9fWZ1bmN0aW9uIHooZCxlLGYsbSxxKXtmdW5jdGlvbiB0KCl7Zyh2KTtjLmFkZFJlcGx5KHosZnVuY3Rpb24oYSl7ei5pZD1hO2MucmVwbGllcy5wdXNoKHopO2wodik7ZiYmZigpfSxmdW5jdGlvbihiKXt5KCk7bih2KTthLmhhbmRsZUVycm9yKGIsbnVsbCwKbnVsbCxudWxsLG14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgib2JqZWN0Tm90Rm91bmQiKSkpfSxtLHEpfWZ1bmN0aW9uIHkoKXtiKHosdixmdW5jdGlvbihhKXt0KCl9LCEwKX12YXIgQT11KCkucGRpdix6PWEubmV3Q29tbWVudChkLGEuZ2V0Q3VycmVudFVzZXIoKSk7ei5wQ29tbWVudElkPWMuaWQ7bnVsbD09Yy5yZXBsaWVzJiYoYy5yZXBsaWVzPVtdKTt2YXIgdj1wKHosYy5yZXBsaWVzLEEsaysxKTtlP3koKTp0KCl9aWYobXx8IWMuaXNSZXNvbHZlZCl7RC5zdHlsZS5kaXNwbGF5PSJub25lIjt2YXIgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTt4LmNsYXNzTmFtZT0iZ2VDb21tZW50Q29udGFpbmVyIjt4LnNldEF0dHJpYnV0ZSgiZGF0YS1jb21tZW50SWQiLGMuaWQpO3guc3R5bGUubWFyZ2luTGVmdD0yMCprKzUrInB4IjtjLmlzUmVzb2x2ZWQmJiJkYXJrIiE9dWlUaGVtZSYmKHguc3R5bGUuYmFja2dyb3VuZENvbG9yPSJnaG9zdFdoaXRlIik7CnZhciBFPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO0UuY2xhc3NOYW1lPSJnZUNvbW1lbnRIZWFkZXIiO3ZhciBDPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO0MuY2xhc3NOYW1lPSJnZUNvbW1lbnRVc2VySW1nIjtDLnNyYz1jLnVzZXIucGljdHVyZVVybHx8RWRpdG9yLnVzZXJJbWFnZTtFLmFwcGVuZENoaWxkKEMpO0M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Qy5jbGFzc05hbWU9ImdlQ29tbWVudEhlYWRlclR4dCI7RS5hcHBlbmRDaGlsZChDKTt2YXIgTT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtNLmNsYXNzTmFtZT0iZ2VDb21tZW50VXNlcm5hbWUiO214VXRpbHMud3JpdGUoTSxjLnVzZXIuZGlzcGxheU5hbWV8fCIiKTtDLmFwcGVuZENoaWxkKE0pO009ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7TS5jbGFzc05hbWU9ImdlQ29tbWVudERhdGUiO00uc2V0QXR0cmlidXRlKCJkYXRhLWNvbW1lbnRJZCIsYy5pZCk7ZShjLApNKTtDLmFwcGVuZENoaWxkKE0pO3guYXBwZW5kQ2hpbGQoRSk7RT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtFLmNsYXNzTmFtZT0iZ2VDb21tZW50VHh0IjtteFV0aWxzLndyaXRlKEUsYy5jb250ZW50fHwiIik7eC5hcHBlbmRDaGlsZChFKTtFPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO0UuY2xhc3NOYW1lPSJnZUNvbW1lbnRBY3Rpb25zIjt2YXIgRj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJ1bCIpO0YuY2xhc3NOYW1lPSJnZUNvbW1lbnRBY3Rpb25zTGlzdCI7RS5hcHBlbmRDaGlsZChGKTt2fHwwIT1rJiYhdHx8QShteFJlc291cmNlcy5nZXQoInJlcGx5IiksZnVuY3Rpb24oKXt6KCIiLCEwKX0sYy5pc1Jlc29sdmVkKTtDPWEuZ2V0Q3VycmVudFVzZXIoKTtudWxsPT1DfHxDLmlkIT1jLnVzZXIuaWR8fHZ8fChBKG14UmVzb3VyY2VzLmdldCgiZWRpdCIpLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZCgpe2IoYyx4LGZ1bmN0aW9uKCl7Zyh4KTtjLmVkaXRDb21tZW50KGMuY29udGVudCwKZnVuY3Rpb24oKXtsKHgpfSxmdW5jdGlvbihiKXtuKHgpO2QoKTthLmhhbmRsZUVycm9yKGIsbnVsbCxudWxsLG51bGwsbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJvYmplY3ROb3RGb3VuZCIpKSl9KX0pfWQoKX0sYy5pc1Jlc29sdmVkKSxBKG14UmVzb3VyY2VzLmdldCgiZGVsZXRlIiksZnVuY3Rpb24oKXthLmNvbmZpcm0obXhSZXNvdXJjZXMuZ2V0KCJhcmVZb3VTdXJlIiksZnVuY3Rpb24oKXtnKHgpO2MuZGVsZXRlQ29tbWVudChmdW5jdGlvbigpe2Zvcih2YXIgYT11KGMpLnJlcGxpZXMsYj0wO2I8YS5sZW5ndGg7YisrKUIucmVtb3ZlQ2hpbGQoYVtiXSk7Zm9yKGI9MDtiPGQubGVuZ3RoO2IrKylpZihkW2JdPT1jKXtkLnNwbGljZShiLDEpO2JyZWFrfUQuc3R5bGUuZGlzcGxheT0wPT1CLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKS5sZW5ndGg/ImJsb2NrIjoibm9uZSJ9LGZ1bmN0aW9uKGIpe24oeCk7YS5oYW5kbGVFcnJvcihiLG51bGwsbnVsbCwKbnVsbCxteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoIm9iamVjdE5vdEZvdW5kIikpKX0pfSl9LGMuaXNSZXNvbHZlZCkpO3Z8fDAhPWt8fEEoYy5pc1Jlc29sdmVkP214UmVzb3VyY2VzLmdldCgicmVvcGVuIik6bXhSZXNvdXJjZXMuZ2V0KCJyZXNvbHZlIiksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe3ZhciBiPWEudGFyZ2V0O2IuaW5uZXJIVE1MPSIiO2MuaXNSZXNvbHZlZD0hYy5pc1Jlc29sdmVkO214VXRpbHMud3JpdGUoYixjLmlzUmVzb2x2ZWQ/bXhSZXNvdXJjZXMuZ2V0KCJyZW9wZW4iKTpteFJlc291cmNlcy5nZXQoInJlc29sdmUiKSk7Zm9yKHZhciBkPWMuaXNSZXNvbHZlZD8ibm9uZSI6IiIsZT11KGMpLnJlcGxpZXMsZj0iZGFyayI9PXVpVGhlbWU/InRyYW5zcGFyZW50IjpjLmlzUmVzb2x2ZWQ/Imdob3N0V2hpdGUiOiJ3aGl0ZSIsZz0wO2c8ZS5sZW5ndGg7ZysrKXtlW2ddLnN0eWxlLmJhY2tncm91bmRDb2xvcj1mO2Zvcih2YXIgaz1lW2ddLnF1ZXJ5U2VsZWN0b3JBbGwoIi5nZUNvbW1lbnRBY3Rpb24iKSwKbD0wO2w8ay5sZW5ndGg7bCsrKWtbbF0hPWIucGFyZW50Tm9kZSYmKGtbbF0uc3R5bGUuZGlzcGxheT1kKTtHfHwoZVtnXS5zdHlsZS5kaXNwbGF5PSJub25lIil9cSgpfWMuaXNSZXNvbHZlZD96KG14UmVzb3VyY2VzLmdldCgicmVPcGVuZWQiKSsiOiAiLCEwLGIsITEsITApOnoobXhSZXNvdXJjZXMuZ2V0KCJtYXJrZWRBc1Jlc29sdmVkIiksITEsYiwhMCl9KTt4LmFwcGVuZENoaWxkKEUpO251bGwhPWY/Qi5pbnNlcnRCZWZvcmUoeCxmLm5leHRTaWJsaW5nKTpCLmFwcGVuZENoaWxkKHgpO2ZvcihmPTA7bnVsbCE9Yy5yZXBsaWVzJiZmPGMucmVwbGllcy5sZW5ndGg7ZisrKUU9Yy5yZXBsaWVzW2ZdLEUuaXNSZXNvbHZlZD1jLmlzUmVzb2x2ZWQscChFLGMucmVwbGllcyxudWxsLGsrMSxtKTtudWxsIT15JiYoeS5jb21tZW50LmlkPT1jLmlkPyhtPWMuY29udGVudCxjLmNvbnRlbnQ9eS5jb21tZW50LmNvbnRlbnQsYihjLHgseS5zYXZlQ2FsbGJhY2sseS5kZWxldGVPbkNhbmNlbCksCmMuY29udGVudD1tKTpudWxsPT15LmNvbW1lbnQuaWQmJnkuY29tbWVudC5wQ29tbWVudElkPT1jLmlkJiYoQi5hcHBlbmRDaGlsZCh5LmRpdiksYih5LmNvbW1lbnQseS5kaXYseS5zYXZlQ2FsbGJhY2sseS5kZWxldGVPbkNhbmNlbCkpKTtyZXR1cm4geH19dmFyIHY9IWEuY2FuQ29tbWVudCgpLHQ9YS5jYW5SZXBseVRvUmVwbGllcygpLHk9bnVsbCx4PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3guY2xhc3NOYW1lPSJnZUNvbW1lbnRzV2luIjt4LnN0eWxlLmJhY2tncm91bmQ9IndoaXRlIj09RGlhbG9nLmJhY2tkcm9wQ29sb3I/IndoaXRlU21va2UiOkRpYWxvZy5iYWNrZHJvcENvbG9yO3ZhciBDPUVkaXRvclVpLmNvbXBhY3RVaT8iMjZweCI6IjMwcHgiLEI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Qi5jbGFzc05hbWU9ImdlQ29tbWVudHNMaXN0IjtCLnN0eWxlLmJhY2tncm91bmRDb2xvcj0id2hpdGUiPT1EaWFsb2cuYmFja2Ryb3BDb2xvcj8id2hpdGVTbW9rZSI6CkRpYWxvZy5iYWNrZHJvcENvbG9yO0Iuc3R5bGUuYm90dG9tPXBhcnNlSW50KEMpKzcrInB4Ijt4LmFwcGVuZENoaWxkKEIpO3ZhciBEPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtELnN0eWxlLmNzc1RleHQ9ImRpc3BsYXk6bm9uZTtwYWRkaW5nLXRvcDoxMHB4O3RleHQtYWxpZ246Y2VudGVyOyI7bXhVdGlscy53cml0ZShELG14UmVzb3VyY2VzLmdldCgibm9Db21tZW50c0ZvdW5kIikpO3ZhciB6PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3ouY2xhc3NOYW1lPSJnZVRvb2xiYXJDb250YWluZXIgZ2VDb21tZW50c1Rvb2xiYXIiO3ouc3R5bGUuaGVpZ2h0PUM7ei5zdHlsZS5wYWRkaW5nPUVkaXRvclVpLmNvbXBhY3RVaT8iNHB4IDBweCAzcHggMHB4IjoiMXB4Ijt6LnN0eWxlLmJhY2tncm91bmRDb2xvcj0id2hpdGUiPT1EaWFsb2cuYmFja2Ryb3BDb2xvcj8id2hpdGVTbW9rZSI6RGlhbG9nLmJhY2tkcm9wQ29sb3I7bXhDbGllbnQuSVNfUVVJUktTJiYoei5zdHlsZS5maWx0ZXI9CiJub25lIik7Qz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7Qy5jbGFzc05hbWU9ImdlQnV0dG9uIjtteENsaWVudC5JU19RVUlSS1MmJihDLnN0eWxlLmZpbHRlcj0ibm9uZSIpO2lmKCF2KXt2YXIgRT1DLmNsb25lTm9kZSgpO0UuaW5uZXJIVE1MPSc8ZGl2IGNsYXNzPSJnZVNwcml0ZSBnZVNwcml0ZS1wbHVzIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7Ij48L2Rpdj4nO0Uuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJjcmVhdGUiKSsiLi4uIik7bXhFdmVudC5hZGRMaXN0ZW5lcihFLCJjbGljayIsZnVuY3Rpb24oYyl7ZnVuY3Rpb24gZCgpe2IoZSxmLGZ1bmN0aW9uKGIpe2coZik7YS5hZGRDb21tZW50KGIsZnVuY3Rpb24oYSl7Yi5pZD1hO0YucHVzaChiKTtsKGYpfSxmdW5jdGlvbihiKXtuKGYpO2QoKTthLmhhbmRsZUVycm9yKGIsbnVsbCxudWxsLG51bGwsbXhVdGlscy5odG1sRW50aXRpZXMobXhSZXNvdXJjZXMuZ2V0KCJvYmplY3ROb3RGb3VuZCIpKSl9KX0sCiEwKX12YXIgZT1hLm5ld0NvbW1lbnQoIiIsYS5nZXRDdXJyZW50VXNlcigpKSxmPXAoZSxGLG51bGwsMCk7ZCgpO2MucHJldmVudERlZmF1bHQoKTtteEV2ZW50LmNvbnN1bWUoYyl9KTt6LmFwcGVuZENoaWxkKEUpfUU9Qy5jbG9uZU5vZGUoKTtFLmlubmVySFRNTD0nPGltZyBzcmM9IicrSU1BR0VfUEFUSCsnL2NoZWNrLnBuZyIgc3R5bGU9IndpZHRoOiAxNnB4OyBwYWRkaW5nOiAycHg7Ij4nO0Uuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzaG93UmVzb2x2ZWQiKSk7dmFyIEc9ITE7ImRhcmsiPT11aVRoZW1lJiYoRS5zdHlsZS5maWx0ZXI9ImludmVydCgxMDAlKSIpO214RXZlbnQuYWRkTGlzdGVuZXIoRSwiY2xpY2siLGZ1bmN0aW9uKGEpe3RoaXMuY2xhc3NOYW1lPShHPSFHKT8iZ2VCdXR0b24gZ2VDaGVja2VkQnRuIjoiZ2VCdXR0b24iO0goKTthLnByZXZlbnREZWZhdWx0KCk7bXhFdmVudC5jb25zdW1lKGEpfSk7ei5hcHBlbmRDaGlsZChFKTthLmNvbW1lbnRzUmVmcmVzaE5lZWRlZCgpJiYKKEU9Qy5jbG9uZU5vZGUoKSxFLmlubmVySFRNTD0nPGltZyBzcmM9IicrSU1BR0VfUEFUSCsnL3VwZGF0ZTE2LnBuZyIgc3R5bGU9IndpZHRoOiAxNnB4OyBwYWRkaW5nOiAycHg7Ij4nLEUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJyZWZyZXNoIikpLCJkYXJrIj09dWlUaGVtZSYmKEUuc3R5bGUuZmlsdGVyPSJpbnZlcnQoMTAwJSkiKSxteEV2ZW50LmFkZExpc3RlbmVyKEUsImNsaWNrIixmdW5jdGlvbihhKXtIKCk7YS5wcmV2ZW50RGVmYXVsdCgpO214RXZlbnQuY29uc3VtZShhKX0pLHouYXBwZW5kQ2hpbGQoRSkpO2EuY29tbWVudHNTYXZlTmVlZGVkKCkmJihDPUMuY2xvbmVOb2RlKCksQy5pbm5lckhUTUw9JzxpbWcgc3JjPSInK0lNQUdFX1BBVEgrJy9zYXZlLnBuZyIgc3R5bGU9IndpZHRoOiAyMHB4OyBwYWRkaW5nOiAycHg7Ij4nLEMuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlIikpLCJkYXJrIj09dWlUaGVtZSYmCihDLnN0eWxlLmZpbHRlcj0iaW52ZXJ0KDEwMCUpIiksbXhFdmVudC5hZGRMaXN0ZW5lcihDLCJjbGljayIsZnVuY3Rpb24oYSl7bSgpO2EucHJldmVudERlZmF1bHQoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSx6LmFwcGVuZENoaWxkKEMpKTt4LmFwcGVuZENoaWxkKHopO3ZhciBGPVtdLEg9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmhhc0Vycm9yPSExO2lmKG51bGwhPXkpdHJ5e3kuZGl2PXkuZGl2LmNsb25lTm9kZSghMCk7dmFyIGM9eS5kaXYucXVlcnlTZWxlY3RvcigiLmdlQ29tbWVudEVkaXRUeHRBcmVhIiksZD15LmRpdi5xdWVyeVNlbGVjdG9yKCIuZ2VDb21tZW50RWRpdEJ0bnMiKTt5LmNvbW1lbnQuY29udGVudD1jLnZhbHVlO2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTtkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCl9Y2F0Y2goQSl7YS5oYW5kbGVFcnJvcihBKX1CLmlubmVySFRNTD0nPGRpdiBzdHlsZT0icGFkZGluZy10b3A6MTBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPjxpbWcgc3JjPSInKwpJTUFHRV9QQVRIKycvc3Bpbi5naWYiIHZhbGlnbj0ibWlkZGxlIj4gJytteFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImxvYWRpbmciKSkrIi4uLjwvZGl2PiI7dD1hLmNhblJlcGx5VG9SZXBsaWVzKCk7YS5jb21tZW50c1N1cHBvcnRlZCgpP2EuZ2V0Q29tbWVudHMoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhKXtpZihudWxsIT1hKXthLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IERhdGUoYS5tb2RpZmllZERhdGUpLW5ldyBEYXRlKGIubW9kaWZpZWREYXRlKX0pO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKWMoYVtiXS5yZXBsaWVzKX19YS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBEYXRlKGEubW9kaWZpZWREYXRlKS1uZXcgRGF0ZShiLm1vZGlmaWVkRGF0ZSl9KTtCLmlubmVySFRNTD0iIjtCLmFwcGVuZENoaWxkKEQpO0Quc3R5bGUuZGlzcGxheT0iYmxvY2siO0Y9YTtmb3IoYT0wO2E8Ri5sZW5ndGg7YSsrKWMoRlthXS5yZXBsaWVzKSwKcChGW2FdLEYsbnVsbCwwLEcpO251bGwhPXkmJm51bGw9PXkuY29tbWVudC5pZCYmbnVsbD09eS5jb21tZW50LnBDb21tZW50SWQmJihCLmFwcGVuZENoaWxkKHkuZGl2KSxiKHkuY29tbWVudCx5LmRpdix5LnNhdmVDYWxsYmFjayx5LmRlbGV0ZU9uQ2FuY2VsKSl9LG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe0IuaW5uZXJIVE1MPW14VXRpbHMuaHRtbEVudGl0aWVzKG14UmVzb3VyY2VzLmdldCgiZXJyb3IiKSsoYSYmYS5tZXNzYWdlPyI6ICIrYS5tZXNzYWdlOiIiKSk7dGhpcy5oYXNFcnJvcj0hMH0pKTpCLmlubmVySFRNTD1teFV0aWxzLmh0bWxFbnRpdGllcyhteFJlc291cmNlcy5nZXQoImVycm9yIikpfSk7SCgpO3RoaXMucmVmcmVzaENvbW1lbnRzPUg7ej1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYil7dmFyIGQ9Y1tiLmlkXTtpZihudWxsIT1kKWZvcihlKGIsZCksZD0wO251bGwhPWIucmVwbGllcyYmZDxiLnJlcGxpZXMubGVuZ3RoO2QrKylhKGIucmVwbGllc1tkXSl9CmlmKHRoaXMud2luZG93LmlzVmlzaWJsZSgpKXtmb3IodmFyIGI9Qi5xdWVyeVNlbGVjdG9yQWxsKCIuZ2VDb21tZW50RGF0ZSIpLGM9e30sZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZj1iW2RdO2NbZi5nZXRBdHRyaWJ1dGUoImRhdGEtY29tbWVudElkIildPWZ9Zm9yKGQ9MDtkPEYubGVuZ3RoO2QrKylhKEZbZF0pfX0pO3NldEludGVydmFsKHosNkU0KTt0aGlzLnJlZnJlc2hDb21tZW50c1RpbWU9ejt0aGlzLndpbmRvdz1uZXcgbXhXaW5kb3cobXhSZXNvdXJjZXMuZ2V0KCJjb21tZW50cyIpLHgsYyxmLGQsaywhMCwhMCk7dGhpcy53aW5kb3cubWluaW11bVNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCwzMDAsMjAwKTt0aGlzLndpbmRvdy5kZXN0cm95T25DbG9zZT0hMTt0aGlzLndpbmRvdy5zZXRNYXhpbWl6YWJsZSghMSk7dGhpcy53aW5kb3cuc2V0UmVzaXphYmxlKCEwKTt0aGlzLndpbmRvdy5zZXRDbG9zYWJsZSghMCk7dGhpcy53aW5kb3cuc2V0VmlzaWJsZSghMCk7dGhpcy53aW5kb3cuYWRkTGlzdGVuZXIobXhFdmVudC5TSE9XLApteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMud2luZG93LmZpdCgpfSkpO3RoaXMud2luZG93LnNldExvY2F0aW9uPWZ1bmN0aW9uKGEsYil7dmFyIGM9d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDthPU1hdGgubWF4KDAsTWF0aC5taW4oYSwod2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCktdGhpcy50YWJsZS5jbGllbnRXaWR0aCkpO2I9TWF0aC5tYXgoMCxNYXRoLm1pbihiLGMtdGhpcy50YWJsZS5jbGllbnRIZWlnaHQtNDgpKTt0aGlzLmdldFgoKT09YSYmdGhpcy5nZXRZKCk9PWJ8fG14V2luZG93LnByb3RvdHlwZS5zZXRMb2NhdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBKPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy53aW5kb3cuZ2V0WCgpLApiPXRoaXMud2luZG93LmdldFkoKTt0aGlzLndpbmRvdy5zZXRMb2NhdGlvbihhLGIpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsSik7dGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7bXhFdmVudC5yZW1vdmVMaXN0ZW5lcih3aW5kb3csInJlc2l6ZSIsSik7dGhpcy53aW5kb3cuZGVzdHJveSgpfX0sQ29uZmlybURpYWxvZz1mdW5jdGlvbihhLGMsZixkLGssbSxxLGIsZSxnLG4pe3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2wuc3R5bGUudGV4dEFsaWduPSJjZW50ZXIiO249bnVsbCE9bj9uOjQ0O3ZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3Auc3R5bGUucGFkZGluZz0iNnB4IjtwLnN0eWxlLm92ZXJmbG93PSJhdXRvIjtwLnN0eWxlLm1heEhlaWdodD1uKyJweCI7cC5zdHlsZS5saW5lSGVpZ2h0PSIxLjJlbSI7bXhDbGllbnQuSVNfUVVJUktTJiYocC5zdHlsZS5oZWlnaHQ9IjYwcHgiKTtteFV0aWxzLndyaXRlKHAsYyk7CmwuYXBwZW5kQ2hpbGQocCk7bnVsbCE9ZyYmKHA9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2IikscC5zdHlsZS5wYWRkaW5nPSI2cHggMCA2cHggMCIsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKSxjLnNldEF0dHJpYnV0ZSgic3JjIixnKSxwLmFwcGVuZENoaWxkKGMpLGwuYXBwZW5kQ2hpbGQocCkpO2c9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zy5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7Zy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO3ZhciB2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7di5zZXRBdHRyaWJ1dGUoInR5cGUiLCJjaGVja2JveCIpO209bXhVdGlscy5idXR0b24obXx8bXhSZXNvdXJjZXMuZ2V0KCJjYW5jZWwiKSxmdW5jdGlvbigpe2EuaGlkZURpYWxvZygpO251bGwhPWQmJmQodi5jaGVja2VkKX0pO20uY2xhc3NOYW1lPSJnZUJ0biI7bnVsbCE9YiYmKG0uaW5uZXJIVE1MPWIrIjxicj4iK20uaW5uZXJIVE1MLG0uc3R5bGUucGFkZGluZ0JvdHRvbT0KIjhweCIsbS5zdHlsZS5wYWRkaW5nVG9wPSI4cHgiLG0uc3R5bGUuaGVpZ2h0PSJhdXRvIixtLnN0eWxlLndpZHRoPSI0MCUiKTthLmVkaXRvci5jYW5jZWxGaXJzdCYmZy5hcHBlbmRDaGlsZChtKTt2YXIgdD1teFV0aWxzLmJ1dHRvbihrfHxteFJlc291cmNlcy5nZXQoIm9rIiksZnVuY3Rpb24oKXthLmhpZGVEaWFsb2coKTtudWxsIT1mJiZmKHYuY2hlY2tlZCl9KTtnLmFwcGVuZENoaWxkKHQpO251bGwhPXE/KHQuaW5uZXJIVE1MPXErIjxicj4iK3QuaW5uZXJIVE1MKyI8YnI+Iix0LnN0eWxlLnBhZGRpbmdCb3R0b209IjhweCIsdC5zdHlsZS5wYWRkaW5nVG9wPSI4cHgiLHQuc3R5bGUuaGVpZ2h0PSJhdXRvIix0LmNsYXNzTmFtZT0iZ2VCdG4iLHQuc3R5bGUud2lkdGg9IjQwJSIpOnQuY2xhc3NOYW1lPSJnZUJ0biBnZVByaW1hcnlCdG4iO2EuZWRpdG9yLmNhbmNlbEZpcnN0fHxnLmFwcGVuZENoaWxkKG0pO2wuYXBwZW5kQ2hpbGQoZyk7ZT8oZy5zdHlsZS5tYXJnaW5Ub3A9CiIxMHB4IixwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInAiKSxwLnN0eWxlLm1hcmdpblRvcD0iMjBweCIscC5hcHBlbmRDaGlsZCh2KSxrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKSxteFV0aWxzLndyaXRlKGssIiAiK214UmVzb3VyY2VzLmdldCgicmVtZW1iZXJUaGlzU2V0dGluZyIpKSxwLmFwcGVuZENoaWxkKGspLGwuYXBwZW5kQ2hpbGQocCksbXhFdmVudC5hZGRMaXN0ZW5lcihrLCJjbGljayIsZnVuY3Rpb24oYSl7di5jaGVja2VkPSF2LmNoZWNrZWQ7bXhFdmVudC5jb25zdW1lKGEpfSkpOmcuc3R5bGUubWFyZ2luVG9wPSIxMnB4Ijt0aGlzLmluaXQ9ZnVuY3Rpb24oKXt0LmZvY3VzKCl9O3RoaXMuY29udGFpbmVyPWx9O2Z1bmN0aW9uIERpYWdyYW1QYWdlKGEsYyl7dGhpcy5ub2RlPWE7bnVsbCE9Yz90aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJpZCIsYyk6bnVsbD09dGhpcy5nZXRJZCgpJiZ0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCJpZCIsRWRpdG9yLmd1aWQoKSl9RGlhZ3JhbVBhZ2UucHJvdG90eXBlLm5vZGU9bnVsbDtEaWFncmFtUGFnZS5wcm90b3R5cGUucm9vdD1udWxsO0RpYWdyYW1QYWdlLnByb3RvdHlwZS52aWV3U3RhdGU9bnVsbDtEaWFncmFtUGFnZS5wcm90b3R5cGUuZ2V0SWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZSgiaWQiKX07RGlhZ3JhbVBhZ2UucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZSgibmFtZSIpfTsKRGlhZ3JhbVBhZ2UucHJvdG90eXBlLnNldE5hbWU9ZnVuY3Rpb24oYSl7bnVsbD09YT90aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKCJuYW1lIik6dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgibmFtZSIsYSl9O2Z1bmN0aW9uIFJlbmFtZVBhZ2UoYSxjLGYpe3RoaXMudWk9YTt0aGlzLnBhZ2U9Yzt0aGlzLnByZXZpb3VzPXRoaXMubmFtZT1mfVJlbmFtZVBhZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBhZ2UuZ2V0TmFtZSgpO3RoaXMucGFnZS5zZXROYW1lKHRoaXMucHJldmlvdXMpO3RoaXMubmFtZT10aGlzLnByZXZpb3VzO3RoaXMucHJldmlvdXM9YTt0aGlzLnVpLmVkaXRvci5ncmFwaC51cGRhdGVQbGFjZWhvbGRlcnMoKTt0aGlzLnVpLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VSZW5hbWVkIikpfTsKZnVuY3Rpb24gTW92ZVBhZ2UoYSxjLGYpe3RoaXMudWk9YTt0aGlzLm9sZEluZGV4PWM7dGhpcy5uZXdJbmRleD1mfU1vdmVQYWdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dGhpcy51aS5wYWdlcy5zcGxpY2UodGhpcy5uZXdJbmRleCwwLHRoaXMudWkucGFnZXMuc3BsaWNlKHRoaXMub2xkSW5kZXgsMSlbMF0pO3ZhciBhPXRoaXMub2xkSW5kZXg7dGhpcy5vbGRJbmRleD10aGlzLm5ld0luZGV4O3RoaXMubmV3SW5kZXg9YTt0aGlzLnVpLmVkaXRvci5ncmFwaC51cGRhdGVQbGFjZWhvbGRlcnMoKTt0aGlzLnVpLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VNb3ZlZCIpKX07CmZ1bmN0aW9uIFNlbGVjdFBhZ2UoYSxjLGYpe3RoaXMudWk9YTt0aGlzLnByZXZpb3VzUGFnZT10aGlzLnBhZ2U9Yzt0aGlzLm5ldmVyU2hvd249ITA7bnVsbCE9YyYmKHRoaXMubmV2ZXJTaG93bj1udWxsPT1jLnZpZXdTdGF0ZSx0aGlzLnVpLnVwZGF0ZVBhZ2VSb290KGMpLG51bGwhPWYmJihjLnZpZXdTdGF0ZT1mLHRoaXMubmV2ZXJTaG93bj0hMSkpfQpTZWxlY3RQYWdlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5pbmRleE9mKHRoaXMudWkucGFnZXMsdGhpcy5wcmV2aW91c1BhZ2UpO2lmKG51bGwhPXRoaXMucGFnZSYmMDw9YSl7dmFyIGE9dGhpcy51aS5jdXJyZW50UGFnZSxjPXRoaXMudWkuZWRpdG9yLGY9Yy5ncmFwaCxkPUdyYXBoLmNvbXByZXNzTm9kZShjLmdldEdyYXBoWG1sKCEwKSk7bXhVdGlscy5zZXRUZXh0Q29udGVudChhLm5vZGUsZCk7YS52aWV3U3RhdGU9Zi5nZXRWaWV3U3RhdGUoKTthLnJvb3Q9Zi5tb2RlbC5yb290O251bGwhPWEubW9kZWwmJmEubW9kZWwucm9vdENoYW5nZWQoYS5yb290KTtmLnZpZXcuY2xlYXIoYS5yb290LCEwKTtmLmNsZWFyU2VsZWN0aW9uKCk7dGhpcy51aS5jdXJyZW50UGFnZT10aGlzLnByZXZpb3VzUGFnZTt0aGlzLnByZXZpb3VzUGFnZT1hO2E9dGhpcy51aS5jdXJyZW50UGFnZTtmLm1vZGVsLnByZWZpeD1FZGl0b3IuZ3VpZCgpKyItIjtmLm1vZGVsLnJvb3RDaGFuZ2VkKGEucm9vdCk7CmYuc2V0Vmlld1N0YXRlKGEudmlld1N0YXRlKTtmLmdyaWRFbmFibGVkPWYuZ3JpZEVuYWJsZWQmJighdGhpcy51aS5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpfHwiMSI9PXVybFBhcmFtcy5ncmlkKTtjLnVwZGF0ZUdyYXBoQ29tcG9uZW50cygpO2Yudmlldy52YWxpZGF0ZSgpO2YuYmxvY2tNYXRoUmVuZGVyPSEwO2Yuc2l6ZURpZENoYW5nZSgpO2YuYmxvY2tNYXRoUmVuZGVyPSExO3RoaXMubmV2ZXJTaG93biYmKHRoaXMubmV2ZXJTaG93bj0hMSxmLnNlbGVjdFVubG9ja2VkTGF5ZXIoKSk7Yy5ncmFwaC5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QobXhFdmVudC5ST09UKSk7Yy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInBhZ2VTZWxlY3RlZCIsImNoYW5nZSIsdGhpcykpfX07CmZ1bmN0aW9uIENoYW5nZVBhZ2UoYSxjLGYsZCxrKXtTZWxlY3RQYWdlLmNhbGwodGhpcyxhLGYpO3RoaXMucmVsYXRlZFBhZ2U9Yzt0aGlzLmluZGV4PWQ7dGhpcy5wcmV2aW91c0luZGV4PW51bGw7dGhpcy5ub1NlbGVjdD1rfW14VXRpbHMuZXh0ZW5kKENoYW5nZVBhZ2UsU2VsZWN0UGFnZSk7CkNoYW5nZVBhZ2UucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt0aGlzLnVpLmVkaXRvci5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImJlZm9yZVBhZ2VDaGFuZ2UiLCJjaGFuZ2UiLHRoaXMpKTt0aGlzLnByZXZpb3VzSW5kZXg9dGhpcy5pbmRleDtpZihudWxsPT10aGlzLmluZGV4KXt2YXIgYT1teFV0aWxzLmluZGV4T2YodGhpcy51aS5wYWdlcyx0aGlzLnJlbGF0ZWRQYWdlKTt0aGlzLnVpLnBhZ2VzLnNwbGljZShhLDEpO3RoaXMuaW5kZXg9YX1lbHNlIHRoaXMudWkucGFnZXMuc3BsaWNlKHRoaXMuaW5kZXgsMCx0aGlzLnJlbGF0ZWRQYWdlKSx0aGlzLmluZGV4PW51bGw7dGhpcy5ub1NlbGVjdHx8U2VsZWN0UGFnZS5wcm90b3R5cGUuZXhlY3V0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0VkaXRvclVpLnByb3RvdHlwZS50YWJDb250YWluZXJIZWlnaHQ9Mzg7CkVkaXRvclVpLnByb3RvdHlwZS5nZXRTZWxlY3RlZFBhZ2VJbmRleD1mdW5jdGlvbigpe3ZhciBhPW51bGw7aWYobnVsbCE9dGhpcy5wYWdlcyYmbnVsbCE9dGhpcy5jdXJyZW50UGFnZSlmb3IodmFyIGM9MDtjPHRoaXMucGFnZXMubGVuZ3RoO2MrKylpZih0aGlzLnBhZ2VzW2NdPT10aGlzLmN1cnJlbnRQYWdlKXthPWM7YnJlYWt9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5nZXRQYWdlQnlJZD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLnBhZ2VzKWZvcih2YXIgYz0wO2M8dGhpcy5wYWdlcy5sZW5ndGg7YysrKWlmKHRoaXMucGFnZXNbY10uZ2V0SWQoKT09YSlyZXR1cm4gdGhpcy5wYWdlc1tjXTtyZXR1cm4gbnVsbH07CkVkaXRvclVpLnByb3RvdHlwZS5pbml0UGFnZXM9ZnVuY3Rpb24oKXtpZighdGhpcy5lZGl0b3IuZ3JhcGguc3RhbmRhbG9uZSl7dGhpcy5hY3Rpb25zLmFkZEFjdGlvbigicHJldmlvdXNQYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2VsZWN0TmV4dFBhZ2UoITEpfSkpO3RoaXMuYWN0aW9ucy5hZGRBY3Rpb24oIm5leHRQYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2VsZWN0TmV4dFBhZ2UoITApfSkpO3RoaXMua2V5SGFuZGxlci5iaW5kQWN0aW9uKDMzLCEwLCJwcmV2aW91c1BhZ2UiLCEwKTt0aGlzLmtleUhhbmRsZXIuYmluZEFjdGlvbigzNCwhMCwibmV4dFBhZ2UiLCEwKTt2YXIgYT10aGlzLmVkaXRvci5ncmFwaCxjPWEudmlldy52YWxpZGF0ZUJhY2tncm91bmQ7YS52aWV3LnZhbGlkYXRlQmFja2dyb3VuZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMudGFiQ29udGFpbmVyKXt2YXIgZD10aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5oZWlnaHQ7CnRoaXMudGFiQ29udGFpbmVyLnN0eWxlLmhlaWdodD1udWxsPT10aGlzLmZpbGVOb2RlfHxudWxsPT10aGlzLnBhZ2VzfHwxPT10aGlzLnBhZ2VzLmxlbmd0aCYmIjAiPT11cmxQYXJhbXMucGFnZXM/IjBweCI6dGhpcy50YWJDb250YWluZXJIZWlnaHQrInB4IjtkIT10aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5oZWlnaHQmJnRoaXMucmVmcmVzaCghMSl9Yy5hcHBseShhLnZpZXcsYXJndW1lbnRzKX0pO3ZhciBmPW51bGwsZD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMudXBkYXRlVGFiQ29udGFpbmVyKCk7dmFyIGM9dGhpcy5jdXJyZW50UGFnZTtudWxsIT1jJiZjIT1mJiYobnVsbD09Yy52aWV3U3RhdGV8fG51bGw9PWMudmlld1N0YXRlLnNjcm9sbExlZnQ/KHRoaXMucmVzZXRTY3JvbGxiYXJzKCksYS5pc0xpZ2h0Ym94VmlldygpJiZ0aGlzLmxpZ2h0Ym94Rml0KCksbnVsbCE9dGhpcy5jaHJvbWVsZXNzUmVzaXplJiYoYS5jb250YWluZXIuc2Nyb2xsTGVmdD0wLAphLmNvbnRhaW5lci5zY3JvbGxUb3A9MCx0aGlzLmNocm9tZWxlc3NSZXNpemUoKSkpOihhLmNvbnRhaW5lci5zY3JvbGxMZWZ0PWEudmlldy50cmFuc2xhdGUueCphLnZpZXcuc2NhbGUrYy52aWV3U3RhdGUuc2Nyb2xsTGVmdCxhLmNvbnRhaW5lci5zY3JvbGxUb3A9YS52aWV3LnRyYW5zbGF0ZS55KmEudmlldy5zY2FsZStjLnZpZXdTdGF0ZS5zY3JvbGxUb3ApLGY9Yyk7bnVsbCE9dGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdyYmdGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdy5yZWZyZXNoTGF5ZXJzKCk7InVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheCYmInVuZGVmaW5lZCIhPT10eXBlb2YgTWF0aEpheC5IdWI/MSE9TWF0aEpheC5IdWIucXVldWUucGVuZGluZ3x8bnVsbD09dGhpcy5lZGl0b3J8fHRoaXMuZWRpdG9yLmdyYXBoLm1hdGhFbmFibGVkfHxNYXRoSmF4Lkh1Yi5RdWV1ZShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe251bGwhPXRoaXMuZWRpdG9yJiZ0aGlzLmVkaXRvci5ncmFwaC5yZWZyZXNoKCl9KSk6CiJ1bmRlZmluZWQiPT09dHlwZW9mIEVkaXRvci5NYXRoSmF4Q2xlYXJ8fG51bGwhPXRoaXMuZWRpdG9yJiZ0aGlzLmVkaXRvci5ncmFwaC5tYXRoRW5hYmxlZHx8RWRpdG9yLk1hdGhKYXhDbGVhcigpfSk7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuYWRkTGlzdGVuZXIobXhFdmVudC5DSEFOR0UsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtmb3IodmFyIGY9Yy5nZXRQcm9wZXJ0eSgiZWRpdCIpLmNoYW5nZXMsYj0wO2I8Zi5sZW5ndGg7YisrKWlmKGZbYl1pbnN0YW5jZW9mIFNlbGVjdFBhZ2V8fGZbYl1pbnN0YW5jZW9mIFJlbmFtZVBhZ2V8fGZbYl1pbnN0YW5jZW9mIE1vdmVQYWdlfHxmW2JdaW5zdGFuY2VvZiBteFJvb3RDaGFuZ2Upe2QoKTticmVha319KSk7bnVsbCE9dGhpcy50b29sYmFyJiZ0aGlzLmVkaXRvci5hZGRMaXN0ZW5lcigicGFnZVNlbGVjdGVkIix0aGlzLnRvb2xiYXIudXBkYXRlWm9vbSl9fTsKRWRpdG9yVWkucHJvdG90eXBlLnJlc3RvcmVWaWV3U3RhdGU9ZnVuY3Rpb24oYSxjLGYpe2E9bnVsbCE9YT90aGlzLmdldFBhZ2VCeUlkKGEuZ2V0SWQoKSk6bnVsbDt2YXIgZD10aGlzLmVkaXRvci5ncmFwaDtudWxsIT1hJiZudWxsIT10aGlzLmN1cnJlbnRQYWdlJiZudWxsIT10aGlzLnBhZ2VzJiYoYSE9dGhpcy5jdXJyZW50UGFnZT90aGlzLnNlbGVjdFBhZ2UoYSwhMCxjKTooZC5zZXRWaWV3U3RhdGUoYyksdGhpcy5lZGl0b3IudXBkYXRlR3JhcGhDb21wb25lbnRzKCksZC52aWV3LnJldmFsaWRhdGUoKSxkLnNpemVEaWRDaGFuZ2UoKSksZC5jb250YWluZXIuc2Nyb2xsTGVmdD1kLnZpZXcudHJhbnNsYXRlLngqZC52aWV3LnNjYWxlK2Muc2Nyb2xsTGVmdCxkLmNvbnRhaW5lci5zY3JvbGxUb3A9ZC52aWV3LnRyYW5zbGF0ZS55KmQudmlldy5zY2FsZStjLnNjcm9sbFRvcCxkLnJlc3RvcmVTZWxlY3Rpb24oZikpfTsKR3JhcGgucHJvdG90eXBlLmNyZWF0ZVZpZXdTdGF0ZT1mdW5jdGlvbihhKXt2YXIgYz1hLmdldEF0dHJpYnV0ZSgicGFnZSIpLGY9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZVNjYWxlIikpLGQ9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZVdpZHRoIikpLGs9cGFyc2VGbG9hdChhLmdldEF0dHJpYnV0ZSgicGFnZUhlaWdodCIpKSxtPWEuZ2V0QXR0cmlidXRlKCJiYWNrZ3JvdW5kIikscT1hLmdldEF0dHJpYnV0ZSgiYmFja2dyb3VuZEltYWdlIikscT1udWxsIT1xJiYwPHEubGVuZ3RoP0pTT04ucGFyc2UocSk6bnVsbCxiPWEuZ2V0QXR0cmlidXRlKCJleHRGb250cyIpO2lmKGIpdHJ5e2I9Yi5zcGxpdCgifCIpLm1hcChmdW5jdGlvbihhKXthPWEuc3BsaXQoIl4iKTtyZXR1cm57bmFtZTphWzBdLHVybDphWzFdfX0pfWNhdGNoKGUpe2NvbnNvbGUubG9nKCJFeHRGb250cyBmb3JtYXQgZXJyb3I6ICIrZS5tZXNzYWdlKX1yZXR1cm57Z3JpZEVuYWJsZWQ6IjAiIT0KYS5nZXRBdHRyaWJ1dGUoImdyaWQiKSxncmlkU2l6ZTpwYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCJncmlkU2l6ZSIpKXx8bXhHcmFwaC5wcm90b3R5cGUuZ3JpZFNpemUsZ3VpZGVzRW5hYmxlZDoiMCIhPWEuZ2V0QXR0cmlidXRlKCJndWlkZXMiKSxmb2xkaW5nRW5hYmxlZDoiMCIhPWEuZ2V0QXR0cmlidXRlKCJmb2xkIiksc2hhZG93VmlzaWJsZToiMSI9PWEuZ2V0QXR0cmlidXRlKCJzaGFkb3ciKSxwYWdlVmlzaWJsZTp0aGlzLmlzTGlnaHRib3hWaWV3KCk/ITE6bnVsbCE9Yz8iMCIhPWM6dGhpcy5kZWZhdWx0UGFnZVZpc2libGUsYmFja2dyb3VuZDpudWxsIT1tJiYwPG0ubGVuZ3RoP206bnVsbCxiYWNrZ3JvdW5kSW1hZ2U6bnVsbCE9cT9uZXcgbXhJbWFnZShxLnNyYyxxLndpZHRoLHEuaGVpZ2h0KTpudWxsLHBhZ2VTY2FsZTppc05hTihmKT9teEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGU6ZixwYWdlRm9ybWF0OmlzTmFOKGQpfHxpc05hTihrKT8idW5kZWZpbmVkIj09PQp0eXBlb2YgbXhTZXR0aW5ncz9teEdyYXBoLnByb3RvdHlwZS5wYWdlRm9ybWF0Om14U2V0dGluZ3MuZ2V0UGFnZUZvcm1hdCgpOm5ldyBteFJlY3RhbmdsZSgwLDAsZCxrKSx0b29sdGlwczoiMCIhPWEuZ2V0QXR0cmlidXRlKCJ0b29sdGlwcyIpLGNvbm5lY3Q6IjAiIT1hLmdldEF0dHJpYnV0ZSgiY29ubmVjdCIpLGFycm93czoiMCIhPWEuZ2V0QXR0cmlidXRlKCJhcnJvd3MiKSxtYXRoRW5hYmxlZDoiMSI9PWEuZ2V0QXR0cmlidXRlKCJtYXRoIiksc2VsZWN0aW9uQ2VsbHM6bnVsbCxkZWZhdWx0UGFyZW50Om51bGwsc2Nyb2xsYmFyczp0aGlzLmRlZmF1bHRTY3JvbGxiYXJzLHNjYWxlOjEsZXh0Rm9udHM6Ynx8W119fTsKR3JhcGgucHJvdG90eXBlLnNhdmVWaWV3U3RhdGU9ZnVuY3Rpb24oYSxjLGYpe2Z8fChjLnNldEF0dHJpYnV0ZSgiZ3JpZCIsbnVsbD09YXx8YS5ncmlkRW5hYmxlZD8iMSI6IjAiKSxjLnNldEF0dHJpYnV0ZSgiZ3JpZFNpemUiLG51bGwhPWE/YS5ncmlkU2l6ZTpteEdyYXBoLnByb3RvdHlwZS5ncmlkU2l6ZSksYy5zZXRBdHRyaWJ1dGUoImd1aWRlcyIsbnVsbD09YXx8YS5ndWlkZXNFbmFibGVkPyIxIjoiMCIpLGMuc2V0QXR0cmlidXRlKCJ0b29sdGlwcyIsbnVsbD09YXx8YS50b29sdGlwcz8iMSI6IjAiKSxjLnNldEF0dHJpYnV0ZSgiY29ubmVjdCIsbnVsbD09YXx8YS5jb25uZWN0PyIxIjoiMCIpLGMuc2V0QXR0cmlidXRlKCJhcnJvd3MiLG51bGw9PWF8fGEuYXJyb3dzPyIxIjoiMCIpLGMuc2V0QXR0cmlidXRlKCJwYWdlIixudWxsPT1hJiZ0aGlzLmRlZmF1bHRQYWdlVmlzaWJsZXx8bnVsbCE9YSYmYS5wYWdlVmlzaWJsZT8iMSI6IjAiKSxjLnNldEF0dHJpYnV0ZSgiZm9sZCIsCm51bGw9PWF8fGEuZm9sZGluZ0VuYWJsZWQ/IjEiOiIwIikpO2Muc2V0QXR0cmlidXRlKCJwYWdlU2NhbGUiLG51bGwhPWEmJm51bGwhPWEucGFnZVNjYWxlP2EucGFnZVNjYWxlOm14R3JhcGgucHJvdG90eXBlLnBhZ2VTY2FsZSk7Zj1udWxsIT1hP2EucGFnZUZvcm1hdDoidW5kZWZpbmVkIj09PXR5cGVvZiBteFNldHRpbmdzP214R3JhcGgucHJvdG90eXBlLnBhZ2VGb3JtYXQ6bXhTZXR0aW5ncy5nZXRQYWdlRm9ybWF0KCk7bnVsbCE9ZiYmKGMuc2V0QXR0cmlidXRlKCJwYWdlV2lkdGgiLGYud2lkdGgpLGMuc2V0QXR0cmlidXRlKCJwYWdlSGVpZ2h0IixmLmhlaWdodCkpO251bGwhPWEmJm51bGwhPWEuYmFja2dyb3VuZCYmYy5zZXRBdHRyaWJ1dGUoImJhY2tncm91bmQiLGEuYmFja2dyb3VuZCk7bnVsbCE9YSYmbnVsbCE9YS5iYWNrZ3JvdW5kSW1hZ2UmJmMuc2V0QXR0cmlidXRlKCJiYWNrZ3JvdW5kSW1hZ2UiLEpTT04uc3RyaW5naWZ5KGEuYmFja2dyb3VuZEltYWdlKSk7Yy5zZXRBdHRyaWJ1dGUoIm1hdGgiLApudWxsIT1hJiZhLm1hdGhFbmFibGVkPyIxIjoiMCIpO2Muc2V0QXR0cmlidXRlKCJzaGFkb3ciLG51bGwhPWEmJmEuc2hhZG93VmlzaWJsZT8iMSI6IjAiKTtudWxsIT1hJiZudWxsIT1hLmV4dEZvbnRzJiYwPGEuZXh0Rm9udHMubGVuZ3RoJiZjLnNldEF0dHJpYnV0ZSgiZXh0Rm9udHMiLGEuZXh0Rm9udHMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWUrIl4iK2EudXJsfSkuam9pbigifCIpKX07CkdyYXBoLnByb3RvdHlwZS5nZXRWaWV3U3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm57ZGVmYXVsdFBhcmVudDp0aGlzLmRlZmF1bHRQYXJlbnQsY3VycmVudFJvb3Q6dGhpcy52aWV3LmN1cnJlbnRSb290LGdyaWRFbmFibGVkOnRoaXMuZ3JpZEVuYWJsZWQsZ3JpZFNpemU6dGhpcy5ncmlkU2l6ZSxndWlkZXNFbmFibGVkOnRoaXMuZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWQsZm9sZGluZ0VuYWJsZWQ6dGhpcy5mb2xkaW5nRW5hYmxlZCxzaGFkb3dWaXNpYmxlOnRoaXMuc2hhZG93VmlzaWJsZSxzY3JvbGxiYXJzOnRoaXMuc2Nyb2xsYmFycyxwYWdlVmlzaWJsZTp0aGlzLnBhZ2VWaXNpYmxlLGJhY2tncm91bmQ6dGhpcy5iYWNrZ3JvdW5kLGJhY2tncm91bmRJbWFnZTp0aGlzLmJhY2tncm91bmRJbWFnZSxwYWdlU2NhbGU6dGhpcy5wYWdlU2NhbGUscGFnZUZvcm1hdDp0aGlzLnBhZ2VGb3JtYXQsdG9vbHRpcHM6dGhpcy50b29sdGlwSGFuZGxlci5pc0VuYWJsZWQoKSxjb25uZWN0OnRoaXMuY29ubmVjdGlvbkhhbmRsZXIuaXNFbmFibGVkKCksCmFycm93czp0aGlzLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkLHNjYWxlOnRoaXMudmlldy5zY2FsZSxzY3JvbGxMZWZ0OnRoaXMuY29udGFpbmVyLnNjcm9sbExlZnQtdGhpcy52aWV3LnRyYW5zbGF0ZS54KnRoaXMudmlldy5zY2FsZSxzY3JvbGxUb3A6dGhpcy5jb250YWluZXIuc2Nyb2xsVG9wLXRoaXMudmlldy50cmFuc2xhdGUueSp0aGlzLnZpZXcuc2NhbGUsdHJhbnNsYXRlOnRoaXMudmlldy50cmFuc2xhdGUuY2xvbmUoKSxsYXN0UGFzdGVYbWw6dGhpcy5sYXN0UGFzdGVYbWwscGFzdGVDb3VudGVyOnRoaXMucGFzdGVDb3VudGVyLG1hdGhFbmFibGVkOnRoaXMubWF0aEVuYWJsZWQsZXh0Rm9udHM6dGhpcy5leHRGb250c319OwpHcmFwaC5wcm90b3R5cGUuc2V0Vmlld1N0YXRlPWZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9YSl7dGhpcy5sYXN0UGFzdGVYbWw9YS5sYXN0UGFzdGVYbWw7dGhpcy5wYXN0ZUNvdW50ZXI9YS5wYXN0ZUNvdW50ZXJ8fDA7dGhpcy5tYXRoRW5hYmxlZD1hLm1hdGhFbmFibGVkO3RoaXMuZ3JpZEVuYWJsZWQ9YS5ncmlkRW5hYmxlZDt0aGlzLmdyaWRTaXplPWEuZ3JpZFNpemU7dGhpcy5ncmFwaEhhbmRsZXIuZ3VpZGVzRW5hYmxlZD1hLmd1aWRlc0VuYWJsZWQ7dGhpcy5mb2xkaW5nRW5hYmxlZD1hLmZvbGRpbmdFbmFibGVkO3RoaXMuc2V0U2hhZG93VmlzaWJsZShhLnNoYWRvd1Zpc2libGUsITEpO3RoaXMuc2Nyb2xsYmFycz1hLnNjcm9sbGJhcnM7dGhpcy5wYWdlVmlzaWJsZT0hdGhpcy5pc1ZpZXdlcigpJiZhLnBhZ2VWaXNpYmxlO3RoaXMuYmFja2dyb3VuZD1hLmJhY2tncm91bmQ7dGhpcy5iYWNrZ3JvdW5kSW1hZ2U9YS5iYWNrZ3JvdW5kSW1hZ2U7dGhpcy5wYWdlU2NhbGU9YS5wYWdlU2NhbGU7CnRoaXMucGFnZUZvcm1hdD1hLnBhZ2VGb3JtYXQ7dGhpcy52aWV3LmN1cnJlbnRSb290PWEuY3VycmVudFJvb3Q7dGhpcy5kZWZhdWx0UGFyZW50PWEuZGVmYXVsdFBhcmVudDt0aGlzLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkPWEuYXJyb3dzO3RoaXMuc2V0VG9vbHRpcHMoYS50b29sdGlwcyk7dGhpcy5zZXRDb25uZWN0YWJsZShhLmNvbm5lY3QpO3ZhciBmPXRoaXMuZXh0Rm9udHM7dGhpcy5leHRGb250cz1hLmV4dEZvbnRzfHxbXTtpZihjJiZudWxsIT1mKWZvcih2YXIgZD0wO2Q8Zi5sZW5ndGg7ZCsrKXt2YXIgaz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZXh0Rm9udF8iK2ZbZF0ubmFtZSk7bnVsbCE9ayYmay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGspfWZvcihkPTA7ZDx0aGlzLmV4dEZvbnRzLmxlbmd0aDtkKyspdGhpcy5hZGRFeHRGb250KHRoaXMuZXh0Rm9udHNbZF0ubmFtZSx0aGlzLmV4dEZvbnRzW2RdLnVybCwhMCk7dGhpcy52aWV3LnNjYWxlPW51bGwhPWEuc2NhbGU/CmEuc2NhbGU6MTtudWxsPT10aGlzLnZpZXcuY3VycmVudFJvb3R8fHRoaXMubW9kZWwuY29udGFpbnModGhpcy52aWV3LmN1cnJlbnRSb290KXx8KHRoaXMudmlldy5jdXJyZW50Um9vdD1udWxsKTtudWxsPT10aGlzLmRlZmF1bHRQYXJlbnR8fHRoaXMubW9kZWwuY29udGFpbnModGhpcy5kZWZhdWx0UGFyZW50KXx8KHRoaXMuc2V0RGVmYXVsdFBhcmVudChudWxsKSx0aGlzLnNlbGVjdFVubG9ja2VkTGF5ZXIoKSk7bnVsbCE9YS50cmFuc2xhdGUmJih0aGlzLnZpZXcudHJhbnNsYXRlPWEudHJhbnNsYXRlKX1lbHNlIHRoaXMudmlldy5jdXJyZW50Um9vdD1udWxsLHRoaXMudmlldy5zY2FsZT0xLHRoaXMuZ3JpZEVuYWJsZWQ9ITAsdGhpcy5ncmlkU2l6ZT1teEdyYXBoLnByb3RvdHlwZS5ncmlkU2l6ZSx0aGlzLnBhZ2VTY2FsZT1teEdyYXBoLnByb3RvdHlwZS5wYWdlU2NhbGUsdGhpcy5wYWdlRm9ybWF0PSJ1bmRlZmluZWQiPT09dHlwZW9mIG14U2V0dGluZ3M/bXhHcmFwaC5wcm90b3R5cGUucGFnZUZvcm1hdDoKbXhTZXR0aW5ncy5nZXRQYWdlRm9ybWF0KCksdGhpcy5wYWdlVmlzaWJsZT10aGlzLmRlZmF1bHRQYWdlVmlzaWJsZSx0aGlzLmJhY2tncm91bmRJbWFnZT10aGlzLmJhY2tncm91bmQ9bnVsbCx0aGlzLnNjcm9sbGJhcnM9dGhpcy5kZWZhdWx0U2Nyb2xsYmFycyx0aGlzLmZvbGRpbmdFbmFibGVkPXRoaXMuZ3JhcGhIYW5kbGVyLmd1aWRlc0VuYWJsZWQ9ITAsdGhpcy5zZXRTaGFkb3dWaXNpYmxlKCExLCExKSx0aGlzLmRlZmF1bHRQYXJlbnQ9bnVsbCx0aGlzLnNldFRvb2x0aXBzKCEwKSx0aGlzLnNldENvbm5lY3RhYmxlKCEwKSx0aGlzLmxhc3RQYXN0ZVhtbD1udWxsLHRoaXMucGFzdGVDb3VudGVyPTAsdGhpcy5tYXRoRW5hYmxlZD0hMSx0aGlzLmNvbm5lY3Rpb25BcnJvd3NFbmFibGVkPSEwLHRoaXMuZXh0Rm9udHM9W107dGhpcy5wcmVmZXJQYWdlU2l6ZT10aGlzLnBhZ2VCcmVha3NWaXNpYmxlPXRoaXMucGFnZVZpc2libGU7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoInZpZXdTdGF0ZUNoYW5nZWQiLAoic3RhdGUiLGEpKX07CkdyYXBoLnByb3RvdHlwZS5hZGRFeHRGb250PWZ1bmN0aW9uKGEsYyxmKXtpZihhJiZjKXt2YXIgZD0iZXh0Rm9udF8iK2E7aWYobnVsbD09ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZCkpaWYoMD09Yy5pbmRleE9mKEVkaXRvci5HT09HTEVfRk9OVFMpKW14Q2xpZW50LmxpbmsoInN0eWxlc2hlZXQiLGMsbnVsbCxkKTtlbHNle2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIik7dmFyIGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3R5bGUiKTtrLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdAZm9udC1mYWNlIHtcblx0Zm9udC1mYW1pbHk6ICInK2ErJyI7XG5cdHNyYzogdXJsKCInK2MrJyIpO1xufScpKTtrLnNldEF0dHJpYnV0ZSgiaWQiLGQpO2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQoayl9aWYoIWYpe251bGw9PXRoaXMuZXh0Rm9udHMmJih0aGlzLmV4dEZvbnRzPVtdKTtmPXRoaXMuZXh0Rm9udHM7CmQ9ITA7Zm9yKGs9MDtrPGYubGVuZ3RoO2srKylpZihmW2tdLm5hbWU9PWEpe2Q9ITE7YnJlYWt9ZCYmdGhpcy5leHRGb250cy5wdXNoKHtuYW1lOmEsdXJsOmN9KX19fTsKRWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZVBhZ2VSb290PWZ1bmN0aW9uKGEsYyl7aWYobnVsbD09YS5yb290KXt2YXIgZj10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChhLm5vZGUsbnVsbCxjKSxkPUVkaXRvci5leHRyYWN0UGFyc2VyRXJyb3IoZik7aWYoZCl0aHJvdyBFcnJvcihkKTtudWxsIT1mPyhhLmdyYXBoTW9kZWxOb2RlPWYsYS52aWV3U3RhdGU9dGhpcy5lZGl0b3IuZ3JhcGguY3JlYXRlVmlld1N0YXRlKGYpLGQ9bmV3IG14Q29kZWMoZi5vd25lckRvY3VtZW50KSxhLnJvb3Q9ZC5kZWNvZGUoZikucm9vdCk6YS5yb290PXRoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNyZWF0ZVJvb3QoKX1lbHNlIGlmKG51bGw9PWEudmlld1N0YXRlKXtpZihudWxsPT1hLmdyYXBoTW9kZWxOb2RlKXtmPXRoaXMuZWRpdG9yLmV4dHJhY3RHcmFwaE1vZGVsKGEubm9kZSk7aWYoZD1FZGl0b3IuZXh0cmFjdFBhcnNlckVycm9yKGYpKXRocm93IEVycm9yKGQpO251bGwhPWYmJihhLmdyYXBoTW9kZWxOb2RlPQpmKX1udWxsIT1hLmdyYXBoTW9kZWxOb2RlJiYoYS52aWV3U3RhdGU9dGhpcy5lZGl0b3IuZ3JhcGguY3JlYXRlVmlld1N0YXRlKGEuZ3JhcGhNb2RlbE5vZGUpKX1yZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS5zZWxlY3RQYWdlPWZ1bmN0aW9uKGEsYyxmKXt0cnl7aWYoYSE9dGhpcy5jdXJyZW50UGFnZSl7dGhpcy5lZGl0b3IuZ3JhcGguaXNFZGl0aW5nKCkmJnRoaXMuZWRpdG9yLmdyYXBoLnN0b3BFZGl0aW5nKCExKTtjPW51bGwhPWM/YzohMTt0aGlzLmVkaXRvci5ncmFwaC5pc01vdXNlRG93bj0hMTt0aGlzLmVkaXRvci5ncmFwaC5yZXNldCgpO3ZhciBkPXRoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmNyZWF0ZVVuZG9hYmxlRWRpdCgpO2QuaWdub3JlRWRpdD0hMDt2YXIgaz1uZXcgU2VsZWN0UGFnZSh0aGlzLGEsZik7ay5leGVjdXRlKCk7ZC5hZGQoayk7ZC5ub3RpZnkoKTt0aGlzLmVkaXRvci5ncmFwaC50b29sdGlwSGFuZGxlci5oaWRlKCk7Y3x8dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KG14RXZlbnQuVU5ETywiZWRpdCIsZCkpfX1jYXRjaChtKXt0aGlzLmhhbmRsZUVycm9yKG0pfX07CkVkaXRvclVpLnByb3RvdHlwZS5zZWxlY3ROZXh0UGFnZT1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmN1cnJlbnRQYWdlO251bGwhPWMmJm51bGwhPXRoaXMucGFnZXMmJihjPW14VXRpbHMuaW5kZXhPZih0aGlzLnBhZ2VzLGMpLGE/dGhpcy5zZWxlY3RQYWdlKHRoaXMucGFnZXNbbXhVdGlscy5tb2QoYysxLHRoaXMucGFnZXMubGVuZ3RoKV0pOmF8fHRoaXMuc2VsZWN0UGFnZSh0aGlzLnBhZ2VzW214VXRpbHMubW9kKGMtMSx0aGlzLnBhZ2VzLmxlbmd0aCldKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuaW5zZXJ0UGFnZT1mdW5jdGlvbihhLGMpe2lmKHRoaXMuZWRpdG9yLmdyYXBoLmlzRW5hYmxlZCgpKXt0aGlzLmVkaXRvci5ncmFwaC5pc0VkaXRpbmcoKSYmdGhpcy5lZGl0b3IuZ3JhcGguc3RvcEVkaXRpbmcoITEpO2E9bnVsbCE9YT9hOnRoaXMuY3JlYXRlUGFnZShudWxsLHRoaXMuY3JlYXRlUGFnZUlkKCkpO2M9bnVsbCE9Yz9jOnRoaXMucGFnZXMubGVuZ3RoO3ZhciBmPW5ldyBDaGFuZ2VQYWdlKHRoaXMsYSxhLGMpO3RoaXMuZWRpdG9yLmdyYXBoLm1vZGVsLmV4ZWN1dGUoZil9cmV0dXJuIGF9O0VkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVQYWdlSWQ9ZnVuY3Rpb24oKXt2YXIgYTtkbyBhPUVkaXRvci5ndWlkKCk7d2hpbGUobnVsbCE9dGhpcy5nZXRQYWdlQnlJZChhKSk7cmV0dXJuIGF9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlUGFnZT1mdW5jdGlvbihhLGMpe3ZhciBmPW5ldyBEaWFncmFtUGFnZSh0aGlzLmZpbGVOb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGlhZ3JhbSIpLGMpO2Yuc2V0TmFtZShudWxsIT1hP2E6dGhpcy5jcmVhdGVQYWdlTmFtZSgpKTtyZXR1cm4gZn07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVBhZ2VOYW1lPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXt9LGM9MDtjPHRoaXMucGFnZXMubGVuZ3RoO2MrKyl7dmFyIGY9dGhpcy5wYWdlc1tjXS5nZXROYW1lKCk7bnVsbCE9ZiYmMDxmLmxlbmd0aCYmKGFbZl09Zil9Yz10aGlzLnBhZ2VzLmxlbmd0aDtkbyBmPW14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFsrK2NdKTt3aGlsZShudWxsIT1hW2ZdKTtyZXR1cm4gZn07CkVkaXRvclVpLnByb3RvdHlwZS5yZW1vdmVQYWdlPWZ1bmN0aW9uKGEpe3RyeXt2YXIgYz10aGlzLmVkaXRvci5ncmFwaCxmPW14VXRpbHMuaW5kZXhPZih0aGlzLnBhZ2VzLGEpO2lmKGMuaXNFbmFibGVkKCkmJjA8PWYpe3RoaXMuZWRpdG9yLmdyYXBoLmlzRWRpdGluZygpJiZ0aGlzLmVkaXRvci5ncmFwaC5zdG9wRWRpdGluZyghMSk7Yy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD10aGlzLmN1cnJlbnRQYWdlO2Q9PWEmJjE8dGhpcy5wYWdlcy5sZW5ndGg/KGY9PXRoaXMucGFnZXMubGVuZ3RoLTE/Zi0tOmYrKyxkPXRoaXMucGFnZXNbZl0pOjE+PXRoaXMucGFnZXMubGVuZ3RoJiYoZD10aGlzLmluc2VydFBhZ2UoKSxjLm1vZGVsLmV4ZWN1dGUobmV3IFJlbmFtZVBhZ2UodGhpcyxkLG14UmVzb3VyY2VzLmdldCgicGFnZVdpdGhOdW1iZXIiLFsxXSkpKSk7Yy5tb2RlbC5leGVjdXRlKG5ldyBDaGFuZ2VQYWdlKHRoaXMsYSxkKSl9ZmluYWxseXtjLm1vZGVsLmVuZFVwZGF0ZSgpfX19Y2F0Y2goayl7dGhpcy5oYW5kbGVFcnJvcihrKX1yZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS5kdXBsaWNhdGVQYWdlPWZ1bmN0aW9uKGEsYyl7dmFyIGY9bnVsbDt0cnl7dmFyIGQ9dGhpcy5lZGl0b3IuZ3JhcGg7aWYoZC5pc0VuYWJsZWQoKSl7ZC5pc0VkaXRpbmcoKSYmZC5zdG9wRWRpdGluZygpO3ZhciBrPWEubm9kZS5jbG9uZU5vZGUoITEpO2sucmVtb3ZlQXR0cmlidXRlKCJpZCIpO2Y9bmV3IERpYWdyYW1QYWdlKGspO2Yucm9vdD1kLmNsb25lQ2VsbChkLm1vZGVsLnJvb3QpO2Yudmlld1N0YXRlPWQuZ2V0Vmlld1N0YXRlKCk7Zi52aWV3U3RhdGUuc2NhbGU9MTtmLnZpZXdTdGF0ZS5zY3JvbGxMZWZ0PW51bGw7Zi52aWV3U3RhdGUuc2Nyb2xsVG9wPW51bGw7Zi52aWV3U3RhdGUuY3VycmVudFJvb3Q9bnVsbDtmLnZpZXdTdGF0ZS5kZWZhdWx0UGFyZW50PW51bGw7Zi5zZXROYW1lKGMpO2Y9dGhpcy5pbnNlcnRQYWdlKGYsbXhVdGlscy5pbmRleE9mKHRoaXMucGFnZXMsYSkrMSl9fWNhdGNoKG0pe3RoaXMuaGFuZGxlRXJyb3IobSl9cmV0dXJuIGZ9OwpFZGl0b3JVaS5wcm90b3R5cGUucmVuYW1lUGFnZT1mdW5jdGlvbihhKXtpZih0aGlzLmVkaXRvci5ncmFwaC5pc0VuYWJsZWQoKSl7dmFyIGM9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMsYS5nZXROYW1lKCksbXhSZXNvdXJjZXMuZ2V0KCJyZW5hbWUiKSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXtudWxsIT1jJiYwPGMubGVuZ3RoJiZ0aGlzLmVkaXRvci5ncmFwaC5tb2RlbC5leGVjdXRlKG5ldyBSZW5hbWVQYWdlKHRoaXMsYSxjKSl9KSxteFJlc291cmNlcy5nZXQoInJlbmFtZSIpKTt0aGlzLnNob3dEaWFsb2coYy5jb250YWluZXIsMzAwLDgwLCEwLCEwKTtjLmluaXQoKX1yZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLm1vdmVQYWdlPWZ1bmN0aW9uKGEsYyl7dGhpcy5lZGl0b3IuZ3JhcGgubW9kZWwuZXhlY3V0ZShuZXcgTW92ZVBhZ2UodGhpcyxhLGMpKX07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVUYWJDb250YWluZXI9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTthLmNsYXNzTmFtZT0iZ2VUYWJDb250YWluZXIiO2Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjthLnN0eWxlLndoaXRlU3BhY2U9Im5vd3JhcCI7YS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjthLnN0eWxlLmhlaWdodD0iMHB4IjtyZXR1cm4gYX07CkVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVUYWJDb250YWluZXI9ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnRhYkNvbnRhaW5lciYmbnVsbCE9dGhpcy5wYWdlcyl7dmFyIGE9dGhpcy5lZGl0b3IuZ3JhcGgsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7Yy5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIjtjLnN0eWxlLnZlcnRpY2FsQWxpZ249InRvcCI7Yy5zdHlsZS5oZWlnaHQ9dGhpcy50YWJDb250YWluZXIuc3R5bGUuaGVpZ2h0O2Muc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtjLnN0eWxlLm92ZXJmbG93PSJoaWRkZW4iO2Muc3R5bGUuZm9udFNpemU9IjEzcHgiO2Muc3R5bGUubWFyZ2luTGVmdD0iMzBweCI7Zm9yKHZhciBmPXRoaXMuZWRpdG9yLmlzQ2hyb21lbGVzc1ZpZXcoKT8yOTo1OSxkPU1hdGgubWluKDE0MCxNYXRoLm1heCgyMCwodGhpcy50YWJDb250YWluZXIuY2xpZW50V2lkdGgtCmYpL3RoaXMucGFnZXMubGVuZ3RoKSsxKSxrPW51bGwsbT0wO208dGhpcy5wYWdlcy5sZW5ndGg7bSsrKW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIsZCl7dGhpcy5wYWdlc1tiXT09dGhpcy5jdXJyZW50UGFnZT8oZC5jbGFzc05hbWU9ImdlQWN0aXZlUGFnZSIsZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ImRhcmsiPT11aVRoZW1lPyIjMmEyYTJhIjoiI2ZmZiIpOmQuY2xhc3NOYW1lPSJnZUluYWN0aXZlUGFnZSI7ZC5zZXRBdHRyaWJ1dGUoImRyYWdnYWJsZSIsInRydWUiKTtteEV2ZW50LmFkZExpc3RlbmVyKGQsImRyYWdzdGFydCIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7YS5pc0VuYWJsZWQoKT8obXhDbGllbnQuSVNfRkYmJmMuZGF0YVRyYW5zZmVyLnNldERhdGEoIlRleHQiLCI8ZGlhZ3JhbS8+Iiksaz1iKTpteEV2ZW50LmNvbnN1bWUoYyl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJkcmFnZW5kIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtrPQpudWxsO2Euc3RvcFByb3BhZ2F0aW9uKCk7YS5wcmV2ZW50RGVmYXVsdCgpfSkpO214RXZlbnQuYWRkTGlzdGVuZXIoZCwiZHJhZ292ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWsmJihhLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0PSJtb3ZlIik7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJkcm9wIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1rJiZiIT1rJiZ0aGlzLm1vdmVQYWdlKGssYik7YS5zdG9wUHJvcGFnYXRpb24oKTthLnByZXZlbnREZWZhdWx0KCl9KSk7Yy5hcHBlbmRDaGlsZChkKX0pKG0sdGhpcy5jcmVhdGVUYWJGb3JQYWdlKHRoaXMucGFnZXNbbV0sZCx0aGlzLnBhZ2VzW21dIT10aGlzLmN1cnJlbnRQYWdlLG0rMSkpO3RoaXMudGFiQ29udGFpbmVyLmlubmVySFRNTD0iIjt0aGlzLnRhYkNvbnRhaW5lci5hcHBlbmRDaGlsZChjKTtkPXRoaXMuY3JlYXRlUGFnZU1lbnVUYWIoKTsKdGhpcy50YWJDb250YWluZXIuYXBwZW5kQ2hpbGQoZCk7ZD1udWxsO3RoaXMuaXNQYWdlSW5zZXJ0VGFiVmlzaWJsZSgpJiYoZD10aGlzLmNyZWF0ZVBhZ2VJbnNlcnRUYWIoKSx0aGlzLnRhYkNvbnRhaW5lci5hcHBlbmRDaGlsZChkKSk7aWYoYy5jbGllbnRXaWR0aD50aGlzLnRhYkNvbnRhaW5lci5jbGllbnRXaWR0aC1mKXtudWxsIT1kJiYoZC5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGQuc3R5bGUucmlnaHQ9IjBweCIsYy5zdHlsZS5tYXJnaW5SaWdodD0iMzBweCIpO3ZhciBxPXRoaXMuY3JlYXRlQ29udHJvbFRhYig0LCImbmJzcDsmIzEwMDk0OyZuYnNwOyIpO3Euc3R5bGUucG9zaXRpb249ImFic29sdXRlIjtxLnN0eWxlLnJpZ2h0PXRoaXMuZWRpdG9yLmNocm9tZWxlc3M/IjI5cHgiOiI1NXB4IjtxLnN0eWxlLmZvbnRTaXplPSIxM3B0Ijt0aGlzLnRhYkNvbnRhaW5lci5hcHBlbmRDaGlsZChxKTt2YXIgYj10aGlzLmNyZWF0ZUNvbnRyb2xUYWIoNCwiJm5ic3A7JiMxMDA5NTsiKTsKYi5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2Iuc3R5bGUucmlnaHQ9dGhpcy5lZGl0b3IuY2hyb21lbGVzcz8iMHB4IjoiMjlweCI7Yi5zdHlsZS5mb250U2l6ZT0iMTNwdCI7dGhpcy50YWJDb250YWluZXIuYXBwZW5kQ2hpbGQoYik7dmFyIGU9TWF0aC5tYXgoMCx0aGlzLnRhYkNvbnRhaW5lci5jbGllbnRXaWR0aC0odGhpcy5lZGl0b3IuY2hyb21lbGVzcz84NjoxMTYpKTtjLnN0eWxlLndpZHRoPWUrInB4IjtteEV2ZW50LmFkZExpc3RlbmVyKHEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtjLnNjcm9sbExlZnQtPU1hdGgubWF4KDIwLGUtMjApO214VXRpbHMuc2V0T3BhY2l0eShxLDA8Yy5zY3JvbGxMZWZ0PzEwMDo1MCk7bXhVdGlscy5zZXRPcGFjaXR5KGIsYy5zY3JvbGxMZWZ0PGMuc2Nyb2xsV2lkdGgtYy5jbGllbnRXaWR0aD8xMDA6NTApO214RXZlbnQuY29uc3VtZShhKX0pKTtteFV0aWxzLnNldE9wYWNpdHkocSwwPGMuc2Nyb2xsTGVmdD8xMDA6CjUwKTtteFV0aWxzLnNldE9wYWNpdHkoYixjLnNjcm9sbExlZnQ8Yy5zY3JvbGxXaWR0aC1jLmNsaWVudFdpZHRoPzEwMDo1MCk7bXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yy5zY3JvbGxMZWZ0Kz1NYXRoLm1heCgyMCxlLTIwKTtteFV0aWxzLnNldE9wYWNpdHkocSwwPGMuc2Nyb2xsTGVmdD8xMDA6NTApO214VXRpbHMuc2V0T3BhY2l0eShiLGMuc2Nyb2xsTGVmdDxjLnNjcm9sbFdpZHRoLWMuY2xpZW50V2lkdGg/MTAwOjUwKTtteEV2ZW50LmNvbnN1bWUoYSl9KSl9fX07RWRpdG9yVWkucHJvdG90eXBlLmlzUGFnZUluc2VydFRhYlZpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4gMT09dXJsUGFyYW1zLmVtYmVkfHxudWxsIT10aGlzLmdldEN1cnJlbnRGaWxlKCkmJnRoaXMuZ2V0Q3VycmVudEZpbGUoKS5pc0VkaXRhYmxlKCl9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVGFiPWZ1bmN0aW9uKGEpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Muc3R5bGUuZGlzcGxheT1teENsaWVudC5JU19RVUlSS1M/ImlubGluZSI6ImlubGluZS1ibG9jayI7Yy5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiO2Muc3R5bGUuYm94U2l6aW5nPSJib3JkZXItYm94IjtjLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7Yy5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtjLnN0eWxlLnRleHRBbGlnbj0iY2VudGVyIjtjLnN0eWxlLm1hcmdpbkxlZnQ9Ii0xcHgiO2Muc3R5bGUuaGVpZ2h0PXRoaXMudGFiQ29udGFpbmVyLmNsaWVudEhlaWdodCsicHgiO2Muc3R5bGUucGFkZGluZz0iMTJweCA0cHggOHB4IDRweCI7Yy5zdHlsZS5ib3JkZXI9ImRhcmsiPT11aVRoZW1lPyIxcHggc29saWQgIzUwNTc1OSI6IjFweCBzb2xpZCAjZThlYWVkIjtjLnN0eWxlLmJvcmRlclRvcFN0eWxlPSJub25lIjtjLnN0eWxlLmJvcmRlckJvdHRvbVN0eWxlPQoibm9uZSI7Yy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy50YWJDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yO2Muc3R5bGUuY3Vyc29yPSJtb3ZlIjtjLnN0eWxlLmNvbG9yPSJncmF5IjthJiYobXhFdmVudC5hZGRMaXN0ZW5lcihjLCJtb3VzZWVudGVyIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5pc01vdXNlRG93bnx8KGMuc3R5bGUuYmFja2dyb3VuZENvbG9yPSJkYXJrIj09dWlUaGVtZT8iYmxhY2siOiIjZThlYWVkIixteEV2ZW50LmNvbnN1bWUoYSkpfSkpLG14RXZlbnQuYWRkTGlzdGVuZXIoYywibW91c2VsZWF2ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7Yy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9dGhpcy50YWJDb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yO214RXZlbnQuY29uc3VtZShhKX0pKSk7cmV0dXJuIGN9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlQ29udHJvbFRhYj1mdW5jdGlvbihhLGMpe3ZhciBmPXRoaXMuY3JlYXRlVGFiKCEwKTtmLnN0eWxlLmxpbmVIZWlnaHQ9dGhpcy50YWJDb250YWluZXJIZWlnaHQrInB4IjtmLnN0eWxlLnBhZGRpbmdUb3A9YSsicHgiO2Yuc3R5bGUuY3Vyc29yPSJwb2ludGVyIjtmLnN0eWxlLndpZHRoPSIzMHB4IjtmLmlubmVySFRNTD1jO251bGwhPWYuZmlyc3RDaGlsZCYmbnVsbCE9Zi5maXJzdENoaWxkLnN0eWxlJiZteFV0aWxzLnNldE9wYWNpdHkoZi5maXJzdENoaWxkLDQwKTtyZXR1cm4gZn07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVQYWdlTWVudVRhYj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3JlYXRlQ29udHJvbFRhYigzLCc8ZGl2IGNsYXNzPSJnZVNwcml0ZSBnZVNwcml0ZS1kb3RzIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXRvcDo1cHg7d2lkdGg6MjFweDtoZWlnaHQ6MjFweDsiPjwvZGl2PicpO2Euc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJwYWdlcyIpKTthLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7YS5zdHlsZS5tYXJnaW5MZWZ0PSIwcHgiO2Euc3R5bGUudG9wPSIwcHgiO2Euc3R5bGUubGVmdD0iMXB4IjtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmVkaXRvci5ncmFwaC5wb3B1cE1lbnVIYW5kbGVyLmhpZGVNZW51KCk7dmFyIGM9bmV3IG14UG9wdXBNZW51KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBiPQowO2I8dGhpcy5wYWdlcy5sZW5ndGg7YisrKW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGIpe3ZhciBkPWEuYWRkSXRlbSh0aGlzLnBhZ2VzW2JdLmdldE5hbWUoKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RQYWdlKHRoaXMucGFnZXNbYl0pfSksYyk7dGhpcy5wYWdlc1tiXT09dGhpcy5jdXJyZW50UGFnZSYmYS5hZGRDaGVja21hcmsoZCxFZGl0b3IuY2hlY2ttYXJrSW1hZ2UpfSkoYik7aWYodGhpcy5lZGl0b3IuZ3JhcGguaXNFbmFibGVkKCkpe2EuYWRkU2VwYXJhdG9yKGMpO2EuYWRkSXRlbShteFJlc291cmNlcy5nZXQoImluc2VydFBhZ2UiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5pbnNlcnRQYWdlKCl9KSxjKTt2YXIgZD10aGlzLmN1cnJlbnRQYWdlO251bGwhPWQmJihhLmFkZFNlcGFyYXRvcihjKSxhLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJkZWxldGUiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe3RoaXMucmVtb3ZlUGFnZShkKX0pLGMpLGEuYWRkSXRlbShteFJlc291cmNlcy5nZXQoInJlbmFtZSIpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlbmFtZVBhZ2UoZCxkLmdldE5hbWUoKSl9KSxjKSxhLmFkZFNlcGFyYXRvcihjKSxhLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJkdXBsaWNhdGUiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5kdXBsaWNhdGVQYWdlKGQsbXhSZXNvdXJjZXMuZ2V0KCJjb3B5T2YiLFtkLmdldE5hbWUoKV0pKX0pLGMpKX19KSk7Yy5kaXYuY2xhc3NOYW1lKz0iIGdlTWVudWJhck1lbnUiO2Muc21hcnRTZXBhcmF0b3JzPSEwO2Muc2hvd0Rpc2FibGVkPSEwO2MuYXV0b0V4cGFuZD0hMDtjLmhpZGVNZW51PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmhpZGVNZW51LmFwcGx5KGMsYXJndW1lbnRzKTtjLmRlc3Ryb3koKX0pO3ZhciBkPQpteEV2ZW50LmdldENsaWVudFgoYSksaz1teEV2ZW50LmdldENsaWVudFkoYSk7Yy5wb3B1cChkLGssbnVsbCxhKTt0aGlzLnNldEN1cnJlbnRNZW51KGMpO214RXZlbnQuY29uc3VtZShhKX0pKTtyZXR1cm4gYX07RWRpdG9yVWkucHJvdG90eXBlLmNyZWF0ZVBhZ2VJbnNlcnRUYWI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNyZWF0ZUNvbnRyb2xUYWIoNCwnPGRpdiBjbGFzcz0iZ2VTcHJpdGUgZ2VTcHJpdGUtcGx1cyIgc3R5bGU9ImRpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjIxcHg7aGVpZ2h0OjIxcHg7Ij48L2Rpdj4nKTthLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiaW5zZXJ0UGFnZSIpKTtteEV2ZW50LmFkZExpc3RlbmVyKGEsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmluc2VydFBhZ2UoKTtteEV2ZW50LmNvbnN1bWUoYSl9KSk7cmV0dXJuIGF9OwpFZGl0b3JVaS5wcm90b3R5cGUuY3JlYXRlVGFiRm9yUGFnZT1mdW5jdGlvbihhLGMsZixkKXtmPXRoaXMuY3JlYXRlVGFiKGYpO3ZhciBrPWEuZ2V0TmFtZSgpfHxteFJlc291cmNlcy5nZXQoInVudGl0bGVkIiksbT1hLmdldElkKCk7Zi5zZXRBdHRyaWJ1dGUoInRpdGxlIixrKyhudWxsIT1tPyIgKCIrbSsiKSI6IiIpKyIgWyIrZCsiXSIpO214VXRpbHMud3JpdGUoZixrKTtmLnN0eWxlLm1heFdpZHRoPWMrInB4IjtmLnN0eWxlLndpZHRoPWMrInB4Ijt0aGlzLmFkZFRhYkxpc3RlbmVycyhhLGYpOzQyPGMmJihmLnN0eWxlLnRleHRPdmVyZmxvdz0iZWxsaXBzaXMiKTtyZXR1cm4gZn07CkVkaXRvclVpLnByb3RvdHlwZS5hZGRUYWJMaXN0ZW5lcnM9ZnVuY3Rpb24oYSxjKXtteEV2ZW50LmRpc2FibGVDb250ZXh0TWVudShjKTt2YXIgZj10aGlzLmVkaXRvci5ncmFwaDtteEV2ZW50LmFkZExpc3RlbmVyKGMsImRibGNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXt0aGlzLnJlbmFtZVBhZ2UoYSk7bXhFdmVudC5jb25zdW1lKGMpfSkpO3ZhciBkPSExLGs9ITE7bXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKGMsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYyl7ZD1udWxsIT10aGlzLmN1cnJlbnRNZW51O2s9YT09dGhpcy5jdXJyZW50UGFnZTtmLmlzTW91c2VEb3dufHxrfHx0aGlzLnNlbGVjdFBhZ2UoYSl9KSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKG0pe2lmKGYuaXNFbmFibGVkKCkmJiFmLmlzTW91c2VEb3duJiYobXhFdmVudC5pc1RvdWNoRXZlbnQobSkmJmt8fG14RXZlbnQuaXNQb3B1cFRyaWdnZXIobSkpKXtmLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKTsKdGhpcy5oaWRlQ3VycmVudE1lbnUoKTtpZighbXhFdmVudC5pc1RvdWNoRXZlbnQobSl8fCFkKXt2YXIgcT1uZXcgbXhQb3B1cE1lbnUodGhpcy5jcmVhdGVQYWdlTWVudShhKSk7cS5kaXYuY2xhc3NOYW1lKz0iIGdlTWVudWJhck1lbnUiO3Euc21hcnRTZXBhcmF0b3JzPSEwO3Euc2hvd0Rpc2FibGVkPSEwO3EuYXV0b0V4cGFuZD0hMDtxLmhpZGVNZW51PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bXhQb3B1cE1lbnUucHJvdG90eXBlLmhpZGVNZW51LmFwcGx5KHEsYXJndW1lbnRzKTt0aGlzLnJlc2V0Q3VycmVudE1lbnUoKTtxLmRlc3Ryb3koKX0pO3ZhciBiPW14RXZlbnQuZ2V0Q2xpZW50WChtKSxlPW14RXZlbnQuZ2V0Q2xpZW50WShtKTtxLnBvcHVwKGIsZSxudWxsLG0pO3RoaXMuc2V0Q3VycmVudE1lbnUocSxjKX1teEV2ZW50LmNvbnN1bWUobSl9fSkpfTsKRWRpdG9yVWkucHJvdG90eXBlLmdldExpbmtGb3JQYWdlPWZ1bmN0aW9uKGEpe2lmKCFteENsaWVudC5JU19DSFJPTUVBUFAmJiFFZGl0b3JVaS5pc0VsZWN0cm9uQXBwKXt2YXIgYz10aGlzLmdldEN1cnJlbnRGaWxlKCk7aWYobnVsbCE9YyYmYy5jb25zdHJ1Y3RvciE9TG9jYWxGaWxlJiYiZHJhdy5pbyI9PXRoaXMuZ2V0U2VydmljZU5hbWUoKSl7dmFyIGY9dGhpcy5nZXRTZWFyY2goImNyZWF0ZSB0aXRsZSBtb2RlIHVybCBkcml2ZSBzcGxhc2ggc3RhdGUgY2xpYnMgdWkiLnNwbGl0KCIgIikpLGY9ZisoKDA9PWYubGVuZ3RoPyI/IjoiJiIpKyJwYWdlLWlkPSIrYS5nZXRJZCgpKTtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sKyIvLyIrd2luZG93LmxvY2F0aW9uLmhvc3QrIi8iK2YrIiMiK2MuZ2V0SGFzaCgpfX1yZXR1cm4gbnVsbH07CkVkaXRvclVpLnByb3RvdHlwZS5jcmVhdGVQYWdlTWVudT1mdW5jdGlvbihhLGMpe3JldHVybiBteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihmLGQpe2YuYWRkSXRlbShteFJlc291cmNlcy5nZXQoImluc2VydCIpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmluc2VydFBhZ2UobnVsbCxteFV0aWxzLmluZGV4T2YodGhpcy5wYWdlcyxhKSsxKX0pLGQpO2YuYWRkSXRlbShteFJlc291cmNlcy5nZXQoImRlbGV0ZSIpLG51bGwsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnJlbW92ZVBhZ2UoYSl9KSxkKTtmLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJyZW5hbWUiKSxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5yZW5hbWVQYWdlKGEsYyl9KSxkKTt2YXIgaz10aGlzLmdldExpbmtGb3JQYWdlKGEpO251bGwhPWsmJihmLmFkZFNlcGFyYXRvcihkKSxmLmFkZEl0ZW0obXhSZXNvdXJjZXMuZ2V0KCJsaW5rIiksbnVsbCwKbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT1uZXcgRW1iZWREaWFsb2codGhpcyxrKTt0aGlzLnNob3dEaWFsb2coYS5jb250YWluZXIsNDQwLDI0MCwhMCwhMCk7YS5pbml0KCl9KSxkKSk7Zi5hZGRTZXBhcmF0b3IoZCk7Zi5hZGRJdGVtKG14UmVzb3VyY2VzLmdldCgiZHVwbGljYXRlIiksbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZHVwbGljYXRlUGFnZShhLG14UmVzb3VyY2VzLmdldCgiY29weU9mIixbYS5nZXROYW1lKCldKSl9KSxkKTtteENsaWVudC5JU19DSFJPTUVBUFB8fEVkaXRvclVpLmlzRWxlY3Ryb25BcHB8fCJkcmF3LmlvIiE9dGhpcy5nZXRTZXJ2aWNlTmFtZSgpfHwoZi5hZGRTZXBhcmF0b3IoZCksZi5hZGRJdGVtKG14UmVzb3VyY2VzLmdldCgib3BlbkluTmV3V2luZG93IiksbnVsbCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZWRpdG9yLmVkaXRBc05ldyh0aGlzLmdldEZpbGVEYXRhKCEwLG51bGwsCm51bGwsbnVsbCwhMCwhMCkpfSksZCkpfSl9OyhmdW5jdGlvbigpe3ZhciBhPUVkaXRvclVpLnByb3RvdHlwZS5yZWZyZXNoO0VkaXRvclVpLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGMpe2EuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMudXBkYXRlVGFiQ29udGFpbmVyKCl9fSkoKTsoZnVuY3Rpb24oKXtteENvZGVjUmVnaXN0cnkuZ2V0Q29kZWMoQ2hhbmdlUGFnZVNldHVwKS5leGNsdWRlLnB1c2goInBhZ2UiKX0pKCk7KGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IE1vdmVQYWdlLFsidWkiXSk7YS5iZWZvcmVEZWNvZGU9ZnVuY3Rpb24oYSxmLGQpe2QudWk9YS51aTtyZXR1cm4gZn07YS5hZnRlckRlY29kZT1mdW5jdGlvbihhLGYsZCl7YT1kLm9sZEluZGV4O2Qub2xkSW5kZXg9ZC5uZXdJbmRleDtkLm5ld0luZGV4PWE7cmV0dXJuIGR9O214Q29kZWNSZWdpc3RyeS5yZWdpc3RlcihhKX0pKCk7CihmdW5jdGlvbigpe3ZhciBhPW5ldyBteE9iamVjdENvZGVjKG5ldyBSZW5hbWVQYWdlLFsidWkiLCJwYWdlIl0pO2EuYmVmb3JlRGVjb2RlPWZ1bmN0aW9uKGEsZixkKXtkLnVpPWEudWk7cmV0dXJuIGZ9O2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxmLGQpe2E9ZC5wcmV2aW91cztkLnByZXZpb3VzPWQubmFtZTtkLm5hbWU9YTtyZXR1cm4gZH07bXhDb2RlY1JlZ2lzdHJ5LnJlZ2lzdGVyKGEpfSkoKTsKKGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14T2JqZWN0Q29kZWMobmV3IENoYW5nZVBhZ2UsInVpIHJlbGF0ZWRQYWdlIGluZGV4IG5ldmVyU2hvd24gcGFnZSBwcmV2aW91c1BhZ2UiLnNwbGl0KCIgIikpLGM9ImRlZmF1bHRQYXJlbnQgY3VycmVudFJvb3Qgc2Nyb2xsTGVmdCBzY3JvbGxUb3Agc2NhbGUgdHJhbnNsYXRlIGxhc3RQYXN0ZVhtbCBwYXN0ZUNvdW50ZXIiLnNwbGl0KCIgIik7YS5hZnRlckVuY29kZT1mdW5jdGlvbihhLGQsayl7ay5zZXRBdHRyaWJ1dGUoInJlbGF0ZWRQYWdlIixkLnJlbGF0ZWRQYWdlLmdldElkKCkpO251bGw9PWQuaW5kZXgmJihrLnNldEF0dHJpYnV0ZSgibmFtZSIsZC5yZWxhdGVkUGFnZS5nZXROYW1lKCkpLG51bGwhPWQucmVsYXRlZFBhZ2Uudmlld1N0YXRlJiZrLnNldEF0dHJpYnV0ZSgidmlld1N0YXRlIixKU09OLnN0cmluZ2lmeShkLnJlbGF0ZWRQYWdlLnZpZXdTdGF0ZSxmdW5jdGlvbihhLGQpe3JldHVybiAwPm14VXRpbHMuaW5kZXhPZihjLAphKT9kOnZvaWQgMH0pKSxudWxsIT1kLnJlbGF0ZWRQYWdlLnJvb3QmJmEuZW5jb2RlQ2VsbChkLnJlbGF0ZWRQYWdlLnJvb3QsaykpO3JldHVybiBrfTthLmJlZm9yZURlY29kZT1mdW5jdGlvbihhLGMsayl7ay51aT1hLnVpO2sucmVsYXRlZFBhZ2U9ay51aS5nZXRQYWdlQnlJZChjLmdldEF0dHJpYnV0ZSgicmVsYXRlZFBhZ2UiKSk7aWYobnVsbD09ay5yZWxhdGVkUGFnZSl7dmFyIGQ9Yy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpYWdyYW0iKTtkLnNldEF0dHJpYnV0ZSgiaWQiLGMuZ2V0QXR0cmlidXRlKCJyZWxhdGVkUGFnZSIpKTtkLnNldEF0dHJpYnV0ZSgibmFtZSIsYy5nZXRBdHRyaWJ1dGUoIm5hbWUiKSk7ay5yZWxhdGVkUGFnZT1uZXcgRGlhZ3JhbVBhZ2UoZCk7ZD1jLmdldEF0dHJpYnV0ZSgidmlld1N0YXRlIik7bnVsbCE9ZCYmKGsucmVsYXRlZFBhZ2Uudmlld1N0YXRlPUpTT04ucGFyc2UoZCksYy5yZW1vdmVBdHRyaWJ1dGUoInZpZXdTdGF0ZSIpKTsKYz1jLmNsb25lTm9kZSghMCk7ZD1jLmZpcnN0Q2hpbGQ7aWYobnVsbCE9ZClmb3Ioay5yZWxhdGVkUGFnZS5yb290PWEuZGVjb2RlQ2VsbChkLCExKSxrPWQubmV4dFNpYmxpbmcsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLGQ9aztudWxsIT1kOyl7az1kLm5leHRTaWJsaW5nO2lmKGQubm9kZVR5cGU9PW14Q29uc3RhbnRzLk5PREVUWVBFX0VMRU1FTlQpe3ZhciBmPWQuZ2V0QXR0cmlidXRlKCJpZCIpO251bGw9PWEubG9va3VwKGYpJiZhLmRlY29kZUNlbGwoZCl9ZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpO2Q9a319cmV0dXJuIGN9O2EuYWZ0ZXJEZWNvZGU9ZnVuY3Rpb24oYSxjLGspe2suaW5kZXg9ay5wcmV2aW91c0luZGV4O3JldHVybiBrfTtteENvZGVjUmVnaXN0cnkucmVnaXN0ZXIoYSl9KSgpOyhmdW5jdGlvbigpe0VkaXRvclVpLnByb3RvdHlwZS5hbHRTaGlmdEFjdGlvbnNbNjhdPSJzZWxlY3REZXNjZW5kYW50cyI7dmFyIGE9R3JhcGgucHJvdG90eXBlLmZvbGRDZWxscztHcmFwaC5wcm90b3R5cGUuZm9sZENlbGxzPWZ1bmN0aW9uKGMsZixtLHEsYil7Zj1udWxsIT1mP2Y6ITE7bnVsbD09bSYmKG09dGhpcy5nZXRGb2xkYWJsZUNlbGxzKHRoaXMuZ2V0U2VsZWN0aW9uQ2VsbHMoKSxjKSk7dGhpcy5zdG9wRWRpdGluZygpO3RoaXMubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBkPW0uc2xpY2UoKSxnPVtdLGs9MDtrPG0ubGVuZ3RoO2srKyl7dmFyIGw9dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKG1ba10pOyIxIj09bXhVdGlscy5nZXRWYWx1ZShsLCJ0cmVlRm9sZGluZyIsIjAiKSYmKHRoaXMudHJhdmVyc2UobVtrXSwhMCxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGIpe251bGwhPWImJmcucHVzaChiKTthIT1tW2tdJiZnLnB1c2goYSk7cmV0dXJuIGE9PQptW2tdfHwhdGhpcy5tb2RlbC5pc0NvbGxhcHNlZChhKX0pKSx0aGlzLm1vZGVsLnNldENvbGxhcHNlZChtW2tdLGMpKX1mb3Ioaz0wO2s8Zy5sZW5ndGg7aysrKXRoaXMubW9kZWwuc2V0VmlzaWJsZShnW2tdLCFjKTttPWQ7bT1hLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIG19O3ZhciBjPUVkaXRvclVpLnByb3RvdHlwZS5pbml0O0VkaXRvclVpLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy5lZGl0b3IuaXNDaHJvbWVsZXNzVmlldygpJiYhdGhpcy5lZGl0b3IuZWRpdGFibGV8fHRoaXMuYWRkVHJlZXMoKX07RWRpdG9yVWkucHJvdG90eXBlLmFkZFRyZWVzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtyZXR1cm4geS5pc1ZlcnRleChhKSYmZihhKX1mdW5jdGlvbiBjKGEpe3ZhciBiPSExO251bGwhPWEmJihiPSIxIj09dC5nZXRDdXJyZW50Q2VsbFN0eWxlKGEpLnRyZWVNb3ZpbmcpOwpyZXR1cm4gYn1mdW5jdGlvbiBmKGEpe3ZhciBiPSExO251bGwhPWEmJihhPXkuZ2V0UGFyZW50KGEpLGI9dC52aWV3LmdldFN0YXRlKGEpLGI9InRyZWUiPT0obnVsbCE9Yj9iLnN0eWxlOnQuZ2V0Q2VsbFN0eWxlKGEpKS5jb250YWluZXJUeXBlKTtyZXR1cm4gYn1mdW5jdGlvbiBxKGEpe3ZhciBiPSExO251bGwhPWEmJihhPXkuZ2V0UGFyZW50KGEpLGI9dC52aWV3LmdldFN0YXRlKGEpLHQudmlldy5nZXRTdGF0ZShhKSxiPW51bGwhPShudWxsIT1iP2Iuc3R5bGU6dC5nZXRDZWxsU3R5bGUoYSkpLmNoaWxkTGF5b3V0KTtyZXR1cm4gYn1mdW5jdGlvbiBiKGEpe2E9dC52aWV3LmdldFN0YXRlKGEpO2lmKG51bGwhPWEpe3ZhciBiPXQuZ2V0SW5jb21pbmdFZGdlcyhhLmNlbGwpO2lmKDA8Yi5sZW5ndGgmJihiPXQudmlldy5nZXRTdGF0ZShiWzBdKSxudWxsIT1iJiYoYj1iLmFic29sdXRlUG9pbnRzLG51bGwhPWImJjA8Yi5sZW5ndGgmJihiPWJbYi5sZW5ndGgtMV0sbnVsbCE9YikpKSl7aWYoYi55PT0KYS55JiZNYXRoLmFicyhiLngtYS5nZXRDZW50ZXJYKCkpPGEud2lkdGgvMilyZXR1cm4gbXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIO2lmKGIueT09YS55K2EuaGVpZ2h0JiZNYXRoLmFicyhiLngtYS5nZXRDZW50ZXJYKCkpPGEud2lkdGgvMilyZXR1cm4gbXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIO2lmKGIueD5hLmdldENlbnRlclgoKSlyZXR1cm4gbXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1R9fXJldHVybiBteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVH1mdW5jdGlvbiBlKGEsYyl7Yz1udWxsIT1jP2M6ITA7dC5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD10Lm1vZGVsLmdldFBhcmVudChhKSxlPXQuZ2V0SW5jb21pbmdFZGdlcyhhKSxmPXQuY2xvbmVDZWxscyhbZVswXSxhXSk7dC5tb2RlbC5zZXRUZXJtaW5hbChmWzBdLHQubW9kZWwuZ2V0VGVybWluYWwoZVswXSwhMCksITApO3ZhciBnPWIoYSksaz1kLmdlb21ldHJ5O2c9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSHx8Cmc9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9mWzFdLmdlb21ldHJ5LngrPWM/YS5nZW9tZXRyeS53aWR0aCsxMDotZlsxXS5nZW9tZXRyeS53aWR0aC0xMDpmWzFdLmdlb21ldHJ5LnkrPWM/YS5nZW9tZXRyeS5oZWlnaHQrMTA6LWZbMV0uZ2VvbWV0cnkuaGVpZ2h0LTEwO3Qudmlldy5jdXJyZW50Um9vdCE9ZCYmKGZbMV0uZ2VvbWV0cnkueC09ay54LGZbMV0uZ2VvbWV0cnkueS09ay55KTt2YXIgbD10LnZpZXcuZ2V0U3RhdGUoYSksbT10LnZpZXcuc2NhbGU7aWYobnVsbCE9bCl7dmFyIG49bXhSZWN0YW5nbGUuZnJvbVJlY3RhbmdsZShsKTtnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGc9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSD9uLngrPShjP2EuZ2VvbWV0cnkud2lkdGgrMTA6LWZbMV0uZ2VvbWV0cnkud2lkdGgtMTApKm06bi55Kz0oYz9hLmdlb21ldHJ5LmhlaWdodCsxMDotZlsxXS5nZW9tZXRyeS5oZWlnaHQtMTApKm07dmFyIHA9dC5nZXRPdXRnb2luZ0VkZ2VzKHQubW9kZWwuZ2V0VGVybWluYWwoZVswXSwKITApKTtpZihudWxsIT1wKXtmb3IodmFyIHE9Zz09bXhDb25zdGFudHMuRElSRUNUSU9OX1NPVVRIfHxnPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgseT1rPWU9MDt5PHAubGVuZ3RoO3krKyl7dmFyIHU9dC5tb2RlbC5nZXRUZXJtaW5hbChwW3ldLCExKTtpZihnPT1iKHUpKXt2YXIgej10LnZpZXcuZ2V0U3RhdGUodSk7dSE9YSYmbnVsbCE9eiYmKHEmJmMhPXouZ2V0Q2VudGVyWCgpPGwuZ2V0Q2VudGVyWCgpfHwhcSYmYyE9ei5nZXRDZW50ZXJZKCk8bC5nZXRDZW50ZXJZKCkpJiZteFV0aWxzLmludGVyc2VjdHMobix6KSYmKGU9MTArTWF0aC5tYXgoZSwoTWF0aC5taW4obi54K24ud2lkdGgsei54K3oud2lkdGgpLU1hdGgubWF4KG4ueCx6LngpKS9tKSxrPTEwK01hdGgubWF4KGssKE1hdGgubWluKG4ueStuLmhlaWdodCx6Lnkrei5oZWlnaHQpLU1hdGgubWF4KG4ueSx6LnkpKS9tKSl9fXE/az0wOmU9MDtmb3IoeT0wO3k8cC5sZW5ndGg7eSsrKWlmKHU9dC5tb2RlbC5nZXRUZXJtaW5hbChwW3ldLAohMSksZz09Yih1KSYmKHo9dC52aWV3LmdldFN0YXRlKHUpLHUhPWEmJm51bGwhPXomJihxJiZjIT16LmdldENlbnRlclgoKTxsLmdldENlbnRlclgoKXx8IXEmJmMhPXouZ2V0Q2VudGVyWSgpPGwuZ2V0Q2VudGVyWSgpKSkpe3ZhciBBPVtdO3QudHJhdmVyc2Uoei5jZWxsLCEwLGZ1bmN0aW9uKGEsYil7bnVsbCE9YiYmQS5wdXNoKGIpO0EucHVzaChhKTtyZXR1cm4hMH0pO3QubW92ZUNlbGxzKEEsKGM/MTotMSkqZSwoYz8xOi0xKSprKX19fXJldHVybiB0LmFkZENlbGxzKGYsZCl9ZmluYWxseXt0Lm1vZGVsLmVuZFVwZGF0ZSgpfX1mdW5jdGlvbiBnKGEpe3QubW9kZWwuYmVnaW5VcGRhdGUoKTt0cnl7dmFyIGM9YihhKSxkPXQuZ2V0SW5jb21pbmdFZGdlcyhhKSxlPXQuY2xvbmVDZWxscyhbZFswXSxhXSk7dC5tb2RlbC5zZXRUZXJtaW5hbChkWzBdLGVbMV0sITEpO3QubW9kZWwuc2V0VGVybWluYWwoZVswXSxlWzFdLCEwKTt0Lm1vZGVsLnNldFRlcm1pbmFsKGVbMF0sYSwhMSk7CnZhciBmPXQubW9kZWwuZ2V0UGFyZW50KGEpLGc9Zi5nZW9tZXRyeSxrPVtdO3Qudmlldy5jdXJyZW50Um9vdCE9ZiYmKGVbMV0uZ2VvbWV0cnkueC09Zy54LGVbMV0uZ2VvbWV0cnkueS09Zy55KTt0LnRyYXZlcnNlKGEsITAsZnVuY3Rpb24oYSxiKXtudWxsIT1iJiZrLnB1c2goYik7ay5wdXNoKGEpO3JldHVybiEwfSk7dmFyIGw9YS5nZW9tZXRyeS53aWR0aCs0MCxtPWEuZ2VvbWV0cnkuaGVpZ2h0KzQwO2M9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9TT1VUSD9sPTA6Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX05PUlRIPyhsPTAsbT0tbSk6Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/KGw9LWwsbT0wKTpjPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCYmKG09MCk7dC5tb3ZlQ2VsbHMoayxsLG0pO3JldHVybiB0LmFkZENlbGxzKGUsZil9ZmluYWxseXt0Lm1vZGVsLmVuZFVwZGF0ZSgpfX1mdW5jdGlvbiBuKGEsYyl7dC5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgZD0KdC5tb2RlbC5nZXRQYXJlbnQoYSksZT10LmdldEluY29taW5nRWRnZXMoYSksZj1iKGEpOzA9PWUubGVuZ3RoJiYoZT1bdC5jcmVhdGVFZGdlKGQsbnVsbCwiIixudWxsLG51bGwsdC5jcmVhdGVDdXJyZW50RWRnZVN0eWxlKCkpXSxmPWMpO3ZhciBnPXQuY2xvbmVDZWxscyhbZVswXSxhXSk7dC5tb2RlbC5zZXRUZXJtaW5hbChnWzBdLGEsITApO2lmKG51bGw9PXQubW9kZWwuZ2V0VGVybWluYWwoZ1swXSwhMSkpe3QubW9kZWwuc2V0VGVybWluYWwoZ1swXSxnWzFdLCExKTt2YXIgaz10LmdldENlbGxTdHlsZShnWzFdKS5uZXdFZGdlU3R5bGU7aWYobnVsbCE9ayl0cnl7dmFyIGw9SlNPTi5wYXJzZShrKSxtO2ZvcihtIGluIGwpdC5zZXRDZWxsU3R5bGVzKG0sbFttXSxbZ1swXV0pLCJlZGdlU3R5bGUiPT1tJiYiZWxib3dFZGdlU3R5bGUiPT1sW21dJiZ0LnNldENlbGxTdHlsZXMoImVsYm93IixmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEh8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1RIPwoidmVydGljYWwiOiJob3Jpem9udGFsIixbZ1swXV0pfWNhdGNoKFkpe319dmFyIGU9dC5nZXRPdXRnb2luZ0VkZ2VzKGEpLG49ZC5nZW9tZXRyeSxrPVtdO3Qudmlldy5jdXJyZW50Um9vdD09ZCYmKG49bmV3IG14UmVjdGFuZ2xlKTtmb3IobD0wO2w8ZS5sZW5ndGg7bCsrKXt2YXIgcD10Lm1vZGVsLmdldFRlcm1pbmFsKGVbbF0sITEpO251bGwhPXAmJmsucHVzaChwKX12YXIgcT10LnZpZXcuZ2V0Qm91bmRzKGspLHk9dC52aWV3LnRyYW5zbGF0ZSx6PXQudmlldy5zY2FsZTtmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEg/KGdbMV0uZ2VvbWV0cnkueD1udWxsPT1xP2EuZ2VvbWV0cnkueCsoYS5nZW9tZXRyeS53aWR0aC1nWzFdLmdlb21ldHJ5LndpZHRoKS8yOihxLngrcS53aWR0aCkvei15Lngtbi54KzEwLGdbMV0uZ2VvbWV0cnkueSs9Z1sxXS5nZW9tZXRyeS5oZWlnaHQtbi55KzQwKTpmPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEg/KGdbMV0uZ2VvbWV0cnkueD0KbnVsbD09cT9hLmdlb21ldHJ5LngrKGEuZ2VvbWV0cnkud2lkdGgtZ1sxXS5nZW9tZXRyeS53aWR0aCkvMjoocS54K3Eud2lkdGgpL3oteS54Ky1uLngrMTAsZ1sxXS5nZW9tZXRyeS55LT1nWzFdLmdlb21ldHJ5LmhlaWdodCtuLnkrNDApOihnWzFdLmdlb21ldHJ5Lng9Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1Q/Z1sxXS5nZW9tZXRyeS54LShnWzFdLmdlb21ldHJ5LndpZHRoK24ueCs0MCk6Z1sxXS5nZW9tZXRyeS54KyhnWzFdLmdlb21ldHJ5LndpZHRoLW4ueCs0MCksZ1sxXS5nZW9tZXRyeS55PW51bGw9PXE/YS5nZW9tZXRyeS55KyhhLmdlb21ldHJ5LmhlaWdodC1nWzFdLmdlb21ldHJ5LmhlaWdodCkvMjoocS55K3EuaGVpZ2h0KS96LXkueSstbi55KzEwKTtyZXR1cm4gdC5hZGRDZWxscyhnLGQpfWZpbmFsbHl7dC5tb2RlbC5lbmRVcGRhdGUoKX19ZnVuY3Rpb24gbChhLGIsYyl7YT10LmdldE91dGdvaW5nRWRnZXMoYSk7Yz10LnZpZXcuZ2V0U3RhdGUoYyk7dmFyIGQ9CltdO2lmKG51bGwhPWMmJm51bGwhPWEpe2Zvcih2YXIgZT0wO2U8YS5sZW5ndGg7ZSsrKXt2YXIgZj10LnZpZXcuZ2V0U3RhdGUodC5tb2RlbC5nZXRUZXJtaW5hbChhW2VdLCExKSk7bnVsbCE9ZiYmKCFiJiZNYXRoLm1pbihmLngrZi53aWR0aCxjLngrYy53aWR0aCk+PU1hdGgubWF4KGYueCxjLngpfHxiJiZNYXRoLm1pbihmLnkrZi5oZWlnaHQsYy55K2MuaGVpZ2h0KT49TWF0aC5tYXgoZi55LGMueSkpJiZkLnB1c2goZil9ZC5zb3J0KGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGI/YS54K2Eud2lkdGgtYy54LWMud2lkdGg6YS55K2EuaGVpZ2h0LWMueS1jLmhlaWdodH0pfXJldHVybiBkfWZ1bmN0aW9uIHAoYSxjKXt2YXIgZD1iKGEpLGU9Yz09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1R8fGM9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUOyhkPT1teENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVHx8ZD09bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpPT1lJiZkIT1jP3YuYWN0aW9ucy5nZXQoInNlbGVjdFBhcmVudCIpLmZ1bmN0KCk6CmQ9PWM/KGU9dC5nZXRPdXRnb2luZ0VkZ2VzKGEpLG51bGwhPWUmJjA8ZS5sZW5ndGgmJnQuc2V0U2VsZWN0aW9uQ2VsbCh0Lm1vZGVsLmdldFRlcm1pbmFsKGVbMF0sITEpKSk6KGQ9dC5nZXRJbmNvbWluZ0VkZ2VzKGEpLG51bGwhPWQmJjA8ZC5sZW5ndGgmJihlPWwodC5tb2RlbC5nZXRUZXJtaW5hbChkWzBdLCEwKSxlLGEpLGQ9dC52aWV3LmdldFN0YXRlKGEpLG51bGwhPWQmJihkPW14VXRpbHMuaW5kZXhPZihlLGQpLDA8PWQmJihkKz1jPT1teENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEh8fGM9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNUPy0xOjEsMDw9ZCYmZDw9ZS5sZW5ndGgtMSYmdC5zZXRTZWxlY3Rpb25DZWxsKGVbZF0uY2VsbCkpKSkpfXZhciB2PXRoaXMsdD12LmVkaXRvci5ncmFwaCx5PXQuZ2V0TW9kZWwoKSx4PXYubWVudXMuY3JlYXRlUG9wdXBNZW51O3YubWVudXMuY3JlYXRlUG9wdXBNZW51PWZ1bmN0aW9uKGIsYyxkKXt4LmFwcGx5KHRoaXMsYXJndW1lbnRzKTsKaWYoMT09dC5nZXRTZWxlY3Rpb25Db3VudCgpKXtjPXQuZ2V0U2VsZWN0aW9uQ2VsbCgpO3ZhciBlPXQuZ2V0T3V0Z29pbmdFZGdlcyhjKTtiLmFkZFNlcGFyYXRvcigpOzA8ZS5sZW5ndGgmJihhKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSYmdGhpcy5hZGRNZW51SXRlbXMoYixbInNlbGVjdENoaWxkcmVuIl0sbnVsbCxkKSx0aGlzLmFkZE1lbnVJdGVtcyhiLFsic2VsZWN0RGVzY2VuZGFudHMiXSxudWxsLGQpKTthKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKSYmKGIuYWRkU2VwYXJhdG9yKCksMDx0LmdldEluY29taW5nRWRnZXMoYykubGVuZ3RoJiZ0aGlzLmFkZE1lbnVJdGVtcyhiLFsic2VsZWN0U2libGluZ3MiLCJzZWxlY3RQYXJlbnQiXSxudWxsLGQpKX19O3YuYWN0aW9ucy5hZGRBY3Rpb24oInNlbGVjdENoaWxkcmVuIixmdW5jdGlvbigpe2lmKHQuaXNFbmFibGVkKCkmJjE9PXQuZ2V0U2VsZWN0aW9uQ291bnQoKSl7dmFyIGE9dC5nZXRTZWxlY3Rpb25DZWxsKCksYT10LmdldE91dGdvaW5nRWRnZXMoYSk7CmlmKG51bGwhPWEpe2Zvcih2YXIgYj1bXSxjPTA7YzxhLmxlbmd0aDtjKyspYi5wdXNoKHQubW9kZWwuZ2V0VGVybWluYWwoYVtjXSwhMSkpO3Quc2V0U2VsZWN0aW9uQ2VsbHMoYil9fX0sbnVsbCxudWxsLCJBbHQrU2hpZnQrWCIpO3YuYWN0aW9ucy5hZGRBY3Rpb24oInNlbGVjdFNpYmxpbmdzIixmdW5jdGlvbigpe2lmKHQuaXNFbmFibGVkKCkmJjE9PXQuZ2V0U2VsZWN0aW9uQ291bnQoKSl7dmFyIGE9dC5nZXRTZWxlY3Rpb25DZWxsKCksYT10LmdldEluY29taW5nRWRnZXMoYSk7aWYobnVsbCE9YSYmMDxhLmxlbmd0aCYmKGE9dC5nZXRPdXRnb2luZ0VkZ2VzKHQubW9kZWwuZ2V0VGVybWluYWwoYVswXSwhMCkpLG51bGwhPWEpKXtmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKWIucHVzaCh0Lm1vZGVsLmdldFRlcm1pbmFsKGFbY10sITEpKTt0LnNldFNlbGVjdGlvbkNlbGxzKGIpfX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K1MiKTt2LmFjdGlvbnMuYWRkQWN0aW9uKCJzZWxlY3RQYXJlbnQiLApmdW5jdGlvbigpe2lmKHQuaXNFbmFibGVkKCkmJjE9PXQuZ2V0U2VsZWN0aW9uQ291bnQoKSl7dmFyIGE9dC5nZXRTZWxlY3Rpb25DZWxsKCksYT10LmdldEluY29taW5nRWRnZXMoYSk7bnVsbCE9YSYmMDxhLmxlbmd0aCYmdC5zZXRTZWxlY3Rpb25DZWxsKHQubW9kZWwuZ2V0VGVybWluYWwoYVswXSwhMCkpfX0sbnVsbCxudWxsLCJBbHQrU2hpZnQrUCIpO3YuYWN0aW9ucy5hZGRBY3Rpb24oInNlbGVjdERlc2NlbmRhbnRzIixmdW5jdGlvbigpe2lmKHQuaXNFbmFibGVkKCkmJjE9PXQuZ2V0U2VsZWN0aW9uQ291bnQoKSl7dmFyIGE9dC5nZXRTZWxlY3Rpb25DZWxsKCksYj1bXTt0LnRyYXZlcnNlKGEsITAsZnVuY3Rpb24oYSxjKXtudWxsIT1jJiZiLnB1c2goYyk7Yi5wdXNoKGEpO3JldHVybiEwfSk7dC5zZXRTZWxlY3Rpb25DZWxscyhiKX19LG51bGwsbnVsbCwiQWx0K1NoaWZ0K0QiKTt2YXIgQz10LnJlbW92ZUNlbGxzO3QucmVtb3ZlQ2VsbHM9ZnVuY3Rpb24oYixjKXtjPW51bGwhPQpjP2M6ITA7bnVsbD09YiYmKGI9dGhpcy5nZXREZWxldGFibGVDZWxscyh0aGlzLmdldFNlbGVjdGlvbkNlbGxzKCkpKTtjJiYoYj10aGlzLmdldERlbGV0YWJsZUNlbGxzKHRoaXMuYWRkQWxsRWRnZXMoYikpKTtmb3IodmFyIGQ9W10sZT0wO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgZz1iW2VdO3kuaXNFZGdlKGcpJiZmKGcpJiYoZC5wdXNoKGcpLGc9eS5nZXRUZXJtaW5hbChnLCExKSk7aWYoYShnKSl7dmFyIGs9W107dC50cmF2ZXJzZShnLCEwLGZ1bmN0aW9uKGEsYil7bnVsbCE9YiYmay5wdXNoKGIpO2sucHVzaChhKTtyZXR1cm4hMH0pOzA8ay5sZW5ndGgmJihkPWQuY29uY2F0KGspLGc9dC5nZXRJbmNvbWluZ0VkZ2VzKGJbZV0pLGI9Yi5jb25jYXQoZykpfWVsc2UgbnVsbCE9ZyYmZC5wdXNoKGJbZV0pfWI9ZDtyZXR1cm4gQy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3YuaG92ZXJJY29ucy5nZXRTdGF0ZUF0PWZ1bmN0aW9uKGIsYyxkKXtyZXR1cm4gYShiLmNlbGwpP251bGw6dGhpcy5ncmFwaC52aWV3LmdldFN0YXRlKHRoaXMuZ3JhcGguZ2V0Q2VsbEF0KGMsCmQpKX07dmFyIEI9dC5kdXBsaWNhdGVDZWxsczt0LmR1cGxpY2F0ZUNlbGxzPWZ1bmN0aW9uKGIsYyl7Yj1udWxsIT1iP2I6dGhpcy5nZXRTZWxlY3Rpb25DZWxscygpO2Zvcih2YXIgZD1iLnNsaWNlKDApLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9dC52aWV3LmdldFN0YXRlKGRbZV0pO2lmKG51bGwhPWYmJmEoZi5jZWxsKSlmb3IodmFyIGc9dC5nZXRJbmNvbWluZ0VkZ2VzKGYuY2VsbCksZj0wO2Y8Zy5sZW5ndGg7ZisrKW14VXRpbHMucmVtb3ZlKGdbZl0sYil9dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgaz1CLmNhbGwodGhpcyxiLGMpO2lmKGsubGVuZ3RoPT1iLmxlbmd0aClmb3IoZT0wO2U8Yi5sZW5ndGg7ZSsrKWlmKGEoYltlXSkpe3ZhciBsPXQuZ2V0SW5jb21pbmdFZGdlcyhrW2VdKSxnPXQuZ2V0SW5jb21pbmdFZGdlcyhiW2VdKTtpZigwPT1sLmxlbmd0aCYmMDxnLmxlbmd0aCl7dmFyIG09dGhpcy5jbG9uZUNlbGwoZ1swXSk7dGhpcy5hZGRFZGdlKG0sCnQuZ2V0RGVmYXVsdFBhcmVudCgpLHRoaXMubW9kZWwuZ2V0VGVybWluYWwoZ1swXSwhMCksa1tlXSl9fX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGt9O3ZhciBEPXQubW92ZUNlbGxzO3QubW92ZUNlbGxzPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGspe3ZhciBsPW51bGw7dGhpcy5tb2RlbC5iZWdpblVwZGF0ZSgpO3RyeXt2YXIgbT1mLG49dGhpcy5nZXRDdXJyZW50Q2VsbFN0eWxlKGYpO2lmKG51bGwhPWImJmEoZikmJiIxIj09bXhVdGlscy5nZXRWYWx1ZShuLCJ0cmVlRm9sZGluZyIsIjAiKSl7Zm9yKHZhciBwPTA7cDxiLmxlbmd0aDtwKyspaWYoYShiW3BdKXx8dC5tb2RlbC5pc0VkZ2UoYltwXSkmJm51bGw9PXQubW9kZWwuZ2V0VGVybWluYWwoYltwXSwhMCkpe2Y9dC5tb2RlbC5nZXRQYXJlbnQoYltwXSk7YnJlYWt9aWYobnVsbCE9bSYmZiE9bSYmbnVsbCE9dGhpcy52aWV3LmdldFN0YXRlKGJbMF0pKXt2YXIgcT10LmdldEluY29taW5nRWRnZXMoYlswXSk7CmlmKDA8cS5sZW5ndGgpe3ZhciB5PXQudmlldy5nZXRTdGF0ZSh0Lm1vZGVsLmdldFRlcm1pbmFsKHFbMF0sITApKTtpZihudWxsIT15KXt2YXIgej10LnZpZXcuZ2V0U3RhdGUobSk7bnVsbCE9eiYmKGM9KHouZ2V0Q2VudGVyWCgpLXkuZ2V0Q2VudGVyWCgpKS90LnZpZXcuc2NhbGUsZD0oei5nZXRDZW50ZXJZKCkteS5nZXRDZW50ZXJZKCkpL3Qudmlldy5zY2FsZSl9fX19bD1ELmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihudWxsIT1sJiZudWxsIT1iJiZsLmxlbmd0aD09Yi5sZW5ndGgpZm9yKHA9MDtwPGwubGVuZ3RoO3ArKylpZih0aGlzLm1vZGVsLmlzRWRnZShsW3BdKSlhKG0pJiYwPm14VXRpbHMuaW5kZXhPZihsLHRoaXMubW9kZWwuZ2V0VGVybWluYWwobFtwXSwhMCkpJiZ0aGlzLm1vZGVsLnNldFRlcm1pbmFsKGxbcF0sbSwhMCk7ZWxzZSBpZihhKGJbcF0pJiYocT10LmdldEluY29taW5nRWRnZXMoYltwXSksMDxxLmxlbmd0aCkpaWYoIWUpYShtKSYmMD5teFV0aWxzLmluZGV4T2YoYiwKdGhpcy5tb2RlbC5nZXRUZXJtaW5hbChxWzBdLCEwKSkmJnRoaXMubW9kZWwuc2V0VGVybWluYWwocVswXSxtLCEwKTtlbHNlIGlmKDA9PXQuZ2V0SW5jb21pbmdFZGdlcyhsW3BdKS5sZW5ndGgpe249bTtpZihudWxsPT1ufHxuPT10Lm1vZGVsLmdldFBhcmVudChiW3BdKSluPXQubW9kZWwuZ2V0VGVybWluYWwocVswXSwhMCk7ZT10aGlzLmNsb25lQ2VsbChxWzBdKTt0aGlzLmFkZEVkZ2UoZSx0LmdldERlZmF1bHRQYXJlbnQoKSxuLGxbcF0pfX1maW5hbGx5e3RoaXMubW9kZWwuZW5kVXBkYXRlKCl9cmV0dXJuIGx9O2lmKG51bGwhPXYuc2lkZWJhcil7dmFyIHo9di5zaWRlYmFyLmRyb3BBbmRDb25uZWN0O3Yuc2lkZWJhci5kcm9wQW5kQ29ubmVjdD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj10Lm1vZGVsLGc9bnVsbDtmLmJlZ2luVXBkYXRlKCk7dHJ5e2lmKGc9ei5hcHBseSh0aGlzLGFyZ3VtZW50cyksYShiKSlmb3IodmFyIGs9MDtrPGcubGVuZ3RoO2srKylpZihmLmlzRWRnZShnW2tdKSYmCm51bGw9PWYuZ2V0VGVybWluYWwoZ1trXSwhMCkpe2Yuc2V0VGVybWluYWwoZ1trXSxiLCEwKTt2YXIgbD10LmdldENlbGxHZW9tZXRyeShnW2tdKTtsLnBvaW50cz1udWxsO251bGwhPWwuZ2V0VGVybWluYWxQb2ludCghMCkmJmwuc2V0VGVybWluYWxQb2ludChudWxsLCEwKX19ZmluYWxseXtmLmVuZFVwZGF0ZSgpfXJldHVybiBnfX12YXIgRT17ODg6di5hY3Rpb25zLmdldCgic2VsZWN0Q2hpbGRyZW4iKSw4NDp2LmFjdGlvbnMuZ2V0KCJzZWxlY3RTdWJ0cmVlIiksODA6di5hY3Rpb25zLmdldCgic2VsZWN0UGFyZW50IiksODM6di5hY3Rpb25zLmdldCgic2VsZWN0U2libGluZ3MiKX0sRz12Lm9uS2V5RG93bjt2Lm9uS2V5RG93bj1mdW5jdGlvbihiKXt0cnl7aWYodC5pc0VuYWJsZWQoKSYmIXQuaXNFZGl0aW5nKCkmJmEodC5nZXRTZWxlY3Rpb25DZWxsKCkpJiYxPT10LmdldFNlbGVjdGlvbkNvdW50KCkpe3ZhciBjPW51bGw7MDx0LmdldEluY29taW5nRWRnZXModC5nZXRTZWxlY3Rpb25DZWxsKCkpLmxlbmd0aCYmCig5PT1iLndoaWNoP2M9bXhFdmVudC5pc1NoaWZ0RG93bihiKT9nKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKTpuKHQuZ2V0U2VsZWN0aW9uQ2VsbCgpKToxMz09Yi53aGljaCYmKGM9ZSh0LmdldFNlbGVjdGlvbkNlbGwoKSwhbXhFdmVudC5pc1NoaWZ0RG93bihiKSkpKTtpZihudWxsIT1jJiYwPGMubGVuZ3RoKTE9PWMubGVuZ3RoJiZ0Lm1vZGVsLmlzRWRnZShjWzBdKT90LnNldFNlbGVjdGlvbkNlbGwodC5tb2RlbC5nZXRUZXJtaW5hbChjWzBdLCExKSk6dC5zZXRTZWxlY3Rpb25DZWxsKGNbYy5sZW5ndGgtMV0pLG51bGwhPXYuaG92ZXJJY29ucyYmdi5ob3Zlckljb25zLnVwZGF0ZSh0LnZpZXcuZ2V0U3RhdGUodC5nZXRTZWxlY3Rpb25DZWxsKCkpKSx0LnN0YXJ0RWRpdGluZ0F0Q2VsbCh0LmdldFNlbGVjdGlvbkNlbGwoKSksbXhFdmVudC5jb25zdW1lKGIpO2Vsc2UgaWYobXhFdmVudC5pc0FsdERvd24oYikmJm14RXZlbnQuaXNTaGlmdERvd24oYikpe3ZhciBkPUVbYi5rZXlDb2RlXTsKbnVsbCE9ZCYmKGQuZnVuY3QoYiksbXhFdmVudC5jb25zdW1lKGIpKX1lbHNlIDM3PT1iLmtleUNvZGU/KHAodC5nZXRTZWxlY3Rpb25DZWxsKCksbXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpLG14RXZlbnQuY29uc3VtZShiKSk6Mzg9PWIua2V5Q29kZT8ocCh0LmdldFNlbGVjdGlvbkNlbGwoKSxteENvbnN0YW50cy5ESVJFQ1RJT05fTk9SVEgpLG14RXZlbnQuY29uc3VtZShiKSk6Mzk9PWIua2V5Q29kZT8ocCh0LmdldFNlbGVjdGlvbkNlbGwoKSxteENvbnN0YW50cy5ESVJFQ1RJT05fRUFTVCksbXhFdmVudC5jb25zdW1lKGIpKTo0MD09Yi5rZXlDb2RlJiYocCh0LmdldFNlbGVjdGlvbkNlbGwoKSxteENvbnN0YW50cy5ESVJFQ1RJT05fU09VVEgpLG14RXZlbnQuY29uc3VtZShiKSl9fWNhdGNoKEkpe3YuaGFuZGxlRXJyb3IoSSl9bXhFdmVudC5pc0NvbnN1bWVkKGIpfHxHLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIEY9dC5jb25uZWN0VmVydGV4O3QuY29ubmVjdFZlcnRleD0KZnVuY3Rpb24oYyxkLGYsayxsLG0pe3ZhciBwPXQuZ2V0SW5jb21pbmdFZGdlcyhjKTtyZXR1cm4gYShjKT8oZj1iKGMpLGs9Zj09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1R8fGY9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNULGw9ZD09bXhDb25zdGFudHMuRElSRUNUSU9OX0VBU1R8fGQ9PW14Q29uc3RhbnRzLkRJUkVDVElPTl9XRVNULGY9PWR8fDA9PXAubGVuZ3RoP24oYyxkKTprPT1sP2coYyk6ZShjLGQhPW14Q29uc3RhbnRzLkRJUkVDVElPTl9OT1JUSCYmZCE9bXhDb25zdGFudHMuRElSRUNUSU9OX1dFU1QpKTpGLmNhbGwodGhpcyxjLGQsZixrLGwsbSl9O3QuZ2V0U3VidHJlZT1mdW5jdGlvbihiKXt2YXIgZD1bYl07IWMoYikmJiFhKGIpfHxxKGIpfHx0LnRyYXZlcnNlKGIsITAsZnVuY3Rpb24oYSxiKXtudWxsIT1iJiYwPm14VXRpbHMuaW5kZXhPZihkLGIpJiZkLnB1c2goYik7MD5teFV0aWxzLmluZGV4T2YoZCxhKSYmZC5wdXNoKGEpO3JldHVybiEwfSk7cmV0dXJuIGR9Owp2YXIgSD1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmluaXQ7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7SC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7KGModGhpcy5zdGF0ZS5jZWxsKXx8YSh0aGlzLnN0YXRlLmNlbGwpKSYmIXEodGhpcy5zdGF0ZS5jZWxsKSYmMDx0aGlzLmdyYXBoLmdldE91dGdvaW5nRWRnZXModGhpcy5zdGF0ZS5jZWxsKS5sZW5ndGgmJih0aGlzLm1vdmVIYW5kbGU9bXhVdGlscy5jcmVhdGVJbWFnZShFZGl0b3IubW92ZUltYWdlKSx0aGlzLm1vdmVIYW5kbGUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIk1vdmUgU3VidHJlZSIpLHRoaXMubW92ZUhhbmRsZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLHRoaXMubW92ZUhhbmRsZS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiLHRoaXMubW92ZUhhbmRsZS5zdHlsZS53aWR0aD0iMjRweCIsdGhpcy5tb3ZlSGFuZGxlLnN0eWxlLmhlaWdodD0iMjRweCIsdGhpcy5ncmFwaC5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5tb3ZlSGFuZGxlKSwKbXhFdmVudC5hZGRHZXN0dXJlTGlzdGVuZXJzKHRoaXMubW92ZUhhbmRsZSxteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXt0aGlzLmdyYXBoLmdyYXBoSGFuZGxlci5zdGFydCh0aGlzLnN0YXRlLmNlbGwsbXhFdmVudC5nZXRDbGllbnRYKGEpLG14RXZlbnQuZ2V0Q2xpZW50WShhKSx0aGlzLmdyYXBoLmdldFN1YnRyZWUodGhpcy5zdGF0ZS5jZWxsKSk7dGhpcy5ncmFwaC5ncmFwaEhhbmRsZXIuY2VsbFdhc0NsaWNrZWQ9ITA7dGhpcy5ncmFwaC5pc01vdXNlVHJpZ2dlcj1teEV2ZW50LmlzTW91c2VFdmVudChhKTt0aGlzLmdyYXBoLmlzTW91c2VEb3duPSEwO3YuaG92ZXJJY29ucy5yZXNldCgpO214RXZlbnQuY29uc3VtZShhKX0pKSl9O3ZhciBKPW14VmVydGV4SGFuZGxlci5wcm90b3R5cGUucmVkcmF3SGFuZGxlcztteFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnJlZHJhd0hhbmRsZXM9ZnVuY3Rpb24oKXtKLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtudWxsIT10aGlzLm1vdmVIYW5kbGUmJgoodGhpcy5tb3ZlSGFuZGxlLnN0eWxlLmxlZnQ9dGhpcy5zdGF0ZS54K3RoaXMuc3RhdGUud2lkdGgrKDQwPnRoaXMuc3RhdGUud2lkdGg/MTA6MCkrMisicHgiLHRoaXMubW92ZUhhbmRsZS5zdHlsZS50b3A9dGhpcy5zdGF0ZS55K3RoaXMuc3RhdGUuaGVpZ2h0Kyg0MD50aGlzLnN0YXRlLmhlaWdodD8xMDowKSsyKyJweCIpfTt2YXIgdT1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLnNldEhhbmRsZXNWaXNpYmxlO214VmVydGV4SGFuZGxlci5wcm90b3R5cGUuc2V0SGFuZGxlc1Zpc2libGU9ZnVuY3Rpb24oYSl7dS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy5tb3ZlSGFuZGxlJiYodGhpcy5tb3ZlSGFuZGxlLnN0eWxlLmRpc3BsYXk9YT8iIjoibm9uZSIpfTt2YXIgSz1teFZlcnRleEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3k7bXhWZXJ0ZXhIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKGEsYil7Sy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9CnRoaXMubW92ZUhhbmRsZSYmKHRoaXMubW92ZUhhbmRsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubW92ZUhhbmRsZSksdGhpcy5tb3ZlSGFuZGxlPW51bGwpfX07aWYoInVuZGVmaW5lZCIhPT10eXBlb2YgU2lkZWJhcil7dmFyIGY9U2lkZWJhci5wcm90b3R5cGUuY3JlYXRlQWR2YW5jZWRTaGFwZXM7U2lkZWJhci5wcm90b3R5cGUuY3JlYXRlQWR2YW5jZWRTaGFwZXM9ZnVuY3Rpb24oKXt2YXIgYT1mLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxjPXRoaXMuZ3JhcGg7cmV0dXJuIGEuY29uY2F0KFt0aGlzLmFkZEVudHJ5KCJ0cmVlIGNvbnRhaW5lciIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJUcmVlIENvbnRhaW5lciIsbmV3IG14R2VvbWV0cnkoMCwwLDQwMCwzMjApLCJzd2ltbGFuZTtodG1sPTE7c3RhcnRTaXplPTIwO2hvcml6b250YWw9MTtjb250YWluZXJUeXBlPXRyZWU7Iik7YS52ZXJ0ZXg9ITA7dmFyIGM9bmV3IG14Q2VsbCgiUGFyZW50IixuZXcgbXhHZW9tZXRyeSgxNDAsCjYwLDEyMCw0MCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpO2MudmVydGV4PSEwO3ZhciBiPW5ldyBteENlbGwoIkNoaWxkIixuZXcgbXhHZW9tZXRyeSgxNDAsMTQwLDEyMCw0MCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpO2IudmVydGV4PSEwO3ZhciBkPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbGJvd0VkZ2VTdHlsZTtlbGJvdz12ZXJ0aWNhbDtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtyb3VuZGVkPTA7Iik7ZC5nZW9tZXRyeS5yZWxhdGl2ZT0KITA7ZC5lZGdlPSEwO2MuaW5zZXJ0RWRnZShkLCEwKTtiLmluc2VydEVkZ2UoZCwhMSk7YS5pbnNlcnQoZCk7YS5pbnNlcnQoYyk7YS5pbnNlcnQoYik7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBtaW5kbWFwIG1pbmRtYXBzIGNlbnRyYWwgaWRlYSBicmFuY2ggdG9waWMiLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiTWluZG1hcCIsbmV3IG14R2VvbWV0cnkoMCwwLDQyMCwxMjYpLCJzd2ltbGFuZTtodG1sPTE7c3RhcnRTaXplPTIwO2hvcml6b250YWw9MTtjb250YWluZXJUeXBlPXRyZWU7Iik7YS52ZXJ0ZXg9ITA7dmFyIGM9bmV3IG14Q2VsbCgiQ2VudHJhbCBJZGVhIixuZXcgbXhHZW9tZXRyeSgxNjAsNjAsMTAwLDQwKSwnZWxsaXBzZTt3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FsaWduPWNlbnRlcjt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7CmMudmVydGV4PSEwO3ZhciBiPW5ldyBteENlbGwoIlRvcGljIixuZXcgbXhHZW9tZXRyeSgzMjAsNDAsODAsMjApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO3JvdW5kZWQ9MTthcmNTaXplPTUwO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTtzdHJva2VXaWR0aD0xO2F1dG9zaXplPTE7c3BhY2luZz00O3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVudGl0eVJlbGF0aW9uRWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUiLCJzZWdtZW50IjoxMCwiY3VydmVkIjoxfTsnKTtiLnZlcnRleD0hMDt2YXIgZD1uZXcgbXhDZWxsKCIiLG5ldyBteEdlb21ldHJ5KDAsMCwwLDApLCJlZGdlU3R5bGU9ZW50aXR5UmVsYXRpb25FZGdlU3R5bGU7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7c2VnbWVudD0xMDtjdXJ2ZWQ9MTsiKTtkLmdlb21ldHJ5LnJlbGF0aXZlPSEwO2QuZWRnZT0hMDsKYy5pbnNlcnRFZGdlKGQsITApO2IuaW5zZXJ0RWRnZShkLCExKTt2YXIgZj1uZXcgbXhDZWxsKCJCcmFuY2giLG5ldyBteEdlb21ldHJ5KDMyMCw4MCw3MiwyNiksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7c2hhcGU9cGFydGlhbFJlY3RhbmdsZTt0b3A9MDtsZWZ0PTA7Ym90dG9tPTE7cmlnaHQ9MDtwb2ludHM9W1swLDFdLFsxLDFdXTtmaWxsQ29sb3I9bm9uZTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1ib3R0b207cm91dGluZ0NlbnRlclk9MC41O3NuYXBUb1BvaW50PTE7YXV0b3NpemU9MTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7Zi52ZXJ0ZXg9ITA7dmFyIGs9bmV3IG14Q2VsbCgiIixuZXcgbXhHZW9tZXRyeSgwLDAsMCwwKSwiZWRnZVN0eWxlPWVudGl0eVJlbGF0aW9uRWRnZVN0eWxlO3N0YXJ0QXJyb3c9bm9uZTtlbmRBcnJvdz1ub25lO3NlZ21lbnQ9MTA7Y3VydmVkPTE7Iik7CmsuZ2VvbWV0cnkucmVsYXRpdmU9ITA7ay5lZGdlPSEwO2MuaW5zZXJ0RWRnZShrLCEwKTtmLmluc2VydEVkZ2UoaywhMSk7dmFyIGw9bmV3IG14Q2VsbCgiVG9waWMiLG5ldyBteEdlb21ldHJ5KDIwLDQwLDgwLDIwKSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTtyb3VuZGVkPTE7YXJjU2l6ZT01MDthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7c3Ryb2tlV2lkdGg9MTthdXRvc2l6ZT0xO3NwYWNpbmc9NDt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7bC52ZXJ0ZXg9ITA7dmFyIHA9bmV3IG14Q2VsbCgiIixuZXcgbXhHZW9tZXRyeSgwLDAsMCwwKSwiZWRnZVN0eWxlPWVudGl0eVJlbGF0aW9uRWRnZVN0eWxlO3N0YXJ0QXJyb3c9bm9uZTtlbmRBcnJvdz1ub25lO3NlZ21lbnQ9MTA7Y3VydmVkPTE7Iik7CnAuZ2VvbWV0cnkucmVsYXRpdmU9ITA7cC5lZGdlPSEwO2MuaW5zZXJ0RWRnZShwLCEwKTtsLmluc2VydEVkZ2UocCwhMSk7dmFyIHY9bmV3IG14Q2VsbCgiQnJhbmNoIixuZXcgbXhHZW9tZXRyeSgyMCw4MCw3MiwyNiksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7c2hhcGU9cGFydGlhbFJlY3RhbmdsZTt0b3A9MDtsZWZ0PTA7Ym90dG9tPTE7cmlnaHQ9MDtwb2ludHM9W1swLDFdLFsxLDFdXTtmaWxsQ29sb3I9bm9uZTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1ib3R0b207cm91dGluZ0NlbnRlclk9MC41O3NuYXBUb1BvaW50PTE7YXV0b3NpemU9MTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7di52ZXJ0ZXg9ITA7dmFyIHQ9bmV3IG14Q2VsbCgiIixuZXcgbXhHZW9tZXRyeSgwLAowLDAsMCksImVkZ2VTdHlsZT1lbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZTtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtzZWdtZW50PTEwO2N1cnZlZD0xOyIpO3QuZ2VvbWV0cnkucmVsYXRpdmU9ITA7dC5lZGdlPSEwO2MuaW5zZXJ0RWRnZSh0LCEwKTt2Lmluc2VydEVkZ2UodCwhMSk7YS5pbnNlcnQoZCk7YS5pbnNlcnQoayk7YS5pbnNlcnQocCk7YS5pbnNlcnQodCk7YS5pbnNlcnQoYyk7YS5pbnNlcnQoYik7YS5pbnNlcnQoZik7YS5pbnNlcnQobCk7YS5pbnNlcnQodik7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBtaW5kbWFwIG1pbmRtYXBzIGNlbnRyYWwgaWRlYSIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJDZW50cmFsIElkZWEiLG5ldyBteEdlb21ldHJ5KDAsMCwxMDAsNDApLCdlbGxpcHNlO3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YWxpZ249Y2VudGVyO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVudGl0eVJlbGF0aW9uRWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUiLCJzZWdtZW50IjoxMCwiY3VydmVkIjoxfTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTsnKTsKYS52ZXJ0ZXg9ITA7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBtaW5kbWFwIG1pbmRtYXBzIGJyYW5jaCIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJCcmFuY2giLG5ldyBteEdlb21ldHJ5KDAsMCw4MCwyMCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7c2hhcGU9cGFydGlhbFJlY3RhbmdsZTt0b3A9MDtsZWZ0PTA7Ym90dG9tPTE7cmlnaHQ9MDtwb2ludHM9W1swLDFdLFsxLDFdXTtmaWxsQ29sb3I9bm9uZTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1ib3R0b207cm91dGluZ0NlbnRlclk9MC41O3NuYXBUb1BvaW50PTE7cmVjdXJzaXZlUmVzaXplPTA7YXV0b3NpemU9MTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7CmEudmVydGV4PSEwO3ZhciBjPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZTtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtzZWdtZW50PTEwO2N1cnZlZD0xOyIpO2MuZ2VvbWV0cnkuc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludCgtNDAsNDApLCEwKTtjLmdlb21ldHJ5LnJlbGF0aXZlPSEwO2MuZWRnZT0hMDthLmluc2VydEVkZ2UoYywhMSk7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthLGNdLGEuZ2VvbWV0cnkud2lkdGgsYS5nZW9tZXRyeS5oZWlnaHQsYS52YWx1ZSl9KSx0aGlzLmFkZEVudHJ5KCJ0cmVlIG1pbmRtYXAgbWluZG1hcHMgc3ViIHRvcGljIixmdW5jdGlvbigpe3ZhciBhPW5ldyBteENlbGwoIlN1YiBUb3BpYyIsbmV3IG14R2VvbWV0cnkoMCwwLDcyLDI2KSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTtyb3VuZGVkPTE7YXJjU2l6ZT01MDthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7c3Ryb2tlV2lkdGg9MTthdXRvc2l6ZT0xO3NwYWNpbmc9NDt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIiwic2VnbWVudCI6MTAsImN1cnZlZCI6MX07Jyk7CmEudmVydGV4PSEwO3ZhciBjPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbnRpdHlSZWxhdGlvbkVkZ2VTdHlsZTtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtzZWdtZW50PTEwO2N1cnZlZD0xOyIpO2MuZ2VvbWV0cnkuc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludCgtNDAsNDApLCEwKTtjLmdlb21ldHJ5LnJlbGF0aXZlPSEwO2MuZWRnZT0hMDthLmluc2VydEVkZ2UoYywhMSk7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthLGNdLGEuZ2VvbWV0cnkud2lkdGgsYS5nZW9tZXRyeS5oZWlnaHQsYS52YWx1ZSl9KSx0aGlzLmFkZEVudHJ5KCJ0cmVlIG9yZ2NoYXJ0IG9yZ2FuaXphdGlvbiBkaXZpc2lvbiIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJPcmdjaGFydCIsbmV3IG14R2VvbWV0cnkoMCwwLDI4MCwyMjApLCdzd2ltbGFuZTtodG1sPTE7c3RhcnRTaXplPTIwO2hvcml6b250YWw9MTtjb250YWluZXJUeXBlPXRyZWU7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpOwphLnZlcnRleD0hMDt2YXIgZD1uZXcgbXhDZWxsKCJPcmdhbml6YXRpb24iLG5ldyBteEdlb21ldHJ5KDgwLDQwLDEyMCw2MCksJ3doaXRlU3BhY2U9d3JhcDtodG1sPTE7YWxpZ249Y2VudGVyO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xO25ld0VkZ2VTdHlsZT17ImVkZ2VTdHlsZSI6ImVsYm93RWRnZVN0eWxlIiwic3RhcnRBcnJvdyI6Im5vbmUiLCJlbmRBcnJvdyI6Im5vbmUifTsnKTtjLnNldEF0dHJpYnV0ZUZvckNlbGwoZCwidHJlZVJvb3QiLCIxIik7ZC52ZXJ0ZXg9ITA7dmFyIGI9bmV3IG14Q2VsbCgiRGl2aXNpb24iLG5ldyBteEdlb21ldHJ5KDIwLDE0MCwxMDAsNjApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbGJvd0VkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIn07Jyk7CmIudmVydGV4PSEwO3ZhciBlPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbGJvd0VkZ2VTdHlsZTtlbGJvdz12ZXJ0aWNhbDtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtyb3VuZGVkPTA7Iik7ZS5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtlLmVkZ2U9ITA7ZC5pbnNlcnRFZGdlKGUsITApO2IuaW5zZXJ0RWRnZShlLCExKTt2YXIgZj1uZXcgbXhDZWxsKCJEaXZpc2lvbiIsbmV3IG14R2VvbWV0cnkoMTYwLDE0MCwxMDAsNjApLCd3aGl0ZVNwYWNlPXdyYXA7aHRtbD0xO2FsaWduPWNlbnRlcjt2ZXJ0aWNhbEFsaWduPW1pZGRsZTt0cmVlRm9sZGluZz0xO3RyZWVNb3Zpbmc9MTtuZXdFZGdlU3R5bGU9eyJlZGdlU3R5bGUiOiJlbGJvd0VkZ2VTdHlsZSIsInN0YXJ0QXJyb3ciOiJub25lIiwiZW5kQXJyb3ciOiJub25lIn07Jyk7Zi52ZXJ0ZXg9ITA7dmFyIGs9bmV3IG14Q2VsbCgiIixuZXcgbXhHZW9tZXRyeSgwLDAsMCwwKSwiZWRnZVN0eWxlPWVsYm93RWRnZVN0eWxlO2VsYm93PXZlcnRpY2FsO3N0YXJ0QXJyb3c9bm9uZTtlbmRBcnJvdz1ub25lO3JvdW5kZWQ9MDsiKTsKay5nZW9tZXRyeS5yZWxhdGl2ZT0hMDtrLmVkZ2U9ITA7ZC5pbnNlcnRFZGdlKGssITApO2YuaW5zZXJ0RWRnZShrLCExKTthLmluc2VydChlKTthLmluc2VydChrKTthLmluc2VydChkKTthLmluc2VydChiKTthLmluc2VydChmKTtyZXR1cm4gc2IuY3JlYXRlVmVydGV4VGVtcGxhdGVGcm9tQ2VsbHMoW2FdLGEuZ2VvbWV0cnkud2lkdGgsYS5nZW9tZXRyeS5oZWlnaHQsYS52YWx1ZSl9KSx0aGlzLmFkZEVudHJ5KCJ0cmVlIHJvb3QiLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IG14Q2VsbCgiT3JnYW5pemF0aW9uIixuZXcgbXhHZW9tZXRyeSgwLDAsMTIwLDYwKSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTthbGlnbj1jZW50ZXI7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpO2Muc2V0QXR0cmlidXRlRm9yQ2VsbChhLCJ0cmVlUm9vdCIsCiIxIik7YS52ZXJ0ZXg9ITA7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthXSxhLmdlb21ldHJ5LndpZHRoLGEuZ2VvbWV0cnkuaGVpZ2h0LGEudmFsdWUpfSksdGhpcy5hZGRFbnRyeSgidHJlZSBkaXZpc2lvbiIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJEaXZpc2lvbiIsbmV3IG14R2VvbWV0cnkoMjAsNDAsMTAwLDYwKSwnd2hpdGVTcGFjZT13cmFwO2h0bWw9MTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7bmV3RWRnZVN0eWxlPXsiZWRnZVN0eWxlIjoiZWxib3dFZGdlU3R5bGUiLCJzdGFydEFycm93Ijoibm9uZSIsImVuZEFycm93Ijoibm9uZSJ9OycpO2EudmVydGV4PSEwO3ZhciBjPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1lbGJvd0VkZ2VTdHlsZTtlbGJvdz12ZXJ0aWNhbDtzdGFydEFycm93PW5vbmU7ZW5kQXJyb3c9bm9uZTtyb3VuZGVkPTA7Iik7CmMuZ2VvbWV0cnkuc2V0VGVybWluYWxQb2ludChuZXcgbXhQb2ludCgwLDApLCEwKTtjLmdlb21ldHJ5LnJlbGF0aXZlPSEwO2MuZWRnZT0hMDthLmluc2VydEVkZ2UoYywhMSk7cmV0dXJuIHNiLmNyZWF0ZVZlcnRleFRlbXBsYXRlRnJvbUNlbGxzKFthLGNdLGEuZ2VvbWV0cnkud2lkdGgsYS5nZW9tZXRyeS5oZWlnaHQsYS52YWx1ZSl9KSx0aGlzLmFkZEVudHJ5KCJ0cmVlIHN1YiBzZWN0aW9ucyIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgbXhDZWxsKCJTdWIgU2VjdGlvbiIsbmV3IG14R2VvbWV0cnkoMCwwLDEwMCw2MCksIndoaXRlU3BhY2U9d3JhcDtodG1sPTE7YWxpZ249Y2VudGVyO3ZlcnRpY2FsQWxpZ249bWlkZGxlO3RyZWVGb2xkaW5nPTE7dHJlZU1vdmluZz0xOyIpO2EudmVydGV4PSEwO3ZhciBjPW5ldyBteENlbGwoIiIsbmV3IG14R2VvbWV0cnkoMCwwLDAsMCksImVkZ2VTdHlsZT1vcnRob2dvbmFsRWRnZVN0eWxlO3N0YXJ0QXJyb3c9bm9uZTtlbmRBcnJvdz1ub25lO3JvdW5kZWQ9MDt0YXJnZXRQb3J0Q29uc3RyYWludD1lYXN0d2VzdDtzb3VyY2VQb3J0Q29uc3RyYWludD1ub3J0aHNvdXRoOyIpOwpjLmdlb21ldHJ5LnNldFRlcm1pbmFsUG9pbnQobmV3IG14UG9pbnQoMTEwLC00MCksITApO2MuZ2VvbWV0cnkucmVsYXRpdmU9ITA7Yy5lZGdlPSEwO2EuaW5zZXJ0RWRnZShjLCExKTt2YXIgYj1uZXcgbXhDZWxsKCJTdWIgU2VjdGlvbiIsbmV3IG14R2VvbWV0cnkoMTIwLDAsMTAwLDYwKSwid2hpdGVTcGFjZT13cmFwO2h0bWw9MTthbGlnbj1jZW50ZXI7dmVydGljYWxBbGlnbj1taWRkbGU7dHJlZUZvbGRpbmc9MTt0cmVlTW92aW5nPTE7Iik7Yi52ZXJ0ZXg9ITA7dmFyIGQ9bmV3IG14Q2VsbCgiIixuZXcgbXhHZW9tZXRyeSgwLDAsMCwwKSwiZWRnZVN0eWxlPW9ydGhvZ29uYWxFZGdlU3R5bGU7c3RhcnRBcnJvdz1ub25lO2VuZEFycm93PW5vbmU7cm91bmRlZD0wO3RhcmdldFBvcnRDb25zdHJhaW50PWVhc3R3ZXN0O3NvdXJjZVBvcnRDb25zdHJhaW50PW5vcnRoc291dGg7Iik7ZC5nZW9tZXRyeS5zZXRUZXJtaW5hbFBvaW50KG5ldyBteFBvaW50KDExMCwtNDApLCEwKTtkLmdlb21ldHJ5LnJlbGF0aXZlPQohMDtkLmVkZ2U9ITA7Yi5pbnNlcnRFZGdlKGQsITEpO3JldHVybiBzYi5jcmVhdGVWZXJ0ZXhUZW1wbGF0ZUZyb21DZWxscyhbYyxkLGEsYl0sMjIwLDYwLCJTdWIgU2VjdGlvbnMiKX0pXSl9fX0pKCk7RWRpdG9yVWkuaW5pdE1pbmltYWxUaGVtZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXt2YXIgYz1hLmVkaXRvci5ncmFwaDtjLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKTtudWxsPT1hLmZvcm1hdFdpbmRvdz8oYS5mb3JtYXRXaW5kb3c9bmV3IGsoYSxteFJlc291cmNlcy5nZXQoImZvcm1hdCIpLE1hdGgubWF4KDIwLGEuZGlhZ3JhbUNvbnRhaW5lci5jbGllbnRXaWR0aC0yNDAtMTIpLDU2LDI0MCxNYXRoLm1pbig1NjYsYy5jb250YWluZXIuY2xpZW50SGVpZ2h0LTEwKSxmdW5jdGlvbihiKXtiPWEuY3JlYXRlRm9ybWF0KGIpO2IuaW5pdCgpO3JldHVybiBifSksYS5mb3JtYXRXaW5kb3cud2luZG93Lm1pbmltdW1TaXplPW5ldyBteFJlY3RhbmdsZSgwLDAsMjQwLDgwKSxhLmZvcm1hdFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMCkpOmEuZm9ybWF0V2luZG93LndpbmRvdy5zZXRWaXNpYmxlKG51bGwhPWI/YjohYS5mb3JtYXRXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpKTsKYS5mb3JtYXRXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpJiZhLmZvcm1hdFdpbmRvdy53aW5kb3cuZml0KCl9ZnVuY3Rpb24gYyhhLGIpe3ZhciBjPWEuZWRpdG9yLmdyYXBoO2MucG9wdXBNZW51SGFuZGxlci5oaWRlTWVudSgpO25ldyBteFJlY3RhbmdsZTtpZihudWxsPT1hLnNpZGViYXJXaW5kb3cpe3ZhciBkPU1hdGgubWluKGMuY29udGFpbmVyLmNsaWVudFdpZHRoLTEwLDIxOCk7YS5zaWRlYmFyV2luZG93PW5ldyBrKGEsbXhSZXNvdXJjZXMuZ2V0KCJzaGFwZXMiKSwxMCw1NixkLTYsTWF0aC5taW4oNjUwLGMuY29udGFpbmVyLmNsaWVudEhlaWdodC0zMCksZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe3ZhciBmPWEubWVudXMuZ2V0KGMpLGc9ZS5hZGRNZW51KGQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtmLmZ1bmN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pKTtnLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOmFic29sdXRlO2JvcmRlci10b3A6MXB4IHNvbGlkIGxpZ2h0Z3JheTt3aWR0aDo1MCU7aGVpZ2h0OjI0cHg7Ym90dG9tOjBweDt0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjZweCAwIDAgMDtjdXNvcjpwb2ludGVyOyI7CmcuY2xhc3NOYW1lPSJnZVRpdGxlIjtiLmFwcGVuZENoaWxkKGcpO3JldHVybiBnfXZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Quc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7Ym9yZGVyLXRvcDoxcHggc29saWQgbGlnaHRncmF5O2hlaWdodDoyNHB4O2JvdHRvbTozMXB4O3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6NnB4IDAgMCAwOyI7ZC5jbGFzc05hbWU9ImdlVGl0bGUiO2QuaW5uZXJIVE1MPSc8c3BhbiBzdHlsZT0iZm9udC1zaXplOjE4cHg7bWFyZ2luLXJpZ2h0OjVweDsiPis8L3NwYW4+JztteFV0aWxzLndyaXRlKGQsbXhSZXNvdXJjZXMuZ2V0KCJtb3JlU2hhcGVzIikpO2IuYXBwZW5kQ2hpbGQoZCk7bXhFdmVudC5hZGRMaXN0ZW5lcihkLCJjbGljayIsZnVuY3Rpb24oKXthLmFjdGlvbnMuZ2V0KCJzaGFwZXMiKS5mdW5jdCgpfSk7dmFyIGU9bmV3IE1lbnViYXIoYSxiKTtpZighRWRpdG9yLmVuYWJsZUN1c3RvbUxpYnJhcmllc3x8CiIxIj09dXJsUGFyYW1zLmVtYmVkJiYiMSIhPXVybFBhcmFtcy5saWJyYXJpZXMpZC5zdHlsZS5ib3R0b209IjAiO2Vsc2UgaWYobnVsbCE9YS5hY3Rpb25zLmdldCgibmV3TGlicmFyeSIpKXtkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Quc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDowcHg7d2lkdGg6NTAlO2JvcmRlci10b3A6MXB4IHNvbGlkIGxpZ2h0Z3JheTtoZWlnaHQ6MzBweDtib3R0b206MHB4O3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MHB4OyI7ZC5jbGFzc05hbWU9ImdlVGl0bGUiO3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTtmLnN0eWxlLmNzc1RleHQ9InBvc2l0aW9uOnJlbGF0aXZlO3RvcDo2cHg7IjtteFV0aWxzLndyaXRlKGYsbXhSZXNvdXJjZXMuZ2V0KCJuZXdMaWJyYXJ5IikpO2QuYXBwZW5kQ2hpbGQoZik7Yi5hcHBlbmRDaGlsZChkKTtteEV2ZW50LmFkZExpc3RlbmVyKGQsCiJjbGljayIsYS5hY3Rpb25zLmdldCgibmV3TGlicmFyeSIpLmZ1bmN0KTtkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Quc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7d2lkdGg6NTAlO2JvcmRlci10b3A6MXB4IHNvbGlkIGxpZ2h0Z3JheTtoZWlnaHQ6MzBweDtib3R0b206MHB4O3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MHB4O2JvcmRlci1sZWZ0OiAxcHggc29saWQgbGlnaHRncmF5OyI7ZC5jbGFzc05hbWU9ImdlVGl0bGUiO2Y9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic3BhbiIpO2Yuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246cmVsYXRpdmU7dG9wOjZweDsiO214VXRpbHMud3JpdGUoZixteFJlc291cmNlcy5nZXQoIm9wZW5MaWJyYXJ5IikpO2QuYXBwZW5kQ2hpbGQoZik7Yi5hcHBlbmRDaGlsZChkKTtteEV2ZW50LmFkZExpc3RlbmVyKGQsImNsaWNrIixhLmFjdGlvbnMuZ2V0KCJvcGVuTGlicmFyeSIpLmZ1bmN0KX1lbHNlIGQ9CmMoIm5ld0xpYnJhcnkiLG14UmVzb3VyY2VzLmdldCgibmV3TGlicmFyeSIpKSxkLnN0eWxlLmJveFNpemluZz0iYm9yZGVyLWJveCIsZC5zdHlsZS5wYWRkaW5nUmlnaHQ9IjZweCIsZC5zdHlsZS5wYWRkaW5nTGVmdD0iNnB4IixkLnN0eWxlLmhlaWdodD0iMzJweCIsZC5zdHlsZS5sZWZ0PSIwIixkPWMoIm9wZW5MaWJyYXJ5RnJvbSIsbXhSZXNvdXJjZXMuZ2V0KCJvcGVuTGlicmFyeUZyb20iKSksZC5zdHlsZS5ib3JkZXJMZWZ0PSIxcHggc29saWQgbGlnaHRncmF5IixkLnN0eWxlLmJveFNpemluZz0iYm9yZGVyLWJveCIsZC5zdHlsZS5wYWRkaW5nUmlnaHQ9IjZweCIsZC5zdHlsZS5wYWRkaW5nTGVmdD0iNnB4IixkLnN0eWxlLmhlaWdodD0iMzJweCIsZC5zdHlsZS5sZWZ0PSI1MCUiO2IuYXBwZW5kQ2hpbGQoYS5zaWRlYmFyLmNvbnRhaW5lcik7Yi5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtyZXR1cm4gYn0pO2Euc2lkZWJhcldpbmRvdy53aW5kb3cubWluaW11bVNpemU9bmV3IG14UmVjdGFuZ2xlKDAsCjAsOTAsOTApO2Euc2lkZWJhcldpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMCk7YS5nZXRMb2NhbERhdGEoInNpZGViYXIiLGZ1bmN0aW9uKGIpe2Euc2lkZWJhci5zaG93RW50cmllcyhiLG51bGwsITApfSk7YS5yZXN0b3JlTGlicmFyaWVzKCl9ZWxzZSBhLnNpZGViYXJXaW5kb3cud2luZG93LnNldFZpc2libGUobnVsbCE9Yj9iOiFhLnNpZGViYXJXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpKTthLnNpZGViYXJXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpJiZhLnNpZGViYXJXaW5kb3cud2luZG93LmZpdCgpfWlmKCIxIj09dXJsUGFyYW1zLmxpZ2h0Ym94fHwiMCI9PXVybFBhcmFtcy5jaHJvbWV8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHdpbmRvdy5Gb3JtYXR8fCJ1bmRlZmluZWQiPT09dHlwZW9mIHdpbmRvdy5NZW51cyl3aW5kb3cudWlUaGVtZT1udWxsO2Vsc2V7dmFyIGY9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDsKdHJ5e3ZhciBkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7ZC50eXBlPSJ0ZXh0L2NzcyI7ZC5pbm5lckhUTUw9IiogeyAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDsgfWh0bWwgYm9keSAubXhXaW5kb3cgYnV0dG9uLmdlQnRuIHsgZm9udC1zaXplOjEycHggIWltcG9ydGFudDsgbWFyZ2luLWxlZnQ6IDA7IH1odG1sIGJvZHkgdGFibGUubXhXaW5kb3cgdGQubXhXaW5kb3dQYW5lIGRpdi5teFdpbmRvd1BhbmUgKjpub3Qoc3ZnICopIHsgZm9udC1zaXplOjlwdDsgfXRhYmxlLm14V2luZG93ICogOm5vdChzdmcgKikgeyBmb250LXNpemU6MTNweDsgfWh0bWwgYm9keSBkaXYuZGlhZ3JhbUNvbnRhaW5lciBidXR0b24sIGh0bWwgYm9keSBidXR0b24uZ2VCdG4geyBmb250LXNpemU6MTRweDsgZm9udC13ZWlnaHQ6NzAwO2JvcmRlci1yYWRpdXM6IDVweDsgfWh0bWwgYm9keSBidXR0b24uZ2VCdG46YWN0aXZlIHsgb3BhY2l0eTogMC42OyB9aHRtbCBib2R5IGEuZ2VNZW51SXRlbSB7IG9wYWNpdHk6IDAuNzU7IGN1cnNvcjogcG9pbnRlcjsgdXNlci1zZWxlY3Q6bm9uZTsgfWh0bWwgYm9keSBhLmdlTWVudUl0ZW1bZGlzYWJsZWRdIHsgb3BhY2l0eTogMC4yOyB9aHRtbCBib2R5IGEuZ2VNZW51SXRlbVtkaXNhYmxlZF06YWN0aXZlIHsgb3BhY2l0eTogMC4yOyB9aHRtbCBib2R5IGRpdi5nZUFjdGl2ZVBhZ2UgeyBvcGFjaXR5OiAwLjc7IH1odG1sIGJvZHkgYS5nZU1lbnVJdGVtOmFjdGl2ZSB7IG9wYWNpdHk6IDAuMjsgfWh0bWwgYm9keSAuZ2VUb29sYmFyQnV0dG9uIHsgb3BhY2l0eTogMC4zOyB9aHRtbCBib2R5IC5nZVRvb2xiYXJCdXR0b246YWN0aXZlIHsgb3BhY2l0eTogMC4xNTsgfWh0bWwgYm9keSAuZ2VTdGF0dXM6YWN0aXZlIHsgb3BhY2l0eTogMC41OyB9aHRtbCB0YWJsZS5teFBvcHVwTWVudSB0ci5teFBvcHVwTWVudUl0ZW1Ib3ZlcjphY3RpdmUgeyBvcGFjaXR5OjAuNzsgfWh0bWwgYm9keSAuZ2VEaWFsb2cgaW5wdXQsIGh0bWwgYm9keSAuZ2VUb29sYmFyQ29udGFpbmVyIGlucHV0LCBodG1sIGJvZHkgLm14V2luZG93IGlucHV0IHtwYWRkaW5nOjJweDtkaXNwbGF5OmlubGluZS1ibG9jazsgfWRpdi5nZURpYWxvZyB7IGJvcmRlci1yYWRpdXM6IDVweDsgfWh0bWwgYm9keSBkaXYuZ2VEaWFsb2cgYnV0dG9uLmdlQmlnQnV0dG9uIHsgY29sb3I6ICNmZmYgIWltcG9ydGFudDsgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7IH0ubXhXaW5kb3cgYnV0dG9uLCAuZ2VEaWFsb2cgc2VsZWN0LCAubXhXaW5kb3cgc2VsZWN0IHsgZGlzcGxheTppbmxpbmUtYmxvY2s7IH1odG1sIGJvZHkgLm14V2luZG93IC5nZUNvbG9yQnRuLCBodG1sIGJvZHkgLmdlRGlhbG9nIC5nZUNvbG9yQnRuIHsgYmFja2dyb3VuZDogbm9uZTsgfWh0bWwgYm9keSBkaXYuZGlhZ3JhbUNvbnRhaW5lciBidXR0b24sIGh0bWwgYm9keSAubXhXaW5kb3cgYnV0dG9uLCBodG1sIGJvZHkgLmdlRGlhbG9nIGJ1dHRvbiB7IG1pbi13aWR0aDogMHB4OyBib3JkZXItcmFkaXVzOiA1cHg7IGNvbG9yOiAjMzUzNTM1ICFpbXBvcnRhbnQ7IGJvcmRlci1zdHlsZTogc29saWQ7IGJvcmRlci13aWR0aDogMXB4OyBib3JkZXItY29sb3I6IHJnYigyMTYsIDIxNiwgMjE2KTsgfWh0bWwgYm9keSBkaXYuZGlhZ3JhbUNvbnRhaW5lciBidXR0b246aG92ZXIsIGh0bWwgYm9keSAubXhXaW5kb3cgYnV0dG9uOmhvdmVyLCBodG1sIGJvZHkgLmdlRGlhbG9nIGJ1dHRvbjpob3ZlciB7IGJvcmRlci1jb2xvcjogcmdiKDE3NywgMTc3LCAxNzcpOyB9aHRtbCBib2R5IGRpdi5kaWFncmFtQ29udGFpbmVyIGJ1dHRvbjphY3RpdmUsIGh0bWwgYm9keSAubXhXaW5kb3cgYnV0dG9uOmFjdGl2ZSwgaHRtbCBib2R5IC5nZURpYWxvZyBidXR0b246YWN0aXZlIHsgb3BhY2l0eTogMC42OyB9ZGl2LmRpYWdyYW1Db250YWluZXIgYnV0dG9uLmdlQnRuLCAubXhXaW5kb3cgYnV0dG9uLmdlQnRuLCAuZ2VEaWFsb2cgYnV0dG9uLmdlQnRuIHsgbWluLXdpZHRoOjcycHg7IGZvbnQtd2VpZ2h0OiA2MDA7IGJhY2tncm91bmQ6IG5vbmU7IH1kaXYuZGlhZ3JhbUNvbnRhaW5lciBidXR0b24uZ2VQcmltYXJ5QnRuLCAubXhXaW5kb3cgYnV0dG9uLmdlUHJpbWFyeUJ0biwgLmdlRGlhbG9nIGJ1dHRvbi5nZVByaW1hcnlCdG4sIGh0bWwgYm9keSAuZ2VQcmltYXJ5QnRuIHsgYmFja2dyb3VuZDogIzI5YjZmMjsgY29sb3I6ICNmZmYgIWltcG9ydGFudDsgYm9yZGVyOiBub25lOyBib3gtc2hhZG93OiBub25lOyB9aHRtbCBib2R5IC5nZVByaW1hcnlCdG46aG92ZXIgeyBiYWNrZ3JvdW5kOiAjMjliNmYyOyBib3JkZXI6IG5vbmU7IGJveC1zaGFkb3c6IGluaGVyaXQ7IH1odG1sIGJvZHkgYnV0dG9uLmdlUHJpbWFyeUJ0bjpob3ZlciB7IGJhY2tncm91bmQ6ICMyOWI2ZjI7IGJvcmRlcjogbm9uZTsgfS5nZUJ0biBidXR0b24geyBtaW4td2lkdGg6NzJweCAhaW1wb3J0YW50OyB9ZGl2LmdlVG9vbGJhckNvbnRhaW5lciBhLmdlQnV0dG9uIHsgbWFyZ2luOjBweDsgcGFkZGluZzogMCAycHggNHB4IDJweDsgfSAuZ2VEaWFsb2csIC5teFdpbmRvdyB0ZC5teFdpbmRvd1BhbmUgKiwgZGl2LmdlU3ByaXRlLCB0ZC5teFdpbmRvd1RpdGxlLCAuZ2VEaWFncmFtQ29udGFpbmVyIHsgYm94LXNpemluZzpjb250ZW50LWJveDsgfS5teFdpbmRvdyBkaXYgYnV0dG9uLmdlU3R5bGVCdXR0b24geyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9dGFibGUubXhXaW5kb3cgdGQubXhXaW5kb3dQYW5lIGJ1dHRvbi5nZUNvbG9yQnRuIHsgcGFkZGluZzowcHg7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH10ZC5teFdpbmRvd1BhbmUgLmdlU2lkZWJhckNvbnRhaW5lciBidXR0b24geyBwYWRkaW5nOjJweDsgYm94LXNpemluZzogYm9yZGVyLWJveDsgfWh0bWwgYm9keSAuZ2VNZW51SXRlbSB7IGZvbnQtc2l6ZToxNHB4OyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IHBhZGRpbmc6IDZweCAxMHB4IDZweCAxMHB4OyBib3JkZXI6IG5vbmU7IGJvcmRlci1yYWRpdXM6IDVweDsgY29sb3I6ICMzNTM1MzU7IGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCByZ2JhKDAsMCwwLC4xMSksIGluc2V0IDAgLTFweCAwIDAgcmdiYSgwLDAsMCwuMDgpLCAwIDFweCAycHggMCByZ2JhKDAsMCwwLC4wNCk7IH0uZ2VUb29sYmFyQ29udGFpbmVyIHsgYmFja2dyb3VuZDojZmZmICFpbXBvcnRhbnQ7IH1kaXYuZ2VTaWRlYmFyQ29udGFpbmVyIHsgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjsgfWRpdi5nZVNpZGViYXJDb250YWluZXIgLmdlVGl0bGUgeyBiYWNrZ3JvdW5kLWNvbG9yOiNmZGZkZmQ7IH1kaXYubXhXaW5kb3cgdGQubXhXaW5kb3dQYW5lIGJ1dHRvbiB7IGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IGZsb2F0OiBub25lOyB9dGQubXhXaW5kb3dUaXRsZSB7IGhlaWdodDogMjJweCAhaW1wb3J0YW50OyBiYWNrZ3JvdW5kOiBub25lICFpbXBvcnRhbnQ7IGZvbnQtc2l6ZTogMTNweCAhaW1wb3J0YW50OyB0ZXh0LWFsaWduOmNlbnRlciAhaW1wb3J0YW50OyBib3JkZXItYm90dG9tOjFweCBzb2xpZCBsaWdodGdyYXk7IH1kaXYubXhXaW5kb3csIGRpdi5teFdpbmRvd1RpdGxlIHsgYmFja2dyb3VuZC1pbWFnZTogbm9uZSAhaW1wb3J0YW50OyBiYWNrZ3JvdW5kLWNvbG9yOiNmZmYgIWltcG9ydGFudDsgfWRpdi5teFdpbmRvdyB7IGJvcmRlci1yYWRpdXM6NXB4OyBib3gtc2hhZG93OiAwcHggMHB4IDJweCAjQzBDMEMwICFpbXBvcnRhbnQ7fWRpdi5teFdpbmRvdyAqIHsgZm9udC1mYW1pbHk6IGluaGVyaXQgIWltcG9ydGFudDsgfWh0bWwgZGl2LmdlVmVydGljYWxIYW5kbGUgeyBwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MHB4O2xlZnQ6NTAlO2N1cnNvcjpyb3ctcmVzaXplO3dpZHRoOjExcHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZDp3aGl0ZTttYXJnaW4tYm90dG9tOi02cHg7IG1hcmdpbi1sZWZ0Oi02cHg7IGJvcmRlcjogbm9uZTsgYm9yZGVyLXJhZGl1czogNnB4OyBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggcmdiYSgwLDAsMCwuMTEpLCBpbnNldCAwIC0xcHggMCAwIHJnYmEoMCwwLDAsLjA4KSwgMCAxcHggMnB4IDAgcmdiYSgwLDAsMCwuMDQpOyB9aHRtbCBkaXYuZ2VJbmFjdGl2ZVBhZ2UgeyBiYWNrZ3JvdW5kOiByZ2IoMjQ5LCAyNDksIDI0OSkgIWltcG9ydGFudDsgY29sb3I6ICNBMEEwQTAgIWltcG9ydGFudDsgfSBodG1sIGRpdi5nZUFjdGl2ZVBhZ2UgeyBiYWNrZ3JvdW5kOiB3aGl0ZSAhaW1wb3J0YW50O2NvbG9yOiAjMzUzNTM1ICFpbXBvcnRhbnQ7IH0gaHRtbCBkaXYubXhSdWJiZXJiYW5kIHsgYm9yZGVyOjFweCBzb2xpZDsgYm9yZGVyLWNvbG9yOiAjMjliNmYyICFpbXBvcnRhbnQ7IGJhY2tncm91bmQ6cmdiYSg0MSwxODIsMjQyLDAuNCkgIWltcG9ydGFudDsgfSBodG1sIGJvZHkgZGl2Lm14UG9wdXBNZW51IHsgYm9yZGVyLXJhZGl1czo1cHg7IGJvcmRlcjoxcHggc29saWQgI2MwYzBjMDsgcGFkZGluZzo1cHggMCA1cHggMDsgYm94LXNoYWRvdzogMHB4IDRweCAxN3B4IC00cHggcmdiYSg5Niw5Niw5NiwxKTsgfSBodG1sIHRhYmxlLm14UG9wdXBNZW51IHRkLm14UG9wdXBNZW51SXRlbSB7IGNvbG9yOiAjMzUzNTM1OyBmb250LXNpemU6IDE0cHg7IHBhZGRpbmctdG9wOiA0cHg7IHBhZGRpbmctYm90dG9tOiA0cHg7IH1odG1sIHRhYmxlLm14UG9wdXBNZW51IHRyLm14UG9wdXBNZW51SXRlbUhvdmVyIHsgYmFja2dyb3VuZC1jb2xvcjogIzI5YjZmMjsgfWh0bWwgdHIubXhQb3B1cE1lbnVJdGVtSG92ZXIgdGQubXhQb3B1cE1lbnVJdGVtLCBodG1sIHRyLm14UG9wdXBNZW51SXRlbUhvdmVyIHRkLm14UG9wdXBNZW51SXRlbSBzcGFuIHsgY29sb3I6ICNmZmYgIWltcG9ydGFudDsgfWh0bWwgdHIubXhQb3B1cE1lbnVJdGVtLCBodG1sIHRkLm14UG9wdXBNZW51SXRlbSB7IHRyYW5zaXRpb24tcHJvcGVydHk6IG5vbmUgIWltcG9ydGFudDsgfWh0bWwgdGFibGUubXhQb3B1cE1lbnUgaHIgeyBoZWlnaHQ6IDJweDsgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDAsMCwuMDcpOyBtYXJnaW46IDVweCAwOyB9IisKKG14Q2xpZW50LklTX0lPUz8iaHRtbCBpbnB1dFt0eXBlPWNoZWNrYm94XSwgaHRtbCBpbnB1dFt0eXBlPXJhZGlvXSB7IGhlaWdodDoxMnB4OyB9IjoiIik7ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImhlYWQiKVswXS5hcHBlbmRDaGlsZChkKX1jYXRjaCh5KXt9dmFyIGs9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7dmFyIGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ay5jbGFzc05hbWU9ImdlU2lkZWJhckNvbnRhaW5lciI7ay5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO2suc3R5bGUud2lkdGg9IjEwMCUiO2suc3R5bGUuaGVpZ2h0PSIxMDAlIjtrLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkIHdoaXRlU21va2UiO2suc3R5bGUub3ZlcmZsb3dYPSJoaWRkZW4iO2suc3R5bGUub3ZlcmZsb3dZPSJhdXRvIjtnKGspO3RoaXMud2luZG93PW5ldyBteFdpbmRvdyhiLGssYyxkLGUsZiwhMCwhMCk7dGhpcy53aW5kb3cuZGVzdHJveU9uQ2xvc2U9ITE7dGhpcy53aW5kb3cuc2V0TWF4aW1pemFibGUoITEpOwp0aGlzLndpbmRvdy5zZXRSZXNpemFibGUoITApO3RoaXMud2luZG93LnNldENsb3NhYmxlKCEwKTt0aGlzLndpbmRvdy5zZXRWaXNpYmxlKCEwKTt0aGlzLndpbmRvdy5zZXRMb2NhdGlvbj1mdW5jdGlvbihhLGIpe3ZhciBjPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7YT1NYXRoLm1heCgwLE1hdGgubWluKGEsKHdpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpLXRoaXMudGFibGUuY2xpZW50V2lkdGgpKTtiPU1hdGgubWF4KDAsTWF0aC5taW4oYixjLXRoaXMudGFibGUuY2xpZW50SGVpZ2h0LTQ4KSk7dGhpcy5nZXRYKCk9PWEmJnRoaXMuZ2V0WSgpPT1ifHxteFdpbmRvdy5wcm90b3R5cGUuc2V0TG9jYXRpb24uYXBwbHkodGhpcyxhcmd1bWVudHMpfTtteENsaWVudC5JU19TRiYmCih0aGlzLndpbmRvdy5kaXYub25zZWxlY3RzdGFydD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXtudWxsPT1iJiYoYj13aW5kb3cuZXZlbnQpO3JldHVybiBudWxsIT1iJiZhLmlzU2VsZWN0aW9uQWxsb3dlZChiKX0pKX07RWRpdG9yLmNoZWNrbWFya0ltYWdlPUdyYXBoLmNyZWF0ZVN2Z0ltYWdlKDIyLDE4LCc8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0IDApIiBkPSJNNy4xODEsMTUuMDA3YTEsMSwwLDAsMS0uNzkzLTAuMzkxTDMuMjIyLDEwLjVBMSwxLDAsMSwxLDQuODA4LDkuMjc0TDcuMTMyLDEyLjNsNi4wNDQtOC44NkExLDEsMCwxLDEsMTQuODMsNC41NjlsLTYuODIzLDEwYTEsMSwwLDAsMS0uOC40MzdINy4xODFaIiBmaWxsPSIjMjliNmYyIi8+Jykuc3JjO214V2luZG93LnByb3RvdHlwZS5jbG9zZUltYWdlPUdyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE4LDEwLCc8cGF0aCBkPSJNIDUgMSBMIDEzIDkgTSAxMyAxIEwgNSA5IiBzdHJva2U9IiNDMEMwQzAiIHN0cm9rZS13aWR0aD0iMiIvPicpLnNyYzsKbXhXaW5kb3cucHJvdG90eXBlLm1pbmltaXplSW1hZ2U9R3JhcGguY3JlYXRlU3ZnSW1hZ2UoMTQsMTAsJzxwYXRoIGQ9Ik0gMyA3IEwgNyAzIEwgMTEgNyIgc3Ryb2tlPSIjQzBDMEMwIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9IiNmZmZmZmYiLz4nKS5zcmM7bXhXaW5kb3cucHJvdG90eXBlLm5vcm1hbGl6ZUltYWdlPUdyYXBoLmNyZWF0ZVN2Z0ltYWdlKDE0LDEwLCc8cGF0aCBkPSJNIDMgMyBMIDcgNyBMIDExIDMiIHN0cm9rZT0iI0MwQzBDMCIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSIjZmZmZmZmIi8+Jykuc3JjO214Q29uc3RyYWludEhhbmRsZXIucHJvdG90eXBlLnBvaW50SW1hZ2U9R3JhcGguY3JlYXRlU3ZnSW1hZ2UoNSw1LCc8cGF0aCBkPSJtIDAgMCBMIDUgNSBNIDAgNSBMIDUgMCIgc3Ryb2tlPSIjMjliNmYyIi8+Jyk7bXhPdXRsaW5lLnByb3RvdHlwZS5zaXplckltYWdlPW51bGw7bXhDb25zdGFudHMuVkVSVEVYX1NFTEVDVElPTl9DT0xPUj0iI0MwQzBDMCI7bXhDb25zdGFudHMuRURHRV9TRUxFQ1RJT05fQ09MT1I9CiIjQzBDMEMwIjtteENvbnN0YW50cy5DT05ORUNUX0hBTkRMRV9GSUxMQ09MT1I9IiNjZWU3ZmYiO214Q29uc3RhbnRzLkRFRkFVTFRfVkFMSURfQ09MT1I9IiMyOWI2ZjIiO214Q29uc3RhbnRzLkdVSURFX0NPTE9SPSIjQzBDMEMwIjtteENvbnN0YW50cy5ISUdITElHSFRfU1RST0tFV0lEVEg9NTtteENvbnN0YW50cy5ISUdITElHSFRfT1BBQ0lUWT0zNTtteENvbnN0YW50cy5PVVRMSU5FX0NPTE9SPSIjMjliNmYyIjtteENvbnN0YW50cy5PVVRMSU5FX0hBTkRMRV9GSUxMQ09MT1I9IiMyOWI2ZjIiO214Q29uc3RhbnRzLk9VVExJTkVfSEFORExFX1NUUk9LRUNPTE9SPSIjZmZmIjtHcmFwaC5wcm90b3R5cGUuc3ZnU2hhZG93Q29sb3I9IiMzRDQ1NzQiO0dyYXBoLnByb3RvdHlwZS5zdmdTaGFkb3dPcGFjaXR5PSIwLjQiO0dyYXBoLnByb3RvdHlwZS5zdmdTaGFkb3dTaXplPSIwLjYiO0dyYXBoLnByb3RvdHlwZS5zdmdTaGFkb3dCbHVyPSIxLjIiO0Zvcm1hdC5wcm90b3R5cGUuaW5hY3RpdmVUYWJCYWNrZ3JvdW5kQ29sb3I9CiIjZjBmMGYwIjtteEdyYXBoSGFuZGxlci5wcm90b3R5cGUucHJldmlld0NvbG9yPSIjQzBDMEMwIjtteFJ1YmJlcmJhbmQucHJvdG90eXBlLmRlZmF1bHRPcGFjaXR5PTUwO0hvdmVySWNvbnMucHJvdG90eXBlLmluYWN0aXZlT3BhY2l0eT0yNTtGb3JtYXQucHJvdG90eXBlLnNob3dDbG9zZUJ1dHRvbj0hMTtFZGl0b3JVaS5wcm90b3R5cGUuY2xvc2FibGVTY3JhdGNocGFkPSExO0VkaXRvclVpLnByb3RvdHlwZS50b29sYmFySGVpZ2h0PTQ2O0VkaXRvclVpLnByb3RvdHlwZS5mb290ZXJIZWlnaHQ9MDtHcmFwaC5wcm90b3R5cGUuZWRpdEFmdGVySW5zZXJ0PSFteENsaWVudC5JU19JT1MmJiFteENsaWVudC5JU19BTkRST0lEO0VkaXRvci5wcm90b3R5cGUuaXNDaHJvbWVsZXNzVmlldz1mdW5jdGlvbigpe3JldHVybiExfTtHcmFwaC5wcm90b3R5cGUuaXNMaWdodGJveFZpZXc9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIG09RWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZVRhYkNvbnRhaW5lcjsKRWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZVRhYkNvbnRhaW5lcj1mdW5jdGlvbigpe251bGwhPXRoaXMudGFiQ29udGFpbmVyJiYodGhpcy50YWJDb250YWluZXIuc3R5bGUucmlnaHQ9IjcwcHgiLHRoaXMuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS5ib3R0b209dGhpcy50YWJDb250YWluZXJIZWlnaHQrInB4Iik7bS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBxPUVkaXRvclVpLnByb3RvdHlwZS51cGRhdGVBY3Rpb25TdGF0ZXM7RWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZUFjdGlvblN0YXRlcz1mdW5jdGlvbigpe3EuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMubWVudXMuZ2V0KCJzYXZlIikuc2V0RW5hYmxlZChudWxsIT10aGlzLmdldEN1cnJlbnRGaWxlKCl8fCIxIj09dXJsUGFyYW1zLmVtYmVkKX07dmFyIGI9TWVudXMucHJvdG90eXBlLmFkZFNob3J0Y3V0O01lbnVzLnByb3RvdHlwZS5hZGRTaG9ydGN1dD1mdW5jdGlvbihhLGMpe251bGwhPWMuc2hvcnRjdXQmJjkwMD4KZiYmIW14Q2xpZW50LklTX0lPUz9hLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYy5zaG9ydGN1dCk6Yi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBlPUFwcC5wcm90b3R5cGUudXBkYXRlVXNlckVsZW1lbnQ7QXBwLnByb3RvdHlwZS51cGRhdGVVc2VyRWxlbWVudD1mdW5jdGlvbigpe2UuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKG51bGwhPXRoaXMudXNlckVsZW1lbnQpe3ZhciBhPXRoaXMudXNlckVsZW1lbnQ7YS5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tcmlnaHQ6NHB4O2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6IithLnN0eWxlLmRpc3BsYXk7YS5jbGFzc05hbWU9ImdlVG9vbGJhckJ1dHRvbiI7YS5pbm5lckhUTUw9IiI7YS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgiK0VkaXRvci51c2VySW1hZ2UrIikiO2Euc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJjZW50ZXIgY2VudGVyIjthLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9CiJuby1yZXBlYXQiO2Euc3R5bGUuYmFja2dyb3VuZFNpemU9IjI0cHggMjRweCI7YS5zdHlsZS5oZWlnaHQ9IjI0cHgiO2Euc3R5bGUud2lkdGg9IjI0cHgiO2Euc3R5bGUuY3NzRmxvYXQ9InJpZ2h0IjthLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiY2hhbmdlVXNlciIpKTsibm9uZSIhPWEuc3R5bGUuZGlzcGxheSYmKGEuc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIil9fTt2YXIgZz1BcHAucHJvdG90eXBlLnVwZGF0ZUJ1dHRvbkNvbnRhaW5lcjtBcHAucHJvdG90eXBlLnVwZGF0ZUJ1dHRvbkNvbnRhaW5lcj1mdW5jdGlvbigpe2cuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKG51bGwhPXRoaXMuc2hhcmVCdXR0b24pe3ZhciBhPXRoaXMuc2hhcmVCdXR0b247YS5zdHlsZS5jc3NUZXh0PSJkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7bWFyZ2luLXJpZ2h0OjRweDtjdXJzb3I6cG9pbnRlcjsiOwphLmNsYXNzTmFtZT0iZ2VUb29sYmFyQnV0dG9uIjthLmlubmVySFRNTD0iIjthLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrRWRpdG9yLnNoYXJlSW1hZ2UrIikiO2Euc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJjZW50ZXIgY2VudGVyIjthLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCI7YS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZT0iMjRweCAyNHB4IjthLnN0eWxlLmhlaWdodD0iMjRweCI7YS5zdHlsZS53aWR0aD0iMjRweCJ9fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkRW1iZWRCdXR0b25zPWZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5idXR0b25Db250YWluZXIpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Euc3R5bGUuZGlzcGxheT0iaW5saW5lLWJsb2NrIjthLnN0eWxlLnBvc2l0aW9uPSJyZWxhdGl2ZSI7YS5zdHlsZS5tYXJnaW5Ub3A9IjhweCI7YS5zdHlsZS5tYXJnaW5SaWdodD0iNHB4Ijt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7CmIuY2xhc3NOYW1lPSJnZU1lbnVJdGVtIGdlUHJpbWFyeUJ0biI7Yi5zdHlsZS5tYXJnaW5MZWZ0PSI4cHgiO2Iuc3R5bGUucGFkZGluZz0iNnB4IjsiMSI9PXVybFBhcmFtcy5ub1NhdmVCdG4/KG14VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoInNhdmVBbmRFeGl0IikpLGIuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQW5kRXhpdCIpKSxteEV2ZW50LmFkZExpc3RlbmVyKGIsImNsaWNrIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuYWN0aW9ucy5nZXQoInNhdmVBbmRFeGl0IikuZnVuY3QoKX0pKSxhLmFwcGVuZENoaWxkKGIpKToobXhVdGlscy53cml0ZShiLG14UmVzb3VyY2VzLmdldCgic2F2ZSIpKSxiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgic2F2ZSIpKyIgKCIrRWRpdG9yLmN0cmxLZXkrIitTKSIpLG14RXZlbnQuYWRkTGlzdGVuZXIoYiwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgic2F2ZSIpLmZ1bmN0KCl9KSksCmEuYXBwZW5kQ2hpbGQoYiksIjEiPT11cmxQYXJhbXMuc2F2ZUFuZEV4aXQmJihiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKSxteFV0aWxzLndyaXRlKGIsbXhSZXNvdXJjZXMuZ2V0KCJzYXZlQW5kRXhpdCIpKSxiLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgic2F2ZUFuZEV4aXQiKSksYi5jbGFzc05hbWU9ImdlTWVudUl0ZW0iLGIuc3R5bGUubWFyZ2luTGVmdD0iNnB4IixiLnN0eWxlLnBhZGRpbmc9IjZweCIsbXhFdmVudC5hZGRMaXN0ZW5lcihiLCJjbGljayIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLmFjdGlvbnMuZ2V0KCJzYXZlQW5kRXhpdCIpLmZ1bmN0KCl9KSksYS5hcHBlbmRDaGlsZChiKSkpO2I9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpO214VXRpbHMud3JpdGUoYixteFJlc291cmNlcy5nZXQoImV4aXQiKSk7Yi5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoImV4aXQiKSk7Yi5jbGFzc05hbWU9CiJnZU1lbnVJdGVtIjtiLnN0eWxlLm1hcmdpbkxlZnQ9IjZweCI7Yi5zdHlsZS5wYWRkaW5nPSI2cHgiO214RXZlbnQuYWRkTGlzdGVuZXIoYiwiY2xpY2siLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5hY3Rpb25zLmdldCgiZXhpdCIpLmZ1bmN0KCl9KSk7YS5hcHBlbmRDaGlsZChiKTt0aGlzLmJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChhKTt0aGlzLmJ1dHRvbkNvbnRhaW5lci5zdHlsZS50b3A9IjZweCJ9fTtTaWRlYmFyLnByb3RvdHlwZS5nZXRUb29sdGlwT2Zmc2V0PWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5nZXRPZmZzZXQodGhpcy5lZGl0b3JVaS5zaWRlYmFyV2luZG93LndpbmRvdy5kaXYpO2EueSs9NDA7cmV0dXJuIGF9O3ZhciBuPU1lbnVzLnByb3RvdHlwZS5jcmVhdGVQb3B1cE1lbnU7TWVudXMucHJvdG90eXBlLmNyZWF0ZVBvcHVwTWVudT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5lZGl0b3JVaS5lZGl0b3IuZ3JhcGg7YS5zbWFydFNlcGFyYXRvcnM9CiEwO24uYXBwbHkodGhpcyxhcmd1bWVudHMpO214VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IEZpbGVuYW1lRGlhbG9nKHRoaXMuZWRpdG9yVWksYSxteFJlc291cmNlcy5nZXQoImFwcGx5IiksZnVuY3Rpb24oYSl7YihwYXJzZUZsb2F0KGEpKX0sbXhSZXNvdXJjZXMuZ2V0KCJzcGFjaW5nIikpO3RoaXMuZWRpdG9yVWkuc2hvd0RpYWxvZyhjLmNvbnRhaW5lciwzMDAsODAsITAsITApO2MuaW5pdCgpfSk7MT09ZC5nZXRTZWxlY3Rpb25Db3VudCgpPyh0aGlzLmFkZE1lbnVJdGVtcyhhLFsiZWRpdFRvb2x0aXAiLCItIiwiZWRpdFN0eWxlIiwiZWRpdEdlb21ldHJ5IiwiLSJdLG51bGwsYyksZC5pc0NlbGxGb2xkYWJsZShkLmdldFNlbGVjdGlvbkNlbGwoKSkmJnRoaXMuYWRkTWVudUl0ZW1zKGEsZC5pc0NlbGxDb2xsYXBzZWQoYik/WyJleHBhbmQiXTpbImNvbGxhcHNlIl0sbnVsbCxjKSx0aGlzLmFkZE1lbnVJdGVtcyhhLFsiY29sbGFwc2libGUiLCItIiwKImxvY2tVbmxvY2siLCJlbnRlckdyb3VwIl0sbnVsbCxjKSxhLmFkZFNlcGFyYXRvcigpLHRoaXMuYWRkU3VibWVudSgibGF5b3V0IixhKSk6ZC5pc1NlbGVjdGlvbkVtcHR5KCkmJmQuaXNFbmFibGVkKCk/KGEuYWRkU2VwYXJhdG9yKCksdGhpcy5hZGRNZW51SXRlbXMoYSxbImVkaXREYXRhIl0sbnVsbCxjKSxhLmFkZFNlcGFyYXRvcigpLHRoaXMuYWRkU3VibWVudSgibGF5b3V0IixhKSx0aGlzLmFkZFN1Ym1lbnUoInZpZXciLGEsbnVsbCxteFJlc291cmNlcy5nZXQoIm9wdGlvbnMiKSksYS5hZGRTZXBhcmF0b3IoKSx0aGlzLmFkZFN1Ym1lbnUoImluc2VydCIsYSksdGhpcy5hZGRNZW51SXRlbXMoYSxbIi0iLCJleGl0R3JvdXAiXSxudWxsLGMpKTpkLmlzRW5hYmxlZCgpJiZ0aGlzLmFkZE1lbnVJdGVtcyhhLFsiLSIsImxvY2tVbmxvY2siXSxudWxsLGMpfTtFZGl0b3JVaS5wcm90b3R5cGUudG9nZ2xlRm9ybWF0UGFuZWw9ZnVuY3Rpb24oYil7bnVsbCE9dGhpcy5mb3JtYXRXaW5kb3c/CnRoaXMuZm9ybWF0V2luZG93LndpbmRvdy5zZXRWaXNpYmxlKG51bGwhPWI/YjohdGhpcy5mb3JtYXRXaW5kb3cud2luZG93LmlzVmlzaWJsZSgpKTphKHRoaXMpfTtEaWFncmFtRm9ybWF0UGFuZWwucHJvdG90eXBlLmlzTWF0aE9wdGlvblZpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH07dmFyIGw9RWRpdG9yVWkucHJvdG90eXBlLmRlc3Ryb3k7RWRpdG9yVWkucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnNpZGViYXJXaW5kb3cmJih0aGlzLnNpZGViYXJXaW5kb3cud2luZG93LnNldFZpc2libGUoITEpLHRoaXMuc2lkZWJhcldpbmRvdy53aW5kb3cuZGVzdHJveSgpLHRoaXMuc2lkZWJhcldpbmRvdz1udWxsKTtudWxsIT10aGlzLmZvcm1hdFdpbmRvdyYmKHRoaXMuZm9ybWF0V2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSx0aGlzLmZvcm1hdFdpbmRvdy53aW5kb3cuZGVzdHJveSgpLHRoaXMuZm9ybWF0V2luZG93PW51bGwpO251bGwhPXRoaXMuYWN0aW9ucy5vdXRsaW5lV2luZG93JiYKKHRoaXMuYWN0aW9ucy5vdXRsaW5lV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSx0aGlzLmFjdGlvbnMub3V0bGluZVdpbmRvdy53aW5kb3cuZGVzdHJveSgpLHRoaXMuYWN0aW9ucy5vdXRsaW5lV2luZG93PW51bGwpO251bGwhPXRoaXMuYWN0aW9ucy5sYXllcnNXaW5kb3cmJih0aGlzLmFjdGlvbnMubGF5ZXJzV2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSx0aGlzLmFjdGlvbnMubGF5ZXJzV2luZG93LndpbmRvdy5kZXN0cm95KCksdGhpcy5hY3Rpb25zLmxheWVyc1dpbmRvdz1udWxsKTtudWxsIT10aGlzLm1lbnVzLnRhZ3NXaW5kb3cmJih0aGlzLm1lbnVzLnRhZ3NXaW5kb3cud2luZG93LnNldFZpc2libGUoITEpLHRoaXMubWVudXMudGFnc1dpbmRvdy53aW5kb3cuZGVzdHJveSgpLHRoaXMubWVudXMudGFnc1dpbmRvdz1udWxsKTtudWxsIT10aGlzLm1lbnVzLmZpbmRXaW5kb3cmJih0aGlzLm1lbnVzLmZpbmRXaW5kb3cud2luZG93LnNldFZpc2libGUoITEpLHRoaXMubWVudXMuZmluZFdpbmRvdy53aW5kb3cuZGVzdHJveSgpLAp0aGlzLm1lbnVzLmZpbmRXaW5kb3c9bnVsbCk7bC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBwPUVkaXRvclVpLnByb3RvdHlwZS5zZXRHcmFwaEVuYWJsZWQ7RWRpdG9yVWkucHJvdG90eXBlLnNldEdyYXBoRW5hYmxlZD1mdW5jdGlvbihhKXtwLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthPzFFMzw9KHdpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpJiYobnVsbCE9dGhpcy5zaWRlYmFyV2luZG93JiZ0aGlzLnNpZGViYXJXaW5kb3cud2luZG93LnNldFZpc2libGUoITApLG51bGwhPXRoaXMuZm9ybWF0V2luZG93JiZ0aGlzLmZvcm1hdFdpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMCkpOihudWxsIT10aGlzLnNpZGViYXJXaW5kb3cmJnRoaXMuc2lkZWJhcldpbmRvdy53aW5kb3cuc2V0VmlzaWJsZSghMSksbnVsbCE9dGhpcy5mb3JtYXRXaW5kb3cmJnRoaXMuZm9ybWF0V2luZG93LndpbmRvdy5zZXRWaXNpYmxlKCExKSl9OwpFZGl0b3JVaS5wcm90b3R5cGUuY2hyb21lbGVzc1dpbmRvd1Jlc2l6ZT1mdW5jdGlvbigpe307dmFyIHY9TWVudXMucHJvdG90eXBlLmluaXQ7TWVudXMucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt2LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYj10aGlzLmVkaXRvclVpLGQ9Yi5lZGl0b3IuZ3JhcGg7Yi5hY3Rpb25zLmdldCgiZWRpdERpYWdyYW0iKS5sYWJlbD1teFJlc291cmNlcy5nZXQoImZvcm1hdFhtbCIpKyIuLi4iO2IuYWN0aW9ucy5nZXQoImNyZWF0ZVNoYXBlIikubGFiZWw9bXhSZXNvdXJjZXMuZ2V0KCJzaGFwZSIpKyIuLi4iO2IuYWN0aW9ucy5nZXQoIm91dGxpbmUiKS5sYWJlbD1teFJlc291cmNlcy5nZXQoIm91dGxpbmUiKSsiLi4uIjtiLmFjdGlvbnMuZ2V0KCJsYXllcnMiKS5sYWJlbD1teFJlc291cmNlcy5nZXQoImxheWVycyIpKyIuLi4iO2IuYWN0aW9ucy5wdXQoImltcG9ydENzdiIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoImNzdiIpKyIuLi4iLApmdW5jdGlvbigpe2QucG9wdXBNZW51SGFuZGxlci5oaWRlTWVudSgpO2Iuc2hvd0ltcG9ydENzdkRpYWxvZygpfSkpO2IuYWN0aW9ucy5wdXQoImltcG9ydFRleHQiLG5ldyBBY3Rpb24obXhSZXNvdXJjZXMuZ2V0KCJ0ZXh0IikrIi4uLiIsZnVuY3Rpb24oKXt2YXIgYT1uZXcgUGFyc2VEaWFsb2coYiwiSW5zZXJ0IGZyb20gVGV4dCIpO2Iuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciw2MjAsNDIwLCEwLCExKTthLmluaXQoKX0pKTtiLmFjdGlvbnMucHV0KCJmb3JtYXRTcWwiLG5ldyBBY3Rpb24obXhSZXNvdXJjZXMuZ2V0KCJmb3JtYXRTcWwiKSsiLi4uIixmdW5jdGlvbigpe3ZhciBhPW5ldyBQYXJzZURpYWxvZyhiLCJJbnNlcnQgZnJvbSBUZXh0IiwiZm9ybWF0U3FsIik7Yi5zaG93RGlhbG9nKGEuY29udGFpbmVyLDYyMCw0MjAsITAsITEpO2EuaW5pdCgpfSkpO2IuYWN0aW9ucy5wdXQoInRvZ2dsZVNoYXBlcyIsbmV3IEFjdGlvbihteFJlc291cmNlcy5nZXQoInNoYXBlcyIpKyIuLi4iLApmdW5jdGlvbigpe2MoYil9KSk7Yi5hY3Rpb25zLnB1dCgidG9nZ2xlRm9ybWF0IixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgiZm9ybWF0IikrIi4uLiIsZnVuY3Rpb24oKXthKGIpfSkpO0VkaXRvclVpLmVuYWJsZVBsYW50VW1sJiYhYi5pc09mZmxpbmUoKSYmYi5hY3Rpb25zLnB1dCgicGxhbnRVbWwiLG5ldyBBY3Rpb24obXhSZXNvdXJjZXMuZ2V0KCJwbGFudFVtbCIpKyIuLi4iLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IFBhcnNlRGlhbG9nKGIsbXhSZXNvdXJjZXMuZ2V0KCJwbGFudFVtbCIpKyIuLi4iLCJwbGFudFVtbCIpO2Iuc2hvd0RpYWxvZyhhLmNvbnRhaW5lciw2MjAsNDIwLCEwLCExKTthLmluaXQoKX0pKTtiLmFjdGlvbnMucHV0KCJtZXJtYWlkIixuZXcgQWN0aW9uKG14UmVzb3VyY2VzLmdldCgibWVybWFpZCIpKyIuLi4iLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IFBhcnNlRGlhbG9nKGIsbXhSZXNvdXJjZXMuZ2V0KCJtZXJtYWlkIikrIi4uLiIsIm1lcm1haWQiKTsKYi5zaG93RGlhbG9nKGEuY29udGFpbmVyLDYyMCw0MjAsITAsITEpO2EuaW5pdCgpfSkpO3RoaXMucHV0KCJkaWFncmFtIixuZXcgTWVudShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3ZhciBkPWIuZ2V0Q3VycmVudEZpbGUoKTtiLm1lbnVzLmFkZFN1Ym1lbnUoImV4dHJhcyIsYSxjLG14UmVzb3VyY2VzLmdldCgicHJlZmVyZW5jZXMiKSk7YS5hZGRTZXBhcmF0b3IoYyk7bXhDbGllbnQuSVNfQ0hST01FQVBQfHxFZGl0b3JVaS5pc0VsZWN0cm9uQXBwPyhiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsibmV3Iiwib3BlbiIsIi0iXSxjKSxFZGl0b3JVaS5pc0VsZWN0cm9uQXBwJiZiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsic3luY2hyb25pemUiLCItIl0sYyksYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInNhdmUiLCJzYXZlQXMiLCItIl0sYykpOiIxIj09dXJsUGFyYW1zLmVtYmVkPyhiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsInNhdmUiXSxjKSwiMSI9PXVybFBhcmFtcy5zYXZlQW5kRXhpdCYmCmIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJzYXZlQW5kRXhpdCJdLGMpLGEuYWRkU2VwYXJhdG9yKGMpKTooYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIm5ldyJdLGMpLGIubWVudXMuYWRkU3VibWVudSgib3BlbkZyb20iLGEsYyksaXNMb2NhbFN0b3JhZ2UmJnRoaXMuYWRkU3VibWVudSgib3BlblJlY2VudCIsYSxjKSxhLmFkZFNlcGFyYXRvcihjKSxudWxsIT1kJiZkLmNvbnN0cnVjdG9yPT1Ecml2ZUZpbGUmJmIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyJzaGFyZSJdLGMpLG14Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcHx8bnVsbD09ZHx8ZC5jb25zdHJ1Y3Rvcj09TG9jYWxGaWxlfHxiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsic3luY2hyb25pemUiXSxjKSxhLmFkZFNlcGFyYXRvcihjKSxiLm1lbnVzLmFkZFN1Ym1lbnUoInNhdmUiLGEsYykpO2IubWVudXMuYWRkU3VibWVudSgiZXhwb3J0QXMiLGEsYyk7bXhDbGllbnQuSVNfQ0hST01FQVBQfHwKRWRpdG9yVWkuaXNFbGVjdHJvbkFwcD9iLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiaW1wb3J0Il0sYyk6Yi5tZW51cy5hZGRTdWJtZW51KCJpbXBvcnRGcm9tIixhLGMpO2IubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwib3V0bGluZSIsImxheWVycyJdLGMpO2IuY29tbWVudHNTdXBwb3J0ZWQoKSYmYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbImNvbW1lbnRzIl0sYyk7Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIi0iLCJmaW5kIiwidGFncyJdLGMpO251bGwhPWQmJm51bGwhPWIuZmlsZU5vZGUmJihkPW51bGwhPWQuZ2V0VGl0bGUoKT9kLmdldFRpdGxlKCk6Yi5kZWZhdWx0RmlsZW5hbWUsLyhcLmh0bWwpJC9pLnRlc3QoZCl8fC8oXC5zdmcpJC9pLnRlc3QoZCl8fHRoaXMuYWRkTWVudUl0ZW1zKGEsWyItIiwicHJvcGVydGllcyJdKSk7bXhDbGllbnQuSVNfSU9TJiZuYXZpZ2F0b3Iuc3RhbmRhbG9uZXx8Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIi0iLCJwcmludCIsIi0iXSxjKTsKYi5tZW51cy5hZGRTdWJtZW51KCJoZWxwIixhLGMpOyIxIj09dXJsUGFyYW1zLmVtYmVkP2IubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwiZXhpdCJdLGMpOmIubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwiY2xvc2UiXSl9KSkpO3RoaXMucHV0KCJzYXZlIixuZXcgTWVudShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe3ZhciBkPWIuZ2V0Q3VycmVudEZpbGUoKTtudWxsIT1kJiZkLmNvbnN0cnVjdG9yPT1Ecml2ZUZpbGU/Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInNhdmUiLCJtYWtlQ29weSIsIi0iLCJyZW5hbWUiLCJtb3ZlVG9Gb2xkZXIiXSxjKTooYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInNhdmUiLCJzYXZlQXMiLCItIiwicmVuYW1lIl0sYyksYi5pc09mZmxpbmVBcHAoKT9uYXZpZ2F0b3Iub25MaW5lJiYiMSIhPXVybFBhcmFtcy5zdGVhbHRoJiZ0aGlzLmFkZE1lbnVJdGVtcyhhLFsidXBsb2FkIl0sYyk6Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIm1ha2VDb3B5Il0sCmMpKTtiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsImF1dG9zYXZlIl0sYyk7bnVsbCE9ZCYmZC5pc1JldmlzaW9uSGlzdG9yeVN1cHBvcnRlZCgpJiZiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiLSIsInJldmlzaW9uSGlzdG9yeSJdLGMpfSkpKTt2YXIgZT10aGlzLmdldCgiZXhwb3J0QXMiKTt0aGlzLnB1dCgiZXhwb3J0QXMiLG5ldyBNZW51KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEsYyl7ZS5mdW5jdChhLGMpO214Q2xpZW50LklTX0NIUk9NRUFQUHx8RWRpdG9yVWkuaXNFbGVjdHJvbkFwcHx8Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInB1Ymxpc2hMaW5rIl0sYyk7YS5hZGRTZXBhcmF0b3IoYyk7Yi5tZW51cy5hZGRTdWJtZW51KCJlbWJlZCIsYSxjKX0pKSk7dmFyIGY9dGhpcy5nZXQoImxhbmd1YWdlIik7dGhpcy5wdXQoInRhYmxlIixuZXcgTWVudShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe2IubWVudXMuYWRkSW5zZXJ0VGFibGVDZWxsSXRlbShhLApjKX0pKSk7dGhpcy5wdXQoImV4dHJhcyIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXsiMSIhPXVybFBhcmFtcy5lbWJlZCYmYi5tZW51cy5hZGRTdWJtZW51KCJ0aGVtZSIsYSxjKTtudWxsIT1mJiZiLm1lbnVzLmFkZFN1Ym1lbnUoImxhbmd1YWdlIixhLGMpO2IubWVudXMuYWRkU3VibWVudSgidW5pdHMiLGEsYyk7YS5hZGRTZXBhcmF0b3IoYyk7Yi5tZW51cy5hZGRNZW51SXRlbXMoYSxbInNjcm9sbGJhcnMiLCJ0b29sdGlwcyIsInJ1bGVyIl0sYyk7IjEiIT11cmxQYXJhbXMuZW1iZWQmJihpc0xvY2FsU3RvcmFnZXx8bXhDbGllbnQuSVNfQ0hST01FQVBQKSYmYi5tZW51cy5hZGRNZW51SXRlbXMoYSxbIi0iLCJzZWFyY2giLCJzY3JhdGNocGFkIiwiLSIsInNob3dTdGFydFNjcmVlbiJdLGMpOyFiLmlzT2ZmbGluZUFwcCgpJiZpc0xvY2FsU3RvcmFnZSYmYi5tZW51cy5hZGRNZW51SXRlbShhLCJwbHVnaW5zIixjKTthLmFkZFNlcGFyYXRvcihjKTsKYi5tZW51cy5hZGRNZW51SXRlbShhLCJkcmF3Q29uZmlnIixjKTthLmFkZFNlcGFyYXRvcihjKX0pKSk7dGhpcy5wdXQoImluc2VydEFkdmFuY2VkIixuZXcgTWVudShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhLGMpe2IubWVudXMuYWRkTWVudUl0ZW1zKGEsImltcG9ydFRleHQgcGxhbnRVbWwgbWVybWFpZCAtIGZvcm1hdFNxbCBpbXBvcnRDc3YgLSBjcmVhdGVTaGFwZSBlZGl0RGlhZ3JhbSIuc3BsaXQoIiAiKSxjKX0pKSk7bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldCgiaW5zZXJ0IiksYz1hLmZ1bmN0O2EuZnVuY3Q9ZnVuY3Rpb24oYSxkKXtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtiLm1lbnVzLmFkZFN1Ym1lbnUoInRhYmxlIixhLGQpO2EuYWRkU2VwYXJhdG9yKGQpO2IubWVudXMuYWRkTWVudUl0ZW1zKGEsWyItIiwidG9nZ2xlU2hhcGVzIl0sZCl9fSkoKTt2YXIgZz0iaG9yaXpvbnRhbEZsb3cgdmVydGljYWxGbG93IC0gaG9yaXpvbnRhbFRyZWUgdmVydGljYWxUcmVlIHJhZGlhbFRyZWUgLSBvcmdhbmljIGNpcmNsZSIuc3BsaXQoIiAiKSwKaz1mdW5jdGlvbihhLGMsZCxlKXthLmFkZEl0ZW0oZCxudWxsLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGE9bmV3IENyZWF0ZUdyYXBoRGlhbG9nKGIsZCxlKTtiLnNob3dEaWFsb2coYS5jb250YWluZXIsNjIwLDQyMCwhMCwhMSk7YS5pbml0KCl9KSxjKX07dGhpcy5wdXQoImluc2VydExheW91dCIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGcubGVuZ3RoO2MrKykiLSI9PWdbY10/YS5hZGRTZXBhcmF0b3IoYik6ayhhLGIsbXhSZXNvdXJjZXMuZ2V0KGdbY10pKyIuLi4iLGdbY10pfSkpKTt0aGlzLnB1dCgidmlldyIsbmV3IE1lbnUobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSxjKXtiLm1lbnVzLmFkZE1lbnVJdGVtcyhhLCJncmlkIGd1aWRlcyBydWxlciAtIGNvbm5lY3Rpb25BcnJvd3MgY29ubmVjdGlvblBvaW50cyAtIi5zcGxpdCgiICIpLGMpO2lmKCJ1bmRlZmluZWQiIT09dHlwZW9mIE1hdGhKYXgpe3ZhciBkPQpiLm1lbnVzLmFkZE1lbnVJdGVtKGEsIm1hdGhlbWF0aWNhbFR5cGVzZXR0aW5nIixjKTtiLm1lbnVzLmFkZExpbmtUb0l0ZW0oZCwiaHR0cHM6Ly9kZXNrLmRyYXcuaW8vc3VwcG9ydC9zb2x1dGlvbnMvYXJ0aWNsZXMvMTYwMDAwMzI4NzUiKX1iLm1lbnVzLmFkZE1lbnVJdGVtcyhhLFsiY29weUNvbm5lY3QiLCJjb2xsYXBzZUV4cGFuZCIsIi0iLCJwYWdlU2NhbGUiXSxjKX0pKSl9O3ZhciB0PUVkaXRvclVpLnByb3RvdHlwZS5pbml0O0VkaXRvclVpLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIsYyl7dmFyIGQ9bC5tZW51cy5nZXQoYSksZT1xLmFkZE1lbnUobXhSZXNvdXJjZXMuZ2V0KGEpLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7ZC5mdW5jdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSxwKTtlLmNsYXNzTmFtZT0iZ2VNZW51SXRlbSI7ZS5zdHlsZS5kaXNwbGF5PSJpbmxpbmUtYmxvY2siO2Uuc3R5bGUuYm94U2l6aW5nPSJib3JkZXItYm94IjsKZS5zdHlsZS50b3A9IjZweCI7ZS5zdHlsZS5tYXJnaW5SaWdodD0iNnB4IjtlLnN0eWxlLmhlaWdodD0iMzBweCI7ZS5zdHlsZS5wYWRkaW5nVG9wPSI2cHgiO2Uuc3R5bGUucGFkZGluZ0JvdHRvbT0iNnB4IjtlLnN0eWxlLmN1cnNvcj0icG9pbnRlciI7ZS5zZXRBdHRyaWJ1dGUoInRpdGxlIixteFJlc291cmNlcy5nZXQoYSkpO2wubWVudXMubWVudUNyZWF0ZWQoZCxlLCJnZU1lbnVJdGVtIik7bnVsbCE9Yz8oZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9InVybCgiK2MrIikiLGUuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJjZW50ZXIgY2VudGVyIixlLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCIsZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZT0iMjRweCAyNHB4IixlLnN0eWxlLndpZHRoPSIzNHB4IixlLmlubmVySFRNTD0iIik6Ynx8KGUuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoIitteFdpbmRvdy5wcm90b3R5cGUubm9ybWFsaXplSW1hZ2UrIikiLGUuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPQoicmlnaHQgNnB4IGNlbnRlciIsZS5zdHlsZS5iYWNrZ3JvdW5kUmVwZWF0PSJuby1yZXBlYXQiLGUuc3R5bGUucGFkZGluZ1JpZ2h0PSIyMnB4Iik7cmV0dXJuIGV9ZnVuY3Rpb24gZChhLGIsYyxkLGUsZil7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYSIpO2cuY2xhc3NOYW1lPSJnZU1lbnVJdGVtIjtnLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayI7Zy5zdHlsZS5ib3hTaXppbmc9ImJvcmRlci1ib3giO2cuc3R5bGUuaGVpZ2h0PSIzMHB4IjtnLnN0eWxlLnBhZGRpbmc9IjZweCI7Zy5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiO2cuc3R5bGUudmVydGljYWxBbGlnbj0idG9wIjtnLnN0eWxlLnRvcD0iMHB4IjtudWxsIT1sLnN0YXR1c0NvbnRhaW5lcj9uLmluc2VydEJlZm9yZShnLGwuc3RhdHVzQ29udGFpbmVyKTpuLmFwcGVuZENoaWxkKGcpO251bGwhPWY/KGcuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoIitmKyIpIixnLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbj0KImNlbnRlciBjZW50ZXIiLGcuc3R5bGUuYmFja2dyb3VuZFJlcGVhdD0ibm8tcmVwZWF0IixnLnN0eWxlLmJhY2tncm91bmRTaXplPSIyNHB4IDI0cHgiLGcuc3R5bGUud2lkdGg9IjM0cHgiKTpteFV0aWxzLndyaXRlKGcsYSk7bXhFdmVudC5hZGRMaXN0ZW5lcihnLG14Q2xpZW50LklTX1BPSU5URVI/InBvaW50ZXJkb3duIjoibW91c2Vkb3duIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9KSk7bXhFdmVudC5hZGRMaXN0ZW5lcihnLCJjbGljayIsZnVuY3Rpb24oYSl7ImRpc2FibGVkIiE9Zy5nZXRBdHRyaWJ1dGUoImRpc2FibGVkIikmJmIoYSk7bXhFdmVudC5jb25zdW1lKGEpfSk7bnVsbD09YyYmKGcuc3R5bGUubWFyZ2luUmlnaHQ9IjRweCIpO251bGwhPWQmJmcuc2V0QXR0cmlidXRlKCJ0aXRsZSIsZCk7bnVsbCE9ZSYmKGE9ZnVuY3Rpb24oKXtlLmlzRW5hYmxlZCgpPyhnLnJlbW92ZUF0dHJpYnV0ZSgiZGlzYWJsZWQiKSxnLnN0eWxlLmN1cnNvcj0KInBvaW50ZXIiKTooZy5zZXRBdHRyaWJ1dGUoImRpc2FibGVkIiwiZGlzYWJsZWQiKSxnLnN0eWxlLmN1cnNvcj0iZGVmYXVsdCIpfSxlLmFkZExpc3RlbmVyKCJzdGF0ZUNoYW5nZWQiLGEpLGEoKSk7cmV0dXJuIGd9ZnVuY3Rpb24gZShhLGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2MuY2xhc3NOYW1lPSJnZU1lbnVJdGVtIjtjLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayI7Yy5zdHlsZS52ZXJ0aWNhbEFsaWduPSJ0b3AiO2Muc3R5bGUubWFyZ2luUmlnaHQ9IjZweCI7Yy5zdHlsZS5wYWRkaW5nPSIwIDRweCAwIDRweCI7Yy5zdHlsZS5oZWlnaHQ9IjMwcHgiO2Muc3R5bGUucG9zaXRpb249InJlbGF0aXZlIjtjLnN0eWxlLnRvcD0iMHB4Ijtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyludWxsIT1hW2RdJiYoYVtkXS5zdHlsZS5tYXJnaW49IjBweCIsYVtkXS5zdHlsZS5ib3hTaGFkb3c9Im5vbmUiLGMuYXBwZW5kQ2hpbGQoYVtkXSkpO251bGwhPQpiJiZteFV0aWxzLnNldE9wYWNpdHkoYyxiKTtudWxsIT1sLnN0YXR1c0NvbnRhaW5lcj9uLmluc2VydEJlZm9yZShjLGwuc3RhdHVzQ29udGFpbmVyKTpuLmFwcGVuZENoaWxkKGMpO3JldHVybiBjfWZ1bmN0aW9uIGcoKXtmb3IodmFyIGE9bi5maXJzdENoaWxkO251bGwhPWE7KXt2YXIgYz1hLm5leHRTaWJsaW5nOyJnZU1lbnVJdGVtIiE9YS5jbGFzc05hbWUmJiJnZUl0ZW0iIT1hLmNsYXNzTmFtZXx8YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2E9Y31wPW4uZmlyc3RDaGlsZDtmPXdpbmRvdy5pbm5lcldpZHRofHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh8fGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7KGE9MUUzPmYpfHxiKCJkaWFncmFtIik7ZShbYT9iKCJkaWFncmFtIixudWxsLElNQUdFX1BBVEgrIi9kcmF3bG9nby5zdmciKTpudWxsLGQobXhSZXNvdXJjZXMuZ2V0KCJzaGFwZXMiKSxsLmFjdGlvbnMuZ2V0KCJ0b2dnbGVTaGFwZXMiKS5mdW5jdCwKbnVsbCxteFJlc291cmNlcy5nZXQoInNoYXBlcyIpLGwuYWN0aW9ucy5nZXQoImltYWdlIiksYT8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRNZ01UTjJPR2c0ZGkwNGFDMDRlazB6SURJeGFEaDJMVGhJTTNZNGVrMHpJRE4yT0dnNFZqTklNM3B0TVRNdU5qWXRNUzR6TVV3eE1TQTNMak0wSURFMkxqWTJJREV6YkRVdU5qWXROUzQyTmkwMUxqWTJMVFV1TmpWNklpOCtQQzl6ZG1jKyI6bnVsbCksZChteFJlc291cmNlcy5nZXQoImZvcm1hdCIpLGwuYWN0aW9ucy5nZXQoInRvZ2dsZUZvcm1hdCIpLmZ1bmN0LG51bGwsbXhSZXNvdXJjZXMuZ2V0KCJmb3JtYXQiKSsiICgiK2wuYWN0aW9ucy5nZXQoImZvcm1hdFBhbmVsIikuc2hvcnRjdXQrIikiLGwuYWN0aW9ucy5nZXQoImltYWdlIiksCmE/ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1USWdNMk10TkM0NU55QXdMVGtnTkM0d015MDVJRGx6TkM0d015QTVJRGtnT1dNdU9ETWdNQ0F4TGpVdExqWTNJREV1TlMweExqVWdNQzB1TXprdExqRTFMUzQzTkMwdU16a3RNUzR3TVMwdU1qTXRMakkyTFM0ek9DMHVOakV0TGpNNExTNDVPU0F3TFM0NE15NDJOeTB4TGpVZ01TNDFMVEV1TlVneE5tTXlMamMySURBZ05TMHlMakkwSURVdE5TQXdMVFF1TkRJdE5DNHdNeTA0TFRrdE9IcHRMVFV1TlNBNVl5MHVPRE1nTUMweExqVXRMalkzTFRFdU5TMHhMalZUTlM0Mk55QTVJRFl1TlNBNUlEZ2dPUzQyTnlBNElERXdMalVnTnk0ek15QXhNaUEyTGpVZ01USjZiVE10TkVNNExqWTNJRGdnT0NBM0xqTXpJRGdnTmk0MVV6Z3VOamNnTlNBNUxqVWdOWE14TGpVdU5qY2dNUzQxSURFdU5WTXhNQzR6TXlBNElEa3VOU0E0ZW0wMUlEQmpMUzQ0TXlBd0xURXVOUzB1TmpjdE1TNDFMVEV1TlZNeE15NDJOeUExSURFMExqVWdOWE14TGpVdU5qY2dNUzQxSURFdU5WTXhOUzR6TXlBNElERTBMalVnT0hwdE15QTBZeTB1T0RNZ01DMHhMalV0TGpZM0xURXVOUzB4TGpWVE1UWXVOamNnT1NBeE55NDFJRGx6TVM0MUxqWTNJREV1TlNBeExqVXRMalkzSURFdU5TMHhMalVnTVM0MWVpSXZQand2YzNablBnPT0iOgpudWxsKV0sYT82MDpudWxsKTtjPWIoImluc2VydCIsITAsYT8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRrZ01UTm9MVFoyTm1ndE1uWXROa2cxZGkweWFEWldOV2d5ZGpab05uWXllaUl2UGp3dmMzWm5QZz09IjpudWxsKTtlKFtjLGQobXhSZXNvdXJjZXMuZ2V0KCJkZWxldGUiKSxsLmFjdGlvbnMuZ2V0KCJkZWxldGUiKS5mdW5jdCxudWxsLG14UmVzb3VyY2VzLmdldCgiZGVsZXRlIiksbC5hY3Rpb25zLmdldCgiZGVsZXRlIiksYT8iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTmlBeE9XTXdJREV1TVM0NUlESWdNaUF5YURoak1TNHhJREFnTWkwdU9TQXlMVEpXTjBnMmRqRXllazB4T1NBMGFDMHpMalZzTFRFdE1XZ3ROV3d0TVNBeFNEVjJNbWd4TkZZMGVpSXZQand2YzNablBnPT0iOgpudWxsKV0sYT82MDpudWxsKTtpZig0MTE8PWYmJihjPWwuYWN0aW9ucy5nZXQoInVuZG8iKSxhPWwuYWN0aW9ucy5nZXQoInJlZG8iKSxjPWQoIiIsYy5mdW5jdCxudWxsLG14UmVzb3VyY2VzLmdldCgidW5kbyIpKyIgKCIrYy5zaG9ydGN1dCsiKSIsYywiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajQ4Y0dGMGFDQmtQU0pOTVRJdU5TQTRZeTB5TGpZMUlEQXROUzR3TlM0NU9TMDJMamtnTWk0MlRESWdOM1k1YURsc0xUTXVOakl0TXk0Mk1tTXhMak01TFRFdU1UWWdNeTR4TmkweExqZzRJRFV1TVRJdE1TNDRPQ0F6TGpVMElEQWdOaTQxTlNBeUxqTXhJRGN1TmlBMUxqVnNNaTR6TnkwdU56aERNakV1TURnZ01URXVNRE1nTVRjdU1UVWdPQ0F4TWk0MUlEaDZJaTgrUEM5emRtYysiKSxhPWQoIiIsCmEuZnVuY3QsbnVsbCxteFJlc291cmNlcy5nZXQoInJlZG8iKSsiICgiK2Euc2hvcnRjdXQrIikiLGEsImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1UZ3VOQ0F4TUM0MlF6RTJMalUxSURndU9Ua2dNVFF1TVRVZ09DQXhNUzQxSURoakxUUXVOalVnTUMwNExqVTRJRE11TURNdE9TNDVOaUEzTGpJeVRETXVPU0F4Tm1NeExqQTFMVE11TVRrZ05DNHdOUzAxTGpVZ055NDJMVFV1TlNBeExqazFJREFnTXk0M015NDNNaUExTGpFeUlERXVPRGhNTVRNZ01UWm9PVlkzYkMwekxqWWdNeTQyZWlJdlBqd3ZjM1puUGc9PSIpLGUoW2MsYV0sNjApLDQ4MDw9Zikpe3ZhciBhPWwuYWN0aW9ucy5nZXQoInpvb21JbiIpLGM9bC5hY3Rpb25zLmdldCgiem9vbU91dCIpLGc9bC5hY3Rpb25zLmdldCgicmVzZXRWaWV3Iik7CmUoW2QoIiIsZnVuY3Rpb24oKXttLnBvcHVwTWVudUhhbmRsZXIuaGlkZU1lbnUoKTt2YXIgYT1tLnZpZXcuc2NhbGUsYj1tLnZpZXcudHJhbnNsYXRlLngsYz1tLnZpZXcudHJhbnNsYXRlLnk7bC5hY3Rpb25zLmdldCgicmVzZXRWaWV3IikuZnVuY3QoKTsxRS01Pk1hdGguYWJzKGEtbS52aWV3LnNjYWxlKSYmYj09bS52aWV3LnRyYW5zbGF0ZS54JiZjPT1tLnZpZXcudHJhbnNsYXRlLnkmJmwuYWN0aW9ucy5nZXQobS5wYWdlVmlzaWJsZT8iZml0UGFnZSI6ImZpdFdpbmRvdyIpLmZ1bmN0KCl9LCEwLG14UmVzb3VyY2VzLmdldCgiZml0IikrIiAoIitFZGl0b3IuY3RybEtleSsiK0gpIixnLCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElqNDhjR0YwYUNCa1BTSk5NeUExZGpSb01sWTFhRFJXTTBnMVl5MHhMakVnTUMweUlDNDVMVElnTW5wdE1pQXhNRWd6ZGpSak1DQXhMakV1T1NBeUlESWdNbWcwZGkweVNEVjJMVFI2YlRFMElEUm9MVFIyTW1nMFl6RXVNU0F3SURJdExqa2dNaTB5ZGkwMGFDMHlkalI2YlRBdE1UWm9MVFIyTW1nMGRqUm9NbFkxWXpBdE1TNHhMUzQ1TFRJdE1pMHllaUl2UGp3dmMzWm5QZz09IiksCjY0MDw9Zj9kKCIiLGEuZnVuY3QsITAsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tSW4iKSsiICgiK0VkaXRvci5jdHJsS2V5KyIgKykiLGEsImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1UVXVOU0F4TkdndExqYzViQzB1TWpndExqSTNRekUxTGpReElERXlMalU1SURFMklERXhMakV4SURFMklEa3VOU0F4TmlBMUxqa3hJREV6TGpBNUlETWdPUzQxSUROVE15QTFMamt4SURNZ09TNDFJRFV1T1RFZ01UWWdPUzQxSURFMll6RXVOakVnTUNBekxqQTVMUzQxT1NBMExqSXpMVEV1TlRkc0xqSTNMakk0ZGk0M09XdzFJRFF1T1RsTU1qQXVORGtnTVRsc0xUUXVPVGt0TlhwdExUWWdNRU0zTGpBeElERTBJRFVnTVRFdU9Ua2dOU0E1TGpWVE55NHdNU0ExSURrdU5TQTFJREUwSURjdU1ERWdNVFFnT1M0MUlERXhMams1SURFMElEa3VOU0F4TkhwdE1pNDFMVFJvTFRKMk1rZzVkaTB5U0RkV09XZ3lWamRvTVhZeWFESjJNWG9pTHo0OEwzTjJaejQ9Iik6Cm51bGwsNjQwPD1mP2QoIiIsYy5mdW5jdCwhMCxteFJlc291cmNlcy5nZXQoInpvb21PdXQiKSsiICgiK0VkaXRvci5jdHJsS2V5KyIgLSkiLGMsImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWo0OGNHRjBhQ0JrUFNKTk1UVXVOU0F4TkdndExqYzViQzB1TWpndExqSTNRekUxTGpReElERXlMalU1SURFMklERXhMakV4SURFMklEa3VOU0F4TmlBMUxqa3hJREV6TGpBNUlETWdPUzQxSUROVE15QTFMamt4SURNZ09TNDFJRFV1T1RFZ01UWWdPUzQxSURFMll6RXVOakVnTUNBekxqQTVMUzQxT1NBMExqSXpMVEV1TlRkc0xqSTNMakk0ZGk0M09XdzFJRFF1T1RsTU1qQXVORGtnTVRsc0xUUXVPVGt0TlhwdExUWWdNRU0zTGpBeElERTBJRFVnTVRFdU9Ua2dOU0E1TGpWVE55NHdNU0ExSURrdU5TQTFJREUwSURjdU1ERWdNVFFnT1M0MUlERXhMams1SURFMElEa3VOU0F4TkhwTk55QTVhRFYyTVVnM2VpSXZQand2YzNablBnPT0iKToKbnVsbF0sNjApfWE9bC5tZW51cy5nZXQoImxhbmd1YWdlIik7bnVsbCE9YSYmIW14Q2xpZW50LklTX0NIUk9NRUFQUCYmIUVkaXRvclVpLmlzRWxlY3Ryb25BcHAmJjYwMDw9Zj8obnVsbD09USYmKGM9cS5hZGRNZW51KCIiLGEuZnVuY3QpLGMuc2V0QXR0cmlidXRlKCJ0aXRsZSIsbXhSZXNvdXJjZXMuZ2V0KCJsYW5ndWFnZSIpKSxjLmNsYXNzTmFtZT0iZ2VUb29sYmFyQnV0dG9uIixjLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrRWRpdG9yLmdsb2JlSW1hZ2UrIikiLGMuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJjZW50ZXIgY2VudGVyIixjLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCIsYy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZT0iMjRweCAyNHB4IixjLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSIsYy5zdHlsZS5oZWlnaHQ9IjI0cHgiLGMuc3R5bGUud2lkdGg9IjI0cHgiLGMuc3R5bGUuekluZGV4PSIxIixjLnN0eWxlLnJpZ2h0PSI4cHgiLGMuc3R5bGUuY3Vyc29yPQoicG9pbnRlciIsYy5zdHlsZS50b3A9IjEiPT11cmxQYXJhbXMuZW1iZWQ/IjEycHgiOiIxMXB4IixuLmFwcGVuZENoaWxkKGMpLFE9YyksbC5idXR0b25Db250YWluZXIuc3R5bGUucGFkZGluZ1JpZ2h0PSIzNHB4Iik6KGwuYnV0dG9uQ29udGFpbmVyLnN0eWxlLnBhZGRpbmdSaWdodD0iNHB4IixudWxsIT1RJiYoUS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKFEpLFE9bnVsbCkpfXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2suc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDowcHg7cmlnaHQ6MHB4O3RvcDowcHg7b3ZlcmZsb3cteTphdXRvO292ZXJmbG93LXg6aGlkZGVuOyI7ay5zdHlsZS5ib3R0b209IjEiIT11cmxQYXJhbXMuZW1iZWR8fCIxIj09dXJsUGFyYW1zLmxpYnJhcmllcz8iNjNweCI6IjMycHgiO3RoaXMuc2lkZWJhcj10aGlzLmNyZWF0ZVNpZGViYXIoayk7KDFFMzw9Znx8bnVsbCE9dXJsUGFyYW1zLmNsaWJzfHwKbnVsbCE9dXJsUGFyYW1zLmxpYnMpJiZjKHRoaXMsITApOzFFMzw9ZiYmYSh0aGlzLCEwKTt2YXIgbD10aGlzLG09bC5lZGl0b3IuZ3JhcGg7bC50b29sYmFyPXRoaXMuY3JlYXRlVG9vbGJhcihsLmNyZWF0ZURpdigiZ2VUb29sYmFyIikpO2wuZGVmYXVsdExpYnJhcnlOYW1lPW14UmVzb3VyY2VzLmdldCgidW50aXRsZWRMaWJyYXJ5Iik7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bi5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjBweDtyaWdodDowcHg7dG9wOjBweDtoZWlnaHQ6MzBweDtwYWRkaW5nOjhweDtib3JkZXItYm90dG9tOjFweCBzb2xpZCBsaWdodGdyYXk7YmFja2dyb3VuZC1jb2xvcjojZmZmZmZmO3RleHQtYWxpZ246bGVmdDt3aGl0ZS1zcGFjZTpub3dyYXA7Ijt2YXIgcD1udWxsLHE9bmV3IE1lbnViYXIobCxuKTtsLnN0YXR1c0NvbnRhaW5lcj1sLmNyZWF0ZVN0YXR1c0NvbnRhaW5lcigpO2wuc3RhdHVzQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPQoicmVsYXRpdmUiO2wuc3RhdHVzQ29udGFpbmVyLnN0eWxlLm1heFdpZHRoPSIiO2wuc3RhdHVzQ29udGFpbmVyLnN0eWxlLm1hcmdpblRvcD0iN3B4IjtsLnN0YXR1c0NvbnRhaW5lci5zdHlsZS5tYXJnaW5MZWZ0PSI2cHgiO2wuc3RhdHVzQ29udGFpbmVyLnN0eWxlLmNvbG9yPSJncmF5IjtsLnN0YXR1c0NvbnRhaW5lci5zdHlsZS5jdXJzb3I9ImRlZmF1bHQiO2wuZWRpdG9yLmFkZExpc3RlbmVyKCJzdGF0dXNDaGFuZ2VkIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2wuc2V0U3RhdHVzVGV4dChsLmVkaXRvci5nZXRTdGF0dXMoKSl9KSk7dmFyIHY9bC5kZXNjcmlwdG9yQ2hhbmdlZDtsLmRlc2NyaXB0b3JDaGFuZ2VkPWZ1bmN0aW9uKCl7di5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9bC5nZXRDdXJyZW50RmlsZSgpO2lmKG51bGwhPWEmJm51bGwhPWEuZ2V0VGl0bGUoKSl7dmFyIGI9YS5nZXRNb2RlKCk7Imdvb2dsZSI9PWI/Yj0iZ29vZ2xlRHJpdmUiOiJnaXRodWIiPT0KYj9iPSJnaXRIdWIiOiJnaXRsYWIiPT1iP2I9ImdpdExhYiI6Im9uZWRyaXZlIj09YiYmKGI9Im9uZURyaXZlIik7Yj1teFJlc291cmNlcy5nZXQoYik7bi5zZXRBdHRyaWJ1dGUoInRpdGxlIixhLmdldFRpdGxlKCkrKG51bGwhPWI/IiAoIitiKyIpIjoiIikpfWVsc2Ugbi5yZW1vdmVBdHRyaWJ1dGUoInRpdGxlIil9O2wuc2V0U3RhdHVzVGV4dChsLmVkaXRvci5nZXRTdGF0dXMoKSk7bi5hcHBlbmRDaGlsZChsLnN0YXR1c0NvbnRhaW5lcik7bC5idXR0b25Db250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bC5idXR0b25Db250YWluZXIuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MHB4O3BhZGRpbmctcmlnaHQ6MzRweDt0b3A6MTBweDt3aGl0ZS1zcGFjZTpub3dyYXA7cGFkZGluZy10b3A6MnB4O2JhY2tncm91bmQtY29sb3I6aW5oZXJpdDsiO24uYXBwZW5kQ2hpbGQobC5idXR0b25Db250YWluZXIpO2wubWVudWJhckNvbnRhaW5lcj0KbC5idXR0b25Db250YWluZXI7bC50YWJDb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7bC50YWJDb250YWluZXIuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7bGVmdDowcHg7cmlnaHQ6MHB4O2JvdHRvbTowcHg7aGVpZ2h0OjMwcHg7d2hpdGUtc3BhY2U6bm93cmFwO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIGxpZ2h0Z3JheTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmY7Ym9yZGVyLXRvcDoxcHggc29saWQgbGlnaHRncmF5O21hcmdpbi1ib3R0b206LTJweDt2aXNpYmlsaXR5OmhpZGRlbjsiO3ZhciBrPWwuZGlhZ3JhbUNvbnRhaW5lci5wYXJlbnROb2RlLHU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7dS5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MHB4O2xlZnQ6MHB4O3JpZ2h0OjBweDtib3R0b206MHB4O292ZXJmbG93OmhpZGRlbjsiO2wuZGlhZ3JhbUNvbnRhaW5lci5zdHlsZS50b3A9IjQ3cHgiO3ZhciBLPQpsLm1lbnVzLmdldCgidmlld1pvb20iKTtpZihudWxsIT1LKXt0aGlzLnRhYkNvbnRhaW5lci5zdHlsZS5yaWdodD0iNzBweCI7dmFyIEE9cS5hZGRNZW51KCIxMDAlIixLLmZ1bmN0KTtBLnNldEF0dHJpYnV0ZSgidGl0bGUiLG14UmVzb3VyY2VzLmdldCgiem9vbSIpKyIgKEFsdCtNb3VzZXdoZWVsKSIpO0Euc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtBLnN0eWxlLmJhY2tncm91bmRJbWFnZT0idXJsKCIrbXhXaW5kb3cucHJvdG90eXBlLm1pbmltaXplSW1hZ2UrIikiO0Euc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uPSJyaWdodCA2cHggY2VudGVyIjtBLnN0eWxlLmJhY2tncm91bmRSZXBlYXQ9Im5vLXJlcGVhdCI7QS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNmZmZmZmYiO0Euc3R5bGUucGFkZGluZ1JpZ2h0PSIxMHB4IjtBLnN0eWxlLmRpc3BsYXk9ImJsb2NrIjtBLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7QS5zdHlsZS50ZXh0RGVjb3JhdGlvbj0ibm9uZSI7QS5zdHlsZS50ZXh0RGVjb3JhdGlvbj0KIm5vbmUiO0Euc3R5bGUucmlnaHQ9IjBweCI7QS5zdHlsZS5ib3R0b209IjBweCI7QS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtBLnN0eWxlLnZpc2liaWxpdHk9ImhpZGRlbiI7QS5zdHlsZS50ZXh0QWxpZ249ImNlbnRlciI7QS5zdHlsZS5jb2xvcj0iIzAwMCI7QS5zdHlsZS5mb250U2l6ZT0iMTJweCI7QS5zdHlsZS5jb2xvcj0iIzcwNzA3MCI7QS5zdHlsZS53aWR0aD0iNTlweCI7QS5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO0Euc3R5bGUuYm9yZGVyVG9wPSIxcHggc29saWQgbGlnaHRncmF5IjtBLnN0eWxlLmJvcmRlckxlZnQ9IjFweCBzb2xpZCBsaWdodGdyYXkiO0Euc3R5bGUuaGVpZ2h0PXBhcnNlSW50KGwudGFiQ29udGFpbmVySGVpZ2h0KS0xKyJweCI7QS5zdHlsZS5saW5lSGVpZ2h0PXBhcnNlSW50KGwudGFiQ29udGFpbmVySGVpZ2h0KSsxKyJweCI7dS5hcHBlbmRDaGlsZChBKTtLPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7QS5pbm5lckhUTUw9TWF0aC5yb3VuZCgxMDAqCmwuZWRpdG9yLmdyYXBoLnZpZXcuc2NhbGUpKyIlIn0pO2wuZWRpdG9yLmdyYXBoLnZpZXcuYWRkTGlzdGVuZXIobXhFdmVudC5FVkVOVF9TQ0FMRSxLKTtsLmVkaXRvci5hZGRMaXN0ZW5lcigicmVzZXRHcmFwaFZpZXciLEspO2wuZWRpdG9yLmFkZExpc3RlbmVyKCJwYWdlU2VsZWN0ZWQiLEspO3ZhciBNPWwuc2V0R3JhcGhFbmFibGVkO2wuc2V0R3JhcGhFbmFibGVkPWZ1bmN0aW9uKCl7TS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bnVsbCE9dGhpcy50YWJDb250YWluZXImJihBLnN0eWxlLnZpc2liaWxpdHk9dGhpcy50YWJDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSx0aGlzLmRpYWdyYW1Db250YWluZXIuc3R5bGUuYm90dG9tPSJoaWRkZW4iIT10aGlzLnRhYkNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5P3RoaXMudGFiQ29udGFpbmVySGVpZ2h0KyJweCI6IjBweCIpfX11LmFwcGVuZENoaWxkKGwudGFiQ29udGFpbmVyKTt1LmFwcGVuZENoaWxkKG4pO3UuYXBwZW5kQ2hpbGQobC5kaWFncmFtQ29udGFpbmVyKTsKay5hcHBlbmRDaGlsZCh1KTtsLnVwZGF0ZVRhYkNvbnRhaW5lcigpO3ZhciBRPW51bGw7ZygpO214RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJyZXNpemUiLGZ1bmN0aW9uKCl7ZygpO251bGwhPWwuc2lkZWJhcldpbmRvdyYmbC5zaWRlYmFyV2luZG93LndpbmRvdy5maXQoKTtudWxsIT1sLmZvcm1hdFdpbmRvdyYmbC5mb3JtYXRXaW5kb3cud2luZG93LmZpdCgpO251bGwhPWwuYWN0aW9ucy5vdXRsaW5lV2luZG93JiZsLmFjdGlvbnMub3V0bGluZVdpbmRvdy53aW5kb3cuZml0KCk7bnVsbCE9bC5hY3Rpb25zLmxheWVyc1dpbmRvdyYmbC5hY3Rpb25zLmxheWVyc1dpbmRvdy53aW5kb3cuZml0KCk7bnVsbCE9bC5tZW51cy50YWdzV2luZG93JiZsLm1lbnVzLnRhZ3NXaW5kb3cud2luZG93LmZpdCgpO251bGwhPWwubWVudXMuZmluZFdpbmRvdyYmbC5tZW51cy5maW5kV2luZG93LndpbmRvdy5maXQoKX0pfX19OwooZnVuY3Rpb24oKXt2YXIgYT0hMTsibWluIiE9dWlUaGVtZXx8YXx8bXhDbGllbnQuSVNfQ0hST01FQVBQfHwoRWRpdG9yVWkuaW5pdE1pbmltYWxUaGVtZSgpLGE9ITApO3ZhciBjPUVkaXRvclVpLmluaXRUaGVtZTtFZGl0b3JVaS5pbml0VGhlbWU9ZnVuY3Rpb24oKXtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsibWluIiE9dWlUaGVtZXx8YXx8KHRoaXMuaW5pdE1pbmltYWxUaGVtZSgpLGE9ITApfX0pKCk7RHJhd2lvQ29tbWVudD1mdW5jdGlvbihhLGMsZixkLGssbSxxKXt0aGlzLmZpbGU9YTt0aGlzLmlkPWM7dGhpcy5jb250ZW50PWY7dGhpcy5tb2RpZmllZERhdGU9ZDt0aGlzLmNyZWF0ZWREYXRlPWs7dGhpcy5pc1Jlc29sdmVkPW07dGhpcy51c2VyPXE7dGhpcy5yZXBsaWVzPVtdfTtEcmF3aW9Db21tZW50LnByb3RvdHlwZS5hZGRSZXBseURpcmVjdD1mdW5jdGlvbihhKXtudWxsIT1hJiZ0aGlzLnJlcGxpZXMucHVzaChhKX07RHJhd2lvQ29tbWVudC5wcm90b3R5cGUuYWRkUmVwbHk9ZnVuY3Rpb24oYSxjLGYsZCxrKXtjKCl9O0RyYXdpb0NvbW1lbnQucHJvdG90eXBlLmVkaXRDb21tZW50PWZ1bmN0aW9uKGEsYyxmKXtjKCl9O0RyYXdpb0NvbW1lbnQucHJvdG90eXBlLmRlbGV0ZUNvbW1lbnQ9ZnVuY3Rpb24oYSxjKXthKCl9O0RyYXdpb1VzZXI9ZnVuY3Rpb24oYSxjLGYsZCxrKXt0aGlzLmlkPWE7dGhpcy5lbWFpbD1jO3RoaXMuZGlzcGxheU5hbWU9Zjt0aGlzLnBpY3R1cmVVcmw9ZDt0aGlzLmxvY2FsZT1rfTtteFJlc291cmNlcy5wYXJzZSgnIyAqRE8gTk9UIERJUkVDVExZIEVESVQgVEhJUyBGSUxFLCBJVCBJUyBBVVRPTUFUSUNBTExZIEdFTkVSQVRFRCBBTkQgSVQgSVMgQkFTRUQgT046KlxuIyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldC9jY2M/a2V5PTBBbVFFTzM2bGlMNEZkREpMV1ZOTWFWVjJVbVJLU25wWFUwOU1Za2RHYkVFXG5hYm91dD1BYm91dCBcbmFib3V0RHJhd2lvPUFib3V0IGRyYXcuaW9cbmFjY2Vzc0RlbmllZD1BY2Nlc3MgRGVuaWVkXG5hY3Rpb249QWN0aW9uXG5hY3R1YWxTaXplPUFjdHVhbCBTaXplXG5hZGQ9QWRkXG5hZGRBY2NvdW50PUFkZCBhY2NvdW50XG5hZGRlZEZpbGU9QWRkZWQgezF9XG5hZGRJbWFnZXM9QWRkIEltYWdlc1xuYWRkSW1hZ2VVcmw9QWRkIEltYWdlIFVSTFxuYWRkTGF5ZXI9QWRkIExheWVyXG5hZGRQcm9wZXJ0eT1BZGQgUHJvcGVydHlcbmFkZHJlc3M9QWRkcmVzc1xuYWRkVG9FeGlzdGluZ0RyYXdpbmc9QWRkIHRvIEV4aXN0aW5nIERyYXdpbmdcbmFkZFdheXBvaW50PUFkZCBXYXlwb2ludFxuYWRqdXN0VG89QWRqdXN0IHRvXG5hZHZhbmNlZD1BZHZhbmNlZFxuYWxpZ249QWxpZ25cbmFsaWdubWVudD1BbGlnbm1lbnRcbmFsbENoYW5nZXNMb3N0PUFsbCBjaGFuZ2VzIHdpbGwgYmUgbG9zdCFcbmFsbFBhZ2VzPUFsbCBQYWdlc1xuYWxsUHJvamVjdHM9QWxsIFByb2plY3RzXG5hbGxTcGFjZXM9QWxsIFNwYWNlc1xuYWxsVGFncz1BbGwgVGFnc1xuYW5jaG9yPUFuY2hvclxuYW5kcm9pZD1BbmRyb2lkXG5hbmdsZT1BbmdsZVxuYXJjPUFyY1xuYXJlWW91U3VyZT1BcmUgeW91IHN1cmU/XG5lbnN1cmVEYXRhU2F2ZWQ9UGxlYXNlIGVuc3VyZSB5b3VyIGRhdGEgaXMgc2F2ZWQgYmVmb3JlIGNsb3NpbmcuXG5hbGxDaGFuZ2VzU2F2ZWQ9QWxsIGNoYW5nZXMgc2F2ZWRcbmFsbENoYW5nZXNTYXZlZEluRHJpdmU9QWxsIGNoYW5nZXMgc2F2ZWQgaW4gRHJpdmVcbmFsbG93UG9wdXBzPUFsbG93IHBvcC11cHMgdG8gYXZvaWQgdGhpcyBkaWFsb2cuXG5hbGxvd1JlbGF0aXZlVXJsPUFsbG93IHJlbGF0aXZlIFVSTFxuYWxyZWFkeUNvbm5lY3RlZD1Ob2RlcyBhbHJlYWR5IGNvbm5lY3RlZFxuYXBwbHk9QXBwbHlcbmFyY2hpTWF0ZTIxPUFyY2hpTWF0ZSAyLjFcbmFycmFuZ2U9QXJyYW5nZVxuYXJyb3c9QXJyb3dcbmFycm93cz1BcnJvd3NcbmFzTmV3PUFzIE5ld1xuYXRsYXM9QXRsYXNcbmF1dGhvcj1BdXRob3JcbmF1dGhvcml6YXRpb25SZXF1aXJlZD1BdXRob3JpemF0aW9uIHJlcXVpcmVkXG5hdXRob3JpemVUaGlzQXBwSW49QXV0aG9yaXplIHRoaXMgYXBwIGluIHsxfTpcbmF1dGhvcml6ZT1BdXRob3JpemVcbmF1dGhvcml6aW5nPUF1dGhvcml6aW5nXG5hdXRvbWF0aWM9QXV0b21hdGljXG5hdXRvc2F2ZT1BdXRvc2F2ZVxuYXV0b3NpemU9QXV0b3NpemVcbmF0dGFjaG1lbnRzPUF0dGFjaG1lbnRzXG5hd3M9QVdTXG5hd3MzZD1BV1MgM0RcbmF6dXJlPUF6dXJlXG5iYWNrPUJhY2tcbmJhY2tncm91bmQ9QmFja2dyb3VuZFxuYmFja2dyb3VuZENvbG9yPUJhY2tncm91bmQgQ29sb3JcbmJhY2tncm91bmRJbWFnZT1CYWNrZ3JvdW5kIEltYWdlXG5iYXNpYz1CYXNpY1xuYmxhbmtEcmF3aW5nPUJsYW5rIERyYXdpbmdcbmJsYW5rRGlhZ3JhbT1CbGFuayBEaWFncmFtXG5ibG9jaz1CbG9ja1xuYmxvY2txdW90ZT1CbG9ja3F1b3RlXG5ibG9nPUJsb2dcbmJvbGQ9Qm9sZFxuYm9vdHN0cmFwPUJvb3RzdHJhcFxuYm9yZGVyPUJvcmRlclxuYm9yZGVyQ29sb3I9Qm9yZGVyIENvbG9yXG5ib3JkZXJXaWR0aD1Cb3JkZXIgV2lkdGhcbmJvdHRvbT1Cb3R0b21cbmJvdHRvbUFsaWduPUJvdHRvbSBBbGlnblxuYm90dG9tTGVmdD1Cb3R0b20gTGVmdFxuYm90dG9tUmlnaHQ9Qm90dG9tIFJpZ2h0XG5icG1uPUJQTU5cbmJyb3dzZXI9QnJvd3NlclxuYnVsbGV0ZWRMaXN0PUJ1bGxldGVkIExpc3RcbmJ1c2luZXNzPUJ1c2luZXNzXG5idXN5PU9wZXJhdGlvbiBpbiBwcm9ncmVzc1xuY2FiaW5ldHM9Q2FiaW5ldHNcbmNhbmNlbD1DYW5jZWxcbmNlbnRlcj1DZW50ZXJcbmNhbm5vdExvYWQ9TG9hZCBhdHRlbXB0cyBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXG5jYW5ub3RMb2dpbj1Mb2cgaW4gYXR0ZW1wdHMgZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlxuY2Fubm90T3BlbkZpbGU9Q2Fubm90IG9wZW4gZmlsZVxuY2hhbmdlPUNoYW5nZVxuY2hhbmdlT3JpZW50YXRpb249Q2hhbmdlIE9yaWVudGF0aW9uXG5jaGFuZ2VVc2VyPUNoYW5nZSB1c2VyXG5jaGFuZ2VTdG9yYWdlPUNoYW5nZSBzdG9yYWdlXG5jaGFuZ2VzTm90U2F2ZWQ9Q2hhbmdlcyBoYXZlIG5vdCBiZWVuIHNhdmVkXG5jbGFzc0RpYWdyYW09Q2xhc3MgRGlhZ3JhbVxudXNlckpvaW5lZD17MX0gaGFzIGpvaW5lZFxudXNlckxlZnQ9ezF9IGhhcyBsZWZ0XG5jaGF0V2luZG93VGl0bGU9Q2hhdFxuY2hvb3NlQW5PcHRpb249Q2hvb3NlIGFuIG9wdGlvblxuY2hyb21lQXBwPUNocm9tZSBBcHBcbmNvbGxhYm9yYXRpdmVFZGl0aW5nTm90aWNlPUltcG9ydGFudCBOb3RpY2UgZm9yIENvbGxhYm9yYXRpdmUgRWRpdGluZ1xuY29tcHJlc3NlZD1Db21wcmVzc2VkXG5jb21taXRNZXNzYWdlPUNvbW1pdCBNZXNzYWdlXG5jb25maWdMaW5rV2Fybj1UaGlzIGxpbmsgY29uZmlndXJlcyBkcmF3LmlvLiBPbmx5IGNsaWNrIE9LIGlmIHlvdSB0cnVzdCB3aG9ldmVyIGdhdmUgeW91IGl0IVxuY29uZmlnTGlua0NvbmZpcm09Q2xpY2sgT0sgdG8gY29uZmlndXJlIGFuZCByZXN0YXJ0IGRyYXcuaW8uXG5jc3Y9Q1NWXG5kYXJrPURhcmtcbmRpYWdyYW1YbWxEZXNjPVhNTCBGaWxlXG5kaWFncmFtSHRtbERlc2M9SFRNTCBGaWxlXG5kaWFncmFtUG5nRGVzYz1FZGl0YWJsZSBCaXRtYXAgSW1hZ2VcbmRpYWdyYW1TdmdEZXNjPUVkaXRhYmxlIFZlY3RvciBJbWFnZVxuZGlkWW91TWVhblRvRXhwb3J0VG9QZGY9RGlkIHlvdSBtZWFuIHRvIGV4cG9ydCB0byBQREY/XG5kcmFmdEZvdW5kPUEgZHJhZnQgZm9yIFwnezF9XCcgaGFzIGJlZW4gZm91bmQuIExvYWQgaXQgaW50byB0aGUgZWRpdG9yIG9yIGRpc2NhcmQgaXQgdG8gY29udGludWUuXG5zZWxlY3REcmFmdD1TZWxlY3QgYSBkcmFmdCB0byBjb250aW51ZSBlZGl0aW5nOlxuZHJhZ0FuZERyb3BOb3RTdXBwb3J0ZWQ9RHJhZyBhbmQgZHJvcCBub3Qgc3VwcG9ydGVkIGZvciBpbWFnZXMuIFdvdWxkIHlvdSBsaWtlIHRvIGltcG9ydCBpbnN0ZWFkP1xuZHJvcGJveENoYXJzTm90QWxsb3dlZD1UaGUgZm9sbG93aW5nIGNoYXJhY3RlcnMgYXJlIG5vdCBhbGxvd2VkOiAgLyA6ID8gKiAiIHxcbmNoZWNrPUNoZWNrXG5jaGVja3N1bT1DaGVja3N1bVxuY2lyY2xlPUNpcmNsZVxuY2lzY289Q2lzY29cbmNsYXNzaWM9Q2xhc3NpY1xuY2xlYXJEZWZhdWx0U3R5bGU9Q2xlYXIgRGVmYXVsdCBTdHlsZVxuY2xlYXJXYXlwb2ludHM9Q2xlYXIgV2F5cG9pbnRzXG5jbGlwYXJ0PUNsaXBhcnRcbmNsb3NlPUNsb3NlXG5jbG9zaW5nRmlsZT1DbG9zaW5nIGZpbGVcbmNvbGxhYm9yYXRvcj1Db2xsYWJvcmF0b3JcbmNvbGxhYm9yYXRvcnM9Q29sbGFib3JhdG9yc1xuY29sbGFwc2U9Q29sbGFwc2VcbmNvbGxhcHNlRXhwYW5kPUNvbGxhcHNlL0V4cGFuZFxuY29sbGFwc2UtZXhwYW5kPUNsaWNrIHRvIGNvbGxhcHNlL2V4cGFuZFxuU2hpZnQtY2xpY2sgdG8gbW92ZSBuZWlnaGJvcnMgXG5BbHQtY2xpY2sgdG8gcHJvdGVjdCBncm91cCBzaXplXG5jb2xsYXBzaWJsZT1Db2xsYXBzaWJsZVxuY29taWM9Q29taWNcbmNvbW1lbnQ9Q29tbWVudFxuY29tbWVudHNOb3Rlcz1Db21tZW50cy9Ob3Rlc1xuY29tcHJlc3M9Q29tcHJlc3NcbmNvbmZpZ3VyYXRpb249Q29uZmlndXJhdGlvblxuY29ubmVjdD1Db25uZWN0XG5jb25uZWN0aW5nPUNvbm5lY3RpbmdcbmNvbm5lY3RXaXRoRHJpdmU9Q29ubmVjdCB3aXRoIEdvb2dsZSBEcml2ZVxuY29ubmVjdGlvbj1Db25uZWN0aW9uXG5jb25uZWN0aW9uQXJyb3dzPUNvbm5lY3Rpb24gQXJyb3dzXG5jb25uZWN0aW9uUG9pbnRzPUNvbm5lY3Rpb24gUG9pbnRzXG5jb25zdHJhaW5Qcm9wb3J0aW9ucz1Db25zdHJhaW4gUHJvcG9ydGlvbnNcbmNvbnRhaW5zVmFsaWRhdGlvbkVycm9ycz1Db250YWlucyB2YWxpZGF0aW9uIGVycm9yc1xuY29waWVkVG9DbGlwYm9hcmQ9Q29waWVkIHRvIGNsaXBib2FyZFxuY29weT1Db3B5XG5jb3B5Q29ubmVjdD1Db3B5IG9uIGNvbm5lY3RcbmNvcHlDcmVhdGVkPUEgY29weSBvZiB0aGUgZmlsZSB3YXMgY3JlYXRlZC5cbmNvcHlPZj1Db3B5IG9mIHsxfVxuY29weU9mRHJhd2luZz1Db3B5IG9mIERyYXdpbmdcbmNvcHlTaXplPUNvcHkgU2l6ZVxuY29weVN0eWxlPUNvcHkgU3R5bGVcbmNyZWF0ZT1DcmVhdGVcbmNyZWF0ZU5ld0RpYWdyYW09Q3JlYXRlIE5ldyBEaWFncmFtXG5jcmVhdGVSZXZpc2lvbj1DcmVhdGUgUmV2aXNpb25cbmNyZWF0ZVNoYXBlPUNyZWF0ZSBTaGFwZVxuY3JvcD1Dcm9wXG5jdXJ2ZWQ9Q3VydmVkXG5jdXN0b209Q3VzdG9tXG5jdXJyZW50PUN1cnJlbnRcbmN1cnJlbnRQYWdlPUN1cnJlbnQgcGFnZVxuY3V0PUN1dFxuZGFzaGVkPURhc2hlZFxuZGVjaWRlTGF0ZXI9RGVjaWRlIGxhdGVyXG5kZWZhdWx0PURlZmF1bHRcbmRlbGV0ZT1EZWxldGVcbmRlbGV0ZUNvbHVtbj1EZWxldGUgQ29sdW1uXG5kZWxldGVMaWJyYXJ5NDAxPUluc3VmZmljaWVudCBwZXJtaXNzaW9ucyB0byBkZWxldGUgdGhpcyBsaWJyYXJ5XG5kZWxldGVMaWJyYXJ5NDA0PVNlbGVjdGVkIGxpYnJhcnkgY291bGQgbm90IGJlIGZvdW5kXG5kZWxldGVMaWJyYXJ5NTAwPUVycm9yIGRlbGV0aW5nIGxpYnJhcnlcbmRlbGV0ZUxpYnJhcnlDb25maXJtPVlvdSBhcmUgYWJvdXQgdG8gcGVybWFuZW50bHkgZGVsZXRlIHRoaXMgbGlicmFyeS4gQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRvIHRoaXM/XG5kZWxldGVSb3c9RGVsZXRlIFJvd1xuZGVzY3JpcHRpb249RGVzY3JpcHRpb25cbmRldmljZT1EZXZpY2VcbmRpYWdyYW09RGlhZ3JhbVxuZGlhZ3JhbUNvbnRlbnQ9RGlhZ3JhbSBDb250ZW50XG5kaWFncmFtTG9ja2VkPURpYWdyYW0gaGFzIGJlZW4gbG9ja2VkIHRvIHByZXZlbnQgZnVydGhlciBkYXRhIGxvc3MuXG5kaWFncmFtTG9ja2VkQnlTaW5jZT1UaGUgZGlhZ3JhbSBpcyBsb2NrZWQgYnkgezF9IHNpbmNlIHsyfSBhZ29cbmRpYWdyYW1OYW1lPURpYWdyYW0gTmFtZVxuZGlhZ3JhbUlzUHVibGljPURpYWdyYW0gaXMgcHVibGljXG5kaWFncmFtSXNOb3RQdWJsaWM9RGlhZ3JhbSBpcyBub3QgcHVibGljXG5kaWFtb25kPURpYW1vbmRcbmRpYW1vbmRUaGluPURpYW1vbmQgKHRoaW4pXG5kaWRZb3VLbm93PURpZCB5b3Uga25vdy4uLlxuZGlyZWN0aW9uPURpcmVjdGlvblxuZGlzY2FyZD1EaXNjYXJkXG5kaXNjYXJkQ2hhbmdlc0FuZFJlY29ubmVjdD1EaXNjYXJkIENoYW5nZXMgYW5kIFJlY29ubmVjdFxuZ29vZ2xlRHJpdmVNaXNzaW5nQ2xpY2tIZXJlPUdvb2dsZSBEcml2ZSBtaXNzaW5nPyBDbGljayBoZXJlIVxuZGlzY2FyZENoYW5nZXM9RGlzY2FyZCBDaGFuZ2VzXG5kaXNjb25uZWN0ZWQ9RGlzY29ubmVjdGVkXG5kaXN0cmlidXRlPURpc3RyaWJ1dGVcbmRvbmU9RG9uZVxuZG9Ob3RTaG93QWdhaW49RG8gbm90IHNob3cgYWdhaW5cbmRvdHRlZD1Eb3R0ZWRcbmRvdWJsZUNsaWNrT3JpZW50YXRpb249RG91YmxlY2xpY2sgdG8gY2hhbmdlIG9yaWVudGF0aW9uXG5kb3VibGVDbGlja1Rvb2x0aXA9RG91YmxlY2xpY2sgdG8gaW5zZXJ0IHRleHRcbmRvdWJsZUNsaWNrQ2hhbmdlUHJvcGVydHk9RG91YmxlY2xpY2sgdG8gY2hhbmdlIHByb3BlcnR5IG5hbWVcbmRvd25sb2FkPURvd25sb2FkXG5kb3dubG9hZERlc2t0b3A9R2V0IERlc2t0b3BcbmRvd25sb2FkQXM9RG93bmxvYWQgYXNcbmNsaWNrSGVyZVRvU2F2ZT1DbGljayBoZXJlIHRvIHNhdmUuXG5kcGk9RFBJXG5kcmFmdERpc2NhcmRlZD1EcmFmdCBkaXNjYXJkZWRcbmRyYWZ0U2F2ZWQ9RHJhZnQgc2F2ZWRcbmRyYWdFbGVtZW50c0hlcmU9RHJhZyBlbGVtZW50cyBoZXJlXG5kcmFnSW1hZ2VzSGVyZT1EcmFnIGltYWdlcyBvciBVUkxzIGhlcmVcbmRyYWdVcmxzSGVyZT1EcmFnIFVSTHMgaGVyZVxuZHJhdy5pbz1kcmF3LmlvXG5kcmF3aW5nPURyYXdpbmd7MX1cbmRyYXdpbmdFbXB0eT1EcmF3aW5nIGlzIGVtcHR5XG5kcmF3aW5nVG9vTGFyZ2U9RHJhd2luZyBpcyB0b28gbGFyZ2VcbmRyYXdpb0Zvcldvcms9RHJhdy5pbyBmb3IgR1N1aXRlXG5kcm9wYm94PURyb3Bib3hcbmR1cGxpY2F0ZT1EdXBsaWNhdGVcbmR1cGxpY2F0ZUl0PUR1cGxpY2F0ZSB7MX1cbmRpdmlkZXI9RGl2aWRlclxuZHg9RHhcbmR5PUR5XG5lYXN0PUVhc3RcbmVkaXQ9RWRpdFxuZWRpdERhdGE9RWRpdCBEYXRhXG5lZGl0RGlhZ3JhbT1FZGl0IERpYWdyYW1cbmVkaXRHZW9tZXRyeT1FZGl0IEdlb21ldHJ5XG5lZGl0SW1hZ2U9RWRpdCBJbWFnZVxuZWRpdEltYWdlVXJsPUVkaXQgSW1hZ2UgVVJMXG5lZGl0TGluaz1FZGl0IExpbmtcbmVkaXRTaGFwZT1FZGl0IFNoYXBlXG5lZGl0U3R5bGU9RWRpdCBTdHlsZVxuZWRpdFRleHQ9RWRpdCBUZXh0XG5lZGl0VG9vbHRpcD1FZGl0IFRvb2x0aXBcbmdsYXNzPUdsYXNzXG5nb29nbGVJbWFnZXM9R29vZ2xlIEltYWdlc1xuaW1hZ2VTZWFyY2g9SW1hZ2UgU2VhcmNoXG5laXA9RUlQXG5lbWJlZD1FbWJlZFxuZW1iZWRJbWFnZXM9RW1iZWQgSW1hZ2VzXG5tYWluRW1iZWROb3RpY2U9UGFzdGUgdGhpcyBpbnRvIHRoZSBwYWdlXG5lbGVjdHJpY2FsPUVsZWN0cmljYWxcbmVsbGlwc2U9RWxsaXBzZVxuZW1iZWROb3RpY2U9UGFzdGUgdGhpcyBvbmNlIGF0IHRoZSBlbmQgb2YgdGhlIHBhZ2VcbmVudGVyR3JvdXA9RW50ZXIgR3JvdXBcbmVudGVyTmFtZT1FbnRlciBOYW1lXG5lbnRlclByb3BlcnR5TmFtZT1FbnRlciBQcm9wZXJ0eSBOYW1lXG5lbnRlclZhbHVlPUVudGVyIFZhbHVlXG5lbnRpdHlSZWxhdGlvbj1FbnRpdHkgUmVsYXRpb25cbmVudGl0eVJlbGF0aW9uc2hpcERpYWdyYW09RW50aXR5IFJlbGF0aW9uc2hpcCBEaWFncmFtXG5lcnJvcj1FcnJvclxuZXJyb3JEZWxldGluZ0ZpbGU9RXJyb3IgZGVsZXRpbmcgZmlsZVxuZXJyb3JMb2FkaW5nRmlsZT1FcnJvciBsb2FkaW5nIGZpbGVcbmVycm9yUmVuYW1pbmdGaWxlPUVycm9yIHJlbmFtaW5nIGZpbGVcbmVycm9yUmVuYW1pbmdGaWxlTm90Rm91bmQ9RXJyb3IgcmVuYW1pbmcgZmlsZS4gRmlsZSB3YXMgbm90IGZvdW5kLlxuZXJyb3JSZW5hbWluZ0ZpbGVGb3JiaWRkZW49RXJyb3IgcmVuYW1pbmcgZmlsZS4gSW5zdWZmaWNpZW50IGFjY2VzcyByaWdodHMuXG5lcnJvclNhdmluZ0RyYWZ0PUVycm9yIHNhdmluZyBkcmFmdFxuZXJyb3JTYXZpbmdGaWxlPUVycm9yIHNhdmluZyBmaWxlXG5lcnJvclNhdmluZ0ZpbGVVbmtub3duPUVycm9yIGF1dGhvcml6aW5nIHdpdGggR29vZ2xlXCdzIHNlcnZlcnMuIFBsZWFzZSByZWZyZXNoIHRoZSBwYWdlIHRvIHJlLWF0dGVtcHQuXG5lcnJvclNhdmluZ0ZpbGVGb3JiaWRkZW49RXJyb3Igc2F2aW5nIGZpbGUuIEluc3VmZmljaWVudCBhY2Nlc3MgcmlnaHRzLlxuZXJyb3JTYXZpbmdGaWxlTmFtZUNvbmZsaWN0PUNvdWxkIG5vdCBzYXZlIGRpYWdyYW0uIEN1cnJlbnQgcGFnZSBhbHJlYWR5IGNvbnRhaW5zIGZpbGUgbmFtZWQgXCd7MX1cJy5cbmVycm9yU2F2aW5nRmlsZU5vdEZvdW5kPUVycm9yIHNhdmluZyBmaWxlLiBGaWxlIHdhcyBub3QgZm91bmQuXG5lcnJvclNhdmluZ0ZpbGVSZWFkT25seU1vZGU9Q291bGQgbm90IHNhdmUgZGlhZ3JhbSB3aGlsZSByZWFkLW9ubHkgbW9kZSBpcyBhY3RpdmUuXG5lcnJvclNhdmluZ0ZpbGVTZXNzaW9uVGltZW91dD1Zb3VyIHNlc3Npb24gaGFzIGVuZGVkLiBQbGVhc2UgPGEgdGFyZ2V0PVwnX2JsYW5rXCcgaHJlZj1cJ3sxfVwnPnsyfTwvYT4gYW5kIHJldHVybiB0byB0aGlzIHRhYiB0byB0cnkgdG8gc2F2ZSBhZ2Fpbi5cbmVycm9yU2VuZGluZ0ZlZWRiYWNrPUVycm9yIHNlbmRpbmcgZmVlZGJhY2suXG5lcnJvclVwZGF0aW5nUHJldmlldz1FcnJvciB1cGRhdGluZyBwcmV2aWV3LlxuZXhpdD1FeGl0XG5leGl0R3JvdXA9RXhpdCBHcm91cFxuZXhwYW5kPUV4cGFuZFxuZXhwb3J0PUV4cG9ydFxuZXhwb3J0aW5nPUV4cG9ydGluZ1xuZXhwb3J0QXM9RXhwb3J0IGFzXG5leHBvcnRPcHRpb25zRGlzYWJsZWQ9RXhwb3J0IG9wdGlvbnMgZGlzYWJsZWRcbmV4cG9ydE9wdGlvbnNEaXNhYmxlZERldGFpbHM9VGhlIG93bmVyIGhhcyBkaXNhYmxlZCBvcHRpb25zIHRvIGRvd25sb2FkLCBwcmludCBvciBjb3B5IGZvciBjb21tZW50ZXJzIGFuZCB2aWV3ZXJzIG9uIHRoaXMgZmlsZS5cbmV4dGVybmFsQ2hhbmdlcz1FeHRlcm5hbCBDaGFuZ2VzXG5leHRyYXM9RXh0cmFzXG5mYWNlYm9vaz1GYWNlYm9va1xuZmFpbGVkVG9TYXZlVHJ5UmVjb25uZWN0PUZhaWxlZCB0byBzYXZlLCB0cnlpbmcgdG8gcmVjb25uZWN0XG5mZWF0dXJlUmVxdWVzdD1GZWF0dXJlIFJlcXVlc3RcbmZlZWRiYWNrPUZlZWRiYWNrXG5mZWVkYmFja1NlbnQ9RmVlZGJhY2sgc3VjY2Vzc2Z1bGx5IHNlbnQuXG5mbG9vcnBsYW5zPUZsb29ycGxhbnNcbmZpbGU9RmlsZVxuZmlsZUNoYW5nZWRPdmVyd3JpdGVEaWFsb2c9VGhlIGZpbGUgaGFzIGJlZW4gbW9kaWZpZWQuIERvIHlvdSB3YW50IHRvIHNhdmUgdGhlIGZpbGUgYW5kIG92ZXJ3cml0ZSB0aG9zZSBjaGFuZ2VzP1xuZmlsZUNoYW5nZWRTeW5jRGlhbG9nPVRoZSBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkLiBEbyB5b3Ugd2FudCB0byBzeW5jaHJvbml6ZSB0aG9zZSBjaGFuZ2VzP1xuZmlsZUNoYW5nZWRTeW5jPVRoZSBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkLiBDbGljayBoZXJlIHRvIHN5bmNocm9uaXplLlxub3ZlcndyaXRlPU92ZXJ3cml0ZVxuc3luY2hyb25pemU9U3luY2hyb25pemVcbmZpbGVuYW1lPUZpbGVuYW1lXG5maWxlRXhpc3RzPUZpbGUgYWxyZWFkeSBleGlzdHNcbmZpbGVNb3ZlZFRvVHJhc2g9RmlsZSB3YXMgbW92ZWQgdG8gdHJhc2hcbmZpbGVOZWFybHlGdWxsU2VlRmFxPUZpbGUgbmVhcmx5IGZ1bGwsIHBsZWFzZSBzZWUgRkFRXG5maWxlTm90Rm91bmQ9RmlsZSBub3QgZm91bmRcbnJlcG9zaXRvcnlOb3RGb3VuZD1SZXBvc2l0b3J5IG5vdCBmb3VuZFxuZmlsZU5vdEZvdW5kT3JEZW5pZWQ9VGhlIGZpbGUgd2FzIG5vdCBmb3VuZC4gSXQgZG9lcyBub3QgZXhpc3Qgb3IgeW91IGRvIG5vdCBoYXZlIGFjY2Vzcy5cbmZpbGVOb3RMb2FkZWQ9RmlsZSBub3QgbG9hZGVkXG5maWxlTm90U2F2ZWQ9RmlsZSBub3Qgc2F2ZWRcbmZpbGVPcGVuTG9jYXRpb249SG93IHdvdWxkIHlvdSBsaWtlIHRvIG9wZW4gdGhlc2UgZmlsZShzKT9cbmZpbGV0eXBlSHRtbD0uaHRtbCBjYXVzZXMgZmlsZSB0byBzYXZlIGFzIEhUTUwgd2l0aCByZWRpcmVjdCB0byBjbG91ZCBVUkxcbmZpbGV0eXBlUG5nPS5wbmcgY2F1c2VzIGZpbGUgdG8gc2F2ZSBhcyBQTkcgd2l0aCBlbWJlZGRlZCBkYXRhXG5maWxldHlwZVN2Zz0uc3ZnIGNhdXNlcyBmaWxlIHRvIHNhdmUgYXMgU1ZHIHdpdGggZW1iZWRkZWQgZGF0YVxuZmlsZVdpbGxCZVNhdmVkSW5BcHBGb2xkZXI9ezF9IHdpbGwgYmUgc2F2ZWQgaW4gdGhlIGFwcCBmb2xkZXIuXG5maWxsPUZpbGxcbmZpbGxDb2xvcj1GaWxsIENvbG9yXG5maWx0ZXJDYXJkcz1GaWx0ZXIgQ2FyZHNcbmZpbmQ9RmluZFxuZml0PUZpdFxuZml0Q29udGFpbmVyPVJlc2l6ZSBDb250YWluZXJcbmZpdEludG9Db250YWluZXI9Rml0IGludG8gQ29udGFpbmVyXG5maXRQYWdlPUZpdCBQYWdlXG5maXRQYWdlV2lkdGg9Rml0IFBhZ2UgV2lkdGhcbmZpdFRvPUZpdCB0b1xuZml0VG9TaGVldHNBY3Jvc3M9c2hlZXQocykgYWNyb3NzXG5maXRUb0J5PWJ5XG5maXRUb1NoZWV0c0Rvd249c2hlZXQocykgZG93blxuZml0VHdvUGFnZXM9VHdvIFBhZ2VzXG5maXRXaW5kb3c9Rml0IFdpbmRvd1xuZmxpcD1GbGlwXG5mbGlwSD1GbGlwIEhvcml6b250YWxcbmZsaXBWPUZsaXAgVmVydGljYWxcbmZsb3djaGFydD1GbG93Y2hhcnRcbmZvbGRlcj1Gb2xkZXJcbmZvbnQ9Rm9udFxuZm9udENvbG9yPUZvbnQgQ29sb3JcbmZvbnRGYW1pbHk9Rm9udCBGYW1pbHlcbmZvbnRTaXplPUZvbnQgU2l6ZVxuZm9yYmlkZGVuPVlvdSBhcmUgbm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgZmlsZVxuZm9ybWF0PUZvcm1hdFxuZm9ybWF0UGFuZWw9Rm9ybWF0IFBhbmVsXG5mb3JtYXR0ZWQ9Rm9ybWF0dGVkXG5mb3JtYXR0ZWRUZXh0PUZvcm1hdHRlZCBUZXh0XG5mb3JtYXRQbmc9UE5HXG5mb3JtYXRHaWY9R0lGXG5mb3JtYXRKcGc9SlBFR1xuZm9ybWF0UGRmPVBERlxuZm9ybWF0U3FsPVNRTFxuZm9ybWF0U3ZnPVNWR1xuZm9ybWF0SHRtbEVtYmVkZGVkPUhUTUxcbmZvcm1hdFN2Z0VtYmVkZGVkPVNWRyAod2l0aCBYTUwpXG5mb3JtYXRWc2R4PVZTRFhcbmZvcm1hdFZzc3g9VlNTWFxuZm9ybWF0WG1sUGxhaW49WE1MIChQbGFpbilcbmZvcm1hdFhtbD1YTUxcbmZvcnVtPURpc2N1c3Npb24vSGVscCBGb3J1bXNcbmZyZWVoYW5kPUZyZWVoYW5kXG5mcm9tVGVtcGxhdGU9RnJvbSBUZW1wbGF0ZVxuZnJvbVRlbXBsYXRlVXJsPUZyb20gVGVtcGxhdGUgVVJMXG5mcm9tVGV4dD1Gcm9tIFRleHRcbmZyb21Vcmw9RnJvbSBVUkxcbmZyb21UaGlzUGFnZT1Gcm9tIHRoaXMgcGFnZVxuZnVsbHNjcmVlbj1GdWxsc2NyZWVuXG5nYXA9R2FwXG5nY3A9R0NQXG5nZW5lcmFsPUdlbmVyYWxcbmdpdGh1Yj1HaXRIdWJcbmdpdGxhYj1HaXRMYWJcbmdsaWZmeT1HbGlmZnlcbmdsb2JhbD1HbG9iYWxcbmdvb2dsZURvY3M9R29vZ2xlIERvY3Ncbmdvb2dsZURyaXZlPUdvb2dsZSBEcml2ZVxuZ29vZ2xlR2FkZ2V0PUdvb2dsZSBHYWRnZXRcbmdvb2dsZVBsdXM9R29vZ2xlK1xuZ29vZ2xlU2hhcmluZ05vdEF2YWlsYWJsZT1TaGFyaW5nIGlzIG9ubHkgYXZhaWxhYmxlIHZpYSBHb29nbGUgRHJpdmUuIFBsZWFzZSBjbGljayBPcGVuIGJlbG93IGFuZCBzaGFyZSBmcm9tIHRoZSBtb3JlIGFjdGlvbnMgbWVudTpcbmdvb2dsZVNsaWRlcz1Hb29nbGUgU2xpZGVzXG5nb29nbGVTaXRlcz1Hb29nbGUgU2l0ZXNcbmdvb2dsZVNoZWV0cz1Hb29nbGUgU2hlZXRzXG5ncmFkaWVudD1HcmFkaWVudFxuZ3JhZGllbnRDb2xvcj1Db2xvclxuZ3JpZD1HcmlkXG5ncmlkQ29sb3I9R3JpZCBDb2xvclxuZ3JpZFNpemU9R3JpZCBTaXplXG5ncm91cD1Hcm91cFxuZ3VpZGVzPUd1aWRlc1xuaGF0ZUFwcD1JIGhhdGUgZHJhdy5pb1xuaGVhZGluZz1IZWFkaW5nXG5oZWlnaHQ9SGVpZ2h0XG5oZWxwPUhlbHBcbmhlbHBUcmFuc2xhdGU9SGVscCB1cyB0cmFuc2xhdGUgdGhpcyBhcHBsaWNhdGlvblxuaGlkZT1IaWRlXG5oaWRlSXQ9SGlkZSB7MX1cbmhpZGRlbj1IaWRkZW5cbmhvbWU9SG9tZVxuaG9yaXpvbnRhbD1Ib3Jpem9udGFsXG5ob3Jpem9udGFsRmxvdz1Ib3Jpem9udGFsIEZsb3dcbmhvcml6b250YWxUcmVlPUhvcml6b250YWwgVHJlZVxuaG93VHJhbnNsYXRlPUhvdyBnb29kIGlzIHRoZSB0cmFuc2xhdGlvbiBpbiB5b3VyIGxhbmd1YWdlP1xuaHRtbD1IVE1MXG5odG1sVGV4dD1IVE1MIFRleHRcbmlkPUlEXG5pZnJhbWU9SUZyYW1lXG5pZ25vcmU9SWdub3JlXG5pbWFnZT1JbWFnZVxuaW1hZ2VVcmw9SW1hZ2UgVVJMXG5pbWFnZXM9SW1hZ2VzXG5pbWFnZVByZXZpZXdFcnJvcj1UaGlzIGltYWdlIGNvdWxkblwndCBiZSBsb2FkZWQgZm9yIHByZXZpZXcuIFBsZWFzZSBjaGVjayB0aGUgVVJMLlxuaW1hZ2VUb29CaWc9SW1hZ2UgdG9vIGJpZ1xuaW1ndXI9SW1ndXJcbmltcG9ydD1JbXBvcnRcbmltcG9ydEZyb209SW1wb3J0IGZyb21cbmluY2x1ZGVDb3B5T2ZNeURpYWdyYW09SW5jbHVkZSBhIGNvcHkgb2YgbXkgZGlhZ3JhbVxuaW5jcmVhc2VJbmRlbnQ9SW5jcmVhc2UgSW5kZW50XG5kZWNyZWFzZUluZGVudD1EZWNyZWFzZSBJbmRlbnRcbmluc2VydD1JbnNlcnRcbmluc2VydENvbHVtbkJlZm9yZT1JbnNlcnQgQ29sdW1uIExlZnRcbmluc2VydENvbHVtbkFmdGVyPUluc2VydCBDb2x1bW4gUmlnaHRcbmluc2VydEVsbGlwc2U9SW5zZXJ0IEVsbGlwc2Vcbmluc2VydEltYWdlPUluc2VydCBJbWFnZVxuaW5zZXJ0SG9yaXpvbnRhbFJ1bGU9SW5zZXJ0IEhvcml6b250YWwgUnVsZVxuaW5zZXJ0TGluaz1JbnNlcnQgTGlua1xuaW5zZXJ0UGFnZT1JbnNlcnQgUGFnZVxuaW5zZXJ0UmVjdGFuZ2xlPUluc2VydCBSZWN0YW5nbGVcbmluc2VydFJob21idXM9SW5zZXJ0IFJob21idXNcbmluc2VydFJvd0JlZm9yZT1JbnNlcnQgUm93IEFib3ZlXG5pbnNlcnRSb3dBZnRlcj1JbnNlcnQgUm93IEFmdGVyXG5pbnNlcnRUZXh0PUluc2VydCBUZXh0XG5pbnNlcnRpbmc9SW5zZXJ0aW5nXG5pbnN0YWxsQXBwPUluc3RhbGwgQXBwXG5pbnZhbGlkRmlsZW5hbWU9RGlhZ3JhbSBuYW1lcyBtdXN0IG5vdCBjb250YWluIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyczogIC8gfCA6IDsgeyB9IDwgPiAmICsgPyA9ICJcbmludmFsaWRMaWNlbnNlU2VlVGhpc1BhZ2U9WW91ciBsaWNlbnNlIGlzIGludmFsaWQsIHBsZWFzZSBzZWUgdGhpcyA8YSB0YXJnZXQ9Il9ibGFuayIgaHJlZj0iaHR0cHM6Ly9zdXBwb3J0LmRyYXcuaW8vZGlzcGxheS9ERkNTL0xpY2Vuc2luZyt5b3VyK2RyYXcuaW8rcGx1Z2luIj5wYWdlPC9hPi5cbmludmFsaWRJbnB1dD1JbnZhbGlkIGlucHV0XG5pbnZhbGlkTmFtZT1JbnZhbGlkIG5hbWVcbmludmFsaWRPck1pc3NpbmdGaWxlPUludmFsaWQgb3IgbWlzc2luZyBmaWxlXG5pbnZhbGlkUHVibGljVXJsPUludmFsaWQgcHVibGljIFVSTFxuaXNvbWV0cmljPUlzb21ldHJpY1xuaW9zPWlPU1xuaXRhbGljPUl0YWxpY1xua2VubmVkeT1LZW5uZWR5XG5rZXlib2FyZFNob3J0Y3V0cz1LZXlib2FyZCBTaG9ydGN1dHNcbmxheWVycz1MYXllcnNcbmxhbmRzY2FwZT1MYW5kc2NhcGVcbmxhbmd1YWdlPUxhbmd1YWdlXG5sZWFuTWFwcGluZz1MZWFuIE1hcHBpbmdcbmxhc3RDaGFuZ2U9TGFzdCBjaGFuZ2UgezF9IGFnb1xubGVzc1RoYW5BTWludXRlPWxlc3MgdGhhbiBhIG1pbnV0ZVxubGljZW5zaW5nRXJyb3I9TGljZW5zaW5nIEVycm9yXG5saWNlbnNlSGFzRXhwaXJlZD1UaGUgbGljZW5zZSBmb3IgezF9IGhhcyBleHBpcmVkIG9uIHsyfS4gQ2xpY2sgaGVyZS5cbmxpY2Vuc2VXaWxsRXhwaXJlPVRoZSBsaWNlbnNlIGZvciB7MX0gd2lsbCBleHBpcmUgb24gezJ9LiBDbGljayBoZXJlLlxubGluZUp1bXBzPUxpbmUganVtcHNcbmxpbmtBY2NvdW50UmVxdWlyZWQ9SWYgdGhlIGRpYWdyYW0gaXMgbm90IHB1YmxpYyBhIEdvb2dsZSBhY2NvdW50IGlzIHJlcXVpcmVkIHRvIHZpZXcgdGhlIGxpbmsuXG5saW5rVGV4dD1MaW5rIFRleHRcbmxpc3Q9TGlzdFxubWludXRlPW1pbnV0ZVxubWludXRlcz1taW51dGVzXG5ob3Vycz1ob3Vyc1xuZGF5cz1kYXlzXG5tb250aHM9bW9udGhzXG55ZWFycz15ZWFyc1xucmVzdGFydEZvckNoYW5nZVJlcXVpcmVkPUNoYW5nZXMgd2lsbCB0YWtlIGVmZmVjdCBhZnRlciBhIHJlc3RhcnQgb2YgdGhlIGFwcGxpY2F0aW9uLlxubGFuZUNvbG9yPUxhbmVjb2xvclxubGFzdE1vZGlmaWVkPUxhc3QgbW9kaWZpZWRcbmxheW91dD1MYXlvdXRcbmxlZnQ9TGVmdFxubGVmdEFsaWduPUxlZnQgQWxpZ25cbmxlZnRUb1JpZ2h0PUxlZnQgdG8gcmlnaHRcbmxpYnJhcnlUb29sdGlwPURyYWcgYW5kIGRyb3Agc2hhcGVzIGhlcmUgb3IgY2xpY2sgKyB0byBpbnNlcnQuIERvdWJsZSBjbGljayB0byBlZGl0LlxubGlnaHRib3g9TGlnaHRib3hcbmxpbmU9TGluZVxubGluZWVuZD1MaW5lIGVuZFxubGluZWhlaWdodD1MaW5lIEhlaWdodFxubGluZXN0YXJ0PUxpbmUgc3RhcnRcbmxpbmV3aWR0aD1MaW5ld2lkdGhcbmxpbms9TGlua1xubGlua3M9TGlua3NcbmxvYWRpbmc9TG9hZGluZ1xubG9ja1VubG9jaz1Mb2NrL1VubG9ja1xubG9nZ2VkT3V0PUxvZ2dlZCBPdXRcbmxvZ0luPWxvZyBpblxubG92ZUl0PUkgbG92ZSB7MX1cbmx1Y2lkY2hhcnQ9THVjaWRjaGFydFxubWFwcz1NYXBzXG5tYXRoZW1hdGljYWxUeXBlc2V0dGluZz1NYXRoZW1hdGljYWwgVHlwZXNldHRpbmdcbm1ha2VDb3B5PU1ha2UgYSBDb3B5XG5tYW51YWw9TWFudWFsXG5tZXJtYWlkPU1lcm1haWRcbm1pY3Jvc29mdE9mZmljZT1NaWNyb3NvZnQgT2ZmaWNlXG5taWNyb3NvZnRFeGNlbD1NaWNyb3NvZnQgRXhjZWxcbm1pY3Jvc29mdFBvd2VyUG9pbnQ9TWljcm9zb2Z0IFBvd2VyUG9pbnRcbm1pY3Jvc29mdFdvcmQ9TWljcm9zb2Z0IFdvcmRcbm1pZGRsZT1NaWRkbGVcbm1pbmltYWw9TWluaW1hbFxubWlzYz1NaXNjXG5tb2NrdXBzPU1vY2t1cHNcbm1vZGlmaWNhdGlvbkRhdGU9TW9kaWZpY2F0aW9uIGRhdGVcbm1vZGlmaWVkQnk9TW9kaWZpZWQgYnlcbm1vcmU9TW9yZVxubW9yZVJlc3VsdHM9TW9yZSBSZXN1bHRzXG5tb3JlU2hhcGVzPU1vcmUgU2hhcGVzXG5tb3ZlPU1vdmVcbm1vdmVUb0ZvbGRlcj1Nb3ZlIHRvIEZvbGRlclxubW92aW5nPU1vdmluZ1xubW92ZVNlbGVjdGlvblRvPU1vdmUgc2VsZWN0aW9uIHRvIHsxfVxubmFtZT1OYW1lXG5uYXZpZ2F0aW9uPU5hdmlnYXRpb25cbm5ldHdvcms9TmV0d29ya1xubmV0d29ya2luZz1OZXR3b3JraW5nXG5uZXc9TmV3XG5uZXdMaWJyYXJ5PU5ldyBMaWJyYXJ5XG5uZXh0UGFnZT1OZXh0IFBhZ2Vcbm5vPU5vXG5ub1BpY2tGb2xkZXI9Tm8sIHBpY2sgZm9sZGVyXG5ub0F0dGFjaG1lbnRzPU5vIGF0dGFjaG1lbnRzIGZvdW5kXG5ub0NvbG9yPU5vIENvbG9yXG5ub0ZpbGVzPU5vIEZpbGVzXG5ub0ZpbGVTZWxlY3RlZD1ObyBmaWxlIHNlbGVjdGVkXG5ub0xpYnJhcmllcz1ObyBsaWJyYXJpZXMgZm91bmRcbm5vTW9yZVJlc3VsdHM9Tm8gbW9yZSByZXN1bHRzXG5ub25lPU5vbmVcbm5vT3RoZXJWaWV3ZXJzPU5vIG90aGVyIHZpZXdlcnNcbm5vUGx1Z2lucz1ObyBwbHVnaW5zXG5ub1ByZXZpZXc9Tm8gcHJldmlld1xubm9SZXNwb25zZT1ObyByZXNwb25zZSBmcm9tIHNlcnZlclxubm9SZXN1bHRzRm9yPU5vIHJlc3VsdHMgZm9yIFwnezF9XCdcbm5vUmV2aXNpb25zPU5vIHJldmlzaW9uc1xubm9TZWFyY2hSZXN1bHRzPU5vIHNlYXJjaCByZXN1bHRzIGZvdW5kXG5ub1BhZ2VDb250ZW50T3JOb3RTYXZlZD1ObyBhbmNob3JzIGZvdW5kIG9uIHRoaXMgcGFnZSBvciBpdCBoYXNuXCd0IGJlZW4gc2F2ZWQgeWV0XG5ub3JtYWw9Tm9ybWFsXG5ub3J0aD1Ob3J0aFxubm90QURpYWdyYW1GaWxlPU5vdCBhIGRpYWdyYW0gZmlsZVxubm90QUxpYnJhcnlGaWxlPU5vdCBhIGxpYnJhcnkgZmlsZVxubm90QXZhaWxhYmxlPU5vdCBhdmFpbGFibGVcbm5vdEFVdGY4RmlsZT1Ob3QgYSBVVEYtOCBmaWxlXG5ub3RDb25uZWN0ZWQ9Tm90IGNvbm5lY3RlZFxubm90ZT1Ob3RlXG5ub3RTYXRpc2ZpZWRXaXRoSW1wb3J0PU5vdCBzYXRpc2ZpZWQgd2l0aCB0aGUgaW1wb3J0P1xubm90VXNpbmdTZXJ2aWNlPU5vdCB1c2luZyB7MX0/XG5udW1iZXJlZExpc3Q9TnVtYmVyZWQgbGlzdFxub2ZmbGluZT1PZmZsaW5lXG5vaz1PS1xub25lRHJpdmU9T25lRHJpdmVcbm9ubGluZT1PbmxpbmVcbm9wYWNpdHk9T3BhY2l0eVxub3Blbj1PcGVuXG5vcGVuQXJyb3c9T3BlbiBBcnJvd1xub3BlbkV4aXN0aW5nRGlhZ3JhbT1PcGVuIEV4aXN0aW5nIERpYWdyYW1cbm9wZW5GaWxlPU9wZW4gRmlsZVxub3BlbkZyb209T3BlbiBmcm9tXG5vcGVuTGlicmFyeT1PcGVuIExpYnJhcnlcbm9wZW5MaWJyYXJ5RnJvbT1PcGVuIExpYnJhcnkgZnJvbVxub3Blbkxpbms9T3BlbiBMaW5rXG5vcGVuSW5OZXdXaW5kb3c9T3BlbiBpbiBOZXcgV2luZG93XG5vcGVuSW5UaGlzV2luZG93PU9wZW4gaW4gVGhpcyBXaW5kb3dcbm9wZW5JdD1PcGVuIHsxfVxub3BlblJlY2VudD1PcGVuIFJlY2VudFxub3BlblN1cHBvcnRlZD1TdXBwb3J0ZWQgZm9ybWF0cyBhcmUgZmlsZXMgc2F2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlICgueG1sKSwgLnZzZHggYW5kIC5nbGlmZnlcbm9wdGlvbnM9T3B0aW9uc1xub3JnYW5pYz1PcmdhbmljXG5vcmdDaGFydD1PcmcgQ2hhcnRcbm9ydGhvZ29uYWw9T3J0aG9nb25hbFxub3RoZXJWaWV3ZXI9b3RoZXIgdmlld2VyXG5vdGhlclZpZXdlcnM9b3RoZXIgdmlld2Vyc1xub3V0bGluZT1PdXRsaW5lXG5vdmFsPU92YWxcbnBhZ2U9UGFnZVxucGFnZUNvbnRlbnQ9UGFnZSBDb250ZW50XG5wYWdlTm90Rm91bmQ9UGFnZSBub3QgZm91bmRcbnBhZ2VXaXRoTnVtYmVyPVBhZ2UtezF9XG5wYWdlcz1QYWdlc1xucGFnZVZpZXc9UGFnZSBWaWV3XG5wYWdlU2V0dXA9UGFnZSBTZXR1cFxucGFnZVNjYWxlPVBhZ2UgU2NhbGVcbnBhbj1QYW5cbnBhblRvb2x0aXA9U3BhY2UrRHJhZyB0byBwYW5cbnBhcGVyU2l6ZT1QYXBlciBTaXplXG5wYXR0ZXJuPVBhdHRlcm5cbnBhc3RlPVBhc3RlXG5wYXN0ZUhlcmU9UGFzdGUgaGVyZVxucGFzdGVTaXplPVBhc3RlIFNpemVcbnBhc3RlU3R5bGU9UGFzdGUgU3R5bGVcbnBlcmltZXRlcj1QZXJpbWV0ZXJcbnBlcm1pc3Npb25BbnlvbmU9QW55b25lIGNhbiBlZGl0XG5wZXJtaXNzaW9uQXV0aG9yPU93bmVyIGFuZCBhZG1pbnMgY2FuIGVkaXRcbnBpY2tGb2xkZXI9UGljayBhIGZvbGRlclxucGlja0xpYnJhcnlEaWFsb2dUaXRsZT1TZWxlY3QgTGlicmFyeVxucHVibGljRGlhZ3JhbVVybD1QdWJsaWMgVVJMIG9mIHRoZSBkaWFncmFtXG5wbGFjZWhvbGRlcnM9UGxhY2Vob2xkZXJzXG5wbGFudFVtbD1QbGFudFVNTFxucGx1Z2lucz1QbHVnaW5zXG5wbHVnaW5Vcmw9UGx1Z2luIFVSTFxucGx1Z2luV2FybmluZz1UaGUgcGFnZSBoYXMgcmVxdWVzdGVkIHRvIGxvYWQgdGhlIGZvbGxvd2luZyBwbHVnaW4ocyk6XG4gXG4gezF9XG4gXG4gV291bGQgeW91IGxpa2UgdG8gbG9hZCB0aGVzZSBwbHVnaW4ocykgbm93P1xuIFxuIE5PVEUgOiBPbmx5IGFsbG93IHBsdWdpbnMgdG8gcnVuIGlmIHlvdSBmdWxseSB1bmRlcnN0YW5kIHRoZSBzZWN1cml0eSBpbXBsaWNhdGlvbnMgb2YgZG9pbmcgc28uXG5cbnBsdXNUb29sdGlwPUNsaWNrIHRvIGNvbm5lY3QgYW5kIGNsb25lIChjdHJsK2NsaWNrIHRvIGNsb25lLCBzaGlmdCtjbGljayB0byBjb25uZWN0KS4gRHJhZyB0byBjb25uZWN0IChjdHJsK2RyYWcgdG8gY2xvbmUpLlxucG9ydHJhaXQ9UG9ydHJhaXRcbnBvc2l0aW9uPVBvc2l0aW9uXG5wb3N0ZXJQcmludD1Qb3N0ZXIgUHJpbnRcbnByZWZlcmVuY2VzPVByZWZlcmVuY2VzXG5wcmV2aWV3PVByZXZpZXdcbnByZXZpb3VzUGFnZT1QcmV2aW91cyBQYWdlXG5wcmludD1QcmludFxucHJpbnRBbGxQYWdlcz1QcmludCBBbGwgUGFnZXNcbnByb2NFbmc9UHJvYy4gRW5nLlxucHJvamVjdD1Qcm9qZWN0XG5wcmlvcml0eT1Qcmlvcml0eVxucHJvcGVydGllcz1Qcm9wZXJ0aWVzXG5wdWJsaXNoPVB1Ymxpc2hcbnF1aWNrU3RhcnQ9UXVpY2sgU3RhcnQgVmlkZW9cbnJhY2s9UmFja1xucmFkaWFsVHJlZT1SYWRpYWwgVHJlZVxucmVhZE9ubHk9UmVhZC1vbmx5XG5yZWNvbm5lY3Rpbmc9UmVjb25uZWN0aW5nXG5yZWNlbnRseVVwZGF0ZWQ9UmVjZW50bHkgVXBkYXRlZFxucmVjZW50bHlWaWV3ZWQ9UmVjZW50bHkgVmlld2VkXG5yZWN0YW5nbGU9UmVjdGFuZ2xlXG5yZWRpcmVjdFRvTmV3QXBwPVRoaXMgZmlsZSB3YXMgY3JlYXRlZCBvciBtb2RpZmllZCBpbiBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBhcHAuIFlvdSB3aWxsIGJlIHJlZGlyZWN0ZWQgbm93LlxucmVhbHRpbWVUaW1lb3V0PUl0IGxvb2tzIGxpa2UgeW91XCd2ZSBtYWRlIGEgZmV3IGNoYW5nZXMgd2hpbGUgb2ZmbGluZS4gV2VcJ3JlIHNvcnJ5LCB0aGVzZSBjaGFuZ2VzIGNhbm5vdCBiZSBzYXZlZC5cbnJlZG89UmVkb1xucmVmcmVzaD1SZWZyZXNoXG5yZWd1bGFyRXhwcmVzc2lvbj1SZWd1bGFyIEV4cHJlc3Npb25cbnJlbGF0aXZlPVJlbGF0aXZlXG5yZWxhdGl2ZVVybE5vdEFsbG93ZWQ9UmVsYXRpdmUgVVJMIG5vdCBhbGxvd2VkXG5yZW1lbWJlck1lPVJlbWVtYmVyIG1lXG5yZW1lbWJlclRoaXNTZXR0aW5nPVJlbWVtYmVyIHRoaXMgc2V0dGluZ1xucmVtb3ZlRm9ybWF0PUNsZWFyIEZvcm1hdHRpbmdcbnJlbW92ZUZyb21Hcm91cD1SZW1vdmUgZnJvbSBHcm91cFxucmVtb3ZlSXQ9UmVtb3ZlIHsxfVxucmVtb3ZlV2F5cG9pbnQ9UmVtb3ZlIFdheXBvaW50XG5yZW5hbWU9UmVuYW1lXG5yZW5hbWVkPVJlbmFtZWRcbnJlbmFtZUl0PVJlbmFtZSB7MX1cbnJlbmFtaW5nPVJlbmFtaW5nXG5yZXBsYWNlPVJlcGxhY2VcbnJlcGxhY2VJdD17MX0gYWxyZWFkeSBleGlzdHMuIERvIHlvdSB3YW50IHRvIHJlcGxhY2UgaXQ/XG5yZXBsYWNlRXhpc3RpbmdEcmF3aW5nPVJlcGxhY2UgZXhpc3RpbmcgZHJhd2luZ1xucmVxdWlyZWQ9cmVxdWlyZWRcbnJlc2V0PVJlc2V0XG5yZXNldFZpZXc9UmVzZXQgVmlld1xucmVzaXplPVJlc2l6ZVxucmVzaXplTGFyZ2VJbWFnZXM9RG8geW91IHdhbnQgdG8gcmVzaXplIGxhcmdlIGltYWdlcyB0byBtYWtlIHRoZSBhcHBsaWNhdGlvbiBydW4gZmFzdGVyP1xucmV0aW5hPVJldGluYVxucmVzcG9uc2l2ZT1SZXNwb25zaXZlXG5yZXN0b3JlPVJlc3RvcmVcbnJlc3RvcmluZz1SZXN0b3JpbmdcbnJldHJ5aW5nSW49UmV0cnlpbmcgaW4gezF9IHNlY29uZChzKVxucmV0cnlpbmdMb2FkPUxvYWQgZmFpbGVkLiBSZXRyeWluZy4uLlxucmV0cnlpbmdMb2dpbj1Mb2dpbiB0aW1lIG91dC4gUmV0cnlpbmcuLi5cbnJldmVyc2U9UmV2ZXJzZVxucmV2aXNpb249UmV2aXNpb25cbnJldmlzaW9uSGlzdG9yeT1SZXZpc2lvbiBIaXN0b3J5XG5yaG9tYnVzPVJob21idXNcbnJpZ2h0PVJpZ2h0XG5yaWdodEFsaWduPVJpZ2h0IEFsaWduXG5yaWdodFRvTGVmdD1SaWdodCB0byBsZWZ0XG5yb3RhdGU9Um90YXRlXG5yb3RhdGVUb29sdGlwPUNsaWNrIGFuZCBkcmFnIHRvIHJvdGF0ZSwgY2xpY2sgdG8gdHVybiBzaGFwZSBvbmx5IGJ5IDkwIGRlZ3JlZXNcbnJvdGF0aW9uPVJvdGF0aW9uXG5yb3VuZGVkPVJvdW5kZWRcbnNhdmU9U2F2ZVxuc2F2ZUFuZEV4aXQ9U2F2ZSAmIEV4aXRcbnNhdmVBcz1TYXZlIGFzXG5zYXZlQXNYbWxGaWxlPVNhdmUgYXMgWE1MIGZpbGU/XG5zYXZlZD1TYXZlZFxuc2F2ZURpYWdyYW1GaXJzdD1QbGVhc2Ugc2F2ZSB0aGUgZGlhZ3JhbSBmaXJzdFxuc2F2ZURpYWdyYW1zVG89U2F2ZSBkaWFncmFtcyB0b1xuc2F2ZUxpYnJhcnk0MDM9SW5zdWZmaWNpZW50IHBlcm1pc3Npb25zIHRvIGVkaXQgdGhpcyBsaWJyYXJ5XG5zYXZlTGlicmFyeTUwMD1UaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgc2F2aW5nIHRoZSBsaWJyYXJ5XG5zYXZlTGlicmFyeVJlYWRPbmx5PUNvdWxkIG5vdCBzYXZlIGxpYnJhcnkgd2hpbGUgcmVhZC1vbmx5IG1vZGUgaXMgYWN0aXZlXG5zYXZpbmc9U2F2aW5nXG5zY3JhdGNocGFkPVNjcmF0Y2hwYWRcbnNjcm9sbGJhcnM9U2Nyb2xsYmFyc1xuc2VhcmNoPVNlYXJjaFxuc2VhcmNoU2hhcGVzPVNlYXJjaCBTaGFwZXNcbnNlbGVjdEFsbD1TZWxlY3QgQWxsXG5zZWxlY3Rpb25Pbmx5PVNlbGVjdGlvbiBPbmx5XG5zZWxlY3RDYXJkPVNlbGVjdCBDYXJkXG5zZWxlY3RFZGdlcz1TZWxlY3QgRWRnZXNcbnNlbGVjdEZpbGU9U2VsZWN0IEZpbGVcbnNlbGVjdEZvbGRlcj1TZWxlY3QgRm9sZGVyXG5zZWxlY3RGb250PVNlbGVjdCBGb250XG5zZWxlY3ROb25lPVNlbGVjdCBOb25lXG5zZWxlY3RUZW1wbGF0ZT1TZWxlY3QgVGVtcGxhdGVcbnNlbGVjdFZlcnRpY2VzPVNlbGVjdCBWZXJ0aWNlc1xuc2VuZE1lc3NhZ2U9U2VuZFxuc2VuZFlvdXJGZWVkYmFjaz1TZW5kIHlvdXIgZmVlZGJhY2tcbnNlcnZpY2VVbmF2YWlsYWJsZU9yQmxvY2tlZD1TZXJ2aWNlIHVuYXZhaWxhYmxlIG9yIGJsb2NrZWRcbnNlc3Npb25FeHBpcmVkPVlvdXIgc2Vzc2lvbiBoYXMgZXhwaXJlZC4gUGxlYXNlIHJlZnJlc2ggdGhlIGJyb3dzZXIgd2luZG93Llxuc2Vzc2lvblRpbWVvdXRPblNhdmU9WW91ciBzZXNzaW9uIGhhcyB0aW1lZCBvdXQgYW5kIHlvdSBoYXZlIGJlZW4gZGlzY29ubmVjdGVkIGZyb20gdGhlIEdvb2dsZSBEcml2ZS4gUHJlc3MgT0sgdG8gbG9naW4gYW5kIHNhdmUuIFxuc2V0QXNEZWZhdWx0U3R5bGU9U2V0IGFzIERlZmF1bHQgU3R5bGVcbnNoYWRvdz1TaGFkb3dcbnNoYXBlPVNoYXBlXG5zaGFwZXM9U2hhcGVzXG5zaGFyZT1TaGFyZVxuc2hhcmVMaW5rPUxpbmsgZm9yIHNoYXJlZCBlZGl0aW5nXG5zaGFycD1TaGFycFxuc2hvdz1TaG93XG5zaG93U3RhcnRTY3JlZW49U2hvdyBTdGFydCBTY3JlZW5cbnNpZGViYXJUb29sdGlwPUNsaWNrIHRvIGV4cGFuZC4gRHJhZyBhbmQgZHJvcCBzaGFwZXMgaW50byB0aGUgZGlhZ3JhbS4gU2hpZnQrY2xpY2sgdG8gY2hhbmdlIHNlbGVjdGlvbi4gQWx0K2NsaWNrIHRvIGluc2VydCBhbmQgY29ubmVjdC5cbnNpZ25zPVNpZ25zXG5zaWduT3V0PVNpZ24gb3V0XG5zaW1wbGU9U2ltcGxlXG5zaW1wbGVBcnJvdz1TaW1wbGUgQXJyb3dcbnNpbXBsZVZpZXdlcj1TaW1wbGUgVmlld2VyXG5zaXplPVNpemVcbnNvbGlkPVNvbGlkXG5zb3VyY2VTcGFjaW5nPVNvdXJjZSBTcGFjaW5nXG5zb3V0aD1Tb3V0aFxuc29mdHdhcmU9U29mdHdhcmVcbnNwYWNlPVNwYWNlXG5zcGFjaW5nPVNwYWNpbmdcbnNwZWNpYWxMaW5rPVNwZWNpYWwgTGlua1xuc3RhbmRhcmQ9U3RhbmRhcmRcbnN0YXJ0RHJhd2luZz1TdGFydCBkcmF3aW5nXG5zdG9wRHJhd2luZz1TdG9wIGRyYXdpbmdcbnN0YXJ0aW5nPVN0YXJ0aW5nXG5zdHJhaWdodD1TdHJhaWdodFxuc3RyaWtldGhyb3VnaD1TdHJpa2V0aHJvdWdoXG5zdHJva2VDb2xvcj1MaW5lIENvbG9yXG5zdHlsZT1TdHlsZVxuc3Vic2NyaXB0PVN1YnNjcmlwdFxuc3VtbWFyeT1TdW1tYXJ5XG5zdXBlcnNjcmlwdD1TdXBlcnNjcmlwdFxuc3VwcG9ydD1TdXBwb3J0XG5zd2ltbGFuZURpYWdyYW09U3dpbWxhbmUgRGlhZ3JhbVxuc3lzbWw9U3lzTUxcbnRhZ3M9VGFnc1xudGFibGU9VGFibGVcbnRhYmxlcz1UYWJsZXNcbnRha2VPdmVyPVRha2UgT3ZlclxudGFyZ2V0U3BhY2luZz1UYXJnZXQgU3BhY2luZ1xudGVtcGxhdGU9VGVtcGxhdGVcbnRlbXBsYXRlcz1UZW1wbGF0ZXNcbnRleHQ9VGV4dFxudGV4dEFsaWdubWVudD1UZXh0IEFsaWdubWVudFxudGV4dE9wYWNpdHk9VGV4dCBPcGFjaXR5XG50aGVtZT1UaGVtZVxudGltZW91dD1UaW1lb3V0XG50aXRsZT1UaXRsZVxudG89dG9cbnRvQmFjaz1UbyBCYWNrXG50b0Zyb250PVRvIEZyb250XG50b29sYmFyPVRvb2xiYXJcbnRvb2x0aXBzPVRvb2x0aXBzXG50b3A9VG9wXG50b3BBbGlnbj1Ub3AgQWxpZ25cbnRvcExlZnQ9VG9wIExlZnRcbnRvcFJpZ2h0PVRvcCBSaWdodFxudHJhbnNwYXJlbnQ9VHJhbnNwYXJlbnRcbnRyYW5zcGFyZW50QmFja2dyb3VuZD1UcmFuc3BhcmVudCBCYWNrZ3JvdW5kXG50cmVsbG89VHJlbGxvXG50cnlBZ2Fpbj1UcnkgYWdhaW5cbnRyeU9wZW5pbmdWaWFUaGlzUGFnZT1Ucnkgb3BlbmluZyB2aWEgdGhpcyBwYWdlXG50dXJuPVJvdGF0ZSBzaGFwZSBvbmx5IGJ5IDkwwrBcbnR5cGU9VHlwZVxudHdpdHRlcj1Ud2l0dGVyXG51bWw9VU1MXG51bmRlcmxpbmU9VW5kZXJsaW5lXG51bmRvPVVuZG9cbnVuZ3JvdXA9VW5ncm91cFxudW5zYXZlZENoYW5nZXM9VW5zYXZlZCBjaGFuZ2VzXG51bnNhdmVkQ2hhbmdlc0NsaWNrSGVyZVRvU2F2ZT1VbnNhdmVkIGNoYW5nZXMuIENsaWNrIGhlcmUgdG8gc2F2ZS5cbnVudGl0bGVkPVVudGl0bGVkXG51bnRpdGxlZERpYWdyYW09VW50aXRsZWQgRGlhZ3JhbVxudW50aXRsZWRMYXllcj1VbnRpdGxlZCBMYXllclxudW50aXRsZWRMaWJyYXJ5PVVudGl0bGVkIExpYnJhcnlcbnVua25vd25FcnJvcj1Vbmtub3duIGVycm9yXG51cGRhdGVGaWxlPVVwZGF0ZSB7MX1cbnVwZGF0aW5nRG9jdW1lbnQ9VXBkYXRpbmcgRG9jdW1lbnQuIFBsZWFzZSB3YWl0Li4uXG51cGRhdGluZ1ByZXZpZXc9VXBkYXRpbmcgUHJldmlldy4gUGxlYXNlIHdhaXQuLi5cbnVwZGF0aW5nU2VsZWN0aW9uPVVwZGF0aW5nIFNlbGVjdGlvbi4gUGxlYXNlIHdhaXQuLi5cbnVwbG9hZD1VcGxvYWRcbnVybD1VUkxcbnVzZU9mZmxpbmU9VXNlIE9mZmxpbmVcbnVzZVJvb3RGb2xkZXI9VXNlIHJvb3QgZm9sZGVyP1xudXNlck1hbnVhbD1Vc2VyIE1hbnVhbFxudmVydGljYWw9VmVydGljYWxcbnZlcnRpY2FsRmxvdz1WZXJ0aWNhbCBGbG93XG52ZXJ0aWNhbFRyZWU9VmVydGljYWwgVHJlZVxudmlldz1WaWV3XG52aWV3ZXJTZXR0aW5ncz1WaWV3ZXIgU2V0dGluZ3NcbnZpZXdVcmw9TGluayB0byB2aWV3OiB7MX1cbnZvaWNlQXNzaXN0YW50PVZvaWNlIEFzc2lzdGFudCAoYmV0YSlcbndhcm5pbmc9V2FybmluZ1xud2F5cG9pbnRzPVdheXBvaW50c1xud2VzdD1XZXN0XG53aWR0aD1XaWR0aFxud2lraT1XaWtpXG53b3JkV3JhcD1Xb3JkIFdyYXBcbndyaXRpbmdEaXJlY3Rpb249V3JpdGluZyBEaXJlY3Rpb25cbnllcz1ZZXNcbnlvdXJFbWFpbEFkZHJlc3M9WW91ciBlbWFpbCBhZGRyZXNzXG56b29tPVpvb21cbnpvb21Jbj1ab29tIEluXG56b29tT3V0PVpvb20gT3V0XG5iYXNpYz1CYXNpY1xuYnVzaW5lc3Nwcm9jZXNzPUJ1c2luZXNzIFByb2Nlc3Nlc1xuY2hhcnRzPUNoYXJ0c1xuZW5naW5lZXJpbmc9RW5naW5lZXJpbmdcbmZsb3djaGFydHM9Rmxvd2NoYXJ0c1xuZ21kbD1NYXRlcmlhbCBEZXNpZ25cbm1pbmRtYXBzPU1pbmRtYXBzXG5tb2NrdXBzPU1vY2t1cHNcbm5ldHdvcmtkaWFncmFtcz1OZXR3b3JrIERpYWdyYW1zXG5ub3RoaW5nSXNTZWxlY3RlZD1Ob3RoaW5nIGlzIHNlbGVjdGVkXG5vdGhlcj1PdGhlclxuc29mdHdhcmVkZXNpZ249U29mdHdhcmUgRGVzaWduXG52ZW5uZGlhZ3JhbXM9VmVubiBEaWFncmFtc1xud2ViRW1haWxPck90aGVyPVdlYiwgZW1haWwgb3IgYW55IG90aGVyIGludGVybmV0IGFkZHJlc3NcbndlYkxpbms9V2ViIExpbmtcbndpcmVmcmFtZXM9V2lyZWZyYW1lc1xucHJvcGVydHk9UHJvcGVydHlcbnZhbHVlPVZhbHVlXG5zaG93TW9yZT1TaG93IE1vcmVcbnNob3dMZXNzPVNob3cgTGVzc1xubXlEaWFncmFtcz1NeSBEaWFncmFtc1xuYWxsRGlhZ3JhbXM9QWxsIERpYWdyYW1zXG5yZWNlbnRseVVzZWQ9UmVjZW50bHkgdXNlZFxubGlzdFZpZXc9TGlzdCB2aWV3XG5ncmlkVmlldz1HcmlkIHZpZXdcbnJlc3VsdHNGb3I9UmVzdWx0cyBmb3IgXCd7MX1cJ1xub25lRHJpdmVDaGFyc05vdEFsbG93ZWQ9VGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJzIGFyZSBub3QgYWxsb3dlZDogfiAiICMgJSAgKiA6IDwgPiA/IC8gIHsgfCB9XG5vbmVEcml2ZUludmFsaWREZXZpY2VOYW1lPVRoZSBzcGVjaWZpZWQgZGV2aWNlIG5hbWUgaXMgaW52YWxpZFxub2ZmaWNlTm90TG9nZ2VkT0Q9WW91IGFyZSBub3QgbG9nZ2VkIGluIHRvIE9uZURyaXZlLiBQbGVhc2Ugb3BlbiBkcmF3LmlvIHRhc2sgcGFuZSBhbmQgbG9naW4gZmlyc3QuXG5vZmZpY2VTZWxlY3RTaW5nbGVEaWFnPVBsZWFzZSBzZWxlY3QgYSBzaW5nbGUgZHJhdy5pbyBkaWFncmFtIG9ubHkgd2l0aG91dCBvdGhlciBjb250ZW50cy5cbm9mZmljZVNlbGVjdERpYWc9UGxlYXNlIHNlbGVjdCBhIGRyYXcuaW8gZGlhZ3JhbS5cbm9mZmljZUNhbm5vdEZpbmREaWFncmFtPUNhbm5vdCBmaW5kIGEgZHJhdy5pbyBkaWFncmFtIGluIHRoZSBzZWxlY3Rpb25cbm5vRGlhZ3JhbXM9Tm8gZGlhZ3JhbXMgZm91bmRcbmF1dGhGYWlsZWQ9QXV0aGVudGljYXRpb24gZmFpbGVkXG5vZmZpY2VGYWlsZWRBdXRoTXNnPVVuYWJsZSB0byBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlIHVzZXIgb3IgYXV0aG9yaXplIGFwcGxpY2F0aW9uLlxuY29udmVydGluZ0RpYWdyYW1GYWlsZWQ9Q29udmVydGluZyBkaWFncmFtIGZhaWxlZFxub2ZmaWNlQ29weUltZ0Vyck1zZz1EdWUgdG8gc29tZSBsaW1pdGF0aW9ucyBpbiB0aGUgaG9zdCBhcHBsaWNhdGlvbiwgdGhlIGltYWdlIGNvdWxkIG5vdCBiZSBpbnNlcnRlZC4gUGxlYXNlIG1hbnVhbGx5IGNvcHkgdGhlIGltYWdlIHRoZW4gcGFzdGUgaXQgdG8gdGhlIGRvY3VtZW50LlxuaW5zZXJ0aW5nSW1hZ2VGYWlsZWQ9SW5zZXJ0aW5nIGltYWdlIGZhaWxlZFxub2ZmaWNlQ29weUltZ0luc3Q9SW5zdHJ1Y3Rpb25zOiBSaWdodC1jbGljayB0aGUgaW1hZ2UgYmVsb3cuIFNlbGVjdCAiQ29weSBpbWFnZSIgZnJvbSB0aGUgY29udGV4dCBtZW51LiBUaGVuLCBpbiB0aGUgZG9jdW1lbnQsIHJpZ2h0LWNsaWNrIGFuZCBzZWxlY3QgIlBhc3RlIiBmcm9tIHRoZSBjb250ZXh0IG1lbnUuXG5mb2xkZXJFbXB0eT1Gb2xkZXIgaXMgZW1wdHlcbnJlY2VudD1SZWNlbnRcbnNoYXJlZFdpdGhNZT1TaGFyZWQgV2l0aCBNZVxuc2hhcmVwb2ludFNpdGVzPVNoYXJlcG9pbnQgU2l0ZXNcbmVycm9yRmV0Y2hpbmdGb2xkZXI9RXJyb3IgZmV0Y2hpbmcgZm9sZGVyIGl0ZW1zXG5lcnJvckF1dGhPRD1FcnJvciBhdXRoZW50aWNhdGluZyB0byBPbmVEcml2ZVxub2ZmaWNlTWFpbkhlYWRlcj1BZGRzIGRyYXcuaW8gZGlhZ3JhbXMgdG8geW91ciBkb2N1bWVudC5cbm9mZmljZVN0ZXBzSGVhZGVyPVRoaXMgYWRkLWluIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5vZmZpY2VTdGVwMT1Db25uZWN0cyB0byBNaWNyb3NvZnQgT25lRHJpdmUsIEdvb2dsZSBEcml2ZSBvciB5b3VyIGRldmljZS5cbm9mZmljZVN0ZXAyPVNlbGVjdCBhIGRyYXcuaW8gZGlhZ3JhbS5cbm9mZmljZVN0ZXAzPUluc2VydCB0aGUgZGlhZ3JhbSBpbnRvIHRoZSBkb2N1bWVudC5cbm9mZmljZUF1dGhQb3B1cEluZm89UGxlYXNlIGNvbXBsZXRlIHRoZSBhdXRoZW50aWNhdGlvbiBpbiB0aGUgcG9wLXVwIHdpbmRvdy5cbm9mZmljZVNlbERpYWc9U2VsZWN0IGRyYXcuaW8gRGlhZ3JhbTpcbmZpbGVzPUZpbGVzXG5zaGFyZWQ9U2hhcmVkXG5zaGFyZXBvaW50PVNoYXJlcG9pbnRcbm9mZmljZU1hbnVhbFVwZGF0ZUluc3Q9SW5zdHJ1Y3Rpb25zOiBDb3B5IGRyYXcuaW8gZGlhZ3JhbSBmcm9tIHRoZSBkb2N1bWVudC4gVGhlbiwgaW4gdGhlIGJveCBiZWxvdywgcmlnaHQtY2xpY2sgYW5kIHNlbGVjdCAiUGFzdGUiIGZyb20gdGhlIGNvbnRleHQgbWVudS5cbm9mZmljZUNsaWNrVG9FZGl0PUNsaWNrIGljb24gdG8gc3RhcnQgZWRpdGluZzpcbnBhc3RlRGlhZ3JhbT1QYXN0ZSBkcmF3LmlvIGRpYWdyYW0gaGVyZVxuY29ubmVjdE9EPUNvbm5lY3QgdG8gT25lRHJpdmVcbnNlbGVjdENoaWxkcmVuPVNlbGVjdCBDaGlsZHJlblxuc2VsZWN0U2libGluZ3M9U2VsZWN0IFNpYmxpbmdzXG5zZWxlY3RQYXJlbnQ9U2VsZWN0IFBhcmVudFxuc2VsZWN0RGVzY2VuZGFudHM9U2VsZWN0IERlc2NlbmRhbnRzXG5sYXN0U2F2ZWQ9TGFzdCBzYXZlZCB7MX0gYWdvXG5yZXNvbHZlPVJlc29sdmVcbnJlb3Blbj1SZS1vcGVuXG5zaG93UmVzb2x2ZWQ9U2hvdyBSZXNvbHZlZFxucmVwbHk9UmVwbHlcbm9iamVjdE5vdEZvdW5kPU9iamVjdCBub3QgZm91bmRcbnJlT3BlbmVkPVJlLW9wZW5lZFxubWFya2VkQXNSZXNvbHZlZD1NYXJrZWQgYXMgcmVzb2x2ZWRcbm5vQ29tbWVudHNGb3VuZD1ObyBjb21tZW50cyBmb3VuZFxuY29tbWVudHM9Q29tbWVudHNcbnRpbWVBZ289ezF9IGFnb1xuY29uZmx1ZW5jZUNsb3VkPUNvbmZsdWVuY2UgQ2xvdWRcbmxpYnJhcmllcz1MaWJyYXJpZXNcbmNvbmZBbmNob3I9Q29uZmx1ZW5jZSBQYWdlIEFuY2hvclxuY29uZlRpbWVvdXQ9VGhlIGNvbm5lY3Rpb24gaGFzIHRpbWVkIG91dFxuY29uZlNydlRha2VUb29Mb25nPVRoZSBzZXJ2ZXIgYXQgezF9IGlzIHRha2luZyB0b28gbG9uZyB0byByZXNwb25kLlxuY29uZkNhbm5vdEluc2VydE5ldz1DYW5ub3QgaW5zZXJ0IGRyYXcuaW8gZGlhZ3JhbSB0byBhIG5ldyBDb25mbHVlbmNlIHBhZ2VcbmNvbmZTYXZlVHJ5PVBsZWFzZSBzYXZlIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uXG5jb25mQ2Fubm90R2V0SUQ9VW5hYmxlIHRvIGRldGVybWluZSBwYWdlIElEXG5jb25mQ29udGFjdEFkbWluPVBsZWFzZSBjb250YWN0IHlvdXIgQ29uZmx1ZW5jZSBhZG1pbmlzdHJhdG9yLlxucmVhZEVycj1SZWFkIEVycm9yXG5lZGl0aW5nRXJyPUVkaXRpbmcgRXJyb3JcbmNvbmZFeHRFZGl0Tm90UG9zc2libGU9VGhpcyBkaWFncmFtIGNhbm5vdCBiZSBlZGl0ZWQgZXh0ZXJuYWxseS4gUGxlYXNlIHRyeSBlZGl0aW5nIGl0IHdoaWxlIGVkaXRpbmcgdGhlIHBhZ2VcbmNvbmZFZGl0ZWRFeHQ9RGlhZ3JhbS9QYWdlIGVkaXRlZCBleHRlcm5hbGx5XG5kaWFnTm90Rm91bmQ9RGlhZ3JhbSBOb3QgRm91bmRcbmNvbmZFZGl0ZWRFeHRSZWZyZXNoPURpYWdyYW0vUGFnZSBpcyBlZGl0ZWQgZXh0ZXJuYWxseS4gUGxlYXNlIHJlZnJlc2ggdGhlIHBhZ2UuXG5jb25mQ2Fubm90RWRpdERyYWZ0RGVsT3JFeHQ9Q2Fubm90IGVkaXQgZGlhZ3JhbXMgaW4gYSBkcmFmdCBwYWdlLCBkaWFncmFtIGlzIGRlbGV0ZWQgZnJvbSB0aGUgcGFnZSwgb3IgZGlhZ3JhbSBpcyBlZGl0ZWQgZXh0ZXJuYWxseS4gUGxlYXNlIGNoZWNrIHRoZSBwYWdlLlxucmV0QmFjaz1SZXR1cm4gYmFja1xuY29uZkRpYWdOb3RQdWJsaXNoZWQ9VGhlIGRpYWdyYW0gZG9lcyBub3QgYmVsb25nIHRvIGEgcHVibGlzaGVkIHBhZ2VcbmNyZWF0ZWRCeURyYXc9Q3JlYXRlZCBieSBkcmF3LmlvXG5maWxlbmFtZVNob3J0PUZpbGVuYW1lIHRvbyBzaG9ydFxuaW52YWxpZENoYXJzPUludmFsaWQgY2hhcmFjdGVyc1xuYWxyZWFkeUV4c3Q9ezF9IGFscmVhZHkgZXhpc3RzXG5kcmFmdFJlYWRFcnI9RHJhZnQgUmVhZCBFcnJvclxuZGlhZ0NhbnRMb2FkPURpYWdyYW0gY2Fubm90IGJlIGxvYWRlZFxuZHJhZnRXcml0ZUVycj1EcmFmdCBXcml0ZSBFcnJvclxuZHJhZnRDYW50Q3JlYXRlPURyYWZ0IGNvdWxkIG5vdCBiZSBjcmVhdGVkXG5jb25mRHVwbE5hbWU9RHVwbGljYXRlIGRpYWdyYW0gbmFtZSBkZXRlY3RlZC4gUGxlYXNlIHBpY2sgYW5vdGhlciBuYW1lLlxuY29uZlNlc3Npb25FeHBpcmVkPUxvb2tzIGxpa2UgeW91ciBzZXNzaW9uIGV4cGlyZWQuIExvZyBpbiBhZ2FpbiB0byBrZWVwIHdvcmtpbmcuXG5sb2dpbj1Mb2dpblxuZHJhd1ByZXY9ZHJhdy5pbyBwcmV2aWV3XG5kcmF3RGlhZz1kcmF3LmlvIGRpYWdyYW1cbmludmFsaWRDYWxsRm5Ob3RGb3VuZD1JbnZhbGlkIENhbGw6IHsxfSBub3QgZm91bmRcbmludmFsaWRDYWxsRXJyT2NjdXJlZD1JbnZhbGlkIENhbGw6IEFuIGVycm9yIG9jY3VycmVkLCB7MX1cbmFub255bW91cz1Bbm9ueW1vdXNcbmNvbmZHb3RvUGFnZT1HbyB0byBjb250YWluaW5nIHBhZ2VcbnNob3dDb21tZW50cz1TaG93IENvbW1lbnRzXG5jb25mRXJyb3I9RXJyb3I6IHsxfVxuZ2xpZmZ5SW1wb3J0PUdsaWZmeSBJbXBvcnRcbmdsaWZmeUltcG9ydEluc3QxPUNsaWNrIHRoZSAiU3RhcnQgSW1wb3J0IiBidXR0b24gdG8gaW1wb3J0IGFsbCBHbGlmZnkgZGlhZ3JhbXMgdG8gZHJhdy5pby5cbmdsaWZmeUltcG9ydEluc3QyPVBsZWFzZSBub3RlIHRoYXQgdGhlIGltcG9ydCBwcm9jZWR1cmUgd2lsbCB0YWtlIHNvbWUgdGltZSBhbmQgdGhlIGJyb3dzZXIgd2luZG93IG11c3QgcmVtYWluIG9wZW4gdW50aWwgdGhlIGltcG9ydCBpcyBjb21wbGV0ZWQuXG5zdGFydEltcG9ydD1TdGFydCBJbXBvcnRcbmRyYXdDb25maWc9ZHJhdy5pbyBDb25maWd1cmF0aW9uXG5jdXN0b21MaWI9Q3VzdG9tIExpYnJhcmllc1xuY3VzdG9tVGVtcD1DdXN0b20gVGVtcGxhdGVzXG5wYWdlSWRzRXhwPVBhZ2UgSURzIEV4cG9ydFxuZHJhd1JlaW5kZXg9ZHJhdy5pbyByZS1pbmRleGluZyAoYmV0YSlcbndvcmtpbmc9V29ya2luZ1xuZHJhd0NvbmZpZ05vdEZvdW5kSW5zdD1kcmF3LmlvIENvbmZpZ3VyYXRpb24gU3BhY2UgKERSQVdJT0NPTkZJRykgZG9lcyBub3QgZXhpc3QuIFRoaXMgc3BhY2UgaXMgbmVlZGVkIHRvIHN0b3JlIGRyYXcuaW8gY29uZmlndXJhdGlvbiBmaWxlcyBhbmQgY3VzdG9tIGxpYnJhcmllcy90ZW1wbGF0ZXMuXG5jcmVhdGVDb25mU3A9Q3JlYXRlIENvbmZpZyBTcGFjZVxudW5leHBFcnJSZWZyZXNoPVVuZXhwZWN0ZWQgZXJyb3IsIHBsZWFzZSByZWZyZXNoIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uXG5jb25maWdKU09OSW5zdD1Xcml0ZSBkcmF3LmlvIEpTT04gY29uZmlndXJhdGlvbiBpbiB0aGUgZWRpdG9yIGJlbG93IHRoZW4gY2xpY2sgc2F2ZS4gSWYgeW91IG5lZWQgaGVscCwgcGxlYXNlIHJlZmVyIHRvXG50aGlzUGFnZT10aGlzIHBhZ2VcbmN1ckN1c3RMaWI9Q3VycmVudCBDdXN0b20gTGlicmFyaWVzXG5saWJOYW1lPUxpYnJhcnkgTmFtZVxuYWN0aW9uPUFjdGlvblxuZHJhd0NvbmZJRD1kcmF3LmlvIENvbmZpZyBJRFxuYWRkTGliSW5zdD1DbGljayB0aGUgIkFkZCBMaWJyYXJ5IiBidXR0b24gdG8gdXBsb2FkIGEgbmV3IGxpYnJhcnkuXG5hZGRMaWI9QWRkIExpYnJhcnlcbmN1c3RvbVRlbXBJbnN0MT1DdXN0b20gdGVtcGxhdGVzIGFyZSBkcmF3LmlvIGRpYWdyYW1zIHNhdmVkIGluIGNoaWxkcmVuIHBhZ2VzIG9mXG5jdXN0b21UZW1wSW5zdDI9Rm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlZmVyIHRvXG50ZW1wc1BhZ2U9VGVtcGxhdGVzIHBhZ2VcbnBhZ2VJZHNFeHBJbnN0MT1TZWxlY3QgZXhwb3J0IHRhcmdldCwgdGhlbiBjbGljayB0aGUgIlN0YXJ0IEV4cG9ydCIgYnV0dG9uIHRvIGV4cG9ydCBhbGwgcGFnZXMgSURzLlxucGFnZUlkc0V4cEluc3QyPVBsZWFzZSBub3RlIHRoYXQgdGhlIGV4cG9ydCBwcm9jZWR1cmUgd2lsbCB0YWtlIHNvbWUgdGltZSBhbmQgdGhlIGJyb3dzZXIgd2luZG93IG11c3QgcmVtYWluIG9wZW4gdW50aWwgdGhlIGV4cG9ydCBpcyBjb21wbGV0ZWQuXG5zdGFydEV4cD1TdGFydCBFeHBvcnRcbnJlZnJlc2hEcmF3SW5kZXg9UmVmcmVzaCBkcmF3LmlvIERpYWdyYW1zIEluZGV4XG5yZWluZGV4SW5zdDE9Q2xpY2sgdGhlICJTdGFydCBJbmRleGluZyIgYnV0dG9uIHRvIHJlZnJlc2ggZHJhdy5pbyBkaWFncmFtcyBpbmRleC5cbnJlaW5kZXhJbnN0Mj1QbGVhc2Ugbm90ZSB0aGF0IHRoZSBpbmRleGluZyBwcm9jZWR1cmUgd2lsbCB0YWtlIHNvbWUgdGltZSBhbmQgdGhlIGJyb3dzZXIgd2luZG93IG11c3QgcmVtYWluIG9wZW4gdW50aWwgdGhlIGluZGV4aW5nIGlzIGNvbXBsZXRlZC5cbnN0YXJ0SW5kZXhpbmc9U3RhcnQgSW5kZXhpbmdcbmNvbmZBUGFnZUZvdW5kRmV0Y2g9UGFnZSAiezF9IiBmb3VuZC4gRmV0Y2hpbmdcbmNvbmZBQWxsRGlhZ0RvbmU9QWxsIHsxfSBkaWFncmFtcyBwcm9jZXNzZWQuIFByb2Nlc3MgZmluaXNoZWQuXG5jb25mQVN0YXJ0ZWRQcm9jZXNzaW5nPVN0YXJ0ZWQgcHJvY2Vzc2luZyBwYWdlICJ7MX0iXG5jb25mQUFsbERpYWdJblBhZ2VEb25lPUFsbCB7MX0gZGlhZ3JhbXMgaW4gcGFnZSAiezJ9IiBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5LlxuY29uZkFQYXJ0aWFsRGlhZ0RvbmU9ezF9IG91dCBvZiB7Mn0gezN9IGRpYWdyYW1zIGluIHBhZ2UgIns0fSIgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseS5cbmNvbmZBVXBkYXRlUGFnZUZhaWxlZD1VcGRhdGluZyBwYWdlICJ7MX0iIGZhaWxlZC5cbmNvbmZBTm9EaWFnRm91bmRJblBhZ2U9Tm8gezF9IGRpYWdyYW1zIGZvdW5kIGluIHBhZ2UgInsyfSIuXG5jb25mQUZldGNoUGFnZUZhaWxlZD1GZXRjaGluZyB0aGUgcGFnZSBmYWlsZWQuXG5jb25mQU5vRGlhZ0ZvdW5kPU5vIHsxfSBkaWFncmFtcyBmb3VuZC4gUHJvY2VzcyBmaW5pc2hlZC5cbmNvbmZBU2VhcmNoRmFpbGVkPVNlYXJjaGluZyBmb3IgezF9IGRpYWdyYW1zIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cbmNvbmZBR2xpZmZ5RGlhZ0ZvdW5kPXsyfSBkaWFncmFtICJ7MX0iIGZvdW5kLiBJbXBvcnRpbmdcbmNvbmZBR2xpZmZ5RGlhZ0ltcG9ydGVkPXsyfSBkaWFncmFtICJ7MX0iIGltcG9ydGVkIHN1Y2Nlc3NmdWxseS5cbmNvbmZBU2F2aW5nSW1wR2xpZmZ5RmFpbGVkPVNhdmluZyBpbXBvcnRlZCB7Mn0gZGlhZ3JhbSAiezF9IiBmYWlsZWQuXG5jb25mQUltcG9ydGVkRnJvbUJ5RHJhdz1JbXBvcnRlZCBmcm9tICJ7MX0iIGJ5IGRyYXcuaW9cbmNvbmZBSW1wb3J0R2xpZmZ5RmFpbGVkPUltcG9ydGluZyB7Mn0gZGlhZ3JhbSAiezF9IiBmYWlsZWQuXG5jb25mQUZldGNoR2xpZmZ5RmFpbGVkPUZldGNoaW5nIHsyfSBkaWFncmFtICJ7MX0iIGZhaWxlZC5cbmNvbmZBQ2hlY2tCcm9rZW5EaWFnTG5rPUNoZWNraW5nIGZvciBicm9rZW4gZGlhZ3JhbXMgbGlua3MuXG5jb25mQURlbERpYWdMaW5rT2Y9RGVsZXRpbmcgZGlhZ3JhbSBsaW5rIG9mICJ7MX0iXG5jb25mQUR1cExuaz0oZHVwbGljYXRlIGxpbmspXG5jb25mQURlbERpYWdMbmtGYWlsZWQ9RGVsZXRpbmcgZGlhZ3JhbSBsaW5rIG9mICJ7MX0iIGZhaWxlZC5cbmNvbmZBVW5leHBFcnJQcm9jZXNzUGFnZT1VbmV4cGVjdGVkIGVycm9yIGR1cmluZyBwcm9jZXNzaW5nIHRoZSBwYWdlIHdpdGggaWQ6IHsxfVxuY29uZkFEaWFnRm91bmRJbmRleD1EaWFncmFtICJ7MX0iIGZvdW5kLiBJbmRleGluZ1xuY29uZkFEaWFnSW5kZXhTdWNjPURpYWdyYW0gInsxfSIgaW5kZXhlZCBzdWNjZXNzZnVsbHkuXG5jb25mQUluZGV4RGlhZ0ZhaWxlZD1JbmRleGluZyBkaWFncmFtICJ7MX0iIGZhaWxlZC5cbmNvbmZBU2tpcERpYWdPdGhlclBhZ2U9U2tpcHBlZCAiezF9IiBhcyBpdCBiZWxvbmdzIHRvIGFub3RoZXIgcGFnZSFcbmNvbmZBRGlhZ1VwdG9EYXRlPURpYWdyYW0gInsxfSIgaXMgdXAgdG8gZGF0ZS5cbmNvbmZBQ2hlY2tQYWdlc1dEcmF3PUNoZWNraW5nIHBhZ2VzIGhhdmluZyBkcmF3LmlvIGRpYWdyYW1zLlxuY29uZkFFcnJPY2N1cmVkPUFuIGVycm9yIG9jY3VycmVkIVxuc2F2ZWRTdWNjPVNhdmVkIHN1Y2Nlc3NmdWxseVxuY29uZkFTYXZlRmFpbGVkRXJyPVNhdmluZyBGYWlsZWQgKFVuZXhwZWN0ZWQgRXJyb3IpXG5jaGFyYWN0ZXI9Q2hhcmFjdGVyXG5jb25mQUNvbmZQYWdlRGVzYz1UaGlzIHBhZ2UgY29udGFpbnMgZHJhdy5pbyBjb25maWd1cmF0aW9uIGZpbGUgKGNvbmZpZ3VyYXRpb24uanNvbikgYXMgYXR0YWNobWVudFxuY29uZkFMaWJQYWdlRGVzYz1UaGlzIHBhZ2UgY29udGFpbnMgZHJhdy5pbyBjdXN0b20gbGlicmFyaWVzIGFzIGF0dGFjaG1lbnRzXG5jb25mQVRlbXBQYWdlRGVzYz1UaGlzIHBhZ2UgY29udGFpbnMgZHJhdy5pbyBjdXN0b20gdGVtcGxhdGVzIGFzIGF0dGFjaG1lbnRzXG53b3JraW5nPVdvcmtpbmdcbmNvbmZBQ29uZlNwYWNlRGVzYz1UaGlzIHNwYWNlIGlzIHVzZWQgdG8gc3RvcmUgZHJhdy5pbyBjb25maWd1cmF0aW9uIGZpbGVzIGFuZCBjdXN0b20gbGlicmFyaWVzL3RlbXBsYXRlc1xuY29uZkFOb0N1c3RMaWI9Tm8gQ3VzdG9tIExpYnJhcmllc1xuZGVsRmFpbGVkPURlbGV0ZSBmYWlsZWQhXG5zaG93SUQ9U2hvdyBJRFxuY29uZkFJbmNvcnJlY3RMaWJGaWxlVHlwZT1JbmNvcnJlY3QgZmlsZSB0eXBlLiBMaWJyYXJpZXMgc2hvdWxkIGJlIFhNTCBmaWxlcy5cbnVwbG9hZGluZz1VcGxvYWRpbmdcbmNvbmZBTGliRXhpc3Q9VGhpcyBsaWJyYXJ5IGFscmVhZHkgZXhpc3RzXG5jb25mQVVwbG9hZFN1Y2M9VXBsb2FkZWQgc3VjY2Vzc2Z1bGx5XG5jb25mQVVwbG9hZEZhaWxFcnI9VXBsb2FkIEZhaWxlZCAoVW5leHBlY3RlZCBFcnJvcilcbmhpUmVzUHJldmlldz1IaWdoIFJlcyBQcmV2aWV3XG5vZmZpY2VOb3RMb2dnZWRHRD1Zb3UgYXJlIG5vdCBsb2dnZWQgaW4gdG8gR29vZ2xlIERyaXZlLiBQbGVhc2Ugb3BlbiBkcmF3LmlvIHRhc2sgcGFuZSBhbmQgbG9naW4gZmlyc3QuXG5vZmZpY2VQb3B1cEluZm89UGxlYXNlIGNvbXBsZXRlIHRoZSBwcm9jZXNzIGluIHRoZSBwb3AtdXAgd2luZG93LlxucGlja09ERmlsZT1QaWNrIE9uZURyaXZlIEZpbGVcbnBpY2tHRHJpdmVGaWxlPVBpY2sgR29vZ2xlIERyaXZlIEZpbGVcbnBpY2tEZXZpY2VGaWxlPVBpY2sgRGV2aWNlIEZpbGVcbnZzZE5vQ29uZmlnPSJ2c2R1cmwiIGlzIG5vdCBjb25maWd1cmVkXG5ydWxlcj1SdWxlclxudW5pdHM9VW5pdHNcbnBvaW50cz1Qb2ludHNcbmluY2hlcz1JbmNoZXNcbm1pbGxpbWV0ZXJzPU1pbGxpbWV0ZXJzXG5jb25mRWRpdERyYWZ0RGVsT3JFeHQ9VGhpcyBkaWFncmFtIGlzIGluIGEgZHJhZnQgcGFnZSwgaXMgZGVsZXRlZCBmcm9tIHRoZSBwYWdlLCBvciBpcyBlZGl0ZWQgZXh0ZXJuYWxseS4gSXQgd2lsbCBiZSBzYXZlZCBhcyBhIG5ldyBhdHRhY2htZW50IHZlcnNpb24gYW5kIG1heSBub3QgYmUgcmVmbGVjdGVkIGluIHRoZSBwYWdlLlxuY29uZkRpYWdFZGl0ZWRFeHQ9RGlhZ3JhbSBpcyBlZGl0ZWQgaW4gYW5vdGhlciBzZXNzaW9uLiBJdCB3aWxsIGJlIHNhdmVkIGFzIGEgbmV3IGF0dGFjaG1lbnQgdmVyc2lvbiBidXQgdGhlIHBhZ2Ugd2lsbCBzaG93IG90aGVyIHNlc3Npb25cJ3MgbW9kaWZpY2F0aW9ucy5cbm1hY3JvTm90Rm91bmQ9TWFjcm8gTm90IEZvdW5kXG5jb25mQUludmFsaWRQYWdlSWRzRm9ybWF0PUluY29ycmVjdCBQYWdlIElEcyBmaWxlIGZvcm1hdFxuY29uZkFDb2xsZWN0aW5nQ3VyUGFnZXM9Q29sbGVjdGluZyBjdXJyZW50IHBhZ2VzXG5jb25mQUJ1aWxkaW5nUGFnZXNNYXA9QnVpbGRpbmcgcGFnZXMgbWFwcGluZ1xuY29uZkFQcm9jZXNzRHJhd0RpYWc9U3RhcnRlZCBwcm9jZXNzaW5nIGltcG9ydGVkIGRyYXcuaW8gZGlhZ3JhbXNcbmNvbmZBUHJvY2Vzc0RyYXdEaWFnRG9uZT1GaW5pc2hlZCBwcm9jZXNzaW5nIGltcG9ydGVkIGRyYXcuaW8gZGlhZ3JhbXNcbmNvbmZBUHJvY2Vzc0ltcFBhZ2VzPVN0YXJ0ZWQgcHJvY2Vzc2luZyBpbXBvcnRlZCBwYWdlc1xuY29uZkFFcnJQcmNzRGlhZ0luUGFnZT1FcnJvciBwcm9jZXNzaW5nIGRyYXcuaW8gZGlhZ3JhbXMgaW4gcGFnZSAiezF9IlxuY29uZkFQcmNzRGlhZ0luUGFnZT1Qcm9jZXNzaW5nIGRyYXcuaW8gZGlhZ3JhbXMgaW4gcGFnZSAiezF9IlxuY29uZkFJbXBEaWFncmFtPUltcG9ydGluZyBkaWFncmFtICJ7MX0iXG5jb25mQUltcERpYWdyYW1GYWlsZWQ9SW1wb3J0aW5nIGRpYWdyYW0gInsxfSIgZmFpbGVkLiBDYW5ub3QgZmluZCBpdHMgbmV3IHBhZ2UgSUQuIE1heWJlIGl0IHBvaW50cyB0byBhIHBhZ2UgdGhhdCBpcyBub3QgaW1wb3J0ZWQuIFxuY29uZkFJbXBEaWFncmFtRXJyb3I9RXJyb3IgaW1wb3J0aW5nIGRpYWdyYW0gInsxfSIuIENhbm5vdCBmZXRjaCBvciBzYXZlIHRoZSBkaWFncmFtLiBDYW5ub3QgZml4IHRoaXMgZGlhZ3JhbSBsaW5rcy5cbmNvbmZBVXBkYXRlRGdybUNDRmFpbGVkPVVwZGF0aW5nIGxpbmsgdG8gZGlhZ3JhbSAiezF9IiBmYWlsZWQuXG5jb25mSW1wRGlhZ3JhbVN1Y2Nlc3M9VXBkYXRpbmcgZGlhZ3JhbSAiezF9IiBkb25lIHN1Y2Nlc3NmdWxseS5cbmNvbmZBTm9MbmtzSW5EcmdtPU5vIGxpbmtzIHRvIHVwZGF0ZSBpbjogezF9XG5jb25mQVVwZGF0ZUxua1RvUGc9VXBkYXRlZCBsaW5rIHRvIHBhZ2U6ICJ7MX0iIGluIGRpYWdyYW06ICJ7Mn0iXG5jb25mQVVwZGF0ZUxCTG5rVG9QZz1VcGRhdGVkIGxpZ2h0Ym94IGxpbmsgdG8gcGFnZTogInsxfSIgaW4gZGlhZ3JhbTogInsyfSJcbmNvbmZBVXBkYXRlTG5rQmFzZT1VcGRhdGVkIGJhc2UgVVJMIGZyb206ICJ7MX0iIHRvOiAiezJ9IiBpbiBkaWFncmFtOiAiezN9IlxuY29uZkFQYWdlSWRzSW1wRG9uZT1QYWdlIElEcyBJbXBvcnQgZmluaXNoZWQuXG5jb25mQVByY3NNYWNyb3NJblBhZ2U9UHJvY2Vzc2luZyBkcmF3LmlvIG1hY3JvcyBpbiBwYWdlICJ7MX0iXG5jb25mQUVyckZldGNoUGFnZT1FcnJvciBmZXRjaGluZyBwYWdlICJ7MX0iXG5jb25mQUZpeGluZ01hY3JvPUZpeGluZyBtYWNybyBvZiBkaWFncmFtICJ7MX0iXG5jb25mQUVyclJlYWRpbmdFeHBGaWxlPUVycm9yIHJlYWRpbmcgZXhwb3J0IGZpbGVcbmNvbmZBUHJjc0RpYWdJblBhZ2VEb25lPVByb2Nlc3NpbmcgZHJhdy5pbyBkaWFncmFtcyBpbiBwYWdlICJ7MX0iIGZpbmlzaGVkXG5jb25mQUZpeGluZ01hY3JvU2tpcHBlZD1GaXhpbmcgbWFjcm8gb2YgZGlhZ3JhbSAiezF9IiBmYWlsZWQuIENhbm5vdCBmaW5kIGl0cyBuZXcgcGFnZSBJRC4gTWF5YmUgaXQgcG9pbnRzIHRvIGEgcGFnZSB0aGF0IGlzIG5vdCBpbXBvcnRlZC4gXG5wYWdlSWRzRXhwVHJnPUV4cG9ydCB0YXJnZXRcbmNvbmZBTHVjaWREaWFnSW1nSW1wb3J0ZWQ9ezJ9IGRpYWdyYW0gInsxfSIgaW1hZ2UgZXh0cmFjdGVkIHN1Y2Nlc3NmdWxseS5cbmNvbmZBU2F2aW5nTHVjaWREaWFnSW1nRmFpbGVkPUV4dHJhY3RpbmcgezJ9IGRpYWdyYW0gInsxfSIgaW1hZ2UgZmFpbGVkLlxuY29uZkdldEluZm9GYWlsZWQ9RmV0Y2hpbmcgZmlsZSBpbmZvIGZyb20gezF9IGZhaWxlZC5cbmNvbmZDaGVja0NhY2hlRmFpbGVkPUNhbm5vdCBnZXQgY2FjaGVkIGZpbGUgaW5mby5cbmNvbmZSZWFkRmlsZUVycj1DYW5ub3QgcmVhZCAiezF9IiBmaWxlIGZyb20gezJ9LlxuY29uZlNhdmVDYWNoZUZhaWxlZD1VbmV4cGVjdGVkIGVycm9yLiBDYW5ub3Qgc2F2ZSBjYWNoZWQgZmlsZVxub3JnQ2hhcnRUeXBlPU9yZyBDaGFydCBUeXBlXG5saW5lYXI9TGluZWFyXG5oYW5nZXIyPUhhbmdlciAyXG5oYW5nZXI0PUhhbmdlciA0XG5maXNoYm9uZTE9RmlzaGJvbmUgMVxuZmlzaGJvbmUyPUZpc2hib25lIDJcbjFDb2x1bW5MZWZ0PVNpbmdsZSBDb2x1bW4gTGVmdFxuMUNvbHVtblJpZ2h0PVNpbmdsZSBDb2x1bW4gUmlnaHRcbnNtYXJ0PVNtYXJ0XG5wYXJlbnRDaGlsZFNwYWNpbmc9UGFyZW50IENoaWxkIFNwYWNpbmdcbnNpYmxpbmdTcGFjaW5nPVNpYmxpbmcgU3BhY2luZ1xuY29uZk5vUGVybUVycj1Tb3JyeSwgeW91IGRvblwndCBoYXZlIGVub3VnaCBwZXJtaXNzaW9ucyB0byB2aWV3IHRoaXMgZW1iZWRkZWQgZGlhZ3JhbSBmcm9tIHBhZ2UgezF9XG5jb3B5QXNJbWFnZT1Db3B5IGFzIEltYWdlXG5sdWNpZEltcG9ydD1MdWNpZGNoYXJ0IEltcG9ydFxubHVjaWRJbXBvcnRJbnN0MT1DbGljayB0aGUgIlN0YXJ0IEltcG9ydCIgYnV0dG9uIHRvIGltcG9ydCBhbGwgTHVjaWRjaGFydCBkaWFncmFtcy5cbmluc3RhbGxGaXJzdD1QbGVhc2UgaW5zdGFsbCB7MX0gZmlyc3QuXG5kcmF3aW9DaHJvbWVFeHQ9ZHJhdy5pbyBDaHJvbWUgRXh0ZW5zaW9uXG5sb2dpbkZpcnN0VGhlbj1QbGVhc2UgbG9naW4gdG8gezF9IGZpcnN0LCB0aGVuIHsyfVxuZXJyRmV0Y2hEb2NMaXN0PUVycm9yOiBDb3VsZG5cJ3QgZmV0Y2ggZG9jdW1lbnRzIGxpc3QuXG4nKTtHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lc1siZGVmYXVsdC1zdHlsZTIiXT1teFV0aWxzLnBhcnNlWG1sKCc8bXhTdHlsZXNoZWV0PjxhZGQgYXM9ImRlZmF1bHRWZXJ0ZXgiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0ibGFiZWwiLz48YWRkIGFzPSJwZXJpbWV0ZXIiIHZhbHVlPSJyZWN0YW5nbGVQZXJpbWV0ZXIiLz48YWRkIGFzPSJmb250U2l6ZSIgdmFsdWU9IjEyIi8+PGFkZCBhcz0iZm9udEZhbWlseSIgdmFsdWU9IkhlbHZldGljYSIvPjxhZGQgYXM9ImFsaWduIiB2YWx1ZT0iY2VudGVyIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9Im1pZGRsZSIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNmZmZmZmYiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiMwMDAwMDAiLz48YWRkIGFzPSJmb250Q29sb3IiIHZhbHVlPSIjMDAwMDAwIi8+PC9hZGQ+PGFkZCBhcz0iZGVmYXVsdEVkZ2UiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0iY29ubmVjdG9yIi8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjZmZmZmZmIi8+PGFkZCBhcz0iZW5kQXJyb3ciIHZhbHVlPSJjbGFzc2ljIi8+PGFkZCBhcz0iZm9udFNpemUiIHZhbHVlPSIxMSIvPjxhZGQgYXM9ImZvbnRGYW1pbHkiIHZhbHVlPSJIZWx2ZXRpY2EiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImNlbnRlciIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJtaWRkbGUiLz48YWRkIGFzPSJyb3VuZGVkIiB2YWx1ZT0iMSIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzAwMDAwMCIvPjxhZGQgYXM9ImZvbnRDb2xvciIgdmFsdWU9IiMwMDAwMDAiLz48L2FkZD48YWRkIGFzPSJ0ZXh0Ij48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImxlZnQiLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0idG9wIi8+PC9hZGQ+PGFkZCBhcz0iZWRnZUxhYmVsIiBleHRlbmQ9InRleHQiPjxhZGQgYXM9ImxhYmVsQmFja2dyb3VuZENvbG9yIiB2YWx1ZT0iI2ZmZmZmZiIvPjxhZGQgYXM9ImZvbnRTaXplIiB2YWx1ZT0iMTEiLz48L2FkZD48YWRkIGFzPSJsYWJlbCI+PGFkZCBhcz0iZm9udFN0eWxlIiB2YWx1ZT0iMSIvPjxhZGQgYXM9ImFsaWduIiB2YWx1ZT0ibGVmdCIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJtaWRkbGUiLz48YWRkIGFzPSJzcGFjaW5nIiB2YWx1ZT0iMiIvPjxhZGQgYXM9InNwYWNpbmdMZWZ0IiB2YWx1ZT0iNTIiLz48YWRkIGFzPSJpbWFnZVdpZHRoIiB2YWx1ZT0iNDIiLz48YWRkIGFzPSJpbWFnZUhlaWdodCIgdmFsdWU9IjQyIi8+PGFkZCBhcz0icm91bmRlZCIgdmFsdWU9IjEiLz48L2FkZD48YWRkIGFzPSJpY29uIiBleHRlbmQ9ImxhYmVsIj48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImNlbnRlciIvPjxhZGQgYXM9ImltYWdlQWxpZ24iIHZhbHVlPSJjZW50ZXIiLz48YWRkIGFzPSJ2ZXJ0aWNhbExhYmVsUG9zaXRpb24iIHZhbHVlPSJib3R0b20iLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0idG9wIi8+PGFkZCBhcz0ic3BhY2luZ1RvcCIgdmFsdWU9IjQiLz48YWRkIGFzPSJsYWJlbEJhY2tncm91bmRDb2xvciIgdmFsdWU9IiNmZmZmZmYiLz48YWRkIGFzPSJzcGFjaW5nIiB2YWx1ZT0iMCIvPjxhZGQgYXM9InNwYWNpbmdMZWZ0IiB2YWx1ZT0iMCIvPjxhZGQgYXM9InNwYWNpbmdUb3AiIHZhbHVlPSI2Ii8+PGFkZCBhcz0iZm9udFN0eWxlIiB2YWx1ZT0iMCIvPjxhZGQgYXM9ImltYWdlV2lkdGgiIHZhbHVlPSI0OCIvPjxhZGQgYXM9ImltYWdlSGVpZ2h0IiB2YWx1ZT0iNDgiLz48L2FkZD48YWRkIGFzPSJzd2ltbGFuZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJzd2ltbGFuZSIvPjxhZGQgYXM9ImZvbnRTaXplIiB2YWx1ZT0iMTIiLz48YWRkIGFzPSJmb250U3R5bGUiIHZhbHVlPSIxIi8+PGFkZCBhcz0ic3RhcnRTaXplIiB2YWx1ZT0iMjMiLz48L2FkZD48YWRkIGFzPSJncm91cCI+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0ibm9uZSIvPjxhZGQgYXM9InBvaW50ZXJFdmVudHMiIHZhbHVlPSIwIi8+PC9hZGQ+PGFkZCBhcz0iZWxsaXBzZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJlbGxpcHNlIi8+PGFkZCBhcz0icGVyaW1ldGVyIiB2YWx1ZT0iZWxsaXBzZVBlcmltZXRlciIvPjwvYWRkPjxhZGQgYXM9InJob21idXMiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0icmhvbWJ1cyIvPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InJob21idXNQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJ0cmlhbmdsZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJ0cmlhbmdsZSIvPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InRyaWFuZ2xlUGVyaW1ldGVyIi8+PC9hZGQ+PGFkZCBhcz0ibGluZSI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJsaW5lIi8+PGFkZCBhcz0ic3Ryb2tlV2lkdGgiIHZhbHVlPSI0Ii8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjZmZmZmZmIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InNwYWNpbmdUb3AiIHZhbHVlPSI4Ii8+PC9hZGQ+PGFkZCBhcz0iaW1hZ2UiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0iaW1hZ2UiLz48YWRkIGFzPSJsYWJlbEJhY2tncm91bmRDb2xvciIgdmFsdWU9IndoaXRlIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InZlcnRpY2FsTGFiZWxQb3NpdGlvbiIgdmFsdWU9ImJvdHRvbSIvPjwvYWRkPjxhZGQgYXM9InJvdW5kSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9ImVsbGlwc2VQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJyaG9tYnVzSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InJob21idXNQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJhcnJvdyI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJhcnJvdyIvPjxhZGQgYXM9ImVkZ2VTdHlsZSIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjZmZmZmZmIi8+PC9hZGQ+PGFkZCBhcz0iZmFuY3kiPjxhZGQgYXM9InNoYWRvdyIgdmFsdWU9IjEiLz48YWRkIGFzPSJnbGFzcyIgdmFsdWU9IjEiLz48L2FkZD48YWRkIGFzPSJncmF5IiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0IzQjNCMyIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNGNUY1RjUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM2NjY2NjYiLz48L2FkZD48YWRkIGFzPSJibHVlIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iIzdFQTZFMCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNEQUU4RkMiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM2QzhFQkYiLz48L2FkZD48YWRkIGFzPSJncmVlbiIgZXh0ZW5kPSJmYW5jeSI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiM5N0QwNzciLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRDVFOEQ0Ii8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjODJCMzY2Ii8+PC9hZGQ+PGFkZCBhcz0idHVycXVvaXNlIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iIzY3QUI5RiIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNENUU4RDQiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM2QTkxNTMiLz48L2FkZD48YWRkIGFzPSJ5ZWxsb3ciIGV4dGVuZD0iZmFuY3kiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjRkZEOTY2Ii8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0ZGRjJDQyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iI0Q2QjY1NiIvPjwvYWRkPjxhZGQgYXM9Im9yYW5nZSIgZXh0ZW5kPSJmYW5jeSI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiNGRkE1MDAiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRkZDRDI4Ii8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjRDc5QjAwIi8+PC9hZGQ+PGFkZCBhcz0icmVkIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0VBNkI2NiIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNGOENFQ0MiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiNCODU0NTAiLz48L2FkZD48YWRkIGFzPSJwaW5rIiBleHRlbmQ9ImZhbmN5Ij48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0I1NzM5RCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNFNkQwREUiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM5OTYxODUiLz48L2FkZD48YWRkIGFzPSJwdXJwbGUiIGV4dGVuZD0iZmFuY3kiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjOEM2QzlDIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0UxRDVFNyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzk2NzNBNiIvPjwvYWRkPjxhZGQgYXM9InBsYWluLWdyYXkiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjQjNCM0IzIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0Y1RjVGNSIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzY2NjY2NiIvPjwvYWRkPjxhZGQgYXM9InBsYWluLWJsdWUiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjN0VBNkUwIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0RBRThGQyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzZDOEVCRiIvPjwvYWRkPjxhZGQgYXM9InBsYWluLWdyZWVuIj48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iIzk3RDA3NyIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNENUU4RDQiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiM4MkIzNjYiLz48L2FkZD48YWRkIGFzPSJwbGFpbi10dXJxdW9pc2UiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjNjdBQjlGIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0Q1RThENCIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzZBOTE1MyIvPjwvYWRkPjxhZGQgYXM9InBsYWluLXllbGxvdyI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiNGRkQ5NjYiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRkZGMkNDIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjRDZCNjU2Ii8+PC9hZGQ+PGFkZCBhcz0icGxhaW4tb3JhbmdlIj48YWRkIGFzPSJncmFkaWVudENvbG9yIiB2YWx1ZT0iI0ZGQTUwMCIvPjxhZGQgYXM9ImZpbGxDb2xvciIgdmFsdWU9IiNGRkNEMjgiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiNENzlCMDAiLz48L2FkZD48YWRkIGFzPSJwbGFpbi1yZWQiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjRUE2QjY2Ii8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0Y4Q0VDQyIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iI0I4NTQ1MCIvPjwvYWRkPjxhZGQgYXM9InBsYWluLXBpbmsiPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSIjQjU3MzlEIi8+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0iI0U2RDBERSIvPjxhZGQgYXM9InN0cm9rZUNvbG9yIiB2YWx1ZT0iIzk5NjE4NSIvPjwvYWRkPjxhZGQgYXM9InBsYWluLXB1cnBsZSI+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9IiM4QzZDOUMiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjRTFENUU3Ii8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjOTY3M0E2Ii8+PC9hZGQ+PC9teFN0eWxlc2hlZXQ+JykuZG9jdW1lbnRFbGVtZW50OwpHcmFwaC5wcm90b3R5cGUuZGVmYXVsdFRoZW1lcy5kYXJrVGhlbWU9bXhVdGlscy5wYXJzZVhtbCgnPG14U3R5bGVzaGVldD48YWRkIGFzPSJkZWZhdWx0VmVydGV4Ij48YWRkIGFzPSJzaGFwZSIgdmFsdWU9ImxhYmVsIi8+PGFkZCBhcz0icGVyaW1ldGVyIiB2YWx1ZT0icmVjdGFuZ2xlUGVyaW1ldGVyIi8+PGFkZCBhcz0iZm9udFNpemUiIHZhbHVlPSIxMiIvPjxhZGQgYXM9ImZvbnRGYW1pbHkiIHZhbHVlPSJIZWx2ZXRpY2EiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImNlbnRlciIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJtaWRkbGUiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSIjZjBmMGYwIi8+PGFkZCBhcz0iZm9udENvbG9yIiB2YWx1ZT0iI2YwZjBmMCIvPjwvYWRkPjxhZGQgYXM9ImRlZmF1bHRFZGdlIj48YWRkIGFzPSJzaGFwZSIgdmFsdWU9ImNvbm5lY3RvciIvPjxhZGQgYXM9ImxhYmVsQmFja2dyb3VuZENvbG9yIiB2YWx1ZT0iIzJhMmEyYSIvPjxhZGQgYXM9ImVuZEFycm93IiB2YWx1ZT0iY2xhc3NpYyIvPjxhZGQgYXM9ImZvbnRTaXplIiB2YWx1ZT0iMTEiLz48YWRkIGFzPSJmb250RmFtaWx5IiB2YWx1ZT0iSGVsdmV0aWNhIi8+PGFkZCBhcz0iYWxpZ24iIHZhbHVlPSJjZW50ZXIiLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0ibWlkZGxlIi8+PGFkZCBhcz0icm91bmRlZCIgdmFsdWU9IjEiLz48YWRkIGFzPSJzdHJva2VDb2xvciIgdmFsdWU9IiNmMGYwZjAiLz48YWRkIGFzPSJmb250Q29sb3IiIHZhbHVlPSIjZjBmMGYwIi8+PC9hZGQ+PGFkZCBhcz0idGV4dCI+PGFkZCBhcz0iZmlsbENvbG9yIiB2YWx1ZT0ibm9uZSIvPjxhZGQgYXM9ImdyYWRpZW50Q29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0iYWxpZ24iIHZhbHVlPSJsZWZ0Ii8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjwvYWRkPjxhZGQgYXM9ImVkZ2VMYWJlbCIgZXh0ZW5kPSJ0ZXh0Ij48YWRkIGFzPSJsYWJlbEJhY2tncm91bmRDb2xvciIgdmFsdWU9IiMyYTJhMmEiLz48YWRkIGFzPSJmb250U2l6ZSIgdmFsdWU9IjExIi8+PC9hZGQ+PGFkZCBhcz0ibGFiZWwiPjxhZGQgYXM9ImZvbnRTdHlsZSIgdmFsdWU9IjEiLz48YWRkIGFzPSJhbGlnbiIgdmFsdWU9ImxlZnQiLz48YWRkIGFzPSJ2ZXJ0aWNhbEFsaWduIiB2YWx1ZT0ibWlkZGxlIi8+PGFkZCBhcz0ic3BhY2luZyIgdmFsdWU9IjIiLz48YWRkIGFzPSJzcGFjaW5nTGVmdCIgdmFsdWU9IjUyIi8+PGFkZCBhcz0iaW1hZ2VXaWR0aCIgdmFsdWU9IjQyIi8+PGFkZCBhcz0iaW1hZ2VIZWlnaHQiIHZhbHVlPSI0MiIvPjxhZGQgYXM9InJvdW5kZWQiIHZhbHVlPSIxIi8+PC9hZGQ+PGFkZCBhcz0iaWNvbiIgZXh0ZW5kPSJsYWJlbCI+PGFkZCBhcz0iYWxpZ24iIHZhbHVlPSJjZW50ZXIiLz48YWRkIGFzPSJpbWFnZUFsaWduIiB2YWx1ZT0iY2VudGVyIi8+PGFkZCBhcz0idmVydGljYWxMYWJlbFBvc2l0aW9uIiB2YWx1ZT0iYm90dG9tIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InNwYWNpbmdUb3AiIHZhbHVlPSI0Ii8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PGFkZCBhcz0ic3BhY2luZyIgdmFsdWU9IjAiLz48YWRkIGFzPSJzcGFjaW5nTGVmdCIgdmFsdWU9IjAiLz48YWRkIGFzPSJzcGFjaW5nVG9wIiB2YWx1ZT0iNiIvPjxhZGQgYXM9ImZvbnRTdHlsZSIgdmFsdWU9IjAiLz48YWRkIGFzPSJpbWFnZVdpZHRoIiB2YWx1ZT0iNDgiLz48YWRkIGFzPSJpbWFnZUhlaWdodCIgdmFsdWU9IjQ4Ii8+PC9hZGQ+PGFkZCBhcz0ic3dpbWxhbmUiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0ic3dpbWxhbmUiLz48YWRkIGFzPSJmb250U2l6ZSIgdmFsdWU9IjEyIi8+PGFkZCBhcz0iZm9udFN0eWxlIiB2YWx1ZT0iMSIvPjxhZGQgYXM9InN0YXJ0U2l6ZSIgdmFsdWU9IjIzIi8+PC9hZGQ+PGFkZCBhcz0iZ3JvdXAiPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJ0b3AiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0ic3Ryb2tlQ29sb3IiIHZhbHVlPSJub25lIi8+PGFkZCBhcz0iZ3JhZGllbnRDb2xvciIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJwb2ludGVyRXZlbnRzIiB2YWx1ZT0iMCIvPjwvYWRkPjxhZGQgYXM9ImVsbGlwc2UiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0iZWxsaXBzZSIvPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9ImVsbGlwc2VQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJyaG9tYnVzIj48YWRkIGFzPSJzaGFwZSIgdmFsdWU9InJob21idXMiLz48YWRkIGFzPSJwZXJpbWV0ZXIiIHZhbHVlPSJyaG9tYnVzUGVyaW1ldGVyIi8+PC9hZGQ+PGFkZCBhcz0idHJpYW5nbGUiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0idHJpYW5nbGUiLz48YWRkIGFzPSJwZXJpbWV0ZXIiIHZhbHVlPSJ0cmlhbmdsZVBlcmltZXRlciIvPjwvYWRkPjxhZGQgYXM9ImxpbmUiPjxhZGQgYXM9InNoYXBlIiB2YWx1ZT0ibGluZSIvPjxhZGQgYXM9InN0cm9rZVdpZHRoIiB2YWx1ZT0iNCIvPjxhZGQgYXM9ImxhYmVsQmFja2dyb3VuZENvbG9yIiB2YWx1ZT0iIzJhMmEyYSIvPjxhZGQgYXM9InZlcnRpY2FsQWxpZ24iIHZhbHVlPSJ0b3AiLz48YWRkIGFzPSJzcGFjaW5nVG9wIiB2YWx1ZT0iOCIvPjwvYWRkPjxhZGQgYXM9ImltYWdlIj48YWRkIGFzPSJzaGFwZSIgdmFsdWU9ImltYWdlIi8+PGFkZCBhcz0ibGFiZWxCYWNrZ3JvdW5kQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PGFkZCBhcz0idmVydGljYWxBbGlnbiIgdmFsdWU9InRvcCIvPjxhZGQgYXM9InZlcnRpY2FsTGFiZWxQb3NpdGlvbiIgdmFsdWU9ImJvdHRvbSIvPjwvYWRkPjxhZGQgYXM9InJvdW5kSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9ImVsbGlwc2VQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJyaG9tYnVzSW1hZ2UiIGV4dGVuZD0iaW1hZ2UiPjxhZGQgYXM9InBlcmltZXRlciIgdmFsdWU9InJob21idXNQZXJpbWV0ZXIiLz48L2FkZD48YWRkIGFzPSJhcnJvdyI+PGFkZCBhcz0ic2hhcGUiIHZhbHVlPSJhcnJvdyIvPjxhZGQgYXM9ImVkZ2VTdHlsZSIgdmFsdWU9Im5vbmUiLz48YWRkIGFzPSJmaWxsQ29sb3IiIHZhbHVlPSIjMmEyYTJhIi8+PC9hZGQ+PC9teFN0eWxlc2hlZXQ+JykuZG9jdW1lbnRFbGVtZW50O0dyYXBoVmlld2VyPWZ1bmN0aW9uKGEsYyxmKXt0aGlzLmluaXQoYSxjLGYpfTtteFV0aWxzLmV4dGVuZChHcmFwaFZpZXdlcixteEV2ZW50U291cmNlKTtHcmFwaFZpZXdlci5wcm90b3R5cGUuZWRpdEJsYW5rVXJsPSJodHRwczovL2FwcC5kaWFncmFtcy5uZXQvIjtHcmFwaFZpZXdlci5wcm90b3R5cGUuaW1hZ2VCYXNlVXJsPSJodHRwczovL2FwcC5kaWFncmFtcy5uZXQvIjtHcmFwaFZpZXdlci5wcm90b3R5cGUudG9vbGJhckhlaWdodD0iQmFja0NvbXBhdCI9PWRvY3VtZW50LmNvbXBhdE1vZGU/Mjg6MzA7R3JhcGhWaWV3ZXIucHJvdG90eXBlLmxpZ2h0Ym94Q2hyb21lPSEwO0dyYXBoVmlld2VyLnByb3RvdHlwZS5saWdodGJveFpJbmRleD05OTk7R3JhcGhWaWV3ZXIucHJvdG90eXBlLnRvb2xiYXJaSW5kZXg9OTk5O0dyYXBoVmlld2VyLnByb3RvdHlwZS5hdXRvRml0PSEwO0dyYXBoVmlld2VyLnByb3RvdHlwZS5jZW50ZXI9ITE7CkdyYXBoVmlld2VyLnByb3RvdHlwZS5hbGxvd1pvb21Jbj0hMTtHcmFwaFZpZXdlci5wcm90b3R5cGUuc2hvd1RpdGxlQXNUb29sdGlwPSExO0dyYXBoVmlld2VyLnByb3RvdHlwZS5jaGVja1Zpc2libGVTdGF0ZT0hMDtHcmFwaFZpZXdlci5wcm90b3R5cGUubWluSGVpZ2h0PTI4O0dyYXBoVmlld2VyLnByb3RvdHlwZS5taW5XaWR0aD0xMDA7CkdyYXBoVmlld2VyLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEsYyxmKXt0aGlzLmdyYXBoQ29uZmlnPW51bGwhPWY/Zjp7fTt0aGlzLmF1dG9GaXQ9bnVsbCE9dGhpcy5ncmFwaENvbmZpZ1siYXV0by1maXQiXT90aGlzLmdyYXBoQ29uZmlnWyJhdXRvLWZpdCJdOnRoaXMuYXV0b0ZpdDt0aGlzLmFsbG93Wm9vbUluPW51bGwhPXRoaXMuZ3JhcGhDb25maWdbImFsbG93LXpvb20taW4iXT90aGlzLmdyYXBoQ29uZmlnWyJhbGxvdy16b29tLWluIl06dGhpcy5hbGxvd1pvb21Jbjt0aGlzLmNlbnRlcj1udWxsIT10aGlzLmdyYXBoQ29uZmlnLmNlbnRlcj90aGlzLmdyYXBoQ29uZmlnLmNlbnRlcjp0aGlzLmNlbnRlcjt0aGlzLmNoZWNrVmlzaWJsZVN0YXRlPW51bGwhPXRoaXMuZ3JhcGhDb25maWdbImNoZWNrLXZpc2libGUtc3RhdGUiXT90aGlzLmdyYXBoQ29uZmlnWyJjaGVjay12aXNpYmxlLXN0YXRlIl06dGhpcy5jaGVja1Zpc2libGVTdGF0ZTt0aGlzLnRvb2xiYXJJdGVtcz1udWxsIT0KdGhpcy5ncmFwaENvbmZpZy50b29sYmFyP3RoaXMuZ3JhcGhDb25maWcudG9vbGJhci5zcGxpdCgiICIpOltdO3RoaXMuem9vbUVuYWJsZWQ9MDw9bXhVdGlscy5pbmRleE9mKHRoaXMudG9vbGJhckl0ZW1zLCJ6b29tIik7dGhpcy5sYXllcnNFbmFibGVkPTA8PW14VXRpbHMuaW5kZXhPZih0aGlzLnRvb2xiYXJJdGVtcywibGF5ZXJzIik7dGhpcy5saWdodGJveEVuYWJsZWQ9MDw9bXhVdGlscy5pbmRleE9mKHRoaXMudG9vbGJhckl0ZW1zLCJsaWdodGJveCIpO3RoaXMubGlnaHRib3hDbGlja0VuYWJsZWQ9MCE9dGhpcy5ncmFwaENvbmZpZy5saWdodGJveDt0aGlzLmluaXRpYWxXaWR0aD1udWxsIT1hP2Euc3R5bGUud2lkdGg6bnVsbDt0aGlzLndpZHRoSXNFbXB0eT1udWxsIT10aGlzLmluaXRpYWxXaWR0aD8iIj09dGhpcy5pbml0aWFsV2lkdGg6ITA7dGhpcy5jdXJyZW50UGFnZT1wYXJzZUludCh0aGlzLmdyYXBoQ29uZmlnLnBhZ2UpfHwwO3RoaXMucGFnZUlkPXRoaXMuZ3JhcGhDb25maWcucGFnZUlkOwp0aGlzLmVkaXRvcj1udWxsOyJpbmxpbmUiPT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0mJih0aGlzLm1pbkhlaWdodCs9dGhpcy50b29sYmFySGVpZ2h0KTtpZihudWxsIT1jJiYodGhpcy54bWxEb2N1bWVudD1jLm93bmVyRG9jdW1lbnQsdGhpcy54bWxOb2RlPWMsdGhpcy54bWw9bXhVdGlscy5nZXRYbWwoYyksbnVsbCE9YSkpe3ZhciBkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaD1uZXcgR3JhcGgoYSk7dGhpcy5ncmFwaC5kZWZhdWx0UGFnZUJhY2tncm91bmRDb2xvcj0idHJhbnNwYXJlbnQiO3RoaXMuZ3JhcGgudHJhbnNwYXJlbnRCYWNrZ3JvdW5kPSExO3RoaXMuZ3JhcGhDb25maWcubW92ZSYmKHRoaXMuZ3JhcGguaXNNb3ZlQ2VsbHNFdmVudD1mdW5jdGlvbihhKXtyZXR1cm4hMH0pO3RoaXMubGlnaHRib3hDbGlja0VuYWJsZWQmJihhLnN0eWxlLmN1cnNvcj0icG9pbnRlciIpO3RoaXMuZWRpdG9yPW5ldyBFZGl0b3IoITAsCm51bGwsbnVsbCx0aGlzLmdyYXBoKTt0aGlzLmVkaXRvci5lZGl0QmxhbmtVcmw9dGhpcy5lZGl0QmxhbmtVcmw7dGhpcy5ncmFwaC5saWdodGJveD0hMDt0aGlzLmdyYXBoLmNlbnRlclpvb209ITE7dGhpcy5ncmFwaC5hdXRvRXh0ZW5kPSExO3RoaXMuZ3JhcGguYXV0b1Njcm9sbD0hMTt0aGlzLmdyYXBoLnNldEVuYWJsZWQoITEpOzE9PXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItbm9oaWRlIl0mJih0aGlzLmVkaXRvci5kZWZhdWx0R3JhcGhPdmVyZmxvdz0idmlzaWJsZSIpO3RoaXMueG1sTm9kZT10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbCh0aGlzLnhtbE5vZGUsITApO3RoaXMueG1sTm9kZSE9YyYmKHRoaXMueG1sPW14VXRpbHMuZ2V0WG1sKHRoaXMueG1sTm9kZSksdGhpcy54bWxEb2N1bWVudD10aGlzLnhtbE5vZGUub3duZXJEb2N1bWVudCk7dmFyIGQ9dGhpczt0aGlzLmdyYXBoLmdldEltYWdlRnJvbUJ1bmRsZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuZ2V0SW1hZ2VVcmwoYSl9OwpteENsaWVudC5JU19TVkcmJnRoaXMuZ3JhcGguYWRkU3ZnU2hhZG93KHRoaXMuZ3JhcGgudmlldy5jYW52YXMub3duZXJTVkdFbGVtZW50LG51bGwsITApO2lmKCJteGZpbGUiPT10aGlzLnhtbE5vZGUubm9kZU5hbWUpe3ZhciBiPXRoaXMueG1sTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiZGlhZ3JhbSIpO2lmKDA8Yi5sZW5ndGgpe2lmKG51bGwhPXRoaXMucGFnZUlkKWZvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKWlmKHRoaXMucGFnZUlkPT1iW2VdLmdldEF0dHJpYnV0ZSgiaWQiKSl7dGhpcy5jdXJyZW50UGFnZT1lO2JyZWFrfXZhciBmPXRoaXMuZ3JhcGguZ2V0R2xvYmFsVmFyaWFibGUsZD10aGlzO3RoaXMuZ3JhcGguZ2V0R2xvYmFsVmFyaWFibGU9ZnVuY3Rpb24oYSl7dmFyIGM9YltkLmN1cnJlbnRQYWdlXTtyZXR1cm4icGFnZSI9PWE/Yy5nZXRBdHRyaWJ1dGUoIm5hbWUiKXx8IlBhZ2UtIisoZC5jdXJyZW50UGFnZSsxKToicGFnZW51bWJlciI9PWE/ZC5jdXJyZW50UGFnZSsKMToicGFnZWNvdW50Ij09YT9iLmxlbmd0aDpmLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19fXRoaXMuZGlhZ3JhbXM9W107dmFyIGs9bnVsbDt0aGlzLnNlbGVjdFBhZ2U9ZnVuY3Rpb24oYSl7dGhpcy5oYW5kbGluZ1Jlc2l6ZXx8KHRoaXMuY3VycmVudFBhZ2U9bXhVdGlscy5tb2QoYSx0aGlzLmRpYWdyYW1zLmxlbmd0aCksdGhpcy51cGRhdGVHcmFwaFhtbChFZGl0b3IucGFyc2VEaWFncmFtTm9kZSh0aGlzLmRpYWdyYW1zW3RoaXMuY3VycmVudFBhZ2VdKSkpfTt0aGlzLnNlbGVjdFBhZ2VCeUlkPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0hMSxjPTA7Yzx0aGlzLmRpYWdyYW1zLmxlbmd0aDtjKyspaWYodGhpcy5kaWFncmFtc1tjXS5nZXRBdHRyaWJ1dGUoImlkIik9PWEpe3RoaXMuc2VsZWN0UGFnZShjKTtiPSEwO2JyZWFrfXJldHVybiBifTtlPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy54bWxOb2RlfHwibXhmaWxlIiE9dGhpcy54bWxOb2RlLm5vZGVOYW1lKXRoaXMuZGlhZ3JhbXM9CltdO3RoaXMueG1sTm9kZSE9ayYmKHRoaXMuZGlhZ3JhbXM9dGhpcy54bWxOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaWFncmFtIiksaz10aGlzLnhtbE5vZGUpfSk7dGhpcy5hZGRMaXN0ZW5lcigieG1sTm9kZUNoYW5nZWQiLGUpO2UoKTt1cmxQYXJhbXMucGFnZT1kLmN1cnJlbnRQYWdlO3RoaXMuZ3JhcGguZ2V0TW9kZWwoKS5iZWdpblVwZGF0ZSgpO3RyeXt1cmxQYXJhbXMubmF2PTAhPXRoaXMuZ3JhcGhDb25maWcubmF2PyIxIjoiMCIsdGhpcy5lZGl0b3Iuc2V0R3JhcGhYbWwodGhpcy54bWxOb2RlKSx0aGlzLmdyYXBoLmJvcmRlcj1udWxsIT10aGlzLmdyYXBoQ29uZmlnLmJvcmRlcj90aGlzLmdyYXBoQ29uZmlnLmJvcmRlcjo4LHRoaXMuZ3JhcGgudmlldy5zY2FsZT10aGlzLmdyYXBoQ29uZmlnLnpvb218fDF9ZmluYWxseXt0aGlzLmdyYXBoLmdldE1vZGVsKCkuZW5kVXBkYXRlKCl9dGhpcy5ncmFwaC5wYW5uaW5nSGFuZGxlci51c2VMZWZ0QnV0dG9uRm9yUGFubmluZz0KITA7dGhpcy5ncmFwaC5wYW5uaW5nSGFuZGxlci5pc0ZvcmNlUGFubmluZ0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGEuZ2V0RXZlbnQoKSkmJiJhdXRvIj09dGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUub3ZlcmZsb3d9O3RoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIudXNlUG9wdXBUcmlnZ2VyPSExO3RoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIucGluY2hFbmFibGVkPSExO3RoaXMuZ3JhcGgucGFubmluZ0hhbmRsZXIuaWdub3JlQ2VsbD0hMDt0aGlzLmdyYXBoLnNldFBhbm5pbmcoITEpO251bGwhPXRoaXMuZ3JhcGhDb25maWcudG9vbGJhcj90aGlzLmFkZFRvb2xiYXIoKTpudWxsIT10aGlzLmdyYXBoQ29uZmlnLnRpdGxlJiZ0aGlzLnNob3dUaXRsZUFzVG9vbHRpcCYmYS5zZXRBdHRyaWJ1dGUoInRpdGxlIix0aGlzLmdyYXBoQ29uZmlnLnRpdGxlKTt0aGlzLmFkZFNpemVIYW5kbGVyKCk7dGhpcy5zaG93TGF5ZXJzKHRoaXMuZ3JhcGgpOwp0aGlzLmFkZENsaWNrSGFuZGxlcih0aGlzLmdyYXBoKTt0aGlzLmdyYXBoLnNldFRvb2x0aXBzKDAhPXRoaXMuZ3JhcGhDb25maWcudG9vbHRpcHMpO3RoaXMuZ3JhcGguaW5pdGlhbFZpZXdTdGF0ZT17dHJhbnNsYXRlOnRoaXMuZ3JhcGgudmlldy50cmFuc2xhdGUuY2xvbmUoKSxzY2FsZTp0aGlzLmdyYXBoLnZpZXcuc2NhbGV9O2Q9dGhpczt0aGlzLmdyYXBoLmN1c3RvbUxpbmtDbGlja2VkPWZ1bmN0aW9uKGEpe2lmKCJkYXRhOnBhZ2UvaWQsIj09YS5zdWJzdHJpbmcoMCwxMykpe3ZhciBiPWEuaW5kZXhPZigiLCIpO2Quc2VsZWN0UGFnZUJ5SWQoYS5zdWJzdHJpbmcoYisxKSl8fGFsZXJ0KG14UmVzb3VyY2VzLmdldCgicGFnZU5vdEZvdW5kIil8fCJQYWdlIG5vdCBmb3VuZCIpfWVsc2UgdGhpcy5oYW5kbGVDdXN0b21MaW5rKGEpO3JldHVybiEwfTt0aGlzLmZpcmVFdmVudChuZXcgbXhFdmVudE9iamVjdCgicmVuZGVyIikpfSk7Zj13aW5kb3cuTXV0YXRpb25PYnNlcnZlcnx8CndpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyfHx3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcjtpZih0aGlzLmNoZWNrVmlzaWJsZVN0YXRlJiYwPT1hLm9mZnNldFdpZHRoJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBmKXt2YXIgaz10aGlzLmdldE9ic2VydmFibGVQYXJlbnQoYSksbT1uZXcgZihteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihjKXswPGEub2Zmc2V0V2lkdGgmJihtLmRpc2Nvbm5lY3QoKSxkKCkpfSkpO20ub2JzZXJ2ZShrLHthdHRyaWJ1dGVzOiEwfSl9ZWxzZSBkKCl9fTtHcmFwaFZpZXdlci5wcm90b3R5cGUuZ2V0T2JzZXJ2YWJsZVBhcmVudD1mdW5jdGlvbihhKXtmb3IoYT1hLnBhcmVudE5vZGU7YSE9ZG9jdW1lbnQuYm9keSYmbnVsbCE9YS5wYXJlbnROb2RlJiYibm9uZSIhPT1teFV0aWxzLmdldEN1cnJlbnRTdHlsZShhKS5kaXNwbGF5OylhPWEucGFyZW50Tm9kZTtyZXR1cm4gYX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5nZXRJbWFnZVVybD1mdW5jdGlvbihhKXtudWxsIT1hJiYiaHR0cDovLyIhPWEuc3Vic3RyaW5nKDAsNykmJiJodHRwczovLyIhPWEuc3Vic3RyaW5nKDAsOCkmJiJkYXRhOmltYWdlIiE9YS5zdWJzdHJpbmcoMCwxMCkmJigiLyI9PWEuY2hhckF0KDApJiYoYT1hLnN1YnN0cmluZygxLGEubGVuZ3RoKSksYT10aGlzLmltYWdlQmFzZVVybCthKTtyZXR1cm4gYX07R3JhcGhWaWV3ZXIucHJvdG90eXBlLnNldFhtbE5vZGU9ZnVuY3Rpb24oYSl7YT10aGlzLmVkaXRvci5leHRyYWN0R3JhcGhNb2RlbChhLCEwKTt0aGlzLnhtbERvY3VtZW50PWEub3duZXJEb2N1bWVudDt0aGlzLnhtbD1teFV0aWxzLmdldFhtbChhKTt0aGlzLnhtbE5vZGU9YTt0aGlzLnVwZGF0ZUdyYXBoWG1sKGEpO3RoaXMuZmlyZUV2ZW50KG5ldyBteEV2ZW50T2JqZWN0KCJ4bWxOb2RlQ2hhbmdlZCIpKX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5zZXRGaWxlTm9kZT1mdW5jdGlvbihhKXtudWxsPT10aGlzLnhtbE5vZGUmJih0aGlzLnhtbERvY3VtZW50PWEub3duZXJEb2N1bWVudCx0aGlzLnhtbD1teFV0aWxzLmdldFhtbChhKSx0aGlzLnhtbE5vZGU9YSk7dGhpcy5zZXRHcmFwaFhtbChhKX07R3JhcGhWaWV3ZXIucHJvdG90eXBlLnVwZGF0ZUdyYXBoWG1sPWZ1bmN0aW9uKGEpe3RoaXMuc2V0R3JhcGhYbWwoYSk7dGhpcy5maXJlRXZlbnQobmV3IG14RXZlbnRPYmplY3QoImdyYXBoQ2hhbmdlZCIpKX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5zZXRHcmFwaFhtbD1mdW5jdGlvbihhKXtudWxsIT10aGlzLmdyYXBoJiYodGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZT1uZXcgbXhQb2ludCx0aGlzLmdyYXBoLnZpZXcuc2NhbGU9MSx0aGlzLmdyYXBoLmdldE1vZGVsKCkuY2xlYXIoKSx0aGlzLmVkaXRvci5zZXRHcmFwaFhtbChhKSx0aGlzLndpZHRoSXNFbXB0eT8odGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUud2lkdGg9IiIsdGhpcy5ncmFwaC5jb250YWluZXIuc3R5bGUuaGVpZ2h0PSIiKTp0aGlzLmdyYXBoLmNvbnRhaW5lci5zdHlsZS53aWR0aD10aGlzLmluaXRpYWxXaWR0aCx0aGlzLnBvc2l0aW9uR3JhcGgoKSx0aGlzLmdyYXBoLmluaXRpYWxWaWV3U3RhdGU9e3RyYW5zbGF0ZTp0aGlzLmdyYXBoLnZpZXcudHJhbnNsYXRlLmNsb25lKCksc2NhbGU6dGhpcy5ncmFwaC52aWV3LnNjYWxlfSl9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUuYWRkU2l6ZUhhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyYXBoLmNvbnRhaW5lcixjPXRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKSxmPSExO2Euc3R5bGUub3ZlcmZsb3c9MSE9dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1ub2hpZGUiXT8iaGlkZGVuIjoidmlzaWJsZSI7dmFyIGQ9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtpZighZil7Zj0hMDt2YXIgYj10aGlzLmdyYXBoLmdldEdyYXBoQm91bmRzKCk7YS5zdHlsZS5vdmVyZmxvdz0xIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLW5vaGlkZSJdP2Iud2lkdGgrMip0aGlzLmdyYXBoLmJvcmRlcj5hLm9mZnNldFdpZHRoLTI/ImF1dG8iOiJoaWRkZW4iOiJ2aXNpYmxlIjtpZihudWxsIT10aGlzLnRvb2xiYXImJjEhPXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItbm9oaWRlIl0pe3ZhciBiPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksYz1teFV0aWxzLmdldFNjcm9sbE9yaWdpbihkb2N1bWVudC5ib2R5KSwKYz0icmVsYXRpdmUiPT09ZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbj9kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOntsZWZ0Oi1jLngsdG9wOi1jLnl9LGI9e2xlZnQ6Yi5sZWZ0LWMubGVmdCx0b3A6Yi50b3AtYy50b3AsYm90dG9tOmIuYm90dG9tLWMudG9wLHJpZ2h0OmIucmlnaHQtYy5sZWZ0fTt0aGlzLnRvb2xiYXIuc3R5bGUubGVmdD1iLmxlZnQrInB4IjsiYm90dG9tIj09dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1wb3NpdGlvbiJdP3RoaXMudG9vbGJhci5zdHlsZS50b3A9Yi5ib3R0b20tMSsicHgiOiJpbmxpbmUiIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/KHRoaXMudG9vbGJhci5zdHlsZS53aWR0aD1NYXRoLm1heCh0aGlzLm1pblRvb2xiYXJXaWR0aCxhLm9mZnNldFdpZHRoKSsicHgiLHRoaXMudG9vbGJhci5zdHlsZS50b3A9Yi50b3ArMSsicHgiKTp0aGlzLnRvb2xiYXIuc3R5bGUudG9wPWIudG9wKyJweCJ9ZWxzZSBudWxsIT0KdGhpcy50b29sYmFyJiYodGhpcy50b29sYmFyLnN0eWxlLndpZHRoPU1hdGgubWF4KHRoaXMubWluVG9vbGJhcldpZHRoLGEub2Zmc2V0V2lkdGgpKyJweCIpO2Y9ITF9fSksaz1udWxsO3RoaXMuaGFuZGxpbmdSZXNpemU9ITE7dGhpcy5maXRHcmFwaD1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihiKXt2YXIgYz1hLm9mZnNldFdpZHRoO2M9PWt8fHRoaXMuaGFuZGxpbmdSZXNpemV8fCh0aGlzLmhhbmRsaW5nUmVzaXplPSEwLCJhdXRvIj09YS5zdHlsZS5vdmVyZmxvdyYmKGEuc3R5bGUub3ZlcmZsb3c9ImhpZGRlbiIpLHRoaXMuZ3JhcGgubWF4Rml0U2NhbGU9bnVsbCE9Yj9iOnRoaXMuZ3JhcGhDb25maWcuem9vbXx8KHRoaXMuYWxsb3dab29tSW4/bnVsbDoxKSx0aGlzLmdyYXBoLmZpdChudWxsLG51bGwsbnVsbCxudWxsLG51bGwsITApLCh0aGlzLmNlbnRlcnx8MD09dGhpcy5ncmFwaENvbmZpZy5yZXNpemUmJiIiIT1hLnN0eWxlLmhlaWdodCkmJnRoaXMuZ3JhcGguY2VudGVyKCksCnRoaXMuZ3JhcGgubWF4Rml0U2NhbGU9bnVsbCwwPT10aGlzLmdyYXBoQ29uZmlnLnJlc2l6ZSYmIiIhPWEuc3R5bGUuaGVpZ2h0fHx0aGlzLnVwZGF0ZUNvbnRhaW5lckhlaWdodChhLE1hdGgubWF4KHRoaXMubWluSGVpZ2h0LHRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKS5oZWlnaHQrMip0aGlzLmdyYXBoLmJvcmRlcisxKSksdGhpcy5ncmFwaC5pbml0aWFsVmlld1N0YXRlPXt0cmFuc2xhdGU6dGhpcy5ncmFwaC52aWV3LnRyYW5zbGF0ZS5jbG9uZSgpLHNjYWxlOnRoaXMuZ3JhcGgudmlldy5zY2FsZX0saz1jLHdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5oYW5kbGluZ1Jlc2l6ZT0hMX0pLDApKX0pO0dyYXBoVmlld2VyLnVzZVJlc2l6ZVNlbnNvciYmKG14Q2xpZW50LklTX1FVSVJLU3x8OT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlPyhteEV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywicmVzaXplIixkKSx0aGlzLmdyYXBoLmFkZExpc3RlbmVyKCJzaXplIiwKZCkpOm5ldyBSZXNpemVTZW5zb3IodGhpcy5ncmFwaC5jb250YWluZXIsZCkpO2lmKHRoaXMuZ3JhcGhDb25maWcucmVzaXplfHwodGhpcy56b29tRW5hYmxlZHx8IXRoaXMuYXV0b0ZpdCkmJjAhPXRoaXMuZ3JhcGhDb25maWcucmVzaXplKXRoaXMuZ3JhcGgubWluaW11bUNvbnRhaW5lclNpemU9bmV3IG14UmVjdGFuZ2xlKDAsMCx0aGlzLm1pbldpZHRoLHRoaXMubWluSGVpZ2h0KSx0aGlzLmdyYXBoLnJlc2l6ZUNvbnRhaW5lcj0hMDtlbHNlIGlmKCF0aGlzLndpZHRoSXNFbXB0eXx8IiIhPWEuc3R5bGUuaGVpZ2h0JiZ0aGlzLmF1dG9GaXR8fHRoaXMudXBkYXRlQ29udGFpbmVyV2lkdGgoYSxjLndpZHRoKzIqdGhpcy5ncmFwaC5ib3JkZXIpLDA9PXRoaXMuZ3JhcGhDb25maWcucmVzaXplJiYiIiE9YS5zdHlsZS5oZWlnaHR8fHRoaXMudXBkYXRlQ29udGFpbmVySGVpZ2h0KGEsTWF0aC5tYXgodGhpcy5taW5IZWlnaHQsYy5oZWlnaHQrMip0aGlzLmdyYXBoLmJvcmRlcisxKSksCiF0aGlzLnpvb21FbmFibGVkJiZ0aGlzLmF1dG9GaXQpe3ZhciBtPWs9bnVsbCxkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7d2luZG93LmNsZWFyVGltZW91dChtKTt0aGlzLmhhbmRsaW5nUmVzaXplfHwobT13aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyx0aGlzLmZpdEdyYXBoKSwxMDApKX0pO0dyYXBoVmlld2VyLnVzZVJlc2l6ZVNlbnNvciYmKG14Q2xpZW50LklTX1FVSVJLU3x8OT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlP214RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJyZXNpemUiLGQpOm5ldyBSZXNpemVTZW5zb3IodGhpcy5ncmFwaC5jb250YWluZXIsZCkpfWVsc2UgbXhDbGllbnQuSVNfUVVJUktTfHw5Pj1kb2N1bWVudC5kb2N1bWVudE1vZGV8fHRoaXMuZ3JhcGguYWRkTGlzdGVuZXIoInNpemUiLGQpO3ZhciBxPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dmFyIGI9YS5zdHlsZS5taW5XaWR0aDt0aGlzLndpZHRoSXNFbXB0eSYmKGEuc3R5bGUubWluV2lkdGg9CiIxMDAlIik7dmFyIGQ9bnVsbCE9dGhpcy5ncmFwaENvbmZpZ1sibWF4LWhlaWdodCJdP3RoaXMuZ3JhcGhDb25maWdbIm1heC1oZWlnaHQiXToiIiE9YS5zdHlsZS5oZWlnaHQmJnRoaXMuYXV0b0ZpdD9hLm9mZnNldEhlaWdodDp2b2lkIDA7aWYoMDxhLm9mZnNldFdpZHRoJiYodGhpcy5hbGxvd1pvb21Jbnx8Yy53aWR0aCsyKnRoaXMuZ3JhcGguYm9yZGVyPmEub2Zmc2V0V2lkdGh8fGMuaGVpZ2h0KzIqdGhpcy5ncmFwaC5ib3JkZXI+ZCkpe3ZhciBmPW51bGw7bnVsbCE9ZCYmYy5oZWlnaHQrMip0aGlzLmdyYXBoLmJvcmRlcj5kLTImJihmPShkLTIqdGhpcy5ncmFwaC5ib3JkZXItMikvYy5oZWlnaHQpO3RoaXMuZml0R3JhcGgoZil9ZWxzZSB0aGlzLndpZHRoSXNFbXB0eXx8MCE9dGhpcy5ncmFwaENvbmZpZy5yZXNpemV8fCIiPT1hLnN0eWxlLmhlaWdodD8odGhpcy5ncmFwaC52aWV3LnNldFRyYW5zbGF0ZShNYXRoLmZsb29yKHRoaXMuZ3JhcGguYm9yZGVyLWMueC90aGlzLmdyYXBoLnZpZXcuc2NhbGUpLApNYXRoLmZsb29yKHRoaXMuZ3JhcGguYm9yZGVyLWMueS90aGlzLmdyYXBoLnZpZXcuc2NhbGUpKSxrPWEub2Zmc2V0V2lkdGgpOnRoaXMuZ3JhcGguY2VudGVyKCghdGhpcy53aWR0aElzRW1wdHl8fGMud2lkdGg8dGhpcy5taW5XaWR0aCkmJjEhPXRoaXMuZ3JhcGhDb25maWcucmVzaXplKTthLnN0eWxlLm1pbldpZHRoPWJ9KTtteENsaWVudC5JU19RVUlSS1N8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZT93aW5kb3cuc2V0VGltZW91dChxLDApOnEoKTt0aGlzLnBvc2l0aW9uR3JhcGg9ZnVuY3Rpb24oKXtjPXRoaXMuZ3JhcGguZ2V0R3JhcGhCb3VuZHMoKTtrPW51bGw7cSgpfX07R3JhcGhWaWV3ZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lcldpZHRoPWZ1bmN0aW9uKGEsYyl7YS5zdHlsZS53aWR0aD1jKyJweCJ9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVySGVpZ2h0PWZ1bmN0aW9uKGEsYyl7aWYodGhpcy56b29tRW5hYmxlZHx8IXRoaXMuYXV0b0ZpdHx8IkJhY2tDb21wYXQiPT1kb2N1bWVudC5jb21wYXRNb2RlfHxteENsaWVudC5JU19RVUlSS1N8fDg9PWRvY3VtZW50LmRvY3VtZW50TW9kZSlhLnN0eWxlLmhlaWdodD1jKyJweCJ9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUuc2hvd0xheWVycz1mdW5jdGlvbihhLGMpe3ZhciBmPXRoaXMuZ3JhcGhDb25maWcubGF5ZXJzLGY9bnVsbCE9Zj9mLnNwbGl0KCIgIik6W10sZD10aGlzLmdyYXBoQ29uZmlnLmxheWVySWRzLGs9bnVsbCE9ZCYmMDxkLmxlbmd0aDtpZigwPGYubGVuZ3RofHxrfHxudWxsIT1jKXt2YXIgbT1udWxsIT1jP2MuZ2V0TW9kZWwoKTpudWxsLHE9YS5nZXRNb2RlbCgpO3EuYmVnaW5VcGRhdGUoKTt0cnl7Zm9yKHZhciBiPXEuZ2V0Q2hpbGRDb3VudChxLnJvb3QpLGU9MDtlPGI7ZSsrKXEuc2V0VmlzaWJsZShxLmdldENoaWxkQXQocS5yb290LGUpLG51bGwhPWM/bS5pc1Zpc2libGUobS5nZXRDaGlsZEF0KG0ucm9vdCxlKSk6ITEpO2lmKG51bGw9PW0paWYoaylmb3IoZT0wO2U8ZC5sZW5ndGg7ZSsrKXEuc2V0VmlzaWJsZShxLmdldENlbGwoZFtlXSksITApO2Vsc2UgZm9yKGU9MDtlPGYubGVuZ3RoO2UrKylxLnNldFZpc2libGUocS5nZXRDaGlsZEF0KHEucm9vdCwKcGFyc2VJbnQoZltlXSkpLCEwKX1maW5hbGx5e3EuZW5kVXBkYXRlKCl9fX07CkdyYXBoVmlld2VyLnByb3RvdHlwZS5hZGRUb29sYmFyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyxkKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtlLnN0eWxlLmJvcmRlclJpZ2h0PSIxcHggc29saWQgI2QwZDBkMCI7ZS5zdHlsZS5wYWRkaW5nPSIzcHggNnB4IDNweCA2cHgiO214RXZlbnQuYWRkTGlzdGVuZXIoZSwiY2xpY2siLGEpO251bGwhPWMmJmUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYyk7ZS5zdHlsZS5kaXNwbGF5PW14Q2xpZW50LklTX1FVSVJLUz8iaW5saW5lIjoiaW5saW5lLWJsb2NrIjthPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO2Euc2V0QXR0cmlidXRlKCJib3JkZXIiLCIwIik7YS5zZXRBdHRyaWJ1dGUoInNyYyIsYik7bnVsbD09ZHx8ZD8obXhFdmVudC5hZGRMaXN0ZW5lcihlLCJtb3VzZWVudGVyIixmdW5jdGlvbigpe2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjZGRkIn0pLG14RXZlbnQuYWRkTGlzdGVuZXIoZSwibW91c2VsZWF2ZSIsCmZ1bmN0aW9uKCl7ZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNlZWUifSksbXhVdGlscy5zZXRPcGFjaXR5KGEsNjApLGUuc3R5bGUuY3Vyc29yPSJwb2ludGVyIik6bXhVdGlscy5zZXRPcGFjaXR5KGUsMzApO2UuYXBwZW5kQ2hpbGQoYSk7Zi5hcHBlbmRDaGlsZChlKTtuKys7cmV0dXJuIGV9dmFyIGM9dGhpcy5ncmFwaC5jb250YWluZXI7ImJvdHRvbSI9PXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItcG9zaXRpb24iXT9jLnN0eWxlLm1hcmdpbkJvdHRvbT10aGlzLnRvb2xiYXJIZWlnaHQrInB4IjoiaW5saW5lIiE9dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1wb3NpdGlvbiJdJiYoYy5zdHlsZS5tYXJnaW5Ub3A9dGhpcy50b29sYmFySGVpZ2h0KyJweCIpO3ZhciBmPWMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtmLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7Zi5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtmLnN0eWxlLmJveFNpemluZz0iYm9yZGVyLWJveCI7CmYuc3R5bGUud2hpdGVTcGFjZT0ibm93cmFwIjtmLnN0eWxlLnRleHRBbGlnbj0ibGVmdCI7Zi5zdHlsZS56SW5kZXg9dGhpcy50b29sYmFyWkluZGV4O2Yuc3R5bGUuYmFja2dyb3VuZENvbG9yPSIjZWVlIjtmLnN0eWxlLmhlaWdodD10aGlzLnRvb2xiYXJIZWlnaHQrInB4Ijt0aGlzLnRvb2xiYXI9ZjtpZigiaW5saW5lIj09dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1wb3NpdGlvbiJdKXtteFV0aWxzLnNldFByZWZpeGVkU3R5bGUoZi5zdHlsZSwidHJhbnNpdGlvbiIsIm9wYWNpdHkgMTAwbXMgZWFzZS1pbi1vdXQiKTtteFV0aWxzLnNldE9wYWNpdHkoZiwzMCk7dmFyIGQ9bnVsbCxrPW51bGwsbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXtudWxsIT1kJiYod2luZG93LmNsZWFyVGltZW91dChkKSxmYWRlVGhlYWQ9bnVsbCk7bnVsbCE9ayYmKHdpbmRvdy5jbGVhclRpbWVvdXQoayksZmFkZVRoZWFkMj1udWxsKTtkPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLApmdW5jdGlvbigpe214VXRpbHMuc2V0T3BhY2l0eShmLDApO2Q9bnVsbDtrPXdpbmRvdy5zZXRUaW1lb3V0KG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7Zi5zdHlsZS5kaXNwbGF5PSJub25lIjtrPW51bGx9KSwxMDApfSksYXx8MjAwKX0pLHE9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7bnVsbCE9ZCYmKHdpbmRvdy5jbGVhclRpbWVvdXQoZCksZmFkZVRoZWFkPW51bGwpO251bGwhPWsmJih3aW5kb3cuY2xlYXJUaW1lb3V0KGspLGZhZGVUaGVhZDI9bnVsbCk7Zi5zdHlsZS5kaXNwbGF5PSIiO214VXRpbHMuc2V0T3BhY2l0eShmLGF8fDMwKX0pO214RXZlbnQuYWRkTGlzdGVuZXIodGhpcy5ncmFwaC5jb250YWluZXIsbXhDbGllbnQuSVNfUE9JTlRFUj8icG9pbnRlcm1vdmUiOiJtb3VzZW1vdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHwocSgzMCksbSgpKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsbXhDbGllbnQuSVNfUE9JTlRFUj8KInBvaW50ZXJtb3ZlIjoibW91c2Vtb3ZlIixmdW5jdGlvbihhKXtteEV2ZW50LmNvbnN1bWUoYSl9KTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlZW50ZXIiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe3EoMTAwKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlbW92ZSIsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7cSgxMDApO214RXZlbnQuY29uc3VtZShhKX0pKTtteEV2ZW50LmFkZExpc3RlbmVyKGYsIm1vdXNlbGVhdmUiLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe214RXZlbnQuaXNUb3VjaEV2ZW50KGEpfHxxKDMwKX0pKTt2YXIgYj10aGlzLmdyYXBoLGU9Yi5nZXRUb2xlcmFuY2UoKTtiLmFkZE1vdXNlTGlzdGVuZXIoe3N0YXJ0WDowLHN0YXJ0WTowLHNjcm9sbExlZnQ6MCxzY3JvbGxUb3A6MCxtb3VzZURvd246ZnVuY3Rpb24oYSxjKXt0aGlzLnN0YXJ0WD1jLmdldEdyYXBoWCgpO3RoaXMuc3RhcnRZPWMuZ2V0R3JhcGhZKCk7CnRoaXMuc2Nyb2xsTGVmdD1iLmNvbnRhaW5lci5zY3JvbGxMZWZ0O3RoaXMuc2Nyb2xsVG9wPWIuY29udGFpbmVyLnNjcm9sbFRvcH0sbW91c2VNb3ZlOmZ1bmN0aW9uKGEsYil7fSxtb3VzZVVwOmZ1bmN0aW9uKGEsYyl7bXhFdmVudC5pc1RvdWNoRXZlbnQoYy5nZXRFdmVudCgpKSYmTWF0aC5hYnModGhpcy5zY3JvbGxMZWZ0LWIuY29udGFpbmVyLnNjcm9sbExlZnQpPGUmJk1hdGguYWJzKHRoaXMuc2Nyb2xsVG9wLWIuY29udGFpbmVyLnNjcm9sbFRvcCk8ZSYmTWF0aC5hYnModGhpcy5zdGFydFgtYy5nZXRHcmFwaFgoKSk8ZSYmTWF0aC5hYnModGhpcy5zdGFydFktYy5nZXRHcmFwaFkoKSk8ZSYmKDA8cGFyc2VGbG9hdChmLnN0eWxlLm9wYWNpdHl8fDApP20oKTpxKDMwKSl9fSl9Zm9yKHZhciBnPXRoaXMudG9vbGJhckl0ZW1zLG49MCxsPW51bGwscD1udWxsLHY9MDt2PGcubGVuZ3RoO3YrKyl7dmFyIHQ9Z1t2XTtpZigicGFnZXMiPT10KXtwPWMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTsKcC5zdHlsZS5jc3NUZXh0PSJkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjNweCA0cHggMCA0cHg7dmVydGljYWwtYWxpZ246dG9wO2ZvbnQtZmFtaWx5OkhlbHZldGljYSxBcmlhbDtmb250LXNpemU6MTJweDt0b3A6NHB4O2N1cnNvcjpkZWZhdWx0OyI7bXhVdGlscy5zZXRPcGFjaXR5KHAsNzApO3ZhciB5PWEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNlbGVjdFBhZ2UodGhpcy5jdXJyZW50UGFnZS0xKX0pLEVkaXRvci5wcmV2aW91c0ltYWdlLG14UmVzb3VyY2VzLmdldCgicHJldmlvdXNQYWdlIil8fCJQcmV2aW91cyBQYWdlIik7eS5zdHlsZS5ib3JkZXJSaWdodFN0eWxlPSJub25lIjt5LnN0eWxlLnBhZGRpbmdMZWZ0PSIwcHgiO3kuc3R5bGUucGFkZGluZ1JpZ2h0PSIwcHgiO2YuYXBwZW5kQ2hpbGQocCk7dmFyIHg9YShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuc2VsZWN0UGFnZSh0aGlzLmN1cnJlbnRQYWdlKwoxKX0pLEVkaXRvci5uZXh0SW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJuZXh0UGFnZSIpfHwiTmV4dCBQYWdlIik7eC5zdHlsZS5wYWRkaW5nTGVmdD0iMHB4Ijt4LnN0eWxlLnBhZGRpbmdSaWdodD0iMHB4Ijt0PW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cC5pbm5lckhUTUw9IiI7bXhVdGlscy53cml0ZShwLHRoaXMuY3VycmVudFBhZ2UrMSsiIC8gIit0aGlzLmRpYWdyYW1zLmxlbmd0aCk7cC5zdHlsZS5kaXNwbGF5PTE8dGhpcy5kaWFncmFtcy5sZW5ndGg/ImlubGluZS1ibG9jayI6Im5vbmUiO3kuc3R5bGUuZGlzcGxheT1wLnN0eWxlLmRpc3BsYXk7eC5zdHlsZS5kaXNwbGF5PXAuc3R5bGUuZGlzcGxheX0pO3RoaXMuYWRkTGlzdGVuZXIoImdyYXBoQ2hhbmdlZCIsdCk7dCgpfWVsc2UgaWYoInpvb20iPT10KXRoaXMuem9vbUVuYWJsZWQmJihhKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaC56b29tT3V0KCl9KSxFZGl0b3Iuem9vbU91dEltYWdlLApteFJlc291cmNlcy5nZXQoInpvb21PdXQiKXx8Ilpvb20gT3V0IiksYShteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe3RoaXMuZ3JhcGguem9vbUluKCl9KSxFZGl0b3Iuem9vbUluSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJ6b29tSW4iKXx8Ilpvb20gSW4iKSxhKG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7dGhpcy5ncmFwaC52aWV3LnNjYWxlQW5kVHJhbnNsYXRlKHRoaXMuZ3JhcGguaW5pdGlhbFZpZXdTdGF0ZS5zY2FsZSx0aGlzLmdyYXBoLmluaXRpYWxWaWV3U3RhdGUudHJhbnNsYXRlLngsdGhpcy5ncmFwaC5pbml0aWFsVmlld1N0YXRlLnRyYW5zbGF0ZS55KX0pLEVkaXRvci56b29tRml0SW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJmaXQiKXx8IkZpdCIpKTtlbHNlIGlmKCJsYXllcnMiPT10KXtpZih0aGlzLmxheWVyc0VuYWJsZWQpe3ZhciBDPXRoaXMuZ3JhcGguZ2V0TW9kZWwoKSxCPWEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oYSl7aWYobnVsbCE9bClsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobCksCmw9bnVsbDtlbHNle2w9dGhpcy5ncmFwaC5jcmVhdGVMYXllcnNEaWFsb2coKTtteEV2ZW50LmFkZExpc3RlbmVyKGwsIm1vdXNlbGVhdmUiLGZ1bmN0aW9uKCl7bC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGwpO2w9bnVsbH0pO2E9Qi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtsLnN0eWxlLndpZHRoPSIxNDBweCI7bC5zdHlsZS5wYWRkaW5nPSIycHggMHB4IDJweCAwcHgiO2wuc3R5bGUuYm9yZGVyPSIxcHggc29saWQgI2QwZDBkMCI7bC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiNlZWUiO2wuc3R5bGUuZm9udEZhbWlseT0iSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLEFyaWFsIFVuaWNvZGUgTVMsQXJpYWwiO2wuc3R5bGUuZm9udFNpemU9IjExcHgiO2wuc3R5bGUuekluZGV4PXRoaXMudG9vbGJhclpJbmRleCsxO214VXRpbHMuc2V0T3BhY2l0eShsLDgwKTt2YXIgYj1teFV0aWxzLmdldERvY3VtZW50U2Nyb2xsT3JpZ2luKGRvY3VtZW50KTtsLnN0eWxlLmxlZnQ9Yi54K2EubGVmdCsKInB4IjtsLnN0eWxlLnRvcD1iLnkrYS5ib3R0b20rInB4Ijtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpfX0pLEVkaXRvci5sYXllcnNJbWFnZSxteFJlc291cmNlcy5nZXQoImxheWVycyIpfHwiTGF5ZXJzIik7Qy5hZGRMaXN0ZW5lcihteEV2ZW50LkNIQU5HRSxmdW5jdGlvbigpe0Iuc3R5bGUuZGlzcGxheT0xPEMuZ2V0Q2hpbGRDb3VudChDLnJvb3QpPyJpbmxpbmUtYmxvY2siOiJub25lIn0pO0Iuc3R5bGUuZGlzcGxheT0xPEMuZ2V0Q2hpbGRDb3VudChDLnJvb3QpPyJpbmxpbmUtYmxvY2siOiJub25lIn19ZWxzZSJsaWdodGJveCI9PXQ/dGhpcy5saWdodGJveEVuYWJsZWQmJmEobXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXt0aGlzLnNob3dMaWdodGJveCgpfSksRWRpdG9yLm1heGltaXplSW1hZ2UsbXhSZXNvdXJjZXMuZ2V0KCJzaG93Iil8fCJTaG93Iik6bnVsbCE9dGhpcy5ncmFwaENvbmZpZ1sidG9vbGJhci1idXR0b25zIl0mJih0PXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItYnV0dG9ucyJdW3RdLApudWxsIT10JiZhKG51bGw9PXQuZW5hYmxlZHx8dC5lbmFibGVkP3QuaGFuZGxlcjpmdW5jdGlvbigpe30sdC5pbWFnZSx0LnRpdGxlLHQuZW5hYmxlZCkpfW51bGwhPXRoaXMuZ3JhcGgubWluaW11bUNvbnRhaW5lclNpemUmJih0aGlzLmdyYXBoLm1pbmltdW1Db250YWluZXJTaXplLndpZHRoPTM0Km4pO251bGwhPXRoaXMuZ3JhcGhDb25maWcudGl0bGUmJihnPWMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKSxnLnN0eWxlLmNzc1RleHQ9ImRpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6M3B4IDZweCAwIDZweDt2ZXJ0aWNhbC1hbGlnbjp0b3A7Zm9udC1mYW1pbHk6SGVsdmV0aWNhLEFyaWFsO2ZvbnQtc2l6ZToxMnB4O3RvcDo0cHg7Y3Vyc29yOmRlZmF1bHQ7IixnLnNldEF0dHJpYnV0ZSgidGl0bGUiLHRoaXMuZ3JhcGhDb25maWcudGl0bGUpLG14VXRpbHMud3JpdGUoZyx0aGlzLmdyYXBoQ29uZmlnLnRpdGxlKSxteFV0aWxzLnNldE9wYWNpdHkoZywKNzApLGYuYXBwZW5kQ2hpbGQoZyksdGhpcy5maWxlbmFtZT1nKTt0aGlzLm1pblRvb2xiYXJXaWR0aD0zNCpuO3ZhciBEPWMuc3R5bGUuYm9yZGVyLGc9bXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oKXtmLnN0eWxlLndpZHRoPSJpbmxpbmUiPT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/ImF1dG8iOk1hdGgubWF4KHRoaXMubWluVG9vbGJhcldpZHRoLGMub2Zmc2V0V2lkdGgpKyJweCI7Zi5zdHlsZS5ib3JkZXI9IjFweCBzb2xpZCAjZDBkMGQwIjtpZigxIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLW5vaGlkZSJdKXt2YXIgYT1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGI9bXhVdGlscy5nZXRTY3JvbGxPcmlnaW4oZG9jdW1lbnQuYm9keSksYj0icmVsYXRpdmUiPT09ZG9jdW1lbnQuYm9keS5zdHlsZS5wb3NpdGlvbj9kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOntsZWZ0Oi1iLngsdG9wOi1iLnl9LGE9e2xlZnQ6YS5sZWZ0LQpiLmxlZnQsdG9wOmEudG9wLWIudG9wLGJvdHRvbTphLmJvdHRvbS1iLnRvcCxyaWdodDphLnJpZ2h0LWIubGVmdH07Zi5zdHlsZS5sZWZ0PWEubGVmdCsicHgiOyJib3R0b20iPT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/Zi5zdHlsZS50b3A9YS5ib3R0b20tMSsicHgiOiJpbmxpbmUiIT10aGlzLmdyYXBoQ29uZmlnWyJ0b29sYmFyLXBvc2l0aW9uIl0/KGYuc3R5bGUubWFyZ2luVG9wPS10aGlzLnRvb2xiYXJIZWlnaHQrInB4IixmLnN0eWxlLnRvcD1hLnRvcCsxKyJweCIpOmYuc3R5bGUudG9wPWEudG9wKyJweCI7IjFweCBzb2xpZCB0cmFuc3BhcmVudCI9PUQmJihjLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkICNkMGQwZDAiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpO3ZhciBkPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7bnVsbCE9Zi5wYXJlbnROb2RlJiZmLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZik7bnVsbCE9bCYmKGwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsKSwKbD1udWxsKTtjLnN0eWxlLmJvcmRlcj1EfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2Vtb3ZlIixmdW5jdGlvbihhKXtmb3IoYT1teEV2ZW50LmdldFNvdXJjZShhKTtudWxsIT1hOyl7aWYoYT09Y3x8YT09Znx8YT09bClyZXR1cm47YT1hLnBhcmVudE5vZGV9ZCgpfSk7bXhFdmVudC5hZGRMaXN0ZW5lcihkb2N1bWVudCwibW91c2VsZWF2ZSIsZnVuY3Rpb24oYSl7ZCgpfSl9ZWxzZSBmLnN0eWxlLnRvcD0tdGhpcy50b29sYmFySGVpZ2h0KyJweCIsYy5hcHBlbmRDaGlsZChmKX0pOzEhPXRoaXMuZ3JhcGhDb25maWdbInRvb2xiYXItbm9oaWRlIl0/bXhFdmVudC5hZGRMaXN0ZW5lcihjLCJtb3VzZWVudGVyIixnKTpnKCl9OwpHcmFwaFZpZXdlci5wcm90b3R5cGUuYWRkQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKGEsYyl7YS5saW5rUG9saWN5PXRoaXMuZ3JhcGhDb25maWcudGFyZ2V0fHxhLmxpbmtQb2xpY3k7YS5hZGRDbGlja0hhbmRsZXIodGhpcy5ncmFwaENvbmZpZy5oaWdobGlnaHQsbXhVdGlscy5iaW5kKHRoaXMsZnVuY3Rpb24oZixkKXtpZihudWxsPT1kKXt2YXIgaz1teEV2ZW50LmdldFNvdXJjZShmKTsiYSI9PWsubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmKGQ9ay5nZXRBdHRyaWJ1dGUoImhyZWYiKSl9bnVsbCE9Yz9udWxsPT1kfHxhLmlzQ3VzdG9tTGluayhkKT9teEV2ZW50LmNvbnN1bWUoZik6YS5pc0V4dGVybmFsUHJvdG9jb2woZCl8fGEuaXNCbGFua0xpbmsoZCl8fHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5kZXN0cm95KCl9LDApOm51bGwhPWQmJm51bGw9PWMmJmEuaXNDdXN0b21MaW5rKGQpJiYobXhFdmVudC5pc1RvdWNoRXZlbnQoZil8fCFteEV2ZW50LmlzUG9wdXBUcmlnZ2VyKGYpKSYmCmEuY3VzdG9tTGlua0NsaWNrZWQoZCkmJm14RXZlbnQuY29uc3VtZShmKX0pLG14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKGEpe251bGwhPWN8fCF0aGlzLmxpZ2h0Ym94Q2xpY2tFbmFibGVkfHxteEV2ZW50LmlzVG91Y2hFdmVudChhKSYmMCE9dGhpcy50b29sYmFySXRlbXMubGVuZ3RofHx0aGlzLnNob3dMaWdodGJveCgpfSkpfTsKR3JhcGhWaWV3ZXIucHJvdG90eXBlLnNob3dMaWdodGJveD1mdW5jdGlvbihhLGMsZil7aWYoIm9wZW4iPT10aGlzLmdyYXBoQ29uZmlnLmxpZ2h0Ym94fHx3aW5kb3cuc2VsZiE9PXdpbmRvdy50b3ApaWYobnVsbD09dGhpcy5saWdodGJveFdpbmRvd3x8dGhpcy5saWdodGJveFdpbmRvdy5jbG9zZWQpe2E9bnVsbCE9YT9hOm51bGwhPXRoaXMuZ3JhcGhDb25maWcuZWRpdGFibGU/dGhpcy5ncmFwaENvbmZpZy5lZGl0YWJsZTohMDtmPXtjbGllbnQ6MSxsaWdodGJveDoxLHRhcmdldDpudWxsIT1mP2Y6ImJsYW5rIn07YSYmKGYuZWRpdD10aGlzLmdyYXBoQ29uZmlnLmVkaXR8fCJfYmxhbmsiKTtpZihudWxsIT1jP2M6MSlmLmNsb3NlPTE7dGhpcy5sYXllcnNFbmFibGVkJiYoZi5sYXllcnM9MSk7bnVsbCE9dGhpcy5ncmFwaENvbmZpZyYmMCE9dGhpcy5ncmFwaENvbmZpZy5uYXYmJihmLm5hdj0xKTtudWxsIT10aGlzLmdyYXBoQ29uZmlnJiZudWxsIT10aGlzLmdyYXBoQ29uZmlnLmhpZ2hsaWdodCYmCihmLmhpZ2hsaWdodD10aGlzLmdyYXBoQ29uZmlnLmhpZ2hsaWdodC5zdWJzdHJpbmcoMSkpO251bGwhPXRoaXMuY3VycmVudFBhZ2UmJjA8dGhpcy5jdXJyZW50UGFnZSYmKGYucGFnZT10aGlzLmN1cnJlbnRQYWdlKTsidW5kZWZpbmVkIiE9PXR5cGVvZiB3aW5kb3cucG9zdE1lc3NhZ2UmJihudWxsPT1kb2N1bWVudC5kb2N1bWVudE1vZGV8fDEwPD1kb2N1bWVudC5kb2N1bWVudE1vZGUpP251bGw9PXRoaXMubGlnaHRib3hXaW5kb3cmJm14RXZlbnQuYWRkTGlzdGVuZXIod2luZG93LCJtZXNzYWdlIixteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXsicmVhZHkiPT1hLmRhdGEmJmEuc291cmNlPT10aGlzLmxpZ2h0Ym94V2luZG93JiZ0aGlzLmxpZ2h0Ym94V2luZG93LnBvc3RNZXNzYWdlKHRoaXMueG1sLCIqIil9KSk6Zi5kYXRhPWVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnhtbCk7YT0iYXBwLmRpYWdyYW1zLm5ldCI7IjEiPT11cmxQYXJhbXMuZGV2JiYoZi5kZXY9IjEiLApmLmRyYXdkZXY9IjEiLGE9InRlc3QuZHJhdy5pbyIpO3RoaXMubGlnaHRib3hXaW5kb3c9d2luZG93Lm9wZW4oImh0dHBzOi8vIithKyIvI1AiK2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShmKSkpfWVsc2UgdGhpcy5saWdodGJveFdpbmRvdy5mb2N1cygpO2Vsc2UgdGhpcy5zaG93TG9jYWxMaWdodGJveCgpfTsKR3JhcGhWaWV3ZXIucHJvdG90eXBlLnNob3dMb2NhbExpZ2h0Ym94PWZ1bmN0aW9uKCl7dmFyIGE9bXhVdGlscy5nZXREb2N1bWVudFNjcm9sbE9yaWdpbihkb2N1bWVudCksYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtteENsaWVudC5JU19RVUlSS1M/KGMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixjLnN0eWxlLmxlZnQ9YS54KyJweCIsYy5zdHlsZS50b3A9YS55KyJweCIsYy5zdHlsZS53aWR0aD1kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKyJweCIsYy5zdHlsZS5oZWlnaHQ9ZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQrInB4Iik6Yy5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDsiO2Muc3R5bGUuekluZGV4PXRoaXMubGlnaHRib3haSW5kZXg7Yy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9IiMwMDAwMDAiO214VXRpbHMuc2V0T3BhY2l0eShjLDcwKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGMpOwp2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtmLnNldEF0dHJpYnV0ZSgiYm9yZGVyIiwiMCIpO2Yuc2V0QXR0cmlidXRlKCJzcmMiLEVkaXRvci5jbG9zZUltYWdlKTtteENsaWVudC5JU19RVUlSS1M/KGYuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixmLnN0eWxlLnJpZ2h0PSIzMnB4IixmLnN0eWxlLnRvcD1hLnkrMzIrInB4Iik6Zi5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjpmaXhlZDt0b3A6MzJweDtyaWdodDozMnB4OyI7Zi5zdHlsZS5jdXJzb3I9InBvaW50ZXIiO214RXZlbnQuYWRkTGlzdGVuZXIoZiwiY2xpY2siLGZ1bmN0aW9uKCl7ay5kZXN0cm95KCl9KTt1cmxQYXJhbXMucGFnZXM9IjEiO3VybFBhcmFtcy5wYWdlPXRoaXMuY3VycmVudFBhZ2U7dXJsUGFyYW1zWyJwYWdlLWlkIl09dGhpcy5ncmFwaENvbmZpZy5wYWdlSWQ7dXJsUGFyYW1zWyJsYXllci1pZHMiXT1udWxsIT10aGlzLmdyYXBoQ29uZmlnLmxheWVySWRzJiYwPHRoaXMuZ3JhcGhDb25maWcubGF5ZXJJZHMubGVuZ3RoPwp0aGlzLmdyYXBoQ29uZmlnLmxheWVySWRzLmpvaW4oIiAiKTpudWxsO3VybFBhcmFtcy5uYXY9MCE9dGhpcy5ncmFwaENvbmZpZy5uYXY/IjEiOiIwIjt1cmxQYXJhbXMubGF5ZXJzPXRoaXMubGF5ZXJzRW5hYmxlZD8iMSI6IjAiO2lmKG51bGw9PWRvY3VtZW50LmRvY3VtZW50TW9kZXx8MTA8PWRvY3VtZW50LmRvY3VtZW50TW9kZSlFZGl0b3IucHJvdG90eXBlLmVkaXRCdXR0b25MaW5rPXRoaXMuZ3JhcGhDb25maWcuZWRpdCxFZGl0b3IucHJvdG90eXBlLmVkaXRCdXR0b25GdW5jPXRoaXMuZ3JhcGhDb25maWcuZWRpdEZ1bmM7RWRpdG9yVWkucHJvdG90eXBlLnVwZGF0ZUFjdGlvblN0YXRlcz1mdW5jdGlvbigpe307RWRpdG9yVWkucHJvdG90eXBlLmFkZEJlZm9yZVVubG9hZExpc3RlbmVyPWZ1bmN0aW9uKCl7fTtFZGl0b3JVaS5wcm90b3R5cGUuYWRkQ2hyb21lbGVzc0NsaWNrSGFuZGxlcj1mdW5jdGlvbigpe307dmFyIGQ9R3JhcGgucHJvdG90eXBlLnNoYWRvd0lkO0dyYXBoLnByb3RvdHlwZS5zaGFkb3dJZD0KImxpZ2h0Ym94RHJvcFNoYWRvdyI7dmFyIGs9bmV3IEVkaXRvclVpKG5ldyBFZGl0b3IoITApLGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLCEwKTtrLmVkaXRvci5lZGl0QmxhbmtVcmw9dGhpcy5lZGl0QmxhbmtVcmw7ay5lZGl0b3IuZ3JhcGguc2hhZG93SWQ9ImxpZ2h0Ym94RHJvcFNoYWRvdyI7R3JhcGgucHJvdG90eXBlLnNoYWRvd0lkPWQ7ay5yZWZyZXNoPWZ1bmN0aW9uKCl7fTt2YXIgbT1teFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbihhKXsyNz09YS5rZXlDb2RlJiZrLmRlc3Ryb3koKX0pLHE9ay5kZXN0cm95O2suZGVzdHJveT1mdW5jdGlvbigpe214RXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCJrZXlkb3duIixtKTtkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGMpO2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZik7ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz0iYXV0byI7R3JhcGhWaWV3ZXIucmVzaXplU2Vuc29yRW5hYmxlZD0KITA7cS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBiPWsuZWRpdG9yLmdyYXBoLGU9Yi5jb250YWluZXI7ZS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjt0aGlzLmxpZ2h0Ym94Q2hyb21lPyhlLnN0eWxlLmJvcmRlcj0iMXB4IHNvbGlkICNjMGMwYzAiLGUuc3R5bGUubWFyZ2luPSI0MHB4IixteEV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwia2V5ZG93biIsbSkpOihjLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGYuc3R5bGUuZGlzcGxheT0ibm9uZSIpO3ZhciBnPXRoaXM7Yi5nZXRJbWFnZUZyb21CdW5kbGVzPWZ1bmN0aW9uKGEpe3JldHVybiBnLmdldEltYWdlVXJsKGEpfTt2YXIgbj1rLmNyZWF0ZVRlbXBvcmFyeUdyYXBoO2suY3JlYXRlVGVtcG9yYXJ5R3JhcGg9ZnVuY3Rpb24oKXt2YXIgYT1uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthLmdldEltYWdlRnJvbUJ1bmRsZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGcuZ2V0SW1hZ2VVcmwoYSl9O3JldHVybiBhfTsKdGhpcy5ncmFwaENvbmZpZy5tb3ZlJiYoYi5pc01vdmVDZWxsc0V2ZW50PWZ1bmN0aW9uKGEpe3JldHVybiEwfSk7bXhDbGllbnQuSVNfUVVJUktTfHwobXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGUuc3R5bGUsImJvcmRlci1yYWRpdXMiLCI0cHgiKSxlLnN0eWxlLnBvc2l0aW9uPSJmaXhlZCIpO0dyYXBoVmlld2VyLnJlc2l6ZVNlbnNvckVuYWJsZWQ9ITE7ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIjtteENsaWVudC5JU19TRnx8bXhDbGllbnQuSVNfRURHRXx8KG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2Zvcm0iLCJyb3RhdGVZKDkwZGVnKSIpLG14VXRpbHMuc2V0UHJlZml4ZWRTdHlsZShlLnN0eWxlLCJ0cmFuc2l0aW9uIiwiYWxsIC4yNXMgZWFzZS1pbi1vdXQiKSk7dGhpcy5hZGRDbGlja0hhbmRsZXIoYixrKTt3aW5kb3cuc2V0VGltZW91dChteFV0aWxzLmJpbmQodGhpcyxmdW5jdGlvbigpe2Uuc3R5bGUub3V0bGluZT0ibm9uZSI7CmUuc3R5bGUuekluZGV4PXRoaXMubGlnaHRib3haSW5kZXg7Zi5zdHlsZS56SW5kZXg9dGhpcy5saWdodGJveFpJbmRleDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZik7ay5zZXRGaWxlRGF0YSh0aGlzLnhtbCk7bXhVdGlscy5zZXRQcmVmaXhlZFN0eWxlKGUuc3R5bGUsInRyYW5zZm9ybSIsInJvdGF0ZVkoMGRlZykiKTtrLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmJvdHRvbT0iNjBweCI7ay5jaHJvbWVsZXNzVG9vbGJhci5zdHlsZS56SW5kZXg9dGhpcy5saWdodGJveFpJbmRleDtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGsuY2hyb21lbGVzc1Rvb2xiYXIpO2suZ2V0RWRpdEJsYW5rWG1sPW14VXRpbHMuYmluZCh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueG1sfSk7bXhDbGllbnQuSVNfUVVJUktTJiYoZS5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiLGUuc3R5bGUuZGlzcGxheT0iYmxvY2siLGUuc3R5bGUubGVmdD0KYS54KyJweCIsZS5zdHlsZS50b3A9YS55KyJweCIsZS5zdHlsZS53aWR0aD1kb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoLTgwKyJweCIsZS5zdHlsZS5oZWlnaHQ9ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQtODArInB4IixlLnN0eWxlLmJhY2tncm91bmRDb2xvcj0id2hpdGUiLGsuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUuZGlzcGxheT0iYmxvY2siLGsuY2hyb21lbGVzc1Rvb2xiYXIuc3R5bGUucG9zaXRpb249ImFic29sdXRlIixrLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLmJvdHRvbT0iIixrLmNocm9tZWxlc3NUb29sYmFyLnN0eWxlLnRvcD1hLnkrZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQtMTAwKyJweCIpO2subGlnaHRib3hGaXQoKTtrLmNocm9tZWxlc3NSZXNpemUoKTt0aGlzLnNob3dMYXllcnMoYix0aGlzLmdyYXBoKTtteEV2ZW50LmFkZExpc3RlbmVyKGMsImNsaWNrIixmdW5jdGlvbigpe2suZGVzdHJveSgpfSl9KSwwKTtyZXR1cm4ga307CkdyYXBoVmlld2VyLnByb3RvdHlwZS51cGRhdGVUaXRsZT1mdW5jdGlvbihhKXthPWF8fCIiO3RoaXMuc2hvd1RpdGxlQXNUb29sdGlwJiZudWxsIT10aGlzLmdyYXBoJiZudWxsIT10aGlzLmdyYXBoLmNvbnRhaW5lciYmdGhpcy5ncmFwaC5jb250YWluZXIuc2V0QXR0cmlidXRlKCJ0aXRsZSIsYSk7bnVsbCE9dGhpcy5maWxlbmFtZSYmKHRoaXMuZmlsZW5hbWUuaW5uZXJIVE1MPSIiLG14VXRpbHMud3JpdGUodGhpcy5maWxlbmFtZSxhKSx0aGlzLmZpbGVuYW1lLnNldEF0dHJpYnV0ZSgidGl0bGUiLGEpKX07CkdyYXBoVmlld2VyLnByb2Nlc3NFbGVtZW50cz1mdW5jdGlvbihhKXtteFV0aWxzLmZvckVhY2goR3JhcGhWaWV3ZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhfHwibXhncmFwaCIpLGZ1bmN0aW9uKGEpe3RyeXthLmlubmVySFRNTD0iIixHcmFwaFZpZXdlci5jcmVhdGVWaWV3ZXJGb3JFbGVtZW50KGEpfWNhdGNoKGYpe3Rocm93IGEuaW5uZXJIVE1MPWYubWVzc2FnZSxmO319KX07CkdyYXBoVmlld2VyLmdldEVsZW1lbnRzQnlDbGFzc05hbWU9ZnVuY3Rpb24oYSl7aWYoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSl7dmFyIGM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhKTthPVtdO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKWEucHVzaChjW2ZdKTtyZXR1cm4gYX1mb3IodmFyIGQ9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIioiKSxjPVtdLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIGs9ZFtmXS5jbGFzc05hbWU7bnVsbCE9ayYmMDxrLmxlbmd0aCYmKGs9ay5zcGxpdCgiICIpLDA8PW14VXRpbHMuaW5kZXhPZihrLGEpJiZjLnB1c2goZFtmXSkpfXJldHVybiBjfTsKR3JhcGhWaWV3ZXIuY3JlYXRlVmlld2VyRm9yRWxlbWVudD1mdW5jdGlvbihhLGMpe3ZhciBmPWEuZ2V0QXR0cmlidXRlKCJkYXRhLW14Z3JhcGgiKTtpZihudWxsIT1mKXt2YXIgZD1KU09OLnBhcnNlKGYpLGs9ZnVuY3Rpb24oZil7Zj1teFV0aWxzLnBhcnNlWG1sKGYpO2Y9bmV3IEdyYXBoVmlld2VyKGEsZi5kb2N1bWVudEVsZW1lbnQsZCk7bnVsbCE9YyYmYyhmKX07bnVsbCE9ZC51cmw/R3JhcGhWaWV3ZXIuZ2V0VXJsKGQudXJsLGZ1bmN0aW9uKGEpe2soYSl9KTprKGQueG1sKX19OwpHcmFwaFZpZXdlci5pbml0Q3NzPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7YS50eXBlPSJ0ZXh0L2NzcyI7YS5pbm5lckhUTUw9ImRpdi5teFRvb2x0aXAge1xuLXdlYmtpdC1ib3gtc2hhZG93OiAzcHggM3B4IDEycHggI0MwQzBDMDtcbi1tb3otYm94LXNoYWRvdzogM3B4IDNweCAxMnB4ICNDMEMwQzA7XG5ib3gtc2hhZG93OiAzcHggM3B4IDEycHggI0MwQzBDMDtcbmJhY2tncm91bmQ6ICNGRkZGQ0M7XG5ib3JkZXItc3R5bGU6IHNvbGlkO1xuYm9yZGVyLXdpZHRoOiAxcHg7XG5ib3JkZXItY29sb3I6IGJsYWNrO1xuZm9udC1mYW1pbHk6IEFyaWFsO1xuZm9udC1zaXplOiA4cHQ7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG5jdXJzb3I6IGRlZmF1bHQ7XG5wYWRkaW5nOiA0cHg7XG5jb2xvcjogYmxhY2s7fVxudGQubXhQb3B1cE1lbnVJY29uIGRpdiB7XG53aWR0aDoxNnB4O1xuaGVpZ2h0OjE2cHg7fVxuaHRtbCBkaXYubXhQb3B1cE1lbnUge1xuLXdlYmtpdC1ib3gtc2hhZG93OjJweCAycHggM3B4ICNkNWQ1ZDU7XG4tbW96LWJveC1zaGFkb3c6MnB4IDJweCAzcHggI2Q1ZDVkNTtcbmJveC1zaGFkb3c6MnB4IDJweCAzcHggI2Q1ZDVkNTtcbl9maWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkRyb3BTaGFkb3coT2ZmWD0yLCBPZmZZPTIsIENvbG9yPScjZDBkMGQwJyxQb3NpdGl2ZT0ndHJ1ZScpO1xuYmFja2dyb3VuZDp3aGl0ZTtcbnBvc2l0aW9uOmFic29sdXRlO1xuYm9yZGVyOjNweCBzb2xpZCAjZTdlN2U3O1xucGFkZGluZzozcHg7fVxuaHRtbCB0YWJsZS5teFBvcHVwTWVudSB7XG5ib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7XG5tYXJnaW46MHB4O31cbmh0bWwgdGQubXhQb3B1cE1lbnVJdGVtIHtcbnBhZGRpbmc6N3B4IDMwcHggN3B4IDMwcHg7XG5mb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsQXJpYWwgVW5pY29kZSBNUyxBcmlhbDtcbmZvbnQtc2l6ZToxMHB0O31cbmh0bWwgdGQubXhQb3B1cE1lbnVJY29uIHtcbmJhY2tncm91bmQtY29sb3I6d2hpdGU7XG5wYWRkaW5nOjBweDt9XG50ZC5teFBvcHVwTWVudUljb24gLmdlSWNvbiB7XG5wYWRkaW5nOjJweDtcbnBhZGRpbmctYm90dG9tOjRweDtcbm1hcmdpbjoycHg7XG5ib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O1xub3BhY2l0eTowLjU7XG5fd2lkdGg6MjZweDtcbl9oZWlnaHQ6MjZweDt9XG50ZC5teFBvcHVwTWVudUljb24gLmdlSWNvbjpob3ZlciB7XG5ib3JkZXI6MXB4IHNvbGlkIGdyYXk7XG5ib3JkZXItcmFkaXVzOjJweDtcbm9wYWNpdHk6MTt9XG5odG1sIHRyLm14UG9wdXBNZW51SXRlbUhvdmVyIHtcbmJhY2tncm91bmQtY29sb3I6ICNlZWVlZWU7XG5jb2xvcjogYmxhY2s7fVxudGFibGUubXhQb3B1cE1lbnUgaHIge1xuY29sb3I6I2NjY2NjYztcbmJhY2tncm91bmQtY29sb3I6I2NjY2NjYztcbmJvcmRlcjpub25lO1xuaGVpZ2h0OjFweDt9XG50YWJsZS5teFBvcHVwTWVudSB0ciB7XHRmb250LXNpemU6NHB0O31cbi5nZURpYWxvZyB7IGZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEhlbHZldGljYSxBcmlhbCBVbmljb2RlIE1TLEFyaWFsO1xuZm9udC1zaXplOjEwcHQ7XG5ib3JkZXI6bm9uZTtcbm1hcmdpbjowcHg7fVxuLmdlRGlhbG9nIHtcdHBvc2l0aW9uOmFic29sdXRlO1x0YmFja2dyb3VuZDp3aGl0ZTtcdG92ZXJmbG93OmhpZGRlbjtcdHBhZGRpbmc6MzBweDtcdGJvcmRlcjoxcHggc29saWQgI2FjYWNhYztcdC13ZWJraXQtYm94LXNoYWRvdzowcHggMHB4IDJweCAycHggI2Q1ZDVkNTtcdC1tb3otYm94LXNoYWRvdzowcHggMHB4IDJweCAycHggI2Q1ZDVkNTtcdGJveC1zaGFkb3c6MHB4IDBweCAycHggMnB4ICNkNWQ1ZDU7XHRfZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5Ecm9wU2hhZG93KE9mZlg9MiwgT2ZmWT0yLCBDb2xvcj0nI2Q1ZDVkNScsIFBvc2l0aXZlPSd0cnVlJyk7XHR6LWluZGV4OiAyO30uZ2VEaWFsb2dDbG9zZSB7XHRwb3NpdGlvbjphYnNvbHV0ZTtcdHdpZHRoOjlweDtcdGhlaWdodDo5cHg7XHRvcGFjaXR5OjAuNTtcdGN1cnNvcjpwb2ludGVyO1x0X2ZpbHRlcjphbHBoYShvcGFjaXR5PTUwKTt9LmdlRGlhbG9nQ2xvc2U6aG92ZXIge1x0b3BhY2l0eToxO30uZ2VEaWFsb2dUaXRsZSB7XHRib3gtc2l6aW5nOmJvcmRlci1ib3g7XHR3aGl0ZS1zcGFjZTpub3dyYXA7XHRiYWNrZ3JvdW5kOnJnYigyMjksIDIyOSwgMjI5KTtcdGJvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTtcdGZvbnQtc2l6ZToxNXB4O1x0Zm9udC13ZWlnaHQ6Ym9sZDtcdHRleHQtYWxpZ246Y2VudGVyO1x0Y29sb3I6cmdiKDM1LCA4NiwgMTQ5KTt9LmdlRGlhbG9nRm9vdGVyIHtcdGJhY2tncm91bmQ6d2hpdGVTbW9rZTtcdHdoaXRlLXNwYWNlOm5vd3JhcDtcdHRleHQtYWxpZ246cmlnaHQ7XHRib3gtc2l6aW5nOmJvcmRlci1ib3g7XHRib3JkZXItdG9wOjFweCBzb2xpZCAjZTVlNWU1O1x0Y29sb3I6ZGFya0dyYXk7fVxuLmdlQnRuIHtcdGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XHRib3JkZXItcmFkaXVzOiAycHg7XHRib3JkZXI6IDFweCBzb2xpZCAjZDhkOGQ4O1x0Y29sb3I6ICMzMzM7XHRjdXJzb3I6IGRlZmF1bHQ7XHRmb250LXNpemU6IDExcHg7XHRmb250LXdlaWdodDogYm9sZDtcdGhlaWdodDogMjlweDtcdGxpbmUtaGVpZ2h0OiAyN3B4O1x0bWFyZ2luOiAwIDAgMCA4cHg7XHRtaW4td2lkdGg6IDcycHg7XHRvdXRsaW5lOiAwO1x0cGFkZGluZzogMCA4cHg7XHRjdXJzb3I6IHBvaW50ZXI7fS5nZUJ0bjpob3ZlciwgLmdlQnRuOmZvY3VzIHtcdC13ZWJraXQtYm94LXNoYWRvdzogMHB4IDFweCAxcHggcmdiYSgwLDAsMCwwLjEpO1x0LW1vei1ib3gtc2hhZG93OiAwcHggMXB4IDFweCByZ2JhKDAsMCwwLDAuMSk7XHRib3gtc2hhZG93OiAwcHggMXB4IDFweCByZ2JhKDAsMCwwLDAuMSk7XHRib3JkZXI6IDFweCBzb2xpZCAjYzZjNmM2O1x0YmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcdGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCgjZjhmOGY4IDBweCwjZjFmMWYxIDEwMCUpO1x0Y29sb3I6ICMxMTE7fS5nZUJ0bjpkaXNhYmxlZCB7XHRvcGFjaXR5OiAuNTt9LmdlUHJpbWFyeUJ0biB7XHRiYWNrZ3JvdW5kLWNvbG9yOiAjNGQ5MGZlO1x0YmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KCM0ZDkwZmUgMHB4LCM0Nzg3ZWQgMTAwJSk7XHRib3JkZXI6IDFweCBzb2xpZCAjMzA3OWVkO1x0Y29sb3I6ICNmZmY7fS5nZVByaW1hcnlCdG46aG92ZXIsIC5nZVByaW1hcnlCdG46Zm9jdXMge1x0YmFja2dyb3VuZC1jb2xvcjogIzM1N2FlODtcdGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCgjNGQ5MGZlIDBweCwjMzU3YWU4IDEwMCUpO1x0Ym9yZGVyOiAxcHggc29saWQgIzJmNWJiNztcdGNvbG9yOiAjZmZmO30uZ2VQcmltYXJ5QnRuOmRpc2FibGVkIHtcdG9wYWNpdHk6IC41O30iO2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJoZWFkIilbMF0uYXBwZW5kQ2hpbGQoYSl9Y2F0Y2goYyl7fX07CkdyYXBoVmlld2VyLmNhY2hlZFVybHM9e307R3JhcGhWaWV3ZXIuZ2V0VXJsPWZ1bmN0aW9uKGEsYyxmKXtpZihudWxsIT1HcmFwaFZpZXdlci5jYWNoZWRVcmxzW2FdKWMoR3JhcGhWaWV3ZXIuY2FjaGVkVXJsc1thXSk7ZWxzZXt2YXIgZD1udWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYwPG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA5Iik/bmV3IFhEb21haW5SZXF1ZXN0Om5ldyBYTUxIdHRwUmVxdWVzdDtkLm9wZW4oIkdFVCIsYSk7ZC5vbmxvYWQ9ZnVuY3Rpb24oKXtjKG51bGwhPWQuZ2V0VGV4dD9kLmdldFRleHQoKTpkLnJlc3BvbnNlVGV4dCl9O2Qub25lcnJvcj1mO2Quc2VuZCgpfX07R3JhcGhWaWV3ZXIucmVzaXplU2Vuc29yRW5hYmxlZD0hMDtHcmFwaFZpZXdlci51c2VSZXNpemVTZW5zb3I9ITA7CihmdW5jdGlvbigpe3ZhciBhPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGEpe3JldHVybiB3aW5kb3cuc2V0VGltZW91dChhLDIwKX0sYz1mdW5jdGlvbihmLGQpe2Z1bmN0aW9uIGsoKXt0aGlzLnE9W107dGhpcy5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5xLnB1c2goYSl9O3ZhciBhLGI7dGhpcy5jYWxsPWZ1bmN0aW9uKCl7YT0wO2ZvcihiPXRoaXMucS5sZW5ndGg7YTxiO2ErKyl0aGlzLnFbYV0uY2FsbCgpfX1mdW5jdGlvbiBtKGEsYil7cmV0dXJuIGEuY3VycmVudFN0eWxlP2EuY3VycmVudFN0eWxlW2JdOndpbmRvdy5nZXRDb21wdXRlZFN0eWxlP3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShiKTphLnN0eWxlW2JdfWZ1bmN0aW9uIHEoYixjKXtpZighYi5yZXNpemVkQXR0YWNoZWQpYi5yZXNpemVkQXR0YWNoZWQ9Cm5ldyBrLGIucmVzaXplZEF0dGFjaGVkLmFkZChjKTtlbHNlIGlmKGIucmVzaXplZEF0dGFjaGVkKXtiLnJlc2l6ZWRBdHRhY2hlZC5hZGQoYyk7cmV0dXJufWIucmVzaXplU2Vuc29yPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2IucmVzaXplU2Vuc29yLmNsYXNzTmFtZT0icmVzaXplLXNlbnNvciI7Yi5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47IjtiLnJlc2l6ZVNlbnNvci5pbm5lckhUTUw9JzxkaXYgY2xhc3M9InJlc2l6ZS1zZW5zb3ItZXhwYW5kIiBzdHlsZT0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47Ij48ZGl2IHN0eWxlPSJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7Ij48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSJyZXNpemUtc2Vuc29yLXNocmluayIgc3R5bGU9InBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyI+PGRpdiBzdHlsZT0icG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHRyYW5zaXRpb246IDBzOyB3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlIj48L2Rpdj48L2Rpdj4nOwpiLmFwcGVuZENoaWxkKGIucmVzaXplU2Vuc29yKTsic3RhdGljIj09bShiLCJwb3NpdGlvbiIpJiYoYi5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKTt2YXIgZD1iLnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdLGU9ZC5jaGlsZE5vZGVzWzBdLGY9Yi5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXSxnPWZ1bmN0aW9uKCl7ZS5zdHlsZS53aWR0aD0iMTAwMDAwcHgiO2Uuc3R5bGUuaGVpZ2h0PSIxMDAwMDBweCI7ZC5zY3JvbGxMZWZ0PTFFNTtkLnNjcm9sbFRvcD0xRTU7Zi5zY3JvbGxMZWZ0PTFFNTtmLnNjcm9sbFRvcD0xRTV9O2coKTt2YXIgbD0hMSxuPWZ1bmN0aW9uKCl7Yi5yZXNpemVkQXR0YWNoZWQmJihsJiYoYi5yZXNpemVkQXR0YWNoZWQuY2FsbCgpLGw9ITEpLGEobikpfTthKG4pO3ZhciBwLHEsRSxHLEY9ZnVuY3Rpb24oKXtpZigoRT1iLm9mZnNldFdpZHRoKSE9cHx8KEc9Yi5vZmZzZXRIZWlnaHQpIT1xKWw9ITAscD1FLHE9RztnKCl9LEg9ZnVuY3Rpb24oYSxiLGMpe2EuYXR0YWNoRXZlbnQ/CmEuYXR0YWNoRXZlbnQoIm9uIitiLGMpOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMpfTtIKGQsInNjcm9sbCIsRik7SChmLCJzY3JvbGwiLEYpfXZhciBiPWZ1bmN0aW9uKCl7R3JhcGhWaWV3ZXIucmVzaXplU2Vuc29yRW5hYmxlZCYmZCgpfSxlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmKSxnPSJbb2JqZWN0IEFycmF5XSI9PT1lfHwiW29iamVjdCBOb2RlTGlzdF0iPT09ZXx8IltvYmplY3QgSFRNTENvbGxlY3Rpb25dIj09PWV8fCJ1bmRlZmluZWQiIT09dHlwZW9mIGpRdWVyeSYmZiBpbnN0YW5jZW9mIGpRdWVyeXx8InVuZGVmaW5lZCIhPT10eXBlb2YgRWxlbWVudHMmJmYgaW5zdGFuY2VvZiBFbGVtZW50cztpZihnKWZvcih2YXIgZT0wLG49Zi5sZW5ndGg7ZTxuO2UrKylxKGZbZV0sYik7ZWxzZSBxKGYsYik7dGhpcy5kZXRhY2g9ZnVuY3Rpb24oKXtpZihnKWZvcih2YXIgYT0wLGI9Zi5sZW5ndGg7YTxiO2ErKyljLmRldGFjaChmW2FdKTtlbHNlIGMuZGV0YWNoKGYpfX07CmMuZGV0YWNoPWZ1bmN0aW9uKGEpe2EucmVzaXplU2Vuc29yJiYoYS5yZW1vdmVDaGlsZChhLnJlc2l6ZVNlbnNvciksZGVsZXRlIGEucmVzaXplU2Vuc29yLGRlbGV0ZSBhLnJlc2l6ZWRBdHRhY2hlZCl9O3dpbmRvdy5SZXNpemVTZW5zb3I9Y30pKCk7CihmdW5jdGlvbigpe0VkaXRvci5pbml0TWF0aCgpO0dyYXBoVmlld2VyLmluaXRDc3MoKTtpZihudWxsIT13aW5kb3cub25EcmF3aW9WaWV3ZXJMb2FkKXdpbmRvdy5vbkRyYXdpb1ZpZXdlckxvYWQoKTtlbHNlIEdyYXBoVmlld2VyLnByb2Nlc3NFbGVtZW50cygpfSkoKTsK\";\n\nfunction evalCode() {\n  window.eval(window.atob(viewerCode));\n}\n\n\nexport { customize, evalCode };\n","import { FlowchartHandler } from 'flowchartHandler';\n\nimport XGraph from 'graph_class';\nimport { Flowchart } from 'flowchart_class';\nimport { $GF } from 'globals_class';\n\nexport class FlowchartOptionsCtrl {\n  $scope: gf.TIFlowchartOptionsScope;\n  ctrl: any; //TODO: redefine any\n  flowchartHandler: FlowchartHandler;\n  panel: any;\n  sourceTypes = $GF.CONSTANTS.SOURCE_TYPES;\n  themes = $GF.CONSTANTS.DIOTHEME_TYPES;\n  errorSourceFlag = false;\n  errorSourceMsg = '';\n  errorDownloadFlag = false;\n  errorDownloadMsg = '';\n  editMode = false;\n  currentFlowchart: Flowchart | undefined;\n  newName = '';\n  currentFlowchartName = 'Main';\n  /** @ngInject */\n  constructor($scope: gf.TIFlowchartOptionsScope) {\n    $scope.editor = this;\n    $scope.$GF = $GF.me();\n    this.$scope = $scope;\n    this.ctrl = $scope.ctrl;\n    this.panel = this.ctrl.panel;\n    this.flowchartHandler = this.ctrl.flowchartHandler;\n    this.currentFlowchart = this.flowchartHandler.getFlowchart();\n  }\n\n  /**\n   * Render\n   *\n   * @memberof FlowchartOptionsCtrl\n   */\n  render() {\n    this.flowchartHandler.render();\n  }\n\n  /**\n   * onSourceChange event when source changes\n   *\n   * @memberof FlowchartOptionsCtrl\n   */\n  onSourceChange() {\n    const name = this.flowchartHandler.getCurrentFlowchartName();\n    this.flowchartHandler.onSourceChange(name);\n    this.render();\n  }\n\n  /**\n   * onOptionChange event when options change\n   *\n   * @memberof FlowchartOptionsCtrl\n   */\n  onOptionChange() {\n    const name = this.flowchartHandler.getCurrentFlowchartName();\n    this.flowchartHandler.onOptionsChange(name);\n    this.render();\n  }\n\n  // onColorChange() {\n  //   this.onOptionChange();\n  // }\n\n  checkSource_onSourceChange(source: string): boolean {\n    const bool = XGraph.isValidXml(source);\n    this.errorSourceFlag = !bool;\n    if (!bool) {\n      $GF.message.setMessage('Invalid Xml definition', 'error');\n    } else {\n      $GF.message.clearMessage();\n      this.onSourceChange();\n      this.$scope.$applyAsync();\n    }\n    return bool;\n  }\n\n  addFlowchart() {\n    this.editMode = true;\n    this.currentFlowchart = this.flowchartHandler.addFlowchart(this.flowchartHandler.getFlowchartTmpName());\n    this.flowchartHandler.setCurrentFlowchart(this.currentFlowchart.getName());\n    $GF.message.setMessage(this.currentFlowchart.getName());\n    this.newName = this.currentFlowchart.getName();\n  }\n\n  removeFlowchart() {\n    const current = this.flowchartHandler.getCurrentFlowchart();\n    if (current !== undefined && current.getName() !== 'Main') {\n      this.currentFlowchart = this.flowchartHandler.setCurrentFlowchart();\n      this.currentFlowchartName = this.flowchartHandler.getCurrentFlowchartName();\n      $GF.message.setMessage(this.currentFlowchartName);\n      this.flowchartHandler.removeFlowchart(current.getName());\n    }\n  }\n\n  selectFlowchart() {\n    this.flowchartHandler.setCurrentFlowchart(this.currentFlowchartName);\n    this.currentFlowchart = this.flowchartHandler.getCurrentFlowchart();\n    if (this.currentFlowchart) {\n      this.currentFlowchartName = this.flowchartHandler.getCurrentFlowchartName();\n      $GF.message.setMessage(this.currentFlowchartName);\n    }\n  }\n\n  cancelFlowchart() {\n    this.editMode = false;\n    const canceled = this.currentFlowchart;\n    this.currentFlowchart = this.flowchartHandler.setCurrentFlowchart('Main');\n    if (canceled) {\n      this.flowchartHandler.removeFlowchart(canceled.getName());\n      if (this.currentFlowchart) {\n        this.currentFlowchartName = this.currentFlowchart.getName();\n      }\n    }\n    $GF.message.setMessage(this.currentFlowchartName);\n  }\n\n  isValideFlowchart(): boolean {\n    const fcs = this.flowchartHandler.getFlowchartNames();\n    if (this.newName === undefined) {\n      return false;\n    }\n    if (this.newName.length === 0) {\n      return false;\n    }\n    if (fcs.includes(this.newName) && this.currentFlowchart && this.newName !== this.currentFlowchart.getName()) {\n      $GF.message.setMessage(`Flowchart with name \"${this.newName}\" already exist`, 'error');\n      return false;\n    }\n    return true;\n  }\n\n  validateFlowchart() {\n    this.editMode = false;\n    if (this.currentFlowchart) {\n      this.currentFlowchart.setName(this.newName);\n    }\n    this.currentFlowchartName = this.newName;\n    this.currentFlowchart = this.flowchartHandler.setCurrentFlowchart(this.newName);\n  }\n\n  checkUrl_onSourceChange(url: string): boolean {\n    this.errorDownloadFlag = false;\n    // this.errorDownloadMsg = '';\n    const init: RequestInit = { method: 'GET', mode: 'cors', cache: 'default' };\n    try {\n      url = this.ctrl.templateSrv.replaceWithText(url);\n      fetch(url, init)\n        .then(response => {\n          if (!(response.status >= 200 && response.status <= 299)) {\n            this.errorSourceFlag = true;\n            // this.errorDownloadMsg = `Error ${response.status} : ${response.statusText}`;\n            $GF.message.setMessage(`Error ${response.status} : ${response.statusText}`, 'error');\n            this.$scope.$applyAsync();\n          } else {\n            response.text().then(text => {\n              const fc = this.flowchartHandler.getCurrentFlowchart();\n              if (fc && fc.data.type === 'xml') {\n                const bool = XGraph.isValidXml(text);\n                this.errorSourceFlag = !bool;\n                if (this.errorSourceFlag) {\n                  $GF.message.setMessage('Response is an invalid Xml definition', 'error');\n                  $GF.log.error('Response is an invalid Xml definition');\n                  // this.errorSourceMsg = 'Response is an invalid Xml definition';\n                } else {\n                  $GF.message.clearMessage();\n                  // this.errorDownloadMsg = '';\n                  this.onSourceChange();\n                }\n              } else {\n                // this.errorDownloadMsg = '';\n                this.onSourceChange();\n              }\n              this.$scope.$applyAsync();\n            });\n          }\n        })\n        .catch(error => {\n          this.errorSourceFlag = true;\n          // this.errorDownloadMsg = `Error : ${error}`;\n          $GF.message.setMessage(`Error : ${error}`, 'error');\n          this.$scope.$applyAsync();\n        });\n    } catch (error) {\n      this.errorDownloadFlag = true;\n      $GF.message.setMessage('Error when call url', 'error');\n      // this.errorDownloadMsg = 'Error when call url';\n    }\n    return true;\n  }\n\n  /**\n   * Open graph in index in draw.io\n   *\n   * @param {Number} name - index of graph\n   * @memberof FlowchartOptionsCtrl\n   * @see flowchartHandler:openDrawEditor\n   */\n  edit(name: string) {\n    this.flowchartHandler.openDrawEditor(name);\n  }\n\n  getFlowcharts() {\n    return this.flowchartHandler.getFlowcharts();\n  }\n\n  getNames(): string[] {\n    return this.flowchartHandler.getFlowchartNames();\n  }\n\n  getCurrentFlowchart(): Flowchart[] {\n    const current = this.flowchartHandler.getCurrentFlowchart();\n    if (current) {\n      return [current];\n    }\n    return [this.flowchartHandler.flowcharts[0]];\n  }\n}\n\n/** @ngInject */\nexport function flowchartOptionsTab($q, $sce, uiSegmentSrv) {\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: `${$GF.plugin.getPartialPath()}/flowchart/index.html`,\n    controller: FlowchartOptionsCtrl,\n  };\n}\n","import { FlowchartHandler } from './flowchartHandler';\nimport { State } from 'state_class';\nimport { $GF } from 'globals_class';\nimport { StateHandler } from 'statesHandler';\nimport _ from 'lodash';\n// import { MetricHandler } from './metricHandler';\n\ndeclare interface TColumn {\n  id: string;\n  desc: string;\n  sort: 'asc' | 'desc';\n  select: boolean;\n}\n\ndeclare interface TTable {\n  data: State[];\n  columns: TColumn[];\n}\n\nexport class InspectOptionsCtrl {\n  enable = false; // enable inspector or not\n  ctrl: any; //TODO: define type\n  flowchartHandler: FlowchartHandler;\n  stateHandler: StateHandler | undefined;\n  state: TTable;\n  panel: any;\n  traceEnable: boolean = $GF.trace.isEnabled();\n\n  /** @ngInject */\n  constructor($scope: gf.TInspectOptionsScope) {\n    $scope.editor = this;\n    $scope.$GF = $GF.me();\n\n    this.state = {\n      data: this.getStates(),\n      columns: [\n        {\n          id: 'cellId',\n          desc: 'Shape ID',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'label',\n          desc: 'Label',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'cellId',\n          desc: 'Shape ID',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'font',\n          desc: 'Font color',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'fill',\n          desc: 'Fill color',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'stroke',\n          desc: 'Stroke color',\n          sort: 'asc',\n          select: false,\n        },\n        {\n          id: 'tags',\n          desc: 'Tags Mapping',\n          sort: 'asc',\n          select: false,\n        },\n      ],\n    };\n    this.ctrl = $scope.ctrl;\n    this.panel = this.ctrl.panel;\n    this.flowchartHandler = this.ctrl.flowchartHandler;\n    this.stateHandler = this.flowchartHandler.getFlowchart().getStateHandler();\n  }\n\n  render() {\n    this.panel.render();\n  }\n\n  // onDebug() {\n  //   GFP.log.logLevel = this.logLevel;\n  //   GFP.log.logDisplay = this.logDisplay;\n  // }\n\n  onChangeId(state: State) {\n    if (state.newcellId !== undefined && state.cellId !== state.newcellId) {\n      state.edited = true;\n      const sh = this.flowchartHandler.getFlowchart().getStateHandler();\n      if (sh !== undefined) {\n        sh.edited = true;\n      }\n      if (state.previousId === undefined) {\n        state.previousId = state.cellId;\n      }\n      state.cellId = state.newcellId;\n      state.edited = true;\n    }\n    state.edit = false;\n  }\n\n  onEdit(state: State) {\n    state.edit = true;\n    state.newcellId = state.cellId;\n    // let stateHandler = this.flowchartHandler.getFlowchart().getStateHandler();\n    // stateHandler.edited = true;\n    const elt = document.getElementById(state.cellId);\n    setTimeout(() => {\n      if (elt) {\n        elt.focus();\n      }\n    }, 100);\n  }\n\n  reset() {\n    this.flowchartHandler.draw();\n    this.flowchartHandler.refresh();\n    // this.$scope.$apply();\n  }\n\n  apply() {\n    const flowchart = this.flowchartHandler.getFlowchart();\n    const sh = flowchart.getStateHandler();\n    if (sh !== undefined) {\n      const states = sh.getStates();\n      states.forEach(state => {\n        if (state.edited && state.previousId) {\n          flowchart.renameId(state.previousId, state.cellId);\n          state.edited = false;\n        }\n      });\n      sh.edited = false;\n    }\n    flowchart.applyModel();\n  }\n\n  selectCell(state: State) {\n    state.highlightCell();\n  }\n\n  unselectCell(state: State) {\n    state.unhighlightCell();\n  }\n\n  getStates(): State[] {\n    if (this.stateHandler) {\n      const states = this.stateHandler.getStatesForInspect();\n      return _.orderBy(states, ['cellId', 'globalLevel'], ['asc']);\n    }\n    return [];\n  }\n\n  getStateValue(state: State, col: string): string | null {\n    switch (col) {\n      case 'cellId':\n        return state.cellId;\n        break;\n      case 'level':\n        return state.getTextLevel();\n        break;\n      case 'label':\n        return state.getCellProp('value');\n        break;\n\n      default:\n        return null;\n        break;\n    }\n  }\n\n  tracePerf() {\n    if (this.traceEnable) {\n      $GF.trace.enable();\n    } else {\n      $GF.trace.disable();\n    }\n  }\n\n  anonymize() {\n    const fc = this.flowchartHandler.getFlowchart();\n    const xg = fc.getXGraph();\n    if (xg) {\n      xg.anonymize();\n    }\n  }\n}\n\n/** @ngInject */\nexport function inspectOptionsTab($q, uiSegmentSrv) {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: `${$GF.plugin.getPartialPath()}inspect/index.html`,\n    controller: InspectOptionsCtrl,\n  };\n}\n","import { Rule } from 'rule_class';\nimport _ from 'lodash';\nimport { $GF } from 'globals_class';\n\n/**\n * Rules Handler\n *\n * @export\n * @class RulesHandler\n */\nexport class RulesHandler {\n  rules: Rule[];\n  data: gf.TIRulesHandlerData;\n  activeRuleIndex = 0;\n  /**\n   * Creates an instance of RulesHandler.\n   * @param {TIRulesHandlerData} data\n   * @memberof RulesHandler\n   */\n  constructor(data: gf.TIRulesHandlerData) {\n    $GF.log.info('RulesHandler.constructor()');\n    this.rules = [];\n    this.data = data;\n    // this.import(this.data);\n  }\n\n  /**\n   * import datas in rule from current or old version\n   *\n   * @return this\n   * @param {any} obj\n   * @memberof RulesHandler\n   */\n  import(obj: any): this {\n    $GF.log.info('RuleHandler.import()');\n    this.rules = [];\n    let index = 1;\n    if (obj !== undefined && obj !== null) {\n      // For version < 0.6.0\n      let tmpRules: gf.TIRuleData[];\n      if (Array.isArray(obj)) {\n        tmpRules = obj;\n      } else {\n        tmpRules = obj.rulesData;\n      }\n      // Fix bug of grafana 6+\n      if (tmpRules.length > 0 && tmpRules[0].order !== undefined) {\n        tmpRules = _.sortBy(_.sortBy(tmpRules, o => o.order));\n      }\n\n      tmpRules.forEach(ruleData => {\n        this.addRule('')\n          .import(ruleData)\n          .setOrder(index);\n        index += 1;\n      });\n    }\n    return this;\n  }\n\n  static getDefaultData(): gf.TIRulesHandlerData {\n    return {\n      rulesData: [],\n    };\n  }\n\n  /**\n   * Return array of rules\n   *\n   * @returns {Array} of Rules\n   * @memberof RulesHandler\n   */\n  getRules(): Rule[] {\n    return this.rules;\n  }\n\n  /**\n   * Get Rule at index\n   *\n   * @param {number} index\n   * @returns {Rule}\n   * @memberof RulesHandler\n   */\n  getRule(index: number): Rule {\n    return this.rules[index];\n  }\n\n  /**\n   * Add a new rule\n   *\n   * @param {string} pattern\n   * @returns {Rule} New rule\n   * @memberof RulesHandler\n   */\n  addRule(pattern: string): Rule {\n    const data = Rule.getDefaultData();\n    const newRule = new Rule(pattern, data);\n    this.rules.push(newRule);\n    this.data.rulesData.push(data);\n    newRule.setOrder(this.countRules());\n    return newRule;\n  }\n\n  /**\n   * count number of rules\n   *\n   * @returns {number}\n   * @memberof RulesHandler\n   */\n  countRules(): number {\n    if (this.rules !== undefined && Array.isArray(this.rules)) {\n      return this.rules.length;\n    }\n    return 0;\n  }\n\n  /**\n   * Redefine Order number of rules\n   *\n   * @memberof RulesHandler\n   */\n  setOrder(): this {\n    const lg = this.rules.length;\n    for (let index = 0; index < lg; index++) {\n      const rule = this.rules[index];\n      rule.setOrder(index + 1);\n    }\n    return this;\n  }\n\n  /**\n   * Remove rule at index\n   *\n   * @param {number} index\n   * @memberof RulesHandler\n   */\n  removeRule(rule: Rule) {\n    const index = rule.getOrder() - 1;\n    this.rules.splice(index, 1);\n    this.data.rulesData.splice(index, 1);\n    this.setOrder();\n  }\n\n  /**\n   * Clone rules at index in index - 1\n   *\n   * @param {number} index\n   * @returns {Rule}\n   * @memberof RulesHandler\n   */\n  cloneRule(rule: Rule): Rule {\n    const index = rule.getOrder() - 1;\n    const data = rule.getData();\n    const newData: gf.TIRuleData = Rule.getDefaultData();\n    this.reduce();\n    const newRule = new Rule(newData.pattern, newData);\n    newRule.import(data);\n    newData.alias = `Copy of ${newData.alias}`;\n    this.rules.splice(index, 0, newRule);\n    this.data.rulesData.splice(index, 0, newData);\n    newRule.data.reduce = false;\n    this.activeRuleIndex = index;\n    this.setOrder();\n    const elt = document.getElementById(newRule.getId());\n    //TODO: verify ScrollTo\n    if (elt) {\n      setTimeout(() => {\n        elt.focus();\n      }, 100);\n    }\n    return newRule;\n  }\n\n  /**\n   * Reduce all rules\n   *\n   * @memberof RulesHandler\n   */\n  reduce(): this {\n    this.getRules().forEach(rule => {\n      rule.data.reduce = true;\n    });\n    return this;\n  }\n\n  /**\n   * Move rule on index in index - 1\n   *\n   * @param {rule} rule\n   * @memberof RulesHandler\n   */\n  moveRuleToUp(rule: Rule) {\n    const index = rule.getOrder() - 1;\n    const first = 0;\n    const rules = this.rules;\n    const last = rules.length - 1;\n    if (index !== first && last !== first) {\n      const curr = rules[index];\n      curr.setOrder(index);\n      const before = rules[index - 1];\n      before.setOrder(index + 1);\n      rules[index - 1] = curr;\n      rules[index] = before;\n    }\n  }\n\n  /**\n   * Move rule on index in index + 1\n   *\n   * @param {Rule} rule\n   * @memberof RulesHandler\n   */\n  moveRuleToDown(rule: Rule) {\n    const index = rule.getOrder() - 1;\n    const first = 0;\n    const rules = this.rules;\n    const last = rules.length - 1;\n    if (index !== last && last !== first) {\n      const curr = rules[index];\n      curr.setOrder(index + 2);\n      const after = rules[index + 1];\n      after.setOrder(index + 1);\n      rules[index + 1] = curr;\n      rules[index] = after;\n    }\n  }\n}\n","import Chartist from 'chartist';\n// import ctAreaGradient from 'chartist-plugin-gradient';\nimport { Metric } from './metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n *\n *\n * @export\n * @class TooltipHandler\n */\nexport class TooltipHandler {\n  timeFormat = 'YYYY-MM-DD HH:mm:ss';\n  mxcell: mxCell;\n  checked = false;\n  metrics: Set<MetricTooltip>;\n  lastChange: string | undefined;\n  div: HTMLHeadingElement | null = null;\n  constructor(mxcell: any) {\n    this.mxcell = mxcell;\n    this.checked = false;\n    this.metrics = new Set();\n  }\n\n  /**\n   * Return if tooltip is available\n   *\n   * @returns {boolean}\n   * @memberof TooltipHandler\n   */\n  isChecked(): boolean {\n    return this.checked;\n  }\n\n  /**\n   * Add a metric (one value) for tooltip\n   * @returns {MetricTooltip}\n   * @memberof TooltipHandler\n   */\n  addMetric(): MetricTooltip {\n    this.checked = true;\n    const metric = new MetricTooltip();\n    this.metrics.add(metric);\n    return metric;\n  }\n\n  /**\n   * Update date in tooltip\n   *\n   * @memberof TooltipHandler\n   */\n  updateDate() {\n    const currentDateTime = new Date();\n    this.lastChange =\n      currentDateTime.getFullYear() +\n      '-' +\n      (currentDateTime.getMonth() + 1).toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      '-' +\n      currentDateTime.getDate().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      ' ' +\n      currentDateTime.getHours().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      ':' +\n      currentDateTime.getMinutes().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      }) +\n      ':' +\n      currentDateTime.getSeconds().toLocaleString('en-US', {\n        minimumIntegerDigits: 2,\n        useGrouping: false,\n      });\n  }\n\n  destroy() {\n    this.metrics.clear();\n    if (this.mxcell.GF_tooltipHandler) {\n      delete this.mxcell.GF_tooltipHandler;\n    }\n  }\n\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement | null {\n    if (this.div !== null && this.div !== undefined) {\n      if (parentDiv && this.div) {\n        parentDiv.appendChild(this.div);\n      }\n      return this.div;\n    }\n    if (!this.checked) {\n      return null;\n    }\n    const div = document.createElement('div');\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    if (this.metrics.size > 0) {\n      this.getDateDiv(div);\n      this.metrics.forEach((metric: MetricTooltip) => {\n        metric.getDiv(div);\n      });\n    }\n    this.div = div;\n    return div;\n  }\n\n  getDateDiv(parentDiv: HTMLDivElement) {\n    const div = document.createElement('div');\n    div.id = this.mxcell.mxObjectId + '_DATE';\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    div.className = 'graph-tooltip-time tooltip-date';\n    div.innerHTML = `${this.lastChange}`;\n    return div;\n  }\n}\n\n/**\n * Create a metric for tooltip\n *\n * @class MetricTooltip\n */\nexport class MetricTooltip {\n  color: string;\n  graphs: Set<GraphTooltip>;\n  label: string;\n  value: string;\n  direction: gf.TDirectionKeys = 'v';\n  div: HTMLDivElement | undefined;\n  constructor() {\n    this.color = '#8c8980';\n    this.graphs = new Set();\n    this.label = '';\n    this.value = '';\n  }\n\n  setLabel(label: string): this {\n    this.label = label;\n    return this;\n  }\n\n  setValue(value: string): this {\n    this.value = value;\n    return this;\n  }\n\n  setColor(color: string | null): this {\n    if (color !== null) {\n      this.color = color;\n    }\n    return this;\n  }\n\n  setDirection(direction: gf.TDirectionKeys): this {\n    this.direction = direction;\n    return this;\n  }\n\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    const div = document.createElement('div');\n    div.className = 'tooltip-metric';\n    if (this.direction === 'h') {\n      div.style.display = 'inline-block';\n    }\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    this.div = div;\n    this.getTextDiv(div);\n    this.getGraphsDiv(div);\n    return div;\n  }\n\n  getTextDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    const div = document.createElement('div');\n    div.className = 'tooltip-text';\n    let str = '';\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    if (this.label !== undefined) {\n      str += `${this.label} : `;\n      str += `<span style=\"color:${this.color}\"><b>${this.value}</b></span>`;\n    }\n    div.innerHTML = str;\n    return div;\n  }\n\n  getGraphsDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    const div = document.createElement('div');\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    if (this.graphs.size > 0) {\n      this.graphs.forEach(graph => {\n        graph.getDiv(div);\n      });\n    }\n    return div;\n  }\n\n  addGraph(type: gf.TGraphTypeKeys): GraphTooltip {\n    let graph: GraphTooltip;\n    switch (type) {\n      case 'line':\n        graph = new LineGraphTooltip();\n        break;\n      case 'bar':\n        graph = new BarGraphTooltip();\n        break;\n      default:\n        $GF.log.error('Graph type unknow', type);\n        graph = new BarGraphTooltip();\n        break;\n    }\n    this.graphs.add(graph);\n    return graph;\n  }\n}\n\n/**\n * Create a graph for tooltip\n *\n * @class GraphTooltip\n */\nexport class GraphTooltip {\n  color = '#8c8980';\n\n  type: gf.TGraphTypeKeys = 'line';\n  data: Chartist.IChartistData = {\n    series: [\n      {\n        data: [{ x: 0, y: 0 }],\n      },\n    ],\n  };\n  name: string | undefined;\n  column: string | undefined;\n  size: gf.TGraphSizeKeys = '100%';\n  metric: Metric | undefined;\n  low: number | null = null;\n  high: number | null = null;\n  scaleType: gf.TGraphScaleKeys = 'linear';\n  div: HTMLDivElement | undefined;\n  chart: any;\n  parentDiv: HTMLDivElement | undefined;\n  constructor() {}\n\n  getDiv(div: HTMLDivElement): HTMLDivElement | undefined {\n    return this.div;\n  }\n\n  setName(name: string): this {\n    this.name = name;\n    return this;\n  }\n\n  setColumn(column: string): this {\n    this.column = column;\n    return this;\n  }\n\n  setType(type: gf.TGraphTypeKeys): this {\n    this.type = type;\n    return this;\n  }\n\n  setSize(size: gf.TGraphSizeKeys): this {\n    this.size = size;\n    return this;\n  }\n\n  setMetric(metric: any): this {\n    this.metric = metric;\n    return this;\n  }\n\n  setScaling(low: number | null, high: number | null): this {\n    this.low = low;\n    this.high = high;\n    return this;\n  }\n\n  setScale(type: gf.TGraphScaleKeys) {\n    this.scaleType = type;\n  }\n\n  setColor(color: string | null): this {\n    if (color !== null) {\n      this.color = color;\n    }\n    return this;\n  }\n\n  setParentDiv(div: HTMLDivElement): this {\n    this.parentDiv = div;\n    return this;\n  }\n\n  getChart() {\n    return this.chart;\n  }\n}\n\n/**\n * tooltip for line graph\n *\n * @class LineGraphTooltip\n * @extends {GraphTooltip}\n */\nclass LineGraphTooltip extends GraphTooltip {\n  chartistOptions: Chartist.ILineChartOptions;\n  div: HTMLDivElement | undefined;\n  // data: { series: Array<{ x: any; y: any }>[] } | undefined;\n  chart: Chartist.IChartistLineChart | undefined;\n  /**\n   * Creates an instance of LineGraphTooltip.\n   * @memberof LineGraphTooltip\n   */\n  constructor() {\n    super();\n    this.type = 'line';\n    this.chartistOptions = {\n      showPoint: false,\n      showLine: true,\n      showArea: true,\n      fullWidth: true,\n      axisX: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      axisY: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      chartPadding: { top: 0, left: 0, right: 0, bottom: 0 },\n    };\n  }\n\n  /**\n   * get current Div\n   *\n   * @param {HTMLDivElement} parentDiv\n   * @returns {HTMLDivElement}\n   * @memberof LineGraphTooltip\n   */\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    if (this.metric) {\n      let log = this.scaleType === 'log' ? true : false;\n      this.data.series[0]['data'] = this.metric.getData(this.column, log);\n    }\n    const div = document.createElement('div');\n    const color = this.color;\n    // const svg = '<svg style=\"width:0;height:0;position:absolute;\" aria-hidden=\"true\" focusable=\"false\">  <linearGradient id=\"my-cool-gradient\" x2=\"1\" y2=\"1\">    <stop offset=\"0%\" stop-color=\"#447799\" />    <stop offset=\"50%\" stop-color=\"#224488\" />    <stop offset=\"100%\" stop-color=\"#112266\" />  </linearGradient></svg>';\n    this.div = div;\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    div.className = 'ct-chart ct-golden-section';\n    if (this.size !== null) {\n      div.style.width = this.size;\n    }\n    if (this.low !== null) {\n      this.chartistOptions.low = this.low;\n    }\n    if (this.high !== null) {\n      this.chartistOptions.high = this.high;\n    }\n\n    this.chart = new Chartist.Line(div, this.data, this.chartistOptions);\n    this.chart.on('draw', (data: any) => {\n      if (data.type === 'line' || data.type === 'area') {\n        if (data.type === 'line') {\n          data.element.attr({\n            style: `stroke: ${color}`,\n          });\n        }\n        if (data.type === 'area') {\n          data.element.attr({\n            style: `fill: ${color}`,\n          });\n        }\n        data.element.animate({\n          d: {\n            begin: 1000 * data.index,\n            dur: 1000,\n            from: data.path\n              .clone()\n              .scale(1, 0)\n              .translate(0, data.chartRect.height())\n              .stringify(),\n            to: data.path.clone().stringify(),\n            easing: Chartist.Svg.Easing.easeOutQuint,\n          },\n        });\n      }\n    });\n    return div;\n  }\n}\n\n/**\n * Tooltip for Histogram\n *\n * @class BarGraphTooltip\n * @extends {GraphTooltip}\n */\nclass BarGraphTooltip extends GraphTooltip {\n  chartistOptions: Chartist.IBarChartOptions;\n  chart: Chartist.IChartistBarChart | undefined;\n  /**\n   * Creates an instance of BarGraphTooltip.\n   * @memberof BarGraphTooltip\n   */\n  constructor() {\n    super();\n    this.type = 'bar';\n    this.chartistOptions = {\n      axisX: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      axisY: {\n        showGrid: false,\n        showLabel: false,\n        offset: 0,\n      },\n      chartPadding: { top: 0, left: 0, right: 0, bottom: 0 },\n    };\n  }\n\n  /**\n   * Get current div\n   *\n   * @param {HTMLDivElement} parentDiv\n   * @returns {HTMLDivElement}\n   * @memberof BarGraphTooltip\n   */\n  getDiv(parentDiv: HTMLDivElement): HTMLDivElement {\n    if (this.metric) {\n      let log = this.scaleType === 'log' ? true : false;\n      this.data.series[0]['data'] = this.metric.getData(this.column, log);\n    }\n    const div = document.createElement('div');\n    const color = this.color;\n    this.div = div;\n    if (parentDiv !== undefined) {\n      parentDiv.appendChild(div);\n    }\n    div.className = 'ct-chart ct-golden-section';\n    if (this.size !== null) {\n      div.style.width = this.size;\n    }\n    if (this.low !== null) {\n      this.chartistOptions.low = this.low;\n    }\n    if (this.high !== null) {\n      this.chartistOptions.high = this.high;\n    }\n\n    this.chart = new Chartist.Bar(div, this.data, this.chartistOptions);\n    let seq = 0;\n    const length = this.data.series[0]['data'].length;\n    const delays = Math.round(50 / (length / 10));\n    const durations = Math.round(250 / (length / 10));\n    this.chart.on('draw', (data: any) => {\n      if (data.type === 'bar') {\n        data.element.attr({\n          style: `stroke: ${color}`,\n        });\n        seq++;\n        data.element.animate({\n          opacity: {\n            begin: seq * delays,\n            dur: durations,\n            from: 0,\n            to: 1,\n            easing: 'ease',\n          },\n        });\n      }\n    });\n    return div;\n  }\n}\n","import XGraph from './graph_class';\nimport { Rule, EventMap } from './rule_class';\nimport { Metric } from './metric_class';\nimport { TooltipHandler } from './tooltipHandler';\nimport { $GF, GFVariables } from 'globals_class';\n\n/**\n * Class for state of one cell\n *\n * @export\n * @class State\n */\nexport class State {\n  mxcell: mxCell; // mxCell State\n  cellId: string; // cell ID in mxcell\n  newcellId: string | undefined; // for inspect mode\n  previousId: string | undefined; // for inspect mode\n  edited: boolean | undefined; // if modified in inspector\n  edit: boolean | undefined; // if modified in inspector\n  xgraph: XGraph;\n  changed = false;\n  matched = false;\n  shapeState: ShapeState;\n  tooltipState: TooltipState;\n  iconState: IconState;\n  eventState: EventState;\n  textState: TextState;\n  linkState: LinkState;\n  variables: GFVariables;\n  status: Map<string, any>;\n  globalLevel = -1;\n  tooltipHandler: TooltipHandler | null = null;\n  originalText: string;\n\n  /**\n   * Creates an instance of State.\n   * @param {mxCell} mxcell\n   * @param {XGraph} xgraph\n   * @memberof State\n   */\n  constructor(mxcell: mxCell, xgraph: XGraph) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'constructor()');\n    this.mxcell = mxcell;\n    this.cellId = mxcell.id;\n    this.xgraph = xgraph;\n    this.shapeState = new ShapeState(xgraph, mxcell);\n    this.tooltipState = new TooltipState(xgraph, mxcell);\n    this.iconState = new IconState(xgraph, mxcell);\n    this.eventState = new EventState(xgraph, mxcell);\n    this.textState = new TextState(xgraph, mxcell);\n    this.linkState = new LinkState(xgraph, mxcell);\n    this.variables = $GF.createLocalVars();\n    this.status = new Map();\n    this.tooltipHandler = null;\n    this.mxcell.GF_tooltipHandler = null;\n    this.originalText = this.xgraph.getLabelCell(mxcell);\n    trc.after();\n  }\n\n  /**\n   * Call applyState() asynchronously\n   *\n   * @memberof State\n   */\n  async async_applyState() {\n    // new Promise (this.applyState.bind(this));\n    this.applyState();\n  }\n\n  /**\n   * Define state according to 1 rule and 1 serie without apply display\n   *\n   * @returns {this}\n   * @param {Rule} rule\n   * @param {Metric} metric\n   * @memberof State\n   */\n  setState(rule: Rule, metric: Metric): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setState()');\n    if (!rule.isHidden() && rule.matchMetric(metric)) {\n      let beginPerf = Date.now();\n      const shapeMaps = rule.getShapeMaps();\n      const textMaps = rule.getTextMaps();\n      const linkMaps = rule.getLinkMaps();\n      const eventMaps = rule.getEventMaps();\n      const value = rule.getValueForMetric(metric);\n      const FormattedValue = rule.getFormattedValue(value);\n      const level = rule.getThresholdLevel(value);\n      const color =\n        rule.data.gradient && rule.data.type === 'number' ? rule.getColorForValue(value) : rule.getColorForLevel(level);\n      this.variables.set($GF.CONSTANTS.VAR_STR_RULENAME, rule.data.alias);\n      this.variables.set($GF.CONSTANTS.VAR_NUM_VALUE, value);\n      this.variables.set($GF.CONSTANTS.VAR_STR_FORMATED, FormattedValue);\n      this.variables.set($GF.CONSTANTS.VAR_NUM_LEVEL, level);\n      this.variables.set($GF.CONSTANTS.VAR_STR_COLOR, color);\n\n      // SHAPE\n      let cellProp = this.getCellProp(rule.data.shapeProp);\n      shapeMaps.forEach(shape => {\n        let k = shape.data.style;\n        if (!shape.isHidden() && shape.match(cellProp, rule.data.shapeRegEx)) {\n          let v: any = color;\n          this.matched = true;\n          this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n          if (shape.toColorize(level)) {\n            this.shapeState.set(k, v, level) && this.status.set(k, v);\n          }\n          // TOOLTIP\n          if (rule.toTooltipize(level)) {\n            k = 'tooltip';\n            v = true;\n            this.tooltipState.set('tooltip', true, level) && this.status.set(k, v);\n            this.tooltipState.setTooltip(rule, metric, color, FormattedValue);\n          }\n          // ICONS\n          if (rule.toIconize(level)) {\n            k = 'icon';\n            v = true;\n            this.iconState.set('icon', true, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      // TEXT\n      cellProp = this.getCellProp(rule.data.textProp);\n      textMaps.forEach(text => {\n        const k = 'label';\n        if (!text.isHidden() && text.match(cellProp, rule.data.textRegEx) && text.toLabelize(level)) {\n          if (text.toLabelize(level)) {\n            this.matched = true;\n            this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n            const textScoped = this.variables.replaceText(FormattedValue);\n            const v = text.getReplaceText(this.textState.getMatchValue(k), textScoped);\n            this.textState.set(k, v, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      // EVENTS\n      cellProp = this.getCellProp(rule.data.eventProp);\n      eventMaps.forEach(event => {\n        const k = event.data.style;\n        if (!event.isHidden() && event.match(cellProp, rule.data.eventRegEx) && event.toEventable(level)) {\n          if (event.toEventable(level)) {\n            this.matched = true;\n            this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n            const v = this.variables.eval(event.data.value);\n            this.eventState.set(k, v, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      // LINK\n      cellProp = this.getCellProp(rule.data.linkProp);\n      linkMaps.forEach(link => {\n        const k = 'link';\n        if (!link.isHidden() && link.match(cellProp, rule.data.linkRegEx)) {\n          if (link.toLinkable(level)) {\n            this.matched = true;\n            this.globalLevel = level > this.globalLevel ? level : this.globalLevel;\n            const v = this.variables.replaceText(link.getLink());\n            this.linkState.set(k, v, level) && this.status.set(k, v);\n          }\n        }\n      });\n\n      if (level >= rule.highestLevel && this.matched) {\n        rule.highestLevel = level;\n        rule.highestValue = value;\n        rule.highestFormattedValue = FormattedValue;\n        rule.highestColor = color;\n      }\n      let endPerf = Date.now();\n      rule.execTimes += endPerf - beginPerf;\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Restore initial status of state without apply display.\n   * Use applyState() to apply on graph (color, level and text)\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  unsetState(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'unsetState()');\n    this.eventState.unset();\n    this.textState.unset();\n    this.linkState.unset();\n    this.tooltipState.unset();\n    this.iconState.unset();\n    this.matched = false;\n    trc.after();\n    return this;\n  }\n\n  /**\n   *\n   *\n   * @param {string} prop - id|value\n   * @returns {string|null} return original value of id or label of cell\n   * @memberof State\n   */\n  getCellProp(prop: gf.TPropertieKey): string | null {\n    if (prop === 'id') {\n      return this.cellId;\n    }\n    if (prop === 'value') {\n      return this.originalText;\n    }\n    return null;\n  }\n\n  /**\n   * Get the highest/global level\n   *\n   * @returns {number}\n   * @memberof State\n   */\n  getLevel(): number {\n    return this.globalLevel;\n  }\n\n  /**\n   * Get Level in text\n   *\n   * @returns {number}\n   * @memberof State\n   */\n  getTextLevel(): string {\n    return this.globalLevel === -1 ? '' : this.globalLevel.toString();\n  }\n\n  getStatus(key: string): string {\n    let style: string | null | undefined = this.status.get(key);\n    if (style !== undefined && style !== null) {\n      return style;\n    }\n    style = this.xgraph.getStyleCell(this.mxcell, key);\n    if (style === null) {\n      style = '';\n    }\n    this.status.set(key, style);\n    return style;\n  }\n\n  haveStatus(key: string): boolean {\n    return this.status.has(key);\n  }\n\n  /**\n   * Return true if is a shape/vertex\n   *\n   * @returns\n   * @memberof State\n   */\n  isShape(): boolean {\n    return this.mxcell.isVertex();\n  }\n\n  /**\n   * Return true if is a arrow/connector\n   *\n   * @returns\n   * @memberof State\n   */\n  isConnector(): boolean {\n    return this.mxcell.isEdge();\n  }\n\n  /**\n   * Apply new state\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  applyState(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyState()');\n    if (this.matched || this.changed) {\n      this.changed = true;\n      this.shapeState.apply();\n      this.tooltipState.apply();\n      this.iconState.apply();\n      this.textState.apply();\n      this.eventState.apply();\n      this.linkState.apply();\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Reset and restore state\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  reset(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'reset()');\n    this.shapeState.reset();\n    this.tooltipState.reset();\n    this.iconState.reset();\n    this.textState.reset();\n    this.eventState.reset();\n    this.linkState.reset();\n    this.variables.clear();\n    this.status.clear();\n    this.globalLevel = -1;\n    this.changed = false;\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Prepare state for a new rule and serie\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  prepare(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'prepare()');\n    if (this.changed) {\n      this.shapeState.prepare();\n      this.tooltipState.prepare();\n      this.iconState.prepare();\n      this.textState.prepare();\n      this.eventState.prepare();\n      this.linkState.prepare();\n      this.variables.clear();\n      this.status.clear();\n      this.globalLevel = -1;\n      this.matched = false;\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Highlight mxcell\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  highlightCell(): this {\n    this.xgraph.highlightCell(this.mxcell);\n    return this;\n  }\n\n  /**\n   * Unhighlight mxcell\n   *\n   * @returns {this}\n   * @memberof State\n   */\n  unhighlightCell(): this {\n    this.xgraph.unhighlightCell(this.mxcell);\n    return this;\n  }\n}\n\n/**\n * Mother of sub states\n *\n * @class GFState\n */\nexport class GFState {\n  xgraph: XGraph;\n  mxcell: mxCell;\n  keys: string[] = [];\n  matchedKey: Map<string, boolean> = new Map();\n  changedKey: Map<string, boolean> = new Map();\n  originalValue: Map<string, any> = new Map();\n  matchValue: Map<string, any> = new Map();\n  static DEFAULTLEVEL: number = -1;\n  // lastValue: Map<string, any> = new Map(); To not apply the same value\n  matchLevel: Map<string, number> = new Map();\n\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    this.xgraph = xgraph;\n    this.mxcell = mxcell;\n    this.init_core();\n  }\n\n  init_core() {}\n\n  addValue(key: string, value: any) {\n    if (!this.hasKey(key)) {\n      // _GF.log.warn('GFState.addValue()', key, 'not found');\n      this.keys.push(key);\n    }\n    this.originalValue.set(key, value);\n    this.matchValue.set(key, value);\n    // this.lastValue.set(key, value); To not apply the same value\n    this.matchLevel.set(key, GFState.DEFAULTLEVEL);\n    this.matchedKey.set(key, false);\n    this.changedKey.set(key, false);\n  }\n\n  hasKey(key: string): boolean {\n    return this.keys.includes(key);\n  }\n\n  getOriginalValue(key: string): any | undefined {\n    if (!this.hasKey(key)) {\n      this.originalValue.set(key, this.default_core(key));\n    }\n    return this.originalValue.get(key);\n  }\n\n  getMatchValue(key: string): any | undefined {\n    if (!this.hasKey(key)) {\n      this.matchValue.set(key, this.getOriginalValue(key));\n    }\n    return this.matchValue.get(key);\n  }\n\n  /**\n   * Insert key and value if >= level\n   *\n   * @param {string} key\n   * @param {*} value\n   * @param {number} level\n   * @returns {boolean} true if applied\n   * @memberof GFState\n   */\n  set(key: string, value: any, level: number): boolean {\n    let matchLevel = this.matchLevel.get(key);\n    if (matchLevel === undefined) {\n      const defaultValue = this.default_core(key);\n      this.addValue(key, defaultValue);\n      return this.set(key, value, level);\n    }\n    if (matchLevel <= level) {\n      this.matchLevel.set(key, level);\n      this.matchedKey.set(key, true);\n      this.matchValue.set(key, value);\n      return true;\n    }\n    return false;\n  }\n\n  apply(key?: string): this {\n    if (key !== undefined) {\n      if (this.isMatched(key)) {\n        let value = this.getMatchValue(key);\n        try {\n          this.apply_core(key, value);\n        } catch (error) {\n          $GF.log.error('Error on reset for key ' + key, error);\n        }\n        this.changedKey.set(key, true);\n        this.matchedKey.set(key, false);\n      } else if (this.isChanged(key)) {\n        this.reset(key);\n      }\n    } else {\n      this.keys.forEach(key => {\n        this.apply(key);\n      });\n    }\n    return this;\n  }\n\n  default_core(key: any): any {\n    return null;\n  }\n\n  apply_core(key: any, value: any) {}\n\n  isMatched(key?: string): boolean {\n    if (key !== undefined) {\n      return this.matchedKey.get(key) === true;\n    }\n    let matched = false;\n    this.keys.forEach(key => {\n      matched = this.isMatched(key) || matched;\n    });\n    return matched;\n  }\n\n  isChanged(key?: string): boolean {\n    if (key !== undefined) {\n      return this.changedKey.get(key) === true;\n    }\n    let changed = false;\n    this.keys.forEach(key => {\n      changed = this.isChanged(key) ? true : changed;\n    });\n    return changed;\n  }\n\n  getLevel(key?: string): number {\n    if (key !== undefined) {\n      let level = this.matchLevel.get(key);\n      return level !== undefined ? level : GFState.DEFAULTLEVEL;\n    }\n    let level = GFState.DEFAULTLEVEL;\n    this.keys.forEach(key => (level = Math.max(this.getLevel(key))));\n    return level;\n  }\n\n  unset(key?: string): this {\n    if (key !== undefined) {\n      this.matchValue.set(key, this.originalValue.get(key));\n      this.matchedKey.set(key, false);\n      this.matchLevel.set(key, -1);\n    } else {\n      this.keys.forEach(key => {\n        this.unset(key);\n      });\n    }\n    return this;\n  }\n\n  reset(key?: string): this {\n    if (key !== undefined) {\n      this.unset(key);\n      let value = this.getOriginalValue(key);\n      try {\n        this.reset_core(key, value);\n      } catch (error) {\n        $GF.log.error('Error on reset for key ' + key, error);\n      }\n      this.changedKey.set(key, false);\n      this.matchedKey.set(key, false);\n    } else {\n      this.keys.forEach(key => {\n        this.reset(key);\n      });\n    }\n    return this;\n  }\n\n  reset_core(key: any, value: any) {}\n\n  prepare(): this {\n    if (this.isChanged()) {\n      this.unset();\n    }\n    return this;\n  }\n}\n\n/**\n * Event SubState\n *\n * @class EventState\n * @extends {GFState}\n */\nclass EventState extends GFState {\n  keys: gf.TStyleEventKeys[] = [];\n  geo:\n    | {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n      }\n    | undefined = undefined;\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // this.keys = $GF.CONSTANTS.EVENTMETHODS.map(x => x.value);\n    this.geo = this.xgraph.getSizeCell(this.mxcell);\n    // this.keys.forEach(key => {\n    //   const value = this._get(key);\n    //   this.addValue(key, value);\n    // });\n  }\n\n  default_core(key: gf.TStyleEventKeys): any {\n    return this._get(key);\n  }\n\n  async apply_core(key: gf.TStyleEventKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this._set(key, value);\n  }\n\n  async reset_core(key: gf.TStyleEventKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this._set(key, value);\n  }\n\n  _set(key: gf.TStyleEventKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    let beginValue: any = undefined;\n    const toUnset: boolean = this.isChanged(key) && !this.isMatched(key);\n    let className = '';\n    let newkey: gf.TStyleEventKeys | 'class' = key;\n    if (key.startsWith('class_')) {\n      newkey = 'class';\n      className = key.substring(6);\n    }\n    switch (newkey) {\n      case 'class':\n        if (toUnset) {\n          this.xgraph.unsetClassCell(this.mxcell, className);\n        } else {\n          this.xgraph.setClassCell(this.mxcell, className);\n        }\n        break;\n      case 'text':\n        value = String(value);\n        this.xgraph.setLabelCell(this.mxcell, value);\n        break;\n\n      case 'visibility':\n        value = String(value);\n        if (value === '0') {\n          this.xgraph.hideCell(this.mxcell);\n        } else if (value === '1') {\n          this.xgraph.showCell(this.mxcell);\n        }\n        break;\n\n      case 'fold':\n        value = String(value);\n        if (value === '0') {\n          this.xgraph.collapseCell(this.mxcell);\n        } else if (value === '1') {\n          this.xgraph.expandCell(this.mxcell);\n        }\n        break;\n\n      case 'height':\n        if (this.geo !== undefined) {\n          let height = Number(value);\n          if (this.isMatched('height')) {\n            let width = this.isMatched('width') ? Number(this.getMatchValue('width')) : undefined;\n            this.xgraph.changeSizeCell(this.mxcell, width, height, this.geo);\n            this.unset('width');\n          } else {\n            if (!this.isMatched('width')) {\n              this.xgraph.resetSizeCell(this.mxcell, this.geo);\n              this.unset('width');\n            }\n          }\n        }\n        break;\n\n      case 'width':\n        if (this.geo !== undefined) {\n          let width = Number(value);\n          if (this.isMatched('width')) {\n            let height = this.isMatched('height') ? Number(this.getMatchValue('height')) : undefined;\n            this.xgraph.changeSizeCell(this.mxcell, width, height, this.geo);\n            this.unset('width');\n          } else {\n            if (!this.isMatched('height')) {\n              this.xgraph.resetSizeCell(this.mxcell, this.geo);\n              this.unset('height');\n            }\n          }\n        }\n        break;\n\n      case 'size':\n        if (this.geo !== undefined) {\n          let percent = Number(value);\n          this.xgraph.resizeCell(this.mxcell, percent, this.geo);\n        }\n        break;\n\n      case 'barPos':\n      case 'fontSize':\n      case 'opacity':\n      case 'textOpacity':\n      case 'rotation':\n        beginValue = this._get(key);\n        beginValue = beginValue === undefined ? EventMap.getDefaultValue(key) : beginValue;\n        this.xgraph.setStyleAnimCell(this.mxcell, key, value, beginValue);\n        break;\n\n      case 'blink':\n        if (!!value) {\n          this.xgraph.blinkCell(this.mxcell, value);\n        } else {\n          this.xgraph.unblinkCell(this.mxcell);\n        }\n        break;\n\n      default:\n        this.xgraph.setStyleCell(this.mxcell, key, value);\n        break;\n    }\n  }\n\n  _get(key: gf.TStyleEventKeys): any {\n    switch (key) {\n      case 'text':\n        return this.xgraph.getLabelCell(this.mxcell);\n        break;\n\n      case 'visibility':\n        return this.xgraph.isVisibleCell(this.mxcell) === false ? '0' : '1';\n        break;\n\n      case 'height':\n        return this.geo !== undefined ? this.geo.height : undefined;\n        break;\n\n      case 'width':\n        return this.geo !== undefined ? this.geo.width : undefined;\n        break;\n\n      case 'size':\n        return 100;\n        break;\n\n      case 'fold':\n        return this.xgraph.isCollapsedCell(this.mxcell) === true ? '0' : '1';\n        break;\n\n      case 'blink':\n        return this.xgraph.geBlinkMxCell(this.mxcell);\n        break;\n\n      default:\n        return this.xgraph.getStyleCell(this.mxcell, key);\n        break;\n    }\n  }\n}\n\nclass TextState extends GFState {\n  // keys: string[] = ['label'];\n  keys: string[] = [];\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // const value = this.xgraph.getLabelCell(this.mxcell);\n    // this.addValue('label', value);\n  }\n\n  default_core(key: any): string | null {\n    return this.xgraph.getLabelCell(this.mxcell);\n  }\n\n  async apply_core(key: string, value: any) {\n    this.xgraph.setLabelCell(this.mxcell, value);\n  }\n\n  async reset_core(key: string, value: any) {\n    this.xgraph.setLabelCell(this.mxcell, value);\n  }\n}\n\nclass LinkState extends GFState {\n  // keys: string[] = ['link'];\n  keys: string[] = [];\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // const value = this.xgraph.getLink(this.mxcell);\n    // this.addValue('link', value);\n  }\n\n  default_core(key: any): string | null {\n    return this.xgraph.getLink(this.mxcell);\n  }\n\n  async apply_core(key: string, value: any) {\n    this.xgraph.addLink(this.mxcell, value);\n  }\n\n  async reset_core(key: string, value: any) {\n    if (value === undefined || value === null || value.length === 0) {\n      this.xgraph.removeLink(this.mxcell);\n    } else {\n      this.xgraph.addLink(this.mxcell, value);\n    }\n  }\n}\n\n/**\n * State for shape color\n *\n * @class ShapeState\n * @extends {GFState}\n */\nclass ShapeState extends GFState {\n  keys: gf.TStyleColorKeys[] = [];\n  fullStylesString: string | undefined;\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    // this.keys = $GF.CONSTANTS.COLORMETHODS.map(x => x.value);\n    // this.fullStylesString = this.mxcell.getStyle();\n    // this.keys.forEach(key => {\n    //   const value = this.xgraph.getStyleCell(this.mxcell, key);\n    //   this.addValue(key, value);\n    //   $GF.log.debug('ShapeState [' + this.mxcell.id + '] Add value : ' + key, value);\n    // });\n    this.mxcell.GF_tooltipHandler = null;\n  }\n\n  default_core(key: any): string | null {\n    return this.xgraph.getStyleCell(this.mxcell, key);\n  }\n\n  async apply_core(key: gf.TStyleColorKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this.xgraph.setColorAnimCell(this.mxcell, key, value);\n  }\n\n  async reset_core(key: gf.TStyleColorKeys, value: any) {\n    if (value === undefined) {\n      value = null;\n    }\n    this.xgraph.setColorAnimCell(this.mxcell, key, value);\n  }\n}\n\nclass TooltipState extends GFState {\n  keys: string[] = ['tooltip'];\n  tooltipHandler: TooltipHandler | undefined;\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init_core();\n  }\n\n  init_core() {\n    this.addValue('tooltip', false);\n    this.tooltipHandler = undefined;\n    this.mxcell.GF_tooltipHandler = null;\n  }\n\n  async setTooltip(rule: Rule, metric: Metric, color: string, value: string) {\n    let tpColor: string | null = null;\n    let label: string = rule.data.tooltipLabel;\n    if (this.tooltipHandler === null || this.tooltipHandler === undefined) {\n      this.tooltipHandler = new TooltipHandler(this.mxcell);\n    }\n    if (label === null || label.length === 0) {\n      if (rule.data.metricType === 'serie') {\n        label = metric.getName();\n      }\n      if (rule.data.metricType === 'table') {\n        label = rule.data.column;\n      }\n    }\n    if (rule.data.tooltipColors) {\n      tpColor = color;\n    }\n    // METRIC\n    const metricToolip = this.tooltipHandler\n      .addMetric()\n      .setLabel(label)\n      .setValue(value)\n      .setColor(tpColor)\n      .setDirection(rule.data.tpDirection);\n    // GRAPH\n    if (rule.data.tpGraph) {\n      const graph = metricToolip.addGraph(rule.data.tpGraphType);\n      graph\n        .setColor(tpColor)\n        .setColumn(rule.data.column)\n        .setMetric(metric)\n        .setSize(rule.data.tpGraphSize)\n        .setScaling(rule.data.tpGraphLow, rule.data.tpGraphHigh)\n        .setScale(rule.data.tpGraphScale);\n    }\n    // Date\n    this.tooltipHandler.updateDate();\n  }\n\n  apply(key?: string): this {\n    if (key !== undefined && key === 'tooltip') {\n      if (this.isMatched(key) && this.getMatchValue(key) === true) {\n        if (this.tooltipHandler != null && this.tooltipHandler.isChecked()) {\n          this.mxcell.GF_tooltipHandler = this.tooltipHandler;\n        }\n        super.apply(key);\n      }\n    } else {\n      this.keys.forEach(key => {\n        this.apply(key);\n      });\n    }\n    return this;\n  }\n\n  prepare(): this {\n    super.prepare();\n    this.reset();\n    return this;\n  }\n\n  reset(key?: string): this {\n    if (key !== undefined && key === 'tooltip') {\n      this.mxcell.GF_tooltipHandler = null;\n      if (this.tooltipHandler) {\n        this.tooltipHandler.destroy();\n      }\n      this.tooltipHandler = undefined;\n      super.reset(key);\n    } else {\n      this.keys.forEach(key => {\n        this.reset(key);\n      });\n    }\n    return this;\n  }\n}\n\nclass IconState extends GFState {\n  // keys: string[] = ['icon'];\n  keys: string[] = [];\n  constructor(xgraph: XGraph, mxcell: mxCell) {\n    super(xgraph, mxcell);\n    this.init();\n  }\n\n  init() {\n    // this.addValue('icon', false);\n  }\n\n  default_core(key: string): any {\n    return false;\n  }\n\n  apply_core(key?: string): this {\n    if (key !== undefined && key === 'icon') {\n      if (this.isMatched(key) && this.getMatchValue(key) === true) {\n        if (!this.isChanged(key)) {\n          this.xgraph.addOverlay(`WARNING/ERROR`, this.mxcell);\n        }\n        // super.apply(key);\n      } else if (this.isChanged(key)) {\n        this.reset_core(key);\n      }\n    } else {\n      this.keys.forEach(key => {\n        this.apply_core(key);\n      });\n    }\n    return this;\n  }\n\n  reset_core(key?: string): this {\n    if (key !== undefined && key === 'icon') {\n      this.xgraph.removeOverlay(this.mxcell);\n      // super.reset(key);\n    } else {\n      this.keys.forEach(key => {\n        this.reset_core(key);\n      });\n    }\n    return this;\n  }\n}\n","import { State } from './state_class';\nimport { Rule } from './rule_class';\nimport _ from 'lodash';\nimport { Metric } from './metric_class';\nimport XGraph from 'graph_class';\nimport { $GF } from 'globals_class';\n\n/**\n * States Handler class\n *\n * @export\n * @class StateHandler\n */\nexport class StateHandler {\n  states: Map<string, State>;\n  xgraph: XGraph;\n  edited = false;\n  /**\n   * Creates an instance of StateHandler.\n   * @param {XGraph} xgraph\n   * @memberof StateHandler\n   */\n  constructor(xgraph: XGraph) {\n    this.states = new Map();\n    this.xgraph = xgraph;\n    this.initStates(this.xgraph);\n  }\n\n  /**\n   * Initialisation of states\n   *\n   * @returns {this}\n   * @param {XGraph} xgraph\n   * @memberof StateHandler\n   */\n  initStates(xgraph: XGraph): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initStates()');\n    this.xgraph = xgraph;\n    this.states.clear();\n    const mxcells = xgraph.getMxCells();\n    _.each(mxcells, mxcell => {\n      this.addState(mxcell);\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Return states array for a rule\n   *\n   * @param {Rule} rule - rule mapping\n   * @returns {Array<State>}\n   * @memberof StateHandler\n   */\n  getStatesForRule(rule: Rule) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getStatesForRule()');\n    const result = new Map();\n    let name: string | null;\n    const xgraph = this.xgraph;\n    this.states.forEach(state => {\n      const mxcell: mxCell = state.mxcell;\n      const id: string = mxcell.id;\n      let found = false;\n\n      // SHAPES\n      name = xgraph.getValuePropOfMxCell(rule.data.shapeProp, mxcell);\n      if (name !== null && rule.matchShape(name)) {\n        result.set(id, state);\n        found = true;\n      }\n\n      // TEXTS\n      if (!found) {\n        name = xgraph.getValuePropOfMxCell(rule.data.textProp, mxcell);\n        if (rule.matchText(name)) {\n          result.set(id, state);\n          found = true;\n        }\n      }\n\n      // LINKS\n      if (!found) {\n        name = xgraph.getValuePropOfMxCell(rule.data.linkProp, mxcell);\n        if (rule.matchLink(name)) {\n          result.set(id, state);\n          found = true;\n        }\n      }\n\n      // EVENTS\n      if (!found) {\n        name = xgraph.getValuePropOfMxCell(rule.data.eventProp, mxcell);\n        if (rule.matchEvent(name)) {\n          result.set(id, state);\n          found = true;\n        }\n      }\n    });\n    trc.after();\n    return result;\n  }\n\n  /**\n   * Update States : Add or remove state in states when rules changed\n   *\n   * @param {XGraph} xgraph\n   * @param {Array<Rule>} rules\n   * @memberof StateHandler\n   */\n  updateStates(rules: Rule[]) {\n    $GF.log.info('StateHandler.updateStates()');\n    rules.forEach(rule => {\n      rule.states = this.getStatesForRule(rule);\n    });\n  }\n\n  /**\n   * Return array of state\n   *\n   * @returns Map<States>\n   * @memberof StateHandler\n   */\n  getStates() {\n    return this.states;\n  }\n\n  /**\n   * get array states\n   *\n   * @returns {State[]}\n   * @memberof StateHandler\n   */\n  getStatesForInspect(): State[] {\n    const states: State[] = [];\n    this.states.forEach(state => {\n      states.push(state);\n    });\n    return states;\n  }\n\n  /**\n   * Find state by Id\n   * @param  {string} cellId - Id of cell\n   * @returns {state}\n   */\n  getState(cellId: string): State | undefined {\n    return this.states.get(cellId);\n  }\n\n  /**\n   * Add a state\n   *\n   * @param {mxCell} mxcell\n   * @returns {State} created state\n   * @memberof StateHandler\n   */\n  addState(mxcell: mxCell): State {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addState()');\n    const state = new State(mxcell, this.xgraph);\n    this.states.set(mxcell.id, state);\n    if ($GF.DEBUG) {\n      $GF.setVar(`STATE_${state.cellId}`, state);\n    }\n    trc.after();\n    return state;\n  }\n\n  /**\n   * Count number of state\n   *\n   * @returns {Number}\n   * @memberof StateHandler\n   */\n  countStates(): number {\n    return this.states.size;\n  }\n\n  /**\n   * Restore initial status and prepare states object\n   */\n  prepare(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'prepare()');\n    this.states.forEach(state => {\n      state.prepare();\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Change states according to rules and datas from grafana\n   * @param  {Array<Rule>} rules - Array of Rule object\n   * @param  {Array<Metric>} metrics - Array of serie object\n   */\n  setStates(rules: Rule[], metrics: Metric[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setStates()');\n    this.prepare();\n    rules.forEach(rule => {\n      rule.highestLevel = -1;\n      rule.highestFormattedValue = '';\n      rule.highestColor = '';\n      rule.highestValue = '';\n      rule.execTimes = 0;\n      if (rule.states === undefined || rule.states.size === 0) {\n        rule.states = this.getStatesForRule(rule);\n      }\n      rule.states.forEach(state => {\n        metrics.forEach(metric => {\n          state.setState(rule, metric);\n        });\n      });\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Apply color and text\n   */\n  applyStates(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyStates()');\n    this.states.forEach(state => {\n      state.async_applyState();\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Call applyStates asynchronously\n   *\n   * @memberof StateHandler\n   */\n  async async_applyStates() {\n    this.applyStates();\n  }\n}\n","import XGraph from 'graph_class';\nimport { StateHandler } from 'statesHandler';\nimport { State } from 'state_class';\nimport { Rule } from 'rule_class';\n\nimport { FlowchartHandler } from 'flowchartHandler';\nimport { Metric } from 'metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n * Flowchart handler\n *\n * @export\n * @class Flowchart\n */\nexport class Flowchart {\n  data: gf.TFlowchartData;\n  container: HTMLDivElement;\n  xgraph: XGraph | undefined = undefined;\n  stateHandler: StateHandler | undefined;\n  // ctrl: any;\n  templateSrv: any;\n  states: Map<string, State> | undefined;\n  id: string;\n  visible = false;\n\n  constructor(name: string, container: HTMLDivElement, ctrl: any, data: gf.TFlowchartData) {\n    this.data = data;\n    this.data.name = name;\n    this.container = container;\n    this.templateSrv = ctrl.templateSrv;\n    this.id = $GF.utils.uniqueID();\n  }\n\n  /**\n   * Import data object in current flowchart\n   *\n   * @param {Object} obj\n   * @memberof Flowchart\n   */\n  import(obj: any): this {\n    $GF.log.info(`flowchart[${this.data.name}].import()`);\n    if (!!obj.download || this.data.download === false) {\n      this.data.download = obj.download;\n    }\n    // 0.3.0\n    if (!!obj.source) {\n      this.data.type = obj.source.type;\n      this.data.xml = obj.source.xml.value;\n      this.data.url = obj.source.url.value;\n    }\n    // 0.3.0\n    if (!!obj.options) {\n      this.data.zoom = obj.options.zoom;\n      this.data.center = obj.options.center;\n      this.data.scale = obj.options.scale;\n      this.data.lock = obj.options.lock;\n      this.data.allowDrawio = false;\n      this.data.tooltip = obj.options.tooltip;\n      this.data.grid = obj.options.grid;\n      this.data.bgColor = obj.options.bgColor;\n    }\n    if (!!obj.type) {\n      this.data.type = obj.type;\n    }\n    if (!!obj.xml) {\n      this.data.xml = obj.xml;\n    }\n\n    // 0.9.0\n    if (!!obj.csv) {\n      this.data.csv = obj.csv;\n    }\n    if (!!obj.url) {\n      this.data.url = obj.url;\n    }\n    if (!!obj.zoom) {\n      this.data.zoom = obj.zoom;\n    }\n    if (!!obj.center || obj.center === false) {\n      this.data.center = obj.center;\n    }\n    if (!!obj.scale || obj.scale === false) {\n      this.data.scale = obj.scale;\n    }\n\n    if (!!obj.lock || obj.lock === false) {\n      this.data.lock = obj.lock;\n    }\n    if (!!obj.allowDrawio || obj.allowDrawio === false) {\n      this.data.allowDrawio = obj.allowDrawio;\n    }\n    if (!!obj.enableAnim || obj.enableAnim === false) {\n      this.data.enableAnim = obj.enableAnim;\n    }\n    if (!!obj.tooltip) {\n      this.data.tooltip = obj.tooltip;\n    }\n    if (!!obj.grid || obj.grid === false) {\n      this.data.grid = obj.grid;\n    }\n    if (!!obj.bgColor) {\n      this.data.bgColor = obj.bgColor;\n    }\n    if (!!obj.editorUrl) {\n      this.data.editorUrl = obj.editorUrl;\n    }\n    if (!!obj.editorTheme) {\n      this.data.editorTheme = obj.editorTheme;\n    }\n    this.init();\n    return this;\n  }\n\n  /**\n   * Return the default XML when new\n   *\n   * @static\n   * @returns {gf.TFlowchartData}\n   * @memberof Flowchart\n   */\n  static getDefaultData(): gf.TFlowchartData {\n    return {\n      name: 'name',\n      xml: FlowchartHandler.getDefaultDioGraph(),\n      csv: FlowchartHandler.getDefaultCsvGraph(),\n      download: false,\n      type: 'xml',\n      url: 'http://<YourUrl>/<Your XML/drawio file/api>',\n      zoom: '100%',\n      center: true,\n      scale: true,\n      lock: true,\n      allowDrawio: true,\n      enableAnim: true,\n      tooltip: true,\n      grid: false,\n      bgColor: null,\n      editorUrl: 'https://www.draw.io',\n      editorTheme: 'dark',\n    };\n  }\n\n  /**\n   * Return data without functions to save json in grafana\n   *\n   * @returns {Object} Data object\n   * @memberof Flowchart\n   */\n  getData(): gf.TFlowchartData {\n    return this.data;\n  }\n\n  /**\n   * Update states of flowchart/graph\n   *\n   * @param {*} rules\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  updateStates(rules: Rule[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'updateStates()');\n    rules.forEach(rule => {\n      if (this.stateHandler !== undefined) {\n        rule.states = this.stateHandler.getStatesForRule(rule);\n        if (rule.states) {\n          rule.states.forEach((state: any) => {\n            state.unsetState();\n          });\n        } else {\n          $GF.log.warn('States not defined for this rule');\n        }\n      } else {\n        $GF.log.error('updateStates => this.stateHandler undefined');\n      }\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Initialisation of flowchart class\n   *\n   * @return {this}\n   * @memberof Flowchart\n   */\n  init(): this {\n    try {\n      const content = this.getContent();\n      if (this.xgraph === undefined) {\n        this.xgraph = new XGraph(this.container, this.data.type, content);\n      }\n      if (content !== undefined && content !== null) {\n        if (this.data.allowDrawio) {\n          this.xgraph.allowDrawio(true);\n        } else {\n          this.xgraph.allowDrawio(false);\n        }\n        if (this.data.enableAnim) {\n          this.xgraph.enableAnim(true);\n        } else {\n          this.xgraph.enableAnim(false);\n        }\n        this.setOptions();\n        this.xgraph.drawGraph();\n        if (this.data.tooltip) {\n          this.xgraph.tooltipGraph(true);\n        }\n        if (this.data.scale) {\n          this.xgraph.scaleGraph(true);\n        } else {\n          this.xgraph.zoomGraph(this.data.zoom);\n        }\n        if (this.data.center) {\n          this.xgraph.centerGraph(true);\n        }\n        if (this.data.lock) {\n          this.xgraph.lockGraph(true);\n        }\n        this.stateHandler = new StateHandler(this.xgraph);\n        $GF.message.clearMessage();\n      } else {\n        $GF.message.setMessage('Source content empty Graph not defined', 'error');\n        $GF.log.error('Source content empty Graph not defined');\n      }\n    } catch (error) {\n      $GF.message.setMessage('Unable to initialize graph', 'error');\n      $GF.log.error('Unable to initialize graph', error);\n    }\n    return this;\n  }\n\n  /**\n   * Get states handler\n   *\n   * @returns\n   * @memberof Flowchart\n   */\n  getStateHandler() {\n    return this.stateHandler;\n  }\n\n  /**\n   * Get XGraph\n   *\n   * @returns\n   * @memberof Flowchart\n   */\n  getXGraph() {\n    return this.xgraph;\n  }\n\n  /**\n   * Init states with rules and metrics\n   *\n   * @param {Rule[]} rules\n   * @param {Metric[]} metrics\n   * @memberof Flowchart\n   */\n  setStates(rules: Rule[], metrics: Metric[]): this {\n    // $GF.log.info(`flowchart[${this.data.name}].setStates()`);\n    if (rules === undefined) {\n      $GF.log.warn(\"Rules shoudn't be null\");\n    }\n    if (metrics === undefined) {\n      $GF.log.warn(\"Metrics shoudn't be null\");\n    }\n    if (this.stateHandler) {\n      this.stateHandler.setStates(rules, metrics);\n    }\n    return this;\n  }\n\n  /**\n   * Init options of graph\n   *\n   * @memberof Flowchart\n   */\n  setOptions(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setOptions()');\n    this.setScale(this.data.scale);\n    this.setCenter(this.data.center);\n    this.setGrid(this.data.grid);\n    this.setTooltip(this.data.tooltip);\n    this.setLock(this.data.lock);\n    this.setZoom(this.data.zoom);\n    this.setBgColor(this.data.bgColor);\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Apply new states (colors,text ...)\n   *\n   * @memberof Flowchart\n   */\n  applyStates(): this {\n    // $GF.log.info(`flowchart[${this.data.name}].applyStates()`);\n    if (this.stateHandler) {\n      this.stateHandler.applyStates();\n    }\n    return this;\n  }\n\n  /**\n   * Apply options\n   *\n   * @memberof Flowchart\n   */\n  applyOptions() {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyOptions()');\n    if (this.xgraph) {\n      this.xgraph.applyGraph();\n    }\n    trc.after();\n  }\n\n  /**\n   * Refresh graph\n   *\n   * @memberof Flowchart\n   */\n  refresh() {\n    if (this.xgraph) {\n      this.xgraph.refresh();\n    }\n  }\n\n  /**\n   * Reset and redraw graph when source changed\n   *\n   * @param {*} xmlGraph\n   * @memberof Flowchart\n   */\n  redraw(content?: string) {\n    if (content !== undefined) {\n      this.setContent(content);\n    }\n    if (this.xgraph !== undefined) {\n      this.xgraph.setContent(this.getContent());\n    }\n    // this.applyOptions();\n  }\n\n  /**\n   * Reload source of graph\n   *\n   * @memberof Flowchart\n   */\n  reload() {\n    if (this.xgraph !== undefined && this.xgraph !== null) {\n      this.xgraph.destroyGraph();\n      this.xgraph = undefined;\n      this.init();\n    } else {\n      this.init();\n    }\n  }\n\n  /**\n   * Destroy this flowchart correctly\n   *\n   * @memberof Flowchart\n   */\n  destroy() {\n    this.toBack();\n    if (this.xgraph !== undefined && this.xgraph !== null) {\n      this.xgraph.destroyGraph();\n      this.xgraph = undefined;\n    }\n    this.container.remove();\n  }\n\n  /**\n   * Set the name\n   *\n   * @param {string} name\n   * @memberof Flowchart\n   */\n  setName(name: string) {\n    this.data.name = name;\n  }\n\n  getName(): string {\n    return this.data.name;\n  }\n\n  /**\n   * Set paramater lock\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setLock(bool: boolean): this {\n    this.data.lock = bool;\n    if (this.xgraph) {\n      this.xgraph.lock = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Lock graph\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyLock(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.lock = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.lockGraph(this.data.lock);\n    }\n    return this;\n  }\n\n  /**\n   * Set enable tooltip\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setTooltip(bool: boolean): this {\n    this.data.tooltip = bool;\n    if (this.xgraph) {\n      this.xgraph.tooltip = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Enable tooltip\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyTooltip(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.tooltip = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.tooltipGraph(this.data.tooltip);\n    }\n    return this;\n  }\n\n  /**\n   * Set scale parameter\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setScale(bool: boolean): this {\n    this.data.scale = bool;\n    if (this.xgraph) {\n      this.xgraph.scale = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Set BgColor\n   *\n   * @param {(string | null)} bgColor\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setBgColor(bgColor: string | null): this {\n    this.data.bgColor = bgColor;\n    if (this.xgraph) {\n      this.xgraph.bgColor = bgColor;\n    }\n    return this;\n  }\n\n  /**\n   * Apply Background color\n   *\n   * @param {string} bgColor\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  ApplyBgColor(bgColor: string): this {\n    this.data.bgColor = bgColor;\n    if (bgColor) {\n      if (this.xgraph) {\n        this.xgraph.bgGraph(bgColor);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Apply scale parameter\n   *\n   * @param {boolean} bool\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyScale(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.scale = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.scaleGraph(this.data.scale);\n    }\n    return this;\n  }\n\n  /**\n   * set center parameter\n   *\n   * @param {boolean} bool\n   * @returns\n   * @memberof Flowchart\n   */\n  setCenter(bool: boolean) {\n    this.data.center = bool;\n    if (this.xgraph) {\n      this.xgraph.center = bool;\n    }\n    return this;\n  }\n\n  /**\n   * Get names array of names according id or value\n   *\n   * @param {gf.TPropertieKey} prop\n   * @returns {string[]}\n   * @memberof Flowchart\n   */\n  getNamesByProp(prop: gf.TPropertieKey): string[] {\n    if (this.xgraph) {\n      return this.xgraph.getOrignalCells(prop);\n    }\n    return [];\n  }\n\n  /**\n   * get XML def with var replaced\n   *\n   * @param {boolean} replaceVarBool\n   * @returns {string}\n   * @memberof Flowchart\n   */\n  getXml(replaceVarBool: boolean = true): string {\n    if (!replaceVarBool) {\n      return this.data.xml;\n    }\n    return this.templateSrv.replaceWithText(this.data.xml);\n  }\n\n  /**\n   * get CSV def with var replaced\n   *\n   * @param {boolean} replaceVarBool\n   * @returns {string}\n   * @memberof Flowchart\n   */\n  getCsv(replaceVarBool: boolean = true): string {\n    if (!replaceVarBool) {\n      return this.data.csv;\n    }\n    return this.templateSrv.replaceWithText(this.data.csv);\n  }\n\n  /**\n   * Get data source according type\n   *\n   * @param {boolean} [replaceVarBool=true]\n   * @returns\n   * @memberof Flowchart\n   */\n  getSource(replaceVarBool: boolean = true) {\n    if (this.data.type === 'xml') {\n      return this.getXml(replaceVarBool);\n    }\n    if (this.data.type === 'csv') {\n      return this.getCsv(replaceVarBool);\n    }\n    return '';\n  }\n\n  /**\n   * Get Url editor\n   *\n   * @returns {string}\n   * @memberof Flowchart\n   */\n  getUrlEditor(): string {\n    return this.data.editorUrl;\n  }\n\n  getThemeEditor(): string {\n    return this.data.editorTheme;\n  }\n\n  /**\n   * Get Source of graph (csv|xml) or get content from url\n   *\n   * @param {boolean} replaceVarBool\n   * @returns\n   * @memberof Flowchart\n   */\n  getContent(replaceVarBool: boolean = true): string {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getContent()');\n    let content: string | null = '';\n    if (this.data.download) {\n      const url = this.templateSrv.replaceWithText(this.data.url);\n      $GF.message.setMessage(`Loading content definition for ${this.data.name}`, 'info');\n      content = this.loadContent(url);\n      $GF.message.clearMessage();\n      if (content !== null) {\n        if (replaceVarBool) {\n          content = this.templateSrv.replaceWithText(content);\n        }\n      }\n    } else {\n      content = this.getSource(replaceVarBool);\n    }\n    trc.after();\n    return content === null ? '' : content;\n  }\n\n  /**\n   * Set the data source\n   *\n   * @param {string} content\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  setContent(content: string): this {\n    if (this.data.type === 'xml') {\n      this.data.xml = content;\n    }\n    if (this.data.type === 'csv') {\n      this.data.csv = content;\n    }\n    return this;\n  }\n\n  /**\n   * Load source from url\n   *\n   * @param {*} url\n   * @returns\n   * @memberof Flowchart\n   */\n  loadContent(url: string): string | null {\n    return $GF.utils.$loadFile(url);\n  }\n\n  renameId(oldId: string, newId: string): this {\n    if (this.xgraph) {\n      this.xgraph.renameId(oldId, newId);\n    }\n    return this;\n  }\n\n  /**\n   * Apply xml to graph\n   *\n   * @returns {this}\n   * @memberof Flowchart\n   */\n  applyModel(): this {\n    if (this.xgraph) {\n      this.data.xml = this.xgraph.getXmlModel();\n    }\n    this.redraw();\n    return this;\n  }\n\n  center(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.center = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.centerGraph(this.data.center);\n    }\n    return this;\n  }\n\n  setZoom(percent: string): this {\n    this.data.zoom = percent;\n    if (this.xgraph) {\n      this.xgraph.zoomPercent = percent;\n    }\n    return this;\n  }\n\n  zoom(percent: string): this {\n    if (percent !== undefined) {\n      this.data.zoom = percent;\n    }\n    if (this.xgraph) {\n      this.xgraph.zoomGraph(this.data.zoom);\n    }\n    return this;\n  }\n\n  setGrid(bool: boolean): this {\n    this.data.grid = bool;\n    if (this.xgraph) {\n      this.xgraph.grid = bool;\n    }\n    return this;\n  }\n\n  grid(bool: boolean): this {\n    if (bool !== undefined) {\n      this.data.grid = bool;\n    }\n    if (this.xgraph) {\n      this.xgraph.gridGraph(this.data.grid);\n    }\n    return this;\n  }\n\n  setXml(xml: string): this {\n    this.data.xml = xml;\n    return this;\n  }\n\n  setCsv(csv: string): this {\n    this.data.csv = csv;\n    return this;\n  }\n\n  minify() {\n    this.data.xml = $GF.utils.minify(this.data.xml);\n  }\n\n  prettify() {\n    this.data.xml = $GF.utils.prettify(this.data.xml);\n  }\n\n  decode() {\n    if ($GF.utils.isencoded(this.data.xml)) {\n      this.data.xml = $GF.utils.decode(this.data.xml, true, true, true);\n      // this.data.xml = XGraph.decompress(this.data.xml);\n    }\n  }\n\n  encode() {\n    if (!$GF.utils.isencoded(this.data.xml)) {\n      this.data.xml = $GF.utils.encode(this.data.xml, true, true, true);\n      // this.data.xml = XGraph.compress(this.data.xml);\n    }\n  }\n\n  getContainer(): HTMLDivElement {\n    return this.container;\n  }\n\n  setMap(onMappingObj: gf.TIOnMappingObj) {\n    const container = this.getContainer();\n    if (this.xgraph) {\n      this.xgraph.setMap(onMappingObj);\n    }\n    container.scrollIntoView();\n    container.focus();\n  }\n\n  unsetMap() {\n    if (this.xgraph) {\n      this.xgraph.unsetMap();\n    }\n  }\n\n  toFront(forceRefresh: boolean = true): this {\n    $GF.log.debug('toFront', this.data.name);\n    this.visible = true;\n    this.container.className = 'GF_show';\n    if (forceRefresh) {\n      this.applyOptions();\n    }\n    return this;\n  }\n\n  toBack(): this {\n    $GF.log.debug('toBack', this.data.name);\n    this.visible = false;\n    this.container.className = 'GF_hide';\n    return this;\n  }\n\n  isVisible(): boolean {\n    return this.visible;\n  }\n}\n","import { Flowchart } from 'flowchart_class';\nimport { Rule, GFMap } from 'rule_class';\nimport _ from 'lodash';\nimport { Metric } from './metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n * Class FlowchartHandler\n */\nexport class FlowchartHandler {\n  $scope: ng.IScope;\n  $elem: any; //TODO: elem ?\n  parentDiv: HTMLDivElement;\n  ctrl: any; //TODO: ctrl ?\n  flowcharts: Flowchart[] = [];\n  currentFlowchartName = 'Main'; // name of current Flowchart\n  currentFlowchart: Flowchart | undefined;\n  data: gf.TFlowchartHandlerData;\n  firstLoad = true; // First load\n  flags = {\n    sources: new Set<string>(),\n    options: new Set<string>(),\n    rules: new Set<string>(),\n    datas: new Set<string>(),\n    graphHover: new Set<string>(),\n    applyOptions: new Set<string>(),\n    hiddenChange: new Set<string>(),\n  };\n  // changeSourceFlag: Set<string> = new Set<string>(); // Source changed\n  // changeOptionFlag: Set<string> = new Set<string>(); // Options changed\n  // changeDataFlag = false; // Data changed\n  // changeGraphHoverFlag = false; // Graph Hover\n  // changeRuleFlag = false; // rules changed\n  newMode = false; // Mode if new flowchart\n  sequenceNumber = 0; // Sequence Number for a name\n  static defaultXml: string;\n  static defaultCsv: string;\n  onMapping: gf.TIOnMappingObj = {\n    active: false,\n    object: null,\n    value: null,\n    prop: 'id',\n    $scope: null,\n  };\n  mousedownTimeout = 0;\n  mousedown = 0;\n  onEdit = false; // editor open or not\n  postedId: string | undefined = undefined; // Current ID on edit mode\n  editorWindow: Window | null = null; // Window draw.io editor\n\n  /**\n   * Creates an instance of FlowchartHandler to handle flowchart\n   * @param {ng.IScope} $scope - angular scope\n   * @param {any} elem - angular elem\n   * @param {TODO:FlowchartCtrl} ctrl - ctrlPanel\n   * @param {*} data - Empty data to store\n   * @memberof FlowchartHandler\n   */\n  constructor($scope: ng.IScope, elem: any, ctrl: any, data: gf.TFlowchartHandlerData) {\n    FlowchartHandler.getDefaultDioGraph();\n    this.$scope = $scope;\n    this.$elem = elem.find('.flowchart-panel__chart');\n    this.parentDiv = this.$elem[0];\n    this.ctrl = ctrl;\n    this.data = data;\n    this.currentFlowchartName = this.data.main;\n\n    // Events Render\n    ctrl.events.on('render', () => {\n      this.render();\n    });\n\n    document.body.onmousedown = () => {\n      this.mousedown = 0;\n      window.clearInterval(this.mousedownTimeout);\n      this.mousedownTimeout = window.setInterval(() => {\n        this.mousedown += 1;\n      }, 200);\n    };\n\n    document.body.onmouseup = () => {\n      this.mousedown = 0;\n      window.clearInterval(this.mousedownTimeout);\n    };\n  }\n\n  static getDefaultData(): gf.TFlowchartHandlerData {\n    return {\n      editorUrl: 'https://www.draw.io',\n      editorTheme: 'kennedy',\n      main: 'Main',\n      flowcharts: [],\n    };\n  }\n\n  /**\n   * import data into\n   *\n   * @returns {this}\n   * @param {Object} obj\n   * @memberof FlowchartHandler\n   */\n  import(obj: any): this {\n    this.flowcharts = [];\n    if (obj !== undefined && obj !== null) {\n      // For version 0.5.0 and under\n      let tmpFc: gf.TFlowchartData[];\n      if (Array.isArray(obj)) {\n        tmpFc = obj;\n      } else {\n        tmpFc = obj.flowcharts;\n      }\n\n      // For 0.9.0 and under\n      if (tmpFc.length === 1) {\n        this.data.main = tmpFc[0].name;\n        this.currentFlowchartName = this.data.main;\n        this.data.editorTheme = tmpFc[0].editorTheme;\n        this.data.editorUrl = tmpFc[0].editorUrl;\n      }\n      this.data.editorTheme = !!obj.editorTheme ? obj.editorTheme : this.data.editorTheme;\n      this.data.editorUrl = !!obj.editorUrl ? obj.editorUrl : this.data.editorUrl;\n\n      // import data\n      tmpFc.forEach((fcData: gf.TFlowchartData) => {\n        // const container = this.createContainer();\n        // const newData = Flowchart.getDefaultData();\n        // const fc = new Flowchart(fcData.name, container, this.ctrl, newData);\n        this.addFlowchart(fcData.name)\n          .toBack()\n          .import(fcData);\n        // fc.import(fcData);\n        // this.flowcharts.push(fc);\n        // this.data.flowcharts.push(newData);\n      });\n      this.currentFlowchart = this.getFlowchart('Main');\n    }\n    return this;\n  }\n\n  /**\n   * Return default xml source graph\n   *\n   * @static\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  static getDefaultDioGraph(): string {\n    let result = FlowchartHandler.defaultXml;\n    if (!result) {\n      const url = `${$GF.plugin.getRootPath()}${$GF.CONSTANTS.CONF_FILE_DEFAULTDIO}`;\n      result = $GF.utils.$loadFile(url);\n    }\n    return result;\n  }\n\n  /**\n   * Return default xml source graph\n   *\n   * @static\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  static getDefaultCsvGraph(): string {\n    let result = FlowchartHandler.defaultCsv;\n    if (!result) {\n      const url = `${$GF.plugin.getRootPath()}${$GF.CONSTANTS.CONF_FILE_DEFAULTCSV}`;\n      result = $GF.utils.$loadFile(url);\n    }\n    return result;\n  }\n\n  /**\n   * Get flowchart with name\n   *\n   * @param {string} name\n   * @returns {Flowchart}\n   * @memberof FlowchartHandler\n   */\n  getFlowchart(name?: string): Flowchart {\n    if (name) {\n      const lg = this.flowcharts.length;\n      for (let i = 0; i < lg; i++) {\n        const fc = this.flowcharts[i];\n        if (fc.getName() === name) {\n          return fc;\n        }\n      }\n    }\n    const current = this.getCurrentFlowchart();\n    return current !== undefined ? current : this.flowcharts[0];\n  }\n\n  getFlowchartById(id: string): Flowchart | undefined {\n    const fcs = this.getFlowcharts();\n    for (let index = 0; index < fcs.length; index++) {\n      const fc = fcs[index];\n      if (fc.id === id) {\n        return fc;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Return array of flowchart\n   *\n   * @returns {Flowchart[]} Array of flowchart\n   * @memberof FlowchartHandler\n   */\n  getFlowcharts(): Flowchart[] {\n    return this.flowcharts;\n  }\n\n  /**\n   * Return number of flowchart\n   *\n   * @returns {number} Nulber of flowchart\n   * @memberof FlowchartHandler\n   */\n  countFlowcharts(): number {\n    if (this.flowcharts !== undefined && Array.isArray(this.flowcharts)) {\n      return this.flowcharts.length;\n    }\n    return 0;\n  }\n\n  /**\n   * get a temp name\n   *\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  getFlowchartTmpName(): string {\n    if (this.sequenceNumber === 0) {\n      this.sequenceNumber = this.countFlowcharts();\n    }\n    return `Flowchart-${this.sequenceNumber++}`;\n  }\n\n  /**\n   * Define current flowchart to display\n   *\n   * @param {string} name, Main if empty\n   * @returns {(Flowchart|undefined)}\n   * @memberof FlowchartHandler\n   */\n  setCurrentFlowchart(name?: string): Flowchart | undefined {\n    $GF.log.debug('setCurrentFlowchart', name);\n    if (name === undefined) {\n      this.currentFlowchart = this.getFlowchart('Main');\n      this.currentFlowchartName = this.currentFlowchart.getName();\n      this.currentFlowchart.toFront();\n      return this.currentFlowchart;\n    }\n    if (this.currentFlowchart === undefined) {\n      this.currentFlowchart = this.getFlowchart(name);\n      this.currentFlowchartName = this.currentFlowchart.getName();\n      // this.currentFlowchart.toFront();\n      return this.currentFlowchart;\n    }\n    if (this.currentFlowchart.getName() !== name) {\n      this.currentFlowchart.toBack();\n    }\n    this.currentFlowchart = this.getFlowchart(name);\n    this.currentFlowchartName = name;\n    this.currentFlowchart.toFront();\n    return this.currentFlowchart;\n  }\n\n  /**\n   * get Current Flowchart\n   *\n   * @returns {(Flowchart|undefined)}\n   * @memberof FlowchartHandler\n   */\n  getCurrentFlowchart(): Flowchart | undefined {\n    return this.currentFlowchart;\n  }\n\n  /**\n   * Give the name of current flowchart\n   *\n   * @returns {string}\n   * @memberof FlowchartHandler\n   */\n  getCurrentFlowchartName(): string {\n    const cf = this.getCurrentFlowchart();\n    return cf !== undefined ? cf.getName() : 'Main';\n  }\n\n  /**\n   * Create a div container for graph\n   *\n   * @returns {HTMLDivElement}\n   * @memberof FlowchartHandler\n   */\n  createContainer(): HTMLDivElement {\n    const div = document.createElement('div');\n    div.style.margin = 'auto';\n    // div.style.position = 'relative';\n    div.style.position = 'absolute';\n    div.style.width = '100%';\n    div.style.height = '100%';\n    div.style.touchAction = 'none';\n    div.style.border = 'none';\n    div.style.cursor = 'default';\n    div.style.right = '0px';\n    div.style.left = '0px';\n    div.style.bottom = '0px';\n    div.style.top = '0px';\n    // div.style.overflow = 'none';\n    this.parentDiv.appendChild(div);\n    return div;\n  }\n\n  /**\n   * Add a flowchart\n   *\n   * @param {string} name\n   * @returns {Flowchart}\n   * @memberof FlowchartHandler\n   */\n  addFlowchart(name: string): Flowchart {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addFlowchart()');\n    const data = Flowchart.getDefaultData();\n    const container = this.createContainer();\n    const flowchart = new Flowchart(name, container, this.ctrl, data);\n    // flowchart.init();\n    this.flowcharts.push(flowchart);\n    this.data.flowcharts.push(data);\n    // this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES, name);\n    trc.after();\n    return flowchart;\n  }\n\n  /**\n   * Remove a flowchart\n   *\n   * @param {string} name\n   * @memberof FlowchartHandler\n   */\n  removeFlowchart(name: string) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'removeFlowchart()');\n    const fc = this.getFlowchart(name);\n    const index = this.flowcharts.indexOf(fc);\n    this.flowcharts.splice(index, 1);\n    this.data.flowcharts.splice(index, 1);\n    fc.destroy();\n    trc.after();\n  }\n\n  /**\n   * Render for draw\n   *\n   * @memberof FlowchartHandler\n   */\n  async render(name?: string) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'render()');\n    // console.log('RENDER Flags', this.flags);\n    // not repeat render if mouse down\n    if (!this.mousedown) {\n      this.flagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS);\n      const self = this;\n      // SOURCE\n      if (self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES)) {\n        this.getFlagNames($GF.CONSTANTS.FLOWCHART_CHG_SOURCES).forEach(name => {\n          self.load(name).setOptions(name);\n        });\n      }\n\n      // OPTIONS\n      if (self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS)) {\n        this.getFlagNames($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS).forEach(name => {\n          self.setOptions(name);\n        });\n      }\n\n      // RULES or DATAS\n      if (\n        self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_RULES) ||\n        self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS) ||\n        self.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_GRAPHHOVER)\n      ) {\n        const rules = self.ctrl.rulesHandler.getRules();\n        const metrics = self.ctrl.metricHandler.getMetrics();\n\n        // Change to async to optimize\n        self.async_refreshStates(rules, metrics);\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS);\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS);\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_GRAPHHOVER);\n      }\n      // Current visible\n      if (self.currentFlowchart !== undefined && !self.currentFlowchart.isVisible()) {\n        this.setCurrentFlowchart(self.currentFlowchart.getName());\n        this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS);\n      }\n\n      // OTHER : Resize, OnLoad\n      if (self.isFlagedChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS) || self.firstLoad) {\n        // this.setCurrentFlowchart('Main');\n        this.getFlagNames($GF.CONSTANTS.FLOWCHART_APL_OPTIONS).forEach(name => {\n          self.applyOptions(name);\n        });\n        self.firstLoad = false;\n      }\n      // this.refresh();\n    }\n    this.ctrl.renderingCompleted();\n    trc.after();\n  }\n\n  /**\n   * Flag source change\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onSourceChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES, name);\n    return this;\n  }\n\n  /**\n   * Flag options change\n   *\n   * @param {string} [name]\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onOptionsChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS, name);\n    return this;\n  }\n\n  /**\n   * Flag datas change\n   *\n   * @param {string} [name]\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onDatasChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS, name);\n    return this;\n  }\n\n  /**\n   * Flag rule change\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onRulesChange(name?: string): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_RULES, name);\n    return this;\n  }\n\n  /**\n   * Flag data Graph-Hover change\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  onGraphHoverChange(): this {\n    this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_GRAPHHOVER, name);\n    return this;\n  }\n\n  /**\n   * Apply options on graphs\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  applyOptions(name?: string): this {\n    $GF.log.debug(`${this.constructor.name}.applyOptions()`, name);\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyOptions()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.applyOptions(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      flowchart.applyOptions();\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS, name);\n      if (!flowchart.isVisible()) {\n        this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_HIDDENCHANGE, name);\n      }\n    }\n    trc.after();\n    return this;\n  }\n\n  flagChange(type: gf.TFlowchartFlagKeys, name?: string): this {\n    $GF.log.debug('flagChange', type, name);\n    if (name !== undefined) {\n      this.flags[type].add(name);\n    } else {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.flags[type].add(name);\n      });\n    }\n    return this;\n  }\n\n  isFlagedChange(type: gf.TFlowchartFlagKeys, name?: string): boolean {\n    if (name === undefined) {\n      return this.flags[type].size > 0;\n    }\n    return this.flags[type].has(name);\n  }\n\n  aknowledgeFlagChange(type: gf.TFlowchartFlagKeys, name?: string): void {\n    $GF.log.debug('aknowledgeFlagChange', type, name);\n    if (name === undefined) {\n      this.flags[type].clear();\n    } else {\n      this.flags[type].delete(name);\n    }\n  }\n\n  getFlagNames(type: gf.TFlowchartFlagKeys): string[] {\n    let result: string[] = [];\n    this.flags[type].forEach(value => result.push(value));\n    return result;\n  }\n\n  /**\n   * Call refreshStates asynchronously\n   *\n   * @param {Rule[]} rules\n   * @param {Metric[]} metrics\n   * @memberof FlowchartHandler\n   */\n  async_refreshStates(rules: Rule[], metrics: Metric[]) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'async_refreshStates()');\n    this.refreshStates(rules, metrics);\n    trc.after();\n  }\n\n  /**\n   * Refresh rules according new rules or data\n   *\n   * @param {Rule[]} rules\n   * @param {Metric[]} metrics\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  refreshStates(rules: Rule[], metrics: Metric[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'refreshStates()');\n    if (this.isFlagedChange($GF.CONSTANTS.FLOWCHART_CHG_RULES)) {\n      this.updateStates(rules);\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_RULES);\n    }\n    this.setStates(rules, metrics);\n    this.applyStates();\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Refresh all flowchart\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  refresh(): this {\n    this.flowcharts.forEach(flowchart => {\n      flowchart.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * Change states of cell according to rules and metrics\n   *\n   * @param {Rule[]} rules\n   * @param {any[]} metrics\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  setStates(rules: Rule[], metrics: any[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setStates()');\n    this.flowcharts.forEach(flowchart => {\n      flowchart.setStates(rules, metrics);\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Update states with rule\n   *\n   * @param {Rule[]} rules\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  updateStates(rules: Rule[]): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'updateStates()');\n    this.flowcharts.forEach(flowchart => {\n      flowchart.updateStates(rules);\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Apply state of cell after setStates\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  applyStates(): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'applyStates()');\n    new Promise(() => {\n      this.flowcharts.forEach(flowchart => {\n        flowchart.applyStates();\n      });\n    }).then(() => {\n      this.refresh();\n    });\n    trc.after();\n    return this;\n  }\n\n  /**\n   * Set and apply options\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  setOptions(name?: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'setOptions()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.setOptions(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      flowchart.setOptions();\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_OPTIONS, name);\n      this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_DATAS, name);\n      this.flagChange($GF.CONSTANTS.FLOWCHART_APL_OPTIONS, name);\n      if (!flowchart.isVisible()) {\n        this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_HIDDENCHANGE, name);\n      }\n    }\n    trc.after();\n    return this;\n  }\n\n  setCurrentOptions(): this {\n    const name = this.getCurrentFlowchartName();\n    this.setOptions(name);\n    return this;\n  }\n\n  /**\n   * (re)draw graph\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  draw(name?: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'draw()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        const name = flowchart.getName();\n        this.draw(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      flowchart.redraw();\n    }\n    trc.after();\n    return this;\n  }\n\n  drawCurrent(): this {\n    const name = this.getCurrentFlowchartName();\n    this.draw(name);\n    return this;\n  }\n\n  /**\n   * (re)load graph,\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  load(name?: string): this {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'draw()');\n    if (name === undefined) {\n      this.flowcharts.forEach(flowchart => {\n        this.load(name);\n      });\n    } else {\n      const flowchart = this.getFlowchart(name);\n      if (!flowchart.isVisible()) {\n        this.flagChange($GF.CONSTANTS.FLOWCHART_CHG_HIDDENCHANGE, name);\n      }\n      flowchart.reload();\n      this.aknowledgeFlagChange($GF.CONSTANTS.FLOWCHART_CHG_SOURCES, name);\n    }\n    trc.after();\n    return this;\n  }\n\n  /**\n   * load current flowchart\n   *\n   * @returns {this}\n   * @memberof FlowchartHandler\n   */\n  loadCurrent(): this {\n    const name = this.getCurrentFlowchartName();\n    this.load(name);\n    return this;\n  }\n\n  /**\n   * Active option link/map\n   *\n   * @param {Object} objToMap\n   * @memberof FlowchartHandler\n   */\n  setMap(objToMap: GFMap, prop: gf.TPropertieKey = 'id'): this {\n    const flowchart = this.getFlowchart(this.currentFlowchartName);\n    this.onMapping.active = true;\n    this.onMapping.object = objToMap;\n    this.onMapping.value = objToMap.getId();\n    this.onMapping.$scope = this.$scope;\n    this.onMapping.prop = prop;\n    flowchart.setMap(this.onMapping);\n    return this;\n  }\n\n  /**\n   * Desactivate option\n   *\n   * @memberof FlowchartHandler\n   */\n  unsetMap(): this {\n    const flowchart = this.getFlowchart(this.currentFlowchartName);\n    this.onMapping.active = false;\n    this.onMapping.object = undefined;\n    this.onMapping.value = '';\n    flowchart.unsetMap();\n    return this;\n  }\n\n  /**\n   * Return true if mapping object is active\n   *\n   * @param {properties} objToMap\n   * @returns true - true if mapping mode\n   * @memberof FlowchartHandler\n   */\n  isMapping(objToMap: GFMap): boolean {\n    if (objToMap === undefined || objToMap == null) {\n      return this.onMapping.active;\n    }\n    if (this.onMapping.active === true && objToMap === this.onMapping.object) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Wait for draw.io answer\n   *\n   * @private\n   * @param {MessageEvent} event\n   * @memberof FlowchartHandler\n   */\n  listenMessage(event: any) {\n    if (event.data !== undefined && event.data.length > 0 && event.data.substring(0, 3) === 'fc-') {\n      const id = event.data.substring(3);\n      const fc = this.getFlowchartById(id);\n      this.currentFlowchart = fc;\n      // send xml\n      // if (event.source) {\n      //   if (!(event.source instanceof MessagePort) && !(event.source instanceof ServiceWorker)) {\n      if (fc !== undefined) {\n        $GF.message.setMessage('Sending current data to draw.io editor', 'info');\n        event.source.postMessage(fc.data.xml, event.origin);\n        this.postedId = fc.id;\n      }\n      //   }\n      // }\n    } else {\n      if (\n        this.onEdit &&\n        event.data !== undefined &&\n        event.data.length > 0 &&\n        event.data.substring(0, 3) !== 'fc-' &&\n        this.currentFlowchart !== undefined\n      ) {\n        if (this.postedId !== undefined) {\n          const fc = this.getFlowchartById(this.postedId);\n          if (fc !== undefined) {\n            $GF.message.setMessage('Received data from draw.io editor, refresh in progress', 'info');\n            fc.redraw(event.data);\n            this.onSourceChange(fc.getName());\n            this.$scope.$apply();\n            this.render();\n          }\n        }\n      }\n      if ((this.onEdit && event.data !== undefined) || event.data.length === 0) {\n        if (this.editorWindow) {\n          this.editorWindow.close();\n        }\n        this.onEdit = false;\n        this.postedId = undefined;\n        window.removeEventListener('message', this.listenMessage.bind(this), false);\n        $GF.message.setMessage('Draw.io editor closed', 'info');\n      }\n    }\n  }\n\n  /**\n   * Open graph in draw.io\n   *\n   * @memberof FlowchartHandler\n   */\n  openDrawEditor(name?: string) {\n    const fc = this.getFlowchart(name);\n    const urlEditor = fc.getUrlEditor();\n    const theme = this.getFlowchart(name).getThemeEditor();\n    const urlParams = `${urlEditor}?embed=1&spin=1&libraries=1&ui=${theme}&ready=fc-${fc.id}&src=grafana`;\n    this.editorWindow = window.open(urlParams, 'MxGraph Editor', 'width=1280, height=720');\n    this.onEdit = true;\n    $GF.message.setMessage(`Opening current flowchart on draw.io editor`, 'info');\n    window.addEventListener('message', this.listenMessage.bind(this), false);\n  }\n\n  /**\n   * Get flowchart names\n   *\n   * @returns {string[]}\n   * @memberof FlowchartHandler\n   */\n  getFlowchartNames(): string[] {\n    return this.flowcharts.map(f => f.data.name);\n  }\n}\n","import grafana from './grafana_func';\nimport _ from 'lodash';\nimport { $GF } from 'globals_class';\n\n/**\n * Metric parent\n *\n * @export\n * @class Metric\n */\nexport class Metric {\n  type = 'unknow';\n  scopedVars: any;\n  metrics: any = {};\n  name = '';\n  nullPointMode = 'connected';\n  constructor(dataList: any) {}\n\n  /**\n   * Get name of metric\n   *\n   * @returns {string}\n   * @memberof Metric\n   */\n  getName(): string {\n    if (this.name === undefined || this.name === null) {\n      $GF.log.error('Metric => getName : Name is null');\n    }\n    return this.name;\n  }\n\n  /**\n   * Get value of metric for an aggregation\n   *\n   * @param {gf.TAggregationKeys} aggregator\n   * @param {string} [column]\n   * @returns {(string | number | null)}\n   * @memberof Metric\n   */\n  getValue(aggregator: gf.TAggregationKeys, column?: string): string | number | null {\n    return null;\n  }\n\n  findValue(timestamp: number, column?: string): string | number | null {\n    return null;\n  }\n\n  /**\n   * Return coordinates for graph {x:time,y:value}\n   *\n   * @param {string} [column]\n   * @returns {gf.TGraphCoordinate[]}\n   * @memberof Metric\n   */\n  getData(column?: string, log: boolean = false): number[] | Array<{ x: number | Date; y: number }> {\n    return [];\n  }\n\n  /**\n   * Return columns for this metric\n   *\n   * @returns {string[]}\n   * @memberof Metric\n   */\n  getColumnsName(): string[] {\n    return [];\n  }\n}\n\n/**\n * Serie data\n *\n * @export\n * @class Serie\n * @extends {Metric}\n */\n/**\n * Serie type for a metric\n *\n * @export\n * @class Serie\n * @extends {Metric}\n */\nexport class Serie extends Metric {\n  constructor(dataList: any) {\n    super(dataList);\n    this.type = 'serie';\n    this.metrics = this.seriesHandler(dataList);\n    this.addCustomStats();\n    this.name = this.metrics.alias;\n  }\n\n  seriesHandler(seriesData) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'seriesHandler()');\n    const series = grafana.getTimeSeries(seriesData);\n    series.flotpairs = series.getFlotPairs(this.nullPointMode);\n    trc.after();\n    return series;\n  }\n\n  addCustomStats() {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addCustomStats()');\n    try {\n      let lg = this.metrics.flotpairs.length;\n      // LAST TIME\n      this.metrics.stats['last_time'] = this.metrics.flotpairs[lg - 1][0];\n      // LAST\n      this.metrics.stats['current'] = this.metrics.flotpairs[lg - 1][1];\n      // LAST NOT NULL\n      this.metrics.stats['current_notnull'] = null;\n      let idx = lg - 1;\n      while ((this.metrics.flotpairs[idx][1] === null || this.metrics.flotpairs[idx][1] === undefined) && idx >= 0) {\n        idx -= 1;\n      }\n      if (idx >= 0) {\n        this.metrics.stats['current_notnull'] = this.metrics.flotpairs[idx][1];\n      }\n      // FIRST\n      this.metrics.stats['first'] = this.metrics.flotpairs[0][1];\n      // FIRST NOT NULL\n      this.metrics.stats['first_notnull'] = null;\n      idx = 0;\n      while ((this.metrics.flotpairs[idx][1] === null || this.metrics.flotpairs[idx][1] === undefined) && idx < lg) {\n        idx += 1;\n      }\n      if (idx < lg) {\n        this.metrics.stats['first_notnull'] = this.metrics.flotpairs[idx][1];\n      }\n    } catch (error) {\n      $GF.log.error('Unable to add custom stats', error);\n    }\n    trc.after();\n  }\n\n  /**\n   * Get value of serie for an aggregation\n   *\n   * @param {gf.TAggregationKeys} aggregator\n   * @param {string} [column]\n   * @returns {(string | number | null)}\n   * @memberof Metric\n   */\n  getValue(aggregator: gf.TAggregationKeys): string | number | null {\n    try {\n      let value: string | number | null = null;\n      if ($GF.hasGraphHover()) {\n        const timestamp = $GF.getGraphHover();\n        value = timestamp !== undefined ? this.findValue(timestamp) : null;\n      } else {\n        value = this.metrics.stats[aggregator];\n      }\n      return value;\n    } catch (error) {\n      $GF.log.error('datapoint for serie is null', error);\n      return null;\n    }\n  }\n\n  /**\n   * find a value by a timestamp\n   *\n   * @param {number} timestamp\n   * @returns {(string | number | null)}\n   * @memberof Serie\n   */\n  findValue(timestamp: number): string | number | null {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'findValue()');\n    let low = 0;\n    let high = this.metrics.flotpairs.length - 1;\n    let found = !(high > 0);\n    timestamp = Math.round(timestamp);\n    let value = null;\n    while (!found) {\n      let middle = low + Math.round((high - low) / 2);\n      if (this.metrics.flotpairs[middle][0] === timestamp) {\n        value = this.metrics.flotpairs[middle][1];\n        found = true;\n      }\n      if (!found && low < middle && middle < high) {\n        if (timestamp > this.metrics.flotpairs[middle][0]) {\n          low = middle;\n        }\n        if (timestamp < this.metrics.flotpairs[middle][0]) {\n          high = middle;\n        }\n      } else {\n        if (this.metrics.flotpairs[middle][0] > timestamp && middle >= 1) {\n          value = this.metrics.flotpairs[middle - 1][1];\n        } else {\n          value = this.metrics.flotpairs[middle][1];\n        }\n        found = true;\n      }\n    }\n    trc.after();\n    return value;\n  }\n\n  getData(column: string = '', log: boolean = false): number[] | Array<{ x: number | Date; y: number }> {\n    return this.metrics.flotpairs.map(d => {\n      if (!!log) {\n        return { x: d[0], y: Math.log10(d[1]) };\n      }\n      return { x: d[0], y: d[1] };\n    });\n  }\n\n  getColumnsName(): string[] {\n    //TODO: If multi column\n    return ['time', 'value'];\n  }\n}\n\n/**\n * Table data\n *\n * @export\n * @class Table\n * @extends {Metric}\n */\nexport class Table extends Metric {\n  tableColumnOptions: any = {};\n  tableColumn = '';\n  allIsNull = true;\n  allIsZero = true;\n  constructor(dataList: any) {\n    super(dataList);\n    this.type = 'table';\n    this.name = dataList.refId;\n    this.metrics = this.tableHandler(dataList);\n  }\n\n  tableHandler(tableData: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'tableHandler()');\n    const table: any = {\n      datapoints: [],\n      columnNames: {},\n      stats: {},\n    };\n\n    tableData.columns.forEach((column, columnIndex) => {\n      table.columnNames[columnIndex] = column.text;\n      if (column.text.toString().toLowerCase() === 'time') {\n        table.timeIndex = columnIndex;\n        table.timeColumn = column.text;\n      }\n    });\n\n    this.tableColumnOptions = table.columnNames;\n    if (!_.find(tableData.columns, ['text', this.tableColumn])) {\n      this.setTableColumnToSensibleDefault(tableData);\n    }\n\n    tableData.rows.forEach(row => {\n      const datapoint = {};\n      row.forEach((value, columnIndex) => {\n        const key = table.columnNames[columnIndex];\n        datapoint[key] = value;\n      });\n      table.datapoints.push(datapoint);\n    });\n    this.metrics.flotpairs = this.getFlotPairs(this.nullPointMode, table);\n    trc.after();\n    return table;\n  }\n\n  setTableColumnToSensibleDefault(tableData: any) {\n    if (tableData.columns.length === 1) {\n      this.tableColumn = tableData.columns[0].text;\n    } else {\n      this.tableColumn = _.find(tableData.columns, col => {\n        return col.type !== 'time';\n      }).text;\n    }\n  }\n\n  getFlotPairs(fillStyle: string, table: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'getFlotPairs()');\n    const result: any[] = [];\n    const ignoreNulls = fillStyle === 'connected';\n    const nullAsZero = fillStyle === 'null as zero';\n    table.allIsNull = true;\n    table.allIsZero = true;\n\n    for (const idx in table.columnNames) {\n      // let index = Number(idx);\n      // if (table.timeIndex !== undefined && table.timeIndex !== null && index === table.timeIndex) continue;\n      const currName = table.columnNames[idx];\n      table.stats[currName] = {};\n      table.stats[currName].name = currName;\n      table.stats[currName].total = 0;\n      table.stats[currName].max = -Number.MAX_VALUE;\n      table.stats[currName].min = Number.MAX_VALUE;\n      table.stats[currName].logmin = Number.MAX_VALUE;\n      table.stats[currName].avg = null;\n      table.stats[currName].current = null;\n      table.stats[currName].current_notnull = null;\n      table.stats[currName].first = null;\n      table.stats[currName].first_notnull = null;\n      table.stats[currName].delta = 0;\n      table.stats[currName].diff = null;\n      table.stats[currName].range = null;\n      table.stats[currName].timeStep = Number.MAX_VALUE;\n\n      let currentTime: any;\n      let currentValue: any;\n      let nonNulls = 0;\n      let previousTime;\n      let previousValue = 0;\n      let previousDeltaUp = true;\n\n      try {\n        for (let i = 0; i < table.datapoints.length; i++) {\n          if (table.timeColumn) {\n            currentTime = table.datapoints[i][table.timeColumn];\n          }\n          currentValue = table.datapoints[i][currName];\n\n          if (previousTime !== undefined) {\n            const timeStep = currentTime - previousTime;\n            if (timeStep < table.stats[currName].timeStep) {\n              table.stats[currName].timeStep = timeStep;\n            }\n          }\n          previousTime = currentTime;\n\n          if (currentValue === null) {\n            if (ignoreNulls) {\n              continue;\n            }\n            if (nullAsZero) {\n              currentValue = 0;\n            }\n          }\n\n          if (currentValue !== null) {\n            if (_.isNumber(currentValue)) {\n              table.stats[currName].total += currentValue;\n              this.allIsNull = false;\n              nonNulls++;\n            }\n\n            if (currentValue > table.stats[currName].max) {\n              table.stats[currName].max = currentValue;\n            }\n\n            if (currentValue < table.stats[currName].min) {\n              table.stats[currName].min = currentValue;\n            }\n\n            if (table.stats[currName].first === null) {\n              table.stats[currName].first = currentValue;\n            } else {\n              if (previousValue > currentValue) {\n                // counter reset\n                previousDeltaUp = false;\n                if (i === table.datapoints.length - 1) {\n                  // reset on last\n                  table.stats[currName].delta += currentValue;\n                }\n              } else {\n                if (previousDeltaUp) {\n                  table.stats[currName].delta += currentValue - previousValue; // normal increment\n                } else {\n                  table.stats[currName].delta += currentValue; // account for counter reset\n                }\n                previousDeltaUp = true;\n              }\n            }\n            previousValue = currentValue;\n\n            if (currentValue < table.stats[currName].logmin && currentValue > 0) {\n              table.stats[currName].logmin = currentValue;\n            }\n\n            if (currentValue !== 0) {\n              this.allIsZero = false;\n            }\n          }\n          result.push([currentTime, currentValue]);\n        }\n      } catch (error) {\n        $GF.log.error('Unable to aggregate data', error);\n      }\n\n      if (currentTime) {\n        table.stats[currName].last_time = currentTime;\n      }\n\n      if (table.stats[currName].max === -Number.MAX_VALUE) {\n        table.stats[currName].max = null;\n      }\n      if (table.stats[currName].min === Number.MAX_VALUE) {\n        table.stats[currName].min = null;\n      }\n\n      if (result.length && !this.allIsNull) {\n        table.stats[currName].avg = table.stats[currName].total / nonNulls;\n        table.stats[currName].current = result[result.length - 1][1];\n        if (table.stats[currName].current === null && result.length > 1) {\n          table.stats[currName].current = result[result.length - 2][1];\n        }\n      }\n      if (table.stats[currName].max !== null && table.stats[currName].min !== null) {\n        table.stats[currName].range = table.stats[currName].max - table.stats[currName].min;\n      }\n      if (table.stats[currName].current !== null && table.stats[currName].first !== null) {\n        table.stats[currName].diff = table.stats[currName].current - table.stats[currName].first;\n      }\n\n      table.stats[currName].count = result.length;\n    }\n    trc.after();\n    return result;\n  }\n\n  /**\n   * Get value of table for an aggregation\n   *\n   * @param {gf.TAggregationKeys} aggregator\n   * @param {string} [column]\n   * @returns {(string | number | null)}\n   * @memberof Metric\n   */\n  getValue(aggregator: gf.TAggregationKeys, column: string): string | number | null {\n    try {\n      let value: string | number | null = null;\n      if ($GF.hasGraphHover()) {\n        const timestamp = $GF.getGraphHover();\n        value = timestamp !== undefined ? this.findValue(timestamp, column) : null;\n      } else {\n        value = this.metrics.stats[column][aggregator];\n      }\n      return value;\n    } catch (error) {\n      $GF.log.error('datapoint for table is null', error);\n      return null;\n    }\n  }\n\n  /**\n   * find a value by a timestamp\n   *\n   * @param {number} timestamp\n   * @returns {(string | number | null)}\n   * @memberof Serie\n   */\n  findValue(timestamp: number, column: string): string | number | null {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'findValue()');\n    let low = 0;\n    let high = this.metrics.datapoints.length - 1;\n    let found = !(high > 0 && this.metrics.datapoints[low][this.metrics.timeColumn] < timestamp);\n    timestamp = Math.round(timestamp);\n    let value = null;\n    while (!found) {\n      let middle = low + Math.round((high - low) / 2);\n      if (this.metrics.datapoints[middle][this.metrics.timeColumn] === timestamp) {\n        value = this.metrics.datapoints[middle][column];\n        found = true;\n      }\n      if (!found && low < middle && middle < high) {\n        if (timestamp > this.metrics.datapoints[middle][this.metrics.timeColumn]) {\n          low = middle;\n        }\n        if (timestamp < this.metrics.datapoints[middle][this.metrics.timeColumn]) {\n          high = middle;\n        }\n      } else {\n        if (this.metrics.datapoints[middle][this.metrics.timeColumn] > timestamp && middle >= 1) {\n          value = this.metrics.datapoints[middle - 1][column];\n        } else {\n          value = this.metrics.datapoints[middle][column];\n        }\n        found = true;\n      }\n    }\n    trc.after();\n    return value;\n  }\n\n  /**\n   * Return the index of a column\n   *\n   * @param {string} column\n   * @returns {(number | null)}\n   * @memberof Table\n   */\n  getColumnIndex(column: string): number | null {\n    for (const idx in this.tableColumnOptions) {\n      if (column === this.tableColumnOptions[idx]) {\n        return Number(idx);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return name of columns\n   *\n   * @returns {string[]}\n   * @memberof Table\n   */\n  getColumnsName(): string[] {\n    const result: string[] = [];\n    for (const idx in this.tableColumnOptions) {\n      result.push(this.tableColumnOptions[idx]);\n    }\n    return result;\n  }\n\n  /**\n   * Return formated data for tooltips graph\n   *\n   * @param {string} column\n   * @returns {(number[] | Array<{ x: number | Date; y: number }>)}\n   * @memberof Table\n   */\n  getData(column: string): number[] | Array<{ x: number | Date; y: number }> {\n    if (this.metrics.timeColumn) {\n      return this.metrics.datapoints.map(d => {\n        return { x: d[this.metrics.timeColumn], y: d[column] };\n      });\n    }\n    return this.metrics.datapoints.map(d => d[column]);\n  }\n}\n","import _ from 'lodash';\nimport { Metric, Serie, Table } from './metric_class';\nimport { $GF } from 'globals_class';\n\n/**\n * Data Series/Tables handler\n *\n * @export\n * @class MetricHandler\n */\nexport class MetricHandler {\n  panel: any;\n  // $scope: ng.IScope;\n  tables: Table[] = [];\n  series: Serie[] = [];\n  metrics: Array<Serie | Table> = [];\n  // constructor($scope: ng.IScope) {\n  //   this.$scope = $scope;\n  // }\n  constructor() {}\n\n  /**\n   * Init data with dataList\n   *\n   * @param {any} dataList\n   * @memberof MetricHandler\n   */\n  initData(dataList: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'initData()');\n    this.tables = [];\n    this.series = [];\n    this.metrics = [];\n\n    dataList.forEach(dl => {\n      this.addMetric(dl);\n    });\n    trc.after();\n  }\n\n  /**\n   * Add/convert dataList to Metric\n   *\n   * @param {*} data\n   * @memberof MetricHandler\n   */\n  addMetric(data: any) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addMetric()');\n    if (data.type === 'table') {\n      this.addTable(data);\n    } else {\n      this.addSerie(data);\n    }\n    trc.after();\n  }\n\n  /**\n   * Convert and add dataList to a Metric Table\n   *\n   * @param {any} data\n   * @returns {Table}\n   * @memberof MetricHandler\n   */\n  addTable(data: any): Table {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addTable()');\n    const table = new Table(data);\n    this.tables.push(table);\n    this.metrics.push(table);\n    trc.after();\n    return table;\n  }\n\n  /**\n   * Convert and add dataList to a Metric Serie\n   *\n   * @param {any} data\n   * @returns {Serie}\n   * @memberof MetricHandler\n   */\n  addSerie(data: any): Serie {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'addSerie()');\n    const serie = new Serie(data);\n    this.series.push(serie);\n    this.metrics.push(serie);\n    trc.after();\n    return serie;\n  }\n\n  /**\n   * get Names of metrics (serie or table or both if type is undefined)\n   *\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {string[]}\n   * @memberof MetricHandler\n   */\n  getNames(type?: gf.TMetricTypeKeys): string[] {\n    let names: string[] = [];\n    if (type === 'serie') {\n      names = this.series.map(m => m.getName());\n    } else if (type === 'table') {\n      names = this.tables.map(m => m.getName());\n    } else {\n      names = this.metrics.map(m => m.getName());\n    }\n    // GFGlobal.log.debug('getNames', names);\n    return names;\n  }\n\n  /**\n   * get Metrics, series or tables or both if type is undefined\n   *\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {Metric[]}\n   * @memberof MetricHandler\n   */\n  getMetrics(type?: gf.TMetricTypeKeys): Metric[] {\n    if (type === 'serie') {\n      return this.series;\n    }\n    if (type === 'table') {\n      return this.tables;\n    }\n    return this.metrics;\n  }\n\n  /**\n   * Define if have tables or serie\n   *\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {boolean}\n   * @memberof MetricHandler\n   */\n  isTypeOf(type?: gf.TMetricTypeKeys): boolean {\n    if (type === 'serie') {\n      return this.series.length > 0;\n    }\n    if (type === 'table') {\n      return this.tables.length > 0;\n    }\n    return false;\n  }\n\n  /**\n   * Get metrics with this name Serie or table or both\n   *\n   * @param {string} name\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {Metric[]}\n   * @memberof MetricHandler\n   */\n  findMetrics(name: string, type?: gf.TMetricTypeKeys): Metric[] {\n    let metrics: Metric[] = [];\n    if (type) {\n      if (type === 'table') {\n        metrics = this.tables.filter(m => m.getName() === name);\n      }\n      if (type === 'serie') {\n        metrics = this.series.filter(m => m.getName() === name);\n      }\n    } else {\n      metrics = this.metrics.filter(m => m.getName() === name);\n    }\n    return metrics;\n  }\n\n  /**\n   * Get column name for a metric\n   *\n   * @param {string} metricName\n   * @param {gf.TMetricTypeKeys} [type]\n   * @returns {string[]}\n   * @memberof MetricHandler\n   */\n  getColumnsName(metricName: string, type?: gf.TMetricTypeKeys): string[] {\n    const metrics = this.findMetrics(metricName, type);\n    let columns: string[] = [];\n    metrics.forEach(m => {\n      columns = columns.concat(m.getColumnsName());\n    });\n    return columns;\n  }\n}\n","import { MetricsPanelCtrl } from 'grafana/app/plugins/sdk';\n// import { appEvents } from 'grafana/app/core/core';\nimport { mappingOptionsTab } from 'mapping_options';\nimport { flowchartOptionsTab } from 'flowchart_options';\nimport { inspectOptionsTab } from 'inspect_options';\nimport { RulesHandler } from 'rulesHandler';\nimport { FlowchartHandler } from 'flowchartHandler';\nimport { MetricHandler } from 'metricHandler';\n// import { PanelEvents } from '@grafana/data';\nimport { $GF } from 'globals_class';\nimport XGraph from 'graph_class';\nimport grafana from 'grafana_func';\nimport _ from 'lodash';\n\nclass FlowchartCtrl extends MetricsPanelCtrl {\n  $rootScope: any;\n  $scope: any;\n  templateSrv: any;\n  version: any;\n  changedSource: boolean;\n  changedData: boolean;\n  changedOptions: boolean;\n  rulesHandler: RulesHandler | undefined;\n  flowchartHandler: FlowchartHandler | undefined;\n  metricHandler: MetricHandler | undefined;\n  GHApplied = false;\n  panelDefaults: {\n    newFlag: boolean;\n    format: string;\n    valueName: string;\n    rulesData: gf.TIRulesHandlerData;\n    flowchartsData: gf.TFlowchartHandlerData;\n  };\n  containerDivId: string;\n  static templateUrl: string;\n  /**@ngInject*/\n  constructor($scope, $injector, $rootScope, templateSrv) {\n    super($scope, $injector);\n    $GF.init($scope, templateSrv, this.dashboard);\n    this.$rootScope = $rootScope;\n    this.$scope = $scope;\n    this.version = $GF.plugin.getVersion();\n    this.templateSrv = templateSrv;\n    this.changedSource = true;\n    this.changedData = true;\n    this.changedOptions = true;\n    this.rulesHandler = undefined;\n    this.flowchartHandler = undefined;\n    this.metricHandler = undefined;\n    this.panelDefaults = {\n      newFlag: true,\n      format: 'short',\n      valueName: 'current',\n      rulesData: RulesHandler.getDefaultData(),\n      flowchartsData: FlowchartHandler.getDefaultData(),\n    };\n\n    _.defaults(this.panel, this.panelDefaults);\n    this.panel.graphId = `flowchart_${this.panel.id}`;\n    this.containerDivId = `container_${this.panel.graphId}`;\n\n    // events\n    this.events.on(grafana.PanelEvents.render, this.onRender.bind(this));\n    this.events.on(grafana.PanelEvents.refresh, this.onRefresh.bind(this));\n    this.events.on(grafana.PanelEvents.dataReceived, this.onDataReceived.bind(this));\n    this.events.on(grafana.PanelEvents.dataError, this.onDataError.bind(this));\n    this.events.on(grafana.PanelEvents.dataSnapshotLoad, this.onDataReceived.bind(this));\n    this.events.on(grafana.PanelEvents.editModeInitialized, this.onInitEditMode.bind(this));\n    // this.events.on('init-panel-actions', this.onInitPanelActions.bind(this));\n    // this.events.on('template-variable-value-updated', this.onVarChanged.bind(this));\n    // grafana.PanelEvents.on('graph-hover', this.onGraphHover.bind(this), this.$scope);\n    // grafana.PanelEvents.on('graph-hover-clear', this.clearCrosshair.bind(this), this.$scope);\n    grafana.appEvents.on('graph-hover', this.onGraphHover.bind(this), this.$scope);\n    grafana.appEvents.on('graph-hover-clear', this.clearCrosshair.bind(this), this.$scope);\n    this.dashboard.events.on('template-variable-value-updated', this.onVarChanged.bind(this), $scope);\n    // if ($scope.$root.onAppEvent) {\n    //   $scope.$root.onAppEvent('template-variable-value-updated', this.onVarChanged.bind(this), $scope);\n    //   // $scope.$root.onAppEvent('graph-hover', this.onVarChanged.bind(this), $scope);\n    // }\n  }\n\n  //\n  // EVENTS FCT\n  //\n  onInitEditMode() {\n    this.addEditorTab('Flowchart', flowchartOptionsTab, 2);\n    this.addEditorTab('Mapping', mappingOptionsTab, 3);\n    this.addEditorTab('Inspect', inspectOptionsTab, 4);\n  }\n\n  onGraphHover(event: any) {\n    const self = this;\n    const flowchartHandler = this.flowchartHandler;\n    if (this.dashboard.sharedTooltipModeEnabled() && flowchartHandler !== undefined) {\n      const timestamp = event.pos.x;\n      const id = 'graph-hover';\n      $GF.clearUniqTimeOut(id);\n      const setGraphHover = () => {\n        $GF.setGraphHover(timestamp);\n        flowchartHandler.onGraphHoverChange();\n        self.render();\n        self.GHApplied = true;\n        $GF.clearUniqTimeOut(id);\n      };\n      $GF.setUniqTimeOut(setGraphHover, $GF.CONSTANTS.CONF_GRAPHHOVER_DELAY, id);\n    } else if (self.GHApplied) {\n      $GF.unsetGraphHover();\n    }\n  }\n\n  clearCrosshair(event: any) {\n    if (this.flowchartHandler !== undefined && this.GHApplied) {\n      const id = 'graph-hover';\n      this.GHApplied = false;\n      $GF.clearUniqTimeOut(id);\n      $GF.unsetGraphHover();\n      this.flowchartHandler.onGraphHoverChange();\n      this.render();\n    }\n  }\n\n  onRefresh() {\n    this.onRender();\n  }\n\n  onVarChanged() {\n    if (this.flowchartHandler !== undefined) {\n      this.flowchartHandler.onSourceChange();\n      this.flowchartHandler.render();\n    }\n  }\n\n  onRender() {}\n\n  onDataReceived(dataList) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'onDataReceived()');\n    if (!!this.metricHandler) {\n      this.metricHandler.initData(dataList);\n      if (!!this.flowchartHandler) {\n        this.flowchartHandler.onDatasChange();\n      }\n    }\n    this.render();\n    trc.after();\n    $GF.trace.resume();\n  }\n\n  onDataError() {\n    this.render();\n  }\n\n  // onInitPanelActions(actions) {\n  //   actions.push({\n  //     text: 'Export SVG',\n  //     click: 'ctrl.exportSVG()',\n  //   });\n  // }\n\n  //\n  // FUNCTIONS\n  //\n  link(scope, elem, attrs, ctrl) {\n    const trc = $GF.trace.before(this.constructor.name + '.' + 'link()');\n\n    // MxGraph Init\n    XGraph.initMxGraph();\n\n    // $GF Containers\n    const $section = elem.find('#flowcharting-section');\n    const parent = $section[0];\n    $GF.setMessageDiv(parent);\n\n    // DATA\n    this.metricHandler = new MetricHandler();\n\n    // RULES\n    const newRulesData = RulesHandler.getDefaultData();\n    this.rulesHandler = new RulesHandler(newRulesData);\n    // for version < 0.4.0\n    if (this.panel.version === undefined && this.panel.styles !== undefined) {\n      this.rulesHandler.import(this.panel.styles);\n      delete this.panel.styles;\n    } else {\n      this.rulesHandler.import(this.panel.rulesData);\n    }\n    if (this.panel.newFlag && this.rulesHandler.countRules() === 0) {\n      this.rulesHandler.addRule('.*');\n    }\n    this.panel.rulesData = newRulesData;\n\n    // FLOWCHART\n    const newFlowchartsData = FlowchartHandler.getDefaultData();\n    this.flowchartHandler = new FlowchartHandler(scope, elem, ctrl, newFlowchartsData);\n    // for version < 0.4.0\n    if (this.panel.version === undefined && this.panel.flowchart !== undefined) {\n      this.flowchartHandler.import([this.panel.flowchart]);\n      delete this.panel.flowchart;\n    } else {\n      this.flowchartHandler.import(this.panel.flowchartsData);\n    }\n    if (this.panel.newFlag && this.flowchartHandler.countFlowcharts() === 0) {\n      this.flowchartHandler.addFlowchart('Main');\n    }\n    this.panel.flowchartsData = newFlowchartsData;\n\n    // Position to main flowchart\n    // this.flowchartHandler.setCurrentFlowchart('Main');\n\n    // Versions\n    this.panel.newFlag = false;\n    this.panel.version = this.version;\n    trc.after();\n  }\n\n  // exportSVG() {\n  //   const scope = this.$scope.$new(true);\n  //   scope.panel = 'table';\n  //   this.publishAppEvent('show-modal', {\n  //     templateHtml: '<export-data-modal panel=\"panel\" data=\"tableData\"></export-data-modal>',\n  //     scope,\n  //     modalClass: 'modal--narrow',\n  //   });\n  // }\n\n  // setUnitFormat(subItem) {\n  //   this.panel.format = subItem.value;\n  //   this.refresh();\n  // }\n\n  // getVariables() {\n  //   if (this.templateSrv !== undefined && this.templateSrv !== null) {\n  //     return _.map(this.templateSrv.variables, variable => `\\${${variable.name}}`);\n  //   }\n  //   return null;\n  // }\n\n  $onDestroy() {\n    $GF.destroy();\n  }\n}\n\nexport { FlowchartCtrl, FlowchartCtrl as MetricsPanelCtrl };\n\nFlowchartCtrl.templateUrl = './partials/module.html';\n","import { FlowchartCtrl } from './flowchart_ctrl';\nimport grafana from './grafana_func';\n\ngrafana.loadCss();\n\nexport { FlowchartCtrl as PanelCtrl };\n"],"sourceRoot":""}